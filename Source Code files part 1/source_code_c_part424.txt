 this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return iterator(_BaseHashTable::Begin());
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end()
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return iterator(_BaseHashTable::End());
    }

    template <class _InputIterator>
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        _InputIterator f,                     // first element in range
        _InputIterator l,                     // one-beyond-last element
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                         _AddRefRecord, maxload, initsize, num_subtbls,
                         fMultiKeys)
    {
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return _BaseHashTable::Insert(pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return _BaseHashTable::Erase(riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return _BaseHashTable::Erase(riterFirst.m_iter, riterLast.m_iter);
    }

    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>(key);
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::Find(pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>(key);
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::EqualRange(pnKey, riterFirst.m_iter,
                                          riterLast.m_iter);
    }

    // The iterator functions for an STL hash_(|multi)_(set|map)
    //
    // Value type of a Pair-Associative Container is
    //     pair<const key_type, mapped_type>
    //
    // pair<iterator,bool> insert(const value_type& x);
    //
    // void erase(iterator pos);
    // void erase(iterator f, iterator l);
    //
    // iterator find(const key_type& k) [const];
    // const_iterator find(const key_type& k) const;
    //
    // pair<iterator,iterator> equal_range(const key_type& k) [const];
    // pair<const_iterator,const_iterator> equal_range(const key_type& k) const


#endif // LKR_STL_ITERATORS
};



#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__


#endif // __LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\hashfn.h ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


#define __HASHFN_NO_NAMESPACE__

#ifndef __HASHFN_NO_NAMESPACE__
namespace HashFn {
#endif // !__HASHFN_NO_NAMESPACE__

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Faster scrambling function suggested by Eric Jacobsen

inline DWORD
HashRandomizeBits(DWORD dw)
{
	return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}


// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRhash.

inline DWORD
HashString(
    const char* psz,
    DWORD       dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

inline DWORD
HashString(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

inline DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           HASH_MULTIPLIER * Hash(rFoo.m_ch)
//                               +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKRhash.

inline DWORD
HashBlob(
    const void* pv,
    size_t      cb,
    DWORD       dwHash = 0)
{
    LPBYTE pb = static_cast<LPBYTE>(const_cast<void*>(pv));

    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashScramble to result if using with something other than
// LKRhash.
//

inline DWORD Hash(const char* psz)
{ return HashString(psz); }

inline DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

inline DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

inline DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

inline DWORD
Hash(
    const GUID* pguid,
    DWORD       dwHash = 0)
{
    
    return * reinterpret_cast<DWORD*>(const_cast<GUID*>(pguid)) + dwHash;
}

// Identity hash functions: scalar values map to themselves
inline DWORD Hash(char c)
{ return c; }

inline DWORD Hash(unsigned char uc)
{ return uc; }

inline DWORD Hash(signed char sc)
{ return sc; }

inline DWORD Hash(short sh)
{ return sh; }

inline DWORD Hash(unsigned short ush)
{ return ush; }

inline DWORD Hash(int i)
{ return i; }

inline DWORD Hash(unsigned int u)
{ return u; }

inline DWORD Hash(long l)
{ return l; }

inline DWORD Hash(unsigned long ul)
{ return ul; }

inline DWORD Hash(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        DWORD dw;
    } u;
    u.f = f;
    return u.dw;
}

inline DWORD Hash(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        DWORD  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * HASH_MULTIPLIER  +  u.dw[1];
}

#ifndef __HASHFN_NO_NAMESPACE__
}
#endif // !__HASHFN_NO_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\nexus.h ===
#ifndef __NEXUS_H
#define __NEXUS_H

#include <msxml.h>

#if defined(UNICODE) || defined(_UNICODE)
#define CCDUpdated CCDUpdatedW
#else
#define CCDUpdated CCDUpdatedA
#endif

class ICCDUpdate
{
public:
    virtual void CCDUpdatedA(LPCSTR  pszCCDName, IXMLDocument* piXMLDocument) = 0;
    virtual void CCDUpdatedW(LPCWSTR pszCCDName, IXMLDocument* piXMLDocument) = 0;
};

class IConfigurationUpdate
{
public:
    virtual void LocalConfigurationUpdated(void) = 0;
};


#ifdef __cplusplus
extern "C" {
#endif

HANDLE WINAPI
RegisterCCDUpdateNotification(
    LPCTSTR     pszCCDName,
    ICCDUpdate* piCCDUpdate
    );

BOOL WINAPI
UnregisterCCDUpdateNotification(
    HANDLE  hNotificationHandle
    );

HANDLE WINAPI
RegisterConfigChangeNotification(
    IConfigurationUpdate*   piConfigUpdate
    );

BOOL WINAPI
UnregisterConfigChangeNotification(
    HANDLE  hNotificationHandle
    );

BOOL WINAPI
GetCCD(
    LPCTSTR         pszCCDName,
    IXMLDocument**  ppiStream,
    BOOL            bForceFetch
    );


#ifdef __cplusplus
}
#endif

#endif // __NEXUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\lstentry.h ===
/*++

   Copyright    (c)    1999-2002    Microsoft Corporation

   Module  Name :
       lstentry.h

   Abstract:
       Declares CListEntry and other intrusive singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <locks.h>
#endif // !__LOCKS_H__

// TODO:
// * Add STL-style iterators: begin(), end(), operator++(), etc
// * Templatize the lists, so that you can avoid the CONTAINING_RECORD goo

//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    CSpinLock   m_lock;
    CSingleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    CSpinLock   m_lock;
    CDoubleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\pmerrorcodes.h ===
#ifndef __ERRORCODES_H_
#define __ERRORCODES_H_


#define PP_E_NOT_CONFIGURED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define PP_E_NOT_CONFIGUREDSTR  L"PassportManager misconfigured"

#define PP_E_NO_SUCH_ATTRIBUTE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define PP_E_NO_SUCH_ATTRIBUTESTR L"Profile.Attribute: No such attribute."
#define PP_E_NSA_BADMID           L"Profile.Update: Schema has bad memberId fields, cannot update."
#define PP_E_BAD_DATA_FORMAT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define PP_E_BAD_DATA_FORMATSTR L"Invalid profile data format"
#define PP_E_BDF_TOSTRCVT          L"Profile.ByIndex: Couldn't convert value to string."
#define PP_E_BDF_TOBYTECVT         L"Profile.ByIndex: Couldn't convert value to byte."
#define PP_E_BDF_TOSHORTCVT        L"Profile.ByIndex: Couldn't convert value to short."
#define PP_E_BDF_TOINTCVT          L"Profile.ByIndex: Couldn't convert value to integer."
#define PP_E_BDF_STRTOLG           L"Profile.ByIndex: Data too large."
#define PP_E_BDF_NONULL            L"Profile.ByIndex: Can't set null value."
#define PP_E_BDF_CANTSET           L"Can't set that profile field"

#define PP_E_READONLY_ATTRIBUTE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define PP_E_READONLY_ATTRIBUTESTR L"Profile.ByIndex: That attribute is read only."

#define PP_E_INVALID_TICKET     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define PP_E_INVALID_TICKETSTR  L"Passport: cannot ask for properties of invalid auth ticket"
#define PP_E_IT_FOR_HASFLAGSTR  L"Can't call HasFlag: no valid Passport user"
#define PP_E_IT_FOR_COMMITSTR   L"PassportManager.Commit can't be used w/o a valid member."

#define PP_E_INVALID_TIMEWINDOW MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define PP_E_INVALID_TIMEWINDOWSTR L"TimeWindow invalid.  Must be between 20 and 2,678,400"

#define PP_E_LOGOUTURL_NOTDEFINED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define PP_E_LOGOUTURL_NOTDEFINEDSTR L"Logout URL is not defined. Check partner.xml file."

#define PP_E_GETFLAGS_OBSOLETESTR L"HasFlags is now obsolete, please use the Error property."

#define PP_E_HTTP_BODY_REQUIRED   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)
#define PP_E_HTTP_BODY_REQUIREDSTR  L"HTTP body is required."

#define PP_E_NO_ATTRIBUTE   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0208)
#define PP_E_NO_ATTRIBUTESTR   L"No such attribute."

#define PP_E_UNABLE_TO_ENCRYPT MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0209)
#define PP_E_UNABLE_TO_ENCRYPTSTR L"Unable to encrypt.  Out of memory is a likely cause."


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\passporttypes.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportTypes.h

    Abstract:

        Header file for brokers and hubs
--*/
#ifndef _PASSPORT_TYPES_H
#define _PASSPORT_TYPES_H

// Max user entry length
#define MAX_MEMBER_PROFILE_LEN      1024

// Field Lengths
#define MAX_MEMBERNAME_LEN   128
#define MAX_CONTACTEMAIL_LEN 128
#define MAX_PASSWORD_LEN     128
#define MAX_POSTALCODE_LEN   64
#define MAX_MEMBERID_LEN     32
#define MAX_MSNGUID_LEN      32
#define MAX_ALIAS_LEN        48
#define MAX_SESSIONKEY_LEN   36 
#define MAX_PROFILEBLOB_LEN  596   // this will be changing as Profile Schema changes...
                                   // we probably should be doing things like this.... 
#define MAX_CACHEKEY_LEN     145

#define PPM_TIMEWINDOW_MIN   20
#define PPM_TIMEWINDOW_MAX   (31 * 24 * 60 * 60 )	// 31 days timewindow

// Gender can be 'M', 'F', or 'U'
typedef char GENDER;

#define MALE 'M'
#define FEMALE 'F'
#define UNSPECIFIED 'U'

// Network Errors
#ifndef NETWORK_ERRORS_DEFINED
#define NETWORK_ERRORS_DEFINED

#define BAD_REQUEST  1
#define OFFLINE      2
#define TIMEOUT      3
#define LOCKED       4
#define NO_PROFILE   5
#define DISASTER     6
#define INVALID_KEY  7

#endif

#define SECURE_FLAG L' '

// Language codes
// English 
#define LANG_EN 0x0409
// German 
#define LANG_DE 0x0407
// Japanese 
#define LANG_JA 0x0411
// Korean 
#define LANG_KO 0x0412
// Traditional Chinese 
#define LANG_TW 0x0404
// Simplified Chinese 
#define LANG_CN 0x804
// French 
#define LANG_FR 0x40c
// Spanish 
#define LANG_ES 0xc0a
// Brazilian 
#define LANG_BR 0x416
// Italian 
#define LANG_IT 0x410
// Dutch 
#define LANG_NL 0x413
// Swedish 
#define LANG_SV 0x41d
// Danish 
#define LANG_DA 0x406
// Finnish 
#define LANG_FI 0x40b
// Hungarian 
#define LANG_HU 0x40e
// Norwegian 
#define LANG_NO 0x414
// Greek 
#define LANG_EL 0x408
// Polish 
#define LANG_PL 0x415
// Russian 
#define LANG_RU 0x419
// Czech 
#define LANG_CZ 0x405
// Portuguese 
#define LANG_PT 0x816
// Turkish 
#define LANG_TR 0x41f
// Slovak 
#define LANG_SK 0x41b
// Slovenian 
#define LANG_SL 0x424
// Arabic 
#define LANG_AR 0x401
// Hebrew 
#define LANG_HE 0x40d

//
//  HRESULTs specific to passport interfaces.
//

#define PP_E_INVALID_MEMBERNAME     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1001)
#define PP_E_INVALID_DOMAIN         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1002)
#define PP_E_ATTRIBUTE_UNDEFINED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1003)
#define PP_E_SYSTEM_UNAVAILABLE     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1004)
#define PP_E_DOMAIN_MAP_UNAVAILABLE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1005)
#define PP_E_NO_LOCALFILE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1006)
#define PP_E_CCD_INVALID            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1007)
#define PP_E_SITE_NOT_EXISTS        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1008)
#define PP_E_SITE_NOT_EXISTSSTR     L"Site doesn't exist"
#define PP_E_NOT_INITIALIZED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1009)
#define PP_E_NOT_INITIALIZEDSTR        L"Manager object is not initialized"
#define PP_E_TYPE_NOT_SUPPORTED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100a)
#define PP_E_TYPE_NOT_SUPPORTEDSTR  L"Type not supported"

#include "PMErrorCodes.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\pptrace.h ===
/**************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pptrace.h 

Abstract:

    Event tracing header file

Author:

    Naiyi Jiang

Revision History:

***************************************************************/

#pragma once

#pragma warning(disable:4786)
#include <sstream> // use ostringstream

#define MAXSTR 4096
#define MAXNAME 512

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgPtr) ( (CHAR*)(ArgPtr) != (CHAR*)(NULL) )
#endif

#define TRACE_STRINGA(p)	((LPCSTR)(p) != NULL) ? (LPCSTR)(p) : ""

// Macros that allow the file name and line number to be passed in as a string.
#ifndef FILE_AND_LINE
#define LineNumAsString(x)	#x
#define LineNum(x)			LineNumAsString(x)
#define FILE_AND_LINE		__FILE__"_"LineNum(__LINE__)
#endif

// Use these macros in your components
#define PPTracePrint		if (PPTraceStatus::TraceOnFlag) TracePrint
#define PPTracePrintBlob    if (PPTraceStatus::TraceOnFlag) TracePrintBlob
#define PPTracePrintString  if (PPTraceStatus::TraceOnFlag) TracePrintString
#define PPTraceFunc			CTraceFunc
#define PPTraceFuncV		CTraceFuncVoid

// Use these macros to supply level and szFileAndName argument
// Additional levels (upto 255) can be defined
#define PPTRACE_ERR		0, FILE_AND_LINE
#define PPTRACE_RAW		1, FILE_AND_LINE
#define PPTRACE_FUNC	2, FILE_AND_LINE
#define PPTRACE_VERB	3, FILE_AND_LINE


// Use PPInitTrace/PPEndTrace at the entry/exit points of a component
ULONG PPInitTrace(LPGUID pControlGuid);
ULONG PPEndTrace();

// stop all traces
ULONG PPStopTrace();


namespace PPTraceStatus {
	extern bool TraceOnFlag;
	extern UCHAR EnableLevel;
	extern ULONG EnableFlags;
}

//
// Don't use the following functions and class names directly
// Use them via above macros
//
VOID TracePrint(UCHAR Level, LPCSTR szFileAndLine, LPCSTR ParameterList OPTIONAL, ...);
VOID TracePrintBlob(UCHAR Level, LPCSTR szFileAndLine, LPCSTR szDesc, LPBYTE pBlob, DWORD cSize, BOOL bUnderscore = FALSE);
VOID TracePrintString(
    UCHAR  Level,			//@parm log if current logging level is at least this
    LPCSTR szFileAndLine, 	//@parm ignored
    LPCSTR szContext,		//@parm	which function is this called from
    LPCSTR szBuf		    //@parm the string itself
);

ULONG TraceString(UCHAR Level, IN LPCSTR szBuf); 
ULONG TraceString(UCHAR Level, IN LPCWSTR wszBuf); 
ULONG64 GetTraceHandle();
void SetTraceHandle(ULONG64 TraceHandle);

///////////////////////////////////////////////////////////////////////////
// CTraceFunc
// Generate trace events for functions with type T return value
///////////////////////////////////////////////////////////////////////////
template <class T> class CTraceFunc  
{
public:
	CTraceFunc(UCHAR Level, LPCSTR szFileAndLine, T & ret, LPCSTR szFuncName, LPCSTR ParameterList = NULL, ...) : m_Level(Level), m_ret(ret)
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;

		strncpy(m_szFuncName, szFuncName, MAXNAME-1);

		CHAR buf[MAXSTR];
    
		int len = _snprintf(buf, MAXSTR-1, "+%s(", m_szFuncName);
		int count = 0;
		if (ARGUMENT_PRESENT(ParameterList)) {
				va_list parms;
				va_start(parms, ParameterList);
				count = _vsnprintf(buf+len, MAXSTR-len-1, (CHAR*)ParameterList, parms);
				len = (count > 0) ? len + count : MAXSTR - 1;
				va_end(parms);
		}
		if (len < (MAXSTR - 1))
		{
			CHAR* pStr = strrchr(szFileAndLine, '\\');
			if (pStr)
			{
				pStr++; //remove '\'
				_snprintf(buf+len, MAXSTR-len-1, ")@%s", pStr);
			}
		}

		TraceString(m_Level, buf); 
	};

	virtual ~CTraceFunc()
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;
		
		std::ostringstream ost;
        ost.flags(std::ios::hex);
		ost << "-" << m_szFuncName << "=0x" << m_ret;  
		TraceString(m_Level, ost.str().c_str()); 
	};

private:
	UCHAR m_Level;
	T &m_ret;
	CHAR m_szFuncName[MAXNAME];
};

// class to trace void type function
class CTraceFuncVoid  
{
public:
	CTraceFuncVoid(UCHAR Level, LPCSTR szFileAndLine, LPCSTR szFuncName, LPCSTR ParameterList = NULL, ...);
	virtual ~CTraceFuncVoid();

private:
	UCHAR m_Level;
	CHAR m_szFuncName[MAXNAME];
};

//
// old tracing stuff - only XMLUtilities project is still using them
//
#define TRACE_FLOW_ALL  0
#define TRACE_WARN_ALL  0
#define TRACE_ERR_ALL   0

// category flag (define your own!)
#define TRACE_TAG_REG   0x00000001
#define TRACE_TAG_foo1  0x00000002
#define TRACE_TAG_foo2  0x00000004

// level
#define TRACE_INFO      0x10000000
#define TRACE_WARN      0x20000000
#define TRACE_ERR       0x40000000

typedef enum {
    None,
    Bool,
    Int,
    Dword,
    HResult,
    String,
    WString,
    Pointer
} TRACE_FUNCTION_RETURN_TYPE;


VOID
PPInitTrace(LPWSTR wszAppName);


VOID
PPFuncEnter(
    DWORD Category,
    LPCSTR Function,
    LPCSTR ParameterList OPTIONAL,
    ...
    );

VOID
PPFuncLeave(
    IN DWORD Category,
    IN TRACE_FUNCTION_RETURN_TYPE ReturnType,
    IN DWORD_PTR Variable,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    ...
    );

VOID
PPTrace(
    DWORD Category,
    DWORD Level,
    LPCSTR ParameterList OPTIONAL,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\nsconst.h ===
//-----------------------------------------------------------------------------
//
//  @doc
//
//  @module nsconst.h | global constants used in Passport network
//
//  Author: Darren Anderson
//          Steve Fu
//
//  Date:   7/24/2000
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//-----------------------------------------------------------------------------

#pragma once

/* use external linkage to avoid mulitple instances */
#define PPCONST __declspec(selectany) extern const 

// ticket attrubute names
#define  ATTR_PASSPORTFLAGS  L"PassportFlags"
#define  ATTR_SECURELEVEL    L"CredInfo"
#define  ATTR_PINTIME        L"PinTime"
#define  SecureLevelFromSecProp(s)  (s & 0x000000ff)


//
//  Flags
//

PPCONST ULONG  k_ulFlagsEmailValidated        = 0x00000001;
PPCONST ULONG  k_ulFlagsHotmailAcctActivated  = 0x00000002;
PPCONST ULONG  k_ulFlagsHotmailPwdRecovered   = 0x00000004;
PPCONST ULONG  k_ulFlagsWalletUploadAllowed   = 0x00000008;
PPCONST ULONG  k_ulFlagsHotmailAcctBlocked    = 0x00000010;
PPCONST ULONG  k_ulFlagsConsentStatusNone     = 0x00000000;
PPCONST ULONG  k_ulFlagsConsentStatusLimited  = 0x00000020;
PPCONST ULONG  k_ulFlagsConsentStatusFull     = 0x00000040;
PPCONST ULONG  k_ulFlagsConsentStatus         = 0x00000060; // two bits
PPCONST ULONG  k_ulFlagsAccountTypeKid        = 0x00000080;
PPCONST ULONG  k_ulFlagsAccountTypeParent     = 0x00000100;
PPCONST ULONG  k_ulFlagsAccountType           = 0x00000180; // two bits
PPCONST ULONG  k_ulFlagsEmailPassport         = 0x00000200;
PPCONST ULONG  k_ulFlagsEmailPassportValid    = 0x00000400;
PPCONST ULONG  k_ulFlagsHasMsniaAccount       = 0x00000800;
PPCONST ULONG  k_ulFlagsHasMobileAccount      = 0x00001000;
PPCONST ULONG  k_ulFlagsSecuredTransportedTicket      = 0x00002000;
PPCONST ULONG  k_ulFlagsConsentCookieNeeded   = 0x80000000;
PPCONST ULONG  k_ulFlagsConsentCookieMask     = (k_ulFlagsConsentStatus | k_ulFlagsAccountType);

//
//  Cookie values.
//
#define  EXPIRE_FUTURE  "Wed, 30-Dec-2037 16:00:00 GMT"
#define  EXPIRE_PAST    "Thu, 30-Oct-1980 16:00:00 GMT"

#define  COOKIE_EXPIRES(n)  ("expires=" ## n ## ";")
// change string to unicode
#define  __WIDECHAR__(n)   L ## n
#define  W_COOKIE_EXPIRES(n)  L"expires=" ## __WIDECHAR__(n) ## L";"


//
//  secure signin levels
//
PPCONST USHORT k_iSeclevelAny                =   0;
PPCONST USHORT k_iSeclevelSecureChannel      =   10;
PPCONST USHORT k_iSeclevelStrongCreds        =   100;
PPCONST USHORT k_iSeclevelStrongestAvaileble =   0xFF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\ptstl.h ===
#ifndef __PPT_ALLOCATOR_
#define __PPT_ALLOCATOR_

#include <memory>


/**************************************************************************
 *  Template name: heap_allocator
 *
 *  Purpose: Allocator class to handle STL allocations
 *
 */
template<class _Ty>
class PtHeap_allocator : public std::allocator<_Ty>
{
public:
   PtHeap_allocator()
   {
      __hHeap = GetProcessHeap();
   };
   pointer allocate(size_type _N, const void *)
        {return (pointer) _Charalloc(_N * sizeof(_Ty)); }

   char* _Charalloc(size_type _N)
        {return (char*) HeapAlloc(__hHeap, 0, _N); }

   void deallocate(void* _P, size_type)
        {HeapFree(__hHeap, 0, _P); }
private:
   HANDLE   __hHeap;
};




// Defines strings that use the above allocator to that the DMI heap stuff is used.
#include <string>
#include <queue>

typedef std::basic_string<CHAR, std::char_traits<CHAR>, PtHeap_allocator<CHAR> > PtStlString;
typedef std::basic_string<WCHAR, std::char_traits<WCHAR>, PtHeap_allocator<WCHAR> > PtStlWstring;
#if   0// uses new allocator
template<class Key, class T, class Pred = less<Key> > 
class PtStlMap : public std::map<Key, T, Pred, PtHeap_allocator<T> >{};
template<class T> 
class PtStlQueue : public std::queue<T, deque<T, PtHeap_allocator<T> > > {};
#else
template<class Key, class T, class Pred = less<Key> > 
class PtStlMap : public std::map<Key, T, Pred, std::allocator<T> >{};
template<class T> 
class PtStlQueue : public std::queue<T, deque<T, std::allocator<T> > > {};
#endif
#endif // __PPT_ALLOCATOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\smartcls.h ===
// tempary sub string class
#ifndef __PP_SMART_CLASSES__
#define __PP_SMART_CLASSES__
struct TempSubStr
{
   TempSubStr(LPCSTR p = NULL, DWORD l = 0):
      m_p(p), m_l(l), m_tempChar(0)
      {
         Set(p, l);
      };
   void Set(LPCSTR p, DWORD l)
   {
      if(!p || !l)   return;
      m_p = p;
      m_l = l;
      LPSTR t = (LPSTR)(p + l);
      m_tempChar = *t;
      *(t) = 0;
   };

   ~TempSubStr()
   {
      if(!m_p || !m_l)  return;
      LPSTR t = (LPSTR)(m_p + m_l);
      *(t) = m_tempChar;
   };

   LPCSTR   m_p;
   DWORD    m_l;
   char     m_tempChar;
};

#endif  // #ifndef __PP_SMART_CLASSES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\profileschema.h ===
#ifndef _PROFILE_SCHEMA_H
#define _PROFILE_SCHEMA_H

#include "BstrHash.h"

#ifndef __no_msxml_dll_import__
#import <msxml.tlb> rename_namespace("MSXML")
#endif

typedef CRawCIBstrHash<int> RAWBSTR2INT;

#define	INVALID_POS	(UINT)(-1)
#define	FULL_SCHEMA (DWORD)(-1)

class CProfileSchema
{
 public:
  // Read the raw blob according to the schema, and output the positions of
  // each element.  Output array size MUST be >= Count()
  HRESULT parseProfile(LPSTR raw, UINT size, UINT* positions, UINT* bitFlagPositions, DWORD* pdwAttrs);

  enum AttrType {
    tText=0,
    tChar,
    tByte,
    tWord,
    tLong,
    tDate,
    tInvalid
  };

  CProfileSchema();
  ~CProfileSchema();

  BOOL    isOk() const { return m_isOk; }
  _bstr_t getErrorInfo() const { return m_szReason; }
  
  long GetAgeSeconds() const;

#ifndef __no_msxml_dll_import__
  BOOL Read(MSXML::IXMLElementPtr &root);
#endif  
  BOOL ReadFromArray(UINT numAttributes, LPTSTR names[], AttrType types[], short sizes[], BYTE readOnly[] = NULL);
  int         m_maskPos;

  // Number of attributes
  int     Count() const { return m_numAtts; }

  // Find the index by name
  int     GetIndexByName(BSTR name) const;
  BSTR    GetNameByIndex(int index) const;

  // Get the type of an attribute
  AttrType GetType(UINT index) const;

  // Can I write to this attribute?
  BOOL    IsReadOnly(UINT index) const;

  // Get the inherent size of an attribute
  // Returns -1 if the type is length prefixed
  int     GetBitSize(UINT index) const;
  int     GetByteSize(UINT index) const;

  CProfileSchema* AddRef();
  void Release();

 protected:
  long      m_refs;

  BOOL      m_isOk;
  _bstr_t   m_szReason;

  // Valid until this time
  SYSTEMTIME m_validUntil;

  // Array of attribute types
  UINT        m_numAtts;
  AttrType    *m_atts;
  short       *m_sizes;
  BYTE        *m_readOnly;
  RAWBSTR2INT  m_indexes;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\pperr.h ===
#pragma once
//-----------------------------------------------------------------------------
//
//  File:   pperr.h
//
//  Passport error code definitions.
//
//-----------------------------------------------------------------------------
#include <winerror.h>
// General errors

#define     PP_E_COMFAIL                                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1000)
#define     PP_E_ERRORCODE                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1001)
#define     PP_E_TOOMANYREQUESTS                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1002)
#define     PP_E_SVC_NOT_CONFIGURED                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1003)
#define     PP_E_NEEDSBIRTHDATE                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1004)
#define     PP_E_MD5SILENTNOCONSENT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1005)
#define     PP_E_MD5SILENTNEEDPARENT                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1006)
#define     PP_E_PROFILENOTEXIST                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1007)
#define     PP_E_TICKETEXPIRED                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1008)
#define     PP_E_TICKETNOTEXIST                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1009)
#define     PP_E_SECTICKETNOTEXIST                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100A)
#define     PP_E_SECTICKETNOTMATCH                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100B)
#define     PP_E_FORCESIGNIN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100C)
#define     PP_E_KPPVCMISSING                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100D)
#define     PP_E_KPPVCINVALID                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100E)
#define     PP_E_KPPNONKIDSITE                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x100F)
#define     PP_E_EXCLUDED                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1010)
#define     PP_E_MEMBER_LOCKED                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1011)
#define     PP_E_BAD_PASSWORD                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1012)
#define     PP_E_KIDNPP                                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1014)
#define     PP_E_KIDSPASSPORTURL                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1015)
#define     PP_E_NOT_OVER_SSL                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1016)
#define     PP_E_INVALIDKPP                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1017)
#define     PP_E_INVALIDSITEID                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1018)
#define     PP_E_INVALIDMEMBERNAME                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1019)
#define     PP_E_INVALIDRETURNURL                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101A)
#define     PP_E_INVALIDKEYVERSION                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101B)
#define     PP_E_INVALIDREQUEST                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101C)
#define     PP_E_INVALIDPARAMS                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101D)
#define     PP_E_NOCREDENTIALS                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101E)
#define     PP_E_NOAUTH                                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x101F)
#define     PP_E_NO_SL                                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1020)
#define     PP_E_NO_ALIAS_NO_PASSWORD                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1021)
#define     PP_E_NO_ALIAS                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1022)
#define     PP_E_NO_PASSWORD                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1023)
#define     PP_E_NO_DOMAIN                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1024)
#define     PP_E_NO_CHALLENGE                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1025)
#define     PP_E_INVALIDMODE                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1026)
#define     PP_E_USER_BAD_LOGIN                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1027)
#define     PP_E_SAME_USER_BAD_LOGIN                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1028)
#define     PP_E_DIFFERENT_USER                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1029)
#define     PP_E_WRONG_CREDENTIALS                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102A)
#define     PP_E_WRONG_MODE                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102B)
#define     PP_E_BROWSERINCAPABLE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102C)
#define     PP_E_BROWSERCOOKIEDISABLED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102D)
#define     PP_E_CRED_INPUT_TOO_LONG                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102E)
#define     PP_E_NOT_EMAIL_INPUT                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x102F)
#define     PP_E_MISSING_CREDS                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1030)
#define     PP_E_MISSING_MEMBERNAME                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1031)
#define     PP_E_MISSING_PASSWORD                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1032)
#define     PP_E_MISSING_DOMAIN                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1033)
#define     PP_E_INVALID_MEMBERNAME                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1034)
#define     PP_E_WRONG_DA_DOMAIN                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1035)
#define     PP_E_NONE_AUTH_MODE                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1036)
#define     PP_E_INVALID_CARD                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1037)
#define     PP_E_LOCATION_WRONG                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1038)
#define     PP_E_SECRET_ANS_WRONG                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1039)
#define     PP_E_KID_HAS_NO_CONSENT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103A)
#define     PP_E_NO_COUNTRY                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103B)
#define     PP_E_NO_REGION                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103C)
#define     PP_E_NO_POSTALCODE                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103D)
#define     PP_E_NO_SECRET_ANSWER                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103E)
#define     PP_E_NO_CREDIT_CARD                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x103F)
#define     PP_E_NEED_STRONG_CREDENTIALS                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1040)
#define     PP_E_BAD_PIN                                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1041)
#define     PP_E_EMAIL_TAKEN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1042)
#define     PP_E_BAD_PINSA                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1043)
#define     PP_E_MISSING_PIN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1044)
#define     PP_E_MISSING_PINSA                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1045)
#define     PP_E_PIN_MISMATCH                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1046)
#define     PP_E_PIN_INVALID                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1047)
#define     PP_E_PIN_BLANK                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1048)
#define     PP_E_PIN_TOO_SHORT                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1049)
#define     PP_E_PIN_TOO_LONG                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x104A)
#define     PP_E_PIN_CONTAINS_MEMBERNAME                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x104B)
#define     PP_E_FORCE_RENAME                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x104C)
#define     PP_E_MISSING_PHONENUM                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x104D)
#define     PP_E_MISSING_PHONEPIN                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x104E)
#define     PP_E_PPM_NOTCAPABLE                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x104F)
#define     PP_E_CREATECOOKIE_FAILED                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1050)
#define     PP_E_NAMECHANGE_NOTALLOWED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1051)
#define     PP_E_SECRET_QUESTION_BLANK                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1052)
#define     PP_E_BLANK_PASSWORD                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1053)
#define     PP_E_LOADSTRING_NOT_HANDLED                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1054)
#define     PP_E_IIS_ERROR						        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1055)
#define     PP_E_RX_PARSE_ERROR				            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1056)
#define     PP_E_RX_NO_MATCH				            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1057)

#define     PP_E_INVALIDNAMESPACE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1058)

// Success Codes from ValidateFunctions.cpp

#define     PP_S_TIMEZONE_OLD		                    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x1151)

// Errors from ValidateFunctions.cpp

#define     PP_E_NAME_BLANK                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1100)
#define     PP_E_NAME_TOO_SHORT                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1101)
#define     PP_E_NAME_TOO_LONG                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1102)
#define     PP_E_NAME_INVALID                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1103)
#define     PP_E_PASSWORD_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1104)
#define     PP_E_PASSWORD_TOO_SHORT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1105)
#define     PP_E_PASSWORD_TOO_LONG                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1106)
#define     PP_E_PASSWORD_CONTAINS_MEMBERNAME           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1107)
#define     PP_E_PASSWORD_INVALID                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1108)
#define     PP_E_PASSWORD_MISMATCH                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1109)
#define     PP_E_EMAIL_BLANK                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110A)
#define     PP_E_EMAIL_INVALID                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110B)
#define     PP_E_EMAIL_RIGHT_TOO_LONG                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110C)
#define     PP_E_EMAIL_INCOMPLETE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110D)
#define     PP_E_EMAIL_INVALID_CHARS                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110E)
#define     PP_E_BIRTHDATE_NOTENTERED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x110F)
#define     PP_E_BIRTHYEAR_INVALID_CHARS                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1110)
#define     PP_E_BIRTHYEAR_NOT_4DIGIT                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1111)
#define     PP_E_BIRTHYEAR_TOO_LOW                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1112)
#define     PP_E_BIRTHYEAR_MISSING                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1113)
#define     PP_E_BIRTHMONTH_MISSING                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1114)
#define     PP_E_BIRTHMONTH_INVALID                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1115)
#define     PP_E_BIRTHDAY_MISSING                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1116)
#define     PP_E_BIRTHDAY_INVALID                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1117)
#define     PP_E_BADDAYFORMONTH                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1118)
#define     PP_E_BIRTHDATE_UNDER18                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1119)
#define     PP_E_BIRTHDATE_IN_FUTURE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111A)
#define     PP_E_PARENT_UNDER13                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111B)
#define     PP_E_SECRETQA_NOQUESTION                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111C)
#define     PP_E_SECRETQA_NOANSWER                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111D)
#define     PP_E_SQ_INVALID                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111E)
#define     PP_E_SA_INVALID                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x111F)
#define     PP_E_SA_TOOSHORT                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1120)
#define     PP_E_SA_TOOLONG                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1121)
#define     PP_E_SQ_TOOSHORT                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1122)
#define     PP_E_SQ_TOOLONG                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1123)
#define     PP_E_LOCATION_INVALID_REGION                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1124)
#define     PP_E_LOCATION_INVALID_POSTALCODE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1125)
#define     PP_E_LOCATION_INVALID_POSTALCODECHARS       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1126)
#define     PP_E_LOCATION_INVALID_COUNTRY               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1127)
#define     PP_E_GENDER_BLANK                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1128)
#define     PP_E_GENDER_INVALID                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1129)
#define     PP_E_LANGUAGE_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112A)
#define     PP_E_TIMEZONE_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112B)
#define     PP_E_OCCUPATION_BLANK                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112C)
#define     PP_E_SVC_BLANK                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112D)
#define     PP_E_SAVEPASSWORD_BLANK                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112E)
#define     PP_E_ACCESSIBILITY_BLANK                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x112F)
#define     PP_E_ALLOWEMAILINPROFILE_BLANK              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1130)
#define     PP_E_ALLOWPASSPORTNETWORKEMAIL_BLANK        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1131)

#define     PP_E_MEMBER_EXIST                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1132)
#define     PP_E_EMAIL_MEMBER_EXIST                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1133)
#define     PP_E_EMAIL_MANAGED                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1134)

#define     PP_E_SECRETQA_DUPLICATE_Q                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1135)

#define     PP_E_FIRSTNAME_BLANK                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1136)
#define     PP_E_LASTNAME_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1137)
#define     PP_E_NICKNAME_BLANK                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1138)
#define     PP_E_EMAIL_RESERVED                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1139)
#define     PP_E_DOMAIN_INVALID                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113A)

#define     PP_E_SECRETQA_DUPLICATE_A                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113B)
#define     PP_E_SECRETQA_NOMATCH                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113C)

#define     PP_E_EXTERNALFIELD_BLANK                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113D)

#define     PP_E_PARENT_INVALID                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113E)

#define		PP_E_INVALID_PHONENUMBER					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x113F)
#define		PP_E_PHONENUMBER_EXIST						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1140)
#define     PP_E_TIMEZONE_INVALID                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1141)
#define     PP_E_OCCUPATION_INVALID                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1142)
#define     PP_E_LANGUAGE_INVALID						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1143)
#define		PP_E_INVALID_PINNUMBER						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1144)
#define     PP_E_SECUREPIN_MISMATCH                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1145)
#define     PP_E_SECUREPIN_INVALID                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1146)
#define     PP_E_SECUREPIN_BLANK                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1147)
#define     PP_E_SECUREPIN_TOO_SHORT                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1148)
#define     PP_E_SECUREPIN_TOO_LONG                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1149)
#define     PP_E_SECUREPIN_CONTAINS_MEMBERNAME          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x114a)

#define     PP_E_SECRETQA_VERIFY_NOANSWER               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x114b)

#define     PP_E_FIELD_TOO_LONG                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x114c)
#define     PP_E_FIRSTNAME_TOO_LONG                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x114d)
#define     PP_E_LASTNAME_TOO_LONG                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x114e)
#define     PP_E_FORCERENAME_RESPONSE_INVALID           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x114f)
#define     PP_E_LOCATION_INVALID_POSTALCODEBLANK		MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1150)
#define     PP_E_EMAIL_TOO_LONG							MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1151)
#define     PP_E_EMAIL_LEFT_TOO_LONG					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1152)
#define		PP_E_NAME_FIRST_LAST_DOT					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1153)
#define		PP_E_NAME_DOT_AFTER_DOT						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1154)
#define		PP_E_DOMAIN_INVALID_CHAR					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1155)
#define		PP_E_NAME_INVALID_CHAR						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1156)
#define		PP_E_DOMAIN_FIRST_LAST_CHAR_INVALID			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1157)
#define		PP_E_DOMAIN_DOT_AFTER_DOT					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1158)



// Database Errors

#define     PP_E_DB_STRINGTOOLONG                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1200)
#define     PP_E_DB_STRINGTOOSHORT                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1201)
#define     PP_E_DB_INVALIDPASSWORD                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1202)
#define     PP_E_DB_INVALIDEMAIL                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1203)
#define     PP_E_DB_INVALIDMEMBERNAME                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1204)
#define     PP_E_DB_MISSINGPARAMETERS                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1205)
#define     PP_E_DB_FORBIDDENWORD                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1206)
#define     PP_E_DB_INVALIDDOMAINNAME                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1207)
#define     PP_E_DB_CRITICALERROR                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1208)
#define     PP_E_DB_ERROR                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1209)
#define     PP_E_DB_MEMBEREXISTS                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120A)
#define     PP_E_DB_MEMBERDOESNOTEXIST                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120B)
#define     PP_E_DB_NODATA                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120C)
#define     PP_E_DB_DUPLICATEFRIENDLYNAME               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120D)
#define     PP_E_DB_ADDRESSDOESNOTEXIST                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120E)
#define     PP_E_DB_CARDDOESNOTEXIST                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x120F)
#define     PP_E_DB_ADDRESSREFERENCEDBYCARD             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1210)
#define     PP_E_DB_KIDSSITENOTLISTED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1211)
#define     PP_E_DB_SITEALREADYREQUESTED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1212)
#define     PP_E_DB_CONNECTIONTIMEOUT                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1213)
#define     PP_E_DB_NOCONNECTIONAVAILABLE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1224)
#define		PP_E_DB_TOOMANYUSERSWITHTHISNAME			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1225)
#define		PP_E_DB_DOMAINNOTSUPPORTED					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1226)
// XML interface errors

#define     PP_E_XML_PARSE_ERROR                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1300)
#define     PP_E_XML_NO_CLIENTINFO                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1301)
#define     PP_E_XML_UNKNOWN_CLIENTVERSION              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1302)
#define     PP_E_XML_NAME_AND_PASSWORD_BLANK            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1303)
#define     PP_E_XML_DOMAIN_BLANK                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1304)
#define     PP_E_XML_INCOMPLETE_MEMBERNAME              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1305)
#define     PP_E_XML_NO_SUCH_NODE                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1306)
#define     PP_E_XML_NO_TEXT                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1307)
#define     PP_E_XML_INVALID_ROOTTAG                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1308)
#define     PP_E_XML_USER_ALREADY_LOGGEDIN              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1309)
#define     PP_E_XML_KEYVERSION_NOT_A_NUMBER            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x130A)
#define     PP_E_XML_NO_USER_LOGGED_IN                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x130B)
#define     PP_E_XML_NO_SUCH_ATTRIBUTE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x130C)

// Global Init object errors

#define     PP_E_GLOBALINIT_BASE                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1400)
#define     PP_E_GLOBALINIT_MISSING_PCONTROL_SERVICE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1400)
#define     PP_E_GLOBALINIT_NOAGENT                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1401)
#define     PP_E_GLOBALINIT_DOMAINGET_BINDFAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1402)
#define     PP_E_GLOBALINIT_MISSING_STRINGTABLE_SERVICE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1403)
#define     PP_E_GLOBALINIT_DOMAINGET_EXECUTEFAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1404)
#define     PP_E_GLOBALINIT_MISSING_DOMAINID_CONFIG     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1405)
#define     PP_E_GLOBALINIT_INVALID_DOMAIN_INDEX        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1406)
#define     PP_E_GLOBALINIT_BUFFER_TOO_SMALL            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1407)
#define     PP_E_GLOBALINIT_MISSING_MANAGER_SERVICE     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1408)
#define     PP_E_GLOBALINIT_ADDSTRING_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1409)
#define     PP_E_GLOBALINIT_DOMAINGET_GETROWEXFAILED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x140A)
#define     PP_E_GLOBALINIT_DOMAINGET_GETITEMFAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x140B)
#define     PP_E_GLOBALINIT_ADDNUMBER_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x140C)


// Digest Errors
#define     PP_E_DIGEST_PARSE_AUTH_HEADER               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1500)
#define     PP_E_DIGEST_OPAQUE_MISSMATCH                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1501)
#define     PP_E_DIGEST_ALGORITHM_MISSMATCH             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1502)
#define     PP_E_DIGEST_REALMS_MISSMATCH                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1503)
#define     PP_E_DIGEST_URI_MISSMATCH                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1504)
#define     PP_E_DIGEST_USERNAME_MISSING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1505)
#define     PP_E_DIGEST_CNONCE_MISSING                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1506)
#define     PP_E_DIGEST_NONCE_COUNT_MISSING             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1507)
#define     PP_E_DIGEST_NONCE_MISSING                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1508)
#define     PP_E_DIGEST_UNSUPPORTED_KPP_MODE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1509)
#define     PP_E_DIGEST_NONCE_MISSMATCH                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150A)
#define     PP_E_DIGEST_RESPONSE_TIMEOUT                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150B)
#define     PP_E_DIGEST_RESPONSE_MISSING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150C)
#define     PP_E_DIGEST_QOP_MISSMATCH                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150D)
#define     PP_E_DIGEST_INVALID_NONCE_COUNT             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150E)
#define     PP_E_DIGEST_HOTMAIL_USERNAME_MISMATCH       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x150F)


// MD5 Silent Errors
#define     PP_E_MD5SILENT_SITEID_IS_ONE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1600)
#define     PP_E_MD5SILENT_INVALID_T                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1601)
#define     PP_E_MD5SILENT_INVALID_P                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1602)
#define     PP_E_MD5SILENT_INVALID_KPP                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1603)
#define     PP_E_MD5SILENT_INVALID_SITE                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1604)

// Inline Signin Errors
#define     PP_E_INLINESIGNIN_NOT_ALLOWED_FOR_SITE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1700)
#define     PP_E_INLINESIGNIN_SSL_REQUIRED_FOR_POST     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1701)


// NetPartnerInfo (NSO) Errors
#define     PP_E_NETPARTNERINFO_UNINITIALZED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1800)
#define     PP_E_NETPARTNERINFO_SITEID_NOT_FOUND        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1801)
#define     PP_E_NETPARTNERINFO_DECRYPT_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1802)
#define     PP_E_NETPARTNERINFO_KEYSIZE_MISMATCH        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1803)
#define     PP_E_NETPARTNERINFO_CREATEFILE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1804)
#define     PP_E_NETPARTNERINFO_WRITEFILE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1805)
#define     PP_E_NETPARTNERINFO_READFILE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1806)

// Com object errors
#define     PP_E_HASHSTRING_ADDRECORD_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1900)
#define     PP_E_MD5_HASH_FAILED                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1901)

// Globalization errors
#define     PP_E_GLOBALIZATION_INVALID_COUNTRY_ID       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A00)
#define     PP_E_GLOBALIZATION_INVALID_REGION_ID        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A01)
#define     PP_E_GLOBALIZATION_INVALID_POSTAL_ID        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A02)
#define     PP_E_GLOBALIZATION_INVALID_GEO_ID           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A03)
#define     PP_E_GLOBALIZATION_INVALID_TIMEZONE_ID      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A04)
#define     PP_E_GLOBALIZATION_INVALID_REGION           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A05)
#define     PP_E_GLOBALIZATION_INVALID_TIMEZONE         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A06)
#define     PP_E_GLOBALIZATION_INVALID_INDEX            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A07)
#define     PP_E_GLOBALIZATION_INVALID_DATA             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A08)
#define     PP_E_GLOBALIZATION_INVALID_DATA_TYPE        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A09)
#define     PP_E_GLOBALIZATION_OBJ_IS_NULL              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0A)
#define     PP_E_GLOBALIZATION_PTR_IS_NULL              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0B)
#define     PP_E_GLOBALIZATION_STREAM_IS_NULL           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0C)
#define     PP_E_GLOBALIZATION_BSTR_EXPECTED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0D)
#define     PP_E_GLOBALIZATION_SEMICOLON_NOT_FOUND      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0E)
#define     PP_E_GLOBALIZATION_COMMA_NOT_FOUND          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A0F)
#define     PP_E_GLOBALIZATION_ALREADY_LOADED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A10)
#define     PP_E_GLOBALIZATION_LCIDINFO_NOT_LOADED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A11)
#define     PP_E_GLOBALIZATION_LCIDINFO_NOT_PREPARED    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A12)
#define     PP_E_GLOBALIZATION_REGION_LOAD_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A13)
#define     PP_E_GLOBALIZATION_TIMEZONE_LOAD_FAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A14)
#define     PP_E_GLOBALIZATION_LOOKUP_OBJ_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A15)
#define     PP_E_GLOBALIZATION_LOADVALUES_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A16)
#define     PP_E_GLOBALIZATION_GETLOCALINFO_FAILED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A17)
#define     PP_E_GLOBALIZATION_STRING_RETURNED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A18)
#define     PP_E_GLOBALIZATION_W2A_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A19)
#define     PP_E_GLOBALIZATION_A2W_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1A)
#define     PP_E_GLOBALIZATION_INSTREAM_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1B)
#define     PP_E_GLOBALIZATION_GET_LCIDINFODIR_FAILED   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1C)
#define     PP_E_GLOBALIZATION_STRING_TOO_LONG          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1D)
#define     PP_E_GLOBALIZATION_IDTABLE_NOT_INIT         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1A1E)

// DelegatedAdmin Errors
#define     PP_E_DELEGADMIN_INVALID_ADMIN_ELE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B00)
#define     PP_E_DELEGADMIN_INVALID_ADMIN_TICKET        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B01)
#define     PP_E_DELEGADMIN_DOMAIN_ALREADY_MANAGED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B02)
#define     PP_E_DELEGADMIN_DOMAIN_NOT_MANAGED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B03)
#define     PP_E_DELEGADMIN_DOMAIN_NOT_PARTNERS         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B04)
#define     PP_E_DELEGADMIN_INVALID_NS_ADMIN            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B05)
#define     PP_E_DELEGADMIN_INVALID_PARTNER_ADMIN       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B06)
#define     PP_E_DELEGADMIN_ERROR_LOADING_XMLRQ         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B07)
#define     PP_E_DELEGADMIN_INVALID_AUTH_ELE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B08)
#define     PP_E_DELEGADMIN_INVALID_DOMAIN              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B09)
#define     PP_E_DELEGADMIN_INVALID_ACTION              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0a)
#define     PP_E_DELEGADMIN_INVALID_CLIENTVERSION       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0b)
#define     PP_E_DELEGADMIN_NOTALLOWED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0c)
#define     PP_E_DELEGADMIN_INVALID_USER                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0d)
#define     PP_E_DELEGADMIN_INVALID_USER_ELE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0e)
#define     PP_E_DELEGADMIN_INVALID_PARAM               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B0f)
#define     PP_E_DELEGADMIN_NOT_NAMESPACE_PARTNER       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B10)
#define     PP_E_DELEGADMIN_INVALID_SITEID			    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B11)
#define     PP_E_DELEGADMIN_TICKET_EXPIRED			    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B12)
#define     PP_E_DELEGADMIN_ROLLBACK_ERROR			    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B13)
#define     PP_E_DELEGADMIN_INVALID_ENUM_TYPE		    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B14)
#define     PP_E_DELEGADMIN_ALREADY_AN_ADMIN		    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B15)
#define     PP_E_DELEGADMIN_LAST_ADMIN		    		MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B16)
#define     PP_E_DELEGADMIN_INVALID_ADMIN		    	MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1B17)

// Update Server Errors
#define     PP_E_UPDATE_UPDATES_NOT_ALLOWED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1C00)


// Profile Server Errors
#define     PP_E_PROFILE_REG_LOGIN_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D00)


#define     PP_E_EMAILRESPONSE_INTERNALERROR			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D01)		// unexpected error (status should be of VT_INT) return from EmailResponse object
#define	    PP_E_EMAIL_NOT_FOUND						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D02)	
#define		PP_E_LCID_NOT_FOUND							MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D03)
#define		PP_E_EMAILRESPONSE_CHECKSECRET				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D04)
#define		PP_E_MEMBERNAME_NOT_FOUND					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D05)
#define		PP_E_PREEMAIL_NOT_FOUND						MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D06)
#define		PP_E_EMAILRESPONSE_ERROR					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D07)
#define		PP_E_EMAIL_ALREADY_PROCESSED				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1D08)

// PST Support Object Errors
#define	    PP_E_PSTUTIL_INVALID_EMAIL_STATUS			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E00)
#define	    PP_E_PSTUTIL_INVALID_ADMIN					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E01)
#define	    PP_E_PSTUTIL_INVALID_CRED_TYPE				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E02)
#define	    PP_E_PSTUTIL_NOPASSPORTSERVEROBJ			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E03)
#define	    PP_E_PSTUTIL_CANT_UPDATE_INACTIVE			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E04)
#define	    PP_E_PSTUTIL_INVALID_REPORT_TYPE			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E05)
#define	    PP_E_PSTUTIL_OUT_OF_MEMORY					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E06)
#define	    PP_E_PSTUTIL_INTERNALERROR_NOCRED			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E07)
#define	    PP_E_PSTUTIL_DICTIONARY_ERROR				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1E08)

// msppext Errors
#define	    PP_E_MSPPEXT_GETEXTVERSION_FAILED			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F00)
#define	    PP_E_MSPPEXT_GETENV_FAILED					MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F01)
#define	    PP_E_MSPPEXT_SET_EVENT_FAILED				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F02)
#define	    PP_E_MSPPEXT_INIT_UPDATEMGR_FAILED			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F03)
#define	    PP_E_MSPPEXT_INIT_EVENT_FAILED				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F04)
#define	    PP_E_MSPPEXT_CREATE_THREAD_FAILED			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F05)
#define	    PP_E_MSPPEXT_WAIT_EVENT_FAILED				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F06)
#define	    PP_E_MSPPEXT_SERVICEMGR_NOT_INIT		    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F07)
#define	    PP_E_MSPPEXT_SERVICE_NOT_LOADED				MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F08)
#define	    PP_E_MSPPEXT_REQUEST_TIMEOUT			    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F09)
#define	    PP_E_MSPPEXT_COM_SWAP_FAILED			    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x1F0A)


// ProfileInfoCom Errors
#define	    PP_E_PROFILEINFOCOM_COULDNOTEVENTCSITE		    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x2000)


// map db error to application error defined above
HRESULT     DBError(HRESULT hr); 
// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\admin.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    admin.h
        Define CAdmin class for passport admin interface


    FILE HISTORY:

*/
#ifndef __ADMIN_H_
#define __ADMIN_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAdmin
class ATL_NO_VTABLE CAdmin : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAdmin, &CLSID_Admin>,
	public ISupportErrorInfo,
//	public IDispatchImpl<IPassportAdmin, &IID_IPassportAdmin, &LIBID_PASSPORTLib>,
	public IDispatchImpl<IPassportAdminEx, &IID_IPassportAdminEx, &LIBID_PASSPORTLib>
{
public:
  CAdmin()
    { 
    }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ADMIN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAdmin)
  COM_INTERFACE_ENTRY (IPassportAdmin)
  COM_INTERFACE_ENTRY (IPassportAdminEx)
  COM_INTERFACE_ENTRY2(IDispatch, IPassportAdminEx)
  COM_INTERFACE_ENTRY (ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportAdmin
public:
  STDMETHOD(get_currentKeyVersion)(/*[out, retval]*/ int *pVal);
  STDMETHOD(put_currentKeyVersion)(/*[in]*/ int Val);
  STDMETHOD(setKeyTime)(/*[in]*/ int version, /*[in]*/ int fromNow);
  STDMETHOD(deleteKey)(/*[in]*/ int version);
  STDMETHOD(addKey)(/*[in]*/ BSTR keyMaterial, /*[in]*/ int version, /*[in]*/ long expires, /*[out,retval]*/ VARIANT_BOOL *ok);
  STDMETHOD(get_ErrorDescription)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(Refresh)(/*[in]*/ VARIANT_BOOL bWait, /*[out,retval]*/ VARIANT_BOOL* pbSuccess);
  STDMETHOD(setKeyTimeEx)(/*[in]*/ int version, /*[in]*/ int fromNow, /*[in,optional]*/ VARIANT vSiteName);
  STDMETHOD(deleteKeyEx)(/*[in]*/ int version, /*[in,optional]*/ VARIANT vSiteName);
  STDMETHOD(addKeyEx)(/*[in]*/ BSTR keyMaterial, /*[in]*/ int version, /*[in]*/ long expires, /*[in,optional]*/ VARIANT vSiteName, /*[out,retval]*/ VARIANT_BOOL *ok);
  STDMETHOD(getCurrentKeyVersionEx)(/*[in,optional]*/ VARIANT vSiteName, /*[out, retval]*/ int *pVal);
  STDMETHOD(putCurrentKeyVersionEx)(/*[in]*/ int Val, /*[in,optional]*/ VARIANT vSiteName);
  STDMETHOD(setNexusPassword)(/*[in]*/ BSTR bstrPwd);
};


//
// Helper routine to create/set the CCDPassword
//

HRESULT SetCCDPassword(VOID);

#endif //__ADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\ticketschema.h ===
#ifndef _TICKET_SCHEMA_H
#define _TICKET_SCHEMA_H

#include "xstring"
#include "BstrHash.h"

#import <msxml.tlb> rename_namespace("MSXML")

// this schema object can only handles schema version within the following range
#define  VALID_SCHEMA_VERSION_MIN	1
#define  VALID_SCHEMA_VERSION_MAX	0x1ff

class CRefCountObj
{
public:
   ULONG AddRef()
   {
      InterlockedIncrement(&m_refs);
      return m_refs;
   };
   ULONG Release()
   {
      InterlockedDecrement(&m_refs);
      if (m_refs == 0)
      {
         delete this;
         return 0;
      }
      else
         return m_refs;
   };
protected:
   CRefCountObj(): m_refs(0){};
   virtual ~CRefCountObj(){};

   long    m_refs;
};

// the value types supported in the schema
enum TicketValueType {
    tNull = 0, 
    tText,
    tChar,
    tByte,
    tWord,
    tLong,
    tDate,
    tInvalid
  };

#define	SIZE_TEXT		(DWORD)(-1)

// the size array of the types defines in TicketValueType
const DWORD TicketTypeSizes[] =
{
	0, 
    SIZE_TEXT,
    1,	
    1, 
    sizeof(short),
    sizeof(long),
    sizeof(long),
    0
};

// attribute names in schema definition in partner.xml
#define	ATTRNAME_VERSION	L"version"
#define	ATTRNAME_NAME	L"name"
#define	ATTRNAME_TYPE	L"type"
#define	ATTRNAME_SIZE	L"size"
#define	ATTRNAME_FLAGS	L"flags"


// type name value map
struct CTicketTypeNameMap {
   LPCWSTR  name;
   DWORD    type;
};

const CTicketTypeNameMap TicketTypeNameMap[] = { 
	{L"text" , tText},
	{L"char" , tChar},
	{L"byte" , tByte},
	{L"word" , tWord},
	{L"text" , tLong},
	{L"long" , tLong},
	{L"date" , tDate},
	{L"long" , tLong},
};
	
struct TicketFieldDef
{
   _bstr_t  name;
   DWORD    type;
   DWORD    flags;
};

#define  INVALID_OFFSET (DWORD)(-1)

struct   TicketProperty
{
   TicketProperty():flags(0), offset(INVALID_OFFSET) {}; 
   _variant_t  value;
   DWORD       type;       // type of the property, a value of TicketValueType
   DWORD       flags;      // the flags defined in schema
   DWORD       offset;     // the offset of the property in raw buf
};

class CTicketSchema;
class C_Ticket_13X;

class wstringLT
{
 public:
  bool operator()(const std::wstring& x, const std::wstring& y) const
  {
    return (_wcsicmp(x.c_str(),y.c_str()) < 0);
  }
};

typedef std::map<std::wstring,TicketProperty, wstringLT> TicketPropertyMap;

class CTicketPropertyBag
{
friend class CTicketSchema;
friend class C_Ticket_13X;
public:
   CTicketPropertyBag();
   virtual ~CTicketPropertyBag();

   HRESULT GetProperty(LPCWSTR  name, TicketProperty& prop);

   int Size() const { return m_props.size();};
   
protected:     
   // this bag is read only to external
   HRESULT PutProperty(LPCWSTR  name, const TicketProperty& prop);

protected:
   TicketPropertyMap  m_props;
};

class CTicketSchema : public CRefCountObj
{
 public:
  // Read the raw blob according to the schema, and output the positions of
  // each element.  Output array size MUST be >= Count()
  HRESULT parseTicket(LPCSTR raw, UINT size, CTicketPropertyBag& bag);


  CTicketSchema();
  virtual ~CTicketSchema();

  BOOL    isValid() const { return m_isOk; }
  _bstr_t getErrorInfo() const { return m_szReason; }
  
  BOOL ReadSchema(MSXML::IXMLElementPtr &root);

protected:

  BOOL      m_isOk;
  _bstr_t   m_szReason;

  // Valid until this time
  SYSTEMTIME m_validUntil;

  // verion #
  USHORT    m_version;

  // name
  _bstr_t   m_name;

  // Array of attribute types
  UINT            m_numAtts;
  TicketFieldDef* m_attsDef;
};

#define  MORE_MASKUNIT(n)           (((n) & 0x8000) != 0)
#define  MASK_INDEX_INVALID        (USHORT)(-1)

class CTicketFieldMasks
{
public:
   CTicketFieldMasks(): m_fieldIndexes(NULL){};
   virtual ~CTicketFieldMasks(){delete[] m_fieldIndexes;};
   HRESULT     Parse(LPBYTE mask, ULONG size, ULONG* pcParsed);
   unsigned short* GetIndexes(){ return m_fieldIndexes;};

protected:
   unsigned short*   m_fieldIndexes;
};

#endif	// _TICKET_SCHEMA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\admin.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    admin.cpp
       DCOM object for pmconfig -- admin utility to call to configure passport 


    FILE HISTORY:

*/// Admin.cpp : Implementation of CAdmin
#include "stdafx.h"
#include "Passport.h"
#include "Admin.h"
#include "keycrypto.h"
#include <time.h>

#define  MAX_CCDPASSWORD_LEN    256

#include "keyver.h"

#define PASSPORT_KEY    L"SOFTWARE\\Microsoft\\Passport"
#define KEYDATA_KEY     PASSPORT_KEY L"\\KeyData"
#define KEYTIMES_KEY    PASSPORT_KEY L"\\KeyTimes"
#define SITES_KEY       PASSPORT_KEY L"\\Sites"
#define NEXUS_KEY       PASSPORT_KEY L"\\Nexus"
#define KEYDATA_SUBKEY  L"KeyData"
#define KEYTIMES_SUBKEY L"KeyTimes"


/////////////////////////////////////////////////////////////////////////////
// CAdmin

//===========================================================================
//
// InterfaceSupportsErrorInfo 
//

STDMETHODIMP CAdmin::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPassportAdmin,
        &IID_IPassportAdminEx,
    };

    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
        {
            return S_OK;
        }
    }

    return S_FALSE;
}


//===========================================================================
//
// get_IsValid 
//

STDMETHODIMP CAdmin::get_IsValid(VARIANT_BOOL *pVal)
{
    *pVal =  g_config->isValid() ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

//===========================================================================
//
// get_ErrorDescription
//

STDMETHODIMP CAdmin::get_ErrorDescription(BSTR *pVal)
{
    if (g_config->isValid())
    {
        *pVal = SysAllocString(L"Passport Object OK");
    }
    else
    {
        *pVal = SysAllocString(g_config->getFailureString());
    }

    return S_OK;
}

//===========================================================================
//
//  addKey
//

STDMETHODIMP CAdmin::addKey(BSTR keyMaterial, int version, long expires, VARIANT_BOOL *ok)
{
    HRESULT hr = S_OK;
    *ok = VARIANT_FALSE;

    // Must be the appropriate length
    if (SysStringLen(keyMaterial) != CKeyCrypto::RAWKEY_SIZE)
    {
        AtlReportError(CLSID_Admin, L"Key must be 24 characters", IID_IPassportAdmin, E_FAIL);
        return E_FAIL;
    }

    // Must be an appropriate version
    if (version > KEY_VERSION_MAX || version < KEY_VERSION_MIN)
    {
        AtlReportError(CLSID_Admin, L"Key version must be <36 and > 0", IID_IPassportAdmin, E_FAIL);
        return E_FAIL;
    }

    BYTE      original[CKeyCrypto::RAWKEY_SIZE];
    DATA_BLOB iBlob;
    iBlob.cbData = sizeof(original);
    iBlob.pbData = &(original[0]);

    for (int i = 0; i < CKeyCrypto::RAWKEY_SIZE; i++)
    {
        original[i] = static_cast<BYTE>(keyMaterial[i] & 0xFF);
    }

    // Try to encrypt it
    CKeyCrypto   kc;
    DATA_BLOB    oBlob = {0};

    if (kc.encryptKey(&iBlob, &oBlob) != S_OK)
    {
        AtlReportError(CLSID_Admin, 
                       L"Failed to encrypt key, couldn't find valid network card?",
                       IID_IPassportAdmin,
                       E_FAIL);

        return E_FAIL;
    }

    // Now add it to registry
    LONG   lResult;
    HKEY   hkDataKey = NULL, hkTimeKey = NULL;
    char  szKeyNum[2];

    szKeyNum[0] = KeyVerI2C(version);
    szKeyNum[1] = '\0';

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEYDATA_KEY, 0, KEY_WRITE, &hkDataKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyData key in registry.  Reinstall Passport.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEYTIMES_KEY, 0, KEY_WRITE, &hkTimeKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyTimes key in registry.  Reinstall Passport.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegSetValueExA(hkDataKey, szKeyNum, 0, REG_BINARY, oBlob.pbData, oBlob.cbData);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin,
                       L"Couldn't write KeyData key to registry.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    if (expires != 0)
    {
        DWORD dwTime = expires;

        lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0, REG_DWORD, (LPBYTE) &dwTime, sizeof(DWORD));

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't write KeyTime value to registry.",
                           IID_IPassportAdmin,
                           E_FAIL);

            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        RegDeleteValueA(hkTimeKey, szKeyNum);
    }

    *ok = VARIANT_TRUE;

Cleanup:

    if (hkDataKey)
    {
        RegCloseKey(hkDataKey);
    }

    if (hkTimeKey)
    {
        RegCloseKey(hkTimeKey);
    }

    if(oBlob.pbData)
    {
        LocalFree(oBlob.pbData);
    }

    if (*ok == VARIANT_TRUE)
    {
        if (g_pAlert)
        {
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_NEWKEY_INSTALLED);
        }
    }

    return hr;
}


//===========================================================================
//
//  addKeyEx
//

STDMETHODIMP CAdmin::addKeyEx(BSTR keyMaterial, int version, long expires, VARIANT vSiteName, VARIANT_BOOL *ok)
{
    HRESULT       hr = S_OK;
    LPSTR         szSiteName = NULL;
    LONG          lResult;
    HKEY          hkDataKey = NULL, hkTimeKey = NULL;
    HKEY          hkSites = NULL, hkPassport = NULL;
    char          szKeyNum[2];

    BYTE         original[CKeyCrypto::RAWKEY_SIZE];
    DATA_BLOB    iBlob;
    DATA_BLOB    oBlob = {0};
    CKeyCrypto   kc;

    int i;

    *ok = VARIANT_FALSE;
  
    USES_CONVERSION;

    // Must be the appropriate length
    if (SysStringLen(keyMaterial) != CKeyCrypto::RAWKEY_SIZE)
    {
        AtlReportError(CLSID_Admin, L"Key must be 24 characters", IID_IPassportAdminEx, E_FAIL);
        return E_FAIL;
    }

    // Must be an appropriate version
    if (version > KEY_VERSION_MAX || version < KEY_VERSION_MIN)
    {
      AtlReportError(CLSID_Admin,  L"Key version must be < 36 and > 0", IID_IPassportAdminEx, E_FAIL);
      return E_FAIL;
    }

    if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
    {
        szSiteName = NULL;
    }
    else if(vSiteName.vt == VT_BSTR)
    {
        szSiteName = W2A(vSiteName.bstrVal);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; i < CKeyCrypto::RAWKEY_SIZE; i++)
    {
        original[i] = static_cast<BYTE>(keyMaterial[i] & 0xFF);
    }

    iBlob.cbData = sizeof(original);
    iBlob.pbData = &(original[0]);

    // Try to encrypt it 

    if (kc.encryptKey(&iBlob, &oBlob) != S_OK)
    {
        AtlReportError(CLSID_Admin, 
                       L"Failed to encrypt key, couldn't find valid network card?", 
                       IID_IPassportAdminEx, 
                       E_FAIL);

        return E_FAIL;
    }

    // Get the root key.
    if(szSiteName)
    {
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               SITES_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hkSites);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Site not found.  Please add the site before installing the key.", 
                           IID_IPassportAdminEx, 
                           PP_E_SITE_NOT_EXISTS);

            hr = PP_E_SITE_NOT_EXISTS;
            goto Cleanup;
        }

        lResult = RegOpenKeyExA(hkSites,
                                szSiteName,
                                0,
                                KEY_ALL_ACCESS,
                                &hkPassport);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Site not found.  Please add the site before installing the key.", 
                           IID_IPassportAdminEx, 
                           PP_E_SITE_NOT_EXISTS);

            hr = PP_E_SITE_NOT_EXISTS;
            goto Cleanup;
        }
    }
    else
    {
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               PASSPORT_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hkPassport);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't find Passport key in registry.  Reinstall Passport.", 
                           IID_IPassportAdminEx, 
                           E_FAIL);

            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // Now add it to registry

    szKeyNum[0] = KeyVerI2C(version);
    szKeyNum[1] = '\0';

    lResult = RegOpenKeyEx(hkPassport, KEYDATA_SUBKEY, 0, KEY_WRITE, &hkDataKey);

    if (lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyData key in registry.  Reinstall Passport.",
                       IID_IPassportAdminEx,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegOpenKeyEx(hkPassport, KEYTIMES_SUBKEY, 0, KEY_WRITE, &hkTimeKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyTimes key in registry.  Reinstall Passport.",
                       IID_IPassportAdminEx,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegSetValueExA(hkDataKey, szKeyNum, 0, REG_BINARY, oBlob.pbData, oBlob.cbData);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't write KeyData key to registry.",
                       IID_IPassportAdminEx,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    if (expires != 0)
    {
        DWORD dwTime = expires;

        lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0, REG_DWORD, (LPBYTE) &dwTime, sizeof(DWORD));

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't write KeyTime value to registry.",
                           IID_IPassportAdminEx,
                           E_FAIL);

            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        RegDeleteValueA(hkTimeKey, szKeyNum);
    }

    *ok = VARIANT_TRUE;

Cleanup:

    if (hkPassport)
    {
        RegCloseKey(hkPassport);
    }

    if (hkDataKey)
    {
        RegCloseKey(hkDataKey);
    }

    if (hkTimeKey)
    {
        RegCloseKey(hkTimeKey);
    }

    if (hkSites)
    {
        RegCloseKey(hkSites);
    }

    if (oBlob.pbData)
    {
        ::LocalFree(oBlob.pbData);
    }

    if (*ok == VARIANT_TRUE)
    {
        if (g_pAlert)
        {
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_NEWKEY_INSTALLED);
        }
    }

    return hr;
}


//===========================================================================
//
//  deleteKey
//

STDMETHODIMP CAdmin::deleteKey(int version)
{
    HRESULT hr = S_OK, lResult;
    HKEY  hkDataKey = NULL, hkTimeKey = NULL;
    char  szKeyNum[2];

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEYDATA_KEY, 0, KEY_WRITE, &hkDataKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
		       L"Couldn't find KeyData key in registry.  Reinstall Passport.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEYTIMES_KEY, 0, KEY_WRITE, &hkTimeKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
		       L"Couldn't find KeyTimes key in registry.  Reinstall Passport.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    szKeyNum[0] = KeyVerI2C(version);
    szKeyNum[1] = '\0';

    RegDeleteValueA(hkTimeKey, szKeyNum);
    RegDeleteValueA(hkDataKey, szKeyNum);

Cleanup:

    if (hkDataKey)
    {
        RegCloseKey(hkDataKey);
    }

    if (hkTimeKey)
    {
        RegCloseKey(hkTimeKey);
    }

    return hr;
}


//===========================================================================
//
//  deleteKeyEx
//

STDMETHODIMP CAdmin::deleteKeyEx(
    int     version,
    VARIANT vSiteName
    )
{
    HRESULT hr = S_OK, lResult;
    HKEY  hkDataKey = NULL, hkTimeKey = NULL;
    HKEY  hkPassport = NULL, hkSites = NULL;
    char  szKeyNum[2];
    LPSTR szSiteName = NULL;

    USES_CONVERSION;

    if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
    {
        szSiteName = NULL;
    }
    else if(vSiteName.vt == VT_BSTR)
    {
        szSiteName = W2A(vSiteName.bstrVal);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(szSiteName)
    {
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               SITES_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hkSites);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't find Sites key in registry.  Reinstall Passport.",
                           IID_IPassportAdminEx, 
                           PP_E_SITE_NOT_EXISTS);

            hr = PP_E_SITE_NOT_EXISTS;
            goto Cleanup;
        }

        lResult = RegOpenKeyExA(hkSites,
                                szSiteName,
                                0,
                                KEY_ALL_ACCESS,
                                &hkPassport);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't find site key in registry.  Reinstall Passport.",
                           IID_IPassportAdminEx, 
                           PP_E_SITE_NOT_EXISTS);

            hr = PP_E_SITE_NOT_EXISTS;
            goto Cleanup;
        }
    }
    else
    {
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               PASSPORT_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hkPassport);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't find Passport key in registry.  Reinstall Passport.",
                           IID_IPassportAdminEx,
                           E_FAIL);

            hr = E_FAIL;
            goto Cleanup;
        }
    }

    lResult = RegOpenKeyEx(hkPassport, KEYDATA_SUBKEY, 0, KEY_WRITE, &hkDataKey);

    if (lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyData key in registry.  Reinstall Passport.",
                       IID_IPassportAdminEx,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegOpenKeyEx(hkPassport, KEYTIMES_SUBKEY, 0, KEY_WRITE, &hkTimeKey);

    if (lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyTimes key in registry.  Reinstall Passport.",
                       IID_IPassportAdminEx,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    szKeyNum[0] = KeyVerI2C(version);
    szKeyNum[1] = '\0';

    RegDeleteValueA(hkTimeKey, szKeyNum);
    RegDeleteValueA(hkDataKey, szKeyNum);

Cleanup:

    if (hkPassport)
    {
        RegCloseKey(hkPassport);
    }

    if (hkSites)
    {
        RegCloseKey(hkSites);
    }

    if (hkDataKey)
    {
        RegCloseKey(hkDataKey);
    }

    if (hkTimeKey)
    {
        RegCloseKey(hkTimeKey);
    }

    return hr;
}


//===========================================================================
//
//  setKeyTime
//

STDMETHODIMP CAdmin::setKeyTime(int version, int fromNow)
{
    HRESULT hr = S_OK, lResult;
    HKEY  hkDataKey = NULL, hkTimeKey = NULL;
    char  szKeyNum[2];

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEYTIMES_KEY, 0, KEY_WRITE, &hkTimeKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyTimes key in registry.  Reinstall Passport.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    szKeyNum[0] = KeyVerI2C(version);
    szKeyNum[1] = '\0';

    if (fromNow == 0)
    {
        RegDeleteValueA(hkTimeKey, szKeyNum);
    }
    else
    {
        time_t now;
        time(&now);
        now += fromNow;
        DWORD dwT = now;
        lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0, REG_DWORD, (LPBYTE) &dwT, sizeof(DWORD));

        if(lResult != ERROR_SUCCESS)
	{
            AtlReportError(CLSID_Admin, 
			   L"Couldn't write KeyTime key to registry.",
                           IID_IPassportAdmin,
                           E_FAIL);

            hr = E_FAIL;
            goto Cleanup;
	}
    }

Cleanup:

    if (hkTimeKey)
    {
        RegCloseKey(hkTimeKey);
    }

    return hr;
}


//===========================================================================
//
//  setKeyTimeEx
//

STDMETHODIMP CAdmin::setKeyTimeEx(
    int version, 
    int fromNow,
    VARIANT vSiteName
    )
{
    HRESULT hr = S_OK, lResult;
    LPSTR szSiteName = NULL;
    HKEY  hkDataKey = NULL, hkTimeKey = NULL;
    HKEY  hkSites = NULL, hkPassport = NULL;
    char  szKeyNum[2];

    USES_CONVERSION;

    if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
    {
        szSiteName = NULL;
    }
    else if(vSiteName.vt == VT_BSTR)
    {
        szSiteName = W2A(vSiteName.bstrVal);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(szSiteName)
    {
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               SITES_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hkSites);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
		           L"Couldn't find Sites key in registry.  Reinstall Passport.",
                           IID_IPassportAdminEx, 
                           PP_E_SITE_NOT_EXISTS);

            hr = PP_E_SITE_NOT_EXISTS;
            goto Cleanup;
        }

        lResult = RegOpenKeyExA(hkSites,
                                szSiteName,
                                0,
                                KEY_ALL_ACCESS,
                                &hkPassport);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't find site key in registry.  Reinstall Passport.",
                           IID_IPassportAdminEx,
                           PP_E_SITE_NOT_EXISTS);

            hr = PP_E_SITE_NOT_EXISTS;
            goto Cleanup;
        }
    }
    else
    {
        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               PASSPORT_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hkPassport);

        if(lResult != ERROR_SUCCESS)
        {
            AtlReportError(CLSID_Admin, 
                           L"Couldn't find Passport key in registry.  Reinstall Passport.",
                           IID_IPassportAdminEx,
                           E_FAIL);

            hr = E_FAIL;
            goto Cleanup;
        }
    }

    lResult = RegOpenKeyEx(hkPassport, KEYTIMES_SUBKEY, 0, KEY_WRITE, &hkTimeKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find KeyTimes key in registry.  Reinstall Passport.",
                       IID_IPassportAdminEx,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }

    szKeyNum[0] = KeyVerI2C(version);
    szKeyNum[1] = '\0';

    if (fromNow == 0)
    {
        RegDeleteValueA(hkTimeKey, szKeyNum);
    }
    else
    {
        time_t now;
        time(&now);
        now += fromNow;
        DWORD dwT = now;
        lResult = RegSetValueExA(hkTimeKey, szKeyNum, 0, REG_DWORD, (LPBYTE) &dwT, sizeof(DWORD));

        if (lResult != ERROR_SUCCESS)
	{
            AtlReportError(CLSID_Admin, 
                           L"Couldn't write KeyTime key to registry.",
                           IID_IPassportAdminEx,
                           E_FAIL);

            hr = E_FAIL;
            goto Cleanup;
	}
    }

Cleanup:

    if (hkSites)
    {
        RegCloseKey(hkSites);
    }

    if (hkPassport)
    {
        RegCloseKey(hkPassport);
    }

    if (hkTimeKey)
    {
        RegCloseKey(hkTimeKey);
    }

    return hr;
}


//===========================================================================
//
//  get_currentKeyVersion
//

STDMETHODIMP CAdmin::get_currentKeyVersion(int *pVal)
{
    if (!g_config || !g_config->isValid()) // Guarantees config is non-null
    {
        *pVal = -1;
        return S_OK;
    }

    CRegistryConfig* crc = g_config->checkoutRegistryConfig();
    *pVal = crc->getCurrentCryptVersion();
    crc->Release();
    return S_OK;
}


//===========================================================================
//
//  getCurrentKeyVersionEx
//

STDMETHODIMP CAdmin::getCurrentKeyVersionEx(
    VARIANT vSiteName,
    int *pVal
    )
{
    HRESULT           hr;
    LPSTR             szSiteName;
    CRegistryConfig*  crc = NULL;

    USES_CONVERSION;

    if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
    {
        szSiteName = NULL;
    }
    else if(vSiteName.vt == VT_BSTR)
    {
        szSiteName = W2A(vSiteName.bstrVal);
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!g_config || !g_config->isValid()) // Guarantees config is non-null
    {
        *pVal = -1;
        hr = S_OK;
        goto Cleanup;
    }

    crc = g_config->checkoutRegistryConfigBySite(szSiteName);

    if(szSiteName && crc == NULL)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find site key in registry.  Reinstall Passport.",
                       IID_IPassportAdminEx, 
                       PP_E_SITE_NOT_EXISTS);

        hr = PP_E_SITE_NOT_EXISTS;
        goto Cleanup;
    }

    if(crc == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *pVal = crc->getCurrentCryptVersion();

    hr = S_OK;

Cleanup:

    if(crc)
    {
        crc->Release();
    }

    return S_OK;
}


//===========================================================================
//
//  putCurrentKeyVersionEx
//

STDMETHODIMP CAdmin::put_currentKeyVersion(int Val)
{
    HRESULT hr = S_OK, lResult;
    HKEY  hkKey = NULL;
    DWORD dwCK = Val;

    if (Val < KEY_VERSION_MIN || Val > KEY_VERSION_MAX)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PASSPORT_KEY, 0, KEY_WRITE, &hkKey);

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
                       L"Couldn't find Passport key in registry.  Reinstall Passport.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }
  
    lResult = RegSetValueExA(hkKey, "CurrentKey", 0, REG_DWORD, (LPBYTE) &dwCK, sizeof(DWORD));

    if(lResult != ERROR_SUCCESS)
    {
        AtlReportError(CLSID_Admin, 
		       L"Couldn't write CurrentKey value to registry.",
                       IID_IPassportAdmin,
                       E_FAIL);

        hr = E_FAIL;
        goto Cleanup;
    }
  
Cleanup:

    if (hkKey)
    {
        RegCloseKey(hkKey);
    }

    return hr;
}


//===========================================================================
//
//  putCurrentKeyVersionEx
//

STDMETHODIMP CAdmin::putCurrentKeyVersionEx(
    int Val,
    VARIANT vSiteName
    )
{
  HRESULT hr = S_OK, lResult;
  LPSTR szSiteName;
  HKEY  hkPassport = NULL, hkSites = NULL;
  DWORD dwCK = Val;

  USES_CONVERSION;

  if (Val < KEY_VERSION_MIN || Val > KEY_VERSION_MAX)
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  if(vSiteName.vt == VT_ERROR && vSiteName.scode == DISP_E_PARAMNOTFOUND)
      szSiteName = NULL;
  else if(vSiteName.vt == VT_BSTR)
      szSiteName = W2A(vSiteName.bstrVal);
  else
  {
      hr = E_INVALIDARG;
      goto Cleanup;
  }

  if(szSiteName)
  {
      lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             SITES_KEY,
                             0,
                             KEY_ALL_ACCESS,
                             &hkSites);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Sites key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }

      lResult = RegOpenKeyExA(hkSites,
                              szSiteName,
                              0,
                              KEY_ALL_ACCESS,
                              &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find site key in registry.  Reinstall Passport.", IID_IPassportAdminEx, 
                 PP_E_SITE_NOT_EXISTS);
          hr = PP_E_SITE_NOT_EXISTS;
          goto Cleanup;
      }
  }
  else
  {
      lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             PASSPORT_KEY,
                             0,
                             KEY_ALL_ACCESS,
                             &hkPassport);
      if(lResult != ERROR_SUCCESS)
      {
          AtlReportError(CLSID_Admin, 
		         L"Couldn't find Passport key in registry.  Reinstall Passport.", IID_IPassportAdminEx, E_FAIL);
          hr = E_FAIL;
          goto Cleanup;
      }
  }

  lResult = RegSetValueExA(hkPassport, "CurrentKey", 0,
			   REG_DWORD, (LPBYTE) &dwCK, sizeof(DWORD));
  if(lResult != ERROR_SUCCESS)
    {
      AtlReportError(CLSID_Admin, 
		     L"Couldn't write CurrentKey value to registry.", IID_IPassportAdminEx, E_FAIL);
      hr = E_FAIL;
      goto Cleanup;
    }
  
 Cleanup:
  if (hkPassport)
    RegCloseKey(hkPassport);
  if (hkSites)
    RegCloseKey(hkSites);
  return hr;

}

//===========================================================================
//
//  Refresh
//

STDMETHODIMP CAdmin::Refresh(
    VARIANT_BOOL    bWait,
    VARIANT_BOOL*   pbSuccess
    )
{
    HRESULT hr;

    if(pbSuccess == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pbSuccess = (g_config->UpdateNow(TRUE) ? VARIANT_TRUE : VARIANT_FALSE);
    hr = S_OK;

Cleanup:

    return hr;
}

//===========================================================================
//
//  setNexusPassword
//

STDMETHODIMP CAdmin::setNexusPassword(
    BSTR    bstrPwd
    )
{
    HRESULT     hr;

    BYTE        original[CKeyCrypto::RAWKEY_SIZE];
    DATA_BLOB   iBlob;
    DATA_BLOB   oBlob = {0};
    CKeyCrypto  kc;
    long        lResult;
    HKEY        hkNexus = NULL;

    USES_CONVERSION;

    ZeroMemory(original,  sizeof(original));

    strncpy((char*) original, W2A(bstrPwd), sizeof(original));
    original[sizeof(original) - 1] = '\0';

    iBlob.cbData = sizeof(original);
    iBlob.pbData = &(original[0]);

    hr = kc.encryptKey(&iBlob, &oBlob);

    if(hr != S_OK)
    {
        goto Cleanup;
    }

    //
    //  Now we have an encrypted key, put it in the registry.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           NEXUS_KEY,
                           0,
                           KEY_SET_VALUE,
                           &hkNexus);

    if(lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lResult = RegSetValueEx(hkNexus,
                            TEXT("CCDPassword"),
                            0,
                            REG_BINARY,
                            oBlob.pbData,
                            oBlob.cbData
                            );
    if(lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }                          
    
    hr = S_OK;

Cleanup:

    if(hkNexus)
        RegCloseKey(hkNexus);

    if (oBlob.pbData)
        ::LocalFree(oBlob.pbData);

    return hr;
}


//===========================================================================
//
// Helper routine to create/set the CCDPassword registry value
//

HRESULT SetCCDPassword(VOID)
{
    HRESULT         hr;
    LPSTR           szString = "La3b$7Q@93P*JX";
    BYTE            szResult[MAX_CCDPASSWORD_LEN];
    BYTE            szInput[CKeyCrypto::RAWKEY_SIZE] = {0};
    DATA_BLOB       iBlob, oBlob = {0};
    CKeyCrypto      kc;
    LONG            lResult;
    HKEY            hKey;

    strncpy((char *) szInput, szString, sizeof(szInput));
    szInput[sizeof(szInput) - 1] = '\0';

    iBlob.cbData = sizeof(szInput);
    iBlob.pbData = (LPBYTE) szInput;

    hr = kc.encryptKey(&iBlob, &oBlob);

    //
    // Setup restricts size of string to be less than 256
    //

    if (hr == S_OK)
    {
        if (oBlob.cbData >= MAX_CCDPASSWORD_LEN)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            memcpy(szResult, oBlob.pbData, oBlob.cbData);
        }
    }

    if (oBlob.pbData)
    {
        LocalFree(oBlob.pbData);
    }

    if (hr != S_OK)
    {
        return hr;
    }

    //
    // Password's encrypted, now set it in the registry
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           NEXUS_KEY,
                           0,
                           KEY_SET_VALUE,
                           &hKey);

    if (lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        return hr;
    }

    lResult = RegSetValueExA(hKey,
                             "CCDPassword",
                             0,
                             REG_BINARY,
                             szResult,
                             oBlob.cbData);

    if(lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    RegCloseKey(hKey);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\fastauth.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    fastauth.cpp
       COM object for fast auth interface


    FILE HISTORY:

*/

// FastAuth.cpp : Implementation of CFastAuth
#include "stdafx.h"
#include <time.h>
#include <httpfilt.h>
#include <httpext.h>
#include "Passport.h"
#include "FastAuth.h"
#include "Ticket.h"
#include "Profile.h"
#include "VariantUtils.h"
#include "PMErrorCodes.h"
#include "HelperFuncs.h"


#define DIMENSION(a) (sizeof(a) / sizeof(a[0]))


/////////////////////////////////////////////////////////////////////////////
// CFastAuth

//===========================================================================
//
// InterfaceSupportsErrorInfo 
//

STDMETHODIMP CFastAuth::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_IPassportFastAuth,
        &IID_IPassportFastAuth2,
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


//===========================================================================
//
// LogoTag 
//

//
//  old API. href to login
//
STDMETHODIMP
CFastAuth::LogoTag(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrLogoTag
    )
{
    return  CommonLogoTag(bstrTicket,
                          bstrProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          FALSE,
                          pbstrLogoTag);

}

//===========================================================================
//
// LogoTag2 
//

//
//  new API. href back to partner
//
STDMETHODIMP
CFastAuth::LogoTag2(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrLogoTag
    )
{
    return  CommonLogoTag(bstrTicket,
                          bstrProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          TRUE,
                          pbstrLogoTag);

}

//===========================================================================
//
// CommonLogoTag 
//

//
//  logotag impl
//
STDMETHODIMP
CFastAuth::CommonLogoTag(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BOOL            fRedirToSelf,
    BSTR*           pbstrLogoTag
    )
{
    HRESULT                     hr;
    CComObject<CTicket>         *pTicket = NULL;
    CComObject<CProfile>        *pProfile = NULL;
    
    time_t                      ct;
    ULONG                       TimeWindow;
    int                         nKPP;
    VARIANT_BOOL                ForceLogin, bSecure = VARIANT_FALSE;
    ULONG                       ulSecureLevel = 0;
    BSTR                        CBT = NULL, returnUrl = NULL, bstrSiteName = NULL, bstrNameSpace = NULL;
    int                         hasCB = -1, hasRU = -1, hasLCID, hasTW, hasFL, hasSec, hasSiteName, hasNameSpace = -1, hasUseSec;
    int                         hasKPP = -1;
    USHORT                      Lang;
    CNexusConfig*               cnc = NULL;
    CRegistryConfig*            crc = NULL;
    VARIANT_BOOL                bTicketValid,bProfileValid;
    LPSTR                       szSiteName;
    VARIANT                     vFalse;

    USES_CONVERSION;

    PassportLog("CFastAuth::CommonLogoTag Enter:\r\n");
    if (NULL != bstrTicket)
    {
        PassportLog("    %ws\r\n", bstrTicket);
    }
    if (NULL != bstrProfile)
    {
        PassportLog("    %ws\r\n", bstrProfile);
    }

    if (NULL == pbstrLogoTag)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pbstrLogoTag = NULL;

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    //
    // due to STL the allocations of CTicket and CProfile can AV in low memory conditions
    //
    try
    {
        // ticket object
        pTicket = new CComObject<CTicket>();
        if (NULL == pTicket)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        else
        {
            pTicket->AddRef();
        }

        // profile object
        pProfile = new CComObject<CProfile>();

        if (NULL == pProfile)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        else
        {
            pProfile->AddRef();
        }
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //  Get site name if any...
    hasSiteName = GetBstrArg(vSiteName, &bstrSiteName);
    if(hasSiteName == CV_OK || hasSiteName == CV_FREE)
        szSiteName = W2A(bstrSiteName);
    else
        szSiteName = NULL;

    if(hasSiteName == CV_FREE)
        SysFreeString(bstrSiteName);

    cnc = g_config->checkoutNexusConfig();
    crc = g_config->checkoutRegistryConfig(szSiteName);

    hr = DecryptTicketAndProfile(bstrTicket,
                                 bstrProfile,
                                 FALSE,
                                 NULL,
                                 crc,
                                 pTicket,
                                 pProfile);

    if (hr != S_OK)
    {
        goto Cleanup;
    }

    VariantInit(&vFalse);
    vFalse.vt = VT_BOOL;
    vFalse.boolVal = VARIANT_FALSE;

    pTicket->get_IsAuthenticated(0,
                                  VARIANT_FALSE,
                                  vFalse,
                                  &bTicketValid);

    pProfile->get_IsValid(&bProfileValid);

    time(&ct);

    // Make sure args are of the right type
    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasSec = GetBoolArg(vSecure,&bSecure)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasUseSec = GetIntArg(vUseSecureAuth,(int*)&ulSecureLevel)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hasCB = GetBstrArg(vCoBrand, &CBT);

    if (hasCB == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasCB == CV_FREE) { TAKEOVER_BSTR(CBT); }

    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            SysFreeString(CBT);
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasRU == CV_FREE) { TAKEOVER_BSTR(returnUrl); }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT) SysFreeString(CBT);
        if (hasRU == CV_FREE && returnUrl) SysFreeString(returnUrl);
        return E_INVALIDARG;
    }
    if (hasNameSpace == CV_FREE)
    {
        TAKEOVER_BSTR(bstrNameSpace);
    }
    if (hasNameSpace == CV_DEFAULT)
    {
        bstrNameSpace = crc->getNameSpace();
    }


    WCHAR *szSIAttrName, *szSOAttrName;
    if (hasSec == CV_OK && bSecure != VARIANT_FALSE)
    {
        szSIAttrName = L"SecureSigninLogo";
        szSOAttrName = L"SecureSignoutLogo";
    }
    else
    {
        szSIAttrName = L"SigninLogo";
        szSOAttrName = L"SignoutLogo";
    }

    WCHAR *szAUAttrName;
    if (hasUseSec == CV_OK && SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    if (hasLCID == CV_DEFAULT)
        Lang = crc->getDefaultLCID();

    if (hasTW == CV_DEFAULT)
        TimeWindow = crc->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = crc->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = crc->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = crc->getDefaultRU();
    if (hasKPP == CV_DEFAULT)
        nKPP = -1;
    if (returnUrl == NULL)
        returnUrl = L"";

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        //
        // 20 will always be more than large enough for a ULONG
        //

        WCHAR buf[20];

        _itow(TimeWindow,buf,10);
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE,
                             PM_TIMEWINDOW_INVALID, buf);
        AtlReportError(CLSID_FastAuth, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

    if (bTicketValid)
    {
        LPCWSTR domain = NULL;
        WCHAR url[1025];
        VARIANT freeMe;
        VariantInit(&freeMe);

        if (crc->DisasterModeP())
        {
            lstrcpynW(url, crc->getDisasterUrl(), DIMENSION(url) - 1);
            url[DIMENSION(url) - 1] = L'\0';
        }
        else
        {
            if (bProfileValid &&
                pProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe) == S_OK &&
                freeMe.vt == VT_BSTR)
            {
                domain = wcsrchr(freeMe.bstrVal, L'@');
            }

            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    L"Logout",
                                    DIMENSION(url) - 1,
                                    url,
                                    Lang);

            url[DIMENSION(url) - 1] = L'\0';
        }

        // find out if there are any updates

        WCHAR iurl[1025];
        BSTR upd = NULL;

        pProfile->get_updateString(&upd);

        if (upd)
        {
            TAKEOVER_BSTR(upd);
            // form the appropriate URL
            CCoCrypt* crypt = NULL;
            BSTR newCH = NULL;
            crypt = crc->getCurrentCrypt(); // IsValid ensures this is non-null
            // This should never fail... (famous last words)
            if (!crypt->Encrypt(crc->getCurrentCryptVersion(),
                                (LPSTR)upd,
                                SysStringByteLen(upd),
                                &newCH))
            {
                AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_UNABLE_TO_ENCRYPTSTR,
                               IID_IPassportManager, PP_E_UNABLE_TO_ENCRYPT);
                hr = PP_E_UNABLE_TO_ENCRYPT;
                goto Cleanup;
            }
            FREE_BSTR(upd);
            TAKEOVER_BSTR(newCH);
            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    L"Update",
                                    DIMENSION(iurl) - 1,
                                    iurl,
                                    Lang);

            iurl[DIMENSION(iurl) - 1] = L'\0';

            // This is a bit gross... we need to find the $1 in the update url...
            // We'll break if null, but won't crash...
            if (*url != L'\0')
                *pbstrLogoTag = FormatUpdateLogoTag(
                                        url,
                                        crc->getSiteId(),
                                        returnUrl,
                                        TimeWindow,
                                        ForceLogin,
                                        crc->getCurrentCryptVersion(),
                                        ct,
                                        CBT,
                                        nKPP,
                                        (*iurl == L'\0' ? NULL : iurl),
                                        bSecure,
                                        newCH,
                                        PM_LOGOTYPE_SIGNOUT,
                                        ulSecureLevel,
                                        crc,
                                        TRUE
                                        );
            FREE_BSTR(newCH);
        }
        else
        {
            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    szSOAttrName,
                                    DIMENSION(iurl),
                                    iurl,
                                    Lang);

            iurl[DIMENSION(iurl) - 1] = L'\0';

            if (*iurl != L'\0')
                *pbstrLogoTag = FormatNormalLogoTag(
                                        url,
                                        crc->getSiteId(),
                                        returnUrl,
                                        TimeWindow,
                                        ForceLogin,
                                        crc->getCurrentCryptVersion(),
                                        ct,
                                        CBT,
                                        iurl,
                                        NULL,
                                        nKPP,
                                        PM_LOGOTYPE_SIGNOUT,
                                        Lang,
                                        ulSecureLevel,
                                        crc,
                                        fRedirToSelf,
                                        TRUE
                                        );
        }
        VariantClear(&freeMe);
        if (NULL == *pbstrLogoTag)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else
    {
        WCHAR url[1025];
        WCHAR iurl[1025];

        if (!crc->DisasterModeP())
        {
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    DIMENSION(url),
                                    url,
                                    Lang);

            url[DIMENSION(url) - 1] = L'\0';
        }
        else
        {
            lstrcpynW(url, crc->getDisasterUrl(), DIMENSION(url));

            url[DIMENSION(url) - 1] = L'\0';
        }

        cnc->getDomainAttribute(L"Default",
                                szSIAttrName,
                                DIMENSION(iurl),
                                iurl,
                                Lang);

        iurl[DIMENSION(iurl) - 1] = L'\0';

        if (*iurl != L'\0')
        {
            *pbstrLogoTag = FormatNormalLogoTag(
                                    url,
                                    crc->getSiteId(),
                                    returnUrl,
                                    TimeWindow,
                                    ForceLogin,
                                    crc->getCurrentCryptVersion(),
                                    ct,
                                    CBT,
                                    iurl,
                                    bstrNameSpace,
                                    nKPP,
                                    PM_LOGOTYPE_SIGNIN,
                                    Lang,
                                    ulSecureLevel,
                                    crc,
                                    fRedirToSelf,
                                    TRUE
                                    );
            if (NULL == *pbstrLogoTag)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }

    hr = S_OK;

Cleanup:
    PassportLog("CFastAuth::CommonLogoTag Exit:  %X\r\n", hr);
    if ((NULL != pbstrLogoTag) && (NULL != *pbstrLogoTag))
    {
        PassportLog("    %ws\r\n", *pbstrLogoTag);
    }

    if (pTicket)
        pTicket->Release();
    if (pProfile)
        pProfile->Release();

    if (crc) crc->Release();
    if (cnc) cnc->Release();

    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);
    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);
    if (hasNameSpace == CV_FREE && bstrNameSpace)
        FREE_BSTR(bstrNameSpace);

    return hr;
}


//===========================================================================
//
// IsAuthenticated 
//

STDMETHODIMP
CFastAuth::IsAuthenticated(
    BSTR            bstrTicket,
    BSTR            bstrProfile,
    VARIANT         vSecure,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vSiteName,
    VARIANT         vDoSecureCheck,
    VARIANT_BOOL*   pbAuthenticated
    )
{
    HRESULT                     hr;
    CComObject<CTicket>         *pTicket = NULL;
    CComObject<CProfile>        *pProfile = NULL;

    CRegistryConfig*            crc = NULL;
    ULONG                       TimeWindow;
    VARIANT_BOOL                ForceLogin, bTicketValid, bProfileValid;
    int                         hasSec = CV_DEFAULT, hasTW = CV_DEFAULT, hasFL = CV_DEFAULT, hasSiteName = CV_DEFAULT;
    BSTR                        bstrSecure, bstrSiteName;
    LPSTR                       szSiteName;
    VARIANT                     vFalse;

    USES_CONVERSION;

    PassportLog("CFastAuth::IsAuthenticated Enter:\r\n");
    if (NULL != bstrTicket)
    {
        PassportLog("    %ws\r\n", bstrTicket);
    }
    if (NULL != bstrProfile)
    {
        PassportLog("    %ws\r\n", bstrProfile);
    }

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hasSec = GetBstrArg(vSecure, &bstrSecure);
    if(hasSec == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(hasSec == CV_DEFAULT)
        bstrSecure = NULL;

    hasSiteName = GetBstrArg(vSiteName, &bstrSiteName);
    if(hasSiteName == CV_OK || hasSiteName == CV_FREE)
    {
        szSiteName = W2A(bstrSiteName);

        PassportLog("    %ws\r\n", szSiteName);
    }
    else
        szSiteName = NULL;

    if(hasSiteName == CV_FREE)
        SysFreeString(bstrSiteName);

    crc = g_config->checkoutRegistryConfig(szSiteName);

    //
    // due to STL the allocations of CTicket and CProfile can AV in low memory conditions
    //
    try
    {
        // ticket object
        pTicket = new CComObject<CTicket>();
        if (NULL == pTicket)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        else
        {
            pTicket->AddRef();
        }

        // profile object
        pProfile = new CComObject<CProfile>();

        if (NULL == pProfile)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        else
        {
            pProfile->AddRef();
        }
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = DecryptTicketAndProfile(bstrTicket,
                                 NULL,
                                 FALSE,
                                 NULL,
                                 crc,
                                 pTicket,
                                 pProfile);

    if(hr != S_OK)
    {
        goto Cleanup;
    }

    VariantInit(&vFalse);
    vFalse.vt = VT_BOOL;
    vFalse.boolVal = VARIANT_FALSE;

    pTicket->get_IsAuthenticated(0,
                               VARIANT_FALSE,
                               vFalse,
                               &bTicketValid);

    /*
    // Both profile AND ticket must be valid to be authenticated
    // (as of 1.3, this is no longer true).

    Profile.get_IsValid(&bProfileValid);

    if (!bProfileValid)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    */

    if ((hasTW = GetIntArg(vTimeWindow,(int*)&TimeWindow)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasTW == CV_DEFAULT)
        TimeWindow = crc->getDefaultTicketAge();

    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasFL == CV_DEFAULT)
        ForceLogin = crc->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;

    PassportLog("    TW = %X\r\n", TimeWindow);

    hr = pTicket->get_IsAuthenticated(TimeWindow, ForceLogin, vDoSecureCheck, pbAuthenticated);

Cleanup:
    PassportLog("CFastAuth::IsAuthenticated Exit\r\n");

    if (pTicket)
        pTicket->Release();
    if (pProfile)
        pProfile->Release();

    if (crc) crc->Release();

    if(hasSec == CV_FREE)
        SysFreeString(bstrSecure);

    if(hr != S_OK)
    {
        *pbAuthenticated = VARIANT_FALSE;
    }

    return hr;
}


//===========================================================================
//
// AuthURL 
//

//
//  old API. Auth URL goes to login
//
STDMETHODIMP
CFastAuth::AuthURL(
    VARIANT         vTicket,
    VARIANT         vProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vReserved1,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrAuthURL
    )
{
    return  CommonAuthURL(vTicket,
                          vProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vReserved1,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          FALSE,
                          pbstrAuthURL);

}

//===========================================================================
//
// AuthURL2 
//

//
//  new API. Auth URL points to partner
//
STDMETHODIMP
CFastAuth::AuthURL2(
    VARIANT         vTicket,
    VARIANT         vProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vReserved1,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BSTR*           pbstrAuthURL
    )
{
    return  CommonAuthURL(vTicket,
                          vProfile,
                          vRU,
                          vTimeWindow,
                          vForceLogin,
                          vCoBrand,
                          vLCID,
                          vSecure,
                          vLogoutURL,
                          vReserved1,
                          vSiteName,
                          vNameSpace,
                          vKPP,
                          vUseSecureAuth,
                          TRUE,
                          pbstrAuthURL);

}

//===========================================================================
//
// CommonAuthURL 
//

STDMETHODIMP
CFastAuth::CommonAuthURL(
    VARIANT         vTicket,
    VARIANT         vProfile,
    VARIANT         vRU,
    VARIANT         vTimeWindow,
    VARIANT         vForceLogin,
    VARIANT         vCoBrand,
    VARIANT         vLCID,
    VARIANT         vSecure,
    VARIANT         vLogoutURL,
    VARIANT         vReserved1,
    VARIANT         vSiteName,
    VARIANT         vNameSpace,
    VARIANT         vKPP,
    VARIANT         vUseSecureAuth,
    BOOL            fRedirToSelf,
    BSTR*           pbstrAuthURL
    )
{
    HRESULT                     hr;
    BSTR                        bstrTicket = NULL;
    BSTR                        bstrProfile = NULL;
    CComObject<CTicket>         *pTicket = NULL;
    CComObject<CProfile>        *pProfile = NULL;
    
    time_t                      ct;
    WCHAR                       url[1025];
    VARIANT                     freeMe;
    UINT                        TimeWindow;
    int                         nKPP;
    VARIANT_BOOL                ForceLogin;
    VARIANT_BOOL                bTicketValid;
    VARIANT_BOOL                bProfileValid;
    ULONG                       ulSecureLevel = 0;
    BSTR                        CBT = NULL, returnUrl = NULL, bstrSiteName = NULL, bstrNameSpace = NULL;
    int                         hasCB = -1, hasRU = -1, hasLCID, hasTW, hasFL, hasNameSpace = -1, hasUseSec;
    int                         hasTicket = -1, hasProfile = -1, hasSiteName = -1, hasKPP = -1;
    USHORT                      Lang;
    CNexusConfig*               cnc = NULL;
    CRegistryConfig*            crc = NULL;
    LPSTR                       szSiteName;
    VARIANT                     vFalse;

    USES_CONVERSION;

    PassportLog("CFastAuth::CommonAuthURL Enter:\r\n");

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hasSiteName = GetBstrArg(vSiteName, &bstrSiteName);
    if(hasSiteName == CV_OK || hasSiteName == CV_FREE)
        szSiteName = W2A(bstrSiteName);
    else
        szSiteName = NULL;

    if(hasSiteName == CV_FREE)
        SysFreeString(bstrSiteName);

    cnc = g_config->checkoutNexusConfig();
    crc = g_config->checkoutRegistryConfig(szSiteName);

    // Make sure args are of the right type
    if ((hasTicket = GetBstrArg(vTicket, &bstrTicket)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasProfile = GetBstrArg(vProfile, &bstrProfile)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (NULL != bstrTicket)
    {
        PassportLog("    %ws\r\n", bstrTicket);
    }
    if (NULL != bstrProfile)
    {
        PassportLog("    %ws\r\n", bstrProfile);
    }

    //
    // due to STL the allocations of CTicket and CProfile can AV in low memory conditions
    //
    try
    {
        // ticket object
        pTicket = new CComObject<CTicket>();
        if (NULL == pTicket)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        else
        {
            pTicket->AddRef();
        }

        // profile object
        pProfile = new CComObject<CProfile>();

        if (NULL == pProfile)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        else
        {
            pProfile->AddRef();
        }
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(hasTicket != CV_DEFAULT && hasProfile != CV_DEFAULT)
    {
        hr = DecryptTicketAndProfile(bstrTicket, bstrProfile, FALSE, NULL, crc, pTicket, pProfile);

        if(hr != S_OK)
        {
            bTicketValid = VARIANT_FALSE;
            bProfileValid = VARIANT_FALSE;
        }
        else
        {
            VariantInit(&vFalse);
            vFalse.vt = VT_BOOL;
            vFalse.boolVal = VARIANT_FALSE;

            pTicket->get_IsAuthenticated(0,
                              VARIANT_FALSE,
                              vFalse,
                              &bTicketValid);
            pProfile->get_IsValid(&bProfileValid);
        }
    }
    else
    {
        bTicketValid = VARIANT_FALSE;
        bProfileValid = VARIANT_FALSE;
    }

    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasUseSec = GetIntArg(vUseSecureAuth, (int*)&ulSecureLevel)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasCB == CV_FREE) { TAKEOVER_BSTR(CBT); }
    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            FREE_BSTR(CBT);
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasRU == CV_FREE) { TAKEOVER_BSTR(returnUrl); }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasNameSpace == CV_FREE)
    {
        TAKEOVER_BSTR(bstrNameSpace);
    }
    if (hasNameSpace == CV_DEFAULT)
    {
        bstrNameSpace = crc->getNameSpace();
    }

    if (hasLCID == CV_DEFAULT)
        Lang = crc->getDefaultLCID();
    if (hasKPP == CV_DEFAULT)
        nKPP = -1;

    WCHAR *szAUAttrName;
    if (hasUseSec == CV_OK && SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    VariantInit(&freeMe);

    if (!crc->DisasterModeP())
    {
        // If I'm authenticated, get my domain specific url
        if (bTicketValid && bProfileValid)
        {
            hr = pProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe);
            if (hr != S_OK || freeMe.vt != VT_BSTR)
            {
                cnc->getDomainAttribute(L"Default",
                                        szAUAttrName,
                                        DIMENSION(url) - 1,
                                        url,
                                        Lang);

                url[DIMENSION(url) - 1] = L'\0';
            }
            else
            {
                LPCWSTR psz = wcsrchr(freeMe.bstrVal, L'@');
                cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAUAttrName,
                                        DIMENSION(url) - 1,
                                        url,
                                        Lang);

                url[DIMENSION(url) - 1] = L'\0';
            }
        }
        else
        {
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    DIMENSION(url) - 1,
                                    url,
                                    Lang);

            url[DIMENSION(url) - 1] = L'\0';
        }
    }
    else
    {
        lstrcpynW(url, crc->getDisasterUrl(), DIMENSION(url) - 1);
        url[DIMENSION(url) - 1] = L'\0';
    }

    time(&ct);

    if (!url)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (hasTW == CV_DEFAULT)
        TimeWindow = crc->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = crc->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = crc->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = crc->getDefaultRU();
    if (returnUrl == NULL)
        returnUrl = L"";

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        //
        // 20 will always be more than large enough for a ULONG
        //

        WCHAR buf[20];

        _itow(TimeWindow,buf,10);

        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE,
            PM_TIMEWINDOW_INVALID, buf);

        AtlReportError(CLSID_FastAuth, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TIMEWINDOW);

        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

    if (NULL == pbstrAuthURL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pbstrAuthURL = FormatAuthURL(
                            url,
                            crc->getSiteId(),
                            returnUrl,
                            TimeWindow,
                            ForceLogin,
                            crc->getCurrentCryptVersion(),
                            ct,
                            CBT,
                            bstrNameSpace,
                            nKPP,
                            Lang,
                            ulSecureLevel,
                            crc,
                            fRedirToSelf,
                            TRUE
                            );
    if (NULL == *pbstrAuthURL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    PassportLog("CFastAuth::CommonAuthURL Exit:  %X\r\n", hr);

    if (pTicket)
        pTicket->Release();
    if (pProfile)
        pProfile->Release();

    if(cnc) cnc->Release();
    if(crc) crc->Release();
    if (hasTicket == CV_FREE && bstrTicket)
        FREE_BSTR(bstrTicket);
    if (hasProfile == CV_FREE && bstrProfile)
        FREE_BSTR(bstrProfile);
    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);
    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);
    if (hasNameSpace == CV_FREE && bstrNameSpace)
        FREE_BSTR(bstrNameSpace);
    VariantClear(&freeMe);

    return hr;
}


//===========================================================================
//
// GetTicketAndProfilePFC 
//

HRESULT
CFastAuth::GetTicketAndProfilePFC(
    BYTE*   pbPFC,
    BYTE*   pbPPH,
    BSTR*   pbstrTicket,
    BSTR*   pbstrProfile,
    BSTR*   pbstrSecure,
    BSTR*   pbstrSiteName
    )
{
    HTTP_FILTER_CONTEXT*            pfc = (HTTP_FILTER_CONTEXT*)pbPFC;
    HTTP_FILTER_PREPROC_HEADERS*    pph = (HTTP_FILTER_PREPROC_HEADERS*)pbPPH;
    BSTR                            bstrF = NULL;
    CHAR                            achBuf[2048];
    DWORD                           dwBufLen;
    LPSTR                           pszQueryString;
    HRESULT                         hr = S_FALSE;

    USES_CONVERSION;

    dwBufLen = DIMENSION(achBuf);

    if(GetSiteNamePFC(pfc, achBuf, &dwBufLen) == S_OK)
        *pbstrSiteName = SysAllocString(A2W(achBuf));
    else
        *pbstrSiteName = NULL;

    dwBufLen = DIMENSION(achBuf);

    if(pph->GetHeader(pfc, "URL", achBuf, &dwBufLen))
    {
        pszQueryString = strchr(achBuf, '?');
        if(pszQueryString)
        {
            pszQueryString++;

            if(GetQueryData(achBuf, pbstrTicket, pbstrProfile, &bstrF))
            {
                PassportLog("CFastAuth::GetTicketAndProfilePFC  URL: %s\r\n", achBuf);

                *pbstrSecure = NULL;
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

    dwBufLen = DIMENSION(achBuf);

    if(pph->GetHeader(pfc, "Cookie:", achBuf, &dwBufLen))
    {
        if(!GetCookie(achBuf, "MSPAuth", pbstrTicket))
        {
            goto Cleanup;
        }

        GetCookie(achBuf, "MSPProf", pbstrProfile);
        GetCookie(achBuf, "MSPSecAuth", pbstrSecure);

        hr = S_OK;
    }
Cleanup:
    PassportLog("CFastAuth::GetTicketAndProfilePFC  Exit: %X\r\n", hr);

    if (bstrF)
    {
        FREE_BSTR(bstrF);
    }
    return hr;
}


//===========================================================================
//
// GetTicketAndProfileECB 
//

HRESULT
CFastAuth::GetTicketAndProfileECB(
    BYTE*   pbECB,
    BSTR*   pbstrTicket,
    BSTR*   pbstrProfile,
    BSTR*   pbstrSecure,
    BSTR*   pbstrSiteName
    )
{
    EXTENSION_CONTROL_BLOCK*    pECB = (EXTENSION_CONTROL_BLOCK*)pbECB;
    CHAR                        achBuf[2048];
    DWORD                       dwBufLen;
    BSTR                        bstrF;

    USES_CONVERSION;

    dwBufLen = DIMENSION(achBuf);

    if(GetSiteNameECB(pECB, achBuf, &dwBufLen) == S_OK)
        *pbstrSiteName = SysAllocString(A2W(achBuf));
    else
        *pbstrSiteName = NULL;

    dwBufLen = DIMENSION(achBuf);

    if(pECB->GetServerVariable(pECB, "QUERY_STRING", achBuf, &dwBufLen))
    {
        if(GetQueryData(achBuf, pbstrTicket, pbstrProfile, &bstrF))
        {
            PassportLog("CFastAuth::GetTicketAndProfilePFC  QS: %s\r\n", achBuf);

            *pbstrSecure = NULL;
            return S_OK;
        }
    }

    dwBufLen = DIMENSION(achBuf);

    if(pECB->GetServerVariable(pECB, "HTTP_COOKIE", achBuf, &dwBufLen))
    {
        if(!GetCookie(achBuf, "MSPAuth", pbstrTicket))
            return S_FALSE;

        GetCookie(achBuf, "MSPProf", pbstrProfile);
        GetCookie(achBuf, "MSPSecAuth", pbstrSecure);

        return S_OK;
    }

    PassportLog("CFastAuth::GetTicketAndProfilePFC  Failed: %s\r\n", achBuf);

    return S_FALSE;
}


//===========================================================================
//
// GetSiteName 
//

HRESULT GetSiteName(
    LPSTR   szServerName,
    LPSTR   szPort,
    LPSTR   szSecure,
    LPSTR   szBuf,
    LPDWORD lpdwBufLen
    )
{
    HRESULT hr;
    DWORD   dwSize;
    int     nLength;
    LPSTR   szPortTest;

    if(!szServerName)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Make sure the string (plus terminating null)
    //  isn't too long to fit into the buffer
    //

    dwSize = lstrlenA(szServerName);
    if(dwSize + 1 > *lpdwBufLen)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Copy the string.
    //

    lstrcpyA(szBuf, szServerName);

    //
    //  Now, if the incoming port is a port other than
    //  80/443, append it to the server name.
    //

    if(szPort && szSecure)
    {
        nLength = lstrlenA(szPort);

        if(lstrcmpA(szSecure, "on") == 0)
            szPortTest = "443";
        else
            szPortTest = "80";

        if(lstrcmpA(szPort, szPortTest) != 0 &&
           (dwSize + nLength + 2) <= *lpdwBufLen)
        {
            szBuf[dwSize] = ':';
            lstrcpyA(&(szBuf[dwSize + 1]), szPort);
            *lpdwBufLen = dwSize + nLength + 2;
        }
        else
            *lpdwBufLen = dwSize + 1;
    }
    else
        *lpdwBufLen = dwSize + 1;

    hr = S_OK;

Cleanup:

    return hr;
}


//===========================================================================
//
// GetSiteNamePFC 
//

HRESULT
GetSiteNamePFC(
    HTTP_FILTER_CONTEXT*    pfc,
    LPSTR                   szBuf,
    LPDWORD                 lpdwBufLen
    )
{
    HRESULT hr;

    LPSTR szServerName = GetServerVariablePFC(pfc, "SERVER_NAME");
    LPSTR szPort       = GetServerVariablePFC(pfc, "SERVER_PORT");
    LPSTR szSecure     = GetServerVariablePFC(pfc, "HTTPS");

    hr = GetSiteName(szServerName, szPort, szSecure, szBuf, lpdwBufLen);

    if(szServerName)
        delete [] szServerName;
    if(szPort)
        delete [] szPort;
    if(szSecure)
        delete [] szSecure;

    return hr;
}

//===========================================================================
//
// GetSiteNameECB 
//

HRESULT
GetSiteNameECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       szBuf,
    LPDWORD                     lpdwBufLen
    )
{
    HRESULT hr;

    LPSTR szServerName = GetServerVariableECB(pECB, "SERVER_NAME");
    LPSTR szPort       = GetServerVariableECB(pECB, "SERVER_PORT");
    LPSTR szSecure     = GetServerVariableECB(pECB, "HTTPS");

    hr = GetSiteName(szServerName, szPort, szSecure, szBuf, lpdwBufLen);

    if(szServerName)
        delete [] szServerName;
    if(szPort)
        delete [] szPort;
    if(szSecure)
        delete [] szSecure;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

//#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "passport_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\alerts.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    alerts.h


    FILE HISTORY:

*/

// gmarks
#include "PassportAlertInterface.h"
#include "pmAlertsDefs.h"
#include "pmalerts.h"

extern PassportAlertInterface*  g_pAlert;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\fastauth.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    FastAuth.h
      defines the CFastAuth class for FastAuth interface


    FILE HISTORY:

*/
    
// FastAuth.h : Declaration of the CFastAuth

#ifndef __FASTAUTH_H_
#define __FASTAUTH_H_

#include "resource.h"       // main symbols
#include "passport.h"


/////////////////////////////////////////////////////////////////////////////
// CFastAuth
class ATL_NO_VTABLE CFastAuth :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CFastAuth, &CLSID_FastAuth>,
    public ISupportErrorInfo,
    public IDispatchImpl<IPassportFastAuth2, &IID_IPassportFastAuth2, &LIBID_PASSPORTLib>
{
public:
    CFastAuth()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FASTAUTH)
DECLARE_NOT_AGGREGATABLE(CFastAuth)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFastAuth)
    COM_INTERFACE_ENTRY(IPassportFastAuth)
    COM_INTERFACE_ENTRY(IPassportFastAuth2)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportFastAuth
    STDMETHOD(LogoTag)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrLogoTag
                    );
    STDMETHOD(LogoTag2)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrLogoTag
                    );

    STDMETHOD(IsAuthenticated)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vSecure,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vSiteName,
                    VARIANT         vDoSecureCheck,
                    VARIANT_BOOL*   pbAuthenticated
                    );

    STDMETHOD(AuthURL)(
                    VARIANT         vTicket,
                    VARIANT         vProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vReserved1,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrAuthURL
                    );
    STDMETHOD(AuthURL2)(
                    VARIANT         vTicket,
                    VARIANT         vProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vReserved1,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BSTR*           pbstrAuthURL
                    );

    STDMETHOD(GetTicketAndProfilePFC)(
                    BYTE*           pbPFC,
                    BYTE*           pbPPH,
                    BSTR*           pbstrTicket,
                    BSTR*           pbstrProfile,
                    BSTR*           pbstrSecure,
                    BSTR*           pbstrSiteName
                    );

    STDMETHOD(GetTicketAndProfileECB)(
                    BYTE*           pbECB,
                    BSTR*           pbstrTicket,
                    BSTR*           pbstrProfile,
                    BSTR*           pbstrSecure,
                    BSTR*           pbstrSiteName
                    );
public:
private:
    STDMETHOD(CommonAuthURL)(
                    VARIANT         vTicket,
                    VARIANT         vProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vReserved1,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BOOL            fRedirToSelf,
                    BSTR*           pbstrAuthURL
                    );
    STDMETHOD(CommonLogoTag)(
                    BSTR            bstrTicket,
                    BSTR            bstrProfile,
                    VARIANT         vRU,
                    VARIANT         vTimeWindow,
                    VARIANT         vForceLogin,
                    VARIANT         vCoBrand,
                    VARIANT         vLangId,
                    VARIANT         vSecure,
                    VARIANT         vLogoutURL,
                    VARIANT         vSiteName,
                    VARIANT         vNameSpace,
                    VARIANT         vKPP,
                    VARIANT         vUseSecureAuth,
                    BOOL            fRedirToSelf,
                    BSTR*           pbstrLogoTag
                    );
};

#endif //__FASTAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\monitoring.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    monitoring.h


    FILE HISTORY:

*/

// gmarks
#include "PassportAlertInterface.h"
#include "pmAlertsDefs.h"
#include "pmalerts.h"

#include "PassportPerfDefs.h"	    	// for SHM name defines
#include "msppcntr.h"		// for counter defines
#include "PassportPerfInterface.h"  // for object interface

extern PassportAlertInterface*  g_pAlert;
extern PassportPerfInterface*  g_pPerf;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\manager.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    manager.h
        Define CManager class for passport manager interface


    FILE HISTORY:

*/
// Manager.h : Declaration of the CManager

#ifndef __MANAGER_H_
#define __MANAGER_H_

#include "resource.h"       // main symbols
#include "Passport.h"
#include "Ticket.h"
#include "Profile.h"
#include "passportservice.h"
#include <httpext.h>
#include <httpfilt.h>

using namespace ATL;

inline bool IsEmptyString(LPCWSTR str)
{
   if (!str) return true;
   if (*str == 0) return true;
   return false;
};

/////////////////////////////////////////////////////////////////////////////
// CManager
class ATL_NO_VTABLE CManager :
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<CManager, &CLSID_Manager>,
        public ISupportErrorInfo,
        public IPassportService,
        public IDispatchImpl<IPassportManager3, &IID_IPassportManager3, &LIBID_PASSPORTLib>,
        public IDomainMap
{
public:
    CManager();
    ~CManager();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_MANAGER)
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CManager)
  COM_INTERFACE_ENTRY(IPassportManager)
  COM_INTERFACE_ENTRY(IPassportManager2)
  COM_INTERFACE_ENTRY(IPassportManager3)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY(ISupportErrorInfo)
  COM_INTERFACE_ENTRY(IPassportService)
  COM_INTERFACE_ENTRY(IDomainMap)
  COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

        HRESULT FinalConstruct()
        {
            if(m_pUnkMarshaler.p != NULL)
                return S_OK;

            return CoCreateFreeThreadedMarshaler(
                        GetControllingUnknown(), &m_pUnkMarshaler.p);
        }

        void FinalRelease()
        {
                m_pUnkMarshaler.Release();
        }

        CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportManager
public:
        STDMETHOD(HaveConsent)(/*[in]*/ VARIANT_BOOL bNeedFullConsent, /*[in]*/ VARIANT_BOOL bNeedBirthdate, /*[out,retval]*/ VARIANT_BOOL* pbHaveConsent);
        STDMETHOD(GetServerInfo)(/*[out,retval]*/ BSTR *pbstrOut);
  STDMETHOD(Commit)(BSTR *newProf);
  STDMETHOD(get_HasSavedPassword)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_ProfileByIndex)(/*[in]*/ int index, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_ProfileByIndex)(/*[in]*/ int index, /*[in]*/ VARIANT newVal);
  STDMETHOD(get_Profile)(/*[in]*/ BSTR attributeName, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_Profile)(/*[in]*/ BSTR attributeName, /*[in]*/ VARIANT newVal);
  STDMETHOD(DomainFromMemberName)(/*[in,optional]*/ VARIANT memberName, /*[out,retval]*/ BSTR *pDomainName);
  STDMETHOD(GetDomainAttribute)(/*[in]*/ BSTR attributeName, /*[in,optional]*/ VARIANT lcid, /*[in,optional]*/ VARIANT domain, /*[out,retval]*/ BSTR *pAttrVal);
  STDMETHOD(get_TimeSinceSignIn)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_TicketAge)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_SignInTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(get_TicketTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(HasFlag)(/*[in]*/ VARIANT flagMask, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_FromNetworkServer)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_HasTicket)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(HasProfile)(/*[in]*/ VARIANT profileName, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(LogoTag)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT bSecure, VARIANT NameSpace, /*[in, optional*/ VARIANT KPP, /*[in, optional]*/ VARIANT SecureLevel, /*[out, retval]*/ BSTR *pVal);
  STDMETHOD(LogoTag2)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT bSecure, VARIANT NameSpace, /*[in, optional*/ VARIANT KPP, /*[in, optional]*/ VARIANT SecureLevel, /*[out, retval]*/ BSTR *pVal);
  STDMETHOD(IsAuthenticated)(/*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, /*[in,optional]*/ VARIANT SecureLevel, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(AuthURL)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT NameSpace, /*[in, optional]*/ VARIANT KPP, /*[in, optional]*/ VARIANT SecureLevel, /*[out,retval]*/ BSTR *pAuthUrl);
  STDMETHOD(AuthURL2)(/*[in]*/ VARIANT returnUrl, /*[in]*/ VARIANT TimeWindow, /*[in]*/ VARIANT ForceLogin, VARIANT coBrandTemplate, VARIANT lang_id, VARIANT NameSpace, /*[in, optional]*/ VARIANT KPP, /*[in, optional]*/ VARIANT SecureLevel, /*[out,retval]*/ BSTR *pAuthUrl);
  //    New API. call it to generate user logon. ASP caller will get a redirect.
  //    isapi callers should not do any more work after this
  STDMETHOD(LoginUser)(/*[in]*/ VARIANT returnUrl,
                       /*[in]*/ VARIANT TimeWindow,
                       /*[in]*/ VARIANT ForceLogin,
                       /*[in]*/ VARIANT coBrandTemplate,
                       /*[in]*/ VARIANT lang_id,
                       /*[in]*/ VARIANT NameSpace,
             /*[in, optional]*/ VARIANT KPP,
             /*[in, optional]*/ VARIANT SecureLevel,
             /*[in, optional]*/ VARIANT ExtraParams);
  //Active Server Pages Methods
  STDMETHOD(OnStartPage)(IUnknown* IUnk);
  STDMETHOD(OnStartPageManual)(BSTR qsT, BSTR qsP, BSTR mspauth, BSTR mspprof, BSTR mspconsent, VARIANT vmspsec, VARIANT *pCookies);
  STDMETHOD(OnStartPageECB)(/*[in]*/ LPBYTE pECB, /*[in,out]*/ DWORD *pBufSize, /*[out]*/ LPSTR pCookieHeader);
  STDMETHOD(OnStartPageFilter)(/*[in]*/ LPBYTE pPFC, /*[in,out]*/ DWORD *pBufSize, /*[out]*/ LPSTR pCookieHeader);
  STDMETHOD(OnStartPageASP)(/*[in]*/ IDispatch* pdispRequest, /*[in]*/ IDispatch* pdispResponse);
  STDMETHOD(OnEndPage)();
  STDMETHOD(_Ticket)(IPassportTicket** piTicket);
  STDMETHOD(_Profile)(IPassportProfile** piProfile);
  STDMETHOD(get_Domains)(VARIANT* pArrayVal);
  STDMETHOD(get_Error)(long* pErrorVal);

  // IPassportManager3
  STDMETHOD(get_Ticket)(/*[in]*/ BSTR attributeName, /*[out, retval]*/ VARIANT *pVal);


   STDMETHOD(GetCurrentConfig)(/*[in]*/ BSTR name, /*[out, retval]*/ VARIANT *pVal)
   {
      if (!m_pRegistryConfig)
      {
         AtlReportError(CLSID_Manager, PP_E_NOT_INITIALIZEDSTR,
                       IID_IPassportManager, PP_E_NOT_INITIALIZED);
         return PP_E_NOT_INITIALIZED;
      }
      else
         return m_pRegistryConfig->GetCurrentConfig(name, pVal);
   };

   STDMETHOD(LogoutURL)(
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT bSecure,
            /* [retval][out] */  BSTR *pVal);

  STDMETHOD(GetLoginChallenge)(/*[in]*/ VARIANT returnUrl,
                       /*[in]*/ VARIANT TimeWindow,
                       /*[in]*/ VARIANT ForceLogin,
                       /*[in]*/ VARIANT coBrandTemplate,
                       /*[in]*/ VARIANT lang_id,
                       /*[in]*/ VARIANT NameSpace,
             /*[in, optional]*/ VARIANT KPP,
             /*[in, optional]*/ VARIANT SecureLevel,
             /*[in, optional]*/ VARIANT ExtraParams,
//             /*[out, optional]*/ VARIANT *pAuthHeader,
             /*[out, retval]*/ BSTR* pAuthHeader
             );

STDMETHOD(get_HexPUID)(/*[out, retval]*/ BSTR *pVal);
STDMETHOD(get_PUID)(/*[out, retval]*/ BSTR *pVal);

STDMETHOD(OnStartPageHTTPRawEx)(
            /* [in] */          LPCSTR method,
            /* [in] */          LPCSTR path,
            /* [in] */          LPCSTR QS,
            /* [in] */          LPCSTR HTTPVer,
            /* [string][in] */  LPCSTR headers,
            /* [in] */          DWORD  flags,
            /* [out][in] */     DWORD  *bufSize,
            /* [size_is][out]*/ LPSTR  pCookieHeader);

STDMETHOD(OnStartPageHTTPRaw)(
            /* [string][in] */ LPCSTR request_line,
            /* [string][in] */ LPCSTR headers,
            /* [in] */ DWORD flags,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        
STDMETHOD(ContinueStartPageHTTPRaw)(
            /* [in] */ DWORD bodyLen,
            /* [size_is][in] */ byte *body,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pRespHeaders,
            /* [out][in] */ DWORD *pRespBodyLen,
            /* [size_is][out] */ byte *pRespBody);

STDMETHOD(get_Option)( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal);
        
STDMETHOD(put_Option)( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal);


// IDomainMap
public:
  // GetDomainAttribute and get_Domains declared above.
  STDMETHOD(DomainExists)(BSTR bstrDomainName, VARIANT_BOOL* pbExists);

// IPassportService
public:
    STDMETHOD(Initialize)(BSTR, IServiceProvider*);
    STDMETHOD(Shutdown)();
    STDMETHOD(ReloadState)(IServiceProvider*);
    STDMETHOD(CommitState)(IServiceProvider*);
    STDMETHOD(DumpState)( BSTR* );

protected:
  void wipeState();

  // return S_OK -- altered, should use two returned output params for MSPAuth and MSPSecAuth as cookies
  HRESULT   IfAlterAuthCookie(BSTR* pMSPAuth, BSTR* pMSPSecAuth);

  // return S_OK -- should use the generated MSPConsent cookie
  HRESULT   IfConsentCookie(BSTR* pMSPConsent);

private:
  STDMETHOD(GetLoginChallengeInternal)(/*[in]*/ VARIANT returnUrl,
                       /*[in]*/ VARIANT TimeWindow,
                       /*[in]*/ VARIANT ForceLogin,
                       /*[in]*/ VARIANT coBrandTemplate,
                       /*[in]*/ VARIANT lang_id,
                       /*[in]*/ VARIANT NameSpace,
             /*[in, optional]*/ VARIANT KPP,
             /*[in, optional]*/ VARIANT SecureLevel,
             /*[in, optional]*/ VARIANT ExtraParams,
             /*[out, optional]*/ VARIANT *pAuthHeader,
             /*[out, retval]*/ BSTR* pAuthVal
             );

  STDMETHOD(CommonAuthURL)(VARIANT returnUrl,
                           VARIANT TimeWindow,
                           VARIANT ForceLogin,
                           VARIANT coBrandTemplate,
                           VARIANT lang_id,
                           VARIANT NameSpace,
                           VARIANT KPP,
                           VARIANT SecureLevel,
                           BOOL    fRedirToSelf,
                           VARIANT functionArea,
                           BSTR *pAuthUrl);
  BOOL handleQueryStringData(BSTR a, BSTR p);
  BOOL handleCookieData(BSTR a, BSTR p, BSTR c, BSTR s);
  BOOL checkForPassportChallenge(IRequestDictionaryPtr piServerVariables);
  BOOL HeaderFromQS(PWSTR   pszQS, _bstr_t& bstrHeader);
  STDMETHODIMP FormatAuthHeaderFromParams(PCWSTR    pszLoginUrl,    // unused for now
                                          PCWSTR    pszRetUrl,
                                          ULONG     ulTimeWindow,
                                          BOOL      fForceLogin,
                                          time_t    ct,
                                          PCWSTR    pszCBT,         // unused for now
                                          PCWSTR    pszNamespace,
                                          int       nKpp,
                                          PWSTR     pszlcid,
                                          ULONG     ulSecLevel,
                                          _bstr_t&  strHeader   //  return result
                                          );
  STDMETHOD(CommonLogoTag)(VARIANT returnUrl,
                     VARIANT TimeWindow,
                     VARIANT ForceLogin,
                     VARIANT coBrandTemplate,
                     VARIANT lang_id,
                     VARIANT bSecure,
                     VARIANT NameSpace,
                     VARIANT KPP,
                     VARIANT SecureLevel,
                     BOOL    fRedirToSelf,
                     BSTR *pVal);
  //    helper for coming up with login paramers based on
  //    what the site passed in and registry configs
  //    someone should put all these in a class, so the number of
  //    params stays manageable
  STDMETHOD(GetLoginParams)(//  this is what the caller passed in
                      VARIANT vRU,
                      VARIANT vTimeWindow,
                      VARIANT vForceLogin,
                      VARIANT vCoBrand,
                      VARIANT vLCID,
                      VARIANT vNameSpace,
                      VARIANT vKPP,
                      VARIANT vSecureLevel,
                      //    these are the processed values
                      _bstr_t&  url,
                      _bstr_t&  returnUrl,
                      UINT&     TimeWindow,
                      VARIANT_BOOL& ForceLogin,
                      time_t&   ct,
                      _bstr_t&  strCBT,
                      _bstr_t&  strNameSpace,
                      int&      nKpp,
                      ULONG&    ulSecureLevel,
                      PWSTR     pszlcid);

  VARIANT_BOOL m_profileValid;
  VARIANT_BOOL m_ticketValid;

  CComObject<CTicket>  *m_piTicket;
  CComObject<CProfile> *m_piProfile;

  CRegistryConfig*      m_pRegistryConfig;

  IRequestPtr m_piRequest;                              //Request Object
  IResponsePtr m_piResponse;                            //Response Object
  bool m_bOnStartPageCalled;                            //OnStartPage successful?

  bool m_fromQueryString;
  //    for ISAPI ....
  EXTENSION_CONTROL_BLOCK   *m_pECB;
  PHTTP_FILTER_CONTEXT      m_pFC;
  //    is it 1.4 capable client?
  BOOL  m_bIsTweenerCapable;

  long m_lNetworkError;

  // secure sign in
  bool m_bSecureTransported;

  CComVariant   m_iModeOption;
  BOOL IfCreateTPF()
  {
      if (V_VT(&m_iModeOption) == VT_BOOL && V_BOOL(&m_iModeOption) == VARIANT_TRUE)
        return FALSE;
      return TRUE;

  }
};

#endif //__MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\helperfuncs.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    HelperFuncs.h
      defines helper functions for passport manager object


    FILE HISTORY:

*/
    
// HelperFuncs.h : Useful functions

#ifndef __HELPERFUNCS_H_
#define __HELPERFUNCS_H_

#include <httpfilt.h>
#include <httpext.h>
#include "nsconst.h"
#include "passport.h"
#include "smartcls.h"

typedef enum { PM_LOGOTYPE_SIGNIN, PM_LOGOTYPE_SIGNOUT } PM_LOGOTYPE;

#define  SECURELEVEL_USE_HTTPS(n)   (n >= k_iSeclevelSecureChannel)

BSTR
FormatNormalLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentCryptVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszImageURL,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PM_LOGOTYPE nLogoType,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf,
    BOOL    bCreateTPF
    
    );

BSTR
FormatUpdateLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindows,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    int     nKPP,
    LPCWSTR pszUpdateServerURL,
    BOOL    bSecure,
    LPCWSTR pszProfileUpdate,
    PM_LOGOTYPE nLogoType,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL  bCreateTPF
    );

BSTR
FormatAuthURL(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf,
    BOOL    bCreateTPF
    );

BOOL
GetQueryData(
    LPCSTR   pszQueryString,
    BSTR*   pbstrTicket,
    BSTR*   pbstrProfile,
    BSTR*   pbstrFlags
    );

BOOL
GetCookie(
    LPCSTR   pszCookieHeader,
    LPCSTR   pszCookieName,
    BSTR*   pbstrCookieVal
    );

BOOL
BuildCookieHeaders(
    LPCSTR  pszTicket,
    LPCSTR  pszProfile,
    LPCSTR  pszConsent,
    LPCSTR  pszSecure,
    LPCSTR  pszTicketDomain,
    LPCSTR  pszTicketPath,
    LPCSTR  pszConsentDomain,
    LPCSTR  pszConsentPath,
    LPCSTR  pszSecuredomain,
    LPCSTR  pszSecurePath,
    BOOL    bSave,
    LPSTR   pszBuf,
    LPDWORD pdwBufLen,
    bool    bHTTPOnly
    );

HRESULT
DecryptTicketAndProfile(
    BSTR                bstrTicket,
    BSTR                bstrProfile,
    BOOL                bCheckConsent,
    BSTR                bstrConsent,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket,
    IPassportProfile*   piProfile
    );

HRESULT
DoSecureCheck(
    BSTR                bstrSecure,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket
    );

HRESULT
GetSiteNamePFC(
    PHTTP_FILTER_CONTEXT    pfc,
    LPSTR                   szBuf,
    LPDWORD                 lpdwBufLen
    );

HRESULT
GetSiteNameECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       szBuf,
    LPDWORD                     lpdwBufLen
    );

LPSTR
GetServerVariableECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       pszHeader
    );

LPSTR
GetServerVariablePFC(
    PHTTP_FILTER_CONTEXT    pPFC,
    LPSTR                   pszHeader
    );

int GetRawHeaders(LPCSTR headers, LPCSTR* names, LPCSTR* values, DWORD* dwSizes, DWORD namescount);
LPCSTR GetRawQueryString(LPCSTR headers, DWORD* dwSize);


LONG
FromHex(
    LPCWSTR     pszHexString
    );

//  max sizes for URLs (without qs) and with
//  these could be a bit opportunistic
#define MAX_URL_LENGTH      2048
#define MAX_QS_LENGTH       2048
#define PP_MAX_ATTRIBUTE_LENGTH MAX_URL_LENGTH
#define PPSITE_CHALLENGE   L"msppchlg=1"
#define PPSITE_CHALLENGE_A  "msppchlg=1"
#define PPLOGIN_PARAM      L"mspplogin="
#define PPLOGIN_PARAM_A     "mspplogin="

//  identification string for the auth method
#define PASSPORT_PROT14_A    "Passport1.4"
#define PASSPORT_PROT14     L"Passport1.4"

#define C_PPAUTH_INFO_HEADER  "Authentication-Info"
#define W_PPAUTH_INFO_HEADER L"Authentication-Info"

// cookie names for Tweener
#define C_PPCOOKIE_NAMES     "tname=MSPAuth,tname=MSPProf,tname=MSPConsent,tname=MSPSecAuth"
#define W_PPCOOKIE_NAMES    L"tname=MSPAuth,tname=MSPProf,tname=MSPConsent,tname=MSPSecAuth"
#define C_AUTH_INFO_HEADER_PASSPORT C_PPAUTH_INFO_HEADER ": " PASSPORT_PROT14_A " " C_PPCOOKIE_NAMES "\r\n"


PWSTR
FormatAuthURLParameters(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PWSTR   pszBufStart,
    ULONG   cBufLen,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirectToSelf,
    BOOL    bCreateTPF
    );

HRESULT SignQueryString(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPWSTR  pszBufStart,
    LPWSTR& pszCurrent,
    LPCWSTR pszBufEnd,
    BOOL    bCreateTPF
    );

HRESULT PartnerHash(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPCWSTR tobeSigned,
    ULONG   nChars,
    BSTR*   pbstrHash);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\manager.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    manager.cpp
       COM object for manager interface


    FILE HISTORY:

*/


// Manager.cpp : Implementation of CManager
#include "stdafx.h"
#include <httpext.h>
#include "Manager.h"
#include <httpfilt.h>
#include <time.h>
#include <malloc.h>
#include <wininet.h>

#include <nsconst.h>
#include "VariantUtils.h"
#include "HelperFuncs.h"
#include "RegistryConfig.h"
#include "PassportService_i.c"
#include "atlbase.h"

PWSTR GetVersionString();

//using namespace ATL;

// gmarks
#include "Monitoring.h"
/////////////////////////////////////////////////////////////////////////////
// CManager

#include "passporttypes.h"

//  static utility func
static VOID GetTicketAndProfileFromHeader(PWSTR     pszAuthHeader,
                                          PWSTR&    pszTicket,
                                          PWSTR&    pszProfile,
                                          PWSTR&    pszF);

//  Used for cookie expiration.
const DATE g_dtExpire = 365*137;
const DATE g_dtExpired = 365*81;


//===========================================================================
//
// CManager
//
CManager::CManager() :
  m_fromQueryString(false), m_ticketValid(VARIANT_FALSE),
  m_profileValid(VARIANT_FALSE), m_lNetworkError(0),
  m_pRegistryConfig(NULL), m_pECB(NULL), m_pFC(NULL),
  m_bIsTweenerCapable(FALSE),
  m_bSecureTransported(false)
{
    PPTraceFuncV func(PPTRACE_FUNC, "CManager");


    // ticket object
    m_pUnkMarshaler = NULL;
    try
    {
        m_piTicket = new CComObject<CTicket>();
    }
    catch(...)
    {
        m_piTicket = NULL;
    }
    if(m_piTicket)
        m_piTicket->AddRef();

    // profile object
    try
    {
        m_piProfile = new CComObject<CProfile>();
    }
    catch(...)
    {
        m_piProfile = NULL;
    }

    if(m_piProfile)
        m_piProfile->AddRef();

    m_bOnStartPageCalled = false;

}


//===========================================================================
//
// ~CManager
//
CManager::~CManager()
{
  PPTraceFuncV func(PPTRACE_FUNC, "~CManager");
  if(m_pRegistryConfig)
      m_pRegistryConfig->Release();
  if (m_piTicket) m_piTicket->Release();
  if (m_piProfile) m_piProfile->Release();
}

//===========================================================================
//
// IfConsentCookie -- if a consent cookie should be sent back
//    return value: S_OK -- has consent cookie; S_FALSE -- no consent cookie
//    output param: The consent cookie
//
HRESULT CManager::IfConsentCookie(BSTR* pMSPConsent)
{
    BSTR bstrRawConsent = NULL;

    HRESULT  hr = S_FALSE;
    PPTraceFunc<HRESULT>
      func(
         PPTRACE_FUNC,
         hr,
         "IfConsentCookie"," <<<< %lx",
         pMSPConsent
         );
   
    if (!m_piTicket || !m_piProfile || !m_pRegistryConfig)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    LPCSTR   domain = m_pRegistryConfig->getTicketDomain();
    LPCSTR   path = m_pRegistryConfig->getTicketPath();
    LPCSTR   tertiaryDomain = m_pRegistryConfig->getProfileDomain();
    LPCSTR   tertiaryPath = m_pRegistryConfig->getProfilePath();

    if (!tertiaryPath)   tertiaryPath = "/";

    if(!domain)    domain = "";
    if(!path)    path = "";

    if(!tertiaryDomain)    tertiaryDomain = "";
    if(!tertiaryPath)    tertiaryPath = "";

    //
    // if a separate consent cookie is necessary
    if((lstrcmpiA(domain, tertiaryDomain) || lstrcmpiA(path, tertiaryPath)) &&
          (m_piTicket->GetPassportFlags() & k_ulFlagsConsentCookieNeeded) &&
          !m_pRegistryConfig->bInDA() )
    {
        if (pMSPConsent == NULL)   // no output param
            hr = S_OK;
        else
        {
            *pMSPConsent = NULL;

            CCoCrypt* crypt = m_pRegistryConfig->getCurrentCrypt();
            if (!crypt)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            // get the consent cookie from ticket
            hr = m_piTicket->get_unencryptedCookie(CTicket::MSPConsent, 0, &bstrRawConsent);
            if (FAILED(hr))
                goto Cleanup;

            // encrypt it with partner's key
            if (!crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                  (LPSTR)bstrRawConsent,
                  SysStringByteLen(bstrRawConsent),
                  pMSPConsent))
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }

Cleanup:
    if (bstrRawConsent)
    {
        SysFreeString(bstrRawConsent);
    }

    if(pMSPConsent)
        PPTracePrint(PPTRACE_RAW, ">>> pMSPConsent:%ws", PPF_WCHAR(*pMSPConsent));

    return hr;
}


//===========================================================================
//
// IfAlterAuthCookie
//
// return S_OK -- when auth cookie is different from t (altered), should use
//                the cookie and secAuth cookie returned
// S_FALSE -- not altered -- can use the t as auth cookie
// if MSPSecAuth != NULL, write the secure cookie
HRESULT CManager::IfAlterAuthCookie(BSTR* pMSPAuth, BSTR* pMSPSecAuth)
{
    _ASSERT(pMSPAuth && pMSPSecAuth);

    *pMSPAuth = NULL;
    *pMSPSecAuth = NULL;

    HRESULT  hr = S_FALSE;

    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "IfAlterAuthCookie", "<<< %lx, %lx",
         pMSPAuth, pMSPSecAuth);

    if (!m_piTicket || !m_piProfile || !m_pRegistryConfig)
    {
        return E_OUTOFMEMORY;
    }

    if (!(m_piTicket->GetPassportFlags() & k_ulFlagsSecuredTransportedTicket)
        || !m_bSecureTransported)
    {
        return hr;
    }

    BSTR bstrRawAuth = NULL;
    BSTR bstrRawSecAuth = NULL;

    CCoCrypt* crypt = m_pRegistryConfig->getCurrentCrypt();
    if (!crypt)
    {
        hr = PM_CANT_DECRYPT_CONFIG;
        goto Cleanup;
    }

    hr = m_piTicket->get_unencryptedCookie(CTicket::MSPAuth, 0, &bstrRawAuth);
    if (FAILED(hr))
        goto Cleanup;

    if (!crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                  (LPSTR)bstrRawAuth,
                  SysStringByteLen(bstrRawAuth),
                  pMSPAuth))
    {
        hr = PM_CANT_DECRYPT_CONFIG;
        goto Cleanup;
    }

    hr = m_piTicket->get_unencryptedCookie(CTicket::MSPSecAuth, 0, &bstrRawSecAuth);
    if (FAILED(hr))
       goto Cleanup;

    if (!crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                  (LPSTR)bstrRawSecAuth,
                  SysStringByteLen(bstrRawSecAuth),
                  pMSPSecAuth))
    {
        hr = PM_CANT_DECRYPT_CONFIG;
        goto Cleanup;
    }

Cleanup:
    if (bstrRawAuth)
    {
        SysFreeString(bstrRawAuth);
    }
    if (bstrRawSecAuth)
    {
        SysFreeString(bstrRawSecAuth);
    }

    PPTracePrint(PPTRACE_RAW,
         ">>> pMSPAuth:%ws, pMSPSecAuth:%ws",
         PPF_WCHAR(*pMSPAuth),
         PPF_WCHAR(*pMSPSecAuth));

    return hr;
 }


//===========================================================================
//
// wipeState -- cleanup teh state of manager object
//
void
CManager::wipeState()
{
   PPTraceFuncV func(PPTRACE_FUNC, "wipeState");

    m_pECB = NULL;
    m_pFC = NULL;
    m_bIsTweenerCapable = FALSE;
    m_bOnStartPageCalled    = false;
    m_fromQueryString       = false;
    m_lNetworkError         = 0;
    m_ticketValid           = VARIANT_FALSE;
    m_profileValid          = VARIANT_FALSE;
    m_piRequest             = NULL;
    m_piResponse            = NULL;

    // cleanup ticket content
    if(m_piTicket)    m_piTicket->put_unencryptedTicket(NULL);

    // cleanup profile content
    if(m_piProfile)   m_piProfile->put_unencryptedProfile(NULL);

    // cleanup buffered registry config
    if(m_pRegistryConfig)
    {
        m_pRegistryConfig->Release();
        m_pRegistryConfig = NULL;
    }
}


//===========================================================================
//
// InterfaceSupportsErrorInfo
//
STDMETHODIMP CManager::InterfaceSupportsErrorInfo(REFIID riid)
{
    PPTraceFuncV func(PPTRACE_FUNC, "InterfaceSupportsErrorInfo");

    static const IID* arr[] =
    {
        &IID_IPassportManager,
        &IID_IPassportManager2,
        &IID_IPassportManager3,
        &IID_IDomainMap,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
//===========================================================================
//
// OnStartPage -- called by ASP pages automatically by IIS when declared on the page
//
STDMETHODIMP CManager::OnStartPage (IUnknown* pUnk)
{
    HRESULT hr = S_OK;
    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "OnStartPage"," <<< %lx",
         pUnk);

    if(!pUnk)
    {
       return hr = E_POINTER;
    }

    IScriptingContextPtr  spContext;

    spContext = pUnk;
    // Get Request Object Pointer
    hr = OnStartPageASP(spContext->Request, spContext->Response);

    return hr;
}

BSTR
MyA2W(
    char *src
    )
{

    if (src == NULL)
    {
        return NULL;
    }

    BSTR str = NULL;

    int nConvertedLen = MultiByteToWideChar(GetACP(), 0, src, -1, NULL, NULL);

    str = ::SysAllocStringLen(NULL, nConvertedLen - 1);
    if (str != NULL)
    {
        if (!MultiByteToWideChar(GetACP(), 0, src, -1, str, nConvertedLen))
        {
            SysFreeString(str);
            str = NULL;
        }
    }
    return str;
}

//===========================================================================
//
// OnStartPageASP -- called by asp pages when created by using factory object
// FUTURE --- should change the OnStartPage function to use this function
//
STDMETHODIMP CManager::OnStartPageASP(
    IDispatch*  piRequest,
    IDispatch*  piResponse
    )
{
    HRESULT hr = S_OK;
    char*   spBuf = NULL;
    BSTR    bstrName=NULL;
    BSTR    bstrValue=NULL;

    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "OnStartPageASP",
         " <<< %lx, %lx", piRequest, piResponse);
    PassportLog("CManager::OnStartPageASP Enter:\r\n");

    if(!piRequest || !piResponse)
        return hr = E_INVALIDARG;
    
    USES_CONVERSION;

    try
    {
        IRequestDictionaryPtr piServerVariables;
        _variant_t            vtItemName;
        _variant_t            vtHTTPS;
        _variant_t            vtMethod;
        _variant_t            vtPath;
        _variant_t            vtQs;
        _variant_t            vtServerPort;
        _variant_t            vtHeaders;
        
        CComQIPtr<IResponse>    spResponse;
        CComQIPtr<IRequest>     spRequest;
        
        // Get Request Object Pointer
        spRequest  = piRequest;
        spResponse = piResponse;

        //
        //  Get the server variables collection.
        //

        spRequest->get_ServerVariables(&piServerVariables);


        //
        //  now see if that's a special redirect
        //  requiring challenge generation
        //  if so processing stops here ....
        //
        if (checkForPassportChallenge(piServerVariables))
        {
            PPTracePrint(PPTRACE_RAW, "special redirect for Challenge");
            return  S_OK;
        }

        //
        //  Might need this for multi-site, or secure ticket/profile
        //

        vtItemName = L"HTTPS";

        piServerVariables->get_Item(vtItemName, &vtHTTPS);
        if(vtHTTPS.vt != VT_BSTR)
            vtHTTPS.ChangeType(VT_BSTR);

        DWORD flags = 0;
        if(vtHTTPS.bstrVal && lstrcmpiW(L"on", vtHTTPS.bstrVal) == 0)
          flags |=  PASSPORT_HEADER_FLAGS_HTTPS;
        
        // headers        
        vtItemName.Clear();
        vtItemName = L"ALL_RAW";

        piServerVariables->get_Item(vtItemName, &vtHeaders);
        if(vtHeaders.vt != VT_BSTR){
            vtHeaders.ChangeType(VT_BSTR);
        }

        // path
        vtItemName.Clear();
        vtItemName = L"PATH_INFO";

        piServerVariables->get_Item(vtItemName, &vtPath);
        if(vtPath.vt != VT_BSTR)
            vtPath.ChangeType(VT_BSTR);

        // vtMethod
        vtItemName.Clear();
        vtItemName = L"REQUEST_METHOD";

        piServerVariables->get_Item(vtItemName, &vtMethod);
        if(vtMethod.vt != VT_BSTR)
            vtMethod.ChangeType(VT_BSTR);

        // QUERY_STRING
        vtItemName.Clear();
        vtItemName = L"QUERY_STRING";

        piServerVariables->get_Item(vtItemName, &vtQs);
        if(vtQs.vt != VT_BSTR)
            vtQs.ChangeType(VT_BSTR);

        DWORD   bufSize = 0;
        DWORD   requiredBufSize = MAX_URL_LENGTH;


        // make sure the size if sufficient
        while(bufSize < requiredBufSize)
        {
            if (spBuf) 
            {
                free(spBuf);
            }
            if(NULL == (spBuf = (char *)malloc(requiredBufSize)))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            bufSize = requiredBufSize;
            
            hr = OnStartPageHTTPRawEx(W2A(vtMethod.bstrVal), 
                              W2A(vtPath.bstrVal),
                              W2A(vtQs.bstrVal),
                              NULL, // version
                              W2A(vtHeaders.bstrVal),
                              flags,
                              &requiredBufSize,
                              spBuf);
        }

        // write the cookies
        if(hr == S_OK && requiredBufSize && *spBuf)
        {
            char* pNext = spBuf;
            while(pNext != NULL)
            {
               char* pName = pNext;
               char* pValue = strchr(pName, ':');
               if(pValue)
               {
                  // make temp sub string
                  TempSubStr tsN(pName, pValue - pName);
                  bstrName = MyA2W(pName);
                  if (bstrName) {
                      ++pValue;
                      pNext = strstr(pValue, "\r\n");   // new line
                      if(pNext)
                      {
                         // make temp sub string
                         TempSubStr tsV(pValue, pNext - pValue);
                         pNext += 2;
                         bstrValue = MyA2W(pValue);
                         
                      }
                      else
                      {
                         bstrValue = MyA2W(pValue);
                      }
                      if (bstrValue)
                      {
                          spResponse->raw_AddHeader(bstrName, bstrValue);
                      }
                  }
               }
               else
               {
                   pNext = pValue;
               }
               if (bstrName) {
                   SysFreeString(bstrName);
                   bstrName = NULL;
               }
               if (bstrValue) {
                   SysFreeString(bstrValue);
                   bstrValue = NULL;
               }
            }
        }
        if (spBuf) {
            free(spBuf);
            spBuf = NULL;
        }

        // Get Request Object Pointer
        m_piRequest  = piRequest;
        // Get Response Object Pointer
        m_piResponse = piResponse;

    }
    catch (...)
    {
        if (m_piRequest.GetInterfacePtr() != NULL)
            m_piRequest.Release();
        if (m_piResponse.GetInterfacePtr() != NULL)
            m_piResponse.Release();
        m_bOnStartPageCalled = false;
        if (spBuf) {
            free(spBuf);
        }
        if (bstrName) {
            SysFreeString(bstrName);
        }
        if (bstrValue) {
            SysFreeString(bstrValue);
        }
    }

exit:
    return hr = S_OK;
}


//===========================================================================
//
// OnStartPageManual -- authenticate with t, and p, MSPAuth, MSPProf, MSPConsent, MSPsecAuth
//          not recommended to use, will be depracated
//
STDMETHODIMP CManager::OnStartPageManual(
    BSTR        qsT,
    BSTR        qsP,
    BSTR        mspauth,
    BSTR        mspprof,
    BSTR        mspconsent,
    VARIANT     mspsec,
    VARIANT*    pCookies
    )
{
    int                 hasSec;
    BSTR                bstrSec;
    BSTR                bstrConsent = NULL;
    BSTR                bstrNewAuth = NULL;
    BSTR                bstrNewSecAuth = NULL;

    HRESULT hr = S_OK;
    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "OnStartPageManual",
         " <<< %ws, %ws, %ws, %ws, %ws", qsT, qsP, mspauth, mspprof, mspconsent);

    PassportLog("CManager::OnStartPageManual Enter:  T = %ws,    P = %ws,    A = %ws,    PR = %ws\r\n",
          qsT, qsP, mspauth, mspprof);

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_piTicket || !m_piProfile)
    {
        return E_OUTOFMEMORY;
    }

    wipeState();

    if(m_pRegistryConfig)
        m_pRegistryConfig->Release();
    m_pRegistryConfig = g_config->checkoutRegistryConfig();

    // Auth with Query String T & P first
    if (handleQueryStringData(qsT, qsP))
    {
        VARIANT_BOOL persist;
        _bstr_t domain;
        _bstr_t path;
        _bstr_t bstrAuth;
        _bstr_t bstrProf;


        bstrAuth.Assign(qsT);

        bstrProf.Assign(qsP);


        if (pCookies)
        {
            VariantInit(pCookies);

            if (m_pRegistryConfig->getTicketPath())
                path = m_pRegistryConfig->getTicketPath();
            else
                path = L"/";

            m_piTicket->get_HasSavedPassword(&persist);

            BOOL bSetConsent = (S_OK == IfConsentCookie(&bstrConsent));

            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound = 0;
            rgsabound.cElements = 2;

            // secure cookie
            if (m_bSecureTransported)
                rgsabound.cElements++;

            if(bSetConsent)
                rgsabound.cElements++;
            SAFEARRAY *sa = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);

            if (!sa)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pCookies->vt = VT_ARRAY | VT_VARIANT;
            pCookies->parray = sa;

            WCHAR buf[4096];
            DWORD bufSize;
            long  spot = 0;

            VARIANT *vArray;
            SafeArrayAccessData(sa, (void**)&vArray);

            // write Auth cookies
            BSTR  auth, secAuth; // do not call SysFreeString on them, they are skin level copy

            if (S_OK == IfAlterAuthCookie(&bstrNewAuth, &bstrNewSecAuth))
            {
               auth = bstrNewAuth;
               secAuth = bstrNewSecAuth;
            }
            else
            {
               auth = bstrAuth;
               secAuth = NULL;
            }


            domain = m_pRegistryConfig->getTicketDomain();

            // add MSPAuth
            if (domain.length())
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPAuth=%s; path=%s; domain=%s; %s\r\n",
                                    (LPWSTR)auth, (LPWSTR)path, (LPWSTR)domain,
                                    persist ? W_COOKIE_EXPIRES(EXPIRE_FUTURE) : L"");
            }
            else
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPAuth=%s; path=%s; %s\r\n",
                                    (LPWSTR)auth, (LPWSTR)path,
                                    persist ? W_COOKIE_EXPIRES(EXPIRE_FUTURE) : L"");
            }
            buf[4095] = L'\0';

            vArray[spot].vt = VT_BSTR;
            vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
            spot++;

            // add MSPSecAuth
            if (m_bSecureTransported)
            {

               _bstr_t secDomain = m_pRegistryConfig->getSecureDomain();
               _bstr_t secPath;

               if (m_pRegistryConfig->getSecurePath())
                   secPath = m_pRegistryConfig->getSecurePath();
               else
                   secPath = L"/";


               if (secDomain.length())
               {
                   bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPSecAuth=%s; path=%s; domain=%s; %s; secure\r\n",
                                    ((secAuth && *secAuth) ? (LPWSTR)secAuth : L""), (LPWSTR)secPath, (LPWSTR)secDomain,
                                    ((!secAuth || *secAuth == 0) ? W_COOKIE_EXPIRES(EXPIRE_PAST)
                                                                        : L""));
               }
               else
               {
                   bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPSecAuth=%s; path=%s; %s; secure\r\n",
                                    ((secAuth && *secAuth) ? (LPWSTR)secAuth : L""), (LPWSTR)secPath,
                                    ((!secAuth || *secAuth == 0) ? W_COOKIE_EXPIRES(EXPIRE_PAST)
                                                                        : L""));
               }
               buf[4095] = L'\0';

               vArray[spot].vt = VT_BSTR;
               vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
               spot++;
            }


            if (domain.length())
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPProf=%s; path=%s; domain=%s; %s\r\n",
                                    (LPWSTR)bstrProf, (LPWSTR)path, (LPWSTR)domain,
                                    persist ? W_COOKIE_EXPIRES(EXPIRE_FUTURE) : L"");
            }
            else
            {
                bufSize = _snwprintf(buf, 4096,
                                    L"Set-Cookie: MSPProf=%s; path=%s; %s\r\n",
                                    (LPWSTR)bstrProf, (LPWSTR)path,
                                    persist ? W_COOKIE_EXPIRES(EXPIRE_FUTURE) : L"");
            }
            buf[4095] = L'\0';

            vArray[spot].vt = VT_BSTR;
            vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
            spot++;

            if(bSetConsent)
            {
                if (m_pRegistryConfig->getProfilePath())
                    path = m_pRegistryConfig->getProfilePath();
                else
                    path = L"/";
                domain = m_pRegistryConfig->getProfileDomain();

                if (domain.length())
                {
                    bufSize = _snwprintf(buf, 4096,
                                        L"Set-Cookie: MSPConsent=%s; path=%s; domain=%s; %s\r\n",
                                        bSetConsent ? (LPWSTR)bstrConsent : L"", (LPWSTR)path, (LPWSTR)domain,
                                        bSetConsent ? (persist ? W_COOKIE_EXPIRES(EXPIRE_FUTURE) : L"")
                                                  : W_COOKIE_EXPIRES(EXPIRE_PAST));
                }
                else
                {
                    bufSize = _snwprintf(buf, 4096,
                                        L"Set-Cookie: MSPConsent=%s; path=%s; %s\r\n",
                                        bSetConsent ? (LPWSTR)bstrConsent : L"", (LPWSTR)path,
                                        bSetConsent ? (persist ? W_COOKIE_EXPIRES(EXPIRE_FUTURE) : L"")
                                                  : W_COOKIE_EXPIRES(EXPIRE_PAST));
                }
                buf[4095] = L'\0';

                vArray[spot].vt = VT_BSTR;
                vArray[spot].bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(buf, bufSize);
                spot++;
            }

            SafeArrayUnaccessData(sa);
        }
    }

    // Now, check the cookies
    if (!m_fromQueryString)
    {
        hasSec = GetBstrArg(mspsec, &bstrSec);
        if(hasSec == CV_DEFAULT || hasSec == CV_BAD)
            bstrSec = NULL;

        handleCookieData(mspauth, mspprof, mspconsent, bstrSec);

        if(hasSec == CV_FREE)
            SysFreeString(bstrSec);
    }

    hr = S_OK;
Cleanup:
    if (bstrNewAuth)
    {
        SysFreeString(bstrNewAuth);
    }
    if (bstrNewSecAuth)
    {
        SysFreeString(bstrNewSecAuth);
    }
    if (bstrConsent)
    {
        SysFreeString(bstrConsent);
    }

    PassportLog("CManager::OnStartPageManual Exit:\r\n");

    return hr;
}


//===========================================================================
//
// OnStartPageECB -- Authenticate with ECB -- for ISAPI extensions
//
STDMETHODIMP CManager::OnStartPageECB(
    LPBYTE  pvECB,
    DWORD*  bufSize,
    LPSTR   pCookieHeader
    )
{
    if (!pvECB)   return E_INVALIDARG;

    EXTENSION_CONTROL_BLOCK*    pECB = (EXTENSION_CONTROL_BLOCK*) pvECB;
    HRESULT hr = S_OK;
    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "OnStartPageECB",
         " <<< %lx, %lx, %d, %lx", pvECB, bufSize, *bufSize, pCookieHeader);

    ATL::CAutoVectorPtr<CHAR> spHTTPS;
    ATL::CAutoVectorPtr<CHAR> spheaders;

    spheaders.Attach(GetServerVariableECB(pECB, "ALL_RAW"));
    spHTTPS.Attach(GetServerVariableECB(pECB, "HTTPS"));

    DWORD flags = 0;
    if((CHAR*)spHTTPS && lstrcmpiA("on", (CHAR*)spHTTPS) == 0)
      flags |=  PASSPORT_HEADER_FLAGS_HTTPS;

    hr = OnStartPageHTTPRawEx(pECB->lpszMethod,
                              pECB->lpszPathInfo,
                              pECB->lpszQueryString,
                              NULL, // version
                              (CHAR*)spheaders,
                              flags, bufSize,
                              pCookieHeader);

    m_pECB = pECB;

    return hr;
}


//===========================================================================
//
// OnStartPageHTTPRaw -- Authenticate with HTTP request-line and headers
//     returns response headers as output parameters
//
STDMETHODIMP CManager::OnStartPageHTTPRaw(
            /* [string][in] */ LPCSTR request_line,
            /* [string][in] */ LPCSTR headers,
            /* [in] */ DWORD flags,
            /* [out][in] */ DWORD *bufSize,
            /* [size_is][out] */ LPSTR pCookieHeader)
{
     //  an old client, let's try the QS
     DWORD  dwSize;
     HRESULT   hr = S_OK;
     PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "OnStartPageHTTPRaw",
         " <<< %s, %s, %lx, %lx, %d, %lx", request_line, headers, flags, bufSize, *bufSize, pCookieHeader);
     LPCSTR pBuffer = GetRawQueryString(request_line, &dwSize);
     if (pBuffer)
     {
         TempSubStr tss(pBuffer, dwSize);

         hr = OnStartPageHTTPRawEx(NULL, NULL, pBuffer, NULL, headers, flags, bufSize, pCookieHeader);
     }
     else
         hr = OnStartPageHTTPRawEx(NULL, NULL, NULL, NULL, headers, flags, bufSize, pCookieHeader);

     return hr;
}

//===========================================================================
//
//  @func OnStartPageHTTPRawEx -- Authenticate with HTTP request-line and headers
//  returns response headers as output parameters.  If *bufsize is not smaller
//  the required length or pCookieHeader is NULL, the required length is returned
//  in bufsize.  In this case, an empty string is written into pCookieHeader if
//  it is not NULL.
//  method, path, HTTPVer are not being used in this version of the API
//
//  @rdesc  returns one of these values
//  @flag   E_POINTER   | NULL bufSize
//  @flag   E_POINTER   | not writable buffer given by pCookieHeader
//  @flag   PP_E_NOT_CONFIGURED | not valid state to call this method
//  @flag   S_OK
//
STDMETHODIMP CManager::OnStartPageHTTPRawEx(
            /* [string][in] */  LPCSTR method,
            /* [string][in] */  LPCSTR path,
            /* [string][in] */  LPCSTR QS,
            /* [string][in] */  LPCSTR HTTPVer,
            /* [string][in] */  LPCSTR headers,
            /* [in] */          DWORD  flags,
            /* [out][in] */     DWORD  *bufSize,        //@parm retuns the length of the headers.  Could be 0 to ask for the req. len.
            /* [size_is][out]*/ LPSTR  pCookieHeader)   //@parm buffer to hold the headers.  Could be NULL to ask for the req. len
{
    USES_CONVERSION;

    if(bufSize == NULL)
        return E_POINTER;

    HRESULT  hr = S_OK;

    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "OnStartPageHTTPRawEx",
         " <<< %s, %s, %s, %s, %s, %lx, %lx, %d, %lx", method, path, QS, HTTPVer, headers, flags, bufSize, *bufSize, pCookieHeader);

    PassportLog("CManager::OnStartPageHTTPRawEx Enter:\r\n");

    //
    //   12002: if *bufSize is 0, we will not be writing into pCookieHeader
    //
    if(*bufSize == 0)
        pCookieHeader = NULL;

    if(pCookieHeader && IsBadWritePtr(pCookieHeader, *bufSize))
        return E_POINTER;

    if (!g_config || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_piTicket || !m_piProfile)
    {
        return E_OUTOFMEMORY;
    }

    wipeState();

    DWORD                       dwSize;
    LPCSTR                      pBuffer;

    // used to convert to wide ...
    WCHAR    *pwszBuf = NULL;

    enum {
      header_Host,
      header_Accept_Auth,
      header_Authorization,
      header_Cookie,
      header_total

    };
    LPCSTR  headerNames[header_total] = { "Host", "Accept-Auth", "Authorization", "Cookie"};
    DWORD   headerSizes[header_total];
    LPCSTR  headerValues[header_total] = {0};

    GetRawHeaders(headers, headerNames, headerValues, headerSizes, header_total);

    //
    //  Use the header to get the server name being requested
    //  so we can get the correct registry config.  But only do this
    //  if we have some configured sites.
    //
    if(m_pRegistryConfig)
         m_pRegistryConfig->Release();
    pBuffer = headerValues[header_Host];
    if(g_config->HasSites() && pBuffer)
    {
        TempSubStr tss(pBuffer, headerSizes[header_Host]);
        TempSubStr tssRemovePort;

        LPSTR pPort = strstr(pBuffer, ":");
        if(pPort)
        {
             ++pPort;
             DWORD dwPort = atoi(pPort);
             if(dwPort == 80 || dwPort == 443)
             {
                 tssRemovePort.Set(pBuffer, pPort - pBuffer - 1);
             }
        }
        
        // for port 80 and 443, this should be removed
        PPTracePrint(PPTRACE_RAW, "SiteName %s", PPF_CHAR(pBuffer));
        m_pRegistryConfig = g_config->checkoutRegistryConfig((LPSTR)pBuffer);
    }
    else
    {
       PPTracePrint(PPTRACE_RAW, "Default Site");
       m_pRegistryConfig = g_config->checkoutRegistryConfig(NULL);
    }

    if (pCookieHeader)
        *pCookieHeader = '\0';

    //
    //  If we have a secure ticket/profile and the url is SSL,
    //  then tack on the MSPPuid cookie.
    //

    if(PASSPORT_HEADER_FLAGS_HTTPS & flags)
       m_bSecureTransported = true;
    else
       m_bSecureTransported = false;

    PPTracePrint(PPTRACE_RAW, "HTTPS:%d", m_bSecureTransported);

    //  see if client understands passport
    pBuffer = headerValues[header_Accept_Auth];
    if (pBuffer)
    {
        TempSubStr tss(pBuffer, headerSizes[header_Accept_Auth]);

        if (strstr(pBuffer, PASSPORT_PROT14_A))
        {
            m_bIsTweenerCapable = TRUE;
            PPTracePrint(PPTRACE_RAW, "PASSPORT_PROT14 capable");
        }

    }

    BSTR ret = NULL;
    CCoCrypt* crypt = NULL;

    BOOL    fParseSuccess = FALSE;
    pBuffer = headerValues[header_Authorization];
    PWSTR   pwszTicket = NULL, pwszProfile = NULL, pwszF = NULL;
    //  use these when t&p come from qs
    BSTR QSAuth = NULL, QSProf = NULL, QSErrflag = NULL;
    BSTR bstrConsent = NULL;
    BSTR bstrNewAuth = NULL;
    BSTR bstrNewSecAuth = NULL;


    if (pBuffer)
    {
        TempSubStr tss(pBuffer, headerSizes[header_Authorization]);

        // has passport auth header
        if(strstr(pBuffer, PASSPORT_PROT14_A))
        {
            //  convert to wide ...
            int cch = MultiByteToWideChar(GetACP(), 0, pBuffer, -1, NULL, NULL);

            pwszBuf = (WCHAR*)LocalAlloc(LMEM_FIXED, (cch + 1) * sizeof (WCHAR));
            if (NULL != pwszBuf)
            {
                if (0 != MultiByteToWideChar(GetACP(), 0, pBuffer, -1, pwszBuf, cch))
                {
                    BSTR bstrT = NULL;
                    BSTR bstrP = NULL;

                    GetTicketAndProfileFromHeader(pwszBuf, pwszTicket, pwszProfile, pwszF);

                    // due to the fact that handleQueryStringData wants BSTRs we can't use
                    // the direct pointers we just got, so we have to make copies.

                    if( pwszTicket == NULL ) 
                    {
                       bstrT = NULL;
                    }
                    else
                    {
                       bstrT = SysAllocString(pwszTicket);
                       if (NULL == bstrT)
                       {
                           hr = E_OUTOFMEMORY;
                           goto Cleanup;
                       }
                    }

                    if( pwszProfile == NULL ) 
                    {
                       bstrP = NULL;
                    }
                    else
                    {
                       bstrP = SysAllocString(pwszProfile);
                       if (NULL == bstrP)
                       {
                           SysFreeString(bstrT);
                           hr = E_OUTOFMEMORY;
                           goto Cleanup;
                       }
                    }

                    // make ticket and profile BSTRs
                    PPTracePrint(PPTRACE_RAW,
                        "PASSPORT_PROT14 Authorization <<< header:%ws, t:%ws, p:%ws, f:%ws",
                        pwszBuf, pwszTicket, pwszProfile, pwszF);

                    fParseSuccess = handleQueryStringData(bstrT, bstrP);
                    if (pwszF)
                        m_lNetworkError = _wtol(pwszF);

                    SysFreeString(bstrT);
                    SysFreeString(bstrP);
                }
           }
       }
       else
       {
           //  not our header. BUGBUG could there be multiple headers ???
          pBuffer = NULL;

       }
    }
    if (!pBuffer)
    {
        //  an old client, let's try the QS
        if (QS)
        {
            //  get ticket and profile ...
            // BUGBUG This could be optimized to avoid wide/short conversions, but later...
            GetQueryData(QS, &QSAuth, &QSProf, &QSErrflag);

            fParseSuccess = handleQueryStringData(QSAuth,QSProf);
            if(QSErrflag != NULL)
                m_lNetworkError = _wtol(QSErrflag);


            PPTracePrint(PPTRACE_RAW,
               "QueryString <<< t:%ws, p:%ws, f:%ws",
               QSAuth, QSProf, QSErrflag);
        }
    }

    if (fParseSuccess)
    {
         //
         //  If we got secure ticket or profile, then
         //  we need to re-encrypt the insecure version
         //  before setting the cookie headers.
         //

         PPTracePrint(PPTRACE_RAW, "Authenticated");

         // Set the cookies
         LPSTR ticketDomain = m_pRegistryConfig->getTicketDomain();
         LPSTR profileDomain = m_pRegistryConfig->getProfileDomain();
         LPSTR secureDomain = m_pRegistryConfig->getSecureDomain();
         LPSTR ticketPath = m_pRegistryConfig->getTicketPath();
         LPSTR profilePath = m_pRegistryConfig->getProfilePath();
         LPSTR securePath = m_pRegistryConfig->getSecurePath();
         VARIANT_BOOL persist;
         m_piTicket->get_HasSavedPassword(&persist);

         //  MSPConsent cookie
         BOOL bSetConsent = (S_OK == IfConsentCookie(&bstrConsent));

         // Build the cookie headers.

         // the authentication cookies
         BSTR  auth, secAuth; // do not call SysFreeString on them, they are skin level copy

         if (S_OK == IfAlterAuthCookie(&bstrNewAuth, &bstrNewSecAuth))
         {
            auth = bstrNewAuth;
            secAuth = bstrNewSecAuth;
         }
         else
         {
            if (pwszTicket)
            {
                auth = pwszTicket;
            }
            else
            {
                auth = QSAuth;
            }
            secAuth = NULL;
         }

         // build cookies for output
         BuildCookieHeaders(W2A(auth),
                            (pwszProfile ? W2A(pwszProfile) : (QSProf ? W2A(QSProf) : NULL)),
                            (bSetConsent ? W2A(bstrConsent) : NULL),
                            (secAuth ? W2A(secAuth) : NULL),
                            ticketDomain,
                            ticketPath,
                            profileDomain,
                            profilePath,
                            secureDomain,
                            securePath,
                            persist,
                            pCookieHeader,
                            bufSize,
                            !m_pRegistryConfig->getNotUseHTTPOnly());

         PPTracePrint(PPTRACE_RAW,
               "Cookie headers >>> %s",PPF_CHAR(pCookieHeader));


    }

    if (QSAuth) FREE_BSTR(QSAuth);
    if (QSProf) FREE_BSTR(QSProf);
    if (QSErrflag) FREE_BSTR(QSErrflag);

    if (bstrNewAuth)
    {
        SysFreeString(bstrNewAuth);
    }
    if (bstrNewSecAuth)
    {
        SysFreeString(bstrNewSecAuth);
    }
    if (bstrConsent)
    {
        SysFreeString(bstrConsent);
    }

    // Now, check the cookies
    if (!m_fromQueryString)
    {
        BSTR CookieAuth = NULL, CookieProf = NULL, CookieConsent = NULL, CookieSecure = NULL;
        pBuffer = headerValues[header_Cookie];
        if(pBuffer)
        {
            TempSubStr tss(pBuffer, headerSizes[header_Cookie]);

            GetCookie(pBuffer, "MSPAuth", &CookieAuth);  // GetCookie has URLDecode in it
            GetCookie(pBuffer, "MSPProf", &CookieProf);
            GetCookie(pBuffer, "MSPConsent", &CookieConsent);
            GetCookie(pBuffer, "MSPSecAuth", &CookieSecure);

            handleCookieData(CookieAuth,CookieProf,CookieConsent,CookieSecure);

            PPTracePrint(PPTRACE_RAW,
               "Cookies <<< t:%ws, p:%ws, c:%ws, s:%ws",
               CookieAuth, CookieProf, CookieConsent, CookieSecure);

            if (CookieAuth) FREE_BSTR(CookieAuth);
            if (CookieProf) FREE_BSTR(CookieProf);
            if (CookieConsent) FREE_BSTR(CookieConsent);
            if (CookieSecure) FREE_BSTR(CookieSecure);
        }

        // we are not returning cookie info back
        if (pCookieHeader)
            *pCookieHeader = 0;
        *bufSize = 0;
    }

    PassportLog("CManager::OnStartPageHTTPRawEx Exit:\r\n");
    hr = S_OK;
Cleanup:
    if (NULL != pwszBuf)
    {
        // free the memory since we no longer need it
        LocalFree(pwszBuf);
    }

    return hr;
}

//===========================================================================
//
// ContinueStartPageBody
// -- when OnStartPageHTTPRaw  returns PP_E_HTTP_BODY_REQUIRED, this func is expected to call
// not doing anything for 2.0 release
STDMETHODIMP CManager::ContinueStartPageHTTPRaw(
            /* [in] */ DWORD bodyLen,
            /* [size_is][in] */ byte *body,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pRespHeaders,
            /* [out][in] */ DWORD *pRespBodyLen,
            /* [size_is][out] */ byte *pRespBody)
{
   return E_NOTIMPL;
}

//===========================================================================
//
// OnStartPageFilter -- for ISAPI filters
//
STDMETHODIMP CManager::OnStartPageFilter(
    LPBYTE  pvPFC,
    DWORD*  bufSize,
    LPSTR   pCookieHeader
    )
{
    if (!pvPFC)    return E_INVALIDARG;

    PHTTP_FILTER_CONTEXT    pfc = (PHTTP_FILTER_CONTEXT) pvPFC;

    HRESULT hr = S_OK;
    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "OnStartPageFilter",
         " <<< %lx, %lx, %d, %lx", pvPFC, bufSize, *bufSize, pCookieHeader);

    ATL::CAutoVectorPtr<CHAR> spheaders;
    ATL::CAutoVectorPtr<CHAR> spHTTPS;
    ATL::CAutoVectorPtr<CHAR> spQS;

    spheaders.Attach(GetServerVariablePFC(pfc, "ALL_RAW"));
    spHTTPS.Attach(GetServerVariablePFC(pfc, "HTTPS"));
    spQS.Attach(GetServerVariablePFC(pfc, "QUERY_STRING"));

    DWORD flags = 0;
    if((CHAR*)spHTTPS && lstrcmpiA("on", (CHAR*)spHTTPS) == 0)
      flags |=  PASSPORT_HEADER_FLAGS_HTTPS;

    hr = OnStartPageHTTPRawEx(NULL, NULL, (CHAR*)spQS, NULL, (CHAR*)spheaders, flags, bufSize, pCookieHeader);

    m_pFC = pfc;

    return hr;
}

//===========================================================================
//
// OnEndPage
//
STDMETHODIMP CManager::OnEndPage ()
{
    PassportLog("CManager::OnEndPage Enter:\r\n");

    if (m_bOnStartPageCalled)
    {
        m_bOnStartPageCalled = false;
        // Release all interfaces
        m_piRequest.Release();
        m_piResponse.Release();
    }

    if (!m_piTicket || !m_piProfile)
    {
        return E_OUTOFMEMORY;
    }

    // Just in case...
    m_piTicket->put_unencryptedTicket(NULL);
    m_piProfile->put_unencryptedProfile(NULL);
    m_profileValid = m_ticketValid = VARIANT_FALSE;
    m_fromQueryString = false;

    if(m_pRegistryConfig)
    {
        m_pRegistryConfig->Release();
        m_pRegistryConfig = NULL;
    }

    PassportLog("CManager::OnEndPage Exit:\r\n");

    return S_OK;
}

//===========================================================================
//
// AuthURL
//
//
//  Old API. Auth URL is pointing to the login server
//
STDMETHODIMP
CManager::AuthURL(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vSecureLevel,
    BSTR *pAuthUrl)
{
    CComVariant   vEmpty(_T(""));
    return CommonAuthURL(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vNameSpace,
                         vKPP, vSecureLevel,
                         FALSE, vEmpty, pAuthUrl);

}

//===========================================================================
//
// AuthURL2
//
//
//  new API. return URL is to the login server
//
STDMETHODIMP
CManager::AuthURL2(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vSecureLevel,
    BSTR *pAuthUrl)
{
    CComVariant   vEmpty(_T(""));
    return CommonAuthURL(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vNameSpace,
                         vKPP, vSecureLevel,
                         TRUE, vEmpty, pAuthUrl);

}

//===========================================================================
//
// CommonAuthURL
//
//
//  AuthURL implementation
//
STDMETHODIMP
CManager::CommonAuthURL(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vSecureLevel,
    BOOL    fRedirToSelf,
    VARIANT vFunctionArea, // BSTR: e.g. Wireless
    BSTR *pAuthUrl)
{
    USES_CONVERSION;
    time_t ct;
    WCHAR url[MAX_URL_LENGTH] = L"";
    VARIANT freeMe;
    UINT         TimeWindow;
    int          nKPP;
    VARIANT_BOOL ForceLogin = VARIANT_FALSE;
    ULONG        ulSecureLevel = 0;
    BSTR         CBT = NULL, returnUrl = NULL, bstrNameSpace = NULL;
    int          hasCB, hasRU, hasLCID, hasTW, hasFL, hasNameSpace, hasKPP, hasUseSec;
    USHORT       Lang;
    HRESULT      hr = S_OK;

    BSTR         bstrFunctionArea = NULL;
    int          hasFunctionArea;
    CNexusConfig* cnc = NULL;

    PassportLog("CManager::CommonAuthURL Enter:\r\n");

    if (!g_config) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                    IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                    IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    // Make sure args are of the right type
    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasUseSec = GetIntArg(vSecureLevel, (int*)&ulSecureLevel)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD)
        return E_INVALIDARG;
    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;
    if (hasCB == CV_FREE)
    {
        TAKEOVER_BSTR(CBT);
    }

    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            FREE_BSTR(CBT);
        return E_INVALIDARG;
    }
    if (hasRU == CV_FREE)
    {
        TAKEOVER_BSTR(returnUrl);
    }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            SysFreeString(CBT);
        if (hasRU == CV_FREE && returnUrl)
            SysFreeString(returnUrl);
        return E_INVALIDARG;
    }
    if (hasNameSpace == CV_FREE)
    {
        TAKEOVER_BSTR(bstrNameSpace);
    }
    if (hasNameSpace == CV_DEFAULT)
    {
        bstrNameSpace = m_pRegistryConfig->getNameSpace();
    }

    // **************************************************
    // Logging
    if (NULL != returnUrl)
    {
        PassportLog("    RU = %ws\n", returnUrl);
    }
    PassportLog("    TW = %X,   SL = %X,   L = %d,   KPP = %X\r\n", TimeWindow, ulSecureLevel, Lang, nKPP);
    if (NULL != bstrNameSpace)
    {
        PassportLog("    NS = %ws\r\n", bstrNameSpace);
    }
    if (NULL != CBT)
    {
        PassportLog("    CBT = %ws\r\n", CBT);
    }
    // **************************************************

    hasFunctionArea = GetBstrArg(vFunctionArea, &bstrFunctionArea);
    if (hasFunctionArea == CV_FREE)
    {
        TAKEOVER_BSTR(bstrFunctionArea);
    }

    if(hasUseSec == CV_DEFAULT)
        ulSecureLevel = m_pRegistryConfig->getSecureLevel();

    WCHAR *szAUAttrName;

    if (SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    BSTR   szAttrName_FuncArea = NULL;
    if (bstrFunctionArea != NULL)
    {
        szAttrName_FuncArea = SysAllocStringLen(NULL, wcslen(bstrFunctionArea) + wcslen(szAUAttrName));
        if (NULL == szAttrName_FuncArea)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        wcscpy(szAttrName_FuncArea, bstrFunctionArea);
        wcscat(szAttrName_FuncArea, szAUAttrName);
    }

    cnc = g_config->checkoutNexusConfig();

    if (hasLCID == CV_DEFAULT)
        Lang = m_pRegistryConfig->getDefaultLCID();
    if (hasKPP == CV_DEFAULT)
        nKPP = m_pRegistryConfig->getKPP();
    VariantInit(&freeMe);

    if (!m_pRegistryConfig->DisasterModeP())
    {
        // If I'm authenticated, get my domain specific url
        if (m_ticketValid && m_profileValid)
        {
            HRESULT hr = m_piProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe);
            if (hr != S_OK || freeMe.vt != VT_BSTR)
            {
               if (bstrFunctionArea)
               {
                  cnc->getDomainAttribute(L"Default",
                                        szAttrName_FuncArea,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }

               if (*url == 0) // nothing is in URL string
               {
                   cnc->getDomainAttribute(L"Default",
                                        szAUAttrName,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }
            }
            else
            {
               LPCWSTR psz = wcsrchr(freeMe.bstrVal, L'@');
               if (bstrFunctionArea)
               {
                  cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAttrName_FuncArea,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }

               if (*url == 0) // nothing is in URL string
               {
                  cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAUAttrName,
                                        sizeof(url) / sizeof(WCHAR),
                                        url,
                                        Lang);
               }
            }
        }
        else
        {
           if (bstrFunctionArea)
           {
              cnc->getDomainAttribute(L"Default",
                                    szAttrName_FuncArea,
                                    sizeof(url) / sizeof(WCHAR),
                                    url,
                                    Lang);
           }
        }
        if(*url == 0)   // nothing in URL string
        {
           cnc->getDomainAttribute(L"Default",
                                 szAUAttrName,
                                 sizeof(url) / sizeof(WCHAR),
                                 url,
                                 Lang);
        }
    }
    else
        lstrcpynW(url, m_pRegistryConfig->getDisasterUrl(), sizeof(url) / sizeof(WCHAR));

    time(&ct);

    if (*url == L'\0')
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = m_pRegistryConfig->getDefaultRU();
    if (returnUrl == NULL)
        returnUrl = L"";

    if(ulSecureLevel == VARIANT_TRUE)  // special case for backward compatible
        ulSecureLevel = k_iSeclevelSecureChannel;

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        WCHAR buf[20];
        _itow(TimeWindow,buf,10);
        AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                        IID_IPassportManager, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

    if (NULL == pAuthUrl)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pAuthUrl = FormatAuthURL(
                            url,
                            m_pRegistryConfig->getSiteId(),
                            returnUrl,
                            TimeWindow,
                            ForceLogin,
                            m_pRegistryConfig->getCurrentCryptVersion(),
                            ct,
                            CBT,
                            bstrNameSpace,
                            nKPP,
                            Lang,
                            ulSecureLevel,
                            m_pRegistryConfig,
                            fRedirToSelf,
                            IfCreateTPF()
                            
                            );
    if (NULL == *pAuthUrl)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    if (szAttrName_FuncArea)
    {
        SysFreeString(szAttrName_FuncArea);
    }

    if (NULL != cnc)
    {
        cnc->Release();
    }
    if (hasFunctionArea== CV_FREE && bstrFunctionArea)
        FREE_BSTR(bstrFunctionArea);

    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);

    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);

    // !!! need to confirmation
    if (hasNameSpace == CV_FREE && bstrNameSpace)
        FREE_BSTR(bstrNameSpace);

    VariantClear(&freeMe);

    PassportLog("CManager::CommonAuthURL Exit: %X\r\n", hr);

    return hr;
}

//===========================================================================
//
// GetLoginChallenge
//  return AuthURL,
//  output parameter: tweener authHeader
//
//  get AuthURL and AuthHeaders
//
STDMETHODIMP CManager::GetLoginChallenge(VARIANT vReturnUrl,
                                 VARIANT vTimeWindow,
                                 VARIANT vForceLogin,
                                 VARIANT vCoBrandTemplate,
                                 VARIANT vLCID,
                                 VARIANT vNameSpace,
                                 VARIANT vKPP,
                                 VARIANT vSecureLevel,
                                 VARIANT vExtraParams,
                                 BSTR*   pAuthHeader
                                 )
{
    if (!pAuthHeader)   return E_INVALIDARG;
    VARIANT vHeader;

    VariantInit(&vHeader);
    HRESULT hr = GetLoginChallengeInternal(
                                          vReturnUrl, 
                                          vTimeWindow, 
                                          vForceLogin, 
                                          vCoBrandTemplate, 
                                          vLCID, 
                                          vNameSpace, 
                                          vKPP,
                                          vSecureLevel, 
                                          vExtraParams,
                                          &vHeader,
                                          NULL);

    if(S_OK == hr && V_VT(&vHeader) == VT_BSTR && V_BSTR(&vHeader))
    {
      *pAuthHeader = V_BSTR(&vHeader);
      VariantInit(&vHeader);
    }
    else
       VariantClear(&vHeader);
    return  hr;
}

//===========================================================================
//
// GetLoginChallengeInternal
//  return AuthURL,
//  output parameter: tweener authHeader
//
//  get AuthURL and AuthHeaders
//
STDMETHODIMP CManager::GetLoginChallengeInternal(VARIANT vReturnUrl,
                                 VARIANT vTimeWindow,
                                 VARIANT vForceLogin,
                                 VARIANT vCoBrandTemplate,
                                 VARIANT vLCID,
                                 VARIANT vNameSpace,
                                 VARIANT vKPP,
                                 VARIANT vSecureLevel,
                                 VARIANT vExtraParams,
                                 VARIANT *pAuthHeader,
                                 BSTR*   pAuthVal
                                 )
{
    HRESULT hr = S_OK;

    if (pAuthVal)
    {
        *pAuthVal = NULL;
    }
    if (pAuthHeader)
    {
        V_BSTR(pAuthHeader) = NULL;
    }

    _bstr_t strAuthHeader;

    try
    {
        //  format qs and WWW-Authenticate header ....
        _bstr_t strUrl, strRetUrl, strCBT, strNameSpace;
        UINT    TimeWindow;
        int     nKPP;
        time_t  ct;
        VARIANT_BOOL    ForceLogin;
        ULONG   ulSecureLevel;
        WCHAR   rgLCID[10];
        hr = GetLoginParams(vReturnUrl,
                            vTimeWindow,
                            vForceLogin,
                            vCoBrandTemplate,
                            vLCID,
                            vNameSpace,
                            vKPP,
                            vSecureLevel,
                            strUrl,
                            strRetUrl,
                            TimeWindow,
                            ForceLogin,
                            ct,
                            strCBT,
                            strNameSpace,
                            nKPP,
                            ulSecureLevel,
                            rgLCID);

        if (S_OK == hr && strUrl.length() != 0)
        {
            WCHAR   szBuf[MAX_QS_LENGTH] = L"";
            //  prepare redirect URL to the login server for
            //  downlevel clients
            if (NULL == FormatAuthURLParameters(strUrl,
                                m_pRegistryConfig->getSiteId(),
                                strRetUrl,
                                TimeWindow,
                                ForceLogin,
                                m_pRegistryConfig->getCurrentCryptVersion(),
                                ct,
                                strCBT,
                                strNameSpace,
                                nKPP,
                                szBuf,
                                sizeof(szBuf)/sizeof(WCHAR),
                                0,      // lang does not matter ....
                                ulSecureLevel,
                                m_pRegistryConfig,
                                FALSE,
                                IfCreateTPF()
                                )) //  do not redirect to self!
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            //  insert the WWW-Authenticate header ...
            hr = FormatAuthHeaderFromParams(strUrl,
                                   strRetUrl,
                                   TimeWindow,
                                   ForceLogin,
                                   ct,
                                   strCBT,
                                   strNameSpace,
                                   nKPP,
                                   rgLCID,
                                   ulSecureLevel,
                                   strAuthHeader);
            if (S_OK != hr)
            {
                goto Cleanup;
            }

            //  and add the extra ....
            BSTR    strExtra = NULL;
            int res = GetBstrArg(vExtraParams, &strExtra);

            if (res != CV_BAD)
            {
                if (res == CV_DEFAULT)
                {
                    strExtra = m_pRegistryConfig->getExtraParams();
                }
                if (NULL != strExtra)
                {
                    strAuthHeader += _bstr_t(L",") + strExtra;
                }
            }

            if (res == CV_FREE)
                 ::SysFreeString(strExtra);

            // set return values
            if (pAuthHeader && (WCHAR*)strAuthHeader != NULL)
            {
                V_VT(pAuthHeader) = VT_BSTR;
                // TODO: should avoid this SysAllocString
                V_BSTR(pAuthHeader) = ::SysAllocString((WCHAR*)strAuthHeader);
                if (NULL == V_BSTR(pAuthHeader))
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
            }

            if (pAuthVal)
            {
                *pAuthVal = ::SysAllocString(szBuf);
                if (NULL == *pAuthVal)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
            }
        }
    }
    catch(...)
    {
      hr = E_OUTOFMEMORY;
    }

Cleanup:
    return  hr;
}

//===========================================================================
//
// LoginUser
//
//
//  client logon method
//  vExtraParams: coBranding text is passed as cbtxt=cobrandingtext
//                the content of the input parameter should be UTF8 encoded, and
//                properly URL escapted before passing into this function
//
STDMETHODIMP CManager::LoginUser(VARIANT vReturnUrl,
                                 VARIANT vTimeWindow,
                                 VARIANT vForceLogin,
                                 VARIANT vCoBrandTemplate,
                                 VARIANT vLCID,
                                 VARIANT vNameSpace,
                                 VARIANT vKPP,
                                 VARIANT vSecureLevel,
                                 VARIANT vExtraParams)
{
    //  format qs and WWW-Authenticate header ....
    BSTR      authURL = NULL;
    CComVariant   authHeader;

    PassportLog("CManager::LoginUser Enter:\r\n");

    HRESULT       hr = GetLoginChallengeInternal( vReturnUrl,
                                          vTimeWindow,
                                          vForceLogin,
                                          vCoBrandTemplate,
                                          vLCID,
                                          vNameSpace,
                                          vKPP,
                                          vSecureLevel,
                                          vExtraParams,
                                          &authHeader,
                                          &authURL);

    if (S_OK == hr)
    {
       _ASSERT(V_VT(&authHeader) == VT_BSTR);
       _ASSERT(authURL);
       _ASSERT(V_BSTR(&authHeader));

       // TODO: _bstr_t should be removed globaly in ppm
        if (m_piResponse)
        {
            m_piResponse->AddHeader(L"WWW-Authenticate", V_BSTR(&authHeader));

            _bstr_t    authURL1 = authURL;

            //  and redirect!
            if (!m_bIsTweenerCapable)
                m_piResponse->Redirect(authURL1);
            else
            {
                //  send a 401
                m_piResponse->put_Status(L"401 Unauthorized");
                m_piResponse->End();
            }
        }
        else if (m_pECB || m_pFC)
        {
            //  use ECB of Filter interfaces
            //  4k whould be enough ....
            char buffer[4096],
                 status[25] = "302 Object moved",
                 *psz=buffer,
                 rgszTemplate[] = "Content-Type: text/html\r\nLocation: %ws\r\n"
                               "Content-Length: 0\r\n"
                               "WWW-Authenticate: %ws\r\n\r\n";
            DWORD cbTotalLength = strlen(rgszTemplate);
            
            //
            // This is a hack fix, unfortunately we can succeed the call to GetChallengeInternal but
            // have a NULL authHeader, it seemed a bit risky to try and fix GetLoginParams which
            // seems to be the function which returns success when allocations are failing.
            //
            if ((NULL == V_BSTR(&authHeader)) || (NULL == (BSTR)authURL))
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            cbTotalLength += wcslen(V_BSTR(&authHeader)) + wcslen(authURL);

            if (m_bIsTweenerCapable)
                strcpy(status, "401 Unauthorized");
            if (cbTotalLength >= sizeof(buffer))
            {
                //  if not ...
                //  need to alloc
                psz = new CHAR[cbTotalLength];
                _ASSERT(psz);
            }

            if (psz)
            {
                sprintf(psz,
                        rgszTemplate,
                        authURL,
                        V_BSTR(&authHeader));
                if (m_pECB)
                {
                    //  extension
                    HSE_SEND_HEADER_EX_INFO Headers =
                    {
                        status,
                        psz,
                        strlen(status),
                        strlen(psz),
                        TRUE
                    };
                    if (!m_pECB->ServerSupportFunction(m_pECB->ConnID,
                                                  HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                                  &Headers,
                                                  NULL,
                                                  NULL))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    //  filter
                    if (!m_pFC->ServerSupportFunction(m_pFC,
                                                 SF_REQ_SEND_RESPONSE_HEADER,
                                                 status,
                                                 (ULONG_PTR) psz,
                                                 NULL))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }

                if (psz != buffer)
                    //  if we had to allocate
                    delete[]  psz;

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

Cleanup:
    if (authURL)
    {
        SysFreeString(authURL);
    }

    PassportLog("CManager::LoginUser Exit: %X\r\n", hr);

    return  hr;
}



//===========================================================================
//
// IsAuthenticated -- determine if authenticated with specified SecureLevel
//
STDMETHODIMP CManager::IsAuthenticated(
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT SecureLevel,
    VARIANT_BOOL *pVal)
{
    HRESULT hr;
    ULONG TimeWindow;
    VARIANT_BOOL ForceLogin;
    ATL::CComVariant vSecureLevel;
    ULONG ulSecureLevel;
    int hasTW, hasFL, hasSecureLevel;

    PassportLog("CManager::IsAuthenticated Enter:\r\n");

    PPTraceFunc<HRESULT> func(PPTRACE_FUNC, hr,
         "IsAuthenticated", "<<< %lx, %lx, %1x, %1x",
         V_I4(&vTimeWindow), V_I4(&vForceLogin), V_I4(&SecureLevel), pVal);

    if (!m_piTicket || !m_piProfile)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!g_config) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
            IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
            IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    if ((hasTW = GetIntArg(vTimeWindow,(int*)&TimeWindow)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();

    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;

    hasSecureLevel = GetIntArg(SecureLevel, (int*)&ulSecureLevel);
    if(hasSecureLevel == CV_BAD) // try the legacy type VT_BOOL, map VARIANT_TRUE to SecureChannel
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    else if (hasSecureLevel == CV_DEFAULT)
    {
        ulSecureLevel = m_pRegistryConfig->getSecureLevel();
    }

    if(ulSecureLevel == VARIANT_TRUE)// backward compatible with 1.3X
    {
      ulSecureLevel = k_iSeclevelSecureChannel;
    }

    vSecureLevel = ulSecureLevel;

    // Logging
    PassportLog("    TW = %X,   SL = %X\r\n", TimeWindow, ulSecureLevel);

    hr = m_piTicket->get_IsAuthenticated(TimeWindow, ForceLogin, vSecureLevel, pVal);
    PPTracePrint(PPTRACE_RAW, "IsAuthenticated Params: %d, %d, %d, %lx", TimeWindow, ForceLogin, ulSecureLevel, *pVal);

Cleanup:

    if(g_pPerf)
    {
        if (*pVal)
        {
            g_pPerf->incrementCounter(PM_AUTHSUCCESS_TOTAL);
            g_pPerf->incrementCounter(PM_AUTHSUCCESS_SEC);
        }
        else
        {
            g_pPerf->incrementCounter(PM_AUTHFAILURE_TOTAL);
            g_pPerf->incrementCounter(PM_AUTHFAILURE_SEC);
        }
    }
    else
    {
        _ASSERT(g_pPerf);
    }

    PassportLog("CManager::IsAuthenticated Exit: %X\r\n", hr);

    return hr;
}

//===========================================================================
//
// LogoTag
//
//
//  old PM API. The URL is pointing to login server
//
STDMETHODIMP
CManager::LogoTag(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vSecure,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vSecureLevel,
    BSTR *pVal)
{
    return CommonLogoTag(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vSecure,
                         vNameSpace, vKPP, vSecureLevel,
                         FALSE, pVal);
}

//===========================================================================
//
// LogoTag2
//
//
//  new PM API. The URL is pointing to the partner site
//
STDMETHODIMP
CManager::LogoTag2(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vSecure,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vSecureLevel,
    BSTR *pVal)
{
    return CommonLogoTag(vRU, vTimeWindow, vForceLogin,
                         vCoBrand, vLCID, vSecure,
                         vNameSpace, vKPP, vSecureLevel,
                         TRUE, pVal);
}

//===========================================================================
//
// CommonLogoTag
//
STDMETHODIMP
CManager::CommonLogoTag(
    VARIANT vRU,
    VARIANT vTimeWindow,
    VARIANT vForceLogin,
    VARIANT vCoBrand,
    VARIANT vLCID,
    VARIANT vSecure,
    VARIANT vNameSpace,
    VARIANT vKPP,
    VARIANT vSecureLevel,
    BOOL    fRedirToSelf,
    BSTR *pVal)
{
    time_t          ct;
    ULONG           TimeWindow;
    int             nKPP;
    VARIANT_BOOL    ForceLogin, bSecure = VARIANT_FALSE;
    ULONG           ulSecureLevel = 0;
    BSTR            CBT = NULL, returnUrl = NULL, NameSpace = NULL;
    int             hasCB = -1, hasRU = -1, hasLCID, hasTW, hasFL, hasSec, hasUseSec, hasNameSpace = -1, hasKPP;
    USHORT          Lang;
    LPWSTR          pszNewURL = NULL;
    BSTR            upd = NULL;
    CNexusConfig*   cnc = NULL;
    HRESULT         hr = S_OK;

    USES_CONVERSION;

    PassportLog("CManager::CommonLogoTag Enter:\r\n");

    time(&ct);

    if (NULL == pVal)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pVal = NULL;

    if (!g_config) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    //
    // parameters parsing ...

    // Make sure args are of the right type
    if ( ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD) ||
         ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD) ||
         ((hasSec = GetBoolArg(vSecure,&bSecure)) == CV_BAD) ||
         // FUTURE: should introduce a new func: GetLongArg ...
         ((hasUseSec = GetIntArg(vSecureLevel,(int*)&ulSecureLevel)) == CV_BAD) ||
         ((hasLCID = GetShortArg(vLCID,&Lang)) == CV_BAD) ||
         ((hasKPP = GetIntArg(vKPP, &nKPP)) == CV_BAD) )
	{
        hr = E_INVALIDARG;
	    goto Cleanup;
	}

    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
	{
        hr = E_INVALIDARG;
		goto Cleanup;
	}
    if (hasCB == CV_FREE)
    {
        TAKEOVER_BSTR(CBT);
    }
    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        hr = E_INVALIDARG;
		goto Cleanup;
    }
    if (hasRU == CV_FREE)
    {
        TAKEOVER_BSTR(returnUrl);
    }
    hasNameSpace = GetBstrArg(vNameSpace, &NameSpace);
    if (hasNameSpace == CV_BAD)
    {
        hr = E_INVALIDARG;
		goto Cleanup;
    }
    if (hasNameSpace == CV_FREE)
    {
        TAKEOVER_BSTR(NameSpace);
    }
    if (hasNameSpace == CV_DEFAULT)
    {
        NameSpace = m_pRegistryConfig->getNameSpace();
    }

    WCHAR *szSIAttrName, *szSOAttrName;
    if (hasSec == CV_OK && bSecure == VARIANT_TRUE)
    {
        szSIAttrName = L"SecureSigninLogo";
        szSOAttrName = L"SecureSignoutLogo";
    }
    else
    {
        szSIAttrName = L"SigninLogo";
        szSOAttrName = L"SignoutLogo";
    }

    if(hasUseSec == CV_DEFAULT)
        ulSecureLevel = m_pRegistryConfig->getSecureLevel();

    if(ulSecureLevel == VARIANT_TRUE)  // special case for backward compatible
        ulSecureLevel = k_iSeclevelSecureChannel;


    WCHAR *szAUAttrName;
    if (SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    cnc = g_config->checkoutNexusConfig();
    if (NULL == cnc)
    {
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    if (hasLCID == CV_DEFAULT)
        Lang = m_pRegistryConfig->getDefaultLCID();

    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        CBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = m_pRegistryConfig->getDefaultRU();
    if (hasKPP == CV_DEFAULT)
        nKPP = m_pRegistryConfig->getKPP();
    if (returnUrl == NULL)
        returnUrl = L"";

    // **************************************************
    // Logging
    PassportLog("    RU = %ws\r\n", returnUrl);
    PassportLog("    TW = %X,   SL = %X,   L = %d,   KPP = %X\r\n", TimeWindow, ulSecureLevel, Lang, nKPP);
    if (NULL != NameSpace)
    {
        PassportLog("    NS = %ws\r\n", NameSpace);
    }
    if (NULL != CBT)
    {
        PassportLog("    CBT = %ws\r\n", CBT);
    }
    // **************************************************

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        WCHAR buf[20];
        _itow(TimeWindow,buf,10);
        AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                        IID_IPassportManager, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

    if (m_ticketValid)
    {
        LPCWSTR domain = NULL;
        WCHAR url[MAX_URL_LENGTH];
        VARIANT freeMe;
        VariantInit(&freeMe);

        if (m_pRegistryConfig->DisasterModeP())
            lstrcpynW(url, m_pRegistryConfig->getDisasterUrl(), sizeof(url)/sizeof(WCHAR));
        else
        {
            if (m_profileValid &&
                m_piProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe) == S_OK &&
                freeMe.vt == VT_BSTR)
            {
                domain = wcsrchr(freeMe.bstrVal, L'@');
            }

            cnc->getDomainAttribute(L"Default",
                                    L"Logout",
                                    sizeof(url)/sizeof(WCHAR),
                                    url,
                                    Lang);
        }

        // find out if there are any updates
        m_piProfile->get_updateString(&upd);

        if (upd)
        {
            TAKEOVER_BSTR(upd);
            // form the appropriate URL
            CCoCrypt* crypt = NULL;
            BSTR newCH = NULL;
            crypt = m_pRegistryConfig->getCurrentCrypt(); // IsValid ensures this is non-null

            if (!crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                                (LPSTR)upd,
                                SysStringByteLen(upd),
                                &newCH))
            {
                AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_UNABLE_TO_ENCRYPTSTR,
                               IID_IPassportManager, PP_E_UNABLE_TO_ENCRYPT);
                hr = PP_E_UNABLE_TO_ENCRYPT;
                goto Cleanup;
            }
            TAKEOVER_BSTR(newCH);
            WCHAR iurlbuf[1024] = L"";
            LPCWSTR iurl;
            cnc->getDomainAttribute(domain ? domain+1 : L"Default",
                                    L"Update",
                                    sizeof(iurlbuf) >> 1,
                                    iurlbuf,
                                    Lang);

            if(*iurlbuf == 0)
            {
                cnc->getDomainAttribute(L"Default",
                                        L"Update",
                                        sizeof(iurlbuf) >> 1,
                                        iurlbuf,
                                        Lang);
            }
            // convert this url to https as appropriate
            if(!bSecure)
                iurl = iurlbuf;
            else
            {
                LPWSTR psz;

                pszNewURL = SysAllocStringByteLen(NULL, (lstrlenW(iurlbuf) + 2) * sizeof(WCHAR));

                if(pszNewURL)
                {
                    psz = wcsstr(iurlbuf, L"http:");
                    if(psz != NULL)
                    {
                        psz += 4;

                        lstrcpynW(pszNewURL, iurlbuf, (psz - iurlbuf + 1));
                        lstrcatW(pszNewURL, L"s");
                        lstrcatW(pszNewURL, psz);

                        iurl = pszNewURL;
                    }
                }
            }

            // This is a bit gross... we need to find the $1 in the update url...
            LPCWSTR ins = iurl ? (wcsstr(iurl, L"$1")) : NULL;
            // We'll break if null, but won't crash...
            if (ins && *url != L'\0')
            {
                *pVal = FormatUpdateLogoTag(
                                        url,
                                        m_pRegistryConfig->getSiteId(),
                                        returnUrl,
                                        TimeWindow,
                                        ForceLogin,
                                        m_pRegistryConfig->getCurrentCryptVersion(),
                                        ct,
                                        CBT,
                                        nKPP,
                                        iurl,
                                        bSecure,
                                        newCH,
                                        PM_LOGOTYPE_SIGNOUT,
                                        ulSecureLevel,
                                        m_pRegistryConfig,
                                        IfCreateTPF()
                                        );
            }
            FREE_BSTR(newCH);
        }
        else
        {
            WCHAR iurl[MAX_URL_LENGTH] = L"";
            cnc->getDomainAttribute(L"Default",
                                    szSOAttrName,
                                    sizeof(iurl)/sizeof(WCHAR),
                                    iurl,
                                    Lang);
            if (*iurl != L'\0')
            {
                *pVal = FormatNormalLogoTag(
                                    url,
                                    m_pRegistryConfig->getSiteId(),
                                    returnUrl,
                                    TimeWindow,
                                    ForceLogin,
                                    m_pRegistryConfig->getCurrentCryptVersion(),
                                    ct,
                                    CBT,
                                    iurl,
                                    NULL,
                                    nKPP,
                                    PM_LOGOTYPE_SIGNOUT,
                                    Lang,
                                    ulSecureLevel,
                                    m_pRegistryConfig,
                                    fRedirToSelf,
                                    IfCreateTPF()
                                    );
            }
        }
        VariantClear(&freeMe);
        if (NULL == *pVal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    else
    {
        WCHAR url[MAX_URL_LENGTH];
        if (!(m_pRegistryConfig->DisasterModeP()))
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    sizeof(url)/sizeof(WCHAR),
                                    url,
                                    Lang);
        else
            lstrcpynW(url, m_pRegistryConfig->getDisasterUrl(), sizeof(url)/sizeof(WCHAR));

        WCHAR iurl[MAX_URL_LENGTH];
        cnc->getDomainAttribute(L"Default",
                                szSIAttrName,
                                sizeof(iurl)/sizeof(WCHAR),
                                iurl,
                                Lang);
        if (*iurl != L'\0')
        {
            *pVal = FormatNormalLogoTag(
                                url,
                                m_pRegistryConfig->getSiteId(),
                                returnUrl,
                                TimeWindow,
                                ForceLogin,
                                m_pRegistryConfig->getCurrentCryptVersion(),
                                ct,
                                CBT,
                                iurl,
                                NameSpace,
                                nKPP,
                                PM_LOGOTYPE_SIGNIN,
                                Lang,
                                ulSecureLevel,
                                m_pRegistryConfig,
                                fRedirToSelf,
                                IfCreateTPF()
                                );
            if (NULL == *pVal)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }
Cleanup:
    if (NULL != cnc)
    {
        cnc->Release();
    }

    if (NULL != upd)
        FREE_BSTR(upd);
    if (pszNewURL)
        SysFreeString(pszNewURL);
    if (hasRU == CV_FREE && returnUrl)
        FREE_BSTR(returnUrl);
    if (hasCB == CV_FREE && CBT)
        FREE_BSTR(CBT);
    if (hasNameSpace == CV_FREE && NameSpace)
        FREE_BSTR(NameSpace);

    PassportLog("CManager::CommonLogoTag Exit: %X\r\n", hr);

    return hr;
}

//===========================================================================
//
// HasProfile -- if valid profile is present
//
STDMETHODIMP CManager::HasProfile(VARIANT var, VARIANT_BOOL *pVal)
{
    LPWSTR profileName;

    PassportLog("CManager::HasProfile Enter:\r\n");

    if (var.vt == (VT_BSTR | VT_BYREF))
        profileName = *var.pbstrVal;
    else if (var.vt == VT_BSTR)
        profileName = var.bstrVal;
    else if (var.vt == (VT_VARIANT | VT_BYREF))
    {
        return HasProfile(*(var.pvarVal), pVal);
    }
    else
        profileName = NULL;

    if ((!profileName) || (!_wcsicmp(profileName, L"core")))
    {
        HRESULT ok = m_piProfile->get_IsValid(pVal);
        if (ok != S_OK)
            *pVal = VARIANT_FALSE;
    }
    else
    {
        VARIANT vAtt;
        VariantInit(&vAtt);

        PassportLog("    %ws\r\n", profileName);

        HRESULT ok = m_piProfile->get_Attribute(profileName, &vAtt);
        if (ok != S_OK)
        {
            if (g_pAlert)
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_PROFILETYPE);
            *pVal = VARIANT_FALSE;
        }
        else
        {
            if (vAtt.vt == VT_I4)
                *pVal = vAtt.lVal > 0 ? VARIANT_TRUE : VARIANT_FALSE;
            else if (vAtt.vt == VT_I2)
                *pVal = vAtt.iVal > 0 ? VARIANT_TRUE : VARIANT_FALSE;
            else
            {
                if (g_pAlert)
                    g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_PROFILETYPE);
            }
            VariantClear(&vAtt);
        }
    }

    PassportLog("CManager::HasProfile Exit:  %X\r\n", *pVal);

    return(S_OK);
}

//===========================================================================
//
// get_HasTicket
//
STDMETHODIMP CManager::get_HasTicket(VARIANT_BOOL *pVal)
{
    PassportLog("CManager::get_HasTicket:\r\n");

    if(!pVal) return E_POINTER;

    *pVal = m_ticketValid ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

//===========================================================================
//
// get_FromNetworkServer -- if it's authenticated by QueryString
//
STDMETHODIMP CManager::get_FromNetworkServer(VARIANT_BOOL *pVal)
{
   PassportLog("CManager::get_FromNetworkServer:\r\n");

   *pVal = (m_fromQueryString &&
             m_ticketValid) ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

//===========================================================================
//
// HasFlag -- obsolete function
//
STDMETHODIMP CManager::HasFlag(VARIANT var, VARIANT_BOOL *pVal)
{
    PassportLog("CManager::HasFlag:\r\n");

    AtlReportError(CLSID_Manager, PP_E_GETFLAGS_OBSOLETESTR,
               IID_IPassportManager, E_NOTIMPL);
    return E_NOTIMPL;
}

//===========================================================================
//
// get_TicketAge -- get how long has passed since ticket was created
//
STDMETHODIMP CManager::get_TicketAge(int *pVal)
{
    PassportLog("CManager::get_TicketAge:\r\n");

    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }

    return m_piTicket->get_TicketAge(pVal);
}

//===========================================================================
//
// get_TicketTime -- get when the ticket was created
//

STDMETHODIMP CManager::get_TicketTime(long *pVal)
{
    PassportLog("CManager::get_TicketTime:\r\n");

    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }

    return m_piTicket->get_TicketTime(pVal);
}

//===========================================================================
//
// get_SignInTime -- get last signin time
//
STDMETHODIMP CManager::get_SignInTime(long *pVal)
{
    PassportLog("CManager::get_SignInTime:\r\n");

    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }

    return m_piTicket->get_SignInTime(pVal);
}

//===========================================================================
//
// get_TimeSinceSignIn -- time passed since last signin
//
STDMETHODIMP CManager::get_TimeSinceSignIn(int *pVal)
{
    PassportLog("CManager::get_TimeSinceSignIn:\r\n");

    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }

    return m_piTicket->get_TimeSinceSignIn(pVal);
}

//===========================================================================
//
// GetDomainAttribute -- return information defined in partner.xml file
//
STDMETHODIMP CManager::GetDomainAttribute(BSTR attributeName, VARIANT lcid, VARIANT domain, BSTR *pAttrVal)
{
    HRESULT   hr = S_OK;

    PassportLog("CManager::GetDomainAttribute Enter:\r\n");

    if(attributeName == NULL || *attributeName == 0)
        return E_INVALIDARG;

    PassportLog("    %ws\r\n", attributeName);

    if (!g_config || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    LPWSTR d;
    BSTR dn = NULL;
    if (domain.vt == (VT_BSTR | VT_BYREF))
        d = *domain.pbstrVal;
    else if (domain.vt == VT_BSTR)
        d = domain.bstrVal;
    else if (domain.vt == (VT_VARIANT | VT_BYREF))
    {
        return GetDomainAttribute(attributeName, lcid, *(domain.pvarVal), pAttrVal);
    }
    else
    {
        // domain best be not filled in this case, that's why we reuse it here
        // if not, let dfmn generate the error
        HRESULT hr = DomainFromMemberName(domain, &dn);
        if (hr != S_OK)
            return hr;
        TAKEOVER_BSTR(dn);
        d = dn;
    }

    if (NULL != d)
    {
        PassportLog("    %ws\r\n", d);
    }

    CNexusConfig* cnc = g_config->checkoutNexusConfig();
    USHORT sLcid = 0;
    VARIANT innerLC;
    VariantInit(&innerLC);

    if (lcid.vt != VT_ERROR && VariantChangeType(&innerLC, &lcid, 0, VT_UI2) == S_OK)
        sLcid = innerLC.iVal;
    else
    {
        sLcid = m_pRegistryConfig->getDefaultLCID();

        // Check user profile
        if (!sLcid && m_profileValid)
        {
            m_piProfile->get_ByIndex(LANGPREF_INDEX, &innerLC);
            if (innerLC.vt == VT_I2 || innerLC.vt == VT_UI2)
                sLcid = innerLC.iVal;
            VariantClear(&innerLC);
        }
    }

    WCHAR data[PP_MAX_ATTRIBUTE_LENGTH] = L"";
    cnc->getDomainAttribute(d,
                            attributeName,
                            sizeof(data)/sizeof(WCHAR),
                            data,
                            sLcid);

    // try default domain
    if (!(*data) && (!d || !(*d) || lstrcmpiW(d, L"Default")))
    {
        cnc->getDomainAttribute(L"Default",
                            attributeName,
                            sizeof(data)/sizeof(WCHAR),
                            data,
                            sLcid);

    }
    
    if (*data)
    {
        *pAttrVal = ALLOC_AND_GIVEAWAY_BSTR(data);
    }
    else
    {
        /* fix bug: 12102 -- for backward compitible, not to return error
           hr = E_INVALIDARG;
        */
        *pAttrVal = NULL;
    }
    cnc->Release();
    if (dn) FREE_BSTR(dn);

    PassportLog("CManager::GetDomainAttribute Exit: %X,   %ws\r\n", hr, pAttrVal);

    return hr;
}


//===========================================================================
//
// DomainFromMemberName -- returns domain name with given user id
//
STDMETHODIMP CManager::DomainFromMemberName(VARIANT var, BSTR *pDomainName)
{
    HRESULT hr;
    LPWSTR  psz, memberName;
    VARIANT intoVar;

    PassportLog("CManager::DomainFromMemberName Enter:\r\n");

    VariantInit(&intoVar);

    if (var.vt == (VT_BSTR | VT_BYREF))
        memberName = *var.pbstrVal;
    else if (var.vt == VT_BSTR)
        memberName = var.bstrVal;
    else if (var.vt == (VT_VARIANT | VT_BYREF))
    {
        return DomainFromMemberName(*(var.pvarVal), pDomainName);
    }
    else
    {
        // Try to get it from the profile
        if (!m_profileValid)
        {
            *pDomainName = ALLOC_AND_GIVEAWAY_BSTR(L"Default");
            return S_OK;
        }
        HRESULT hr = m_piProfile->get_Attribute(L"internalmembername", &intoVar);
        if (hr != S_OK)
        {
            *pDomainName = NULL;
            return hr;
        }
        if (VariantChangeType(&intoVar,&intoVar, 0, VT_BSTR) != S_OK)
        {
            AtlReportError(CLSID_Manager, L"PassportManager: Couldn't convert memberName to string.  Call partner support.",
                            IID_IPassportManager, E_FAIL);
            return E_FAIL;
        }
        memberName = intoVar.bstrVal;
    }


    if(memberName == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    PassportLog("    %ws\r\n", memberName);

    psz = wcsrchr(memberName, L'@');
    if(psz == NULL)
    {
        // fix bug: 13380
        // hr = E_INVALIDARG;
        // goto Cleanup;
        psz = L"@Default";
    }

    psz++;

    *pDomainName = ALLOC_AND_GIVEAWAY_BSTR(psz);
    hr = S_OK;

    Cleanup:
    VariantClear(&intoVar);

    PassportLog("CManager::DomainFromMemberName Exit: %X\r\n", hr);
    if (S_OK == hr)
    {
        PassportLog("    %ws\r\n", *pDomainName);
    }

    return hr;
}

//===========================================================================
//
// get_Profile -- get property from profile property bag
//
STDMETHODIMP CManager::get_Profile(BSTR attributeName, VARIANT *pVal)
{
    HRESULT hr = m_piProfile->get_Attribute(attributeName,pVal);

    PassportLog("CManager::get_Profile: %ws\r\n", attributeName);

    if(hr == S_OK && pVal->vt != VT_EMPTY)
    {
        if(g_pPerf)
        {
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_SEC);
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_TOTAL);
        }
        else
        {
            _ASSERT(g_pPerf);
        }
    }

    return hr;
}

//===========================================================================
//
// put_Profile -- put property in profile property bag -- obselete
//
STDMETHODIMP CManager::put_Profile(BSTR attributeName, VARIANT newVal)
{
    if (!m_piProfile)
    {
        return E_OUTOFMEMORY;
    }

    PassportLog("CManager::put_Profile: %ws\r\n", attributeName);

    return m_piProfile->put_Attribute(attributeName,newVal);
}


//===========================================================================
//
// get_HexPUID
//
STDMETHODIMP CManager::get_HexPUID(BSTR *pVal)
{
    PassportLog("CManager::get_HexPUID:\r\n");

    if(!pVal) return E_INVALIDARG;

    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }


    if(m_piTicket)
        return m_piTicket->get_MemberId(pVal);
    else
    {
        AtlReportError(CLSID_Manager, PP_E_INVALID_TICKETSTR,
                       IID_IPassportManager, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }
}

//===========================================================================
//
// get_PUID
//
STDMETHODIMP CManager::get_PUID(BSTR *pVal)
{
    PassportLog("CManager::get_HexPUID:\r\n");

    if(!pVal) return E_INVALIDARG;

   if(m_piTicket)
   {
      HRESULT  hr = S_OK;
      WCHAR    id[64] = L"0";
      int      l = 0;
      int      h = 0;
      LARGE_INTEGER ui64;


      hr = m_piTicket->get_MemberIdLow(&l);
      if (S_OK != hr) return hr;
      hr = m_piTicket->get_MemberIdHigh(&h);
      if (S_OK != hr) return hr;

      ui64.HighPart = h;
      ui64.LowPart = l;

      _ui64tow(ui64.QuadPart, id, 10);

     *pVal = SysAllocString(id);

     if(*pVal == NULL)
     {
        hr = E_OUTOFMEMORY;
     }

     return hr;
   }
   else
   {
      AtlReportError(CLSID_Manager, PP_E_INVALID_TICKETSTR,
                       IID_IPassportManager, PP_E_INVALID_TICKET);
      return PP_E_INVALID_TICKET;
   }
}

STDMETHODIMP CManager::get_Option( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal)
{
   if (!name || _wcsicmp(name, L"iMode") != 0 || !pVal)   
      return E_INVALIDARG;
   VariantCopy(pVal, (VARIANT*)&m_iModeOption);
   return S_OK;
}
        
STDMETHODIMP CManager::put_Option( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal)

{
   // support only this option for now.
   if (!name || _wcsicmp(name, L"iMode") != 0)   
      return E_INVALIDARG;
   m_iModeOption = newVal;

   return S_OK;
}


//===========================================================================
//
// get_Ticket -- get new introduced ticket property from the bag.
//
STDMETHODIMP CManager::get_Ticket(BSTR attributeName, VARIANT *pVal)
{
    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }

    return m_piTicket->GetProperty(attributeName,pVal);
}

//===========================================================================
//
// LogoutURL -- returns LogoutURL with given parameters
//
STDMETHODIMP CManager::LogoutURL(
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT Namespace,
    /* [optional][in] */ VARIANT bSecure,
    /* [retval][out] */ BSTR __RPC_FAR *pVal)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bUseSecure = VARIANT_FALSE;
    BSTR            CBT = NULL, returnUrl = NULL, bstrNameSpace = NULL;
    int             hasCB, hasRU, hasLCID, hasNameSpace, hasUseSec;
    USHORT          Lang;
    WCHAR           nameSpace[MAX_PATH] = L"";
    bool            bUrlFromSecureKey = false;
    WCHAR           UrlBuf[MAX_URL_LENGTH] = L"";
    WCHAR           retUrlBuf[MAX_URL_LENGTH] = L"";
    DWORD           bufLen = MAX_URL_LENGTH;
    WCHAR           qsLeadCh = L'?';
    CNexusConfig*   cnc = NULL;
    int             iRet = 0;

    if (!pVal)  return E_INVALIDARG;

    if (!g_config)
    {
        return PP_E_NOT_CONFIGURED;
    }

    cnc = g_config->checkoutNexusConfig();

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();


    if ((hasUseSec = GetBoolArg(bSecure, &bUseSecure)) == CV_BAD)
    {
         hr = E_INVALIDARG;
         goto Cleanup;
    }

    if ((hasLCID = GetShortArg(lang_id,&Lang)) == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (hasLCID == CV_DEFAULT)
        Lang = m_pRegistryConfig->getDefaultLCID();

    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hasNameSpace = GetBstrArg(Namespace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    // get the right URL -- namespace, secure

    // namespace
    if (!IsEmptyString(bstrNameSpace))
    {
        if(0 == _snwprintf(nameSpace, sizeof(nameSpace) / sizeof(WCHAR), L"%s", bstrNameSpace))
        {
             hr = HRESULT_FROM_WIN32(GetLastError());
             if FAILED(hr)
                 goto Cleanup;
        }
    }

    if (hasCB == CV_DEFAULT)
        CBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        returnUrl = m_pRegistryConfig->getDefaultRU();
    if (returnUrl == NULL)
        returnUrl = L"";



    if (*nameSpace == 0) // 0 length string
      wcscpy(nameSpace, L"Default");

    if(hasUseSec == CV_DEFAULT)
    {
        ULONG ulSecureLevel = m_pRegistryConfig->getSecureLevel();
        bUseSecure = (SECURELEVEL_USE_HTTPS(ulSecureLevel)) ? VARIANT_TRUE : VARIANT_FALSE;
    }


    // secure
    if(bUseSecure == VARIANT_TRUE)
    {
       cnc->getDomainAttribute(nameSpace,
                            L"LogoutSecure",
                            sizeof(UrlBuf)/sizeof(WCHAR),
                            UrlBuf,
                            Lang);
       if (*UrlBuf != 0)
       {
           bUrlFromSecureKey = true;
       }
    }

    // insecure
    if (*UrlBuf == 0)
    {
       cnc->getDomainAttribute(nameSpace,
                            L"Logout",
                            sizeof(UrlBuf)/sizeof(WCHAR),
                            UrlBuf,
                            Lang);
    }
    // error case
    if(*UrlBuf == 0)
    {
        AtlReportError(CLSID_Profile, PP_E_LOGOUTURL_NOTDEFINEDSTR,
           IID_IPassportProfile, PP_E_LOGOUTURL_NOTDEFINED);
        hr = PP_E_LOGOUTURL_NOTDEFINED;
         goto Cleanup;
    }

    if(bUseSecure == VARIANT_TRUE && !bUrlFromSecureKey) // translate from http to https
    {
       if (_wcsnicmp(UrlBuf, L"http:", 5) == 0)  // replace with HTTPS
       {
          memmove(UrlBuf + 5, UrlBuf + 4, sizeof(UrlBuf) - 5 * sizeof(WCHAR));
          memcpy(UrlBuf, L"https", 5 * sizeof(WCHAR));
       }
    }

    // us common function to append the thing one by one ...
    if (wcsstr(UrlBuf, L"?"))  // ? already exists in the URL, use & to start
       qsLeadCh = L'&';
    if (CBT)
       _snwprintf(retUrlBuf, sizeof(retUrlBuf) / sizeof(WCHAR), L"%s%cid=%-d&ru=%s&lcid=%-d&cb=%s",
            UrlBuf, qsLeadCh, m_pRegistryConfig->getSiteId(), returnUrl, Lang, CBT);
    else
       _snwprintf(retUrlBuf, sizeof(retUrlBuf) / sizeof(WCHAR), L"%s%cid=%-d&ru=%s&lcid=%-d",
            UrlBuf, qsLeadCh, m_pRegistryConfig->getSiteId(), returnUrl, Lang);


   *pVal = ALLOC_AND_GIVEAWAY_BSTR(retUrlBuf);
Cleanup:
    if (NULL != cnc)
    {
        cnc->Release();
    }

    return hr;
}

//===========================================================================
//
// get_ProfileByIndex -- get property value by index of the property
//
STDMETHODIMP CManager::get_ProfileByIndex(int index, VARIANT *pVal)
{
    HRESULT hr = m_piProfile->get_ByIndex(index,pVal);

    if(hr == S_OK && pVal->vt != VT_EMPTY)
    {
        if(g_pPerf)
        {
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_SEC);
            g_pPerf->incrementCounter(PM_VALIDPROFILEREQ_TOTAL);
        }
        else
        {
            _ASSERT(g_pPerf);
        }
    }

    return hr;
}

//===========================================================================
//
// put_ProfileByIndex -- put property value by index
//
STDMETHODIMP CManager::put_ProfileByIndex(int index, VARIANT newVal)
{
    return m_piProfile->put_ByIndex(index,newVal);
}

//===========================================================================
//
// handleQueryStringData -- authenticate with T & P from Query String
//
BOOL CManager::handleQueryStringData(BSTR a, BSTR p)
{
    BOOL                retVal; //whither to set cookies
    HRESULT             hr;
    VARIANT             vFalse;
    _variant_t          vFlags;

    //
    //  check for empty ticket
    //
    if (!a || !*a)
        return  FALSE;

    if (!m_piTicket || !m_piProfile)
    {
        return FALSE;
    }

    hr = DecryptTicketAndProfile(a, p, FALSE, NULL, m_pRegistryConfig, m_piTicket, m_piProfile);

    if(hr != S_OK)
    {
        m_ticketValid = VARIANT_FALSE;
        m_profileValid = VARIANT_FALSE;
        retVal = FALSE;
        goto Cleanup;
    }

    VariantInit(&vFalse);
    vFalse.vt = VT_BOOL;
    vFalse.boolVal = VARIANT_FALSE;

    m_piTicket->get_IsAuthenticated(0,
                                    VARIANT_FALSE,
                                    vFalse,
                                    &m_ticketValid);

    if(!m_bSecureTransported)  // secure bit should NOI set
    {
       if (S_OK == m_piTicket->GetProperty(ATTR_PASSPORTFLAGS, &vFlags))
       { // the bit should NOT set
          if ( vFlags.vt == VT_I4 && (vFlags.lVal & k_ulFlagsSecuredTransportedTicket) != 0)
             m_ticketValid = VARIANT_FALSE;
       }

    }

    // let the ticket to valid if secure signin
    if(m_ticketValid)
         m_piTicket->DoSecureCheckInTicket(m_bSecureTransported);

    // profile stuff
    m_piProfile->get_IsValid(&m_profileValid);

    if (m_ticketValid)
    {
        m_fromQueryString = true;

        // Set the cookies
        if (!m_pRegistryConfig->setCookiesP())
        {
            retVal = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        retVal = FALSE;
        goto Cleanup;
    }

    retVal = TRUE;

Cleanup:

    return retVal;
}

//===========================================================================
//
// handleCookieData -- authenticate with cookies
//
BOOL CManager::handleCookieData(
    BSTR auth,
    BSTR prof,
    BSTR consent,
    BSTR secAuth
    )
{
    BOOL                retVal;
    HRESULT             hr;
    VARIANT             vDoSecureCheck;
    VARIANT_BOOL        bValid;
    _variant_t          vFlags;

    //  bail out on empty cookie
    if (!auth || !*auth)
        return  FALSE;

    if (!m_piTicket || !m_piProfile)
    {
        return FALSE;
    }

    //  the consent cookie
    if(consent != NULL && SysStringLen(consent) != 0)
    {
        hr = DecryptTicketAndProfile(  auth,
                                       prof,
                                       !(m_pRegistryConfig->bInDA()),
                                       consent,
                                       m_pRegistryConfig,
                                       m_piTicket,
                                       m_piProfile);
    }
    else
    {
        //
        //  If regular cookie domain/path is identical to consent cookie domain/path, then
        //  MSPProf cookie is equivalent to consent cookie, and we should set m_bUsingConsentCookie
        //  to true
        //

        BOOL bCheckConsentCookie = (
               lstrcmpA(m_pRegistryConfig->getTicketDomain(), m_pRegistryConfig->getProfileDomain())
               || lstrcmpA(m_pRegistryConfig->getTicketPath(), m_pRegistryConfig->getProfilePath())
                                 );

        hr = DecryptTicketAndProfile(  auth,
                                       prof,
                                       !(m_pRegistryConfig->bInDA()) && bCheckConsentCookie,
                                       NULL,
                                       m_pRegistryConfig,
                                       m_piTicket,
                                       m_piProfile);
    }

    if(hr != S_OK)
    {
        m_ticketValid = VARIANT_FALSE;
        m_profileValid = VARIANT_FALSE;
        retVal = FALSE;
        goto Cleanup;
    }

    VariantInit(&vDoSecureCheck);
    vDoSecureCheck.vt = VT_BOOL;

    if(secAuth && secAuth[0] && m_bSecureTransported)
    {
        if(DoSecureCheck(secAuth, m_pRegistryConfig, m_piTicket) == S_OK)
            vDoSecureCheck.boolVal = VARIANT_TRUE;
        else
            vDoSecureCheck.boolVal = VARIANT_FALSE;
    }
    else
        vDoSecureCheck.boolVal = VARIANT_FALSE;

    m_piTicket->get_IsAuthenticated(0,
                                    VARIANT_FALSE,
                                    vDoSecureCheck,
                                    &m_ticketValid);

    // a partner cookie should not include the secure bit
    if (!m_pRegistryConfig->bInDA() && S_OK == m_piTicket->GetProperty(ATTR_PASSPORTFLAGS, &vFlags))
    { // the bit should NOT set
       if ( vFlags.vt == VT_I4 && (vFlags.lVal & k_ulFlagsSecuredTransportedTicket) != 0)
          m_ticketValid = VARIANT_FALSE;
    }

    // for insecure case, the secure cookie should not come
    if(!m_bSecureTransported && (secAuth && secAuth[0]))  // this should not come
    {
       m_ticketValid = VARIANT_FALSE;
    }

    // profile stuff
    m_piProfile->get_IsValid(&m_profileValid);

    if(!m_ticketValid)
    {
        retVal = FALSE;
        goto Cleanup;
    }

    retVal = TRUE;

Cleanup:

    return retVal;
}

//===========================================================================
//
// get_HasSavedPassword -- if users chooses to persiste cookies
//
STDMETHODIMP CManager::get_HasSavedPassword(VARIANT_BOOL *pVal)
{
    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }

    PassportLog("CManager::get_HasSavedPassword:\r\n");

    // TODO: using flags for this
    return m_piTicket->get_HasSavedPassword(pVal);
}

//===========================================================================
//
// Commit -- post changes of profile back to the cookie
//
STDMETHODIMP CManager::Commit(BSTR *pNewProfileCookie)
{
    PassportLog("CManager::Commit:\r\n");

    if (!g_config) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_piTicket || !m_piProfile)
    {
        return E_OUTOFMEMORY;
    }

    if (!m_ticketValid || !m_profileValid)
    {
        AtlReportError(CLSID_Manager, PP_E_IT_FOR_COMMITSTR,
                        IID_IPassportManager, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    // Write new passport profile cookie...
    // return a safearray if we aren't used from ASP
    BSTR newP = NULL;
    HRESULT hr = m_piProfile->incrementVersion();
    hr = m_piProfile->get_unencryptedProfile(&newP);
    TAKEOVER_BSTR(newP);

    if (hr != S_OK || newP == NULL)
    {
        AtlReportError(CLSID_Manager,
                        L"PassportManager.Commit: unknown failure.",
                        IID_IPassportManager, E_FAIL);
        return E_FAIL;
    }

    CCoCrypt* crypt = NULL;
    BSTR newCH = NULL;
    crypt = m_pRegistryConfig->getCurrentCrypt(); // IsValid ensures this is non-null
    if ((!crypt->Encrypt(m_pRegistryConfig->getCurrentCryptVersion(),
                        (LPSTR)newP,
                        SysStringByteLen(newP),
                        &newCH)) ||
        !newCH)
    {
        AtlReportError(CLSID_Manager,
                        L"PassportManager.Commit: encryption failure.",
                        IID_IPassportManager, E_FAIL);
        FREE_BSTR(newP);
        return E_FAIL;
    }
    FREE_BSTR(newP);
    TAKEOVER_BSTR(newCH);

    if (m_bOnStartPageCalled)
    {
        if (m_pRegistryConfig->setCookiesP())
        {
            try
            {
                VARIANT_BOOL persist;
                _bstr_t domain;
                _bstr_t path;

                if (m_pRegistryConfig->getTicketPath())
                    path = m_pRegistryConfig->getTicketPath();
                else
                    path = L"/";

                m_piTicket->get_HasSavedPassword(&persist);
                IRequestDictionaryPtr piCookies = m_piResponse->Cookies;

                VARIANT vtNoParam;
                VariantInit(&vtNoParam);
                vtNoParam.vt = VT_ERROR;
                vtNoParam.scode = DISP_E_PARAMNOTFOUND;

                IWriteCookiePtr piCookie = piCookies->Item[L"MSPProf"];
                piCookie->Item[vtNoParam] = newCH;
                domain = m_pRegistryConfig->getTicketDomain();
                if (domain.length())
                    piCookie->put_Domain(domain);
                if (persist)
                    piCookie->put_Expires(g_dtExpire);
                piCookie->put_Path(path);

            }
            catch (...)
            {
                FREE_BSTR(newCH);
                return E_FAIL;
            }
        }
    }
    GIVEAWAY_BSTR(newCH);
    *pNewProfileCookie = newCH;

    if(g_pPerf)
    {
        g_pPerf->incrementCounter(PM_PROFILECOMMITS_SEC);
        g_pPerf->incrementCounter(PM_PROFILECOMMITS_TOTAL);
    }
    else
    {
        _ASSERT(g_pPerf);
    }

    return S_OK;
}

//===========================================================================
//
// _Ticket -- ticket object property
//
STDMETHODIMP CManager::_Ticket(IPassportTicket** piTicket)
{
    if (!m_piTicket)
    {
        return E_OUTOFMEMORY;
    }

    return m_piTicket->QueryInterface(IID_IPassportTicket,(void**)piTicket);
}

//===========================================================================
//
// _Profile
//
STDMETHODIMP CManager::_Profile(IPassportProfile** piProfile)
{
    return m_piProfile->QueryInterface(IID_IPassportProfile,(void**)piProfile);
}

//===========================================================================
//
// DomainExists -- if a domain exists
//
STDMETHODIMP CManager::DomainExists(
    BSTR bstrDomainName,
    VARIANT_BOOL* pbExists
    )
{
    PassportLog("CManager::DomainExists Enter:\r\n");

    if(!pbExists)
        return E_INVALIDARG;

    if(!bstrDomainName || (bstrDomainName[0] == L'\0'))
        return E_INVALIDARG;

    if(!g_config || !g_config->isValid())
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    CNexusConfig* cnc = g_config->checkoutNexusConfig();

    *pbExists = cnc->DomainExists(bstrDomainName) ? VARIANT_TRUE : VARIANT_FALSE;

    cnc->Release();

    PassportLog("CManager::DomainExists Exit:\r\n");

    return S_OK;
}

//===========================================================================
//
// get_Domains -- get a list of domains
//
STDMETHODIMP CManager::get_Domains(VARIANT *pArrayVal)
{
    CNexusConfig*   cnc = NULL;
    LPCWSTR*        arr = NULL;
    int             iArr = 0;
    HRESULT         hr;

    PassportLog("CManager::get_Domains Enter:\r\n");

    if (!pArrayVal)
        return E_INVALIDARG;

    if (!g_config || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    cnc = g_config->checkoutNexusConfig();

    arr = cnc->getDomains(&iArr);

    if (!arr || iArr == 0)
    {
        VariantClear(pArrayVal);
        hr = S_OK;
        goto Cleanup;
    }

    // Make a safearray with all the goods
    SAFEARRAYBOUND rgsabound;
    rgsabound.lLbound = 0;
    rgsabound.cElements = iArr;
    SAFEARRAY *sa = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);

    if (!sa)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    VariantInit(pArrayVal);
    pArrayVal->vt = VT_ARRAY | VT_VARIANT;
    pArrayVal->parray = sa;

    VARIANT *vArray;
    SafeArrayAccessData(sa, (void**)&vArray);

    for (long i = 0; i < iArr; i++)
    {
        vArray[i].vt = VT_BSTR;
        vArray[i].bstrVal = ALLOC_AND_GIVEAWAY_BSTR(arr[i]);
    }
    SafeArrayUnaccessData(sa);

    hr = S_OK;
Cleanup:
    if (arr)
    {
        delete[] arr;
    }
    if (NULL != cnc)
    {
        cnc->Release();
    }

    PassportLog("CManager::DomainExists Exit:\r\n");

    return hr;
}

//===========================================================================
//
// get_Error -- get the error returned with &f query parameter
//
STDMETHODIMP CManager::get_Error(long* plError)
{
    if(plError == NULL)
        return E_INVALIDARG;

    if(m_ticketValid)
    {
        if (!m_piTicket)
        {
            return E_OUTOFMEMORY;
        }

        m_piTicket->get_Error(plError);
        if(*plError == 0)
            *plError = m_lNetworkError;
    }
    else
    {
        *plError = m_lNetworkError;
    }

    PassportLog("CManager::get_Error: %X\r\n", *plError);

    return S_OK;
}

//===========================================================================
//
// GetServerInfo
//
STDMETHODIMP CManager::GetServerInfo(BSTR *pbstrOut)
{
    if (!g_config || !g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                   IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if(!m_pRegistryConfig)
        //  This only happens when OnStartPage was not called first.
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!m_pRegistryConfig)
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                   IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    CNexusConfig* cnc = g_config->checkoutNexusConfig();
    BSTR bstrVersion = cnc->GetXMLInfo();
    cnc->Release();

    WCHAR wszName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName(wszName, &dwSize);

    *pbstrOut = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL,
                                            wcslen(wszName) + ::SysStringLen(bstrVersion) + 2);

    if (NULL == *pbstrOut)
    {
        return E_OUTOFMEMORY;
    }

    wcscpy(*pbstrOut, wszName);
    BSTR p = *pbstrOut + wcslen(wszName);
    *p = L' ';
    wcsncpy(p+1, bstrVersion, ::SysStringLen(bstrVersion) + 1);

    return S_OK;
}

//===========================================================================
//
// HaveConsent -- if the user has the specified consent
//
STDMETHODIMP
CManager::HaveConsent(
    VARIANT_BOOL    bNeedFullConsent,
    VARIANT_BOOL    bNeedBirthdate,
    VARIANT_BOOL*   pbHaveConsent)
{
    HRESULT hr;
    ULONG   flags = 0;
    VARIANT vBdayPrecision;
    BOOL    bKid;
    BOOL    bConsentSatisfied;
    ConsentStatusEnum   ConsentCode = ConsentStatus_Unknown;
    VARIANT_BOOL bRequireConsentCookie;

    if(pbHaveConsent == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pbHaveConsent = VARIANT_FALSE;

    VariantInit(&vBdayPrecision);

    if (!m_piTicket || !m_piProfile || !m_pRegistryConfig)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // If the cookies came in on the query string then there is no consent cookie yet so don't
    // require one.  Otherwise check to see if the consent cookie domain or path is set
    // differently than the cookie domain or path.  If so (and we aren't in the DA domain) then
    // the consent cookie is required.
    bRequireConsentCookie = !m_fromQueryString &&
          ((lstrcmpA(m_pRegistryConfig->getTicketDomain(), m_pRegistryConfig->getProfileDomain())
            || lstrcmpA(m_pRegistryConfig->getTicketPath(), m_pRegistryConfig->getProfilePath()))
            && !(m_pRegistryConfig->bInDA())) ? VARIANT_TRUE : VARIANT_FALSE;

    //
    //  Get flags.
    //

    hr = m_piTicket->ConsentStatus(bRequireConsentCookie, &flags, &ConsentCode); // ignore return value

    if (hr != S_OK)
    {
         hr = S_OK;
         goto Cleanup;
    }

    // if old ticket, we get the consent info from the profile
    if(ConsentCode == ConsentStatus_NotDefinedInTicket)
    {
      // then we get from profile
      VARIANT_BOOL bValid;
      CComVariant  vFlags;
      m_piProfile->get_IsValid(&bValid);

      if(bValid == VARIANT_FALSE)
      {
         hr = S_OK;
         goto Cleanup;
      }

      hr = m_piProfile->get_Attribute(L"flags", &vFlags);

      if(hr != S_OK)
         goto Cleanup;

      bKid = ((V_I4(&vFlags) & k_ulFlagsAccountType) == k_ulFlagsAccountTypeKid);
    }
    else
       bKid = ((flags & k_ulFlagsAccountType) == k_ulFlagsAccountTypeKid);

    // we should have the flags by now
    //
    //  Do we have the requested level of consent?
    //

    bConsentSatisfied = bNeedFullConsent ? (flags & 0x60) == 0x40 :
                                           (flags & 0x60) != 0;

    if(bKid)
    {
        *pbHaveConsent = (bConsentSatisfied) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        //
        //  Make sure we have birthday if it was requested.
        //
        //  no return value check need here, always returns S_OK.
        VARIANT_BOOL bValid;
        m_piProfile->get_IsValid(&bValid);

        //  if profile is not valid, then we don't have consent.
        //  return.
        if(bValid == VARIANT_FALSE)
        {
            hr = S_OK;
            goto Cleanup;
        }

        if(bNeedBirthdate)
        {
            hr = m_piProfile->get_Attribute(L"bday_precision", &vBdayPrecision);
            if(hr != S_OK)
                goto Cleanup;

            *pbHaveConsent = (vBdayPrecision.iVal != 0 && vBdayPrecision.iVal != 3) ?
                             VARIANT_TRUE : VARIANT_FALSE;
        }
        else
            *pbHaveConsent = VARIANT_TRUE;
    }

    hr = S_OK;

Cleanup:

    VariantClear(&vBdayPrecision);

        return hr;
}


//===========================================================================
//
// checkForPassportChallenge
//
//
//  check the qs parameter. if challenge is requested,
//  build the auth header and redirect with a modified qs
//
BOOL CManager::checkForPassportChallenge(IRequestDictionaryPtr piServerVariables)
{
    BOOL fReturn = FALSE;
    BSTR bstrBuf = NULL;

    //  just need the request string
    _variant_t  vtItemName, vtQueryString;
    vtItemName = L"QUERY_STRING";

    piServerVariables->get_Item(vtItemName, &vtQueryString);
    if(vtQueryString.vt != VT_BSTR)
        vtQueryString.ChangeType(VT_BSTR);

    if (vtQueryString.bstrVal && *vtQueryString.bstrVal)
    {
        // check if pchg=1 is there. It is the first parameter ....
        PWSTR   psz = wcsstr(vtQueryString.bstrVal, L"pchg=1");
        if (psz)
        {

            //  we are in business. reformat the URL, insert the headers and
            //  redirect
            psz = wcsstr(psz, PPLOGIN_PARAM);
            _ASSERT(psz);
            if (psz)
            {
                psz += wcslen(PPLOGIN_PARAM);
                PWSTR   pszEndLoginUrl = wcsstr(psz, L"&");
                _ASSERT(pszEndLoginUrl);
                if (pszEndLoginUrl)
                {
                    *pszEndLoginUrl = L'\0';
                    //  unescape the URL
                    //  use temp buffer ...
                    DWORD       cch = wcslen(psz) + 1;
                    bstrBuf = SysAllocStringLen(NULL, cch);
                    if (NULL == bstrBuf)
                    {
                        goto Cleanup;
                    }

                    if(!InternetCanonicalizeUrl(psz,
                                                bstrBuf,
                                                &cch,
                                                ICU_DECODE | ICU_NO_ENCODE))
                    {
                        //  what else can be done ???
                        _ASSERT(FALSE);
                    }
                    else
                    {
                        //  copy the unescaped URL to the orig buffer
                        wcscpy(psz, (BSTR)bstrBuf);
                        //  set headers first ...
                        //  just use the qs param with some reformatting
                        _bstr_t bstrHeader;

                        if (HeaderFromQS(wcsstr(psz, L"?"), bstrHeader))
                        {
                            m_piResponse->AddHeader(L"WWW-Authenticate", bstrHeader);
                            //  Url is ready, redirect ...
                            m_piResponse->Redirect(psz);
                            fReturn = TRUE;
                        }
                    }
                }
            }
        }
    }
Cleanup:
    if (bstrBuf)
    {
        SysFreeString(bstrBuf);
    }

    return fReturn;
}


//===========================================================================
//
// HeaderFromQS
//
//
//  given a queryString, format the www-authenticate header
//
BOOL
CManager::HeaderFromQS(PWSTR    pszQS, _bstr_t& bstrHeader)
{
    //  common header start ...
    bstrHeader = PASSPORT_PROT14;
    BOOL    fSuccess = TRUE;
    BSTR    signature = NULL;

    //  advance thru any leading junk ...
    while(!iswalnum(*pszQS) && *pszQS) pszQS++;
    if (!*pszQS)
    {
        fSuccess = FALSE;
        goto Cleanup;
    }

    WCHAR   rgszValue[1000];    // buffer large enough for most values ...
    PCWSTR psz = pszQS, pszNext = pszQS;

    while(TRUE)
    {
        //  no param name is more than 10 ....
        WCHAR   rgszName[10];
        LONG    cch = sizeof(rgszName)/sizeof(WCHAR);
        PCWSTR  pszName = psz;
 
        while(*pszNext && *pszNext != L'&') pszNext++;

        //  grab the next qsparam
        // name first
        while(*pszName != L'=' && pszName < pszNext) pszName++;

        _ASSERT(pszName != pszNext); // this should never happen
        if (pszName == pszNext)
        {
            //  and if it does, skip this parameter and return FALSE ...
            fSuccess = FALSE;
            goto Cleanup;
        }
        else
        {
            PWSTR   pszVal = rgszValue;
            ULONG   cchVal;    

            _ASSERT((pszName - psz) <= cch);
            wcsncpy(rgszName, psz, cch - 1);
            rgszName[cch - 1] = L'\0';

            //  next comes the value
            pszName++;
            cchVal = (pszNext - pszName);  // note these are PWSTR pointers so the result is length in characters
            if (cchVal >= (sizeof(rgszValue) / sizeof(rgszValue[0])) )
            {
                //  have to allocate ...
                pszVal = new WCHAR[cchVal + 1];
                if (!pszVal)
                {
                    fSuccess = FALSE;
                    goto Cleanup;
                }
            }

            //  copy the value ...
            wcsncpy(pszVal, pszName, cchVal );
            pszVal[cchVal] = L'\0';
            //  and insert in the header ...
            if (psz != pszQS)
                //  this is not the first param
                bstrHeader += L",";
            else
                //  first separator is a space ...
                bstrHeader += L" ";

            bstrHeader += _bstr_t(rgszName) + L"=" + pszVal;

            if (pszVal != rgszValue)
                //  it was alloc'd
                delete[]  pszVal;
        } // else '=' found

        //  leave loop
        if (!*pszNext)
            break;
        psz = ++pszNext;
    } // while

    //  sign the header
    //  actually the signature is on the qs
    HRESULT hr = PartnerHash(m_pRegistryConfig,
                             m_pRegistryConfig->getCurrentCryptVersion(),
                             pszQS,
                             wcslen(pszQS),
                             &signature);
    if (S_OK == hr)
    {
        bstrHeader += _bstr_t(L",tpf=") + (BSTR)signature;
    }
    else
    {
        fSuccess = FALSE;
    }

Cleanup:
    if (signature)
    {
        SysFreeString(signature);
    }
    return  fSuccess;
}


//===========================================================================
//
// FormatAuthHeaderFromParams
//
//
//  format WWW-Auth from parameters
//
STDMETHODIMP CManager::FormatAuthHeaderFromParams(PCWSTR    pszLoginUrl,    // unused for now
                                                  PCWSTR    pszRetUrl,
                                                  ULONG     ulTimeWindow,
                                                  BOOL      fForceLogin,
                                                  time_t    ct,
                                                  PCWSTR    pszCBT,         // unused for now
                                                  PCWSTR    pszNamespace,
                                                  int       nKpp,
                                                  PWSTR     pszLCID,    // tweener needs the LCID
                                                  ULONG     ulSecureLevel,
                                                  _bstr_t&  strHeader   //  return result
                                                  )
{
    WCHAR   temp[40];

    //  based on the spec ...
    //  lcid is not really needed, however it is present when
    //  header is created from qs and it's used
    strHeader = _bstr_t(PASSPORT_PROT14) + L" lc=" + pszLCID;

    //  site=
    strHeader += "&id=";
    _ultow(m_pRegistryConfig->getSiteId(), temp, 10);
    strHeader += temp;

    //  rtw=
    strHeader += "&tw=";
    _ultow(ulTimeWindow, temp, 10);
    strHeader += temp;

    if (fForceLogin)
    {
        strHeader += _bstr_t("&fs=1");
    }
    if (pszNamespace && *pszNamespace)
    {
        strHeader += _bstr_t("&ns=") + pszNamespace;
    }
    //  ru=
    strHeader += _bstr_t("&ru=") + pszRetUrl;

    //  ct=
    _ultow(ct, temp, 10);
    strHeader += _bstr_t(L"&ct=") + temp;

    //  kpp
    if (nKpp != -1)
    {
        _ultow(nKpp, temp, 10);
        strHeader += _bstr_t(L"&kpp=") + temp;
    }

    //  key version and version
    _ultow(m_pRegistryConfig->getCurrentCryptVersion(), temp, 10);
    strHeader += _bstr_t(L"&kv=") + temp;
    strHeader += _bstr_t(L"&ver=") + GetVersionString();

    //  secure level
    if (ulSecureLevel)
    {
        strHeader += _bstr_t(L"&seclog=") + _ultow(ulSecureLevel, temp, 10);
    }

    //  sign the header
    BSTR signature = NULL;
    PWSTR   szStart = wcsstr(strHeader, L"lc=");
    HRESULT hr = PartnerHash(m_pRegistryConfig,
                             m_pRegistryConfig->getCurrentCryptVersion(),
                             szStart,
                             strHeader.length() - (szStart - strHeader),
                             &signature);
    //  replace '&' with ','
    BSTR psz = (BSTR)strHeader;
    while (*psz)
    {
        if (*psz == L'&') *psz = L',';
        psz++;
    }

    if (S_OK == hr)
    {
        strHeader += _bstr_t(L",tpf=") + (BSTR)signature;
    }

    if (signature)
    {
        SysFreeString(signature);
    }
    return hr;
}



//===========================================================================
//
// GetLoginParams
//
//
//  common code to parse user's parameters
//  and get defaults from registry config
//
STDMETHODIMP CManager::GetLoginParams(VARIANT vRU,
                              VARIANT vTimeWindow,
                              VARIANT vForceLogin,
                              VARIANT vCoBrand,
                              VARIANT vLCID,
                              VARIANT vNameSpace,
                              VARIANT vKPP,
                              VARIANT vSecureLevel,
                              //    these are the processed values
                              _bstr_t&  strUrl,
                              _bstr_t&  strReturnUrl,
                              UINT&     TimeWindow,
                              VARIANT_BOOL& ForceLogin,
                              time_t&   ct,
                              _bstr_t&  strCBT,
                              _bstr_t&  strNameSpace,
                              int&      nKpp,
                              ULONG&    ulSecureLevel,
                              PWSTR     pszLCID)
{
    USES_CONVERSION;
    LPCWSTR url;
    VARIANT freeMe;
    BSTR         CBT = NULL, returnUrl = NULL, bstrNameSpace = NULL;
    int          hasCB, hasRU, hasLCID, hasTW, hasFL, hasNameSpace, hasKPP, hasUseSec;
    USHORT       Lang;
    CNexusConfig* cnc = NULL;
    HRESULT      hr = S_OK;

    PassportLog("CManager::GetLoginParams Enter:\r\n");

    if (!g_config) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                    IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!m_pRegistryConfig)
        m_pRegistryConfig = g_config->checkoutRegistryConfig();

    if (!g_config->isValid() || !m_pRegistryConfig) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                    IID_IPassportManager, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    // Make sure args are of the right type
    if ((hasTW = GetIntArg(vTimeWindow, (int*) &TimeWindow)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasFL = GetBoolArg(vForceLogin, &ForceLogin)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasUseSec = GetIntArg(vSecureLevel, (int*)&ulSecureLevel)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasLCID = GetShortArg(vLCID, &Lang)) == CV_BAD)
        return E_INVALIDARG;
    if ((hasKPP = GetIntArg(vKPP, &nKpp)) == CV_BAD)
        return E_INVALIDARG;
    hasCB = GetBstrArg(vCoBrand, &CBT);
    if (hasCB == CV_BAD)
        return E_INVALIDARG;
    strCBT = CBT;
    if (hasCB == CV_FREE)
    {
        TAKEOVER_BSTR(CBT);
    }

    hasRU = GetBstrArg(vRU, &returnUrl);
    if (hasRU == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            FREE_BSTR(CBT);
        return E_INVALIDARG;
    }
    strReturnUrl = returnUrl;
    if (hasRU == CV_FREE)
    {
        FREE_BSTR(returnUrl);
    }

    hasNameSpace = GetBstrArg(vNameSpace, &bstrNameSpace);
    if (hasNameSpace == CV_BAD)
    {
        if (hasCB == CV_FREE && CBT)
            FREE_BSTR(CBT);
        return E_INVALIDARG;
    }
    if (hasNameSpace == CV_OK)
        strNameSpace = bstrNameSpace;
    if (hasNameSpace == CV_FREE)
    {
        FREE_BSTR(bstrNameSpace);
    }
    if (hasNameSpace == CV_DEFAULT)
    {
        if (NULL == m_pRegistryConfig->getNameSpace())
        {
            strNameSpace = L"";
        }
        else
        {
            strNameSpace = m_pRegistryConfig->getNameSpace();
        }
    }

    if(hasUseSec == CV_DEFAULT)
        ulSecureLevel = m_pRegistryConfig->getSecureLevel();

    if(ulSecureLevel == VARIANT_TRUE)  // special case for backward compatible
        ulSecureLevel = k_iSeclevelSecureChannel;

    WCHAR *szAUAttrName;
    if (SECURELEVEL_USE_HTTPS(ulSecureLevel))
        szAUAttrName = L"AuthSecure";
    else
        szAUAttrName = L"Auth";

    cnc = g_config->checkoutNexusConfig();

    if (hasLCID == CV_DEFAULT)
        Lang = m_pRegistryConfig->getDefaultLCID();
    if (hasKPP == CV_DEFAULT)
        nKpp = m_pRegistryConfig->getKPP();

    //  convert the LCID to str for tweener ...
    _itow((int)Lang, pszLCID, 10);
    VariantInit(&freeMe);

    // **************************************************
    // Logging
    if (NULL != returnUrl)
    {
        PassportLog("    RU = %ws\r\n", returnUrl);
    }
    PassportLog("    TW = %X,   SL = %X,   L = %d,   KPP = %X\r\n", TimeWindow, ulSecureLevel, Lang, nKpp);
    if (NULL != CBT)
    {
        PassportLog("    CBT = %ws\r\n", CBT);
    }
    // **************************************************

    if (!m_pRegistryConfig->DisasterModeP())
    {
        // If I'm authenticated, get my domain specific url
        WCHAR   UrlBuf[MAX_URL_LENGTH];
        if (m_ticketValid && m_profileValid)
        {
            HRESULT hr = m_piProfile->get_ByIndex(MEMBERNAME_INDEX, &freeMe);
            if (hr != S_OK || freeMe.vt != VT_BSTR)
            {
                cnc->getDomainAttribute(L"Default",
                                        szAUAttrName,
                                        sizeof(UrlBuf)/sizeof(WCHAR),
                                        UrlBuf,
                                        Lang);
                strUrl = UrlBuf;
            }
            else
            {
                LPCWSTR psz = wcsrchr(freeMe.bstrVal, L'@');
                cnc->getDomainAttribute(psz ? psz+1 : L"Default",
                                        szAUAttrName,
                                        sizeof(UrlBuf)/sizeof(WCHAR),
                                        UrlBuf,
                                        Lang);
                strUrl = UrlBuf;
            }
        }
        if (strUrl.length() == 0)
        {
            cnc->getDomainAttribute(L"Default",
                                    szAUAttrName,
                                    sizeof(UrlBuf)/sizeof(WCHAR),
                                    UrlBuf,
                                    Lang);
            strUrl = UrlBuf;
        }
    }
    else
        strUrl = m_pRegistryConfig->getDisasterUrl();

    _ASSERT(strUrl.length() != 0);

    time(&ct);

    if (hasTW == CV_DEFAULT)
        TimeWindow = m_pRegistryConfig->getDefaultTicketAge();
    if (hasFL == CV_DEFAULT)
        ForceLogin = m_pRegistryConfig->forceLoginP() ? VARIANT_TRUE : VARIANT_FALSE;
    if (hasCB == CV_DEFAULT)
        strCBT = m_pRegistryConfig->getDefaultCoBrand();
    if (hasRU == CV_DEFAULT)
        strReturnUrl = m_pRegistryConfig->getDefaultRU() ?
            m_pRegistryConfig->getDefaultRU() : L"";

    if ((TimeWindow != 0 && TimeWindow < PPM_TIMEWINDOW_MIN) || TimeWindow > PPM_TIMEWINDOW_MAX)
    {
        AtlReportError(CLSID_Manager, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                        IID_IPassportManager, PP_E_INVALID_TIMEWINDOW);
        hr = PP_E_INVALID_TIMEWINDOW;
        goto Cleanup;
    }

Cleanup:
    if (NULL != cnc)
    {
        cnc->Release();
    }
        
    VariantClear(&freeMe);

    PassportLog("CManager::GetLoginParams Exit:  %X\r\n", hr);

    return  hr;
}

//===========================================================================
//
// GetTicketAndProfileFromHeader
//
//
//  get ticket & profile from auth header
//  params:
//  AuthHeader - [in/out] contents of HTTP_Authorization header
//  pszTicket - [out]   ptr to the ticket part in the header
//  pszProfile -[out]   ptr to the profile
//  pwszF   -   [out]   ptr to error coming in the header
//  Auth header contents is changed as a side effect of the function
//
static VOID GetTicketAndProfileFromHeader(PWSTR     pszAuthHeader,
                                          PWSTR&    pszTicket,
                                          PWSTR&    pszProfile,
                                          PWSTR&    pszF)
{
   // check for t=, p=, and f=
    if (pszAuthHeader && *pszAuthHeader)
    {
        // format is 'Authorization: from-PP='t=xxx&p=xxx'
        PWSTR pwsz = wcsstr(pszAuthHeader, L"from-PP");
        if (pwsz)
        {
            //  ticket and profile are enclosed in ''. Not very strict parsing indeed ....
            while(*pwsz != L'\'' && *pwsz)
                pwsz++;
            if (*pwsz++)
            {
                if (*pwsz == L'f')
                {
                    pwsz++;
                    if (*pwsz == L'=')
                    {
                        pwsz++;
                        // error case
                        pszF = pwsz;
                    }
                }
                else
                {
                    //  ticket and profile ...
                    _ASSERT(*pwsz == L't');
                    if (*pwsz == L't')
                    {
                        pwsz++;
                        if (*pwsz == L'=')
                        {
                            pwsz++;
                            pszTicket = pwsz;
                        }
                    }

                    while(*pwsz != L'&' && *pwsz)
                        pwsz++;

                    if (*pwsz)
                        *pwsz++ = L'\0';

                    if (*pwsz == L'p')
                    {
                        pwsz++;
                        if (*pwsz == L'=')
                        {
                            pwsz++;
                            pszProfile = pwsz;
                        }
                    }
                    //  finally remove the last '
                }
                //  set \0 terminator
                while(*pwsz != L'\'' && *pwsz)
                    pwsz++;
                if (*pwsz)
                    *pwsz = L'\0';
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// IPassportService implementation

//===========================================================================
//
// Initialize
//
STDMETHODIMP CManager::Initialize(BSTR configfile, IServiceProvider* p)
{
    HRESULT hr;

    // Initialized?
    if (!g_config || !g_config->isValid()) // This calls UpdateNow if not yet initialized.
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


//===========================================================================
//
// Shutdown
//
STDMETHODIMP CManager::Shutdown()
{
    return S_OK;
}


//===========================================================================
//
// ReloadState
//
STDMETHODIMP CManager::ReloadState(IServiceProvider*)
{
    HRESULT hr;

    // Initialize.

    if(!g_config || !g_config->PrepareUpdate(TRUE))
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


//===========================================================================
//
// CommitState
//
STDMETHODIMP CManager::CommitState(IServiceProvider*)
{
    HRESULT hr;

    // Finish the two phase update.
    if(!g_config || !g_config->CommitUpdate())
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                        IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


//===========================================================================
//
// DumpState
//
STDMETHODIMP CManager::DumpState(BSTR* pbstrState)
{
    ATLASSERT( *pbstrState != NULL &&
               "CManager:DumpState - "
               "Are you sure you want to hand me a non-null BSTR?" );

    if(!g_config)
    {
        return PP_E_NOT_CONFIGURED;
    }

    g_config->Dump(pbstrState);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\nexusconfig.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    NexusConfig.h
        Define class for fetching nexus files -- e.g. partner.xml


    FILE HISTORY:

*/
// NexusConfig.h: interface for the CNexusConfig class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NEXUSCONFIG_H__74EB2516_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
#define AFX_NEXUSCONFIG_H__74EB2516_E239_11D2_95E9_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "BstrHash.h"
#include "CoCrypt.h"
#include "ProfileSchema.h"  // also imports msxml
#include "TicketSchema.h"  // also imports msxml
#include "PassportLock.hpp"
#include "ptstl.h"

//
// TOP FOLDER NAMES in PARTNER.XML
//
// folder for profile schemata
#define	FOLDER_PROFILE_SCHEMATA		L"SCHEMATA"
// folder for ticket schemas
#define	FOLDER_TICKET_SCHEMATA		L"TICKETSCHEMATA"
// folder for passport network
#define	FOLDER_PASSPORT_NETWORK		L"PASSPORTNETWORK"
//

// 

typedef PtStlMap<USHORT,BSTR > LCID2ATTR;

// if bDoLCIDReplace is true, bstrAttrVal will have the attribute value
// with replacement parameters.
// if bDoLCIDReplace is false, pLCIDAttrMap will point to a map of values
// indexed by lcid.
typedef struct
{
    bool        bDoLCIDReplace;
    
    union
    {
        LCID2ATTR*  pLCIDAttrMap;
        BSTR        bstrAttrVal;
    };
}
ATTRVAL;

typedef PtStlMap<BSTR,CProfileSchema*,RawBstrLT> BSTR2PS;
typedef PtStlMap<BSTR,CTicketSchema*,RawBstrLT> BSTR2TS;
typedef PtStlMap<BSTR,ATTRVAL*,RawBstrLT> ATTRMAP;
typedef PtStlMap<BSTR,ATTRMAP*,RawBstrLT> BSTR2DA;

class CNexusConfig
{
public:
    CNexusConfig();
    virtual ~CNexusConfig();

    BSTR                GetXMLInfo();

    // Get a profile schema by name, or the default if null is passed
    CProfileSchema*     getProfileSchema(BSTR schemaName = NULL);
    // Get a ticket schema by name, or the default if null is passed
    CTicketSchema*      getTicketSchema(BSTR schemaName = NULL);

    // Return a description of the failure
    BSTR                getFailureString();
    BOOL                isValid() { return m_valid; }

    // 0 is "default language", ie the entry w/o an LCID.  This does NOT do
    // the registry fallback, etc.
    void                getDomainAttribute(LPCWSTR  domain, 
                                           LPCWSTR  attr, 
                                           DWORD    valuebuflen, 
                                           LPWSTR   valuebuf, 
                                           USHORT   lcid = 0,
                                           BOOL     bNoAlt = FALSE,
                                           BOOL     bExactLcid = FALSE);

    // Get the domain list.  You should delete[] the pointer you receive
    LPCWSTR*            getDomains(int *numDomains);

    // Is the domain name passed in a valid domain authority?
    bool                DomainExists(LPCWSTR domain);

    CNexusConfig*       AddRef();
    void                Release();

    BOOL                Read(IXMLDocument* is);

    void                Dump(BSTR* pbstrDump);

protected:
    void                setReason(LPWSTR reason);

    // profile schemata 
    BSTR2PS             m_profileSchemata;
    CProfileSchema*     m_defaultProfileSchema;

    // ticket schemata
    BSTR2TS             m_ticketSchemata;
    CTicketSchema*      m_defaultTicketSchema;

    // 
    BSTR2DA             m_domainAttributes;

    BOOL                m_valid;

    BSTR                m_szReason;

    long                m_refs;

    static PassportLock m_ReadLock;

private:
    _bstr_t m_bstrVersion;
};

#endif // !defined(AFX_NEXUSCONFIG_H__74EB2516_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\nexusconfig.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    nexusconfig.cpp


    FILE HISTORY:

*/

// NexusConfig.cpp: implementation of the CNexusConfig class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NexusConfig.h"
#include "PassportGuard.hpp"
#include "helperfuncs.h"

PassportLock    CNexusConfig::m_ReadLock;

#define  ALT_ATTRIBUTE_SUFFIX L"Default"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// turn a char into it's hex value
#define XTOI(x) (isalpha(x) ? (toupper(x)-'A'+10) : (x - '0'))

//===========================================================================
//
// CNexusConfig 
//
CNexusConfig::CNexusConfig() :
  m_defaultProfileSchema(NULL), m_defaultTicketSchema(NULL), 
  m_valid(FALSE), m_szReason(NULL), m_refs(0)
{
}

//===========================================================================
//
// ~CNexusConfig 
//
CNexusConfig::~CNexusConfig()
{
   // profile schemata
    if (!m_profileSchemata.empty())
    {
        BSTR2PS::iterator ita = m_profileSchemata.begin();
        for (; ita != m_profileSchemata.end(); ita++)
        {
            FREE_BSTR(ita->first);
            ita->second->Release();
        }
        m_profileSchemata.clear();
    }

    // ticket schemata
    if (!m_ticketSchemata.empty())
    {
        BSTR2TS::iterator ita = m_ticketSchemata.begin();
        for (; ita != m_ticketSchemata.end(); ita++)
        {
            FREE_BSTR(ita->first);
            ita->second->Release();
        }
        m_ticketSchemata.clear();
    }

    // 
    if (!m_domainAttributes.empty())
    {
        BSTR2DA::iterator itc = m_domainAttributes.begin();
        for (; itc != m_domainAttributes.end(); itc++)
        {
            FREE_BSTR(itc->first);
            if (!itc->second->empty())
            {
                // Now we're deleting ATTRVALs
                ATTRMAP::iterator itd = itc->second->begin();
                for (; itd != itc->second->end(); itd++)
                {
                    ATTRVAL* pAttrVal = itd->second;

                    if(pAttrVal->bDoLCIDReplace)
                    {
                        FREE_BSTR(pAttrVal->bstrAttrVal);
                    }
                    else
                    {
                        LCID2ATTR::iterator ite = pAttrVal->pLCIDAttrMap->begin();
                        for (;ite != pAttrVal->pLCIDAttrMap->end(); ite++)
                        {
                            FREE_BSTR(ite->second);
                        }

                        delete pAttrVal->pLCIDAttrMap;
                    }
                    FREE_BSTR(itd->first);
                    delete itd->second;
                }
            }
            delete itc->second;
        }
        m_domainAttributes.clear();
    }
    if (m_szReason)
        FREE_BSTR(m_szReason);
}

//===========================================================================
//
// getFailureString 
//
BSTR CNexusConfig::getFailureString()
{
  if (m_valid)
    return NULL;
  return m_szReason;
}

//===========================================================================
//
// setReason 
//
void CNexusConfig::setReason(LPTSTR reason)
{
  if (m_szReason)
    FREE_BSTR(m_szReason);
  m_szReason = ALLOC_BSTR(reason);
}

//===========================================================================
//
// AddRef 
//
CNexusConfig* CNexusConfig::AddRef()
{
  InterlockedIncrement(&m_refs);
  return this;
}

//===========================================================================
//
// Release 
//
void CNexusConfig::Release()
{
  long refs = InterlockedDecrement(&m_refs);
  if (refs == 0)
    delete this;
}

//===========================================================================
//
// Read 
//
BOOL CNexusConfig::Read(IXMLDocument* s)
{
    //BUGBUG  Put this here because having two threads in Read at the same
    //        time is almost guaranteed to cause STL maps to hurl (heap
    //        corruption, pointer nastiness, etc.  Long term solution
    //        is to move these to LKRHash tables as well.

    PassportGuard<PassportLock> readGuard(m_ReadLock);

    MSXML::IXMLDocumentPtr pDoc;
    MSXML::IXMLElementCollectionPtr pElts, pSchemas, pDomains, pAtts;
    MSXML::IXMLElementPtr pElt, pDom, pAtt;
    VARIANT iTopLevel, iSubNodes, iAtts;
    _bstr_t name(L"Name"), suffix(L"DomainSuffix"), lcidatt(L"lcid"), version(L"Version");
    LONG    cTLN, cSN, cAtts;

    BSTR attribute = NULL, value = NULL;
    _bstr_t lcid;

    HRESULT hr = S_OK;

    try
    {
        pDoc = s;

        pElts = pDoc->root->children;
        m_bstrVersion = pDoc->root->getAttribute(version);

        VariantInit(&iTopLevel);
        iTopLevel.vt = VT_I4;
        cTLN = pElts->length;

        for (iTopLevel.lVal=0; iTopLevel.lVal < cTLN; iTopLevel.lVal++)
        {
            pElt = pElts->item(&iTopLevel);
            CComBSTR tagName; 
            hr = pElt->get_tagName(&tagName);

            if(hr != S_OK)
                continue;
            if (!_wcsicmp(tagName,FOLDER_TICKET_SCHEMATA))
            {
                VariantInit(&iSubNodes);
                iSubNodes.vt = VT_I4;
                pSchemas = pElt->children;
                cSN = pSchemas->length;
                for (iSubNodes.lVal=0;iSubNodes.lVal < cSN;iSubNodes.lVal++)
                {
                    pElt = pSchemas->item(&iSubNodes);
                    // Read a schema

                    // BUGBUG probably more efficient ways to handle this variant->BSTR issue
                    BSTR schemaName = NULL;
                    _bstr_t tmp = pElt->getAttribute(name);
                    if (tmp.length() > 0)
                        schemaName = ALLOC_BSTR(tmp);

                    CTicketSchema *pSchema = new CTicketSchema();
                    pSchema->AddRef();
                    if (schemaName && pSchema)
                    {
                        BSTR2TS::value_type pMapVal(schemaName,pSchema);
                        pSchema->ReadSchema(pElt);
                        if (!_wcsicmp(schemaName,L"CORE"))
                            m_defaultTicketSchema = pSchema;
                        m_ticketSchemata.insert(pMapVal);
                    }
                    else
                    {
                        if (schemaName)
                            FREE_BSTR(schemaName);
                        if (pSchema)
                            pSchema->Release();
                    }
                }

            }
            else if (!_wcsicmp(tagName,FOLDER_PROFILE_SCHEMATA))
            {
                VariantInit(&iSubNodes);
                iSubNodes.vt = VT_I4;
                pSchemas = pElt->children;
                cSN = pSchemas->length;
                for (iSubNodes.lVal=0;iSubNodes.lVal < cSN;iSubNodes.lVal++)
                {
                    pElt = pSchemas->item(&iSubNodes);
                    // Read a schema

                    // BUGBUG probably more efficient ways to handle this variant->BSTR issue
                    BSTR schemaName = NULL;
                    _bstr_t tmp = pElt->getAttribute(name);
                    if (tmp.length() > 0)
                        schemaName = ALLOC_BSTR(tmp);

                    CProfileSchema *pSchema = new CProfileSchema();
                    pSchema->AddRef();
                    if (schemaName && pSchema)
                    {
                        BSTR2PS::value_type pMapVal(schemaName,pSchema);
                        pSchema->Read(pElt);
                        if (!_wcsicmp(schemaName,L"CORE"))
                            m_defaultProfileSchema = pSchema;
                        m_profileSchemata.insert(pMapVal);
                    }
                    else
                    {
                        if (schemaName)
                            FREE_BSTR(schemaName);
                        if (pSchema)
                            pSchema->Release();
                    }
                }
            }
            else if (!_wcsicmp(tagName,FOLDER_PASSPORT_NETWORK))
            {
                // individual domain attributes
                pElt = pElts->item(&iTopLevel);
                VariantInit(&iSubNodes);
                iSubNodes.vt = VT_I4;
                pDomains = pElt->children;
                cSN = pDomains->length;
                VariantInit(&iAtts);
                iAtts.vt = VT_I4;

                for (iSubNodes.lVal=0;iSubNodes.lVal < cSN;iSubNodes.lVal++)
                {
                    pDom = pDomains->item(&iSubNodes);
                    BSTR dname = NULL;
                    _bstr_t rawdn = pDom->getAttribute(suffix);

                    dname = ALLOC_BSTR(rawdn);

                    if (!dname)
                        continue;

                    pAtts = pDom->children;
                    cAtts = pAtts->length;

                    // Add new hash table for this domain
                    ATTRMAP *newsite = new ATTRMAP;
                    if (!newsite)
                        continue;

                    BSTR2DA::value_type pNewSite(dname, newsite);
                    m_domainAttributes.insert(pNewSite);

                    for (iAtts.lVal = 0; iAtts.lVal < cAtts; iAtts.lVal++)
                    {
                        pAtt = pAtts->item(&iAtts);
                        lcid = pAtt->getAttribute(lcidatt);
                        bool bIsReplaceLcid = (_wcsicmp(lcid, L"lang_replace") == 0);
                        pAtt->get_tagName(&attribute);
                        pAtt->get_text(&value);

                        TAKEOVER_BSTR(attribute);
                        TAKEOVER_BSTR(value);
                        if (attribute && value)
                        {
                            // Find or add the lcid->value map for this attr
                            ATTRMAP::const_iterator lcit = newsite->find(attribute);
                            ATTRVAL* attrval;
                            if (lcit == newsite->end())
                            {
                                attrval = new ATTRVAL;
                                if(attrval != NULL)
                                {
                                    attrval->bDoLCIDReplace = bIsReplaceLcid;
                                    if(!bIsReplaceLcid)
                                    {
                                        attrval->pLCIDAttrMap = new LCID2ATTR;
                                    }
                                    else
                                    {
                                        attrval->bstrAttrVal = value;
                                        value = NULL;
                                    }

                                    ATTRMAP::value_type pAtt(attribute,attrval);
                                    newsite->insert(pAtt);
                                    attribute = NULL;
                                }
                                else
                                {
                                    FREE_BSTR(attribute);
                                    attribute = NULL;
                                    FREE_BSTR(value);
                                    value = NULL;
                                }
                            }
                            else
                            {
                                FREE_BSTR(attribute);
                                attribute = NULL;
                                attrval = lcit->second;
                            }

                            short iLcid = 0;
                            if(!bIsReplaceLcid)
                            {
                                if (lcid.length() == 4)
                                {
                                    LPWSTR szlcid = lcid;
                                    if (iswxdigit(szlcid[0]) && iswxdigit(szlcid[1]) &&
                                        iswxdigit(szlcid[2]) && iswxdigit(szlcid[3]))
                                    {
                                        iLcid = 
                                            (XTOI(szlcid[0]) << 12) +
                                            (XTOI(szlcid[1]) << 8) +
                                            (XTOI(szlcid[2]) << 4) +
                                            (XTOI(szlcid[3]) << 0);
                                    }
                                    else
                                    {
                                        if (g_pAlert)
                                            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                                             PM_LCID_ERROR, lcid);
                                    }
                                }
                                else if (lcid.length() == 2)
                                {
                                    LPWSTR szlcid = lcid;
                                    if (iswxdigit(szlcid[0]) && iswxdigit(szlcid[1]))
                                    {
                                        iLcid = 
                                            (XTOI(szlcid[0]) << 12) +
                                            (XTOI(szlcid[1]) << 8);
                                    }
                                    else
                                    {
                                        if (g_pAlert)
                                            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                                             PM_LCID_ERROR, lcid);
                                    }
                                }
                                else if (lcid.length() > 0)
                                {
                                    if (g_pAlert)
                                        g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                                         PM_LCID_ERROR, lcid);
                                }

                                LCID2ATTR::value_type lcAtt(iLcid,value);
                                if (attrval && attrval->pLCIDAttrMap)
                                {
                                    attrval->pLCIDAttrMap->insert(lcAtt);
                                }
                                else
                                {
                                    FREE_BSTR(value);
                                    value = NULL;
                                }
                            }
                            else
                            {
                                if (value)
                                {
                                    FREE_BSTR(value);
                                    value = NULL;
                                }
                            }
                        }
                        else
                        {
                            if (attribute)
                            {
                                FREE_BSTR(attribute);
                                attribute = NULL;
                            }
                            if (value)
                            {
                                FREE_BSTR(value);
                                value = NULL;
                            }
                        }
                    }
                }
            }
        }
    }
    catch (...)
    {
//        _bstr_t r = e.Description();
        if (attribute)
        {
            FREE_BSTR(attribute);
            attribute = NULL;
        }
        if (value)
        {
            FREE_BSTR(value);
            value = NULL;
        }
        return FALSE;
    }
    m_valid = TRUE;
    return TRUE;

}

//===========================================================================
//
// DomainExists 
//
bool CNexusConfig::DomainExists(LPCWSTR domain)
{
    BSTR2DA::const_iterator it = m_domainAttributes.find(_bstr_t(domain));
    return (it == m_domainAttributes.end() ? false : true);
}


//===========================================================================
//
// getDomainAttribute 
//
void CNexusConfig::getDomainAttribute(
    LPCWSTR domain,    // in
    LPCWSTR attr,      // in
    DWORD valuebuflen, // in (chars, not bytes!)
    LPWSTR valuebuf,   // out
    USHORT lcid,        // in
    BOOL     bNoAlt,    // in if to try alternate attribute
    BOOL     bExactLcid // if do exact lcid match
    )
{
    BSTR2DA::const_iterator it;
    ATTRMAP::const_iterator daiter;
    ATTRVAL* pAttrVal;

    if(valuebuf == NULL)
        goto Cleanup;

    *valuebuf = L'\0';

    it = m_domainAttributes.find(_bstr_t(domain));
    if (it == m_domainAttributes.end())
    {
        // Not found
        goto Cleanup;
    }

    daiter = (*it).second->find(_bstr_t(attr));
    if (daiter == it->second->end())
    {
        // Not found
        goto Cleanup;
    }

    pAttrVal = daiter->second;
    if(pAttrVal->bDoLCIDReplace)
    {
        LPWSTR szSrc = pAttrVal->bstrAttrVal;
        LPWSTR szDst = valuebuf;
        DWORD  dwLenRemaining = valuebuflen;

        while(*szSrc != L'\0' && dwLenRemaining != 0)
        {
            if(*szSrc == L'%')
            {
                szSrc++;

                switch((WCHAR)CharUpperW((LPWSTR)(*szSrc)))
                {
                case L'L':
                    {
                        WCHAR szLCID[32];

                        _ultow(lcid, szLCID, 10);

                        int nLength = lstrlenW(szLCID);

                        for(int nIndex = 0; 
                            nIndex < nLength && dwLenRemaining != 0; 
                            nIndex++)
                        {
                            *(szDst++) = szLCID[nIndex];
                            --dwLenRemaining;
                        }

                        szSrc++;
                    }
                    break;

                case L'C':
                    {
                        WCHAR szCharCode[3];

                        //
                        //  TODO Insert code here to lookup char code
                        //  based on lcid.
                        //

                        lstrcpyW(szCharCode, L"EN");

                        *(szDst++) = szCharCode[0];
                        --dwLenRemaining;

                        if(dwLenRemaining != 0)
                        {
                            *(szDst++) = szCharCode[1];
                            --dwLenRemaining;
                        }

                        szSrc++;
                    }
                    break;

                default:

                    *(szDst++) = L'%';
                    --dwLenRemaining;

                    if(dwLenRemaining != 0)
                    {
                        *(szDst++) = *(szSrc++);
                        --dwLenRemaining;
                    }

                    break;
                }
            }
            else
            {
                *(szDst++) = *(szSrc++);
                dwLenRemaining--;
            }
        }

        if(dwLenRemaining != 0)
            *szDst = L'\0';
        else
            valuebuf[valuebuflen - 1] = L'\0';
    }
    else
    {
        LCID2ATTR* pLcidMap = pAttrVal->pLCIDAttrMap;
        LCID2ATTR::const_iterator lciter = pLcidMap->find(lcid);
        if (lciter == pLcidMap->end())
        {
            // try default lcid
            ATTRMAP::const_iterator defaultLcidIt;
            defaultLcidIt = (*it).second->find(_bstr_t(L"DEFAULTLCID"));
            if (defaultLcidIt != it->second->end())
            {
               ATTRVAL* pDefaultAttrVal;
               pDefaultAttrVal =  (*defaultLcidIt).second;
               LCID2ATTR::const_iterator pDefaultLcidMapIt = pDefaultAttrVal->pLCIDAttrMap->find(0);

               if ((*pDefaultLcidMapIt).second && *((*pDefaultLcidMapIt).second))
               {
                  LONG   defaultLcid = 0;
                  defaultLcid = FromHex((*pDefaultLcidMapIt).second);

                  if (lcid == defaultLcid)
                  {
                      lciter = pLcidMap->find(0);
                  }
               }
            }
            
            //    BOOL     bNoAlt,    // in if to try alternate attribute
            //    BOOL     bExactLcid // if do exact lcid match
            if (lciter == pLcidMap->end() && !bNoAlt)
            {
               // try to find the alternative attribute by appending the suffix
               WCHAR    wszAltAttr[MAX_PATH + 1];
               if( wnsprintf(wszAltAttr, MAX_PATH, L"%s%s", attr, ALT_ATTRIBUTE_SUFFIX ) > 0)
               {
                  getDomainAttribute(domain, wszAltAttr, valuebuflen, valuebuf, lcid, TRUE, TRUE);    
                  if ( *valuebuf != 0 )   // found
                     goto Cleanup;
               }
            }
            // Not found
            if (lciter == pLcidMap->end() && lcid != 0 && !bExactLcid)
            {
                lciter = pLcidMap->find(PRIMARYLANGID(lcid));   // primary language
                if (lciter == pLcidMap->end())
                {
                    lciter = pLcidMap->find(0);
                    if (lciter == pLcidMap->end())
                        goto Cleanup;
                }
            }
        }
        if(lciter != pLcidMap->end())
		    lstrcpynW(valuebuf, (*lciter).second, valuebuflen);
    }

Cleanup:

    return;
}

//===========================================================================
//
// getProfileSchema 
//
CProfileSchema* CNexusConfig::getProfileSchema(BSTR schemaName)
{
  if (schemaName == NULL)
    return m_defaultProfileSchema;

  BSTR2PS::const_iterator it = m_profileSchemata.find(schemaName);
  if (it == m_profileSchemata.end())
    return NULL;
  else
    return (*it).second;
}

//===========================================================================
//
// getTicketSchema 
//
CTicketSchema* CNexusConfig::getTicketSchema(BSTR schemaName)
{
  if (schemaName == NULL)
    return m_defaultTicketSchema;

  BSTR2TS::const_iterator it = m_ticketSchemata.find(schemaName);
  if (it == m_ticketSchemata.end())
    return NULL;
  else
    return (*it).second;
}

//===========================================================================
//
// getDomains 
//
LPCWSTR* CNexusConfig::getDomains(int *numDomains)
{
  int i;

  if (!numDomains) return NULL;

  *numDomains = m_domainAttributes.size();

  if (*numDomains == 0)
    return NULL;

  LPCWSTR* retVal = new LPCWSTR[*numDomains];

  if (!retVal) return NULL;

  BSTR2DA::const_iterator itc = m_domainAttributes.begin();
  for (i = 0; itc != m_domainAttributes.end(); itc++, i++)
    {
      retVal[i] = itc->first;
    }
  return retVal;
}

//===========================================================================
//
// GetXMLInfo 
//
BSTR CNexusConfig::GetXMLInfo()
{
    return m_bstrVersion;
}


//===========================================================================
//
// Dump 
//
void CNexusConfig::Dump(BSTR* pbstrDump)
{
    if(pbstrDump == NULL)
        return;

    *pbstrDump = NULL;

    CComBSTR bstrDump;

    // because CComBSTR will throw an exception if a memory allocation fails
    // we need to wrap this code with a try/catch.
    try
    {
        BSTR2DA::const_iterator domainIterator;
        for(domainIterator = m_domainAttributes.begin(); 
            domainIterator != m_domainAttributes.end();
            domainIterator++)
        {
            ATTRMAP* pAttrMap = domainIterator->second;

            bstrDump += L"Domain: ";
            bstrDump += domainIterator->first;
            bstrDump += L"<BR><BR>";

            ATTRMAP::const_iterator attrIterator;

            for(attrIterator = pAttrMap->begin();
                attrIterator != pAttrMap->end();
                attrIterator++)
            {
                bstrDump += L"Attribute: ";
                bstrDump += attrIterator->first;
                bstrDump += L"<BR><BR>";

                ATTRVAL* pAttrVal = attrIterator->second;
                if(pAttrVal->bDoLCIDReplace)
                {
                    bstrDump += L"LCID = lang_replace  Value = ";
                    bstrDump += pAttrVal->bstrAttrVal;
                    bstrDump += L"<BR>";
                }
                else
                {
                    LCID2ATTR* pLCIDMap = pAttrVal->pLCIDAttrMap;

                    LCID2ATTR::const_iterator lcidIterator;

                    for(lcidIterator = pLCIDMap->begin();
                        lcidIterator != pLCIDMap->end();
                        lcidIterator++)
                    {
                        WCHAR szBuf[32];

                        bstrDump += L"LCID = ";
                        bstrDump += _itow(lcidIterator->first, szBuf, 10);
                        bstrDump += L"  Value = ";
                        bstrDump += lcidIterator->second;
                        bstrDump += L"<BR>";
                    }

                    bstrDump += L"<BR>";
                }
            }

            bstrDump += L"<BR>";
        }

        *pbstrDump = bstrDump.Detach();
    }
    catch(...)
    {
        *pbstrDump = NULL;
    }
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\passport.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    Passport.cpp


    FILE HISTORY:

*/


// Passport.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Passportps.mk in the project directory.

#include "stdafx.h"
#include <atlbase.h>
#include "resource.h"
#include <initguid.h>
#include "Passport.h"

#include "Passport_i.c"
#include "Admin.h"
#include "Ticket.h"
#include "Profile.h"
#include "Manager.h"
#include "PassportCrypt.h"
#include "PassportFactory.h"
#include "PassportLock.hpp"
#include "PassportEvent.hpp"
#include "FastAuth.h"
#include "RegistryConfig.h"
#include "commd5.h"
#include <shlguid.h>
#include <shlobj.h>             // IShellLink

#define IS_DOT_NET_SERVER()      (LOWORD(GetVersion()) >= 0x0105)

#define PASSPORT_DIRECTORY       L"MicrosoftPassport"
#define PASSPORT_DIRECTORY_LEN   (sizeof(PASSPORT_DIRECTORY) / sizeof(WCHAR) - 1)
#define NT_PARTNER_FILE          L"msppptnr.xml"
#define NT_PARTNER_FILE_LEN      (sizeof(NT_PARTNER_FILE) / sizeof(WCHAR) - 1)
#define WEB_PARTNER_FILE         L"partner2.xml"
#define WEB_PARTNER_FILE_LEN     (sizeof(WEB_PARTNER_FILE) / sizeof(WCHAR) - 1)
#define CONFIG_UTIL_NAME         L"\\msppcnfg.exe"
#define CONFIG_UTIL_NAME_LEN     (sizeof(CONFIG_UTIL_NAME) / sizeof(WCHAR) - 1)
#define SHORTCUT_SUFFIX_NAME     L"\\Programs\\Microsoft Passport\\Passport Administration Utility.lnk"
#define SHORTCUT_SUFFIX_NAME_LEN (sizeof(SHORTCUT_SUFFIX_NAME) / sizeof(WCHAR) - 1)

HINSTANCE   hInst;
CComModule _Module;
CPassportConfiguration *g_config=NULL;
// CProfileSchema *g_authSchema = NULL;
BOOL g_bStarted = FALSE;
BOOL g_bRegistering = FALSE;

PassportAlertInterface* g_pAlert    = NULL;
PassportPerfInterface* g_pPerf    = NULL;
static CComPtr<IMD5>  g_spCOMmd5;

//===========================================================================
//
// GetGlobalCOMmd5 
//
HRESULT GetGlobalCOMmd5(IMD5 ** ppMD5)
{
    HRESULT  hr = S_OK;

    if (!ppMD5)
    {
        return E_INVALIDARG;
    }
      
    if(!g_spCOMmd5)
    {
        hr = CoCreateInstance(__uuidof(CoMD5),
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              __uuidof(IMD5),
                              (void**)ppMD5);

        *ppMD5 = (IMD5*) ::InterlockedExchangePointer((void**) &g_spCOMmd5, (void*) *ppMD5);
    }

    if (*ppMD5 == NULL && g_spCOMmd5 != NULL)
    {
        *ppMD5 = g_spCOMmd5;
        (*ppMD5)->AddRef();
    }

    return hr;
};


BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Manager, CManager)
OBJECT_ENTRY(CLSID_Ticket, CTicket)
OBJECT_ENTRY(CLSID_Profile, CProfile)
OBJECT_ENTRY(CLSID_Crypt, CCrypt)
OBJECT_ENTRY(CLSID_Admin, CAdmin)
OBJECT_ENTRY(CLSID_FastAuth, CFastAuth)
OBJECT_ENTRY(CLSID_PassportFactory, CPassportFactory)
END_OBJECT_MAP()

// {{2D2B36FC-EB86-4e5c-9A06-20303542CCA3}
static const GUID CLSID_Manager_ALT = 
{ 0x2D2B36FC, 0xEB86, 0x4e5c, { 0x9A, 0x06, 0x20, 0x30, 0x35, 0x42, 0xCC, 0xA3 } };

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        hInst = hInstance;

        // gmarks
        // Initialize the Alert object
        if(!g_pAlert)
        {
            g_pAlert = CreatePassportAlertObject(PassportAlertInterface::EVENT_TYPE);

            if(g_pAlert)
            {
                g_pAlert->initLog(PM_ALERTS_REGISTRY_KEY, EVCAT_PM, NULL, 1);
            }
        }

        if(g_pAlert)
        {
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_STARTED);
        }

        //
        // Initialize the logging stuff
        //
        InitLogging();

        // gmarks
        // Initialize the Perf object
        if(!g_pPerf) 
        {
            g_pPerf = CreatePassportPerformanceObject(PassportPerfInterface::PERFMON_TYPE);

            if(g_pPerf) 
            {
                // Initialize.
                g_pPerf->init(PASSPORT_PERF_BLOCK);
            }
        }

        _Module.Init(ObjectMap, hInstance, &LIBID_PASSPORTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        // gmarks
        if(g_pAlert) 
        {
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_STOPPED);
            g_pAlert->closeLog();
            delete g_pAlert;
        }

        CloseLogging();

        if(g_pPerf)
        {
            delete g_pPerf;
        }

        if (g_config)
        {
            delete g_config;
        }

        g_config = NULL;

        _Module.Term();
    }

    return TRUE;    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    if( hr == S_OK)
    {
        g_spCOMmd5.Release();

        if (g_config)
        {
            delete g_config;
        }

        g_config = NULL;

        g_bStarted = FALSE;
    }
    
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    GUID    guidCLSID;
    static PassportLock startLock;

    if(!g_bStarted)
    {
        PassportGuard<PassportLock> g(startLock);

        if(!g_bStarted)
        {
            g_config = new CPassportConfiguration();

            if (!g_config)
            {
                hr = CLASS_E_CLASSNOTAVAILABLE;
                goto Cleanup;
            }

            g_config->UpdateNow(FALSE);
            
            g_bStarted = TRUE;
        }
    }

    if (InlineIsEqualGUID(rclsid, CLSID_Manager_ALT))
    {
        guidCLSID = CLSID_Manager;
    }
    else
    {
        guidCLSID = rclsid;
    }

    hr = _Module.GetClassObject(guidCLSID, riid, ppv);

Cleanup:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// UpdateConfigShortcut - Checks if a shortcut exists for msppcnfg and if so
//                        updates the shortcut to point to the config utility
//                        is %WINDIR%\system32.

BOOL UpdateConfigShortcut(WCHAR *pszSystemDir)
{
    WCHAR         pszConfigUtilPath[MAX_PATH];
    WCHAR         pszShortcutPath[MAX_PATH];
    IShellLink*   pShellLink = NULL;
    IPersistFile* pPersistFile = NULL;
    HANDLE        hFile = INVALID_HANDLE_VALUE;
    HRESULT       hr;
    BOOL          fResult = FALSE;

    // from the path to the shortcut
    hr = SHGetFolderPath(NULL,
                    ssfCOMMONSTARTMENU,
                    NULL,
                    SHGFP_TYPE_DEFAULT,
                    pszShortcutPath);
    if (S_OK != hr)
    {
        goto Cleanup;
    }
    wcsncat(pszShortcutPath, SHORTCUT_SUFFIX_NAME, MAX_PATH - wcslen(pszShortcutPath));

    // determine if an existing shortcut exists
    hFile = CreateFile(pszShortcutPath,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);

        // form the path for the new config utility in system32
        wcsncpy(pszConfigUtilPath, pszSystemDir, MAX_PATH);
        pszConfigUtilPath[MAX_PATH - 1] = L'\0';
        wcsncat(pszConfigUtilPath, CONFIG_UTIL_NAME, MAX_PATH - wcslen(pszConfigUtilPath));

        // Get a pointer to the IShellLink interface.
        hr = CoCreateInstance(CLSID_ShellLink,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IShellLink,
                        (LPVOID*)&pShellLink);
        if (S_OK == hr)
        {
            // Query IShellLink for the IPersistFile interface for saving the shortcut in persistent storage.
            hr = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
            if (S_OK != hr)
            {
                goto Cleanup;
            }

            // load the shortcut file
            hr = pPersistFile->Load(pszShortcutPath, STGM_READWRITE);
            if (S_OK != hr)
            {
                goto Cleanup;
            }

            // Set the path to the shortcut target, and add the description.
            hr = pShellLink->SetPath(pszConfigUtilPath);
            if (S_OK != hr)
            {
                goto Cleanup;
            }

            hr = pPersistFile->Save(pszShortcutPath, TRUE);
            if (S_OK != hr)
            {
                goto Cleanup;
            }
        }
    }

    fResult = TRUE;
Cleanup:
    if (pPersistFile)
    {
        pPersistFile->Release();
    }

    if (pShellLink)
    {
        pShellLink->Release();
    }

    return fResult;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT         hr;
    IPassportAdmin* pIPassportManager = NULL;
    BSTR            key;
    VARIANT_BOOL    foo = 0;
    WCHAR           wszOldFile[MAX_PATH];
    WCHAR           wszNewFile[MAX_PATH];
    UINT            uRet;
    HKEY            hKey = 0;
    HKEY            hPPKey = 0;
    BOOL            fCoInitialized = FALSE;
    DWORD           dwType;
    DWORD           cbKeyData = 0;
    DWORD           dwSecureLevel;
    LONG            err;

    //
    // Prevent CRegistryConfig class from logging "config's bad" errors
    // until the config should actually be there.
    //

    g_bRegistering = TRUE;

    //
    // registers object, typelib and all interfaces in typelib
    //

    hr = _Module.RegisterServer(TRUE);

    if (FAILED(hr))
    {
        g_bRegistering = FALSE;
        return hr;
    }

    //
    // Stuff below this point is handled by the Passport SDK
    // installation on non-.NET (or beyond) servers.
    //

    if (!IS_DOT_NET_SERVER())
    {
        goto Cleanup;
    }

    //
    // Create the encrypted partner key.
    //

    ::CoInitialize(NULL);

    fCoInitialized = TRUE;

    hr = ::CoCreateInstance(CLSID_Admin,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IPassportAdmin,
                            (void**) &pIPassportManager);

    if (hr != S_OK)
    {
        goto Cleanup;
    }

    //
    // check if there is already key data and if so, leave it alone
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     L"Software\\Microsoft\\Passport\\KeyData",
                     0,
                     KEY_QUERY_VALUE,
                     &hKey)
             != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    err = RegQueryValueEx(hKey,
                     L"1",
                     0,
                     &dwType,
                     NULL,
                     &cbKeyData);

    RegCloseKey(hKey);
    hKey = 0;

    if (ERROR_FILE_NOT_FOUND == err) 
    {
        key = SysAllocString(L"123456781234567812345678");
        hr = (pIPassportManager->addKey(key, 1, 0, &foo));
        SysFreeString(key);

        if (hr != S_OK)
        {
            goto Cleanup;
        }
    }

    hr = (pIPassportManager->put_currentKeyVersion(1));

    if (hr != S_OK)
    {
        goto Cleanup;
    }


    //
    // Create/set the CCDPassword
    //

    hr = SetCCDPassword();


    //
    // First, get the Windows directory
    //

    uRet = GetSystemDirectory(wszOldFile, MAX_PATH);

    if (uRet == 0 || uRet >= MAX_PATH ||
        ((MAX_PATH - uRet) <= (PASSPORT_DIRECTORY_LEN + WEB_PARTNER_FILE_LEN + 1)) ||
        ((MAX_PATH - uRet) <= NT_PARTNER_FILE_LEN))
    {
        goto Cleanup;
    }

    //
    // The following call checks for a start up menu shortcut (would have been
    // previously created by PP SDK and if it finds one then updates that
    // shortcut.
    //
    UpdateConfigShortcut(wszOldFile);

    //
    // partner2.xml is designed to be updated via the web.  However, the NT version of
    // that XML file is msppptnr.xml, which is in the %windir% and protected by SFP.  As
    // such, copy the out-of-the-box XML file to a location where it can be updated.
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     L"Software\\Microsoft\\Passport\\Nexus\\Partner",
                     0,
                     KEY_SET_VALUE | KEY_QUERY_VALUE,
                     &hKey)
             != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    err = RegQueryValueEx(hKey,
                     L"CCDLocalFile",
                     0,
                     &dwType,
                     NULL,
                     &cbKeyData);

    if (ERROR_FILE_NOT_FOUND == err) 
    {
        //
        // Create the MicrosoftPassport subdirectory
        //

        wszOldFile[uRet++] = L'\\';
        wszOldFile[uRet]   = L'\0';

        wcscpy(wszNewFile, wszOldFile);
        wcscpy(wszNewFile + uRet, PASSPORT_DIRECTORY);

        if (!CreateDirectory(wszNewFile, NULL) && (GetLastError() != ERROR_ALREADY_EXISTS))
        {
            goto Cleanup;
        }

        //
        // Now, copy the file over -- don't fail if there's already a copy
        // there but don't overwrite the existing file in that case.
        //

        wcscpy(wszOldFile + uRet, NT_PARTNER_FILE);

        wszNewFile[uRet++ + PASSPORT_DIRECTORY_LEN] = L'\\';
        wcscpy(wszNewFile + uRet + PASSPORT_DIRECTORY_LEN, WEB_PARTNER_FILE);

        if (!CopyFile(wszOldFile, wszNewFile, TRUE) && (GetLastError() != ERROR_FILE_EXISTS))
        {
            goto Cleanup;
        }

        //
        // The copy succeeded -- update CCDLocalFile to point at the new file
        //

        RegSetValueEx(hKey,
                      L"CCDLocalFile",
                      0,
                      REG_SZ,
                      (LPBYTE) wszNewFile,
                      (uRet + PASSPORT_DIRECTORY_LEN + 1 + WEB_PARTNER_FILE_LEN) * sizeof(WCHAR));

        //
        // In this case PP is assumed to have not been installed on the machine previously,
        // so we want to set the secure level to 10 in this case.  If PP is already on the
        // box then we don't do this so we don't break upgrade cases.
        //
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         L"Software\\Microsoft\\Passport",
                         0,
                         KEY_SET_VALUE,
                         &hPPKey)
                 != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        //
        // The copy succeeded -- update CCDLocalFile to point at the new file
        //
        dwSecureLevel = 10;
        RegSetValueEx(hPPKey,
                      L"SecureLevel",
                      0,
                      REG_DWORD,
                      (LPBYTE)&dwSecureLevel,
                      sizeof(dwSecureLevel));
    }

Cleanup:
    if (hPPKey)
    {
        RegCloseKey(hPPKey);
    }

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    if (pIPassportManager)
    {
        pIPassportManager->Release();
    }

    if (fCoInitialized)
    {
        ::CoUninitialize();
    }

    g_bRegistering = FALSE;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// GetMyVersion - return a version string for use in query strings.

LPWSTR
GetVersionString(void)
{
    static LONG             s_lCallersIn = 0;
    static WCHAR            s_achVersionString[44] = L"";
    static LPWSTR           s_pszVersionString = NULL;
    static PassportEvent    s_Event;

    TCHAR               achFileBuf[_MAX_PATH];
    LONG                lCurrentCaller;
    DWORD               dwSize;
    LPVOID              lpVersionBuf = NULL;
    VS_FIXEDFILEINFO*   lpRoot;
    UINT                nRootLen;


    if(s_pszVersionString == NULL)
    {
        lCurrentCaller = InterlockedIncrement(&s_lCallersIn);

        if(lCurrentCaller == 1)
        {
            if (IS_DOT_NET_SERVER())
            {
                //
                // The NT build uses different versioning for the binaries.  Return the
                // appropriate version for these sources as checked by the server.
                //

                wcscpy(s_achVersionString, L"2.1.6000.1");
            }
            else
            {
                //
                // Pull the version off of the DLL itself -- first get the full path
                //

                if(GetModuleFileName(hInst, achFileBuf, sizeof(achFileBuf)/sizeof(TCHAR)) == 0)
                    goto Cleanup;
                achFileBuf[_MAX_PATH - 1] = TEXT('\0');

                if((dwSize = GetFileVersionInfoSize(achFileBuf, &dwSize)) == 0)
                    goto Cleanup;

                lpVersionBuf = new BYTE[dwSize];
                if(lpVersionBuf == NULL)
                    goto Cleanup;

                if(GetFileVersionInfo(achFileBuf, 0, dwSize, lpVersionBuf) == 0)
                    goto Cleanup;

                if(VerQueryValue(lpVersionBuf, TEXT("\\"), (LPVOID*)&lpRoot, &nRootLen) == 0)
                    goto Cleanup;

                wsprintfW(s_achVersionString, L"%d.%d.%04d.%d", 
                         (lpRoot->dwProductVersionMS & 0xFFFF0000) >> 16,
                         lpRoot->dwProductVersionMS & 0xFFFF,
                         (lpRoot->dwProductVersionLS & 0xFFFF0000) >> 16,
                         lpRoot->dwProductVersionLS & 0xFFFF);
            }

            s_pszVersionString = s_achVersionString;

            s_Event.Set();
        }
        else
        {
            //  Just wait to be signaled that we have the string.
            WaitForSingleObject(s_Event, INFINITE);
        }

        InterlockedDecrement(&s_lCallersIn);
    }

Cleanup:

    if(lpVersionBuf)
        delete [] lpVersionBuf;

    return s_pszVersionString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\helperfuncs.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    HelperFuncs.cpp
       COM object for manager interface


    FILE HISTORY:

*/
// HelperFuncs.cpp : Useful functions
#include "stdafx.h"
#include <time.h>
#include "HelperFuncs.h"
#include "Monitoring.h"
#include "nsconst.h"
#include <wininet.h>
#include <commd5.h>

using namespace ATL;

LPWSTR GetVersionString(void);
BOOL PPEscapeUrl(LPCTSTR lpszStringIn,
                 LPTSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags);

//===========================================================================
//
//	@func	Copy char string helper, and ADDs the length of the source string
//			to cb.  
//
//	@rdesc	returns the pointer into the buffer of last char copied.
//

LPSTR
CopyHelperA(
    LPSTR   pszDest,	//@parm	start of buffer to copy INTO
    LPCSTR  pszSrc,	//@parm string to copy
    LPCSTR  pszBufEnd,	//@parm end of buffer to prevent overwrite
    DWORD   &cb		//@parm length of the source string will be ADDed to this value
    )
{
    LPCSTR pszDestTemp = pszDest;

    if(!pszDest || !pszSrc)
        return pszDest;

    while( (pszDest < pszBufEnd) && (*pszDest = *pszSrc))
    {
        pszDest++;
        pszSrc++;
    }

    cb += (DWORD) (pszDest - pszDestTemp);

    while(*pszSrc++)
    	cb++;
    
    return( pszDest );
}

//===========================================================================
//
// Copy wchar string helper
//

LPWSTR
CopyHelperW(
    LPWSTR  pszDest,
    LPCWSTR pszSrc,
    LPCWSTR pszBufEnd
    )
{
    if(!pszDest || !pszSrc)
        return pszDest;

    while(  (pszDest < pszBufEnd) && (*pszDest = *pszSrc))
    {
        pszDest++;
        pszSrc++;
    }
    return( pszDest );
}

//===========================================================================
//
// Copy wchar string helper
//

LPWSTR
CopyNHelperW(
    LPWSTR  pszDest,
    LPCWSTR pszSrc,
    ULONG   ulCount,
    LPCWSTR pszBufEnd
    )
{
    ULONG ulCur = 0;

    if(!pszDest || !pszSrc)
        return pszDest;

    while( (pszDest < pszBufEnd) && (*pszDest = *pszSrc))
    {
        pszDest++;
        pszSrc++;
        if(++ulCur == ulCount) break;
    }

    return pszDest;
}

//===========================================================================
//
// Format a logo tag HTML element
//

BSTR
FormatNormalLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentCryptVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszImageURL,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PM_LOGOTYPE nLogoType,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf,
    BOOL    bCreateTPF
    
    )
/*
The old sprintf for reference:
            _snwprintf(text, 2048, L"<A HREF=\"%s?id=%d&ru=%s&tw=%d&fs=%s&kv=%d&ct=%u%s%s\">%s</A>",
                       url, crc->getSiteId(), returnUrl, TimeWindow, ForceLogin ? L"1" : L"0",
                       crc->getCurrentCryptVersion(), ct, CBT?L"&cb=":L"", CBT?CBT:L"", iurl);
*/
{
    WCHAR   text[MAX_URL_LENGTH * 2];
    LPWSTR  pszCurrent = text;
    LPCWSTR pszBufEnd = &(text[MAX_URL_LENGTH * 2 - 1]);

    //  logotag specific format
    pszCurrent = CopyHelperW(pszCurrent, L"<A HREF=\"", pszBufEnd);

    //  call the common formatting function
    //  it is the same for AuthURL and LogoTag
    pszCurrent = FormatAuthURLParameters(pszLoginServerURL,
                                         ulSiteId,
                                         pszReturnURL,
                                         ulTimeWindow,
                                         bForceLogin,
                                         ulCurrentCryptVersion,
                                         tCurrentTime,
                                         pszCoBrand,
                                         pszNameSpace,
                                         nKPP,
                                         pszCurrent,
                                         MAX_URL_LENGTH,
                                         lang,
                                         ulSecureLevel,
                                         pCRC,
                                         fRedirToSelf &&
                                            nLogoType == PM_LOGOTYPE_SIGNIN,
                                         bCreateTPF
                                         );
    if (NULL == pszCurrent)
    {
        return NULL;
    }

    pszCurrent = CopyHelperW(pszCurrent, L"\">", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszImageURL, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"</A>", pszBufEnd);

    return ALLOC_AND_GIVEAWAY_BSTR(text);
}

//===========================================================================
//
// Format a update logo tag HTML element
//

BSTR
FormatUpdateLogoTag(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    int     nKPP,
    LPCWSTR pszUpdateServerURL,
    BOOL    bSecure,
    LPCWSTR pszProfileUpdate,
    PM_LOGOTYPE nLogoType,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL  bCreateTPF
)
/*
The old sprintf for reference:
_snwprintf(text, 2048,
                   L"<A HREF=\"%s?id=%d&ru=%s&tw=%d&fs=%s&kv=%d&ct=%u%s%s\">%.*s?id=%d&ct=%u&sec=%s&ru=%s&up=%s%s</A>",
                   url, crc->getSiteId(), returnUrl, TimeWindow, ForceLogin ? L"1" : L"0",
                   crc->getCurrentCryptVersion(), ct, CBT?L"&cb=":L"", CBT?CBT:L"",
           (ins-iurl), iurl, crc->getSiteId(), ct, (bSecure ? L"true" : L"false"),returnUrl,
           newCH, ins+2);
*/
{
    WCHAR   text[MAX_URL_LENGTH * 2];
    WCHAR   temp[40];
    WCHAR   siteid[40];
    WCHAR   curtime[40];
    LPWSTR  pszCurrent = text;
    LPCWSTR pszBufEnd = &(text[MAX_URL_LENGTH * 2 - 1]);
    LPWSTR  pszFirstHalfEnd;
    HRESULT hr = S_OK;

    pszCurrent = CopyHelperW(pszCurrent, L"<A HREF=\"", pszBufEnd);
    LPWSTR signStart1 = pszCurrent;
    pszCurrent = CopyHelperW(pszCurrent, pszLoginServerURL, pszBufEnd);

    if(wcschr(text, L'?') == NULL)
        pszCurrent = CopyHelperW(pszCurrent, L"?id=", pszBufEnd);
    else
        pszCurrent = CopyHelperW(pszCurrent, L"&id=", pszBufEnd);

    _ultow(ulSiteId, siteid, 10);
    pszCurrent = CopyHelperW(pszCurrent, siteid, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ru=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszReturnURL, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&tw=", pszBufEnd);

    _ultow(ulTimeWindow, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&fs=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, bForceLogin ? L"1" : L"0", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&kv=", pszBufEnd);

    _ultow(ulCurrentKeyVersion, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ct=", pszBufEnd);

    _ultow(tCurrentTime, curtime, 10);
    pszCurrent = CopyHelperW(pszCurrent, curtime, pszBufEnd);
    if(pszCoBrand)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&cb=", pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, pszCoBrand, pszBufEnd);
    }

    if(nKPP != -1)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&kpp=", pszBufEnd);

        _ultow(nKPP, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    if(ulSecureLevel != 0)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&seclog=", pszBufEnd);

        _ultow(ulSecureLevel, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    pszCurrent = CopyHelperW(pszCurrent, L"&ver=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, GetVersionString(), pszBufEnd);

    hr = SignQueryString(pCRC, ulCurrentKeyVersion, signStart1, pszCurrent, pszBufEnd, bCreateTPF);
    if (S_OK != hr)
    {
        return NULL;
    }

    pszCurrent = CopyHelperW(pszCurrent, L"\">", pszBufEnd);

    pszFirstHalfEnd = pszUpdateServerURL ? (wcsstr(pszUpdateServerURL, L"$1")) : NULL;

    pszCurrent = CopyNHelperW(pszCurrent, pszUpdateServerURL, (ULONG)(pszFirstHalfEnd - pszUpdateServerURL), pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"?id=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, siteid, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ct=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, curtime, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&sec=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, bSecure ? L"true" : L"false", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ru=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszReturnURL, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&up=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszProfileUpdate, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszFirstHalfEnd + 2, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"</A>", pszBufEnd);

    return ALLOC_AND_GIVEAWAY_BSTR(text);
}

//===========================================================================
//
// Sign a query string with partner's key
//

HRESULT SignQueryString(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPWSTR  pszBufStart,
    LPWSTR& pszCurrent,
    LPCWSTR pszBufEnd,
    BOOL    bCreateTPF
    
    )
{
    BSTR signature = NULL;
    HRESULT hr = S_OK;
    if (!bCreateTPF)
       return hr;

    if(pCRC)
    {   
        LPWSTR   signStart = wcschr(pszBufStart, L'?');

        // nothing to sign
        if (NULL == signStart)
        {
            goto Cleanup;
        }

        // if found before pszCurrent
        if(signStart < pszCurrent)
        {
            ++signStart;;
        }
        hr = PartnerHash(pCRC, ulCurrentKeyVersion, signStart, pszCurrent - signStart, &signature);

        if (hr == S_OK && signature != NULL)
        {
            pszCurrent = CopyHelperW(pszCurrent, L"&tpf=", pszBufEnd);
            pszCurrent = CopyHelperW(pszCurrent, signature, pszBufEnd);
        }
        if (!signature && g_pAlert)
        {
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED,
                             0, NULL);
        }
    }
    else if(g_pAlert)
        g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED,
                        0, NULL);
Cleanup:
    if (signature)
    {
        SysFreeString(signature);
    }
    return hr;
}


//===========================================================================
//
// MD5 hash with partner's key
//

HRESULT PartnerHash(
    CRegistryConfig* pCRC,
    ULONG   ulCurrentKeyVersion,
    LPCWSTR tobeSigned,
    ULONG   nChars,
    BSTR*   pbstrHash
    )
{
    // MD5 hash the url and query strings + the key of the
    //
    if(!pCRC || !pbstrHash) return E_INVALIDARG;

    CCoCrypt* crypt = pCRC->getCrypt(ulCurrentKeyVersion, NULL);
    DWORD keyLen = 0;
    unsigned char* key = NULL;
    BSTR bstrHash = NULL;
    HRESULT  hr = S_OK;
    BOOL bSigned = FALSE;
    BSTR binHexedKey = NULL;
    LPSTR lpToBeHashed = NULL;

    if (crypt && (key = crypt->getKeyMaterial(&keyLen)))
    {
        CBinHex  BinHex;

        //encode the key
        hr = BinHex.ToBase64ASCII((BYTE*)key, keyLen, 0, NULL, &binHexedKey);

        if (hr != S_OK)
        {
            goto Cleanup;
        }

        // W2A conversion here -- we sign ascii version

        ULONG ulFullLen;
        ULONG ulKeyLen;
        ULONG ulWideLen = wcslen(tobeSigned);
        ULONG ulAnsiLen = WideCharToMultiByte(CP_ACP, 0, tobeSigned, ulWideLen, NULL, 0, NULL, NULL);

        if (ulAnsiLen == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }

        ulKeyLen = strlen((LPCSTR)binHexedKey);
        ulFullLen = ulAnsiLen + ulKeyLen;

        // NOTE - the SysAllocStringByteLen allocs an additional WCHAR so we won't overflow
        // The MD5Hash function actually uses SysStringByteLen when doing the hashing so unless
        // we want to make a copy just allocate what we need
        lpToBeHashed = (LPSTR) ::SysAllocStringByteLen(NULL, ulFullLen * sizeof(CHAR));

        if (lpToBeHashed == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP,
                            0,
                            tobeSigned,
                            ulWideLen,
                            lpToBeHashed,
                            ulAnsiLen,
                            NULL,
                            NULL);

        strcpy(lpToBeHashed + ulAnsiLen, (LPCSTR)binHexedKey);
        RtlSecureZeroMemory((PVOID)binHexedKey, ulKeyLen);
        {
            CComPtr<IMD5>  md5;

            hr = GetGlobalCOMmd5(&md5);

            if (hr == S_OK)
            {
                hr = md5->MD5Hash((BSTR)lpToBeHashed, &bstrHash);
                RtlSecureZeroMemory(lpToBeHashed + ulAnsiLen, ulKeyLen);

                if( hr == S_OK && bstrHash != NULL)
                {
                    *pbstrHash = bstrHash;
                    bstrHash = NULL;
                    bSigned = TRUE;
                }
                else
                {
                    *pbstrHash = NULL;
                }
            }
        }
    }
    else
    {
        if (g_pAlert )
        {
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CURRENTKEY_NOTDEFINED, 0, NULL);
        }
    }

Cleanup:
    if (bstrHash)
    {
        SysFreeString(bstrHash);
    }

    if (lpToBeHashed)
    {
        SysFreeString((BSTR)lpToBeHashed);
    }

    if (binHexedKey)
    {
        SysFreeString(binHexedKey);
    }

    if (!bSigned && g_pAlert)
    {
        g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_URLSIGNATURE_NOTCREATED, 0, NULL);
    }

    return hr;
}


//===========================================================================
//
// Construct AuthURL, returning BSTR
//

BSTR
FormatAuthURL(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirToSelf,
    BOOL    bCreateTPF
    )
/*
The old sprintf for reference:
  _snwprintf(text, 2048, L"%s?id=%d&ru=%s&tw=%d&fs=%d&kv=%d&ct=%u%s%s",
             url, crc->getSiteId(), returnUrl, TimeWindow, ForceLogin ? 1 : 0,
             crc->getCurrentCryptVersion(), ct ,CBT?L"&cb=":L"", CBT?CBT:L"");
*/
{
    WCHAR   text[2048] = L"";

    if (NULL == FormatAuthURLParameters(pszLoginServerURL,
                            ulSiteId,
                            pszReturnURL,
                            ulTimeWindow,
                            bForceLogin,
                            ulCurrentKeyVersion,
                            tCurrentTime,
                            pszCoBrand,
                            pszNameSpace,
                            nKPP,
                            text,
                            sizeof(text)/sizeof(WCHAR),
                            lang,
                            ulSecureLevel,
                            pCRC,
                            fRedirToSelf,
                            bCreateTPF
                            ))
    {
        return NULL;
    }

    return ALLOC_AND_GIVEAWAY_BSTR(text);
}

//===========================================================================
//
//
//  consolidate the code in FormatAuthUrl and NormalLogoTag -- with passed in buffer
//
PWSTR
FormatAuthURLParameters(
    LPCWSTR pszLoginServerURL,
    ULONG   ulSiteId,
    LPCWSTR pszReturnURL,
    ULONG   ulTimeWindow,
    BOOL    bForceLogin,
    ULONG   ulCurrentKeyVersion,
    time_t  tCurrentTime,
    LPCWSTR pszCoBrand,
    LPCWSTR pszNameSpace,
    int     nKPP,
    PWSTR   pszBufStart,
    ULONG   cBufLen,        //  length of buffer in WCHAR
    USHORT  lang,
    ULONG   ulSecureLevel,
    CRegistryConfig* pCRC,
    BOOL    fRedirectToSelf, //  if true, this is URL for self redirect
                            //  otherwise the redirect is to the login server
    BOOL    bCreateTPF
    )
{
    WCHAR   temp[40];
    LPWSTR  pszCurrent = pszBufStart, pszLoginStart, pszSignURLStart = NULL;
    LPCWSTR pszBufEnd = pszBufStart + cBufLen - 1;
    HRESULT hr = S_OK;
    PWSTR   pwszReturn = NULL;

    //  helper BSTR ...
    BSTR    bstrHelper = SysAllocStringLen(NULL, cBufLen);
    if (NULL == bstrHelper)
    {
        goto Cleanup;
    }

    if (fRedirectToSelf)
    {
        //
        //  new authUrl is the return URL + indication a challenge - msppchlg=1 - has to be
        //  done + the rest of the qs parameters as they are in the original
        //  protocol
        //
        DWORD   cchLen = cBufLen;

        if(!InternetCanonicalizeUrl(pszReturnURL,
                                    pszCurrent,
                                    &cchLen,
                                    ICU_DECODE | ICU_NO_ENCODE))
        {
            //  this should not fail ...
            _ASSERT(FALSE);
            goto Cleanup;
        }

        //  require at least 50 chars
        if (cchLen > cBufLen - 50 )
        {
            _ASSERT(FALSE);
            goto Cleanup;
        }
        PWSTR psz = pszCurrent;
        while(*psz && *psz != L'?') psz++;
        //  see if URL already contains '?'
        //  if so, the sequence will start with '&'
        if (*psz)
            pszCurrent[cchLen] = L'&';
        else
            pszCurrent[cchLen] = L'?';
        pszCurrent += cchLen + 1;

        // indicate challange
        pszCurrent = CopyHelperW(pszCurrent, PPSITE_CHALLENGE, pszBufEnd);

        // login server ....
        pszCurrent = CopyHelperW(pszCurrent, L"&", pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, PPLOGIN_PARAM, pszBufEnd);

        //
        //  remember the start of the login URL
        pszLoginStart = pszCurrent;
        //  use the temp buffer for the rest
        pszCurrent = bstrHelper;
        pszSignURLStart = pszCurrent;
        pszBufEnd = pszCurrent + SysStringLen(bstrHelper) - 1;
        //
        //  format loginserverUrl and qs params in a separate buffer, so
        //  they can be escaped ...
        pszCurrent = CopyHelperW(pszCurrent, pszLoginServerURL, pszBufEnd);

        //  start sequence
        if (wcschr(pszLoginServerURL, L'?'))
        {
            //  login server already contains qs
            pszCurrent = CopyHelperW(pszCurrent, L"&", pszBufEnd);
        }
        else
        {
            //  start qs sequence
            pszCurrent = CopyHelperW(pszCurrent, L"?", pszBufEnd);
        }

        pszCurrent = CopyHelperW(pszCurrent, L"id=", pszBufEnd);
        //  common code will fill in id and the rest ....
    }
    else
    {
        //  redirect directly to a login server
        pszSignURLStart = pszCurrent;
        pszCurrent = CopyHelperW(pszCurrent, pszLoginServerURL, pszBufEnd);
        //  start sequence
        while(*pszLoginServerURL && *pszLoginServerURL != L'?') pszLoginServerURL++;
        if (*pszLoginServerURL)
            pszCurrent = CopyHelperW(pszCurrent, L"&id=", pszBufEnd);
        else
            pszCurrent = CopyHelperW(pszCurrent, L"?id=", pszBufEnd);
    }


    _ultow(ulSiteId, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);

    // keep the ru, so I don't have to reconstruct
    pszCurrent = CopyHelperW(pszCurrent, L"&ru=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, pszReturnURL, pszBufEnd);

    pszCurrent = CopyHelperW(pszCurrent, L"&tw=", pszBufEnd);

    _ultow(ulTimeWindow, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);

    if(bForceLogin)
    {
       pszCurrent = CopyHelperW(pszCurrent, L"&fs=1", pszBufEnd);
    }
    pszCurrent = CopyHelperW(pszCurrent, L"&kv=", pszBufEnd);

    _ultow(ulCurrentKeyVersion, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, L"&ct=", pszBufEnd);

    _ultow(tCurrentTime, temp, 10);
    pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    if(pszCoBrand)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&cb=", pszBufEnd);
        pszCurrent = CopyHelperW(pszCurrent, pszCoBrand, pszBufEnd);
    }

    if(pszNameSpace)
    {
        if (!_wcsicmp(pszNameSpace, L"email"))
        {
            // namespace == email -> ems=1
            pszCurrent = CopyHelperW(pszCurrent, L"&ems=1", pszBufEnd);
        }
        else if(*pszNameSpace)
        {
            // regular namespace logic
            pszCurrent = CopyHelperW(pszCurrent, L"&ns=", pszBufEnd);
            pszCurrent = CopyHelperW(pszCurrent, pszNameSpace, pszBufEnd);
        }
    }
    else
    {
        // namespace == null : default to email
        pszCurrent = CopyHelperW(pszCurrent, L"&ems=1", pszBufEnd);
    }

    if(nKPP != -1 && nKPP != 0)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&kpp=", pszBufEnd);

        _ultow(nKPP, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    if(ulSecureLevel != 0)
    {
        pszCurrent = CopyHelperW(pszCurrent, L"&seclog=", pszBufEnd);

        _ultow(ulSecureLevel, temp, 10);
        pszCurrent = CopyHelperW(pszCurrent, temp, pszBufEnd);
    }

    pszCurrent = CopyHelperW(pszCurrent, L"&ver=", pszBufEnd);
    pszCurrent = CopyHelperW(pszCurrent, GetVersionString(), pszBufEnd);

    // MD5 hash the url and query strings + the key of the
    //
    hr = SignQueryString(pCRC, ulCurrentKeyVersion, pszSignURLStart, pszCurrent, pszBufEnd, bCreateTPF);

    *pszCurrent = L'\0';

    if (S_OK != hr)
    {
        goto Cleanup;
    }

    if (fRedirectToSelf)
    {
        //  escape and put back in the original buffer.
        //  adjust the length first
        cBufLen -= (ULONG) (pszLoginStart - pszBufStart);
        if (!PPEscapeUrl(bstrHelper,
                         pszLoginStart,
                         &cBufLen,
                         cBufLen,
                         0))
        {
            _ASSERT(FALSE);
            //  cut the return
            pszCurrent = pszLoginStart;
        }
        else
        {
            pszCurrent = pszLoginStart + cBufLen;
        }

    }
    pwszReturn = pszCurrent;
Cleanup:
    if (bstrHelper)
    {
        SysFreeString(bstrHelper);
    }
    return pwszReturn;
}

//===========================================================================
//
// retrieve a query parameter from a query string
//

BOOL
GetQueryParam(LPCSTR queryString, LPSTR param, BSTR* p)
{
    LPSTR aLoc, aEnd;
    int aLen, i;

    //  Find the first occurrence of the param in the queryString.
    aLoc = strstr(queryString, param);
    while(aLoc != NULL)
    {
        //  If the string was found at the beginning of the string, or was
        //  preceded by a '&' then we've found the correct param.  Otherwise
        //  we tail-matched some other query string param and should look again.

        if(aLoc == queryString ||
            *(aLoc - 1) == '&')
        {
            aLoc += strlen(param);
            aEnd = strchr(aLoc, '&');

            if(aEnd)
                aLen = aEnd - aLoc;
            else
                aLen = strlen(aLoc);

            BSTR aVal = ALLOC_BSTR_LEN(NULL, aLen);
            if (NULL == aVal)
                return FALSE;

            for (i = 0; i < aLen; i++)
                aVal[i] = aLoc[i];
            *p = aVal;
            GIVEAWAY_BSTR(aVal);
            return TRUE;
        }

        aLoc = strstr(aLoc + 1, param);
    }

    return FALSE;
}

//===========================================================================
//
// get t, p, and f from query string
//

BOOL
GetQueryData(
    LPCSTR   queryString,
    BSTR*   a,
    BSTR*   p,
    BSTR*   f)
{
    //  This one is optional, don't error out if it isn't there.
    GetQueryParam(queryString, "f=", f);

    if(!GetQueryParam(queryString, "t=", a))
        return FALSE;

    // OK if we have ticket w/o profile.
    GetQueryParam(queryString, "p=", p);

    return TRUE;
}

#define ToHexDigit(x) (('0' <= x && x <= '9') ? (x - '0') : (tolower(x) - 'a' + 10))

//===========================================================================
//
// Get a cookie from value of cookie header
//

BOOL
GetCookie(
    LPCSTR   pszCookieHeader,
    LPCSTR   pszCookieName,
    BSTR*   pbstrCookieVal
    )
{
    LPSTR nLoc;
    LPCSTR pH = pszCookieHeader;
    LPSTR nEnd;
    int   nLen, src, dst;

    if(pbstrCookieVal == NULL || pszCookieHeader == NULL)
        return FALSE;

    *pbstrCookieVal = NULL;

    _ASSERT(pszCookieName);

    // find begining
    while (nLoc = strstr(pH, pszCookieName))
    {
      nLen = strlen(pszCookieName);

      _ASSERT(nLen > 0);
      if ((nLoc == pszCookieHeader || *(nLoc - 1) == ' ' || *(nLoc - 1) == ';' || *(nLoc - 1) == ':') && *(nLoc + nLen) == '=')
         break;
      else
         pH = nLoc + nLen;
    }

    if (nLoc == NULL)
    {
        return FALSE;
    }
    else
      nLoc += nLen + 1;

    // find end
    nEnd = strchr(nLoc,';');

    if (nEnd)
        nLen = nEnd - nLoc;
    else
        nLen = strlen(nLoc);

    if (nLen == 0)   // empty cookie
      return FALSE;

    BSTR nVal = ALLOC_BSTR_LEN(NULL, nLen);
    if(!nVal)
        return FALSE;

    for (src = 0, dst = 0; src < nLen;)
    {
        //handle any url encoded gunk
        if(nLoc[src] == '%')
        {
            nVal[dst++] = (ToHexDigit(nLoc[src+1]) << 4) + ToHexDigit(nLoc[src+2]);
            src+=3;
        }
        else
        {
            nVal[dst++] = nLoc[src++];
        }
    }
    nVal[dst] = 0;

    GIVEAWAY_BSTR(nVal);
    *pbstrCookieVal = nVal;

    return TRUE;
}


//===========================================================================
//
// 	@func	Build passport cookies (MSPAuth, MSPProf, MSPConsent) -- into a buffer
//			If the buffer is not big enough, return EMPTY string in the buffer and
//			the required size (including the NULL terminator) is returned in pdwBufLen.
//			
//			Note that CopyHelperA must be used in the construction for the right buffer length.
//	
//	@rdesc	Returns one of the following values
//	@flag	TRUE	|	Always

BOOL
BuildCookieHeaders(
    LPCSTR  pszTicket,
    LPCSTR  pszProfile,
    LPCSTR  pszConsent,
    LPCSTR  pszSecure,
    LPCSTR  pszTicketDomain,
    LPCSTR  pszTicketPath,
    LPCSTR  pszConsentDomain,
    LPCSTR  pszConsentPath,
    LPCSTR  pszSecureDomain,
    LPCSTR  pszSecurePath,
    BOOL    bSave,
    LPSTR   pszBuf,				//@parm buffer that will hold the output. Could be NULL.
    IN OUT LPDWORD pdwBufLen,	//@parm size of buffer.  Could be 0
    bool    bHTTPOnly
    )
/*
Here is the old code for reference:

    if (domain)
    {
        *bufSize = _snprintf(pCookieHeader, *bufSize,
                            "Set-Cookie: MSPAuth=%s; path=/; domain=%s; %s\r\n"
                            "Set-Cookie: MSPProf=%s; path=/; domain=%s; %s\r\n",
                            W2A(a), domain,
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "",
                            W2A(p), domain,
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "");
    }
    else
    {
        *bufSize = _snprintf(pCookieHeader, *bufSize,
                            "Set-Cookie: MSPAuth=%s; path=/; %s\r\n"
                            "Set-Cookie: MSPProf=%s; path=/; %s\r\n",
                            W2A(a),
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "",
                            W2A(p),
                            persist ? "expires=Mon 1-Jan-2035 12:00:00 GMT;" : "");
    }

*/
{
    LPSTR   pszCurrent = pszBuf;
    LPCSTR  pszBufEnd;
	DWORD	cbBuf	  = 0;    

	//
	// 	12002: if pszBuf was NULL, then we dont care about the passed in length; the caller wants to know 
	//	the required length.  In this case, set *pdwBufLen so that pszBufEnd is also NULL
	//
	if (NULL == pszBuf)
		*pdwBufLen = 0;

	pszBufEnd = pszBuf + ((*pdwBufLen > 0) ? *pdwBufLen - 1 : 0);			
	
	//
	//	12002: cbBuf MUST be initialized before calling CopyHelperA since it accumulates the lengths
	//
    pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPAuth=", pszBufEnd, cbBuf);
    pszCurrent = CopyHelperA(pszCurrent, pszTicket, pszBufEnd, cbBuf);
    if(bHTTPOnly)
        pszCurrent = CopyHelperA(pszCurrent, "; HTTPOnly", pszBufEnd, cbBuf);    
    if(pszTicketPath)
    {
        pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, pszTicketPath, pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
    }
    else
        pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd, cbBuf);

    if(pszTicketDomain)
    {
        pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, pszTicketDomain, pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
    }

    if(bSave)
    {
        pszCurrent = CopyHelperA(pszCurrent, COOKIE_EXPIRES(EXPIRE_FUTURE), pszBufEnd, cbBuf);
    }

    pszCurrent = CopyHelperA(pszCurrent, "\r\n", pszBufEnd, cbBuf);

    if(pszProfile)
    {
        pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPProf=", pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, pszProfile, pszBufEnd, cbBuf);
        if(bHTTPOnly)
            pszCurrent = CopyHelperA(pszCurrent, "; HTTPOnly", pszBufEnd, cbBuf);    

        if(pszTicketPath)
        {
            pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, pszTicketPath, pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
        }
        else
            pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd, cbBuf);

        if(pszTicketDomain)
        {
            pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, pszTicketDomain, pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
        }

        if(bSave)
        {
            pszCurrent = CopyHelperA(pszCurrent, COOKIE_EXPIRES(EXPIRE_FUTURE), pszBufEnd, cbBuf);
        }

        pszCurrent = CopyHelperA(pszCurrent, "\r\n", pszBufEnd, cbBuf);

    }

    if(pszSecure)
    {
        pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPSecAuth=", pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, pszSecure, pszBufEnd, cbBuf);
        if(bHTTPOnly)
            pszCurrent = CopyHelperA(pszCurrent, "; HTTPOnly", pszBufEnd, cbBuf);    
        if(pszSecurePath)
        {
            pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, pszSecurePath, pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
        }
        else
            pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd, cbBuf);

        if(pszSecureDomain)
        {
            pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, pszSecureDomain, pszBufEnd, cbBuf);
            pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
        }

        pszCurrent = CopyHelperA(pszCurrent, "secure\r\n", pszBufEnd, cbBuf);
    }

    //  Set MSPConsent cookie
    pszCurrent = CopyHelperA(pszCurrent, "Set-Cookie: MSPConsent=", pszBufEnd, cbBuf);
    if(pszConsent)
    {
        pszCurrent = CopyHelperA(pszCurrent, pszConsent, pszBufEnd, cbBuf);
        if(bHTTPOnly)
            pszCurrent = CopyHelperA(pszCurrent, "; HTTPOnly", pszBufEnd, cbBuf);    
    }

    if(pszConsentPath)
    {
        pszCurrent = CopyHelperA(pszCurrent, "; path=", pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, pszConsentPath, pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
    }
    else
        pszCurrent = CopyHelperA(pszCurrent, "; path=/; ", pszBufEnd, cbBuf);

    if(pszConsentDomain)
    {
        pszCurrent = CopyHelperA(pszCurrent, "domain=", pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, pszConsentDomain, pszBufEnd, cbBuf);
        pszCurrent = CopyHelperA(pszCurrent, "; ", pszBufEnd, cbBuf);
    }

    if(pszConsent)
    {
        if(bSave)
        {
            pszCurrent = CopyHelperA(pszCurrent, COOKIE_EXPIRES(EXPIRE_FUTURE), pszBufEnd, cbBuf);
        }
    }
    else
    {
        pszCurrent = CopyHelperA(pszCurrent, COOKIE_EXPIRES(EXPIRE_PAST), pszBufEnd, cbBuf);
    }

    pszCurrent = CopyHelperA(pszCurrent, "\r\n", pszBufEnd, cbBuf);


    //  finally put the Auth-Info header
    pszCurrent = CopyHelperA(pszCurrent,
            C_AUTH_INFO_HEADER_PASSPORT,
            pszBufEnd, cbBuf);

	if (*pdwBufLen > 0 && (NULL != pszCurrent))
	{
	    *(pszCurrent++) = '\0';
	    *pdwBufLen = pszCurrent - pszBuf;
	}

	//
	//	The length that we report to the caller when the buffer is not big enough
	//	includes room for the '\0'.
	//
	cbBuf++;


    //
    //	12002: return the required size of the buffer if it is not big enough. 
    //	Also clear the buffer
    //
    if (cbBuf > *pdwBufLen)
   	{
		if (*pdwBufLen > 0)
		{
	   		*pszBuf	= '\0';
		}
   		*pdwBufLen = cbBuf;
   	}
    return TRUE;
}


//===========================================================================
//
// Decrpt and set ticket andprofile
//

HRESULT
DecryptTicketAndProfile(
    BSTR                bstrTicket,
    BSTR                bstrProfile,
    BOOL                bCheckConsent,
    BSTR                bstrConsent,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket,
    IPassportProfile*   piProfile)
{
    HRESULT             hr;
    BSTR                ret = NULL;
    CCoCrypt*           crypt = NULL;
    time_t              tValidUntil;
    time_t              tNow = time(NULL);
    int                 kv;
    int                 nMemberIdHighT, nMemberIdLowT;
    VARIANT             vMemberIdHighP, vMemberIdLowP;
    CComPtr<IPassportTicket2>   spTicket2;

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    // Make sure we have both ticket and profile first.
    if (bstrTicket == NULL || SysStringLen(bstrTicket) == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get key version and crypt object.
    kv = CCoCrypt::getKeyVersion(bstrTicket);
    crypt = pRegistryConfig->getCrypt(kv, &tValidUntil);

    if (crypt == NULL)
    {
        if (g_pAlert )
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_KEY,
                             0, NULL, SysStringByteLen(bstrTicket), (LPVOID)bstrTicket);
        AtlReportError(CLSID_FastAuth, PP_E_INVALID_TICKETSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Is the key still valid?
    if(tValidUntil && tValidUntil < tNow)
    {
        DWORD dwTimes[2] = { tValidUntil, tNow };
        TCHAR *pszStrings[1];
        TCHAR value[34];   // the _itot only takes upto 33 chars
        pszStrings[0] = _itot(pRegistryConfig->getSiteId(), value, 10);

        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_KEY_EXPIRED,
                             1, (LPCTSTR*)pszStrings, sizeof(DWORD) << 1, (LPVOID)dwTimes);
        AtlReportError(CLSID_FastAuth, PP_E_INVALID_TICKETSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Decrypt the ticket and set it into the ticket object.
    if(crypt->Decrypt(bstrTicket, SysStringByteLen(bstrTicket), &ret)==FALSE)
    {
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_TICKET_C,
                             0, NULL, SysStringByteLen(bstrTicket), (LPVOID)bstrTicket);
        AtlReportError(CLSID_FastAuth, PP_E_INVALID_TICKETSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    TAKEOVER_BSTR(ret);
    hr = piTicket->put_unencryptedTicket(ret);
    if (S_OK != hr) 
    {
        goto Cleanup;
    }

    piTicket->QueryInterface(_uuidof(IPassportTicket2), (void**)&spTicket2);
    _ASSERT(spTicket2);
    FREE_BSTR(ret);
    ret = NULL;

    // Decrypt the profile and set it into the profile object.
    if(bstrProfile && SysStringLen(bstrProfile) != 0)
    {
        if(crypt->Decrypt(bstrProfile, SysStringByteLen(bstrProfile), &ret) == FALSE)
        {
            if(g_pAlert)
                g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_PROFILE_C,
                             0, NULL, SysStringByteLen(bstrProfile), (LPVOID)bstrProfile);
            piProfile->put_unencryptedProfile(NULL);
        }
        else
        {

            TAKEOVER_BSTR(ret);
            hr = piProfile->put_unencryptedProfile(ret);
            if (S_OK != hr) 
            {
                goto Cleanup;
            }

            //
            //  Member id in profile MUST match member id in ticket.
            //

            piTicket->get_MemberIdHigh(&nMemberIdHighT);
            piTicket->get_MemberIdLow(&nMemberIdLowT);

            VariantInit(&vMemberIdHighP);
            VariantInit(&vMemberIdLowP);

            // these could be missing for mobile case
            HRESULT hr1 = piProfile->get_Attribute(L"memberidhigh", &vMemberIdHighP);
            HRESULT hr2 = piProfile->get_Attribute(L"memberidlow", &vMemberIdLowP);

            // these could be missing for mobile case
            if(hr1 == S_OK && hr2 == S_OK &&
               (nMemberIdHighT != vMemberIdHighP.lVal ||
                nMemberIdLowT  != vMemberIdLowP.lVal))
            {
                piProfile->put_unencryptedProfile(NULL);
            }
        }
    }
    else
        piProfile->put_unencryptedProfile(NULL);

    //
    // consent stuff
    if(bstrConsent)
    {
        FREE_BSTR(ret);
        ret = NULL;

        if(crypt->Decrypt(bstrConsent, SysStringByteLen(bstrConsent), &ret) == FALSE)
        {
            if(g_pAlert)
                g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_CONSENT,
                             0, NULL, SysStringByteLen(bstrProfile), (LPVOID)bstrProfile);
            // we can continue
        }
        else
        {
           TAKEOVER_BSTR(ret);
           spTicket2->SetTertiaryConsent(ret);  // we ignore return value here
        }
    }

    //  If the caller wants us to check consent, then do it.  If we don't have
    //  consent, then set the profile back to NULL.
    if(bCheckConsent)
    {
        ConsentStatusEnum   ConsentCode = ConsentStatus_Unknown;

        VARIANT_BOOL bRequireConsentCookie = ((
               lstrcmpA(pRegistryConfig->getTicketDomain(), pRegistryConfig->getProfileDomain())
               || lstrcmpA(pRegistryConfig->getTicketPath(), pRegistryConfig->getProfilePath())
                                 ) && !(pRegistryConfig->bInDA())) ? VARIANT_TRUE: VARIANT_FALSE;
        spTicket2->ConsentStatus(bRequireConsentCookie, NULL, &ConsentCode);
        switch(ConsentCode)
        {
            case ConsentStatus_Known :
            case ConsentStatus_DoNotNeed :
                break;

            case ConsentStatus_NotDefinedInTicket :  // mean 1.X ticket
            {
                CComVariant vFlags;
                // mobile case, flags may not exist
                if(S_OK == piProfile->get_Attribute(L"flags", &vFlags) &&
                   (V_I4(&vFlags)& k_ulFlagsConsentCookieNeeded))
                {
                    piProfile->put_unencryptedProfile(NULL);
                }
            }
            break;

            case ConsentStatus_Unknown :
                piProfile->put_unencryptedProfile(NULL);
                break;

            default:
                _ASSERT(0); // should not be here
                break;
        }
    }

    hr = S_OK;

Cleanup:

    if (ret) FREE_BSTR(ret);

    if(g_pPerf)
    {
        switch(hr)
        {
        case PP_E_INVALID_TICKET:
        case E_INVALIDARG:
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_TOTAL);
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_SEC);
            break;

        default:
            g_pPerf->incrementCounter(PM_VALIDREQUESTS_TOTAL);
            g_pPerf->incrementCounter(PM_VALIDREQUESTS_SEC);
            break;
        }

        g_pPerf->incrementCounter(PM_REQUESTS_TOTAL);
        g_pPerf->incrementCounter(PM_REQUESTS_SEC);
    }
    else
    {
        _ASSERT(g_pPerf);
    }

    return hr;
}


//===========================================================================
//
// check if the ticket is secure -- private function
//

HRESULT
DoSecureCheck(
    BSTR                bstrSecure,
    CRegistryConfig*    pRegistryConfig,
    IPassportTicket*    piTicket
    )
{
    HRESULT hr;
    BSTR                ret = NULL;
    CCoCrypt*           crypt = NULL;
    time_t              tValidUntil;
    time_t              tNow = time(NULL);
    int                 kv;

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_FastAuth, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportFastAuth, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    // Make sure we have both ticket and profile first.
    if (bstrSecure == NULL || SysStringLen(bstrSecure) == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get key version and crypt object.
    kv = CCoCrypt::getKeyVersion(bstrSecure);
    crypt = pRegistryConfig->getCrypt(kv, &tValidUntil);

    if (crypt == NULL)
    {
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_INVALID_KEY,
                             0, NULL, sizeof(DWORD), (LPVOID)&kv);
        AtlReportError(CLSID_FastAuth, PP_E_INVALID_TICKETSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Is the key still valid?
    if(tValidUntil && tValidUntil < tNow)
    {
        DWORD dwTimes[2] = { tValidUntil, tNow };
        TCHAR *pszStrings[1];
        TCHAR value[34];   // the _itot only takes upto 33 chars
        pszStrings[0] = _itot(pRegistryConfig->getSiteId(), value, 10);

        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_KEY_EXPIRED,
                             1, (LPCTSTR*)pszStrings, sizeof(DWORD) << 1, (LPVOID)dwTimes);
        AtlReportError(CLSID_FastAuth, PP_E_INVALID_TICKETSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    // Decrypt the ticket and set it into the ticket object.
    if(crypt->Decrypt(bstrSecure, SysStringByteLen(bstrSecure), &ret)==FALSE)
    {
        AtlReportError(CLSID_FastAuth, PP_E_INVALID_TICKETSTR,
                       IID_IPassportFastAuth, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    TAKEOVER_BSTR(ret);
    piTicket->DoSecureCheck(ret);
    FREE_BSTR(ret);
    ret = NULL;

    hr = S_OK;

Cleanup:

    return hr;
}


//===========================================================================
//
// Get HTTP request info from ECB
//


LPSTR
GetServerVariableECB(
    EXTENSION_CONTROL_BLOCK*    pECB,
    LPSTR                       pszHeader
    )
{
    DWORD   dwSize = 0;
    LPSTR   lpBuf;

    pECB->GetServerVariable(pECB->ConnID, pszHeader, NULL, &dwSize);
    if(GetLastError() != ERROR_INSUFFICIENT_BUFFER || dwSize == 0)
    {
        lpBuf = NULL;
        goto Cleanup;
    }

    lpBuf = new CHAR[dwSize];
    if(!lpBuf)
        goto Cleanup;

    if(!pECB->GetServerVariable(pECB->ConnID, pszHeader, lpBuf, &dwSize))
    {
        delete [] lpBuf;
        lpBuf = NULL;
    }

Cleanup:

    return lpBuf;
}

//===========================================================================
//
// Get HTTP request info from Filter context
//

LPSTR
GetServerVariablePFC(
    PHTTP_FILTER_CONTEXT    pPFC,
    LPSTR                   pszHeader
    )
{
    DWORD   dwSize;
    LPSTR   lpBuf;
    CHAR    cDummy;

    dwSize = 1;
    pPFC->GetServerVariable(pPFC, pszHeader, &cDummy, &dwSize);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER || dwSize == 0)
    {
        lpBuf = NULL;
        goto Cleanup;
    }


    lpBuf = new CHAR[dwSize];
    if(!lpBuf)
        goto Cleanup;

    if(!pPFC->GetServerVariable(pPFC, pszHeader, lpBuf, &dwSize))
    {
        delete [] lpBuf;
        lpBuf = NULL;
    }

Cleanup:

    return lpBuf;
}

LONG
HexToNum(
    WCHAR c
    )
{
    return ((c >= L'0' && c <= L'9') ? (c - L'0') : ((c >= 'A' && c <= 'F') ? (c - L'A' + 10) : -1));
}

LONG
FromHex(
    LPCWSTR     pszHexString
    )
{
    LONG    lResult = 0;
    LONG    lCurrent;
    LPWSTR  pszCurrent;

    for(pszCurrent = const_cast<LPWSTR>(pszHexString); *pszCurrent; pszCurrent++)
    {
        if((lCurrent = HexToNum(towupper(*pszCurrent))) == -1)
            break;  // illegal character, we're done

        lResult = (lResult << 4) + lCurrent;
    }

    return lResult;
}


inline BOOL PPIsUnsafeUrlChar(TCHAR chIn) throw();

//===========================================================================
//
// PPEscapeUrl
//

BOOL PPEscapeUrl(LPCTSTR lpszStringIn,
                 LPTSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags)
{
    TCHAR ch;
    DWORD dwLen = 0;
    BOOL bRet = TRUE;
    BOOL bSchemeFile = FALSE;
    DWORD dwColonPos = 0;
    DWORD dwFlagsInternal = dwFlags;
    while((ch = *lpszStringIn++) != '\0')
    {
        //if we are at the maximum length, set bRet to FALSE
        //this ensures no more data is written to lpszStringOut, but
        //the length of the string is still updated, so the user
        //knows how much space to allocate
        if (dwLen == dwMaxLength)
        {
            bRet = FALSE;
        }

        //if we are encoding and it is an unsafe character
        if (PPIsUnsafeUrlChar(ch))
        {
            {
                //if there is not enough space for the escape sequence
                if (dwLen >= (dwMaxLength-3))
                {
                        bRet = FALSE;
                }
                if (bRet)
                {
                        //output the percent, followed by the hex value of the character
                        *lpszStringOut++ = '%';
                        _stprintf(lpszStringOut, _T("%.2X"), (unsigned char)(ch));
                        lpszStringOut+= 2;
                }
                dwLen += 2;
            }
        }
        else //safe character
        {
            if (bRet)
                *lpszStringOut++ = ch;
        }
        dwLen++;
    }

    if (bRet)
        *lpszStringOut = L'\0';
    *pdwStrLen = dwLen;
    return  bRet;
}

//Determine if the character is unsafe under the URI RFC document
inline BOOL PPIsUnsafeUrlChar(TCHAR chIn) throw()
{
        unsigned char ch = (unsigned char)chIn;
        switch(ch)
        {
                case ';': case '\\': case '?': case '@': case '&':
                case '=': case '+': case '$': case ',': case ' ':
                case '<': case '>': case '#': case '%': case '\"':
                case '{': case '}': case '|':
                case '^': case '[': case ']': case '`':
                        return TRUE;
                default:
                {
                        if (ch < 32 || ch > 126)
                                return TRUE;
                        return FALSE;
                }
        }
}

//===========================================================================
//
// Get RAW headers in a parse -- a more efficient way of getting multiple headers back
// return value:
//    -1: indicate failuer
//    0: or positive -- # of headers found
//  input: headers, names, namescount
//  output: values -- value of the corresponding header, dwSizes -- size of the value;
//
int GetRawHeaders(LPCSTR headers, LPCSTR* names, LPCSTR* values, DWORD* dwSizes, DWORD namescount)
{
   if (!headers || !names || !values || !dwSizes)  return -1;
   if (IsBadReadPtr(names, namescount * sizeof(LPCSTR)) 
      || IsBadWritePtr(values, namescount * sizeof(LPCSTR*))
      || IsBadWritePtr(dwSizes, namescount * sizeof(DWORD*))
      )  return -1;

   int   c = 0;
   int   i = 0;
   // init output params
   
   // loop through headers
   LPCSTR header = headers;
   LPCSTR T;
   DWORD  l;
   ZeroMemory(values, sizeof(LPCSTR*) * namescount);
   ZeroMemory(dwSizes, sizeof(DWORD*) * namescount);

   do
   {
      // white spaces
      while(*header == ' ') ++header;
      
      // find if the header is intersted
      T = strchr(header, ':');

      i = namescount;
      if(T && T != header)
      {
         l = T - header;   // size of the header name string
         TempSubStr  ss(header, l);
         ++T;
         
         while( --i >= 0)
         {
            if(strcmp(*(names + i), header) == 0)
            {
               // white spaces
               while(*T == ' ') ++T;
      
               *(values + i) = T;
               ++c;
               
               break;
            }
         }

         // move forward
         header = T;
      }
      
      // not found
      while(*header != 0 && !(*header == 0xd && *(header + 1)==0xa)) ++header;

      // fillin the size of the header value
      if (i >= 0 && i < (int)namescount)
         *(dwSizes + i) = header - T;

      // move to next header
      if(*header == 0) header = 0;
      else
         header += 2;   // skip 0x0D0A

   } while(header);

   return c;
}


//===========================================================================
//
// get QueryString from HTTP request_line
//

LPCSTR GetRawQueryString(LPCSTR request_line, DWORD* dwSize)
{
   if (!request_line)  return NULL;
   LPCSTR URI = strchr(request_line, ' ');

   if (!URI)   return NULL;

   LPCSTR QS = strchr(URI + 1, '?');

   if (!QS) return NULL;
   ++QS;

   // make sure if not part of someother header
   LPCSTR end = strchr(QS,' ');

   DWORD size  = 0;
   if (!end)
      size = strlen(QS);
   else
      size = end - QS;

   if (size == 0)
      return NULL;

   if (dwSize)
      *dwSize = size;
         
   return QS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\passportcrypt.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    PassportCrypt.h
        defines the crypt object in passport manager

    FILE HISTORY:

*/
// PassportCrypt.h : Declaration of the CCrypt

#ifndef __CRYPT_H_
#define __CRYPT_H_

#include "resource.h"       // main symbols
#include "CoCrypt.h"	// Added by ClassView
#include "passportservice.h"

/////////////////////////////////////////////////////////////////////////////
// CCrypt
class ATL_NO_VTABLE CCrypt : 
  public CComObjectRootEx<CComMultiThreadModel>,
  public CComCoClass<CCrypt, &CLSID_Crypt>,
  public ISupportErrorInfo,
  public IPassportService,
  public IDispatchImpl<IPassportCrypt, &IID_IPassportCrypt, &LIBID_PASSPORTLib>
{
public:
  CCrypt();
  ~CCrypt()
  {
    Cleanup();

    if( m_crypt )
      delete m_crypt;
  }

public:
  
DECLARE_REGISTRY_RESOURCEID(IDR_CRYPT)
    
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CCrypt)
  COM_INTERFACE_ENTRY(IPassportCrypt)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY(ISupportErrorInfo)
  COM_INTERFACE_ENTRY(IPassportService)
  COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

HRESULT FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(
        GetControllingUnknown(), &m_pUnkMarshaler.p);
}

void FinalRelease()
{
    m_pUnkMarshaler.Release();
}

CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportCrypt
public:
  STDMETHOD(put_keyMaterial)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_keyVersion)(/*[out, retval]*/ int *pVal);
  STDMETHOD(put_keyVersion)(/*[in]*/ int newVal);

  STDMETHOD(OnStartPage)(/*[in]*/ IUnknown* piUnk);
  STDMETHOD(Decrypt)(/*[in]*/ BSTR rawData, /*[out,retval]*/ BSTR *pUnencrypted);
  STDMETHOD(Encrypt)(/*[in]*/ BSTR rawData, /*[out,retval]*/ BSTR *pEncrypted);
  STDMETHOD(get_IsValid)(/*[out,retval]*/VARIANT_BOOL *pVal);
  STDMETHOD(Compress)(/*[in]*/ BSTR bstrIn, /*[out,retval]*/ BSTR *pbstrOut);
  STDMETHOD(Decompress)(/*[in]*/ BSTR bstrIn, /*[out,retval]*/ BSTR *pbstrOut);
  STDMETHOD(put_site)(/*[in]*/ BSTR bstrSiteName);
  STDMETHOD(put_host)(/*[in]*/ BSTR bstrHostName);
  
// IPassportService
public:
	STDMETHOD(Initialize)(BSTR, IServiceProvider*);
	STDMETHOD(Shutdown)();
	STDMETHOD(ReloadState)(IServiceProvider*);
	STDMETHOD(CommitState)(IServiceProvider*);
	STDMETHOD(DumpState)( BSTR* );

protected:
  void              Cleanup();
  CRegistryConfig*  ObtainCRC();

  int       m_keyVersion;
  time_t    m_validUntil;
  CCoCrypt* m_crypt;
  LPSTR     m_szSiteName;
  LPSTR     m_szHostName;
};

#endif //__CRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\passportconfiguration.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    PassportConfiguration.h
        handles both nexus config and registry config


    FILE HISTORY:

*/
// PassportConfiguration.h: interface for the CPassportConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PASSPORTCONFIGURATION_H__74EB2517_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
#define AFX_PASSPORTCONFIGURATION_H__74EB2517_E239_11D2_95E9_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <map>
#include "nexus.h"
#include "RegistryConfig.h"
#include "NexusConfig.h"
#include "PassportLock.hpp"

#define PRCONFIG "PARTNER"

typedef PtStlMap<LPSTR, CRegistryConfig*> REGCONFIGMAP;

bool less<LPSTR>::operator()(const LPSTR& x, const LPSTR& y) const
{
    return (_strcmpi(x,y) < 0);
};

class CPassportConfiguration :
public ICCDUpdate, public IConfigurationUpdate
{
public:
  CPassportConfiguration();
  virtual ~CPassportConfiguration();

  // You must call release yourself...
  CRegistryConfig* checkoutRegistryConfig(LPSTR szHost = NULL);
  CRegistryConfig* checkoutRegistryConfigBySite(LPSTR szSiteName);
  CNexusConfig*    checkoutNexusConfig();

  BOOL   isValid();
  LPWSTR getFailureString();
  
  void CCDUpdatedA(LPCSTR pszCCDName, IXMLDocument* piStream)
    { NexusConfigUpdated(piStream); }

  void CCDUpdatedW(LPCWSTR pszCCDName, IXMLDocument* piStream)
    { NexusConfigUpdated(piStream); }

  void LocalConfigurationUpdated();

  BOOL UpdateNow(BOOL forceFetch = TRUE);

  // two phase update
  BOOL PrepareUpdate(BOOL forceFetch = TRUE);
  BOOL CommitUpdate(void);

  void Dump(BSTR* pbstrDump);

  BOOL HasSites(void);

 protected:
  void NexusConfigUpdated(IXMLDocument *pi);

  BOOL TakeRegistrySnapshot(CRegistryConfig** ppRegConfig,
                            REGCONFIGMAP** ppConfigMap);
  BOOL ApplyRegistrySnapshot(CRegistryConfig* pRegConfig,
                             REGCONFIGMAP* pConfigMap);

  BOOL TakeNexusSnapshot(CNexusConfig** ppNexusConfig, BOOL bForceFetch);
  BOOL ApplyNexusSnapshot(CNexusConfig* pNexusConfig);

  void getReadLock(PassportLock &l) { l.acquire(); }
  void releaseReadLock(PassportLock &l) { l.release(); }
  void getWriteLock(PassportLock &l) { l.acquire(); }
  void releaseWriteLock(PassportLock &l) { l.release(); }
  BOOL IsIPAddress(LPSTR szSiteName);

  REGCONFIGMAP        *m_ConfigMap, *m_lastConfigMap, *m_ConfigMapPending;
  CRegistryConfig     *m_rDefault, *m_rlastDefault, *m_rPending;
  CNexusConfig        *m_n, *m_nlast, *m_nPending;
  PassportLock        m_lock;
  HANDLE              m_nUpdate, m_rUpdate;
  time_t              m_lastAttempt;
  bool                m_bUpdateInProgress;
};

#endif // !defined(AFX_PASSPORTCONFIGURATION_H__74EB2517_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\passportconfiguration.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    PassportConfiguration.cpp


    FILE HISTORY:

*/


// PassportConfiguration.cpp: implementation of the CPassportConfiguration class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PassportConfiguration.h"
#include <time.h>
#include "passportguard.hpp"

extern BOOL g_bRegistering;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//===========================================================================
//
// CPassportConfiguration 
//
CPassportConfiguration::CPassportConfiguration() :
  m_rDefault(NULL), m_n(NULL), 
  m_rlastDefault(NULL), m_nlast(NULL), m_lastAttempt(0),
  m_ConfigMap(NULL), m_lastConfigMap(NULL),
  m_rPending(NULL), m_nPending(NULL), m_bUpdateInProgress(false),
  m_ConfigMapPending(NULL)
{
  m_nUpdate = RegisterCCDUpdateNotification(_T(PRCONFIG), this);
  m_rUpdate = RegisterConfigChangeNotification(this);
}

//===========================================================================
//
// ~CPassportConfiguration 
//
CPassportConfiguration::~CPassportConfiguration()
{
    REGCONFIGMAP::iterator it;

    if (m_nUpdate)
        UnregisterCCDUpdateNotification(m_nUpdate);
    if (m_rUpdate)
        UnregisterConfigChangeNotification(m_rUpdate);

    //
    //  Empty out config maps.
    //

    {
        PassportGuard<PassportLock> g(m_lock);

        if(m_ConfigMap)
        {
            while((it = m_ConfigMap->begin()) != m_ConfigMap->end())
            {
                it->second->Release();
                free(it->first);
                m_ConfigMap->erase(it);
            }

            delete m_ConfigMap;
            m_ConfigMap = NULL;
        }

        if(m_lastConfigMap)
        {
            while((it = m_lastConfigMap->begin()) != m_lastConfigMap->end())
            {
                it->second->Release();
                free(it->first);
                m_lastConfigMap->erase(it);
            }

            delete m_lastConfigMap;
            m_lastConfigMap = NULL;
        }
        if(m_ConfigMapPending)
        {
            while((it = m_ConfigMapPending->begin()) != m_ConfigMapPending->end())
            {
                it->second->Release();
                free(it->first);
                m_ConfigMapPending->erase(it);
            }

            delete m_ConfigMapPending;
            m_ConfigMapPending = NULL;
        }

        if (m_rDefault)
        {
            m_rDefault->Release();
            m_rDefault = NULL;
        }
        if (m_n)
        {
            m_n->Release();
            m_n = NULL;
        }
        if (m_rlastDefault)
        {
            m_rlastDefault->Release();
            m_rlastDefault = NULL;
        }
        if (m_nlast)
        {
            m_nlast->Release();
            m_nlast = NULL;
        }
        if (m_rPending)
        {
            m_rPending->Release();
            m_rPending = NULL;
        }
        if (m_nPending)
        {
            m_nPending->Release();
            m_nPending = NULL;
        }
    }
}

//===========================================================================
//
// IsIPAddress 
//
BOOL
CPassportConfiguration::IsIPAddress(
    LPSTR  szSiteName
    )
{
    for(LPSTR sz = szSiteName; *sz; sz++)
        if(!_istdigit(*sz) && *sz != '.' && *sz != ':')
            return FALSE;

    return TRUE;
}

//===========================================================================
//
// checkoutRegistryConfig 
//
CRegistryConfig* CPassportConfiguration::checkoutRegistryConfig(
    LPSTR szHost    //  Can be host name or IP
    )
{
    CRegistryConfig*        c = NULL;
    REGCONFIGMAP::iterator  it;
    PassportGuard<PassportLock> g(m_lock);

    if(m_ConfigMap != NULL && szHost && szHost[0])
    {
        if(IsIPAddress(szHost))
        {
            for(it = m_ConfigMap->begin(); it != m_ConfigMap->end(); it++)
            {
                if(lstrcmpA(szHost, it->second->getHostIP()) == 0)
                {
                    c = it->second->AddRef();
                    break;
                }
            }
        }
        else
        {
            it = m_ConfigMap->find(szHost);
            if(it != m_ConfigMap->end())
                c = it->second->AddRef();
        }
    }

    if (c == NULL)
    {
        if(!m_rDefault)
        {
            UpdateNow();
            c = m_rDefault ? m_rDefault->AddRef() : NULL;
        }
        else
            c = m_rDefault->AddRef();
    }

    return c;
}

//===========================================================================
//
// checkoutRegistryConfigBySite 
//
CRegistryConfig* CPassportConfiguration::checkoutRegistryConfigBySite(
    LPSTR   szSiteName
    )
{
    CRegistryConfig*    crc = NULL;
    CHAR                achHostName[2048];
    DWORD               dwHostNameBufLen;

    if(szSiteName && szSiteName[0])
    {
        dwHostNameBufLen = sizeof(achHostName);
        if(CRegistryConfig::GetHostName(szSiteName, achHostName, &dwHostNameBufLen) != ERROR_SUCCESS)
            goto Cleanup;

        crc = checkoutRegistryConfig(achHostName);
    }
    else
    {
        crc = checkoutRegistryConfig();
    }

Cleanup:

    return crc;
}


//===========================================================================
//
// checkoutNexusConfig 
//
CNexusConfig* CPassportConfiguration::checkoutNexusConfig()
{
    if (!m_n)
    {
        PassportGuard<PassportLock> g(m_lock);

        if (!m_n)  // In case it happened while we were waiting
            UpdateNow();

        return m_n ? m_n->AddRef() : NULL;
    }
    CNexusConfig *c = m_n->AddRef();
    return c;
}

//===========================================================================
//
// isValid 
//
BOOL CPassportConfiguration::isValid()
{
    if (m_rDefault != NULL && m_n != NULL)
        return m_rDefault->isValid() && m_n->isValid();
    else
    {
        PassportGuard<PassportLock> g(m_lock);

        if (m_rDefault == NULL || m_n == NULL)  // In case it happened while we were waiting
        {
            BOOL retVal = UpdateNow(FALSE);
            return retVal;
        }
    }
    return (m_rDefault && m_rDefault->isValid()) && (m_n && m_n->isValid());
}

//===========================================================================
//
// TakeRegistrySnapshot 
//
BOOL CPassportConfiguration::TakeRegistrySnapshot(
    CRegistryConfig**   ppRegConfig,
    REGCONFIGMAP**      ppConfigMap
    )
{
    HKEY                    hkSites = 0;
    BOOL                    bReturn;

    *ppRegConfig = NULL;
    *ppConfigMap = NULL;

    // Registry
    CRegistryConfig* pNewRegConfig = new CRegistryConfig();
    if(!pNewRegConfig)
    {
        bReturn = FALSE;
        goto Cleanup;
    }
    pNewRegConfig->AddRef();

    //
    //  Read in all other site configs.  Only if we find a sites reg key with
    //  one or more subkeys.
    //

    REGCONFIGMAP* pNewRegMap = NULL;

    {
        LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    TEXT("Software\\Microsoft\\Passport\\Sites"),
                                    0,
                                    KEY_READ,
                                    &hkSites);

        if(lResult == ERROR_SUCCESS)
        {
            DWORD dwNumSites;
            lResult = RegQueryInfoKey(hkSites, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      &dwNumSites, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL, 
                                      NULL);
            if(lResult == ERROR_SUCCESS && dwNumSites)
            {
                // need to wrap this because it uses STL and the STL constructors don't
                // check memory allocations and can AV in low memory conditions
                try
                {
                    pNewRegMap = new REGCONFIGMAP();
                }
                catch(...)
                {
                    bReturn = FALSE;
                    goto Cleanup;
                }

                if(pNewRegMap)
                {
                    DWORD   dwKeyIndex = 0;
                    CHAR    achSiteName[256];
                    DWORD   dwSiteNameLen = sizeof(achSiteName);
                    while(RegEnumKeyExA(hkSites, 
                                        dwKeyIndex++, 
                                        achSiteName, 
                                        &dwSiteNameLen,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL) == ERROR_SUCCESS)
                    {
                        CRegistryConfig* crSite = new CRegistryConfig(achSiteName);
                        if(crSite)
                        {
                            crSite->AddRef();
                            if (crSite->isValid())
                            {
                                REGCONFIGMAP::value_type* v = 
                                    new REGCONFIGMAP::value_type(_strdup(crSite->getHostName()), 
                                                                 crSite);
                                if(v)
                                {
                                    try
                                    {
                                        pNewRegMap->insert(*v);
                                    }
                                    catch(...)
                                    {
                                        delete v;
                                        crSite->Release();
                                        bReturn = FALSE;
                                        goto Cleanup;
                                    }
                                    delete v;
                                }
                                else
                                    crSite->Release();
                            }
                            else
                            {
                                if (g_pAlert)
                                    g_pAlert->report(PassportAlertInterface::ERROR_TYPE, 
                                                     PM_INVALID_CONFIGURATION,
                                crSite->getFailureString());
                                crSite->Release();
                            }
                        }

                        dwSiteNameLen = sizeof(achSiteName);
                    }
                }
            }
            else
            {
                pNewRegMap = NULL;
            }

            RegCloseKey(hkSites);
            hkSites = 0;
        }
        else
        {
            pNewRegMap = NULL;
        }
    }

    // Assign out parameters and return value.
    *ppRegConfig = pNewRegConfig;
    pNewRegConfig = NULL;
    *ppConfigMap = pNewRegMap;
    pNewRegMap = NULL;

    bReturn = TRUE;

Cleanup:
    if (0 != hkSites)
    {
        RegCloseKey(hkSites);
    }
    if (NULL != pNewRegConfig)
    {
        delete pNewRegConfig;
    }
    if (NULL != pNewRegMap)
    {
        try
        {
            delete pNewRegMap;
        }
        catch(...)
        {
        }
    }

    return bReturn;
}


//===========================================================================
//
// ApplyRegistrySnapshot 
//
BOOL CPassportConfiguration::ApplyRegistrySnapshot(
    CRegistryConfig* pRegConfig,
    REGCONFIGMAP* pConfigMap
    )
{
    //
    // Record the registration state now in case it changes midstream.  This
    // can happen during setup when we're called on a separate thread via
    // msppnxus!PpNotificationThread::run, which executes while msppmgr.dll
    // is still setting up the Passport registry values.
    //

    BOOL fRegistering = g_bRegistering;

    if (pRegConfig->isValid())
    {
        REGCONFIGMAP* temp = m_lastConfigMap;

        {
            PassportGuard<PassportLock> g(m_lock);

            if (m_rlastDefault)
                m_rlastDefault->Release();
            m_rlastDefault = m_rDefault;
            m_rDefault = pRegConfig;

            //
            //  Shuffle config map pointers.
            //

            m_lastConfigMap = m_ConfigMap;
            m_ConfigMap = pConfigMap;
        }

        //
        //  Delete the old site map.
        //

        if(temp)
        {
            REGCONFIGMAP::iterator it;
            while((it = temp->begin()) != temp->end())
            {
                free(it->first);
                it->second->Release();
                temp->erase(it);
            }

            delete temp;
        }

        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_VALID_CONFIGURATION);
    }
    else
    {
        if (g_pAlert && !fRegistering)
        {
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             PM_INVALID_CONFIGURATION,
                             pRegConfig->getFailureString());
        }

        pRegConfig->Release();

        if(pConfigMap)
        {
            REGCONFIGMAP::iterator it;
            while((it = pConfigMap->begin()) != pConfigMap->end())
            {
                free(it->first);
                it->second->Release();
                pConfigMap->erase(it);
            }

            delete pConfigMap;
        }
    }

    return TRUE;
}


//===========================================================================
//
// TakeNexusSnapshot 
//
BOOL CPassportConfiguration::TakeNexusSnapshot(
    CNexusConfig**  ppNexusConfig,
    BOOL            bForceFetch
    )
{
    BOOL                    bReturn;
    CNexusConfig*           pNexusConfig = NULL;
    CComPtr<IXMLDocument>   pXMLDoc;

    *ppNexusConfig = NULL;

    if (GetCCD(_T(PRCONFIG),&pXMLDoc, bForceFetch))
    {
        pNexusConfig = new CNexusConfig();
        if(!pNexusConfig)
        {
            bReturn = FALSE;
            goto Cleanup;
        }

        if (!pNexusConfig->Read(pXMLDoc))
        {
            bReturn = FALSE;
            goto Cleanup;
        }
        pNexusConfig->AddRef();
    }
    else
    {
        if (g_pAlert)
        {
            if (g_pAlert)
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CCD_NOT_LOADED, 0);
        }
        m_lastAttempt = time(NULL);
        bReturn = FALSE;
        goto Cleanup;
    }

    *ppNexusConfig = pNexusConfig;
    bReturn = TRUE;

Cleanup:

    if(pNexusConfig && bReturn == FALSE)
        delete pNexusConfig;

    return bReturn;

}


//===========================================================================
//
// ApplyNexusSnapshot 
//
BOOL CPassportConfiguration::ApplyNexusSnapshot(
    CNexusConfig*   pNexusConfig
    )
{
    BOOL bReturn;

    if (pNexusConfig->isValid())
    {
        PassportGuard<PassportLock> g(m_lock);

        if (m_nlast)
            m_nlast->Release();
        m_nlast = m_n;
        m_n = pNexusConfig;
        if (g_pAlert)
            g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE, PM_CCD_LOADED);
    }
    else
    {
        // NexusConfig throws an alert already
        if (pNexusConfig)
        {
            pNexusConfig->Release();
        }
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    return bReturn;
}


//===========================================================================
//
// UpdateNow 
//
// Update both configs
BOOL CPassportConfiguration::UpdateNow(BOOL forceFetch)
{
    BOOL                    bReturn;
    time_t                  now;
    CComPtr<IXMLDocument>   is;
    time(&now);

    if(m_bUpdateInProgress)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if (now - m_lastAttempt < 60 && m_n == NULL)
    {
        // Don't overload on attempts to the nexus
        bReturn = FALSE;
        goto Cleanup;
    }

    // Registry
    LocalConfigurationUpdated();
    if (m_rDefault == NULL)
    {
        m_lastAttempt = now - 30;
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    // If we are registering msppmgr.dll then we don't want to try and fetch the CCD
    // since the registration occurs during setup and at that time the network isn't
    // available.  If this does occur then msppmgr.dll hangs and setup breaks in with
    // registration time out.
    //
    if (!g_bRegistering)
    {
        if (GetCCD(_T(PRCONFIG),&is, forceFetch))
        {
            try
            {
                NexusConfigUpdated(is);
            }
            catch(...)
            {
                if (g_pAlert)
                {
                    if (g_pAlert)
                        g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CCD_NOT_LOADED, 0);
                }
                bReturn = FALSE;
                goto Cleanup;
            }
        }
        else
        {
            if (g_pAlert)
            {
                if (g_pAlert)
                    g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CCD_NOT_LOADED, 0);
            }
            m_lastAttempt = now;
            bReturn = FALSE;
            goto Cleanup;
        }
    }

    if (!m_n)
    {
        m_lastAttempt = now;
        bReturn = FALSE;
        goto Cleanup;
    }
    m_lastAttempt = 0;
    bReturn = TRUE;

Cleanup:

    return bReturn;
}

//===========================================================================
//
// PrepareUpdate 
//
BOOL CPassportConfiguration::PrepareUpdate(BOOL forceFetch)
{
    BOOL                    bReturn;

    static PassportLock prepareLock;
    PassportGuard<PassportLock> g(prepareLock);

    //  Don't allow another first phase while second phase
    //  is pending.
    //if(m_bUpdateInProgress)
    //{
    //    bReturn = FALSE;
    //    goto Cleanup;
    //}

    // The PrepareUpdate is called by the Refresh method in msppext.dll where
    // a lock value is maintained to prevent calling first phase PrepareUpdate
    // while second phase CommitUpdate is pending.  If for some reason the Refresh
    // aborts after calling PrepareUpdate and before calling CommintUpdate,
    // m_bUpdateInProgress will remain true preventing future Refresh.  Since no first
    // first phase PrepareUpdate can be called while second phase CommitUpdate is pending,
    // m_bUpdateInProgress can be set to false safely

    //if(m_bUpdateInProgress)
    {
        if(m_ConfigMapPending)
        {
            REGCONFIGMAP::iterator it;
            while((it = m_ConfigMapPending->begin()) != m_ConfigMapPending->end())
            {
                it->second->Release();
                free(it->first);
                m_ConfigMapPending->erase(it);
            }

            delete m_ConfigMapPending;
            m_ConfigMapPending = NULL;
        }

        if (m_rPending)
        {
            m_rPending->Release();
            m_rPending = NULL;
        }
        if (m_nPending)
        {
            m_nPending->Release();
            m_nPending = NULL;
        }
        m_bUpdateInProgress = false;
    }

    //  Get the current registry config.
    if (!TakeRegistrySnapshot(&m_rPending, &m_ConfigMapPending))
        return FALSE;

    //  Get the latest xml
    if (!TakeNexusSnapshot(&m_nPending, forceFetch))
        return FALSE;

    m_bUpdateInProgress = true;
    bReturn = TRUE;

    return bReturn;
}

//===========================================================================
//
// CommitUpdate 
//
BOOL CPassportConfiguration::CommitUpdate()
{
    BOOL bReturn;

    // Update default registry and any sites
    if(!ApplyRegistrySnapshot(m_rPending, m_ConfigMapPending))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(!ApplyNexusSnapshot(m_nPending))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    m_rPending = NULL;
    m_ConfigMapPending = NULL;
    m_nPending = NULL;

    bReturn = TRUE;

Cleanup:

    m_bUpdateInProgress = false;

    return bReturn;    
}

//===========================================================================
//
// LocalConfigurationUpdated 
//
void CPassportConfiguration::LocalConfigurationUpdated()
{
    //
    //  Read in default config.
    //

    CRegistryConfig* pNewRegConfig;
    REGCONFIGMAP* pNewConfigMap;

    if(!TakeRegistrySnapshot(&pNewRegConfig, &pNewConfigMap))
        return;

    //
    //  Here we don't care about the results of reading in non-default sites.  pNewConfigMap will be NULL
    //  if anything bad happened and events will be in the event log.  As long as we have a valid 
    //  default configuration we can go ahead and do the switch.
    //

    ApplyRegistrySnapshot(pNewRegConfig, pNewConfigMap);

}

//===========================================================================
//
// NexusConfigUpdated 
//
void CPassportConfiguration::NexusConfigUpdated(IXMLDocument *is)
{
    CNexusConfig *newc = new CNexusConfig();

    if (newc)
    {
        if (newc->Read(is))
        {
            newc->AddRef();

            ApplyNexusSnapshot(newc);
        }
        else
        {
            delete newc;
        }
    }
}

//===========================================================================
//
// getFailureString 
//
LPWSTR CPassportConfiguration::getFailureString()
{
  // IsValid must be called before this
  if (!m_rDefault)
    return L"Registry configuration failed.";
  if (!m_rDefault->isValid())
    return m_rDefault->getFailureString();
  if (!m_n)
    return L"Nexus configuration failed.";
  if (!m_n->isValid())
    return m_n->getFailureString();
  return L"OK";
}

//===========================================================================
//
// HasSites 
//
BOOL
CPassportConfiguration::HasSites()
{
    return (m_ConfigMap && m_ConfigMap->size());
}

//===========================================================================
//
// Dump 
//
void
CPassportConfiguration::Dump(BSTR* pbstrDump)
{
    //m_rDefault->Dump(pbstrDump);
    //m_ConfigMap->Dump(pbstrDump);
    m_n->Dump(pbstrDump);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\passportcrypt.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    PassportCrypt.cpp


    FILE HISTORY:

*/


// PassportCrypt.cpp : Implementation of CCrypt
#include "stdafx.h"
#include "Passport.h"
#include "PassportCrypt.h"
#include <time.h>

/* moved into passport.idl -- so consumer of the COM API can see it
// max blocks + 10 should be multiples of 3 for simplicity
#define ENC_MAX_SIZE  2045
// I don't trust the compiler... (((2045+10)*4)/3)+9 = 2749 * sizeof(wchar)
#define DEC_MAX_SIZE  5498
*/

//===========================================================================
//
// CCrypt 
//
CCrypt::CCrypt() : m_crypt(NULL), m_szSiteName(NULL), m_szHostName(NULL)
{
    m_pUnkMarshaler = NULL;
    m_keyVersion = 0;

    CRegistryConfig* crc = g_config->checkoutRegistryConfig();
    if( crc )
    {
        m_keyVersion = crc->getCurrentCryptVersion();
        crc->getCrypt(m_keyVersion, &m_validUntil);
        crc->Release();
    }
}


/////////////////////////////////////////////////////////////////////////////
// CCrypt

//===========================================================================
//
// InterfaceSupportsErrorInfo 
//
STDMETHODIMP CCrypt::InterfaceSupportsErrorInfo(REFIID riid)
{
  static const IID* arr[] = 
  {
    &IID_IPassportCrypt,
  };
  for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
      if (InlineIsEqualGUID(*arr[i],riid))
	return S_OK;
    }
  return S_FALSE;
}


//===========================================================================
//
// OnStartPage 
//
STDMETHODIMP CCrypt::OnStartPage(IUnknown* piUnk) 
{
    BOOL                    bHasPort;
    DWORD                   dwServerNameLen;
    HRESULT                 hr = S_OK;
    BOOL                    bVariantInited = FALSE;

    // param needs to cleanup
    IRequestPtr             piRequest ;
    IRequestDictionaryPtr   piServerVariables ;
    _variant_t              vtItemName;
    _variant_t              vtServerName;
    _variant_t              vtServerPort;
    _variant_t              vtHTTPS;
//    WCHAR                   szServerName = NULL; 
//    CHAR*                   szServerName_A = NULL; 
    CRegistryConfig*        crc =  NULL;


    if(!piUnk)
    {
        hr = E_POINTER;
        goto exit;
    }

    if (!g_config->isValid()) // Guarantees config is non-null
    {
        AtlReportError(CLSID_Manager, PP_E_NOT_CONFIGUREDSTR,
                       IID_IPassportManager, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
    }

    try
    {

        // Get Request Object Pointer
        piRequest = ((IScriptingContextPtr)piUnk)->Request;

        //
        //  Use the request object to get the server name being requested
        //  so we can get the correct registry config.  But only do this
        //  if we have some configured sites.
        //

        if(g_config->HasSites())
        {
            piRequest->get_ServerVariables(&piServerVariables);

            vtItemName.vt = VT_BSTR;
            vtItemName.bstrVal = SysAllocString(L"SERVER_NAME");
            if (NULL == vtItemName.bstrVal)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            piServerVariables->get_Item(vtItemName, &vtServerName);
            if(vtServerName.vt != VT_BSTR)
                VariantChangeType(&vtServerName, &vtServerName, 0, VT_BSTR);

            VariantClear(&vtItemName);

            vtItemName.vt = VT_BSTR;
            vtItemName.bstrVal = SysAllocString(L"SERVER_PORT");
            if (NULL == vtItemName.bstrVal)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            piServerVariables->get_Item(vtItemName, &vtServerPort);
            if(vtServerPort.vt != VT_BSTR)
                VariantChangeType(&vtServerPort, &vtServerPort, 0, VT_BSTR);

            VariantClear(&vtItemName);
            vtItemName.vt = VT_BSTR;
            vtItemName.bstrVal = SysAllocString(L"HTTPS");
            if (NULL == vtItemName.bstrVal)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            hr = piServerVariables->get_Item(vtItemName, &vtHTTPS);
            if(vtHTTPS.vt != VT_BSTR)
                VariantChangeType(&vtHTTPS, &vtHTTPS, 0, VT_BSTR);

            //  If not default port, append ":port" to server name.
            bHasPort = (lstrcmpiW(L"off", vtHTTPS.bstrVal) == 0 && 
                        lstrcmpW(L"80", vtServerPort.bstrVal) != 0) || 
                        (lstrcmpiW(L"on", vtHTTPS.bstrVal) == 0 && 
                        lstrcmpW(L"443", vtServerPort.bstrVal) != 0); 
            dwServerNameLen = bHasPort ?   
                        lstrlenW(vtServerName.bstrVal) + lstrlenW(vtServerPort.bstrVal) + 2 :
                        lstrlenW(vtServerName.bstrVal) + 1;

            m_szHostName = new CHAR[dwServerNameLen];
            if( !m_szHostName )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            WideCharToMultiByte(CP_ACP, 0, vtServerName.bstrVal, -1,
                    m_szHostName, dwServerNameLen,
                    NULL,
                    NULL);

            if(bHasPort)
            {
                USES_CONVERSION;
                lstrcatA(m_szHostName, ":");
                lstrcatA(m_szHostName, W2A(vtServerPort.bstrVal));
            }

            crc = g_config->checkoutRegistryConfig(m_szHostName);
        }
        else
        {
            crc = g_config->checkoutRegistryConfig();
        }

        m_keyVersion = 0;
        if (crc)
        {
            m_keyVersion = crc->getCurrentCryptVersion();
            crc->getCrypt(m_keyVersion,&m_validUntil);
        }
    }
    catch(...)
    {
        hr = S_OK;
    }

exit:

    if( crc )
        crc->Release();

    return hr;
}

//===========================================================================
//
// Encrypt 
//
STDMETHODIMP CCrypt::Encrypt(BSTR rawData, BSTR *pEncrypted)
{
    if (!rawData)
        return E_INVALIDARG;

    if (SysStringLen(rawData) > ENC_MAX_SIZE)
    {
        AtlReportError(CLSID_Crypt, L"Passport.Crypt: Data too large", 
                       IID_IPassportCrypt, E_FAIL);
        return E_FAIL;
    }

    if (m_crypt)
    {
        if (!m_crypt->Encrypt(m_keyVersion, (LPSTR)rawData, SysStringByteLen(rawData), pEncrypted))
        {
            AtlReportError(CLSID_Crypt, 
                           L"Encryption failed", IID_IPassportCrypt, E_FAIL);
            return E_FAIL;
        }
    }
    else
    {
        CRegistryConfig* crc = ObtainCRC();
        if (!crc)
        {
            AtlReportError(CLSID_Crypt, 
                           L"Passport misconfigured", IID_IPassportCrypt, E_FAIL);
            return E_FAIL;
        }
        CCoCrypt *cr = crc->getCrypt(m_keyVersion,&m_validUntil);
        if (!cr)
        {
            AtlReportError(CLSID_Crypt, 
                           L"No such key version", IID_IPassportCrypt, E_FAIL);
            crc->Release();
            return E_FAIL;
        }
        if (!cr->Encrypt(m_keyVersion,(LPSTR)rawData,SysStringByteLen(rawData),pEncrypted))
        {
             AtlReportError(CLSID_Crypt, 
                            L"Encryption failed", IID_IPassportCrypt, E_FAIL);
             crc->Release();
             return E_FAIL;
        }
        crc->Release();
    }
    return S_OK;
}

//===========================================================================
//
// Decrypt
//
STDMETHODIMP CCrypt::Decrypt(BSTR rawData, BSTR *pUnencrypted)
{
    if (rawData == NULL)
    {
      *pUnencrypted = NULL;
      return S_OK;
    }

    if (SysStringLen(rawData) > DEC_MAX_SIZE)
    {
      AtlReportError(CLSID_Crypt, L"Passport.Crypt: Data too large",
             IID_IPassportCrypt, E_FAIL);
      return E_FAIL;
    }

    if (m_crypt) // Just do our job, no questions
    {
        if (m_crypt->Decrypt(rawData, SysStringByteLen(rawData), pUnencrypted))
        {
            return S_OK;
        }

        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_FAILED_DECRYPT);

        *pUnencrypted = NULL;
        return S_OK;
    }

    // First find the key version
    int kv = CCoCrypt::getKeyVersion(rawData);
    time_t vU, now;

    CRegistryConfig* crc = ObtainCRC();
    if (!crc)
    {
        AtlReportError(CLSID_Crypt,
               L"Passport misconfigured", IID_IPassportCrypt, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }
    CCoCrypt *cr = crc->getCrypt(kv, &vU);

    time(&now);

    if ((vU != 0 && now > vU) || cr == NULL)
    {
        *pUnencrypted = NULL;
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_FAILED_DECRYPT);
        crc->Release();
        return S_OK;
    }

    if (cr->Decrypt(rawData, SysStringByteLen(rawData), pUnencrypted))
    {
      crc->Release();
      return S_OK;
    }
  
    if(g_pAlert)
        g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_FAILED_DECRYPT);
  
    crc->Release();
    *pUnencrypted = NULL;
    return S_OK;
}

//===========================================================================
//
// get_keyVersion 
//
STDMETHODIMP CCrypt::get_keyVersion(int *pVal)
{
  *pVal = m_keyVersion;
  return S_OK;
}

//===========================================================================
//
// put_keyVersion 
//
STDMETHODIMP CCrypt::put_keyVersion(int newVal)
{
  m_keyVersion = newVal;
  if (m_crypt)
    {
      delete m_crypt;
      m_crypt = NULL;
    }
  return S_OK;
}

//===========================================================================
//
// vget_IsValid 
//
STDMETHODIMP CCrypt::get_IsValid(VARIANT_BOOL *pVal)
{
// fix 6695	PassportCrypt.IsValid is inconsistent to end users.
// *pVal = (m_crypt != NULL) ? VARIANT_TRUE : VARIANT_FALSE;

  *pVal = (g_config->isValid()) ? VARIANT_TRUE : VARIANT_FALSE;
  return S_OK;
}

//===========================================================================
//
// put_keyMaterial 
//
STDMETHODIMP CCrypt::put_keyMaterial(BSTR newVal)
{
    CCoCrypt *pcccTemp = new CCoCrypt();

    if (pcccTemp == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (m_crypt)
    {
        delete m_crypt;
    }

    m_crypt = pcccTemp;

    m_crypt->setKeyMaterial(newVal);
    return S_OK;
}


//===========================================================================
//
// Compress 
//
STDMETHODIMP CCrypt::Compress(
    BSTR    bstrIn,
    BSTR*   pbstrCompressed
    )
{
    HRESULT hr;
    UINT    nInLen;

    //
    //  Check inputs.
    //

    if(bstrIn == NULL ||
       pbstrCompressed == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    //  nInLen does not include the terminating NULL.
    //

    nInLen = SysStringLen(bstrIn);

    //
    //  Always want to allocate an even number of bytes
    //  so that the corresponding decompress does not
    //  lose characters.
    //

    if(nInLen & 0x1)
        nInLen++;

    //
    //  Allocate a BSTR of the correct length.
    //

    *pbstrCompressed = SysAllocStringByteLen(NULL, nInLen);
    if(*pbstrCompressed == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  We allocated a total of nInLen + 2 bytes.  Zero it out.
    //

    memset(*pbstrCompressed, 0, nInLen + sizeof(OLECHAR));

    //
    //  Convert to multibyte.
    //

    if (0 == WideCharToMultiByte(CP_ACP, 0, bstrIn, nInLen, (LPSTR)*pbstrCompressed, 
                        nInLen + 1, // this is how many bytes were allocated by
                                                        // SysAllocStringByteLen
                        NULL, NULL))
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    
    return hr;
}


//===========================================================================
//
// Decompress 
//
STDMETHODIMP CCrypt::Decompress(
    BSTR    bstrIn,
    BSTR*   pbstrDecompressed
    )
{
    HRESULT hr;
    CHAR    *pch;
    UINT    nInLen;

    if(bstrIn == NULL ||
       pbstrDecompressed == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    //  nInLen is number of mbc's, and does not include the terminating NULL.
    //

    nInLen = SysStringByteLen(bstrIn);

    //
    //	13386: return NULL if 0 length
    //
    if (nInLen == 0)
    {
        *pbstrDecompressed = NULL;
        hr = S_OK;
        goto Cleanup;
    }
	
    pch = (CHAR*)bstrIn;
    if ('\0' == pch[nInLen - 1])
    {
        nInLen--;
    }

    //
    //  Allocate a BSTR of the correct length.
    //

    *pbstrDecompressed = SysAllocStringLen(NULL, nInLen);
    if(*pbstrDecompressed == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    //  We allocated a total of (nOutLen+1) * sizeof(OLECHAR) bytes, since
    //  SysAllocStringLen allocs an extra character.  Zero it all out.
    //

    memset(*pbstrDecompressed, 0, (nInLen + 1) * sizeof(OLECHAR));

    //
    //  Convert to wide.
    //

    if (0 == MultiByteToWideChar(CP_ACP, 0, (LPCSTR)bstrIn, -1, *pbstrDecompressed, nInLen + 1))
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }
Cleanup:
    
    return hr;
}


//===========================================================================
//
// put_site 
//
STDMETHODIMP
CCrypt::put_site(
    BSTR    bstrSiteName
    )
{
    HRESULT             hr;
    int                 nLen;
    LPSTR               szNewSiteName;
    CRegistryConfig*    crc;

    if(!bstrSiteName)
    {
        if(m_szSiteName)
            delete [] m_szSiteName;
        m_szSiteName = NULL;
    }
    else
    {
        nLen = SysStringLen(bstrSiteName) + 1;
        szNewSiteName = new CHAR[nLen];
        if(!szNewSiteName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, bstrSiteName, -1,
                            szNewSiteName, nLen,
                            NULL,
                            NULL);


        Cleanup();

        m_szSiteName = szNewSiteName;
    }

    crc = ObtainCRC();
    if (!crc)
    {
        m_keyVersion = 0;
    }
    else
    {
        m_keyVersion = crc->getCurrentCryptVersion();
        crc->getCrypt(m_keyVersion,&m_validUntil);
        crc->Release();
    }

    hr = S_OK;

Cleanup:

    return hr;
}

//===========================================================================
//
// put_host 
//
STDMETHODIMP
CCrypt::put_host(
    BSTR    bstrHostName
    )
{
    HRESULT             hr;
    int                 nLen;
    LPSTR               szNewHostName;
    CRegistryConfig*    crc;

    if(!bstrHostName)
    {
        if(m_szHostName)
            delete [] m_szHostName;
        m_szHostName = NULL;
    }
    else
    {

        nLen = SysStringLen(bstrHostName) + 1;
        szNewHostName = new CHAR[nLen];
        if(!szNewHostName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(CP_ACP, 0, bstrHostName, -1,
                            szNewHostName, nLen,
                            NULL,
                            NULL);

        Cleanup();
        m_szHostName = szNewHostName;

        crc = ObtainCRC();
        if (!crc)
        {
            m_keyVersion = 0;
        }
        else
        {
            m_keyVersion = crc->getCurrentCryptVersion();
            crc->getCrypt(m_keyVersion,&m_validUntil);
            crc->Release();
        }
    }
    hr = S_OK;

Cleanup:

    return hr;
}

//===========================================================================
//
// Cleanup 
//
void CCrypt::Cleanup()
{
    if( m_szSiteName )
    {
        delete [] m_szSiteName;
        m_szSiteName = NULL;
    }

    if( m_szHostName )
    {
        delete [] m_szHostName;
        m_szHostName = NULL;
    }
}
    

//===========================================================================
//
// ObtainCRC 
//
CRegistryConfig* CCrypt::ObtainCRC()
{
    CRegistryConfig* crc = NULL;

    if( m_szHostName && m_szSiteName )
    {
        // we are in bad state now
        Cleanup();
        goto exit;
    } 
    
    if( m_szHostName )
        crc = g_config->checkoutRegistryConfig(m_szHostName);

    if( m_szSiteName )
        crc = g_config->checkoutRegistryConfigBySite(m_szSiteName);

    // if we still can't get crc at this moment, try the default one
    if( !crc )
        crc = g_config->checkoutRegistryConfig();

exit:
    return crc;
}

/////////////////////////////////////////////////////////////////////////////
// IPassportService implementation

//===========================================================================
//
// Initialize 
//
STDMETHODIMP CCrypt::Initialize(BSTR configfile, IServiceProvider* p)
{
    HRESULT hr;

    // Initialize.
    if (!g_config->isValid())
    {
        AtlReportError(CLSID_Crypt, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportService, PP_E_NOT_CONFIGURED);
        hr = PP_E_NOT_CONFIGURED;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


//===========================================================================
//
// Shutdown 
//
STDMETHODIMP CCrypt::Shutdown()
{
    return S_OK;
}


//===========================================================================
//
// ReloadState 
//
STDMETHODIMP CCrypt::ReloadState(IServiceProvider*)
{
    return S_OK;
}


//===========================================================================
//
// CommitState 
//
STDMETHODIMP CCrypt::CommitState(IServiceProvider*)
{
    return S_OK;
}


//===========================================================================
//
// DumpState 
//
STDMETHODIMP CCrypt::DumpState(BSTR* pbstrState)
{
	ATLASSERT( *pbstrState != NULL && 
               "CCrypt:DumpState - "
               "Are you sure you want to hand me a non-null BSTR?" );

	HRESULT hr = S_OK;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\profile.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    Profile.cpp


    FILE HISTORY:

*/

// Profile.cpp : Implementation of CProfile
#include "stdafx.h"
#include <oleauto.h>

#include "Passport.h"
#include "Profile.h"

// gmarks
#include "Monitoring.h"

/////////////////////////////////////////////////////////////////////////////
// CProfile
//===========================================================================
//
// CProfile 
//
CProfile::CProfile() : m_raw(NULL), m_pos(NULL), m_bitPos(NULL),
  m_schemaName(NULL), m_valid(FALSE), m_updates(NULL), m_schema(NULL),
  m_versionAttributeIndex(-1), m_secure(FALSE)
{
}

//===========================================================================
//
// ~CProfile 
//
CProfile::~CProfile()
{
  if (m_raw)
    FREE_BSTR(m_raw);
  if (m_pos)
    delete[] m_pos;
  if (m_bitPos)
    delete[] m_bitPos;
  if (m_schemaName)
    FREE_BSTR(m_schemaName);
  if (m_updates)
    {
      for (int i = 0; i < m_schema->Count(); i++)
	{
	  if (m_updates[i])
	    delete[] m_updates[i];
	}
      delete[] m_updates;
    }
  if (m_schema)
    m_schema->Release();
}

//===========================================================================
//
// InterfaceSupportsErrorInfo 
//
STDMETHODIMP CProfile::InterfaceSupportsErrorInfo(REFIID riid)
{
  static const IID* arr[] = 
  {
    &IID_IPassportProfile,
  };
  for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
      if (InlineIsEqualGUID(*arr[i],riid))
	return S_OK;
    }
  return S_FALSE;
}


//===========================================================================
//
// get_Attribute 
//
STDMETHODIMP CProfile::get_Attribute(BSTR name, VARIANT *pVal)
{
    VariantInit(pVal);

    if (!m_valid) return S_OK;  // Already threw event somewhere else

    if (!m_schema)
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (!name) return E_INVALIDARG;

    if (!_wcsicmp(name, L"internalmembername"))
    {
        // return the internal name
        return get_ByIndex(MEMBERNAME_INDEX, pVal);
    }


    int index = m_schema->GetIndexByName(name);
    if (index >= 0)
    {
        if( index != MEMBERNAME_INDEX ) 
        {
            return get_ByIndex(index, pVal);
        }
        else
        { 
            //
            // special case for MEMBERNAME, if this the name is 
            // in the format of email, we will need do something here
            //
            HRESULT hr = get_ByIndex(MEMBERNAME_INDEX, pVal); 
            if( S_OK == hr && VT_BSTR == pVal->vt )
            {
                int bstrLen = SysStringLen(pVal->bstrVal);
                int i = 0;
                int iChangePos = 0;
                int iTerminatePos = 0;

                for( i = 0; i < bstrLen; i++)
                {
                    if( pVal->bstrVal[i] == L'%' )
                        iChangePos = i;
                    if( pVal->bstrVal[i] == L'@' )
                        iTerminatePos = i;
                }

                //
                // for email format, we must have iChangePos < iTerminatePos
                // this code will convert "foo%bar.com@passport.com" into 
                //                        "foo@bar.com"
                //
                if( iChangePos && iTerminatePos && iChangePos < iTerminatePos )
                {
                    BSTR bstrTemp = pVal->bstrVal;

                    pVal->bstrVal[iChangePos] = L'@'; 
                    pVal->bstrVal[iTerminatePos] = L'\0'; 

                    pVal->bstrVal = SysAllocString(pVal->bstrVal);
                    if (NULL == pVal->bstrVal)
                        return E_OUTOFMEMORY;
                    SysFreeString(bstrTemp);
                }
            }
            return hr;
        } 
    }
    else
    {
        AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
                    IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
        return PP_E_NO_SUCH_ATTRIBUTE;
    }
    return S_OK;
}

//===========================================================================
//
// put_Attribute 
//
STDMETHODIMP CProfile::put_Attribute(BSTR name, VARIANT newVal)
{
    PassportLog("CProfile::put_Attribute:\r\n");

    if(g_pPerf) 
    {
        g_pPerf->incrementCounter(PM_PROFILEUPDATES_TOTAL);
        g_pPerf->incrementCounter(PM_PROFILEUPDATES_SEC);
    } 
    else 
    {
        _ASSERT(g_pPerf);
    }

    if (!m_valid) return S_OK;  // Already threw event somewhere else

    if (!m_schema)
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }


    if (!name) return E_INVALIDARG;

    PassportLog("    %ws\r\n", name);

    int index = m_schema->GetIndexByName(name);
    if (index >= 0)
        return put_ByIndex(index, newVal);
    else
    {
        AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
                        IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
        return PP_E_NO_SUCH_ATTRIBUTE;
    }

    return S_OK;
}

//===========================================================================
//
// get_ByIndex 
//
STDMETHODIMP CProfile::get_ByIndex(int index, VARIANT *pVal)
{
    u_short slen;
    u_long llen;

    if(!pVal)   return E_INVALIDARG;
   
    VariantInit(pVal);

    if (!m_valid) return S_OK;
    if (!m_schema)
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (m_pos[index] == INVALID_POS) return S_FALSE;   // the return value is VT_EMPTY

    if (index >= m_schema->Count())
    {
        AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
                    IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);

        return PP_E_NO_SUCH_ATTRIBUTE;
    }

    LPSTR raw = (LPSTR)m_raw;
    CProfileSchema::AttrType t = m_schema->GetType(index);

    switch (t)
    {
    case CProfileSchema::tText:
        {
            //
            // due to IA64 alignment faults this memcpy needs to be performed
            //
            memcpy((PBYTE)&slen, raw+m_pos[index], sizeof(slen));
            slen = ntohs(slen);
            pVal->vt = VT_BSTR;
            if (slen == 0)
            {
                pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(L"", 0);
            }
            else
            {
                int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            raw+m_pos[index]+sizeof(u_short),
                                            slen, NULL, 0);
                pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
                if (NULL == pVal->bstrVal)
                    return E_OUTOFMEMORY;
                MultiByteToWideChar(CP_UTF8, 0,
                                    raw+m_pos[index]+sizeof(u_short),
                                    slen, pVal->bstrVal, wlen);
                pVal->bstrVal[wlen] = L'\0';
            }
        }
        break;
    case CProfileSchema::tChar:
        {
            int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            raw+m_pos[index],
                                            m_schema->GetByteSize(index), NULL, 0);
            pVal->vt = VT_BSTR;
            pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
            if (NULL == pVal->bstrVal)
                return E_OUTOFMEMORY;
            MultiByteToWideChar(CP_UTF8, 0,
                                raw+m_pos[index],
                                m_schema->GetByteSize(index), pVal->bstrVal, wlen);
            pVal->bstrVal[wlen] = L'\0';
        }
        break;
    case CProfileSchema::tByte:
        pVal->vt = VT_I2;
        pVal->iVal = *(BYTE*)(raw+m_pos[index]);
        break;
    case CProfileSchema::tWord:
        pVal->vt = VT_I2;
        //
        // due to IA64 alignment faults this memcpy needs to be performed
        //
        memcpy((PBYTE)&slen, raw+m_pos[index], sizeof(slen));
        pVal->iVal = ntohs(slen);
        break;
    case CProfileSchema::tLong:
        pVal->vt = VT_I4;
        //
        // due to IA64 alignment faults this memcpy needs to be performed
        //
        memcpy((PBYTE)&llen, raw+m_pos[index], sizeof(llen));
        pVal->lVal = ntohl(llen);
        break;
    case CProfileSchema::tDate:
        pVal->vt = VT_DATE;
        //
        // due to IA64 alignment faults this memcpy needs to be performed
        //
        memcpy((PBYTE)&llen, raw+m_pos[index], sizeof(llen));
        llen = ntohl(llen);
        VarDateFromI4(llen, &(pVal->date));
        break;
    default:
        AtlReportError(CLSID_Profile, PP_E_BAD_DATA_FORMATSTR,
        IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
        return PP_E_BAD_DATA_FORMAT;
    }
    return S_OK;

}

//===========================================================================
//
// put_ByIndex 
//
STDMETHODIMP CProfile::put_ByIndex(int index, VARIANT newVal)
{
    static int nEmailIndex, nFlagsIndex;

    if(nEmailIndex == 0)
        nEmailIndex = m_schema->GetIndexByName(L"preferredEmail");
    if(nFlagsIndex == 0)
        nFlagsIndex = m_schema->GetIndexByName(L"flags");

    if(g_pPerf)
    {
        g_pPerf->incrementCounter(PM_PROFILEUPDATES_TOTAL);
        g_pPerf->incrementCounter(PM_PROFILEUPDATES_SEC);
    }
    else
    {
        _ASSERT(g_pPerf);
    }

    if (!m_valid) return S_OK;
    if (!m_schema)
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    if (index >= m_schema->Count())
    {
      AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
		     IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
      return PP_E_NO_SUCH_ATTRIBUTE;
    }

    if (m_schema->IsReadOnly(index))
    {
      AtlReportError(CLSID_Profile, PP_E_READONLY_ATTRIBUTESTR,
		     IID_IPassportProfile, PP_E_READONLY_ATTRIBUTE);
      return PP_E_READONLY_ATTRIBUTE;
    }

    // Now, if the update array doesn't exist, make it
    if (!m_updates)
    {
        m_updates = (void**) new void*[m_schema->Count()];
        if (!m_updates)
	        return E_OUTOFMEMORY;
        memset(m_updates, 0, m_schema->Count()*sizeof(void*));
    }

    // What type is this attribute?
    CProfileSchema::AttrType t = m_schema->GetType(index);

    if (m_updates[index] != NULL)
    {
        delete[] m_updates[index];
        m_updates[index] = NULL;
    }

    _variant_t dest;

    // I don't really like that we have to alloc memory for each entry (even bits)
    // but this happens infrequently enough that I'm not too upset
    switch (t)
    {
        case CProfileSchema::tText:
        {
            // Convert to UTF-8, stuff it
            if (VariantChangeType(&dest, &newVal, 0, VT_BSTR) != S_OK)
            {
	            AtlReportError(CLSID_Profile, PP_E_BDF_TOSTRCVT,
	       		     IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	            return PP_E_BAD_DATA_FORMAT;
            }
            int wlen = WideCharToMultiByte(CP_UTF8, 0,
				         dest.bstrVal, SysStringLen(dest.bstrVal),
				         NULL, 0, NULL, NULL);
            if (wlen > 65536 || wlen < 0)
            {
	             AtlReportError(CLSID_Profile, PP_E_BDF_STRTOLG,
			         IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
	             return PP_E_BAD_DATA_FORMAT;
            }

            if (wlen >= 0)
            {
                m_updates[index] = new char[sizeof(u_short)+wlen+1];
                if (NULL == m_updates[index])
                    return E_OUTOFMEMORY;
          
                WideCharToMultiByte(CP_UTF8, 0, dest.bstrVal, SysStringLen(dest.bstrVal),
			              ((char*)m_updates[index])+sizeof(u_short), wlen,
			              NULL, NULL);
                *(u_short*)m_updates[index] = htons((u_short)wlen);
                ((char*)m_updates[index])[wlen+sizeof(u_short)] = '\0';
            }
            else
            {
                AtlReportError(CLSID_Profile, PP_E_BDF_NONULL,
                    IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
                return PP_E_BAD_DATA_FORMAT;
            }
        }
        break;

        case CProfileSchema::tChar:
        {
            int atsize = m_schema->GetByteSize(index);
            // Create array, convert to UTF-8, stuff it
            m_updates[index] = new char[atsize];
            if (NULL == m_updates[index])
                return E_OUTOFMEMORY;

            // Convert to UTF-8, stuff it
            if (VariantChangeType(&dest, &newVal, 0, VT_BSTR) != S_OK)
            {
                AtlReportError(CLSID_Profile, PP_E_BDF_TOSTRCVT,
			        IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
                return PP_E_BAD_DATA_FORMAT;
            }
            int res = WideCharToMultiByte(CP_UTF8, 0, dest.bstrVal, SysStringLen(dest.bstrVal),
                          (char*)m_updates[index], atsize, NULL, NULL);
            if (res == 0)
            {
                delete[] m_updates[index];
                m_updates[index] = NULL;
                AtlReportError(CLSID_Profile, PP_E_BDF_STRTOLG,
                    IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
                return PP_E_BAD_DATA_FORMAT;
            }
        }
        break;

        case CProfileSchema::tByte:
            // Alloc single byte, put value
            if (VariantChangeType(&dest, &newVal, 0, VT_UI1) != S_OK)
            {
                AtlReportError(CLSID_Profile, PP_E_BDF_TOBYTECVT,
                    IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
                return PP_E_BAD_DATA_FORMAT;
            }
            m_updates[index] = new BYTE[1];
            if (NULL == m_updates[index])
                return E_OUTOFMEMORY;
            *(unsigned char*)(m_updates[index]) = dest.bVal;
        break;

        case CProfileSchema::tWord:
            // Alloc single word, put value
            if (VariantChangeType(&dest, &newVal, 0, VT_I2) != S_OK)
            {
                AtlReportError(CLSID_Profile, PP_E_BDF_TOSHORTCVT,
                    IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
                return PP_E_BAD_DATA_FORMAT;
            }

            m_updates[index] = new u_short[1];
            if (NULL == m_updates[index])
                return E_OUTOFMEMORY;
            *(u_short*)m_updates[index] = htons(dest.iVal);
        break;

        case CProfileSchema::tLong:
            // Alloc single long, put value
            if (VariantChangeType(&dest, &newVal, 0, VT_I4) != S_OK)
            {
                AtlReportError(CLSID_Profile, PP_E_BDF_TOINTCVT,
                    IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
                return PP_E_BAD_DATA_FORMAT;
            }
            m_updates[index] = new u_long[1];
            if (NULL == m_updates[index])
                return E_OUTOFMEMORY;
            *(u_long*)m_updates[index] = htonl(dest.lVal);
        break;

        case CProfileSchema::tDate:
            if (VariantChangeType(&dest, &newVal, 0, VT_DATE) != S_OK)
            {
                AtlReportError(CLSID_Profile, PP_E_BDF_TOINTCVT,
                    IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
                return PP_E_BAD_DATA_FORMAT;
            }
            m_updates[index] = new u_long[1];
            if (NULL == m_updates[index])
                return E_OUTOFMEMORY;
            *(u_long*)m_updates[index] = htonl((u_long)dest.date);
        break;

        default:
            AtlReportError(CLSID_Profile, PP_E_BDF_CANTSET,
                IID_IPassportProfile, PP_E_BAD_DATA_FORMAT);
            return PP_E_BAD_DATA_FORMAT;
    }

    //DarrenAn Bug 2157  If they just updated their email, clear the validation bit in flags.
    if(index == nEmailIndex)
    {
        u_long ulTmp;
        if (m_updates[nFlagsIndex] != NULL)
        {
            delete[] m_updates[nFlagsIndex];
        }
        m_updates[nFlagsIndex] = new u_long[1];
        memcpy((PBYTE)&ulTmp, ((LPSTR)m_raw)+m_pos[nFlagsIndex], sizeof(ulTmp));
        *(u_long*)m_updates[nFlagsIndex] = htonl(ntohl(ulTmp) & 0xFFFFFFFE);
    }

    return S_OK;
}

//===========================================================================
//
// get_IsValid 
//
STDMETHODIMP CProfile::get_IsValid(VARIANT_BOOL *pVal)
{
    *pVal = m_valid ? VARIANT_TRUE : VARIANT_FALSE;

    PassportLog("CProfile::get_IsValid: %X\r\n", *pVal);

    return S_OK;
}

//===========================================================================
//
// get_SchemaName 
//
STDMETHODIMP CProfile::get_SchemaName(BSTR *pVal)
{
    *pVal = ALLOC_AND_GIVEAWAY_BSTR(m_schemaName);
    if (NULL == *pVal)
        return E_OUTOFMEMORY;

    PassportLog("CProfile::get_SchemaName: %ws\r\n", *pVal);

    return S_OK;
}

//===========================================================================
//
// put_SchemaName 
//
STDMETHODIMP CProfile::put_SchemaName(BSTR newVal)
{

// fix: 5247	Profile Object not reseting Schema name
    return E_NOTIMPL;
}

//===========================================================================
//
// get_unencryptedProfile 
//
STDMETHODIMP CProfile::get_unencryptedProfile(BSTR *pVal)
{
    PassportLog("CProfile::get_unencryptedProfile: Enter:\r\n");

    // Take updates into account
    if (!pVal)
        return E_INVALIDARG;

    *pVal = NULL;

    if (!m_valid)
        return S_OK;
    if (!m_schema)
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    int size = 0, len;
    short i = 0;
    u_short Tmp;
    u_long ulTmp;

    LPSTR inraw = (LPSTR)m_raw;

    m_versionAttributeIndex = m_schema->GetIndexByName(L"profileVersion");

    // Pack up each value, first find out how much space we need
    for (; i < m_schema->Count(); i++)
    {
        CProfileSchema::AttrType t = m_schema->GetType(i);
        void* valPtr = NULL;

        if(m_pos[i] != INVALID_POS) valPtr = inraw+m_pos[i];

        if (m_updates && m_updates[i])
            valPtr = m_updates[i];

        // neither exists, end of the loop
        if (valPtr == NULL)  
        {
             break;
        }

        switch (t)
        {
            case CProfileSchema::tText:
	            // How long is the string
                memcpy((PBYTE)&Tmp, valPtr, sizeof(Tmp));
                size += (sizeof(u_short) + ntohs(Tmp));
                break;
            case CProfileSchema::tChar:
                size += m_schema->GetByteSize(i);
                break;
            case CProfileSchema::tByte:
                size += 1;
                break;
            case CProfileSchema::tWord:
                size += sizeof(u_short);
                break;
            case CProfileSchema::tLong:
            case CProfileSchema::tDate:
                size += sizeof(u_long);
                break;
            // no default case needed, it never will be non-null
        }
    }

    // Ok, now build it up...
    *pVal = ALLOC_BSTR_BYTE_LEN(NULL, size);
    if (NULL == *pVal)
        return E_OUTOFMEMORY;

    LPSTR raw = (LPSTR) *pVal;
    size = 0;

    for (i = 0; i < m_schema->Count(); i++)
    {
        void* valPtr = NULL;

        if(m_pos[i] != INVALID_POS) valPtr = inraw+m_pos[i];

        if (m_updates && m_updates[i])
            valPtr = m_updates[i];

        // neither exists, end of the loop
        if (valPtr == NULL)  break;

        CProfileSchema::AttrType t = m_schema->GetType(i);
      
        switch (t)
        {
            case CProfileSchema::tText:
                // How long is the string
                memcpy((PBYTE)&Tmp, valPtr, sizeof(Tmp));
                len = ntohs(Tmp);
                memcpy(raw+size, (char*) valPtr, len+sizeof(u_short));
                size += len + sizeof(u_short);
                break;
            case CProfileSchema::tChar:
                memcpy(raw+size, (char*) valPtr, m_schema->GetByteSize(i));
                size += m_schema->GetByteSize(i);
                break;
            case CProfileSchema::tByte:
                *(raw+size) = *(BYTE*)valPtr;
                size += 1;
                break;
            case CProfileSchema::tWord:
                memcpy(raw+size, valPtr, sizeof(u_short));
                size += sizeof(u_short);
                break;
            case CProfileSchema::tLong:
            case CProfileSchema::tDate:
                if (m_versionAttributeIndex == i && m_updates && m_updates[i])
                {
                    memcpy((PBYTE)&ulTmp, valPtr, sizeof(ulTmp));
                    ulTmp = htonl(ntohl(ulTmp)+1);
                    memcpy(raw+size, (PBYTE)&ulTmp, sizeof(ulTmp));
                }
                else
                {
                    memcpy(raw+size, valPtr, sizeof(u_long));
                }
                size += sizeof(u_long);
                break;
        }
    }

    GIVEAWAY_BSTR(*pVal);

    PassportLog("CProfile::get_unencryptedProfile: Exit:    %ws\r\n", *pVal);

    return S_OK;
}

//===========================================================================
//
// put_unencryptedProfile 
//
STDMETHODIMP CProfile::put_unencryptedProfile(BSTR newVal)
{
    PassportLog("CProfile::put_unencryptedProfile: Enter:\r\n");

    if (!g_config->isValid())
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	           IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    //
    //  Clean up all state associated with the previous profile.
    //

    if (m_raw)
    {
        FREE_BSTR(m_raw);
        m_raw = NULL;
    }

    if (m_pos)
    {
        delete [] m_pos;
        m_pos = NULL;
    }

    if (m_bitPos)
    {
        delete [] m_bitPos;
        m_bitPos = NULL;
    }

    if (m_updates)
    {
        for (int i = 0; i < m_schema->Count(); i++)
        {
            if (m_updates[i])
                delete[] m_updates[i];
        }
        delete[] m_updates;
        m_updates = NULL;
    }

    if (!newVal)
    {
        m_valid = FALSE;
        return S_OK;
    }

    // BOY do you have to be careful here.  If you don't
    // call BYTE version, it truncates at first pair of NULLs
    // we also need to expand beyond the key version byte
    DWORD dwByteLen = SysStringByteLen(newVal);

    if (dwByteLen > 2 && newVal[0] == SECURE_FLAG)
    {
        m_secure = TRUE;
        dwByteLen -= 2;
        m_raw = ALLOC_BSTR_BYTE_LEN((LPSTR)newVal + 2,
			                        dwByteLen);
    }
    else
    {
        m_secure = FALSE;
        m_raw = ALLOC_BSTR_BYTE_LEN((LPSTR)newVal,
			                        dwByteLen);
    }

    if (NULL == m_raw)
    {
        m_valid = FALSE;
        return E_OUTOFMEMORY;
    }

    PPTracePrintBlob(PPTRACE_RAW, "Profile:", (LPBYTE)newVal, dwByteLen, TRUE);

    parse(m_raw, dwByteLen);

    PassportLog("CProfile::get_unencryptedProfile: Exit:\r\n");

    return S_OK;
}

//===========================================================================
//
// parse 
//
void CProfile::parse(
    LPCOLESTR   raw,
    DWORD       dwByteLen
    )
{
    // How many attributes?
    DWORD cAtts = 0;

    CNexusConfig* cnc = g_config->checkoutNexusConfig();
    if (NULL == cnc)
    {
        m_valid = FALSE;
        goto Cleanup;
    }

    m_schema = cnc->getProfileSchema(m_schemaName);
    if (m_schema)
    {
        m_schema->AddRef();
    }
    cnc->Release();

    if (!m_schema)
    {
        m_valid = FALSE;
        goto Cleanup;
    }

    cAtts = m_schema->Count();

    // Set up the arrays
    m_pos = new UINT[cAtts];
    m_bitPos = new UINT[cAtts];

    if (m_pos && m_bitPos &&
        SUCCEEDED(m_schema->parseProfile((LPSTR)raw, dwByteLen, m_pos, m_bitPos, &cAtts)))
        m_valid = TRUE;
    else
        m_valid = FALSE;

Cleanup:
    if (m_valid == FALSE) 
    {
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_PROFILE,
                            0,NULL, dwByteLen, (LPVOID)raw);
    }
}

//===========================================================================
//
// get_updateString 
//
STDMETHODIMP CProfile::get_updateString(BSTR *pVal)
{
  if (!pVal)
    return E_INVALIDARG;

  *pVal = NULL;

  if (!m_valid) return S_OK;
    if (!m_schema)
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

  if (!m_updates)
    return S_OK;

  int size = sizeof(u_long)*2, len;
  short i = 0;
  u_short Tmp;

  // Pack up each value, first find out how much space we need
  for (; i < m_schema->Count(); i++)
    {
      if (m_updates[i])
	{
	  size += sizeof(u_short);  // For the index
	  CProfileSchema::AttrType t = m_schema->GetType(i);

	  switch (t)
	    {
	    case CProfileSchema::tText:
	        // How long is the string
            memcpy((PBYTE)&Tmp, m_updates[i], sizeof(Tmp));
	        size += (sizeof(u_short) + ntohs(Tmp));
	        break;
	    case CProfileSchema::tChar:
	        size += m_schema->GetByteSize(i);
	        break;
	    case CProfileSchema::tByte:
	        size += 1;
	        break;
	    case CProfileSchema::tWord:
	        size += sizeof(u_short);
	        break;
	    case CProfileSchema::tLong:
        case CProfileSchema::tDate:
	        size += sizeof(u_long);
	        break;
	        // no default case needed, it never will be non-null
	    }
	}
    }

  // Ok, now build it up...
  *pVal = ALLOC_BSTR_BYTE_LEN(NULL, size);
  if (NULL == *pVal)
      return E_OUTOFMEMORY;
  LPSTR raw = (LPSTR) *pVal;

  _bstr_t ml("memberIdLow"), mh("memberIdHigh");
  int iMl, iMh;
  iMl = m_schema->GetIndexByName(ml);
  iMh = m_schema->GetIndexByName(mh);

  if (iMl == -1 || iMh == -1)
    {
      AtlReportError(CLSID_Profile, PP_E_NO_SUCH_ATTRIBUTESTR,
		     IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
      return PP_E_NO_SUCH_ATTRIBUTE;
    }

  if (m_schema->GetType(iMl) != CProfileSchema::tLong ||
      m_schema->GetType(iMh) != CProfileSchema::tLong)
    {
      AtlReportError(CLSID_Profile, PP_E_NSA_BADMID,
		     IID_IPassportProfile, PP_E_NO_SUCH_ATTRIBUTE);
      return PP_E_NO_SUCH_ATTRIBUTE;
    }

  memcpy(raw, m_raw+m_pos[iMl], sizeof(int));
  memcpy(raw+sizeof(u_long), m_raw+m_pos[iMh], sizeof(int));

  size = 2*sizeof(u_long);

  for (i = 0; i < m_schema->Count(); i++)
    {
      if (m_updates[i])
      {
	  Tmp = htons(i);
      memcpy(raw+size, (PBYTE)&Tmp, sizeof(Tmp));
	  size+=sizeof(u_short);

	  CProfileSchema::AttrType t = m_schema->GetType(i);

	  switch (t)
	    {
	    case CProfileSchema::tText:
            // How long is the string
            memcpy((PBYTE)&Tmp, m_updates[i], sizeof(Tmp));
	        len = ntohs(Tmp);
	        memcpy(raw+size, (char*) m_updates[i], len+sizeof(u_short));
	        size += len + sizeof(u_short);
	        break;
	    case CProfileSchema::tChar:
	        memcpy(raw+size, (char*) m_updates[i], m_schema->GetByteSize(i));
	        size += m_schema->GetByteSize(i);
	        break;
	    case CProfileSchema::tByte:
	        *(raw+size) = *(BYTE*)m_updates[i];
	        size += 1;
	      break;
	    case CProfileSchema::tWord:
	        memcpy(raw+size, (char*) m_updates[i], sizeof(u_short));
	        size += sizeof(u_short);
	        break;
	    case CProfileSchema::tLong:
        case CProfileSchema::tDate:
	        memcpy(raw+size, (char*) m_updates[i], sizeof(u_long));
	        size += sizeof(u_long);
	        break;
	        // no default case needed, it never will be non-null
	    }
	}
    }

  GIVEAWAY_BSTR(*pVal);
  return S_OK;
}

//===========================================================================
//
// incrementVersion 
//
HRESULT CProfile::incrementVersion()
{
    int size = 0, len, i;
    LPSTR raw = (LPSTR)m_raw;
    u_short Tmp;
    u_long ulTmp;

    if (!m_valid) return S_OK;
    if (!m_schema)
    {
        AtlReportError(CLSID_Profile, PP_E_NOT_CONFIGUREDSTR,
	                    IID_IPassportProfile, PP_E_NOT_CONFIGURED);
        return PP_E_NOT_CONFIGURED;
    }

    m_versionAttributeIndex = m_schema->GetIndexByName(L"profileVersion");

    for(i = 0; i < m_versionAttributeIndex; i++)
    {
        CProfileSchema::AttrType t = m_schema->GetType(i);

        switch (t)
        {
        case CProfileSchema::tText:
            // How long is the string
            memcpy((PBYTE)&Tmp, m_raw+size, sizeof(Tmp));
            len = ntohs(Tmp);
            size += len + sizeof(u_short);
            break;
        case CProfileSchema::tChar:
            size += m_schema->GetByteSize(i);
            break;
        case CProfileSchema::tByte:
            size += 1;
            break;
        case CProfileSchema::tWord:
            size += sizeof(u_short);
            break;
        case CProfileSchema::tLong:
        case CProfileSchema::tDate:
            size += sizeof(u_long);
            break;
        // no default case needed, it never will be non-null
        }
    }

    memcpy((PBYTE)&ulTmp, m_raw+size, sizeof(ulTmp));
	ulTmp = htonl(ntohl(ulTmp) + 1);
    memcpy(raw+size, (PBYTE)&ulTmp, sizeof(ulTmp));

    return S_OK;
}

//===========================================================================
//
// get_IsSecure 
//
HRESULT CProfile::get_IsSecure(VARIANT_BOOL *pbIsSecure)
{
    HRESULT hr;

    if(pbIsSecure == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbIsSecure = (m_secure ? VARIANT_TRUE : VARIANT_FALSE);

    hr = S_OK;

Cleanup:

    return hr;
}

//===========================================================================
//
// IsSecure 
//
BOOL CProfile::IsSecure()
{
    return m_secure;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\profile.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    profile.h
        com object for profile 


    FILE HISTORY:

*/
// Profile.h : Declaration of the CProfile

#ifndef __PROFILE_H_
#define __PROFILE_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CProfile
class ATL_NO_VTABLE CProfile : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CProfile, &CLSID_Profile>,
	public ISupportErrorInfo,
	public IDispatchImpl<IPassportProfile, &IID_IPassportProfile, &LIBID_PASSPORTLib>
{
public:
  CProfile();
  ~CProfile();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PROFILE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProfile)
  COM_INTERFACE_ENTRY(IPassportProfile)
  COM_INTERFACE_ENTRY(IDispatch)
  COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportProfile
public:
  HRESULT get_IsSecure(VARIANT_BOOL* pbIsSecure);
  BOOL IsSecure(void);
  STDMETHOD(get_unencryptedProfile)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(put_unencryptedProfile)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_SchemaName)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(put_SchemaName)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_ByIndex)(/*[in]*/ int index, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_ByIndex)(/*[in]*/ int index, /*[in]*/ VARIANT newVal);
  STDMETHOD(get_Attribute)(/*[in]*/ BSTR name, /*[out, retval]*/ VARIANT *pVal);
  STDMETHOD(put_Attribute)(/*[in]*/ BSTR name, /*[in]*/ VARIANT newVal);
  STDMETHOD(get_updateString)(/*[out,retval]*/ BSTR *pVal);
  STDMETHOD(incrementVersion)(void);

protected:
    UINT*           m_bitPos;
    UINT*           m_pos;
    BSTR            m_schemaName;
    BSTR            m_raw;
    BOOL            m_valid;
    BOOL            m_secure;
    CProfileSchema* m_schema;

    int             m_versionAttributeIndex;
    void**          m_updates;

    void            parse(LPCOLESTR raw, DWORD dwByteLen);
private:
};

#endif //__PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\passportfactory.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    PassportFactory.cpp


    FILE HISTORY:

*/
// PassportFactory.cpp : Implementation of CPassportFactory
#include "stdafx.h"
#include "PassportFactory.h"

using namespace ATL;

/////////////////////////////////////////////////////////////////////////////
// CPassportFactory

//===========================================================================
//
// InterfaceSupportsErrorInfo 
//
STDMETHODIMP CPassportFactory::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IPassportFactory,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


//===========================================================================
//
// CreatePassportManager 
//
STDMETHODIMP CPassportFactory::CreatePassportManager(
    IDispatch** ppDispPassportManager
    )
{

    HRESULT   hr;

    if(ppDispPassportManager == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    CComObject<CManager>* pObj = NULL;
    * ppDispPassportManager = NULL;
    hr = ATL::CComObject<CManager>::CreateInstance(&pObj); // this has 0 ref count on it, don't need release here

    if (hr == S_OK && pObj)
    {
        hr = pObj->QueryInterface(__uuidof(IDispatch), (void**)ppDispPassportManager);
    }

Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\passportfactory.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    PassportFactory.h
        defines the manager factory object

    FILE HISTORY:

*/

// PassportFactory.h : Declaration of the CPassportFactory

#ifndef __PASSPORTFACTORY_H_
#define __PASSPORTFACTORY_H_

#include "resource.h"       // main symbols
#include "Passport.h"
#include "Manager.h"
#include "PassportLock.hpp"
#include "PassportGuard.hpp"


/////////////////////////////////////////////////////////////////////////////
// CPassportFactory
class ATL_NO_VTABLE CPassportFactory : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CPassportFactory, &CLSID_PassportFactory>,
	public ISupportErrorInfo,
	public IDispatchImpl<IPassportFactory, &IID_IPassportFactory, &LIBID_PASSPORTLib>
{
public:
	CPassportFactory()
	{ 
            m_pUnkMarshaler = NULL;
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_PASSPORTFACTORY)

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CPassportFactory)
	COM_INTERFACE_ENTRY(IPassportFactory)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportFactory
public:
	STDMETHOD(CreatePassportManager)(/*[out,retval]*/ IDispatch** pDisp);

private:
};

#endif //__PASSPORTFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\resource.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    RESOURCE.h
        Define class for fetching nexus files -- e.g. partner.xml


    FILE HISTORY:

*///{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Passport.rc
//
#define IDS_PROJNAME                    100
#define IDR_MANAGER                     101
#define IDR_TICKET                      102
#define IDR_PROFILE                     103
#define IDR_CRYPT                       104
#define IDR_ADMIN                       105
#define IDR_PASSPORTFACTORY             107
#define IDR_FASTAUTH                    108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    stdafx.cpp


    FILE HISTORY:

*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\registryconfig.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    RegistryConfig.cpp


    FILE HISTORY:

*/

// RegistryConfig.cpp: implementation of the CRegistryConfig class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegistryConfig.h"
#include "KeyCrypto.h"
#include "passport.h"
#include "keyver.h"
#include "dsysdbg.h"

extern BOOL g_bRegistering;

#define PASSPORT_KEY           L"Software\\Microsoft\\Passport\\"
#define PASSPORT_SITES_SUBKEY  L"Sites"

//===========================================================================
//
// Functions for verbose logging 
//

// define for logging with dsysdbg.lib
DEFINE_DEBUG2(Passport);
DEBUG_KEY   PassportDebugKeys[] = { {DEB_TRACE,         "Trace"},
                                    {0,                 NULL}
                              };
BOOL g_fLoggingOn = FALSE;
#define MAX_LOG_STRLEN 512

void PassportLog(CHAR* Format, ...)
{
    if (g_fLoggingOn)
    {
        if (NULL != Format) {
            SYSTEMTIME SysTime;
            CHAR rgch[MAX_LOG_STRLEN];
            int i, cch;

            // put the time at the front
            cch = sizeof(rgch) / sizeof(rgch[0]) - 1;
            GetSystemTime(&SysTime);
            i = GetDateFormatA (
                        LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                        0, // flags specifying function options
                        &SysTime, // date to be formatted
                        "ddd',' MMM dd yy ", // date format string
                        rgch, // buffer for storing formatted string
                        cch); // size of buffer
            if (i > 0)
                i--;

            i += GetTimeFormatA (
                        LOCALE_USER_DEFAULT, // locale for which date is to be formatted
                        0, // flags specifying function options
                        &SysTime, // date to be formatted
                        "HH':'mm':'ss ", // time format string
                        rgch + i, // buffer for storing formatted string
                        cch - i); // size of buffer
            if (i > 0)
                i--;

            va_list ArgList;                                        \
            va_start(ArgList, Format);                              \
            _vsnprintf(rgch + i, cch - i, Format, ArgList);
            rgch[MAX_LOG_STRLEN - 1] = '\0';

            PassportDebugPrint(DEB_TRACE, rgch);
        }
    }
}

//
// This function opens the logging file.  "%WINDIR%\system32\microsoftpassport\passport.log"
//
HANDLE OpenPassportLoggingFile()
{
    WCHAR   szLogPath[MAX_PATH + 13] = {0};
    UINT    cchMax = sizeof(szLogPath) / sizeof(szLogPath[0]) - 1;
    UINT    cch;
    HANDLE  hLogFile = INVALID_HANDLE_VALUE;

    cch = GetWindowsDirectory(szLogPath, cchMax);
    if ((0 == cch) || (cch > cchMax))
    {
        goto Cleanup;
    }

    if (NULL == wcsncat(szLogPath, L"\\system32\\microsoftpassport\\passport.log", cchMax - cch))
    {
        goto Cleanup;
    }

    szLogPath[MAX_PATH] = L'\0';

    hLogFile = CreateFileW(szLogPath,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL, //&sa,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE != hLogFile)
    {
        SetFilePointer(hLogFile, 0, NULL, FILE_END);
    }
Cleanup:
    return hLogFile;
}


//
// This function checks if logging is supposed to be enabled and if it is then
// it opens the log file and sets the appropriate global variables.
// If logging is supposed to be off then the appropriate variables are also
// changed to the correct values.
//
VOID CheckLogging(HKEY hPassport)
{
    DWORD dwVerbose = 0;
    DWORD cb = sizeof(DWORD);
    HANDLE hLogFile = INVALID_HANDLE_VALUE;

    // first run off and get the reg value, if this call fails we simply assume no logging
    if (ERROR_SUCCESS == RegQueryValueExW(hPassport,
                             L"Verbose",
	                         NULL,
                             NULL,
                             (LPBYTE)&dwVerbose,
                             &cb))
    {
        // only start logging if it is off and only stop logging if it's already on
        if (!g_fLoggingOn && (0 != dwVerbose))
        {
            if (INVALID_HANDLE_VALUE != (hLogFile = OpenPassportLoggingFile()))
            {
                // set the logging file handle
                PassportSetLoggingFile(hLogFile);

                // set it to log to a file
                PassportSetLoggingOption(TRUE);

                g_fLoggingOn = TRUE;
                PassportLog("Start Logging\r\n");
            }
        }
        else if (g_fLoggingOn && (0 == dwVerbose))
        {
            PassportLog("Stop Logging\r\n");
            PassportSetLoggingOption(FALSE);

            g_fLoggingOn = FALSE;
        }
    }
}

void InitLogging()
{
    //
    // Initialize the logging stuff
    //
    PassportInitDebug(PassportDebugKeys);
    PassportInfoLevel = DEB_TRACE;
}

void CloseLogging()
{
    PassportUnloadDebug();
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
using namespace ATL;
//===========================================================================
//
// CRegistryConfig 
//
CRegistryConfig::CRegistryConfig(
    LPSTR  szSiteName
    ) :
    m_siteId(0), m_valid(FALSE), m_ticketPath(NULL), m_profilePath(NULL), m_securePath(NULL),
    m_hostName(NULL), m_hostIP(NULL), m_ticketDomain(NULL), m_profileDomain(NULL), m_secureDomain(NULL),
    m_disasterUrl(NULL), m_disasterMode(FALSE), m_forceLogin(FALSE), m_setCookies(TRUE), 
    m_szReason(NULL), m_refs(0), m_coBrand(NULL), m_ru(NULL), m_ticketAge(1800), m_bInDA(FALSE),
    m_hkPassport(NULL), m_secureLevel(0),m_notUseHTTPOnly(0), m_pcrypts(NULL), m_pcryptValidTimes(NULL),
    m_KPP(-1),m_NameSpace(NULL),m_ExtraParams(NULL)
{
    // Get site id, key from registry
    DWORD bufSize = sizeof(m_siteId);
    LONG lResult;
    HKEY hkSites = NULL;
    DWORD dwBufSize = 0, disMode;
    DWORD dwLCID;

    //
    // Record the current DLL state in case it changes
    // partway through this routine.
    //

    BOOL fRegistering = g_bRegistering;

    if(szSiteName)
    {
        lResult = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                PASSPORT_KEY PASSPORT_SITES_SUBKEY,
                0,
                KEY_READ,
                &hkSites);
        if(lResult != ERROR_SUCCESS)
        {
            m_valid = FALSE;
            setReason(L"Invalid site name.  Site not found.");
            goto Cleanup;
        }

        lResult = RegOpenKeyExA(
                hkSites,
                szSiteName,
                0,
                KEY_READ,
                &m_hkPassport);
        if(lResult != ERROR_SUCCESS)
        {
            m_valid = FALSE;
            setReason(L"Invalid site name.  Site not found.");
            goto Cleanup;
        }
    }
    else
    {
        lResult = RegOpenKeyEx(
		        HKEY_LOCAL_MACHINE,
                        PASSPORT_KEY,
                        0,
                        KEY_READ,
                        &m_hkPassport
                        );
        if(lResult != ERROR_SUCCESS)
        {
            m_valid = FALSE;
            setReason(L"No RegKey HKLM\\SOFTWARE\\Microsoft\\Passport");
            goto Cleanup;
        }
    }

    // Get the current key
    bufSize = sizeof(m_currentKey);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("CurrentKey"),
                                       NULL, NULL, (LPBYTE)&m_currentKey, &bufSize))
    {
        m_valid = FALSE;
        setReason(L"No CurrentKey defined in the registry.");
        goto Cleanup;
    }

    if(m_currentKey < KEY_VERSION_MIN || m_currentKey > KEY_VERSION_MAX)
    {
        m_valid = FALSE;
        setReason(L"Invalid CurrentKey value in the registry.");
        goto Cleanup;
    }

    // Get default LCID
    bufSize = sizeof(dwLCID);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("LanguageID"),
                                   NULL, NULL, (LPBYTE)&dwLCID, &bufSize))
    {
        dwLCID = 0;
    }

    m_lcid = static_cast<short>(dwLCID & 0xFFFF);

    // Get disaster mode status
    bufSize = sizeof(disMode);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("StandAlone"),
                                   NULL, NULL, (LPBYTE)&disMode, &bufSize))
    {
        m_disasterMode = FALSE;
    }
    else if (disMode != 0)
    {
        m_disasterMode = TRUE;
    }

    // Get the disaster URL
    if (m_disasterMode)
    {
        if (ERROR_SUCCESS == RegQueryValueEx(m_hkPassport,
                                             _T("DisasterURL"),
                                             NULL,
                                             NULL,
                                             NULL,
                                             &dwBufSize)
             &&
            dwBufSize > 1)
        {
            m_disasterUrl = new WCHAR[dwBufSize];

            if ((!m_disasterUrl)
                  || 
                 ERROR_SUCCESS != RegQueryValueEx(m_hkPassport,
                                                  _T("DisasterURL"),
                                                  NULL,
                                                  NULL, 
                                                  (LPBYTE) m_disasterUrl,
                                                  &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading DisasterURL from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
        else
        {
            m_valid = FALSE;
            setReason(L"DisasterURL missing from registry.");
            goto Cleanup;
        }
    }

    //
    // This function wraps the allocations of the crypt objects in a try/except
    // since the objects themselves do a poor job in low memory conditions
    //
    try
    {
        m_pcrypts = new INT2CRYPT;
        m_pcryptValidTimes = new INT2TIME;
    }
    catch(...)
    {
        m_valid = FALSE;
        setReason(L"Out of memory.");
        goto Cleanup;
    }
    if (!m_pcrypts || !m_pcryptValidTimes)
    {
        m_valid = FALSE;
        setReason(L"Out of memory.");
        goto Cleanup;
    }

    m_valid = readCryptoKeys(m_hkPassport);
    if (!m_valid)
    {
        if (!m_szReason)
            setReason(L"Error reading Passport crypto keys from registry.");
        goto Cleanup;
    }
    if (m_pcrypts->count(m_currentKey) == 0)
    {
        m_valid = FALSE;
        if (!m_szReason)
            setReason(L"Error reading Passport crypto keys from registry.");
        goto Cleanup;
    }

    // Get the optional default cobrand
    if (ERROR_SUCCESS == RegQueryValueExW(m_hkPassport, L"CoBrandTemplate",
				            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 2)
        {
            m_coBrand = (WCHAR*) new char[dwBufSize];
            if (!m_coBrand
                 ||
                ERROR_SUCCESS != RegQueryValueExW(m_hkPassport, L"CoBrandTemplate",
						                NULL, NULL, 
						                (LPBYTE) m_coBrand, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading CoBrand from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional default return URL
    if (ERROR_SUCCESS == RegQueryValueExW(m_hkPassport, L"ReturnURL",
				                        NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 2)
        {
            m_ru = (WCHAR*) new char[dwBufSize];
            if (!m_ru
                 ||
                ERROR_SUCCESS != RegQueryValueExW(m_hkPassport, L"ReturnURL",
						                    NULL, NULL, 
						                    (LPBYTE) m_ru, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading ReturnURL from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

  // Get the host name
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "HostName",
                                         NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_hostName = new char[dwBufSize];

            if (m_hostName == NULL
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "HostName",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_hostName, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading HostName from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }


  // Get the host ip
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "HostIP",
                                          NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_hostIP = new char[dwBufSize];

            if (!m_hostIP
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "HostIP",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_hostIP, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading HostIP from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }


    // Get the optional domain to set ticket cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "TicketDomain",
                                            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_ticketDomain = new char[dwBufSize];
            if (!m_ticketDomain
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "TicketDomain",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_ticketDomain, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading TicketDomain from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional domain to set profile cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "ProfileDomain",
                                            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_profileDomain = new char[dwBufSize];
            if (!m_profileDomain
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "ProfileDomain",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_profileDomain, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading ProfileDomain from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional domain to set secure cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "SecureDomain",
                                            NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_secureDomain = new char[dwBufSize];
            if (!m_secureDomain
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "SecureDomain",
                                                  NULL, NULL, 
                                                  (LPBYTE) m_secureDomain, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading SecureDomain from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional path to set ticket cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "TicketPath",
				       NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_ticketPath = new char[dwBufSize];
            if (!m_ticketPath
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "TicketPath",
						                          NULL, NULL, 
						                          (LPBYTE) m_ticketPath, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading TicketPath from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional path to set profile cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "ProfilePath",
				       NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_profilePath = new char[dwBufSize];
            if (!m_profilePath
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "ProfilePath",
						  NULL, NULL, 
						  (LPBYTE) m_profilePath, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading ProfilePath from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    // Get the optional path to set secure cookies into
    if (ERROR_SUCCESS == RegQueryValueExA(m_hkPassport, "SecurePath",
				       NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 1)
        {
            m_securePath = new char[dwBufSize];
            if (!m_securePath
                 ||
                ERROR_SUCCESS != RegQueryValueExA(m_hkPassport, "SecurePath",
						                          NULL, NULL, 
						                          (LPBYTE) m_securePath, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading SecurePath from registry. (Query worked, but couldn't retrieve data)");
                goto Cleanup;
            }
        }
    }

    bufSize = sizeof(m_siteId);
    // Now get the site id
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("SiteId"),
                                        NULL, NULL, (LPBYTE)&m_siteId, &bufSize))
    {
        m_valid = FALSE;
        setReason(L"No SiteId specified in registry");
        goto Cleanup;
    }

    // And the default ticket time window
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("TimeWindow"),
                                        NULL, NULL, (LPBYTE)&m_ticketAge, &bufSize))
    {
        m_ticketAge = 1800;
    }

    bufSize = sizeof(DWORD);
    DWORD forced;
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("ForceSignIn"),
                                        NULL, NULL, (LPBYTE)&forced, &bufSize))
    {
        m_forceLogin = FALSE;
    }
    else
    {
        m_forceLogin = forced == 0 ? FALSE : TRUE;
    }

    bufSize = sizeof(DWORD);
    DWORD noSetCookies;
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("DisableCookies"),
                                        NULL, NULL, (LPBYTE)&noSetCookies, &bufSize))
    {
        m_setCookies = TRUE;
    }
    else
    {
        m_setCookies = !noSetCookies;
    }

    bufSize = sizeof(DWORD);
    DWORD dwInDA;
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("InDA"),
                                        NULL, NULL, (LPBYTE)&dwInDA, &bufSize))
    {
        m_bInDA = FALSE;
    }
    else
    {
        m_bInDA = (dwInDA != 0);
    }

    bufSize = sizeof(m_secureLevel);
    // Now get the site id
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("SecureLevel"),
                                        NULL, NULL, (LPBYTE)&m_secureLevel, &bufSize))
    {
        m_secureLevel = 0;
    }

    bufSize = sizeof(m_notUseHTTPOnly);
    // Now get the NotUseHTTPOnly
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("NotUseHTTPOnly"),
                                        NULL, NULL, (LPBYTE)&m_notUseHTTPOnly, &bufSize))
    {
        m_notUseHTTPOnly = 0;
    }

    // Get the KPP value
    bufSize = sizeof(m_KPP);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hkPassport, _T("KPP"),
                                        NULL, NULL, (LPBYTE)&m_KPP, &bufSize))
    {
        m_KPP = -1;
    }

    // Get the optional namespace
    if (ERROR_SUCCESS == RegQueryValueExW(m_hkPassport, L"NameSpace",
				                        NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 2)
        {
            m_NameSpace = (WCHAR*) new char[dwBufSize];
            if (!m_NameSpace
                 ||
                ERROR_SUCCESS != RegQueryValueExW(m_hkPassport, L"NameSpace",
						                    NULL, NULL, 
						                    (LPBYTE) m_NameSpace, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading NameSpace from registry.");
                goto Cleanup;
            }
        }
    }

    // Get the optional extra parameters
    if (ERROR_SUCCESS == RegQueryValueExW(m_hkPassport, L"ExtraParams",
				                        NULL, NULL, NULL, &dwBufSize))
    {
        if (dwBufSize > 2)
        {
            m_ExtraParams = (WCHAR*) new char[dwBufSize];
            if (!m_ExtraParams
                 ||
                ERROR_SUCCESS != RegQueryValueExW(m_hkPassport, L"ExtraParams",
						                    NULL, NULL, 
						                    (LPBYTE) m_ExtraParams, &dwBufSize))
            {
                m_valid = FALSE;
                setReason(L"Error reading ExtraParams from registry.");
                goto Cleanup;
            }
        }
    }

    //
    // Check for the verbose flag in the registry and do the appropriate stuff to either
    // turn logging on or off.
    //
    // Only check if this is the default site.
    //
    if (!szSiteName)
    {
        CheckLogging(m_hkPassport);
    }

    m_szReason = NULL;
    m_valid = TRUE;

Cleanup:
    if ( NULL !=  hkSites )
    {
        RegCloseKey(hkSites);
    }

    if (m_valid == FALSE && !fRegistering)
    {
       g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                         PM_INVALID_CONFIGURATION, m_szReason);
    }

   return;
}

//===========================================================================
//
// ~CRegistryConfig 
//
CRegistryConfig::~CRegistryConfig()
{
    if (m_pcrypts)
    {
        if (!m_pcrypts->empty())
        {
            INT2CRYPT::iterator itb = m_pcrypts->begin();
            for (; itb != m_pcrypts->end(); itb++)
            {
                delete itb->second;
            }
            m_pcrypts->clear();
        }
        delete m_pcrypts;
    }

    // may be a leak that we don't iterate through and delete the elements
    if (m_pcryptValidTimes)
    {
        delete m_pcryptValidTimes;
    }

    if (m_szReason)
        SysFreeString(m_szReason);
    if (m_ticketDomain)
        delete[] m_ticketDomain;
    if (m_profileDomain)
        delete[] m_profileDomain;
    if (m_secureDomain)
        delete[] m_secureDomain;
    if (m_ticketPath)
        delete[] m_ticketPath;
    if (m_profilePath)
        delete[] m_profilePath;
    if (m_securePath)
        delete[] m_securePath;
    if (m_disasterUrl)
        delete[] m_disasterUrl;
    if (m_coBrand)
        delete[] m_coBrand;
    if (m_hostName)
        delete[] m_hostName;
    if (m_hostIP)
        delete[] m_hostIP;
    if (m_ru)
        delete[] m_ru;
    if (m_NameSpace)
        delete[] m_NameSpace;
    if (m_ExtraParams)
        delete[] m_ExtraParams;
    if (m_hkPassport != NULL)
    {
        RegCloseKey(m_hkPassport);
    }

}

//===========================================================================
//
// GetCurrentConfig 
//
#define  __MAX_STRING_LENGTH__   1024
HRESULT CRegistryConfig::GetCurrentConfig(LPCWSTR name, VARIANT* pVal)
{
   if(m_hkPassport == NULL || !m_valid)
   {
        AtlReportError(CLSID_Profile, PP_E_SITE_NOT_EXISTSSTR,
	                    IID_IPassportProfile, PP_E_SITE_NOT_EXISTS);
      return PP_E_SITE_NOT_EXISTS;
   }

   if(!name || !pVal)   return E_INVALIDARG;

   HRESULT  hr = S_OK;
   BYTE  *pBuf = NULL;
   ATL::CComVariant v;
   BYTE  dataBuf[__MAX_STRING_LENGTH__];
   DWORD bufLen = sizeof(dataBuf);
   BYTE  *pData = dataBuf;
   DWORD dwErr = ERROR_SUCCESS;
   DWORD dataType = 0;

   dwErr = RegQueryValueEx(m_hkPassport, name, NULL, &dataType, (LPBYTE)pData, &bufLen);

   if (dwErr == ERROR_MORE_DATA)
   {
      pBuf = (PBYTE)malloc(bufLen);
      if (!pBuf)
      {
         hr = E_OUTOFMEMORY;
         goto Exit;
      }
      pData = pBuf;
      dwErr = RegQueryValueEx(m_hkPassport, name, NULL, &dataType, (LPBYTE)pData, &bufLen);
   }

   if (dwErr != ERROR_SUCCESS)
   {
      hr = PP_E_NO_ATTRIBUTE;
      AtlReportError(CLSID_Manager, PP_E_NO_ATTRIBUTESTR,
                        IID_IPassportManager3, PP_E_NO_ATTRIBUTE);
   }
   else
   {
      switch(dataType)
      {
      case  REG_DWORD:
      case  REG_DWORD_BIG_ENDIAN:
         {
            DWORD* pdw = (DWORD*)pData;
            v = (long)*pdw;
         }
         break;
      case  REG_SZ:
      case  REG_EXPAND_SZ:
         {
            LPCWSTR pch = (LPCWSTR)pData;
            v = (LPCWSTR)pch;
         }
         break;
      default:
      AtlReportError(CLSID_Manager, PP_E_TYPE_NOT_SUPPORTEDSTR,
                        IID_IPassportManager, PP_E_TYPE_NOT_SUPPORTED);
         
         hr = PP_E_TYPE_NOT_SUPPORTED;
         
         break;
      }
   }

Exit:
   if(pBuf)
      free(pBuf);

   if (hr == S_OK)
      hr = v.Detach(pVal);
   
   return hr;

}

#define  MAX_ENCKEYSIZE 1024

//===========================================================================
//
// readCryptoKeys 
//
BOOL CRegistryConfig::readCryptoKeys(
    HKEY    hkPassport
    )
{
    LONG       lResult;
    BOOL       retVal = FALSE;
    HKEY       hkDataKey = NULL, hkTimeKey = NULL;
    DWORD      iterIndex = 0, keySize, keyTime, keyNumSize;
    BYTE       encKeyBuf[MAX_ENCKEYSIZE];
    int        kNum;
    TCHAR      szKeyNum[4];
    CKeyCrypto kc;
    int        foundKeys = 0;
    HANDLE     hToken = NULL;

    if (OpenThreadToken(GetCurrentThread(),
                        MAXIMUM_ALLOWED,
                        TRUE,
                        &hToken))
    {
        if (FALSE == RevertToSelf())
        {
            setReason(L"Unable to revert to self");
            goto Cleanup;
        }
    }

    // Open both the keydata and keytimes key,
    // if there's no keytimes key, we'll assume all keys are valid forever,
    // or more importantly, we won't break if that key isn't there
    lResult = RegOpenKeyEx(hkPassport, TEXT("KeyData"), 0,
			             KEY_READ, &hkDataKey);
    if(lResult != ERROR_SUCCESS)
    {
        setReason(L"No Valid Crypto Keys");
        goto Cleanup;
    }
    RegOpenKeyEx(hkPassport, TEXT("KeyTimes"), 0,
	           KEY_READ, &hkTimeKey);


    // Ok, now enumerate the KeyData keys and create crypt objects

    while (1)
    {
        keySize = sizeof(encKeyBuf);
        keyNumSize = sizeof(szKeyNum) >> (sizeof(TCHAR) - 1);
        lResult = RegEnumValue(hkDataKey, iterIndex++, szKeyNum,
                    &keyNumSize, NULL, NULL, (LPBYTE)&(encKeyBuf[0]), &keySize);
        if (lResult != ERROR_SUCCESS)
        {
            break;
        }

        kNum = KeyVerC2I(szKeyNum[0]);
        if (kNum > 0)
        {
            DATA_BLOB   iBlob;
            DATA_BLOB   oBlob = {0};

            iBlob.cbData = keySize;
            iBlob.pbData = (LPBYTE)&(encKeyBuf[0]);
      
            if(kc.decryptKey(&iBlob, &oBlob) != S_OK)
            {
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                 PM_CANT_DECRYPT_CONFIG);
                break;
            }
            else
            {
                // Now set up a crypt object
                CCoCrypt* cr = new CCoCrypt();
                if (NULL == cr)
                {
                    if(oBlob.pbData)
                    {
                        RtlSecureZeroMemory(oBlob.pbData, oBlob.cbData);
                        ::LocalFree(oBlob.pbData);
                        ZeroMemory(&oBlob, sizeof(oBlob));
                    }
                    setReason(L"Out of memory");
                    goto Cleanup;
                }

                BSTR km = ::SysAllocStringByteLen((LPSTR)oBlob.pbData, oBlob.cbData);
                if (NULL == km)
                {
                    if(oBlob.pbData)
                    {
                        RtlSecureZeroMemory(oBlob.pbData, oBlob.cbData);
                        ::LocalFree(oBlob.pbData);
                        ZeroMemory(&oBlob, sizeof(oBlob));
                    }
                    delete cr;
                    setReason(L"Out of memory");
                    goto Cleanup;
                }

                cr->setKeyMaterial(km);
                ::SysFreeString(km);
                if(oBlob.pbData)
                {
                    RtlSecureZeroMemory(oBlob.pbData, oBlob.cbData);
                    ::LocalFree(oBlob.pbData);
                    ZeroMemory(&oBlob, sizeof(oBlob));
                }

                // Add it to the bucket...
                // wrap the STL calls since in low memory conditions they can AV
                try
                {
                    INT2CRYPT::value_type pMapVal(kNum, cr);
                    m_pcrypts->insert(pMapVal);
                }
                catch(...)
                {
                    setReason(L"Out of memory");
                    goto Cleanup;
                }
              
                foundKeys++;

                keySize = sizeof(DWORD);
                if (RegQueryValueEx(hkTimeKey, szKeyNum, NULL,NULL,(LPBYTE)&keyTime,&keySize) ==
                        ERROR_SUCCESS && (m_currentKey != kNum))
                {
                    // wrap the STL calls since in low memory conditions they can AV
                    try
                    {
                        INT2TIME::value_type pTimeVal(kNum, keyTime);
                        m_pcryptValidTimes->insert(pTimeVal);
                    }
                    catch(...)
                    {
                        setReason(L"Out of memory");
                        goto Cleanup;
                    }
                }
            }
        }

        if (iterIndex > 100)  // Safety latch
        goto Cleanup;
    }

    retVal = foundKeys > 0 ? TRUE : FALSE;

Cleanup:
    if (hToken)
    {
        // put the impersonation token back
        if (!SetThreadToken(NULL, hToken))
        {
            setReason(L"Unable to set thread token");
            retVal = FALSE;
        }
        CloseHandle(hToken);
    }

    if (hkDataKey)
        RegCloseKey(hkDataKey);
    if (hkTimeKey)
        RegCloseKey(hkTimeKey);

    return retVal;
}

//===========================================================================
//
// getCrypt 
//
CCoCrypt* CRegistryConfig::getCrypt(int keyNum, time_t* validUntil)
{
    if (validUntil) // If they asked for the validUntil information
    {
        INT2TIME::const_iterator timeIt = m_pcryptValidTimes->find(keyNum);
        if (timeIt == m_pcryptValidTimes->end())
            *validUntil = 0;
        else
            *validUntil = (*timeIt).second;
    }
    // Now look up the actual crypt object
    INT2CRYPT::const_iterator it = m_pcrypts->find(keyNum);
    if (it == m_pcrypts->end())
        return NULL;
    return (*it).second;
}

//===========================================================================
//
// getFailureString 
//
BSTR CRegistryConfig::getFailureString()
{
  if (m_valid)
    return NULL;
  return m_szReason;
}

//===========================================================================
//
// setReason 
//
void CRegistryConfig::setReason(LPTSTR reason)
{
  if (m_szReason)
    SysFreeString(m_szReason);
  m_szReason = SysAllocString(reason);
}

//===========================================================================
//
// AddRef 
//
CRegistryConfig* CRegistryConfig::AddRef()
{
  InterlockedIncrement(&m_refs);
  return this;
}

//===========================================================================
//
// Release 
//
void CRegistryConfig::Release()
{
  long refs = InterlockedDecrement(&m_refs);
  if (refs == 0)
    delete this;
}

//===========================================================================
//
// GetHostName 
//
long
CRegistryConfig::GetHostName(
    LPSTR   szSiteName,
    LPSTR   szHostName,
    LPDWORD lpdwHostNameBufLen
    )
{
    long    lResult;
    HKEY    hkSites = NULL;
    HKEY    hkPassport = NULL;

    if(!szSiteName || szSiteName[0] == '\0')
    {
        lResult = E_UNEXPECTED;
        goto Cleanup;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           PASSPORT_KEY PASSPORT_SITES_SUBKEY,
                           0,
                           KEY_READ,
                           &hkSites
                           );
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    lResult = RegOpenKeyExA(hkSites,
                            szSiteName,
                            0,
                            KEY_READ,
                            &hkPassport
                            );
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;


    lResult = RegQueryValueExA(hkPassport,
                               "HostName",
                               NULL,
                               NULL,
                               (LPBYTE)szHostName,
                               lpdwHostNameBufLen
                               );

Cleanup:

    if(hkSites != NULL)
        RegCloseKey(hkSites);
    if(hkPassport != NULL)
        RegCloseKey(hkPassport);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    stdafx.h

    FILE HISTORY:

*/
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__41651BE6_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
#define AFX_STDAFX_H__41651BE6_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>
#include "commd5.h"

#include "BstrDebug.h"

#include "PassportConfiguration.h"
#include "Monitoring.h"
#include "PassportTypes.h"

#include "pptrace.h"

// Useful macros
#define PPF_CHAR(p)		((((LPCSTR )(p)) == NULL) ? ("<NULL>") : ((LPCSTR )(p)))
#define PPF_WCHAR(p)	((((LPCWSTR )(p)) == NULL) ? (L"<NULL>") : ((LPCWSTR )(p)))

extern CPassportConfiguration* g_config;
// extern CProfileSchema*         g_authSchema;
HRESULT GetGlobalCOMmd5(IMD5 ** ppMD5);

#define MEMBERNAME_INDEX 0
#define LANGPREF_INDEX   8

#include "asp.tlh"

using namespace ATL;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__41651BE6_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\ticket.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    ticket.h
        Define class for passport ticket


    FILE HISTORY:

*/
// Ticket.h : Declaration of the CTicket

#ifndef __TICKET_H_
#define __TICKET_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CTicket
class ATL_NO_VTABLE CTicket : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTicket, &CLSID_Ticket>,
	public ISupportErrorInfo,
	public IDispatchImpl<IPassportTicket2, &IID_IPassportTicket2, &LIBID_PASSPORTLib>
{
public:
  CTicket() : m_raw(NULL), m_lastSignInTime(0), 
    m_ticketTime(0), m_valid(FALSE),
    m_bSecureCheckSucceeded(FALSE), m_schemaDrivenOffset(INVALID_OFFSET),
    m_passportFlags(0)
    {
        ZeroMemory(m_memberId, sizeof(m_memberId));
    }

  ~CTicket()
    {
        if (m_raw)
            SysFreeString(m_raw);
    }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_TICKET)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTicket)
	COM_INTERFACE_ENTRY(IPassportTicket2)
	COM_INTERFACE_ENTRY(IPassportTicket)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
  STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPassportTicket
public:
  STDMETHOD(DoSecureCheck)(/*[in]*/ BSTR bstrSec);
  STDMETHOD(DoSecureCheckInTicket)(/* [in] */ BOOL fSecureTransported);
  BOOL IsSecure();
  ULONG GetPassportFlags();
  STDMETHOD(get_TicketTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(get_SignInTime)(/*[out, retval]*/ long *pVal);
  STDMETHOD(get_SignInServer)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(get_HasSavedPassword)(/*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_MemberIdHigh)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_MemberIdLow)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_MemberId)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(get_TimeSinceSignIn)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_TicketAge)(/*[out, retval]*/ int *pVal);
  STDMETHOD(get_IsAuthenticated)(/*[in]*/ ULONG timeWindow, /*[in]*/ VARIANT_BOOL forceLogin, /*[in,optional]*/ VARIANT CheckSecure, /*[out, retval]*/ VARIANT_BOOL *pVal);
  STDMETHOD(get_unencryptedTicket)(/*[out, retval]*/ BSTR *pVal);
  STDMETHOD(put_unencryptedTicket)(/*[in]*/ BSTR newVal);
  STDMETHOD(get_Error)(/*[out,retval]*/ long *pVal);

// IPassportTicket2
  STDMETHOD(GetProperty)(/*[in]*/ BSTR propName, /*[out, retval]*/ VARIANT* pVal);
  STDMETHOD(SetTertiaryConsent)(BSTR bstrConsent);
  STDMETHOD(ConsentStatus)(/*[in]*/VARIANT_BOOL bRequireConsentCookie, /*out*/ULONG* pStatus, /*[out, retval]*/ ConsentStatusEnum* pNeedConsent);

// none COM functions
enum{
  MSPAuth = 1, 
  MSPSecAuth, 
  MSPConsent
};

  // flags parameter is reserved for future use, must be 0 for this version
  STDMETHOD(get_unencryptedCookie)(/*in*/ ULONG cookieType, /*in*/ ULONG flags, /*[out, retval]*/ BSTR* pVal);
  
protected:
    BSTR    m_raw;
    BOOL    m_valid;
    BOOL    m_savedPwd;
    WCHAR   m_memberId[20];
    int     m_mIdLow;
    int     m_mIdHigh;
    long    m_flags;
    time_t  m_ticketTime;
    time_t  m_lastSignInTime;

    CComBSTR   m_bstrTertiaryConsent;

    void parse(LPCOLESTR raw, DWORD dwByteLen, DWORD* pcParsed);

private:
   // the bag for the schema driven fields
   CTicketPropertyBag   m_PropBag;
   DWORD                m_schemaDrivenOffset;     // the offset of schema driven data -- the data introduced after 1.3x
   ULONG                m_passportFlags;
   BOOL                 m_bSecureCheckSucceeded;
};

#endif //__TICKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\variantutils.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    variantutils.h
        helper funcs for Variant


    FILE HISTORY:

*/
#ifndef PP_VARIANT_UTILS
#define PP_VARIANT_UTILS

#define DEFAULTARG(v) (v.vt==VT_ERROR && v.scode==DISP_E_PARAMNOTFOUND)
#define HASARG(v) (v.vt!=VT_ERROR || v.scode!=DISP_E_PARAMNOTFOUND)

#define CV_OK      0
#define CV_DEFAULT 1
#define CV_BAD     2
#define CV_FREE    3

inline int GetIntArg(VARIANT &vIn, int *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_I4:
      *out = vIn.lVal;
      return CV_OK;
    case VT_I2:
      *out = vIn.iVal;
      return CV_OK;
    case VT_I4 | VT_BYREF:
      *out = *vIn.plVal;
      return CV_OK;
    case VT_I2 | VT_BYREF:
      *out = *vIn.piVal;
      return CV_OK;
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_I4) == S_OK)
    {
      *out = vConv.lVal;
      return CV_OK;
    }
  else
    return CV_BAD;
}

inline int GetShortArg(VARIANT &vIn, USHORT *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_I4:
      *out = static_cast<unsigned short>(vIn.lVal);
      return CV_OK;
    case VT_UI4:
      *out = static_cast<unsigned short>(vIn.ulVal);
      return CV_OK;
    case VT_I2:
      *out = static_cast<unsigned short>(vIn.iVal);
      return CV_OK;
    case VT_UI2:
      *out = static_cast<unsigned short>(vIn.uiVal);
      return CV_OK;
    case VT_I4 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.plVal);
      return CV_OK;
    case VT_UI4 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.pulVal);
      return CV_OK;
    case VT_I2 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.piVal);
      return CV_OK;
    case VT_UI2 | VT_BYREF:
      *out = static_cast<unsigned short>(*vIn.puiVal);
      return CV_OK;
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_UI2) == S_OK)
    {
      *out = vConv.iVal;
      return CV_OK;
    }
  else
    return CV_BAD;
}

inline int GetBoolArg(VARIANT &vIn, VARIANT_BOOL *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_BOOL:
      *out = vIn.boolVal;
      return CV_OK;
    case VT_BOOL | VT_BYREF:
      *out = *vIn.pboolVal;
      return CV_OK;
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_BOOL) == S_OK)
    {
      *out = vConv.boolVal;
      return CV_OK;
    }
  else
    return CV_BAD;
}

inline int GetBstrArg(VARIANT &vIn, BSTR *out)
{
  if (DEFAULTARG(vIn))
    return CV_DEFAULT;
  switch (vIn.vt)
    {
    case VT_BSTR:
      *out = vIn.bstrVal;
      return CV_OK;
    case VT_BSTR | VT_BYREF:
      *out = *vIn.pbstrVal;
      return CV_OK;
    case VT_VARIANT | VT_BYREF:
      return GetBstrArg(*vIn.pvarVal, out);
    }
  VARIANT vConv;
  VariantInit(&vConv);
  if (VariantChangeType(&vConv, &vIn, 0, VT_BSTR) == S_OK)
    {
      *out = vConv.bstrVal;
      return CV_FREE;
    }
  else
    return CV_BAD;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\registryconfig.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    registryconfig.h
        Define class for fetching nexus files -- e.g. partner.xml


    FILE HISTORY:

*/
// RegistryConfig.h: interface for the CRegistryConfig class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGISTRYCONFIG_H__74EB2515_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
#define AFX_REGISTRYCONFIG_H__74EB2515_E239_11D2_95E9_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "BstrHash.h"
#include "CoCrypt.h"
#include "ptstl.h"
#include "dsysdbg.h"

// logging declarations
DECLARE_DEBUG2(Passport);
extern BOOL g_fLoggingOn;
void PassportLog(CHAR* Format, ...);
void InitLogging();
void CloseLogging();


typedef PtStlMap<int,CCoCrypt*> INT2CRYPT;
typedef PtStlMap<int,time_t> INT2TIME;

class CRegistryConfig  
{
 public:
  CRegistryConfig(LPSTR szSiteName = NULL);
  virtual ~CRegistryConfig();
  
  BOOL            isValid() { return m_valid; }

  CCoCrypt*       getCrypt(int keyNum, time_t* validUntil);
  CCoCrypt*       getCurrentCrypt() { return getCrypt(m_currentKey,NULL); }
  int             getCurrentCryptVersion() { return m_currentKey; }

  int             getSiteId() { return m_siteId; }

  // Return a description of the failure
  BSTR            getFailureString();

  // Shout out to all my LISP homies
  BOOL forceLoginP() { return m_forceLogin; }
  BOOL setCookiesP() { return m_setCookies; }
  BOOL bInDA() { return m_bInDA; }
  
  LPSTR getHostName() { return m_hostName; }
  LPSTR getHostIP() { return m_hostIP; }
  LPSTR getTicketDomain() { return m_ticketDomain; }
  LPSTR getProfileDomain() { return m_profileDomain; }
  LPSTR getSecureDomain() { return m_secureDomain; }
  LPSTR getTicketPath() { return m_ticketPath; }
  LPSTR getProfilePath() { return m_profilePath; }
  LPSTR getSecurePath() { return m_securePath; }
  ULONG getDefaultTicketAge() { return m_ticketAge; }
  USHORT getDefaultLCID() { return m_lcid; }

  LPWSTR getDefaultCoBrand() { return m_coBrand; }
  LPWSTR getDefaultRU() { return m_ru; }

  BOOL   DisasterModeP() { return m_disasterMode; }
  LPWSTR getDisasterUrl() { return m_disasterUrl; }
  int getSecureLevel(){ return m_secureLevel;};
  int getNotUseHTTPOnly(){ return m_notUseHTTPOnly;};

  int getKPP(){ return m_KPP;};
  LPWSTR getNameSpace(){ return m_NameSpace;};
  LPWSTR getExtraParams(){ return m_ExtraParams;};

  CRegistryConfig* AddRef();
  void             Release();
  HRESULT GetCurrentConfig(LPCWSTR name, VARIANT* pVal);

  static long GetHostName(LPSTR szSiteName, 
                          LPSTR szHostNameBuf, 
                          LPDWORD lpdwHostNameBufLen);

 protected:
  void             setReason(LPWSTR reason);

  BOOL             readCryptoKeys(HKEY hkPassport);

  BOOL             m_disasterMode;
  char*            m_hostName;
  char*            m_hostIP;
  WCHAR*           m_disasterUrl;
  char*            m_ticketDomain;
  char*            m_profileDomain;
  char*            m_secureDomain;
  char*            m_ticketPath;
  char*            m_profilePath;
  char*            m_securePath;
  WCHAR*           m_coBrand;
  WCHAR*           m_ru;
  BOOL             m_setCookies;
  ULONG            m_ticketAge;
  BOOL             m_forceLogin;
  BOOL             m_bInDA;
  USHORT           m_lcid;
  int              m_KPP;
  WCHAR*           m_NameSpace;
  WCHAR*           m_ExtraParams;

  INT2CRYPT        *m_pcrypts;
  INT2TIME         *m_pcryptValidTimes;
  int              m_currentKey;

  int              m_siteId;

  BOOL             m_valid;

  BSTR             m_szReason;

  long             m_refs;
  int              m_secureLevel;
  int              m_notUseHTTPOnly;

  HKEY             m_hkPassport;

};

#endif // !defined(AFX_REGISTRYCONFIG_H__74EB2515_E239_11D2_95E9_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\passportmanager\ticket.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    Ticket.cpp


    FILE HISTORY:

*/


// Ticket.cpp : Implementation of CTicket
#include "stdafx.h"
#include "Passport.h"
#include "Ticket.h"
#include <time.h>
#include <nsconst.h>
#include "variantutils.h"
#include "helperfuncs.h"

// gmarks
#include "Monitoring.h"

/////////////////////////////////////////////////////////////////////////////
// CTicket

//===========================================================================
//
// InterfaceSupportsErrorInfo
//
STDMETHODIMP CTicket::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_IPassportTicket,
        &IID_IPassportTicket2
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//===========================================================================
//
// SetTertiaryConsent
//
STDMETHODIMP CTicket::SetTertiaryConsent(BSTR bstrConsent)
{
   _ASSERT(m_raw);

   if(!m_valid ) return S_FALSE;
   if(!bstrConsent) return E_INVALIDARG;

   HRESULT hr = S_OK;

   if(SysStringByteLen(bstrConsent) != sizeof(long) * 4 ||
      memcmp(m_raw, bstrConsent, sizeof(long) * 2) != 0 )
      hr = E_INVALIDARG;
   else
   {
      try{
         m_bstrTertiaryConsent = bstrConsent;
      }
      catch(...)
      {
         hr = E_OUTOFMEMORY;
      }
   }

   return hr;
}

//===========================================================================
//
// needConsent -- if consent cookie is needed,
//          return the flags related to kids passport
//
HRESULT CTicket::ConsentStatus(
    VARIANT_BOOL bRequireConsentCookie,
    ULONG* pStatus,
    ConsentStatusEnum* pConsentCode)
{
   ConsentStatusEnum  ret = ConsentStatus_Unknown;
   ULONG              status = 0;
   u_long             ulTmp;

   if (m_bstrTertiaryConsent &&
       SysStringByteLen(m_bstrTertiaryConsent) >= sizeof(long) * 4)
   {
      ULONG* pData = (ULONG*)(BSTR)m_bstrTertiaryConsent;
      memcpy((PBYTE)&ulTmp, (PBYTE)(pData + 3), sizeof(ulTmp));
      status = (ntohl(ulTmp) & k_ulFlagsConsentCookieMask);
      ret = ConsentStatus_Known;
   }
   else
   {
      TicketProperty prop;

      // 1.X ticket, with no flags in it
      if (S_OK != m_PropBag.GetProperty(ATTR_PASSPORTFLAGS, prop))
      {
         ret = ConsentStatus_NotDefinedInTicket;
         goto Exit;
      }

      ULONG flags = GetPassportFlags();

      if(flags & k_ulFlagsConsentCookieNeeded)
      {
         if (bRequireConsentCookie)
         {
            ret = ConsentStatus_Unknown;
            flags = flags & k_ulFlagsAccountType;
         }
         else
         {
             ret = ConsentStatus_Known;
         }
      }
      else
         ret = ConsentStatus_DoNotNeed;

      status = (flags & k_ulFlagsConsentCookieMask);
   }

Exit:
   if(pConsentCode)
      *pConsentCode = ret;

   if (pStatus)
      *pStatus = status;

   return S_OK;
}

//===========================================================================
//
// get_unencryptedCookie
//
STDMETHODIMP
CTicket::get_unencryptedCookie(ULONG cookieType, ULONG flags, BSTR *pVal)
{
    PassportLog("CTicket::get_unencryptedCookie :\r\n");

    if (!m_raw)   return S_FALSE;

    HRESULT   hr = S_OK;

    if (!pVal || flags != 0) return E_INVALIDARG;

    switch(cookieType)
    {
    case MSPAuth:
      *pVal = SysAllocStringByteLen((LPSTR)m_raw, SysStringByteLen(m_raw));

      if (*pVal)
      {
         // if the secure flags is on, we should turn it off for this cookie always
         TicketProperty prop;

         if (S_OK == m_PropBag.GetProperty(ATTR_PASSPORTFLAGS, prop))
         {
            if (prop.value.vt == VT_I4
               && ((prop.value.lVal & k_ulFlagsSecuredTransportedTicket) != 0))
               // we need to turn off the bit
            {
                ULONG l = prop.value.lVal;
                l &= (~k_ulFlagsSecuredTransportedTicket); // unset the bit

                // put the modified flags into the buffer.
                u_long ulTmp;
                ulTmp = htonl(l);
                memcpy(((PBYTE)(*pVal)) + m_schemaDrivenOffset + prop.offset, (PBYTE)&ulTmp, sizeof(ulTmp));
            }
         }
      }

      break;

    case MSPSecAuth:

      // ticket should be long enough
      _ASSERT(SysStringByteLen(m_raw) > sizeof(long) * 3);

      // the first 3 long fields of the ticket
      // format:
      //  four bytes network long - low memberId bytes
      //  four bytes network long - high memberId bytes
      //  four bytes network long - time of last refresh
      //

      // generate a shorter version of the cookie for secure signin
      *pVal = SysAllocStringByteLen((LPSTR)m_raw, sizeof(long) * 3);

       break;

    case MSPConsent:

      // ticket should be long enough
      _ASSERT(SysStringByteLen(m_raw) > sizeof(long) * 3);

      // check if there is consent
//      if (GetPassportFlags() & k_ulFlagsConsentStatus)
      // we always write consent cookie even if there is no consent
      if (GetPassportFlags() & k_ulFlagsConsentCookieNeeded)
      {
         // the first 3 long fields of the ticket
         // format:
         //  four bytes network long - low memberId bytes
         //  four bytes network long - high memberId bytes
         //  four bytes network long - time of last refresh
         //
         // plus the consent flags -- long
         //

         // generate a shorter version of the cookie for secure signin
         *pVal = SysAllocStringByteLen((LPSTR)m_raw, sizeof(long) * 4);

         // plus the consent flags -- long
         //
         if (*pVal)
         {
             long* pl = (long*)pVal;
             // we mask the flags, and put into the cookie
             *(pl + 3) = htonl(GetPassportFlags() & k_ulFlagsConsentCookieMask);
         }
      }
      else
      {
         *pVal = NULL;
         hr = S_FALSE;
      }

       break;

    default:
      hr = E_INVALIDARG;
      break;
    }

    if (*pVal == 0 && hr == S_OK)
      hr = E_OUTOFMEMORY;

    return hr;
 }

//===========================================================================
//
// get_unencryptedTicket
//
STDMETHODIMP CTicket::get_unencryptedTicket(BSTR *pVal)
{
    PassportLog("CTicket::get_unencryptedTicket :\r\n");

    *pVal = SysAllocStringByteLen((LPSTR)m_raw, SysStringByteLen(m_raw));

    PassportLog("    %ws\r\n", m_raw);

    return S_OK;
}

//===========================================================================
//
// put_unencryptedTicket
//
STDMETHODIMP CTicket::put_unencryptedTicket(BSTR newVal)
{
    DWORD   dw13Xlen = 0;

    PassportLog("CTicket::put_unencryptedTicket Enter:\r\n");

    if (m_raw)
    {
        PassportLog("    T = %ws\r\n", m_raw);

        SysFreeString(m_raw);
        m_raw = NULL;
    }

    if (!newVal)
    {
        m_valid = FALSE;
        return S_OK;
    }


    m_bSecureCheckSucceeded = FALSE;

    // BOY do you have to be careful here.  If you don't
    // call BYTE version, it truncates at first pair of NULLs
    // we also need to go past the key version byte
    DWORD dwByteLen = SysStringByteLen(newVal);
    {
        m_raw = SysAllocStringByteLen((LPSTR)newVal,
                                      dwByteLen);
        if (NULL == m_raw)
        {
            m_valid = FALSE;
            return E_OUTOFMEMORY;
        }
    }

    PPTracePrintBlob(PPTRACE_RAW, "Ticket:", (LPBYTE)newVal, dwByteLen, TRUE);

    // parse the 1.3X ticket data
    parse(m_raw, dwByteLen, &dw13Xlen);

    PPTracePrint(PPTRACE_RAW, "ticket: len=%d, len1.x=%d, len2=%d", dwByteLen, dw13Xlen, dwByteLen - dw13Xlen);

    // parse the schema driven data
    if (dwByteLen > dw13Xlen) // more data to parse
    {
        // the offset related to the raw data
        m_schemaDrivenOffset = dw13Xlen;

        // parse the schema driven properties
        LPCSTR  pData = (LPCSTR)(LPWSTR)m_raw;
        pData += dw13Xlen;
        dwByteLen -= dw13Xlen;

        // parse the schema driven fields
        CNexusConfig* cnc = g_config->checkoutNexusConfig();
        if (NULL == cnc)
        {
            m_valid = FALSE;
            return S_FALSE;
        }

        CTicketSchema* pSchema = cnc->getTicketSchema(NULL);

        if ( pSchema )
        {
            HRESULT hr = pSchema->parseTicket(pData, dwByteLen, m_PropBag);

            // passport flags is useful, should treat it special
            TicketProperty prop;
            if (S_OK == m_PropBag.GetProperty(ATTR_PASSPORTFLAGS, prop))
            {
               if (prop.value.vt == VT_I4)
                   m_passportFlags = prop.value.lVal;
            }

           /*
           if (FAILED(hr) )
            event log
           */
        }
        cnc->Release();

    }

    PPTracePrint(PPTRACE_RAW, "ticket propertybag: size=%d, flags=%lx", m_PropBag.Size(), m_passportFlags);

    PassportLog("CTicket::put_unencryptedTicket Exit:\r\n");

    return S_OK;
}

//===========================================================================
//
// get_IsAuthenticated
//
STDMETHODIMP CTicket::get_IsAuthenticated(
    ULONG           timeWindow,
    VARIANT_BOOL    forceLogin,
    VARIANT         SecureLevel,
    VARIANT_BOOL*   pVal
    )
{
    int hasSecureLevel = CV_DEFAULT;

    PassportLog("CTicket::get_IsAuthenticated Enter:\r\n");

    PPTraceFunc<VARIANT_BOOL> func(PPTRACE_FUNC, *pVal,
         "get_IsAuthenticated", "<<< %lx, %lx, %1x, %p",
         timeWindow, forceLogin, V_I4(&SecureLevel), pVal);

    if(!pVal)
      return E_INVALIDARG;

    *pVal = VARIANT_FALSE;

    if ((timeWindow != 0 && timeWindow < PPM_TIMEWINDOW_MIN) || timeWindow > PPM_TIMEWINDOW_MAX)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TIMEWINDOWSTR,
                        IID_IPassportTicket, PP_E_INVALID_TIMEWINDOW);
        return PP_E_INVALID_TIMEWINDOW;
    }

    if (m_valid == FALSE)
    {
        *pVal = VARIANT_FALSE;
        return S_OK;
    }

    long lSecureLevel = 0;
    time_t now;
    long interval = 0;

    PassportLog("    TW = %X,   LT = %X,   TT = %X\r\n", timeWindow, m_lastSignInTime, m_ticketTime);

    // time window checking
    if (timeWindow != 0) //  check time window
    {
        time(&now);

        interval = forceLogin ? now - m_lastSignInTime :
                        now - m_ticketTime;

        if (interval < 0) interval = 0;

        PPTracePrint(PPTRACE_RAW, "timwindow:%ld, interval:%ld", timeWindow, interval);

        if ((unsigned long)(interval) > timeWindow)
        {
            // Make sure we're not in standalone mode
            CRegistryConfig* crc = g_config->checkoutRegistryConfig();
            if ((!crc) || (crc->DisasterModeP() == FALSE))
            {
                if(forceLogin)
                {
                    if(g_pPerf)
                    {
                        g_pPerf->incrementCounter(PM_FORCEDSIGNIN_TOTAL);
                        g_pPerf->incrementCounter(PM_FORCEDSIGNIN_SEC);
                    }
                    else
                    {
                        _ASSERT(g_pPerf);
                    }
                }
            }
            else
                *pVal = VARIANT_TRUE;  // we're in disaster mode, any cookie is good.
            if (crc) crc->Release();

            goto Cleanup;
        }
    }

    // check secureLevel stuff
    hasSecureLevel = GetIntArg(SecureLevel, (int*)&lSecureLevel);
    if(hasSecureLevel == CV_BAD) // try the legacy type VT_BOOL, map VARIANT_TRUE to SecureChannel
    {
        PPTracePrint(PPTRACE_RAW, "SecureLevel Bad Param");
        return E_INVALIDARG;
    }
    else if (hasSecureLevel == CV_DEFAULT)
    {
        // Make sure we're not in standalone mode
        CRegistryConfig* crc = g_config->checkoutRegistryConfig();
        if(crc)
           lSecureLevel = crc->getSecureLevel();
    }

    PPTracePrint(PPTRACE_RAW, "check secureLevel:%ld", lSecureLevel);

    if(lSecureLevel != 0)
    {
       VARIANT_BOOL bCheckSecure = ( SECURELEVEL_USE_HTTPS(lSecureLevel) ?
                                  VARIANT_TRUE : VARIANT_FALSE );
       PPTracePrint(PPTRACE_RAW, "secure checked OK?:%ld", m_bSecureCheckSucceeded);

       // SSL checking
       if(bCheckSecure && !m_bSecureCheckSucceeded)
         goto Cleanup;

       // securelevel checking
       {
          TicketProperty   prop;
          HRESULT hr = m_PropBag.GetProperty(ATTR_SECURELEVEL, prop);

          PPTracePrint(PPTRACE_RAW, "secure level in ticket:%ld, %lx", (long) (prop.value), hr);

          // secure level is not good enough
          if(hr != S_OK || SecureLevelFromSecProp((int) (long) (prop.value)) < lSecureLevel)
            goto Cleanup;

          // time window checking against pin time -- if Pin signin
          if(SecureLevelFromSecProp((int) (long) (prop.value)) == k_iSeclevelStrongCreds)
          {
             hr = m_PropBag.GetProperty(ATTR_PINTIME, prop);

             PPTracePrint(PPTRACE_RAW, "pin time:%ld, %lx", (long) (prop.value), hr);
             if (hr != S_OK)
               goto Cleanup;

             interval = now - (long) (prop.value);

             if (interval < 0) interval = 0;

             PPTracePrint(PPTRACE_RAW, "timewindow:%ld, pin-interval:%ld", timeWindow, interval);
             if ((unsigned long)(interval) > timeWindow)
             {
               goto Cleanup;
             }
          }
       }
    }

    // if code can reach here, is authenticated
    *pVal = VARIANT_TRUE;

Cleanup:
    PassportLog("CTicket::get_IsAuthenticated Exit: %X\r\n", *pVal);

    return S_OK;
}

//===========================================================================
//
// get_TicketAge
//
STDMETHODIMP CTicket::get_TicketAge(int *pVal)
{
    PassportLog("CTicket::get_TicketAge Enter: %X\r\n", m_ticketTime);

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                    IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    time_t now;
    time(&now);
    *pVal = now - m_ticketTime;

    if (*pVal < 0)
        *pVal = 0;

    PassportLog("CTicket::get_TicketAge Exit: %X\r\n", *pVal);

    return S_OK;
}

//===========================================================================
//
// get_TimeSinceSignIn
//
STDMETHODIMP CTicket::get_TimeSinceSignIn(int *pVal)
{
    PassportLog("CTicket::get_TimeSinceSignIn Enter: %X\r\n", m_lastSignInTime);

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    time_t now;
    time(&now);
    *pVal = now - m_lastSignInTime;

    if (*pVal < 0)
        *pVal = 0;

    PassportLog("CTicket::get_TimeSinceSignIn Exit: %X\r\n", *pVal);

    return S_OK;
}

//===========================================================================
//
// get_MemberId
//
STDMETHODIMP CTicket::get_MemberId(BSTR *pVal)
{
    HRESULT hr = S_OK;

    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        hr = PP_E_INVALID_TICKET;
        goto Cleanup;
    }

    if(pVal == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pVal = SysAllocString(m_memberId);
    if(*pVal == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    return hr;
}

//===========================================================================
//
// get_MemberIdLow
//
STDMETHODIMP CTicket::get_MemberIdLow(int *pVal)
{
    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    PassportLog("CTicket::get_MemberIdLow: %X\r\n", m_mIdLow);

    *pVal = m_mIdLow;

    return S_OK;
}

//===========================================================================
//
// get_MemberIdHigh
//
STDMETHODIMP CTicket::get_MemberIdHigh(int *pVal)
{
    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    PassportLog("CTicket::get_MemberIdHigh: %X\r\n", m_mIdHigh);

    *pVal = m_mIdHigh;

    return S_OK;
}

//===========================================================================
//
// get_HasSavedPassword
//
STDMETHODIMP CTicket::get_HasSavedPassword(VARIANT_BOOL *pVal)
{
    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    PassportLog("CTicket::get_HasSavedPassword: %X\r\n", m_savedPwd);

    *pVal = m_savedPwd ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

//===========================================================================
//
// get_SignInServer
//
STDMETHODIMP CTicket::get_SignInServer(BSTR *pVal)
{
    if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

    // BUGBUG
    return E_NOTIMPL;
}

//===========================================================================
//
// parse
//
// parse the 1.3X ticket fields
void CTicket::parse(
    LPCOLESTR   raw,
    DWORD       dwByteLen,
    DWORD*      pcParsed
    )
{
    LPSTR  lpBase;
    UINT   byteLen, spot=0;
    long   curTime;
    time_t curTime_t;
    u_long ulTmp;

    if (!raw)
    {
        m_valid = false;
        goto Cleanup;
    }

    // format:
    //  four bytes network long - low memberId bytes
    //  four bytes network long - high memberId bytes
    //  four bytes network long - time of last refresh
    //  four bytes network long - time of last password entry
    //  four bytes network long - time of ticket generation
    //  one byte - is this a saved password (Y/N)
    //  four bytes network long - flags

    lpBase = (LPSTR)(LPWSTR) raw;
    byteLen = dwByteLen;
    spot=0;

    //  1.3x ticket length, excluding HM which is 1 long shorter
    DWORD dw13XLen = sizeof(u_long)*6 + sizeof(char);
    if (byteLen < dw13XLen && byteLen != dw13XLen - sizeof(u_long))
    {
        m_valid = FALSE;
        goto Cleanup;
    }

    memcpy((PBYTE)&ulTmp, lpBase, sizeof(ulTmp));
    m_mIdLow  = ntohl(ulTmp);
    spot += sizeof(u_long);

    memcpy((PBYTE)&ulTmp, lpBase + spot, sizeof(ulTmp));
    m_mIdHigh = ntohl(ulTmp);
    spot += sizeof(u_long);

    wsprintfW(m_memberId, L"%08X%08X", m_mIdHigh, m_mIdLow);

    memcpy((PBYTE)&ulTmp, lpBase + spot, sizeof(ulTmp));
    m_ticketTime     = ntohl(ulTmp);
    spot += sizeof(u_long);

    memcpy((PBYTE)&ulTmp, lpBase + spot, sizeof(ulTmp));
    m_lastSignInTime = ntohl(ulTmp);
    spot += sizeof(u_long);

    time(&curTime_t);

    curTime = (ULONG) curTime_t;

    // If the current time is "too" negative, bail (5 mins)
    memcpy((PBYTE)&ulTmp, lpBase + spot, sizeof(ulTmp));
    if ((unsigned long)(curTime+300) < ntohl(ulTmp))
    {
        if (g_pAlert)
        {
            memcpy((PBYTE)&ulTmp, lpBase + spot, sizeof(ulTmp));
            DWORD dwTimes[2] = { curTime, ntohl(ulTmp) };
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_TIMESTAMP_BAD,
                            0, NULL, sizeof(DWORD) << 1, (LPVOID)dwTimes);
        }

        m_valid = FALSE;
        goto Cleanup;
    }
    spot += sizeof(u_long);

    m_savedPwd = (*(char*)(lpBase+spot)) == 'Y' ? TRUE : FALSE;
    spot += sizeof(char);

    if (dwByteLen == dw13XLen)
    {
        memcpy((PBYTE)&ulTmp, lpBase + spot, sizeof(ulTmp));
        m_flags = ntohl(ulTmp);
    }
    else
    {
        //  HM cookie
        m_flags = 0;
    }
    spot += sizeof(u_long);

    m_valid = TRUE;
    if(pcParsed)  *pcParsed = spot;

    Cleanup:
    if (m_valid == FALSE)
    {
        if(g_pAlert)
            g_pAlert->report(PassportAlertInterface::WARNING_TYPE, PM_INVALID_TICKET);
        if(g_pPerf)
        {
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_TOTAL);
            g_pPerf->incrementCounter(PM_INVALIDREQUESTS_SEC);
        }
        else
        {
            _ASSERT(g_pPerf);
        }
    }

}

//===========================================================================
//
// get_TicketTime
//
STDMETHODIMP CTicket::get_TicketTime(long *pVal)
{
    PassportLog("CTicket::get_TicketTime: %X\r\n", m_ticketTime);
    *pVal = m_ticketTime;
    return S_OK;
}

//===========================================================================
//
// get_SignInTime
//
STDMETHODIMP CTicket::get_SignInTime(long *pVal)
{
    PassportLog("CTicket::get_SignInTime: %X\r\n", m_lastSignInTime);
    *pVal = m_lastSignInTime;
    return S_OK;
}

//===========================================================================
//
// get_Error
//
STDMETHODIMP CTicket::get_Error(long* pVal)
{
    PassportLog("CTicket::get_Error: %X\r\n", m_flags);
    *pVal = m_flags;
    return S_OK;
}

//===========================================================================
//
// GetPassportFlags
//
ULONG CTicket::GetPassportFlags()
{
    return m_passportFlags;
}


//===========================================================================
//
// IsSecure
//
BOOL CTicket::IsSecure()
{
    return ((m_passportFlags & k_ulFlagsSecuredTransportedTicket) != 0);
}

//===========================================================================
//
// DoSecureCheckInTicket -- use the information in the ticket to determine if secure signin
//
STDMETHODIMP CTicket::DoSecureCheckInTicket(/* [in] */ BOOL fSecureTransported)
{
    m_bSecureCheckSucceeded =
               (fSecureTransported
               && (m_passportFlags & k_ulFlagsSecuredTransportedTicket) != 0);

    return S_OK;
}

//===========================================================================
//
// DoSecureCheck
//
STDMETHODIMP CTicket::DoSecureCheck(BSTR bstrSec)
{
    if(bstrSec == NULL)
      return E_INVALIDARG;

    // make sure that the member id in the ticket
    // matches the member id in the secure cookie.
    m_bSecureCheckSucceeded = (memcmp(bstrSec, m_raw, sizeof(long) * 3) == 0);

    return S_OK;
}

//===========================================================================
//
// GetProperty
//
STDMETHODIMP CTicket::GetProperty(BSTR propName, VARIANT* pVal)
{
   HRESULT hr = S_OK;
   TicketProperty prop;
   if (m_valid == FALSE)
    {
        AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_INVALID_TICKETSTR,
                        IID_IPassportTicket, PP_E_INVALID_TICKET);
        return PP_E_INVALID_TICKET;
    }

   if (!pVal)  return E_POINTER;

   VariantInit(pVal);

   hr = m_PropBag.GetProperty(propName, prop);

   if (FAILED(hr)) goto Cleanup;

   if (hr == S_FALSE)   // no such property back
   {
    AtlReportError(CLSID_Ticket, (LPCOLESTR) PP_E_NO_ATTRIBUTESTR,
                        IID_IPassportTicket, PP_E_NO_ATTRIBUTE);

      hr = PP_E_NO_SUCH_ATTRIBUTE;
      goto Cleanup;
   }

   if (hr == S_OK)
   {
      //  if(prop.flags & TPF_NO_RETRIEVE)
      *pVal = prop.value;  // skin level copy
      prop.value.Detach();
   }
Cleanup:

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\configset.cpp ===
#include "pmcfg.h"
#include <atlbase.h>
#include <atlconv.h>

DWORD   g_dwSiteNameBufLen;
DWORD   g_dwHostNameBufLen;
DWORD   g_dwHostIPBufLen;
LPTSTR  g_szSiteNameBuf;
LPTSTR  g_szHostNameBuf;
LPTSTR  g_szHostIPBuf;

INT_PTR CALLBACK    NewConfigSetDlgProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL IsValidIP(
    LPCTSTR pszIP
    )
{
    BOOL              bIsValid = FALSE;
    SOCKADDR_STORAGE  TmpSockAddr;
    INT               cbAddr = sizeof(TmpSockAddr);
    WSADATA           wsaData;

    if (0 != WSAStartup(MAKEWORD(2,0), &wsaData))
    {
        return FALSE;
    }
    
    if (0 == WSAStringToAddress((LPTSTR)pszIP,
                                AF_INET,
                                NULL,
                                (LPSOCKADDR)&TmpSockAddr,
                                &cbAddr))
    {
        bIsValid = TRUE;
    }

    WSACleanup();
    return bIsValid;
}


BOOL NewConfigSet
(
    HWND            hWndDlg,
    LPTSTR          szSiteNameBuf,
    DWORD           dwSiteNameBufLen,
    LPTSTR          szHostNameBuf,
    DWORD           dwHostNameBufLen,
    LPTSTR          szHostIPBuf,
    DWORD           dwHostIPBufLen
)
{
    g_dwSiteNameBufLen = dwSiteNameBufLen;
    g_dwHostNameBufLen = dwHostNameBufLen;
    g_dwHostIPBufLen   = dwHostIPBufLen;
    g_szSiteNameBuf    = szSiteNameBuf;
    g_szHostNameBuf    = szHostNameBuf;
    g_szHostIPBuf      = szHostIPBuf;

    if (IDOK == DialogBox( g_hInst, 
                           MAKEINTRESOURCE (IDD_NEW_CONFIGSET), 
                           hWndDlg, 
                           NewConfigSetDlgProc ))
        return TRUE;
    else
        return FALSE;                                    

}


BOOL RemoveConfigSetWarning
(
    HWND    hWndDlg
)
{
    TCHAR   szWarning[MAX_RESOURCE];
    TCHAR   szTitle[MAX_RESOURCE];

    LoadString(g_hInst, IDS_REMOVE_WARNING, szWarning, DIMENSION(szWarning));
    LoadString(g_hInst, IDS_REMOVE_TITLE, szTitle, DIMENSION(szTitle));

    return (MessageBox(hWndDlg, szWarning, szTitle, MB_OKCANCEL | MB_ICONQUESTION) == IDOK); 
}


INT_PTR CALLBACK NewConfigSetDlgProc
(
    HWND     hWndDlg,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM   lParam
)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            SendDlgItemMessage(hWndDlg, IDC_CONFIGSETEDIT, EM_SETLIMITTEXT, MAX_CONFIGSETNAME - 1, 0L);
            SendDlgItemMessage(hWndDlg, IDC_HOSTNAMEEDIT, EM_SETLIMITTEXT, INTERNET_MAX_HOST_NAME_LENGTH - 1, 0L);
            SendDlgItemMessage(hWndDlg, IDC_HOSTIPEDIT, EM_SETLIMITTEXT, MAX_IPLEN, 0L);
            SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
            return FALSE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    TCHAR   szTemp[MAX_RESOURCE];
                    TCHAR   szTitle[MAX_RESOURCE];
                    LPTSTR  lpszConfigSetNames, lpszCur;

                    //
                    //  Check for empty site name
                    //

                    GetDlgItemText(hWndDlg, IDC_CONFIGSETEDIT, g_szSiteNameBuf, g_dwSiteNameBufLen);
                    if(lstrlen(g_szSiteNameBuf) == 0)
                    {
                        LoadString(g_hInst, IDS_EMPTYSITENAME, szTemp, DIMENSION(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, DIMENSION(szTitle));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
                        break;
                    }

                    //
                    //  Make sure the site name isn't default
                    //

                    LoadString(g_hInst, IDS_DEFAULT, szTemp, DIMENSION(szTemp));

                    if(lstrcmp(g_szSiteNameBuf, szTemp) == 0)
                    {
                        LoadString(g_hInst, IDS_INVALIDSITENAME, szTemp, DIMENSION(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, DIMENSION(szTitle));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
                        break;
                    }

                    //
                    //  Check for existing site w/same name
                    //

                    if(ReadRegConfigSetNames(hWndDlg, g_szRemoteComputer, &lpszConfigSetNames) &&
                       lpszConfigSetNames)
                    {
                        BOOL    bFoundMatch = FALSE;

                        lpszCur = lpszConfigSetNames;
                        while(*lpszCur)
                        {
                            if(_wcsicmp(lpszCur, g_szSiteNameBuf) == 0)
                            {
                                LoadString(g_hInst, IDS_EXISTINGSITENAME, szTemp, DIMENSION(szTemp));
                                LoadString(g_hInst, IDS_ERROR, szTitle, DIMENSION(szTitle));
                                MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                                SetFocus(GetDlgItem(hWndDlg, IDC_CONFIGSETEDIT));
                                bFoundMatch = TRUE;
                                break;
                            }

                            lpszCur = _tcschr(lpszCur, TEXT('\0')) + 1;
                        }

                        free(lpszConfigSetNames);
                        lpszConfigSetNames = NULL;

                        if(bFoundMatch)
                            break;
                    }

                    //
                    //  Get data from other controls.
                    //

                    GetDlgItemText(hWndDlg, IDC_HOSTNAMEEDIT, g_szHostNameBuf, g_dwHostNameBufLen);
                    if(lstrlen(g_szHostNameBuf) == 0)
                    {
                        LoadString(g_hInst, IDS_EMPTYHOSTNAME, szTemp, DIMENSION(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, DIMENSION(szTitle));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_HOSTNAMEEDIT));
                        break;
                    }

                    GetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, g_szHostIPBuf, g_dwHostIPBufLen);
                    if(lstrlen(g_szHostIPBuf) == 0)
                    {
                        LoadString(g_hInst, IDS_EMPTYHOSTIP, szTemp, DIMENSION(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, DIMENSION(szTitle));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                        break;
                    }

                    //
                    //  Valid IP address?
                    //

                    if(!IsValidIP(g_szHostIPBuf))
                    {
                        LoadString(g_hInst, IDS_HOSTIP_ERROR, szTemp, DIMENSION(szTemp));
                        LoadString(g_hInst, IDS_ERROR, szTitle, DIMENSION(szTitle));
                        MessageBox(hWndDlg, szTemp, szTitle, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                        break;
                    }

                    EndDialog( hWndDlg, TRUE );
                    break;
                }
                
                case IDCANCEL:
                {
                    g_szSiteNameBuf[0] = TEXT('\0');
                    g_szHostNameBuf[0] = TEXT('\0');
                    g_szHostIPBuf[0] = TEXT('\0');

                    EndDialog( hWndDlg, FALSE );
                    break;
                }
            }                
            break;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\mru.h ===
#ifndef __MRU_H
#define __MRU_H

class PpMRU
{
public:
    PpMRU(int nSize);
    ~PpMRU();

    LPCTSTR operator [] (int nIndex);

    BOOL init();
    BOOL insert(LPCTSTR sz);
    BOOL save(LPCTSTR szSection, LPCTSTR szFilename);
    BOOL load(LPCTSTR szSection, LPCTSTR szFilename);

private:

    int     m_nSize;
    LPTSTR* m_ppszList;
};

#endif // __MRU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\message.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     MESSAGE.CPP

   PURPOSE:    Source module for Passport Manager config tool

   FUNCTIONS:

   COMMENTS:
      
**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"

struct 
{
    UINT    uErrorID;
    UINT    uWarningID;    
}  g_ControlMessageTable[] = 
{
    {IDS_TIMEWINDOW_ERROR, IDS_CONSISTENCY_WARN},       //IDC_TIMEWINDOW
    {0, IDS_CONSISTENCY_WARN},                          //IDC_FORCESIGNIN
    {IDS_LANGUAGEID_ERROR, IDS_CONSISTENCY_WARN},       //IDC_LANGUAGEID
    {IDS_COBRANDING_ERROR, IDS_CONSISTENCY_WARN},       //IDC_COBRANDING_TEMPLATE   
    {IDS_SITEID_ERROR, IDS_SITEID_WARN},                //IDC_SITEID
    {IDS_RETURNURL_ERROR, IDS_CONSISTENCY_WARN},        //IDC_RETURNURL
    {IDS_COOKIEDOMAIN_ERROR, IDS_CONSISTENCY_WARN},     //IDC_COOKIEDOMAIN
    {IDS_COOKIEPATH_ERROR, IDS_CONSISTENCY_WARN},       //IDC_COOKIEPATH
    {0, IDS_STANDALONE_WARN},                           //IDC_STANDALONE
    {0, IDS_DISABLECOOKIE_WARN},                        //IDC_DISABLECOOKIES
    {IDS_DISASTERURL_ERROR, IDS_CONSISTENCY_WARN},      //IDC_DISASTERURL
    {IDS_HOSTNAME_ERROR, IDS_CONSISTENCY_WARN},         //IDC_HOSTNAMEEDIT
    {IDS_HOSTIP_ERROR, IDS_CONSISTENCY_WARN},            //IDC_HOSTIPEDIT
    {IDS_PROFILEDOMAIN_ERROR, IDS_CONSISTENCY_WARN},    //IDC_PROFILEDOMAIN
    {IDS_PROFILEPATH_ERROR, IDS_CONSISTENCY_WARN},      //IDC_PROFILEPATH
    {IDS_SECUREDOMAIN_ERROR, IDS_CONSISTENCY_WARN},     //IDC_SECUREDOMAIN
    {IDS_SECUREPATH_ERROR, IDS_CONSISTENCY_WARN}        //IDC_SECUREPATH
};

INT_PTR CALLBACK    CommitOKDlgProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

void ReportControlMessage
(
    HWND    hWnd, 
    INT     idCtrl, 
    WORD    wMessageType
)
{
    UINT    uMBType = MB_OK;
    TCHAR   szMessageBoxTitle[MAX_TITLE];
    TCHAR   szMessage[MAX_MESSAGE];
    UINT    uID;
    
    // Load the appropriate title
    switch (wMessageType)
    {
        case VALIDATION_ERROR:
            LoadString(g_hInst, IDS_ERROR, szMessageBoxTitle, DIMENSION(szMessageBoxTitle));
            uMBType |= MB_ICONERROR;
            uID = g_ControlMessageTable[idCtrl - CTRL_BASE].uErrorID;
            break;
            
        case CHANGE_WARNING:
            LoadString(g_hInst, IDS_WARNING, szMessageBoxTitle, DIMENSION(szMessageBoxTitle));
            uMBType |= MB_ICONWARNING;
            uID = g_ControlMessageTable[idCtrl - CTRL_BASE].uWarningID;
            break;
    }
    
    // Load the appropriate message
    LoadString(g_hInst, uID, szMessage, DIMENSION(szMessage));
    MessageBox(hWnd, szMessage, szMessageBoxTitle, uMBType);               
}

BOOL CommitOKWarning
(
    HWND            hWndDlg
)
{
    if (IDOK == DialogBox( g_hInst, 
                           MAKEINTRESOURCE (IDD_CONFIRM_COMMIT), 
                           hWndDlg, 
                           CommitOKDlgProc ))
        return TRUE;
    else
        return FALSE;                                    

}

void ReportError
(
    HWND    hWndDlg,
    UINT    idError
)
{
    TCHAR   szMessageBoxTitle[MAX_TITLE];
    TCHAR   szMessage[MAX_MESSAGE];

    LoadString(g_hInst, IDS_ERROR, szMessageBoxTitle, DIMENSION(szMessageBoxTitle));
    LoadString(g_hInst, idError, szMessage, DIMENSION(szMessage));
    
    MessageBox(hWndDlg, szMessage, szMessageBoxTitle, MB_OK | MB_ICONERROR);
}

INT_PTR CALLBACK CommitOKDlgProc
(
    HWND     hWndDlg,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM   lParam
)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            TCHAR   szTemp[MAX_RESOURCE];
            TCHAR   szFields[MAX_MESSAGE];
            BOOL    bOther = FALSE;
                                    
            ShowWindow(GetDlgItem(hWndDlg, IDC_OTHERPROCESS), SW_HIDE);

            // See which of the "other" fields have been modified
            szFields[0] = '\0';
            if (g_OriginalSettings.dwTimeWindow != g_CurrentSettings.dwTimeWindow)
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_TIMEWINDOW, szTemp, DIMENSION(szTemp));
                lstrcat(szFields, szTemp);
            }
            if (g_OriginalSettings.dwForceSignIn != g_CurrentSettings.dwForceSignIn)
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_FORCESIGNIN, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {

                    //
                    // It is not good just skip if buffer overrun. In this case, we assume
                    // user would detect the skipped warning item. And it is not likely we
                    // would have buffer overrun here. If buffer is to small, we just skip
                    // for now.
                    //

                    lstrcat(szFields, szTemp);

                }
            }
            if (g_OriginalSettings.dwVerboseMode != g_CurrentSettings.dwVerboseMode)
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_VERBOSE_MODE, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (g_OriginalSettings.dwLanguageID != g_CurrentSettings.dwLanguageID)
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_LANGUAGEID, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szCoBrandTemplate, g_CurrentSettings.szCoBrandTemplate))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_COBRANDTEMPLATE, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szReturnURL, g_CurrentSettings.szReturnURL))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_RETURNURL, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szTicketDomain, g_CurrentSettings.szTicketDomain))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_COOKIEDOMAIN, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szTicketPath, g_CurrentSettings.szTicketPath))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_COOKIEPATH, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szProfileDomain, g_CurrentSettings.szProfileDomain))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_PROFILEDOMAIN, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szProfilePath, g_CurrentSettings.szProfilePath))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_PROFILEPATH, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szSecureDomain, g_CurrentSettings.szSecureDomain))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_SECUREDOMAIN, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szSecurePath, g_CurrentSettings.szSecurePath))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_SECUREPATH, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szDisasterURL, g_CurrentSettings.szDisasterURL))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_DISASTERURL, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szEnvName, g_CurrentSettings.szEnvName))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_ENVNAME, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szHostName, g_CurrentSettings.szHostName))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_HOSTNAME, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (0 != lstrcmpi(g_OriginalSettings.szHostIP, g_CurrentSettings.szHostIP))
            {
                bOther = TRUE;
                LoadString(g_hInst, IDS_HOSTIP, szTemp, DIMENSION(szTemp));
                if ((lstrlen(szFields) + lstrlen(szTemp)) < MAX_MESSAGE) {
                    lstrcat(szFields, szTemp);
                }
            }
            if (bOther)
            {
                // Kill the final comma and space, since each of the above field names has a 
                // comma and space for concatenation purposes
                szFields[lstrlen(szFields)-2] ='\0';  
                SetDlgItemText(hWndDlg, IDC_OTHER_TYPE, szFields);
            }
            else
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_OTHER_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_OTHER_WARN), SW_HIDE);
            }

            // See if DisableCookies has been changed
            if (g_OriginalSettings.dwDisableCookies == g_CurrentSettings.dwDisableCookies)
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_COOKIES_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_COOKIES_WARN), SW_HIDE);
            }

            // See if SiteID has been changed
            if (g_OriginalSettings.dwSiteID == g_CurrentSettings.dwSiteID)
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_SITEID_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_SITEID_WARN), SW_HIDE);
            }

            // See if StandAlone Mode has been changed
            if (g_OriginalSettings.dwStandAlone == g_CurrentSettings.dwStandAlone)
            {
                ShowWindow(GetDlgItem(hWndDlg,IDC_STANDALONE_TYPE), SW_HIDE);
                ShowWindow(GetDlgItem(hWndDlg,IDC_STANDALONE_WARN), SW_HIDE);
            }
            return TRUE;
        }
        
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    EndDialog( hWndDlg, TRUE );
                    break;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hWndDlg, FALSE );
                    break;
                }
            }                
            break;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\mru.cpp ===
#include "pmcfg.h"
#include "mru.h"


PpMRU::PpMRU(int nSize) : m_nSize(nSize), m_ppszList(NULL)
{
}


BOOL
PpMRU::init()
{
    m_ppszList = new LPTSTR[m_nSize];

    if (m_ppszList == NULL)
    {
        return FALSE;
    }

    ZeroMemory(m_ppszList, m_nSize * sizeof(LPTSTR));

    return TRUE;
}


PpMRU::~PpMRU()
{
    int nIndex;

    if(m_ppszList)
    {
        for(nIndex = 0; nIndex < m_nSize; nIndex++)
        {
            if(m_ppszList[nIndex])
                delete [] m_ppszList[nIndex];
        }

        delete [] m_ppszList;
    }
}


BOOL
PpMRU::insert
(
    LPCTSTR sz
)
{
    int     nIndex;
    LPTSTR  szNew;

    //
    //  If the string is already in the list, just
    //  reshuffle so that it is at the top.  Even 
    //  simpler, if the string is already the first
    //  item in the list then do nothing!
    //

    if(m_ppszList[0] && lstrcmp(sz, m_ppszList[0]) == 0)
        return TRUE;

    for(nIndex = 1; nIndex < m_nSize && m_ppszList[nIndex]; nIndex++)
    {
        if(lstrcmp(sz, m_ppszList[nIndex]) == 0)
        {
            LPTSTR szTemp = m_ppszList[nIndex];
            for(int nIndex2 = nIndex; nIndex2 > 0; nIndex2--)
                m_ppszList[nIndex2] = m_ppszList[nIndex2 - 1];

            m_ppszList[0] = szTemp;
            return TRUE;            
        }
    }

    //
    //  New item in list.  Allocate memory, copy and 
    //  shove list down.
    //

    szNew = new TCHAR[lstrlen(sz) + 1];
    if(!szNew)
        return FALSE;

    lstrcpy(szNew, sz);

    if(m_ppszList[m_nSize - 1])
        delete [] m_ppszList[m_nSize - 1];

    for(nIndex = m_nSize - 1; nIndex > 0; nIndex--)
    {
        m_ppszList[nIndex] = m_ppszList[nIndex - 1];
    }

    m_ppszList[0] = szNew;

    return TRUE;
}


LPCTSTR
PpMRU::operator[]
(
    int nIndex
)
{
    return m_ppszList[nIndex];
}


BOOL
PpMRU::load
(
    LPCTSTR szSection,
    LPCTSTR szFilename
)
{
    int     nIndex;
    TCHAR   achNumBuf[20];
    TCHAR   achBuf[MAX_PATH];

    for(nIndex = 0; nIndex < m_nSize; nIndex++)
    {
        _itot(nIndex + 1, achNumBuf, 10);

        GetPrivateProfileString(szSection, 
                                achNumBuf, 
                                TEXT(""), 
                                achBuf, 
                                MAX_PATH, 
                                szFilename);

        if(lstrlen(achBuf))
        {
            m_ppszList[nIndex] = new TCHAR[lstrlen(achBuf) + 1];
            if(m_ppszList[nIndex])
                lstrcpy(m_ppszList[nIndex], achBuf);
        }
        else
        {
            m_ppszList[nIndex] = NULL;
        }
    }

    return TRUE;
}


BOOL
PpMRU::save
(
    LPCTSTR szSection,
    LPCTSTR szFilename
)
{
    int     nIndex;
    TCHAR   achNumBuf[20];

    //  Make sure any previously existing section is erased.
    WritePrivateProfileString(szSection, NULL, NULL, szFilename);

    //  Now save all the entries.
    for(nIndex = 0; nIndex < m_nSize && m_ppszList[nIndex]; nIndex++)
    {
        _itot(nIndex + 1, achNumBuf, 10);

        WritePrivateProfileString(szSection,
                                  achNumBuf,
                                  m_ppszList[nIndex],
                                  szFilename
                                  );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\envchange.cpp ===
#include "pmcfg.h"
#include <shlobj.h>
#include <shlwapi.h>


DWORD   g_dwEnvNameBufLen;
LPTSTR  g_szEnvNameBuf;
LPTSTR  g_szCurrEnv;
LPTSTR  g_szCurrDesc;
TCHAR   g_szDescProduction[MAX_MESSAGE];
TCHAR   g_szDescPreProduction[MAX_MESSAGE];
TCHAR   g_szDescBetaPreProduction[MAX_MESSAGE];
TCHAR   g_szDescOther[MAX_MESSAGE];
TCHAR   g_szProduction[MAX_RESOURCE];
TCHAR   g_szPreProduction[MAX_RESOURCE];
TCHAR   g_szBetaPreProduction[MAX_RESOURCE];
TCHAR   g_szOther[MAX_RESOURCE];

// unfortunately the registry stores the environment as a string in the registry and
// this string is not localized.  So in the registry we use english strings and in
// UI we use localized versions of these strings.
WCHAR   g_szEnglishProduction[] = L"Production";
WCHAR   g_szEnglishPreProduction[] = L"PreProduction";
WCHAR   g_szEnglishBetaPreProduction[] = L"BetaPreProduction";
WCHAR   g_szEnglishOther[] = L"Other";

TCHAR   g_szCurrChoice[MAX_RESOURCE];
int		g_iOrigChoice;
int		g_iCurrChoice;
TCHAR   g_szTempRemoteFile[INTERNET_MAX_URL_LENGTH];

INT_PTR CALLBACK    EnvChangeDlgProc(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL EnvChange
(
    HWND            hWndDlg,
    LPTSTR          szEnvNameBuf,
    DWORD           dwEnvNameBufLen
)
{
    g_dwEnvNameBufLen = dwEnvNameBufLen;
    g_szEnvNameBuf    = szEnvNameBuf;
	LoadString(g_hInst, IDS_PRODUCTION, g_szProduction, DIMENSION(g_szProduction));
	LoadString(g_hInst, IDS_PREPRODUCTION, g_szPreProduction, DIMENSION(g_szPreProduction));
	LoadString(g_hInst, IDS_BETAPREPRODUCTION, g_szBetaPreProduction, DIMENSION(g_szBetaPreProduction));
	LoadString(g_hInst, IDS_OTHER, g_szOther, DIMENSION(g_szOther));
	LoadString(g_hInst, IDS_PROD_DESC, g_szDescProduction, DIMENSION(g_szDescProduction));
	LoadString(g_hInst, IDS_PREP_DESC, g_szDescPreProduction, DIMENSION(g_szDescPreProduction));
	LoadString(g_hInst, IDS_BETA_DESC, g_szDescBetaPreProduction, DIMENSION(g_szDescBetaPreProduction));
	LoadString(g_hInst, IDS_OTHER_DESC, g_szDescOther, DIMENSION(g_szDescOther));
	if(lstrcmp(g_szEnvNameBuf, g_szEnglishPreProduction) == 0)
		g_iOrigChoice = IDC_PREPRODUCTION;
	else if(lstrcmp(g_szEnvNameBuf, g_szEnglishBetaPreProduction) == 0)
		g_iOrigChoice = IDC_BETA_PREPRODUCTION;
	else if(lstrcmp(g_szEnvNameBuf, g_szEnglishOther) == 0)
		g_iOrigChoice = IDC_OTHER;
	else // must be Production
		g_iOrigChoice = IDC_PRODUCTION;

    if (IDOK == DialogBox( g_hInst, 
                           MAKEINTRESOURCE (IDD_ENV_CHANGE), 
                           hWndDlg, 
                           EnvChangeDlgProc ))
        return TRUE;
    else
        return FALSE;                                    

}


INT_PTR  CALLBACK EnvChangeDlgProc(HWND hWndDlg, UINT message, WPARAM wParam, 
                         LPARAM lParam) 
{ 
 
    switch (message) 
    { 
        case WM_INITDIALOG:
			CheckRadioButton(
				hWndDlg,          // handle to dialog box
				IDC_PRODUCTION, // identifier of first button in group
				IDC_OTHER,  // identifier of last button in group
				g_iOrigChoice  // identifier of button to select
				);
			g_iCurrChoice = g_iOrigChoice;

			if (g_iCurrChoice == IDC_PREPRODUCTION)
				g_szCurrDesc = g_szDescPreProduction;
			else if(g_iCurrChoice == IDC_BETA_PREPRODUCTION)
				g_szCurrDesc = g_szDescBetaPreProduction;
			else if(g_iCurrChoice == IDC_OTHER)
				g_szCurrDesc = g_szDescOther;
			else
				g_szCurrDesc = g_szDescProduction;

			SetDlgItemText(hWndDlg, IDC_DESC, g_szCurrDesc);

			// Remote File
			if (g_iCurrChoice == IDC_OTHER)
			{
				EnableWindow(GetDlgItem(hWndDlg, IDC_REMOTEFILE), TRUE);
				SetDlgItemText(hWndDlg, IDC_REMOTEFILE, g_CurrentSettings.szRemoteFile);
				SendDlgItemMessage(hWndDlg, IDC_REMOTEFILE, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);
				lstrcpy(g_szTempRemoteFile, g_CurrentSettings.szRemoteFile);
			}
			else
			{
				EnableWindow(GetDlgItem(hWndDlg, IDC_REMOTEFILE), FALSE);
			}
			break;
 

        case WM_COMMAND: 
				switch (LOWORD(wParam))
				{
					case IDC_MOREINFO:
					{
					    TCHAR   szURL[MAX_PATH];
                        lstrcpy(szURL, _T("http://www.passport.com/devinfo/Setup_Environments.asp"));
					    ShellExecute(hWndDlg, _T("open"), szURL, NULL, NULL, 0);
						return TRUE;
					}

					case IDOK:
					{

						// Same choice. Do nothing  
						if (g_iCurrChoice == g_iOrigChoice &&
							!(g_iCurrChoice == IDC_OTHER && lstrcmpi(g_CurrentSettings.szRemoteFile, g_szTempRemoteFile) != 0)  )
						{
							EndDialog( hWndDlg, TRUE );
							return TRUE;
						}
						else // different choice
						{
						    if (g_iCurrChoice == IDC_PREPRODUCTION)
							    g_szCurrEnv = g_szEnglishPreProduction;
						    else if(g_iCurrChoice == IDC_BETA_PREPRODUCTION)
							    g_szCurrEnv = g_szEnglishBetaPreProduction;
						    else if(g_iCurrChoice == IDC_OTHER)
							    g_szCurrEnv = g_szEnglishOther;
						    else // default
							    g_szCurrEnv = g_szEnglishProduction;

						    // update curr RemoteFile and EnvName
						    if (ReadRegRemoteFile(hWndDlg, g_CurrentSettings.szRemoteFile, g_szRemoteComputer, g_szCurrEnv))
							    lstrcpy(g_CurrentSettings.szEnvName, g_szCurrEnv);
						    // get RemoteFile for Other
						    if (g_iCurrChoice == IDC_OTHER && lstrcmpi(g_CurrentSettings.szRemoteFile, g_szTempRemoteFile) != 0 )
                            {
							    lstrcpy(g_CurrentSettings.szRemoteFile, g_szTempRemoteFile);
							    lstrcpy(g_CurrentSettings.szEnvName, g_szCurrEnv);
                            }
						    else if (g_iCurrChoice == IDC_OTHER)
						    {
							    EndDialog( hWndDlg, TRUE );
							    return TRUE;
						    }

						    EndDialog( hWndDlg, TRUE );
						    return TRUE;
						}
					}
                
					case IDCANCEL:
					{

						EndDialog( hWndDlg, FALSE );
						return TRUE;
					}

                case IDC_REMOTEFILE:
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            // Get the updated Value
                            GetDlgItemText(hWndDlg, 
                                           IDC_REMOTEFILE, 
                                           g_szTempRemoteFile,
                                           g_CurrentSettings.cbRemoteFile);                                

                            break;                                
                            
                        case EN_MAXTEXT:
                        {
                            ReportControlMessage(hWndDlg, LOWORD(wParam), VALIDATION_ERROR);
                            break;
                        }   
                    }
                    break;
                }
 
                if (HIWORD(wParam) == BN_CLICKED) 
                { 
                    switch (LOWORD(wParam)) 
                    { 
                        case IDC_PRODUCTION: 
                        case IDC_PREPRODUCTION: 
                        case IDC_BETA_PREPRODUCTION: 
							EnableWindow(GetDlgItem(hWndDlg, IDC_REMOTEFILE), FALSE);
							g_szTempRemoteFile[0] = '\0';
							SetDlgItemText(hWndDlg, IDC_REMOTEFILE, g_szTempRemoteFile);
							g_iCurrChoice = LOWORD(wParam);
                            break; 
                        case IDC_OTHER: 
							EnableWindow(GetDlgItem(hWndDlg, IDC_REMOTEFILE), TRUE);
							SendDlgItemMessage(hWndDlg, IDC_REMOTEFILE, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);
							if (ReadRegRemoteFile(hWndDlg, g_szTempRemoteFile, g_szRemoteComputer, g_szEnglishOther))
								SetDlgItemText(hWndDlg, IDC_REMOTEFILE, g_szTempRemoteFile);
							g_iCurrChoice = LOWORD(wParam);
                            break; 
                    } 

					if (g_iCurrChoice == IDC_PREPRODUCTION)
						g_szCurrDesc = g_szDescPreProduction;
					else if(g_iCurrChoice == IDC_BETA_PREPRODUCTION)
						g_szCurrDesc = g_szDescBetaPreProduction;
					else if(g_iCurrChoice == IDC_OTHER)
						g_szCurrDesc = g_szDescOther;
					else
						g_szCurrDesc = g_szDescProduction;

					SetDlgItemText(hWndDlg, IDC_DESC, g_szCurrDesc);
                } 
 
 
    } 
    return FALSE;       // did not process a message 
    UNREFERENCED_PARAMETER(lParam); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\filecfg.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     FILECFG.CPP

   PURPOSE:    Source module reading/writing PM config sets from a file

   FUNCTIONS:

   COMMENTS:
      
**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"

#define MAX_EXT     10
#define MAX_FILTER  256

TCHAR g_szPassportManager[] = TEXT("PassportManager");

/**************************************************************************

    PMAdmin_GetFileName

*******************************************************************************/
BOOL PMAdmin_GetFileName
(
    HWND    hWnd,
    BOOL    fOpen,
    LPTSTR  lpFileName,
    DWORD   cbFileName
)
{
    UINT            TitleStringID, FilterID;
    TCHAR           szTitle[MAX_TITLE];
    TCHAR           szDefaultExtension[MAX_EXT];
    TCHAR           szFilter[MAX_FILTER];
    LPTSTR          lpFilterChar;
    OPENFILENAME    OpenFileName;
    BOOL            fSuccess;

    //
    //  Load various strings that will be displayed and used by the common open
    //  or save dialog box.  Note that if any of these fail, the error is not
    //  fatal-- the common dialog box may look odd, but will still work.
    //

    if (fOpen)
    {
        TitleStringID = IDS_OPENFILETITLE;
        FilterID = IDS_PMOPENFILEFILTER;
    }
    else
    {
        TitleStringID = IDS_SAVEFILETITLE;
        FilterID = IDS_PMSAVEFILEFILTER;
    }        

    LoadString(g_hInst, TitleStringID, szTitle, DIMENSION(szTitle));
    LoadString(g_hInst, IDS_PMCONFIGDEFEXT, szDefaultExtension, DIMENSION(szDefaultExtension));

    if (LoadString(g_hInst, FilterID, szFilter, DIMENSION(szFilter)))
    {
        //
        //  The common dialog library requires that the substrings of the
        //  filter string be separated by nulls, but we cannot load a string
        //  containing nulls.  So we use some dummy character in the resource
        //  that we now convert to nulls.
        //
        for (lpFilterChar = szFilter; 
             *lpFilterChar != 0; 
              lpFilterChar = CharNext(lpFilterChar)) 
        {

            if (*lpFilterChar == TEXT('#'))
                *lpFilterChar++ = 0;
        }
    }

    ZeroMemory(&OpenFileName, sizeof(OPENFILENAME));

    OpenFileName.lStructSize = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner = hWnd;
    OpenFileName.hInstance = g_hInst;
    OpenFileName.lpstrFilter = szFilter;
    OpenFileName.lpstrFile = lpFileName;
    OpenFileName.nMaxFile = cbFileName;
    OpenFileName.lpstrTitle = szTitle;
    OpenFileName.lpstrDefExt = szDefaultExtension;
    if (fOpen) 
    {
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_FILEMUSTEXIST;
        fSuccess = GetOpenFileName(&OpenFileName);
    }
    else 
    {
        OpenFileName.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT |
            OFN_EXPLORER | OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST;
        fSuccess = GetSaveFileName(&OpenFileName);
    }
    return fSuccess;
}

// prototype of function implemented in regcfg.cpp
BOOL OpenTopRegKey
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteComputer,
    HKEY            *phklm,
    HKEY            *phkeyPassport
);

/**************************************************************************

    ReadFileConfigSet
    
    Read the current passport manager config set from the specified file
    
**************************************************************************/
BOOL ReadFileConfigSet
(
    LPPMSETTINGS    lpPMConfig,
    LPCTSTR         lpszFileName
)
{
    HKEY  hklm = 0;
    HKEY  hkeyPassport = 0;
    DWORD dwTemp;
    TCHAR achTemp[INTERNET_MAX_URL_LENGTH];

    // makesure the specified file exists.
    if (!PathFileExists(lpszFileName))
    {
        ReportError(NULL, IDS_FILENOTFOUND);
        return FALSE;
    }

    // make sure this user can save any changes, if not simply bail
    if (!OpenTopRegKey(NULL, g_szRemoteComputer, &hklm, &hkeyPassport))
    {
        if (hklm && hklm != HKEY_LOCAL_MACHINE)
            RegCloseKey(hklm);
        return FALSE;
    }
    RegCloseKey(hkeyPassport);
    if (hklm != HKEY_LOCAL_MACHINE)
        RegCloseKey(hklm);

    // Zero Init the structure
    ZeroMemory(lpPMConfig, sizeof(PMSETTINGS));

    // Read the Time Window Number
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szTimeWindow,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwTimeWindow = dwTemp;
        
    // Read the value for Forced Signin
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szForceSignIn,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwForceSignIn = dwTemp;

    // Read the value for NSRefresh
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szNSRefresh,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwEnableManualRefresh = dwTemp;

    // Read the default language ID
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szLanguageID,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwLanguageID = dwTemp;

    // Get the co-branding template

    GetPrivateProfileString(g_szPassportManager,
                            g_szCoBrandTemplate,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);

    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szCoBrandTemplate, achTemp);

    
    // Get the SiteID
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szSiteID,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwSiteID = dwTemp;
    
    // Get the return URL template

    GetPrivateProfileString(g_szPassportManager,
                            g_szReturnURL,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);

    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szReturnURL, achTemp);

    // Get the ticket cookie domain

    GetPrivateProfileString(g_szPassportManager,
                            g_szTicketDomain,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);

    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szTicketDomain, achTemp);

    // Get the ticket cookie path

    GetPrivateProfileString(g_szPassportManager,
                            g_szTicketPath,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);

    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szTicketPath, achTemp);

    // Get the profile cookie domain
    GetPrivateProfileString(g_szPassportManager,
                            g_szProfileDomain,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szProfileDomain, achTemp);

    // Get the profile cookie path
    GetPrivateProfileString(g_szPassportManager,
                            g_szProfilePath,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szProfilePath, achTemp);

    // Get the secure cookie domain
    GetPrivateProfileString(g_szPassportManager,
                            g_szSecureDomain,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szSecureDomain, achTemp);

    // Get the secure cookie path
    GetPrivateProfileString(g_szPassportManager,
                            g_szSecurePath,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szSecurePath, achTemp);

    // Get the DisasterURL
    GetPrivateProfileString(g_szPassportManager,
                            g_szDisasterURL,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szDisasterURL, achTemp);

    // Get Standalone mode setting
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szStandAlone,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwStandAlone = dwTemp;
    
    // Get DisableCookies mode setting
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szDisableCookies,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwDisableCookies = dwTemp;

    // Get the HostName
    GetPrivateProfileString(g_szPassportManager,
                            g_szHostName,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpyn(lpPMConfig->szHostName, achTemp, DIMENSION(lpPMConfig->szHostName));

    // Get the HostIP
    GetPrivateProfileString(g_szPassportManager,
                            g_szHostIP,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpyn(lpPMConfig->szHostIP, achTemp, DIMENSION(lpPMConfig->szHostIP));

    // Get the Verbose Mode
    dwTemp = GetPrivateProfileInt(g_szPassportManager,
                                  g_szVerboseMode,
                                  -1,
                                  lpszFileName);
    if(dwTemp != -1)
        lpPMConfig->dwVerboseMode = dwTemp;


    // Get the EnvName
    GetPrivateProfileString(g_szPassportManager,
                            g_szEnvName,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpyn(lpPMConfig->szEnvName, achTemp, DIMENSION(lpPMConfig->szEnvName));

    // Get the RemoteFile
    GetPrivateProfileString(g_szPassportManager,
                            g_szRemoteFile,
                            (LPTSTR)TEXT("\xFF"),
                            achTemp,
                            DIMENSION(achTemp),
                            lpszFileName);
    if(lstrcmp(achTemp, TEXT("\xFF")) != 0)
        lstrcpy(lpPMConfig->szRemoteFile, achTemp);

    return TRUE; 
}


/**************************************************************************

    WriteFileConfigSet
    
    Writes the current passport manager config set to the specified file
    
**************************************************************************/
BOOL WriteFileConfigSet
(
    LPPMSETTINGS    lpPMConfig,
    LPCTSTR         lpszFileName
)
{
    TCHAR   szTemp[MAX_PATH];
    
    // Write the Time Window Number
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwTimeWindow);
    WritePrivateProfileString(g_szPassportManager,
                              g_szTimeWindow,
                              szTemp,
                              lpszFileName);
        
    // write the value for Forced Signin
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwForceSignIn);
    WritePrivateProfileString(g_szPassportManager,
                              g_szForceSignIn,
                              szTemp,
                              lpszFileName);

    // write the value for NSRefresh
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwEnableManualRefresh);
    WritePrivateProfileString(g_szPassportManager,
                              g_szNSRefresh,
                              szTemp,
                              lpszFileName);

    // Read the default language ID
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwLanguageID);
    WritePrivateProfileString(g_szPassportManager,
                              g_szLanguageID,
                              szTemp,
                              lpszFileName);
                              
    // Write the co-branding template
    WritePrivateProfileString(g_szPassportManager,
                             g_szCoBrandTemplate,
                             lpPMConfig->szCoBrandTemplate,
                             lpszFileName);
    
    // Write the SiteID
    wsprintf (szTemp, TEXT("%lu"),lpPMConfig->dwSiteID);
    WritePrivateProfileString(g_szPassportManager,
                              g_szSiteID,
                              szTemp,
                              lpszFileName);
    
    // Write the return URL template
    WritePrivateProfileString(g_szPassportManager,
                              g_szReturnURL,
                              lpPMConfig->szReturnURL,
                              lpszFileName);
    
    // Write the ticket cookie domain
    WritePrivateProfileString(g_szPassportManager,
                              g_szTicketDomain,
                              lpPMConfig->szTicketDomain,
                              lpszFileName);
    
    // Write the ticket cookie path
    WritePrivateProfileString(g_szPassportManager,
                              g_szTicketPath,
                              lpPMConfig->szTicketPath,
                              lpszFileName);

    // Write the profile cookie domain
    WritePrivateProfileString(g_szPassportManager,
                              g_szProfileDomain,
                              lpPMConfig->szProfileDomain,
                              lpszFileName);
    
    // Write the profile cookie path
    WritePrivateProfileString(g_szPassportManager,
                              g_szProfilePath,
                              lpPMConfig->szProfilePath,
                              lpszFileName);

    // Write the secure cookie domain
    WritePrivateProfileString(g_szPassportManager,
                              g_szSecureDomain,
                              lpPMConfig->szSecureDomain,
                              lpszFileName);

    // Write the secure profile cookie path
    WritePrivateProfileString(g_szPassportManager,
                              g_szSecurePath,
                              lpPMConfig->szSecurePath,
                              lpszFileName);

    // Write the Disaster URL
    WritePrivateProfileString(g_szPassportManager,
                              g_szDisasterURL,
                              lpPMConfig->szDisasterURL,
                              lpszFileName);
    
    // Write Standalone mode setting
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwStandAlone);
    WritePrivateProfileString(g_szPassportManager,
                           g_szStandAlone,
                           szTemp,
                           lpszFileName);
    
    // Write DisableCookies mode setting
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwDisableCookies);
    WritePrivateProfileString(g_szPassportManager,
                              g_szDisableCookies,
                              szTemp,
                              lpszFileName);

    // Write the Host Name
    WritePrivateProfileString(g_szPassportManager,
                              g_szHostName,
                              lpPMConfig->szHostName,
                              lpszFileName);
    
    // Write the Host IP
    WritePrivateProfileString(g_szPassportManager,
                              g_szHostIP,
                              lpPMConfig->szHostIP,
                              lpszFileName);
    
    // Write the Verbose Mode
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwVerboseMode);
    WritePrivateProfileString(g_szPassportManager,
                              g_szVerboseMode,
                              szTemp,
                              lpszFileName);
    
    // Write the EnvName
    WritePrivateProfileString(g_szPassportManager,
                              g_szEnvName,
                              lpPMConfig->szEnvName,
                              lpszFileName);
    
    // Write the RemoteFile
    WritePrivateProfileString(g_szPassportManager,
                              g_szRemoteFile,
                              lpPMConfig->szRemoteFile,
                              lpszFileName);
    
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\pmcfg.h ===
// Pre-compiled header for Passport Manager config/admin tool

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <winsock2.h>
#include <wininet.h>        // for INTERNET_MAX_URL_LENGTH
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>

#include <tchar.h>

#include "resource.h"
#include "pmhelp.h"
#include "mru.h"

#ifndef GET_WM_COMMAND_ID

#define GET_WM_COMMAND_ID(wp, lp)               (wp)
#define GET_WM_COMMAND_HWND(wp, lp)             (HWND)(LOWORD(lp))
#define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)

#endif

#ifdef WIN32
   #define CBACK  CALLBACK
#else
   #define CBACK  _export CALLBACK
#endif

// macros
#define DIMENSION(a) (sizeof(a) / sizeof(a[0]))


// constant defines
#define MAX_REGISTRY_STRING     256
#define DEFAULT_TIME_WINDOW     1800
#define MIN_TIME_WINDOW_SECONDS 100
#define MAX_TIME_WINDOW_SECONDS 1000000
#define DEFAULT_LANGID          1033
const DWORD MAX_SITEID = 0xFFFFFFFF;
//#define MAX_SITEID              0xFFFFFFFF
#define PRODUCTID_LEN           24

#define MAX_TITLE               80
#define MAX_MESSAGE             1024
#define MAX_RESOURCE            255
#define MAX_CONFIGSETNAME       256
#define MAX_IPLEN               16
#define MAX_ENVNAME             256

#define SECONDS_PER_MIN         60
#define SECONDS_PER_HOUR        (60 * SECONDS_PER_MIN)
#define SECONDS_PER_DAY         (24 * SECONDS_PER_HOUR)

#define VALIDATION_ERROR            1
#define CHANGE_WARNING              2

#define COMPUTER_MRU_SIZE       4
#define FILE_MRU_SIZE           4

// Type defines
typedef struct PMSettings_tag
{
    DWORD       dwTimeWindow;                                // Time Window in Seconds
    DWORD       dwForceSignIn;
    DWORD       dwLanguageID;
    TCHAR       szCoBrandTemplate[INTERNET_MAX_URL_LENGTH];
    DWORD       cbCoBrandTemplate;                           // Size of the CobBrand template buffer
    DWORD       dwSiteID;
    TCHAR       szReturnURL[INTERNET_MAX_URL_LENGTH];
    DWORD       cbReturnURL;                                 // Size of the ReturnURL buffer
    TCHAR       szTicketDomain[INTERNET_MAX_URL_LENGTH];
    DWORD       cbTicketDomain;                              // Size of the CookieDomain buffer
    TCHAR       szTicketPath[INTERNET_MAX_URL_LENGTH];
    DWORD       cbTicketPath;                                // Size of the CookiePath buffer
    TCHAR       szProfileDomain[INTERNET_MAX_URL_LENGTH];
    DWORD       cbProfileDomain;                             // Size of the CookieDomain buffer
    TCHAR       szProfilePath[INTERNET_MAX_URL_LENGTH];
    DWORD       cbProfilePath;                               // Size of the CookiePath buffer
    TCHAR       szSecureDomain[INTERNET_MAX_URL_LENGTH];
    DWORD       cbSecureDomain;                              // Size of the CookiePath buffer
    TCHAR       szSecurePath[INTERNET_MAX_URL_LENGTH];
    DWORD       cbSecurePath;                                // Size of the CookiePath buffer
    TCHAR       szDisasterURL[INTERNET_MAX_URL_LENGTH];
    DWORD       cbDisasterURL;                               // Size of the DisasterURL buffer

#ifdef DO_KEYSTUFF
    DWORD       dwCurrentKey;
#endif
    DWORD       dwDisableCookies;
    DWORD       dwStandAlone;

    TCHAR       szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD       cbHostName;
    TCHAR       szHostIP[MAX_IPLEN];
    DWORD       cbHostIP;

	//JVP - 3/2/2000
	DWORD		dwVerboseMode;

    TCHAR       szEnvName[MAX_ENVNAME];
    DWORD       cbEnvName;
    TCHAR       szRemoteFile[INTERNET_MAX_URL_LENGTH];
    DWORD       cbRemoteFile;                               // Size of the RemoteFile buffer

	DWORD		dwEnableManualRefresh;

    DWORD       dwSecureLevel;
} PMSETTINGS, FAR * LPPMSETTINGS;

typedef struct LanguageIDMap_tag
{
    WORD    wLangID;
    LPCTSTR lpszLang;
} LANGIDMAP, FAR * LPLANGIDMAP;


// declarations for globals that are shared across modules
extern TCHAR       g_szTRUE[];
extern TCHAR       g_szFALSE[];
extern TCHAR       g_szYes[];
extern TCHAR       g_szNo[];
extern HINSTANCE   g_hInst;
extern HWND        g_hwndMain;
extern PMSETTINGS  g_CurrentSettings;
extern PMSETTINGS  g_OriginalSettings;
extern TCHAR       g_szClassName[];
extern LANGIDMAP   g_szLanguageIDMap[];
extern TCHAR       g_szInstallPath[];
extern TCHAR       g_szPMVersion[];
extern TCHAR       g_szHelpFileName[];
extern TCHAR       g_szRemoteComputer[];
extern TCHAR       g_szPassportReg[];
extern TCHAR       g_szPassportSites[];
extern PpMRU       g_ComputerMRU;

// These globals are shared by the reg and file config read/write functions
extern TCHAR       g_szEncryptionKeyData[];
extern TCHAR       g_szInstallDir[];
extern TCHAR       g_szVersion[];
extern TCHAR       g_szTimeWindow[];
extern TCHAR       g_szForceSignIn[];
extern TCHAR       g_szNSRefresh[];
extern TCHAR       g_szLanguageID[];
extern TCHAR       g_szCoBrandTemplate[];
extern TCHAR       g_szSiteID[];
extern TCHAR       g_szReturnURL[];
extern TCHAR       g_szTicketDomain[];
extern TCHAR       g_szTicketPath[];
extern TCHAR       g_szProfileDomain[];
extern TCHAR       g_szProfilePath[];
extern TCHAR       g_szSecureDomain[];
extern TCHAR       g_szSecurePath[];
extern TCHAR       g_szCurrentKey[];
extern TCHAR       g_szStandAlone[];
extern TCHAR       g_szDisableCookies[];
extern TCHAR       g_szDisasterURL[];
extern TCHAR       g_szHostName[];
extern TCHAR       g_szHostIP[];
extern TCHAR       g_szVerboseMode[];
extern TCHAR       g_szEnvName[];
extern TCHAR       g_szRemoteFile[];
extern TCHAR       g_szVersion14[];

// declaractions for functions that are shared across modules
BOOL ReadRegConfigSet(HWND hWndDlg, LPPMSETTINGS  lpPMConfig, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName = NULL);
BOOL WriteRegConfigSet(HWND hWndDlg, LPPMSETTINGS  lpPMConfig, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName = NULL);
BOOL RemoveRegConfigSet(HWND hWndDlg, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName);
BOOL VerifyRegConfigSet(HWND hWndDlg, LPPMSETTINGS lpPMConfig, LPTSTR lpszRemoteComputer, LPTSTR lpszConfigSetName = NULL);

BOOL ReadRegConfigSetNames(HWND hWndDlg, LPTSTR lpszRemoteComputer, LPTSTR* lppszConfigSetNames);

void InitializePMConfigStruct(LPPMSETTINGS lpPMConfig);

void ReportControlMessage(HWND hWnd, INT idCtrl, WORD wMessageType);
BOOL CommitOKWarning(HWND hWndDlg);
void ReportError(HWND hWndDlg, UINT idError);

BOOL PMAdmin_OnCommandConnect(HWND hWnd, LPTSTR  lpszRemoteName);

BOOL PMAdmin_GetFileName(HWND hWnd, BOOL fOpen, LPTSTR lpFileName, DWORD cbFileName);
BOOL ReadFileConfigSet(LPPMSETTINGS lpPMConfig, LPCTSTR lpszFileName);
BOOL WriteFileConfigSet(LPPMSETTINGS lpPMConfig, LPCTSTR lpszFileName);

BOOL NewConfigSet(HWND      hWndDlg,
                  LPTSTR    szSiteNameBuf,
                  DWORD     dwBufLen,
                  LPTSTR    szHostNameBuf,
                  DWORD     dwHostNameLen,
                  LPTSTR    szHostIPBuf,
                  DWORD     dwHostIPLen);

BOOL RemoveConfigSetWarning(HWND hWndDlg);

BOOL IsValidIP(LPCTSTR lpszIP);

BOOL EnvChange
(
    HWND            hWndDlg,
    LPTSTR          szEnvNameBuf,
    DWORD           dwEnvNameBufLen
);

BOOL WriteRegEnv
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    HKEY            hklm,
    LPTSTR          lpszEnvName
);

BOOL ReadRegRemoteFile
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteFile,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszEnvName
);

BOOL ReadRegLocalFile
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszLocalFile
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\pmconfig.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     PMCONFIG.CPP

   PURPOSE:    Source module for Passport Manager config tool

   FUNCTIONS:

   COMMENTS:

**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"
#include <htmlhelp.h>
#include <ntverp.h>
#include <passport.h>

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

MIDL_DEFINE_GUID(CLSID,IID_IPassportAdmin,0xA0082CF5,0xAFF5,0x11D2,0x95,0xE3,0x00,0xC0,0x4F,0x8E,0x7A,0x70);
MIDL_DEFINE_GUID(CLSID,CLSID_Admin,0xA0082CF6,0xAFF5,0x11D2,0x95,0xE3,0x00,0xC0,0x4F,0x8E,0x7A,0x70);

/**************************************************************************
   Local Function Prototypes
**************************************************************************/

int WINAPI          WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    DlgMain(HWND hWndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

/**************************************************************************
   Global Variables
**************************************************************************/


// Globals
HINSTANCE   g_hInst;
HWND        g_hwndMain = 0;
HWND        g_hwndMainDlg = 0;
PMSETTINGS  g_OriginalSettings;
PMSETTINGS  g_CurrentSettings;
TCHAR       g_szDlgClassName[] = TEXT("PassportManagerAdminClass");
TCHAR       g_szClassName[] = TEXT("PassportManagerMainWindowClass");
BOOL        g_bCanUndo;
DWORD       g_dwRefreshNetMap = 0;
TCHAR       g_szInstallPath[MAX_PATH];
TCHAR       g_szPMVersion[MAX_REGISTRY_STRING];
TCHAR       g_szPMOpsHelpFileRelativePath[] = TEXT("sdk\\Passport_SDK.chm");
TCHAR       g_szPMAdminBookmark[] = TEXT("/Reference/operations/Passport_Admin.htm");

TCHAR       g_szRemoteComputer[MAX_PATH] = {L'\0'};
TCHAR       g_szNewRemoteComputer[MAX_PATH];
TCHAR       g_szConfigFile[MAX_PATH];
TCHAR       g_szConfigSet[MAX_CONFIGSETNAME] = {L'\0'};
TCHAR       g_szHelpFileName[MAX_PATH];

PpMRU       g_ComputerMRU(COMPUTER_MRU_SIZE);

// unfortunately the registry stores the environment as a string in the registry and
// this string is not localized.  So in the registry we use english strings and in
// UI we use localized versions of these strings.
extern WCHAR   g_szEnglishProduction[];
extern WCHAR   g_szEnglishPreProduction[];
extern WCHAR   g_szEnglishBetaPreProduction[];
extern WCHAR   g_szEnglishOther[];

// Global constant strings
TCHAR       g_szYes[] = TEXT("Yes");
TCHAR       g_szNo[] = TEXT("No");
TCHAR       g_szUnknown[] = TEXT("Unknown");
BOOL        g_fFromFile = FALSE;


#define MAX_LCID_VALUE  40
// NOTE: 667507: The language strings below are no longer used!  The function szLanguageName
//  derives these from common system data.
LANGIDMAP   g_szLanguageIDMap[] =
{
// 667507: remove duplicate locales - description strings now looked up using GetLocaleInfo, so
//  these duplicates do not have different string descriptions
#if 0
    {0x0409, TEXT("English")},  //  This item will be the default selection below...
    {0x0407, TEXT("German")},
    {0x0411, TEXT("Japanese")},
    {0x0412, TEXT("Korean")},
    {0x0404, TEXT("Traditional Chinese")},
    {0x0804, TEXT("Simplified Chinese")},
    {0x040c, TEXT("French")},
    {0x0c0a, TEXT("Spanish")},
    {0x0416, TEXT("Brazilian")},
    {0x0410, TEXT("Italian")},
    {0x0413, TEXT("Dutch")},
    {0x041d, TEXT("Swedish")},
    {0x0406, TEXT("Danish")},
    {0x040b, TEXT("Finnish")},
    {0x040e, TEXT("Hungarian")},
    {0x0414, TEXT("Norwegian")},
    {0x0408, TEXT("Greek")},
    {0x0415, TEXT("Polish")},
    {0x0419, TEXT("Russian")},
    {0x0405, TEXT("Czech")},
    {0x0816, TEXT("Portuguese")},
    {0x041f, TEXT("Turkish")},
    {0x041b, TEXT("Slovak")},
    {0x0424, TEXT("Slovenian")},
    {0x0401, TEXT("Arabic")},
    {0x040d, TEXT("Hebrew")},
#endif
    {0x0401, TEXT("Arabic - Saudi Arabia")},
    {0x0801, TEXT("Arabic - Iraq")},
    {0x0c01, TEXT("Arabic - Egypt")},
    {0x1001, TEXT("Arabic - Libya")},
    {0x1401, TEXT("Arabic - Algeria")},
    {0x1801, TEXT("Arabic - Morocco")},
    {0x1c01, TEXT("Arabic - Tunisia")},
    {0x2001, TEXT("Arabic - Oman")},
    {0x2401, TEXT("Arabic - Yemen")},
    {0x2801, TEXT("Arabic - Syria")},
    {0x2c01, TEXT("Arabic - Jordan")},
    {0x3001, TEXT("Arabic - Lebanon")},
    {0x3401, TEXT("Arabic - Kuwait")},
    {0x3801, TEXT("Arabic - United Arab Emirates")},
    {0x3c01, TEXT("Arabic - Bahrain")},
    {0x4001, TEXT("Arabic - Qatar")},
    {0x0402, TEXT("Bulgarian - Bulgaria")},
    {0x0403, TEXT("Catalan - Spain")},
    {0x0404, TEXT("Chinese  Taiwan")},
    {0x0804, TEXT("Chinese - PRC")},
    {0x0c04, TEXT("Chinese - Hong Kong SAR, PRC")},
    {0x1004, TEXT("Chinese - Singapore")},
    {0x1404, TEXT("Chinese - Macao SAR")},
    {0x0405, TEXT("Czech - Czech Republic")},
    {0x0406, TEXT("Danish - Denmark")},
    {0x0407, TEXT("German - Germany")},
    {0x0807, TEXT("German - Switzerland")},
    {0x0c07, TEXT("German - Austria")},
    {0x1007, TEXT("German - Luxembourg")},
    {0x1407, TEXT("German - Liechtenstein")},
    {0x0408, TEXT("Greek - Greece")},
    {0x0409, TEXT("English - United States")},
    {0x0809, TEXT("English - United Kingdom")},
    {0x0c09, TEXT("English - Australia")},
    {0x1009, TEXT("English - Canada")},
    {0x1409, TEXT("English - New Zealand")},
    {0x1809, TEXT("English - Ireland")},
    {0x1c09, TEXT("English - South Africa")},
    {0x2009, TEXT("English - Jamaica")},
    {0x2409, TEXT("English - Caribbean")},
    {0x2809, TEXT("English - Belize")},
    {0x2c09, TEXT("English - Trinidad")},
    {0x3009, TEXT("English - Zimbabwe")},
    {0x3409, TEXT("English - Philippines")},
    {0x040a, TEXT("Spanish - Spain (Traditional Sort)")},
    {0x080a, TEXT("Spanish - Mexico")},
    {0x0c0a, TEXT("Spanish - Spain (Modern Sort)")},
    {0x100a, TEXT("Spanish - Guatemala")},
    {0x140a, TEXT("Spanish - Costa Rica")},
    {0x180a, TEXT("Spanish - Panama")},
    {0x1c0a, TEXT("Spanish - Dominican Republic")},
    {0x200a, TEXT("Spanish - Venezuela")},
    {0x240a, TEXT("Spanish - Colombia")},
    {0x280a, TEXT("Spanish - Peru")},
    {0x2c0a, TEXT("Spanish - Argentina")},
    {0x300a, TEXT("Spanish - Ecuador")},
    {0x340a, TEXT("Spanish - Chile")},
    {0x380a, TEXT("Spanish - Uruguay")},
    {0x3c0a, TEXT("Spanish - Paraguay")},
    {0x400a, TEXT("Spanish - Bolivia")},
    {0x440a, TEXT("Spanish - El Salvador")},
    {0x480a, TEXT("Spanish - Honduras")},
    {0x4c0a, TEXT("Spanish - Nicaragua")},
    {0x500a, TEXT("Spanish - Puerto Rico")},
    {0x040b, TEXT("Finnish - Finland")},
    {0x040c, TEXT("French - France")},
    {0x080c, TEXT("French - Belgium")},
    {0x0c0c, TEXT("French - Canada")},
    {0x100c, TEXT("French - Switzerland")},
    {0x140c, TEXT("French - Luxembourg")},
    {0x180c, TEXT("French - Monaco")},
    {0x040d, TEXT("Hebrew - Israel")},
    {0x040e, TEXT("Hungarian - Hungary")},
    {0x040f, TEXT("Icelandic - Iceland")},
    {0x0410, TEXT("Italian - Italy")},
    {0x0810, TEXT("Italian - Switzerland")},
    {0x0411, TEXT("Japanese - Japan")},
    {0x0412, TEXT("Korean (Extended Wansung) - Korea")},
    {0x0812, TEXT("Korean (Johab) - Korea")},
    {0x0413, TEXT("Dutch - Netherlands")},
    {0x0813, TEXT("Dutch - Belgium")},
    {0x0414, TEXT("Norwegian - Norway (Bokmal)")},
    {0x0814, TEXT("Norwegian - Norway (Nynorsk)")},
    {0x0415, TEXT("Polish - Poland")},
    {0x0416, TEXT("Portuguese - Brazil")},
    {0x0816, TEXT("Portuguese - Portugal")},
    {0x0417, TEXT("Rhaeto-Romanic - Rhaeto-Romanic")},
    {0x0418, TEXT("Romanian - Romania")},
    {0x0818, TEXT("Romanian - Moldavia")},
    {0x0419, TEXT("Russian - Russia")},
    {0x0819, TEXT("Russian - Moldavia")},
    {0x041a, TEXT("Croatian - Croatia")},
    {0x081a, TEXT("Serbian - Serbia (Latin)")},
    {0x0c1a, TEXT("Serbian - Serbia (Cyrillic)")},
    {0x041b, TEXT("Slovak - Slovakia")},
    {0x041c, TEXT("Albanian - Albania")},
    {0x041d, TEXT("Swedish - Sweden")},
    {0x081d, TEXT("Swedish - Finland")},
    {0x041e, TEXT("Thai - Thailand")},
    {0x041f, TEXT("Turkish - Turkey")},
    {0x0420, TEXT("Urdu - Urdu")},
    {0x0421, TEXT("Indonesian - Indonesia")},
    {0x0422, TEXT("Ukrainian - Ukraine")},
    {0x0423, TEXT("Belarussian - Belarus")},
    {0x0424, TEXT("Slovene - Slovenia")},
    {0x0425, TEXT("Estonian - Estonia")},
    {0x0426, TEXT("Latvian - Latvia")},
    {0x0427, TEXT("Lithuanian - Lithuania")},
    {0x0429, TEXT("Farsi - Iran")},
    {0x042a, TEXT("Vietnamese - Vietnam")},
    {0x042d, TEXT("Basque - Spain")},
    {0x042e, TEXT("Sorbian - Sorbian")},
    {0x042f, TEXT("FYRO Macedonian - Macedonian (Fyrom)")},
    {0x0430, TEXT("Sutu - Sutu")},
    {0x0431, TEXT("Tsonga - Tsonga")},
    {0x0432, TEXT("Tswana - Tswana")},
    {0x0433, TEXT("Venda - Venda")},
    {0x0434, TEXT("Xhosa - Xhosa")},
    {0x0435, TEXT("Zulu - Zulu")},
    {0x0436, TEXT("Afrikaans - South Africa")},
    {0x0438, TEXT("Faeroese - Faeroe Islands")},
    {0x0439, TEXT("Hindi - Hindi")},
    {0x043a, TEXT("Maltese - Maltese")},
    {0x043b, TEXT("Saami - Saami (Lappish)")},
    {0x043c, TEXT("Gaelic - Scots")},
    {0x083c, TEXT("Gaelic - Irish")},
    {0x043d, TEXT("Yiddish - Yiddish")},
    {0x043e, TEXT("Malay - Malaysian")},
    {0x083e, TEXT("Malay - Brunei")},
    {0x0441, TEXT("Swahili - Kenya")}
};

const DWORD s_PMAdminHelpIDs[] =
{
    IDC_SERVERNAME, IDH_SERVERNAME,
    IDC_INSTALLDIR, IDH_INSTALLDIR,
    IDC_TIMEWINDOW, IDH_TIMEWINDOW,
    IDC_TIMEWINDOW_TIME, NO_HELP,
    IDC_FORCESIGNIN, IDH_FORCESIGNIN,
    IDC_LANGUAGEID, IDH_LANGUAGEID,
    IDC_COBRANDING_TEMPLATE, IDH_COBRANDING_TEMPLATE,
    IDC_SITEID, IDH_SITEID,
    IDC_RETURNURL, IDH_RETURNURL,
    IDC_COOKIEDOMAIN, IDH_COOKIEDOMAIN,
    IDC_COOKIEPATH, IDH_COOKIEPATH,
    IDC_PROFILEDOMAIN, IDH_PROFILEDOMAIN,
    IDC_PROFILEPATH, IDH_PROFILEPATH,
    IDC_SECUREDOMAIN, IDH_SECUREDOMAIN,
    IDC_SECUREPATH, IDH_SECUREPATH,
    IDC_STANDALONE, IDH_STANDALONE,
    IDC_DISABLECOOKIES, IDH_DISABLECOOKIES,
    IDC_DISASTERURL, IDH_DISASTERURL,
    IDC_COMMIT, IDH_COMMIT,
    IDC_UNDO, IDH_UNDO,
    IDC_CONFIGSETS, IDH_CONFIGSETS,
    IDC_NEWCONFIG, IDH_NEWCONFIG,
    IDC_REMOVECONFIG, IDH_REMOVECONFIG,
    IDC_CONFIGSETEDIT, IDH_CONFIGSETEDIT,
    IDC_HOSTNAMEEDIT, IDH_HOSTNAMEEDIT,
    IDC_HOSTIPEDIT, IDH_HOSTIPEDIT,
    IDC_VERBOSE_MODE, IDH_VERBOSE_MODE,
    IDC_ENVCHANGE, IDH_ENVCHANGE,
    IDC_ENVIRONMENT, IDH_ENVIRONMENT,
    IDC_ENABLE_MANREFRESH, IDH_ENABLEMREFRESH,
    IDC_REFRESH_NET, IDH_NSREFRESH,
    IDC_PRODUCTION, NO_HELP,
    IDC_PREPRODUCTION, NO_HELP,
    IDC_BETA_PREPRODUCTION, NO_HELP,
    IDC_OTHER, NO_HELP,
    IDC_REMOTEFILE, IDH_REMOTEFILE,
    IDC_MOREINFO, IDH_MOREINFO,
    0, 0
};

#define SERVERNAME_CMD      TEXT("/Server")
#define CONFIGFILE_CMD      TEXT("/Config")
#define CONFIGSET_CMD       TEXT("/Name")
#define HELP_CMD            TEXT("/?")

#define IS_DOT_NET_SERVER()      (LOWORD(GetVersion()) >= 0x0105)

// 667507 - Look up locale description string from locale ID from the table
TCHAR g_szTemp[200];            // buffer for locale names fetched by GetLocaleInfo()

// 667507: Accept locale ID as input, fetch locale description string from system via GetLocaleInfo, and
//  return a pointer to it.  This function is intended as a drop-in replacement for references to 
//  the string value: g_szLanguageIDMap[idx].lpszLang
TCHAR *szLanguageName(WORD lc)
{
    if (0 == GetLocaleInfo(lc,LOCALE_SLANGUAGE,g_szTemp,200))
        g_szTemp[0] = 0;
        
    return g_szTemp;
}

// Process the incomming command line
void Usage()
{
    ReportError(NULL, IDS_USAGE);
    exit(0);
}

// ----------------------------------------------------------------------------
// Re-written to use CommandLineToArgvW instead of a custom parser, for bug #9049.
//
// We do a lot of W -> A and A -> W conversion in here (the implementation
// would be trivial if it weren't for the conversions). Since we're only going
// to run on NT platforms, it would be better to just compile with UNICODE and
// go from there.
// ----------------------------------------------------------------------------
void
ProcessCommandLineArgs (
    LPSTR szCmdLine
    )
{
    TCHAR szOut[MAX_PATH];

    int nArgCount = 0, nArgPos;
    LPWSTR *awszArgs = NULL;
    LPTSTR szArg = NULL;
    LPTSTR szArgValue = NULL;

    awszArgs = CommandLineToArgvW(GetCommandLineW(), &nArgCount);

    if (awszArgs == NULL) Usage();

    // Iterate over the arguments.  Check for the command-line switches.  Currently,
    // all switches have a parameter that comes after them (in the next command-line argument).
    //
    nArgPos = 0;

    while (nArgPos < nArgCount)
    {
        szArg = NULL;
        szArgValue = NULL;

#ifndef UNICODE
        // Convert the parameter in the array from wide ot ansi, so we can compare
        //

        int nLen = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, NULL, 0, NULL, NULL);

        szArg = new char[nLen];

        if (szArg == NULL)
        {
            return;
        }

        nLen = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, szArg, nLen, NULL, NULL);
#else
        szArg = awszArgs[nArgPos];
#endif

        if (lstrcmpi(szArg, SERVERNAME_CMD) == 0)
        {
            if (++nArgPos >= nArgCount) Usage();

#ifndef UNICODE
            int nLenValue = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, NULL, 0, NULL, NULL);
            szArgValue = new char[nLenValue];
            nLenValue = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, szArgValue, nLenValue, NULL, NULL);
#else
            szArgValue = awszArgs[nArgPos];
#endif

            if (lstrlen(szArgValue) >= MAX_PATH) {

                //
                // As we are running .Net above. We should always have UNICODE. Just return. No memory free required here.
                //

                return;
            }

            lstrcpy(g_szRemoteComputer, szArgValue);
        }

        if (lstrcmpi(szArg, CONFIGFILE_CMD) == 0)
        {
            if (++nArgPos >= nArgCount) Usage();

#ifndef UNICODE
            int nLenValue = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, NULL, 0, NULL, NULL);
            szArgValue = new char[nLenValue];
            nLenValue = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, szArgValue, nLenValue, NULL, NULL);
#else
            szArgValue = awszArgs[nArgPos];
#endif

            if (lstrlen(szArgValue) >= MAX_PATH) {

                //
                // As we are running .Net above. We should always have UNICODE. Just return. No memory free required here.
                //

                return;
            }
            lstrcpy(g_szConfigFile, szArgValue);
        }

        if (lstrcmpi(szArg, CONFIGSET_CMD) == 0)
        {
            if (++nArgPos >= nArgCount) Usage();

#ifndef UNICODE
            int nLenValue = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, NULL, 0, NULL, NULL);
            szArgValue = new char[nLenValue];
            nLenValue = WideCharToMultiByte(CP_ACP, 0, awszArgs[nArgPos], -1, szArgValue, nLenValue, NULL, NULL);
#else
            szArgValue = awszArgs[nArgPos];
#endif
            if (lstrlen(szArgValue) >= MAX_CONFIGSETNAME) {

                //
                // As we are running .Net above. We should always have UNICODE. Just return. No memory free required here.
                //

                return;
            }
            lstrcpy(g_szConfigSet, szArgValue);
        }

        nArgPos++;

#ifndef UNICODE
        szArg = NULL;
        szArgValue = NULL;
#endif

    } // while

    HeapFree(GetProcessHeap(), 0, (PVOID) awszArgs);
}


BOOL RegisterAndSetIcon
(
    HINSTANCE hInstance
)
{
    //
    // Fetch the default dialog class information.
    //
    WNDCLASS wndClass;
    if (!GetClassInfo (0, MAKEINTRESOURCE (32770), &wndClass))
    {
        return FALSE;
    }

    //
    // Assign the Icon.
    //
    wndClass.hInstance      = hInstance;
    wndClass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
    wndClass.lpszClassName  = (LPTSTR)g_szDlgClassName;
    wndClass.lpszMenuName   = MAKEINTRESOURCE(IDR_MAIN_MENU);


    //
    // Register the window class.
    //
    return RegisterClass( &wndClass );
}

void InitializeComputerMRU(void)
{
    g_ComputerMRU.load(TEXT("Computer MRU"), TEXT("msppcnfg.ini"));
}


void SaveComputerMRU(void)
{
    g_ComputerMRU.save(TEXT("Computer MRU"), TEXT("msppcnfg.ini"));
}


void InsertComputerMRU
(
    LPCTSTR szComputer
)
{
    g_ComputerMRU.insert(szComputer);
}


void InitializePMConfigStruct
(
    LPPMSETTINGS  lpPMConfig
)
{
    // Zero Init the structure
    ZeroMemory(lpPMConfig, sizeof(PMSETTINGS));

    // Setup the buffer sizes
    lpPMConfig->cbCoBrandTemplate = sizeof(lpPMConfig->szCoBrandTemplate);
    lpPMConfig->cbReturnURL = sizeof(lpPMConfig->szReturnURL);
    lpPMConfig->cbTicketDomain = sizeof(lpPMConfig->szTicketDomain);
    lpPMConfig->cbTicketPath = sizeof(lpPMConfig->szTicketPath);
    lpPMConfig->cbProfileDomain = sizeof(lpPMConfig->szProfileDomain);
    lpPMConfig->cbProfilePath = sizeof(lpPMConfig->szProfilePath);
    lpPMConfig->cbSecureDomain = sizeof(lpPMConfig->szSecureDomain);
    lpPMConfig->cbSecurePath = sizeof(lpPMConfig->szSecurePath);
    lpPMConfig->cbDisasterURL = sizeof(lpPMConfig->szDisasterURL);
    lpPMConfig->cbHostName = sizeof(lpPMConfig->szHostName);
    lpPMConfig->cbHostIP = sizeof(lpPMConfig->szHostIP);
    lpPMConfig->cbEnvName = sizeof(lpPMConfig->szEnvName);
    lpPMConfig->cbRemoteFile = sizeof(lpPMConfig->szRemoteFile);
}

void GetDefaultSettings
(
    LPPMSETTINGS    lpPMConfig
)
{
    InitializePMConfigStruct(lpPMConfig);

    lpPMConfig->dwSiteID = 1;
    lpPMConfig->dwLanguageID = 1033;
    lpPMConfig->dwTimeWindow = DEFAULT_TIME_WINDOW;
#ifdef DO_KEYSTUFF
    lpPMConfig->dwCurrentKey = 1;
#endif

    // set the default secure level so that HTTPS is used
    lpPMConfig->dwSecureLevel = 10;
}


void InitInstance
(
    HINSTANCE   hInstance
)
{
    InitializeComputerMRU();

    InitializePMConfigStruct(&g_OriginalSettings);

    g_bCanUndo = FALSE;
    g_szInstallPath[0] = TEXT('\0');
    ZeroMemory(g_szPMVersion, sizeof(g_szPMVersion));
    ZeroMemory(g_szRemoteComputer, sizeof(g_szRemoteComputer));
    ZeroMemory(g_szNewRemoteComputer, sizeof(g_szNewRemoteComputer));
    ZeroMemory(g_szConfigFile, sizeof(g_szConfigFile));
    ZeroMemory(g_szHelpFileName, sizeof(g_szHelpFileName));

    // Load the Help File Name
    LoadString(hInstance, IDS_PMHELPFILE, g_szHelpFileName, DIMENSION(g_szHelpFileName));
}

INT WINAPI WinMain
(
    HINSTANCE        hInstance,
    HINSTANCE        hPrevInstance,
    LPSTR            lpszCmdLine,
    INT              nCmdShow
)
{

    MSG     msg;
    HACCEL  hAccel;
    TCHAR   szTitle[MAX_TITLE];
    TCHAR   szMessage[MAX_MESSAGE];

    g_hInst = hInstance;

    //don't forget this
    InitCommonControls();

    if(!hPrevInstance)
    {
        //
        // Register this app's window and set the icon only 1 time for all instances
        //
        if (!RegisterAndSetIcon(hInstance))
            return FALSE;
    }

    if (!g_ComputerMRU.init())
    {
        return FALSE;
    }

    // Initialize the necessary Instance Variables and settings;
    InitInstance(hInstance);

    // If there was a command line, then process it, otherwise show the GUI
    if (lpszCmdLine && (*lpszCmdLine != TEXT('\0')))
    {
        TCHAR   szFile[MAX_PATH];

        ProcessCommandLineArgs(lpszCmdLine);

        if(g_szConfigFile[0] == TEXT('\0')) Usage();

        // Check to see if we got a fully qualified path name for the config file
        if (PathIsFileSpec(g_szConfigFile))
        {
            // Not qualified, so assume it exists in our CWD
            lstrcpy(szFile, g_szConfigFile);
            GetCurrentDirectory(DIMENSION(g_szConfigFile), g_szConfigFile);

            if (!PathAppend(g_szConfigFile, szFile)){
                //
                // We could have do better than just return error. The original code uses too many global vars.
                // It would be real pain to make this app support path longer than MAX_PATH. Let's behave not too
                // bad if path is really longer than MAX_PATH. If support for longer than MAX_PATH is needed, we
                // can change more later. This is just a quick fix.
                //
                return FALSE;
            }
        }

        // Load the Config set specified
        if (ReadFileConfigSet(&g_OriginalSettings, g_szConfigFile))
        {
            if ((g_szRemoteComputer[0] != TEXT('\0')) || (g_szConfigSet[0] != TEXT('\0')))
            {
                // Commit the ConfigSet Read
                WriteRegConfigSet(NULL,
                              &g_OriginalSettings,
                              g_szRemoteComputer,
                              g_szConfigSet);
            }
            else
            {
                g_fFromFile = TRUE;
                //
                // Create the dialog for this instance
                //
                DialogBox( hInstance,
                           MAKEINTRESOURCE (IDD_MAIN),
                           NULL,
                           DlgMain );
            }
        }
    }
    else
    {
        //
        // Create the dialog for this instance
        //
        DialogBox( hInstance,
                   MAKEINTRESOURCE (IDD_MAIN),
                   NULL,
                   DlgMain );
    }

    SaveComputerMRU();

    return TRUE;
}


/**************************************************************************

   Utility functions for the dialogs

**************************************************************************/

/**************************************************************************

   About()

**************************************************************************/
INT_PTR CALLBACK About
(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            TCHAR achProductVersionBuf[64];
            TCHAR achProductIDBuf[64 + PRODUCTID_LEN];
            HKEY  hkeyPassport;
            DWORD dwcbTemp;
            DWORD dwType;

            if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              g_szPassportReg,
                                              0,
                                              KEY_READ,
                                              &hkeyPassport))
            {
                ReportError(hWnd, IDS_CONFIGREAD_ERROR);
                return TRUE;
            }

            // Load the Help File Name
            LoadString(g_hInst,
                       IDS_PRODUCTID,
                       achProductIDBuf,
                       DIMENSION(achProductIDBuf) - PRODUCTID_LEN);

            LoadString(g_hInst,
                       IDS_PRODUCTVERSION,
                       achProductVersionBuf,
                       DIMENSION(achProductVersionBuf));

            //  Display product version

            if (IS_DOT_NET_SERVER())
            {
                DWORD dwLen = lstrlen(achProductVersionBuf);

                dwcbTemp = DIMENSION(achProductVersionBuf) - dwLen;
                dwType = REG_SZ;

                RegQueryValueEx(hkeyPassport,
                                TEXT("Version"),
                                NULL,
                                &dwType,
                                (LPBYTE) (achProductVersionBuf + dwLen),
                                &dwcbTemp);
            }
            else
            {
#ifdef UNICODE
                lstrcat(achProductVersionBuf, LVER_PRODUCTVERSION_STR);
#else
                lstrcat(achProductVersionBuf, VER_PRODUCTVERSION_STR);
#endif
            }

            SetDlgItemText(hWnd, IDC_PRODUCTVERSION, achProductVersionBuf);

            //  Display product id
            dwcbTemp = PRODUCTID_LEN;
            dwType = REG_SZ;
            RegQueryValueEx(hkeyPassport,
                            TEXT("ProductID"),
                            NULL,
                            &dwType,
                            (LPBYTE)&(achProductIDBuf[lstrlen(achProductIDBuf)]),
                            &dwcbTemp);

            RegCloseKey(hkeyPassport);

            SetDlgItemText(hWnd, IDC_PRODUCTID, achProductIDBuf);

            return TRUE;
        }

        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hWnd, wParam);
                    return TRUE;
            }
            break;
    }
    return FALSE;
}


/**************************************************************************

    UpdateTimeWindowDisplay

    this function will update the "human" readable display of the time
    window setting.

**************************************************************************/
void UpdateTimeWindowDisplay
(
    HWND    hWndDlg,
    DWORD   dwTimeWindow
)
{
    int     days, hours, minutes, seconds;
    TCHAR   szTemp[MAX_REGISTRY_STRING];

    // Format the Time display
    days = dwTimeWindow / SECONDS_PER_DAY;
    hours = (dwTimeWindow - (days * SECONDS_PER_DAY)) / SECONDS_PER_HOUR;
    minutes = (dwTimeWindow - (days * SECONDS_PER_DAY) - (hours * SECONDS_PER_HOUR)) / SECONDS_PER_MIN;
    seconds = dwTimeWindow -
                (days * SECONDS_PER_DAY) -
                (hours * SECONDS_PER_HOUR) -
                (minutes * SECONDS_PER_MIN);

    wsprintf (szTemp, TEXT("%d d : %d h : %d m : %d s"), days, hours, minutes, seconds);
    SetDlgItemText(hWndDlg, IDC_TIMEWINDOW_TIME, szTemp);

}


/**************************************************************************

    UpdateLanguageDisplay

    this function will update both the combo box for selecting/entering
    the Language ID value, and the language value if possible.
    If idx is >= 0, then it is a valid index into the array, otherwise
    the index is found by searching the entries in the list

**************************************************************************/
void UpdateLanguageDisplay
(
    HWND    hWndDlg,
    DWORD   dwLanguageID,
    INT     idx
)
{
    TCHAR   szTemp[MAX_LCID_VALUE];
    LRESULT     idxLangID;

    if (idx >= 0)
    {
        TCHAR *psz = szLanguageName(g_szLanguageIDMap[idx].wLangID);
        if (psz[0] != 0)
            // 667507: use lookup fn to get locale description.  Use unknown if the system doesn't recognize it
            //SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, g_szLanguageIDMap[idx].lpszLang);
            SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, psz);
        else
            SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, g_szUnknown);
    }
    else
    {
        wsprintf (szTemp, TEXT("%lu"), dwLanguageID);
        // Search the Combo-Box to see if we have the proposed LCID in the list already
        if (CB_ERR !=
             (idxLangID = SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_FINDSTRINGEXACT, 0, (LPARAM)szTemp)))
        {
            // The Language ID is one that is in our pre-populated list, so we have a matching
            // language string as well
            // 667507: use lookup fn to get description string
            SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETCURSEL, idxLangID, 0l);
            SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, szLanguageName(g_szLanguageIDMap[(int) idxLangID].wLangID));
        }
        else
        {
            SetDlgItemText(hWndDlg, IDC_LANGUAGEID_LANG, g_szUnknown);
        }
    }
}

/**************************************************************************

    SetUndoButton

    Sets the state of the Undo button.

**************************************************************************/
void SetUndoButton
(
    HWND    hWndDlg,
    BOOL    bUndoState
)
{
    g_bCanUndo = bUndoState;
    EnableWindow(GetDlgItem(hWndDlg, IDC_UNDO), bUndoState);
}

/**************************************************************************

    InitMainDlg

**************************************************************************/
BOOL InitMainDlg
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig
)
{
    TCHAR           szTemp[MAX_REGISTRY_STRING];
    LPTSTR          lpszConfigSetNames, lpszCur;
    LRESULT           dwCurSel;
    int             nCmdShow;
    int             nSelectedLanguage;

#ifdef DO_KEYSTUFF
    HWND        hWndListView;
    LVCOLUMN    lvc;
#endif

    // Remote Computer Name
    if ((TEXT('\0') != g_szRemoteComputer[0]))
    {
        SetDlgItemText(hWndDlg, IDC_SERVERNAME, g_szRemoteComputer);
    }
    else
    {
        LoadString(g_hInst, IDS_LOCALHOST, szTemp, DIMENSION(szTemp));
        SetDlgItemText(hWndDlg, IDC_SERVERNAME, szTemp);
    }

    // Icon
    HICON hic = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_PMADMIN));
    SendMessage(hWndDlg, WM_SETICON, ICON_SMALL, (LPARAM)hic);
    SendMessage(hWndDlg, WM_SETICON, ICON_BIG, (LPARAM)hic);

    // List of config sets
    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_RESETCONTENT, 0, 0L);

    LoadString(g_hInst, IDS_DEFAULT, szTemp, DIMENSION(szTemp));
    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_ADDSTRING, 0, (LPARAM)szTemp);

    if(ReadRegConfigSetNames(hWndDlg, g_szRemoteComputer, &lpszConfigSetNames) &&
       lpszConfigSetNames)
    {
        lpszCur = lpszConfigSetNames;
        while(*lpszCur)
        {
            SendDlgItemMessage(hWndDlg,
                               IDC_CONFIGSETS,
                               CB_ADDSTRING,
                               0,
                               (LPARAM)lpszCur);

            lpszCur = _tcschr(lpszCur, TEXT('\0')) + 1;
        }

        free(lpszConfigSetNames);
        lpszConfigSetNames = NULL;
    }

    if(g_szConfigSet[0] != TEXT('\0'))
    {
        dwCurSel = SendDlgItemMessage(hWndDlg,
                                      IDC_CONFIGSETS,
                                      CB_FINDSTRINGEXACT,
                                      -1,
                                      (LPARAM)g_szConfigSet);
    }
    else
    {
        dwCurSel = 0;
    }

    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_SETCURSEL, dwCurSel, 0L);

    //  If the current selection was the default, then hide the
    //  host name and ip address controls.
    nCmdShow = (dwCurSel ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTNAMETEXT), nCmdShow);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTNAMEEDIT), nCmdShow);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTIPTEXT),   nCmdShow);
    ShowWindow(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT),   nCmdShow);

    EnableWindow(GetDlgItem(hWndDlg, IDC_REMOVECONFIG), (int) dwCurSel);

	// Check registry to decide if Enable Manual Refresh checkbox should be checked
	TCHAR		szBuffer[MAX_REGISTRY_STRING];
	DWORD		dwBufferSize = MAX_REGISTRY_STRING;
	HKEY		hKey;
	DWORD		dwValType;

    //
    // EnvName
    // Warning: if version number > 1.10, this algorithm needs to be changed
    if (lstrcmp(g_szPMVersion, g_szVersion14) < 0) // hide this for previous verison
	{
        EnableWindow(GetDlgItem(hWndDlg, IDC_ENVCHANGE), FALSE);
		EnableWindow(GetDlgItem(hWndDlg, IDC_ENABLE_MANREFRESH), FALSE);
		EnableWindow(GetDlgItem(hWndDlg, IDC_REFRESH_NET), FALSE);
	}
    else
	{
        EnableWindow(GetDlgItem(hWndDlg, IDC_ENVCHANGE), TRUE);
		EnableWindow(GetDlgItem(hWndDlg, IDC_ENABLE_MANREFRESH), TRUE);
		EnableWindow(GetDlgItem(hWndDlg, IDC_REFRESH_NET), lpPMConfig->dwEnableManualRefresh ? TRUE : FALSE);
	}

    CheckDlgButton(hWndDlg, IDC_ENABLE_MANREFRESH, lpPMConfig->dwEnableManualRefresh ? BST_CHECKED : BST_UNCHECKED);

    {
        TCHAR   pszEnvName[MAX_RESOURCE];

        if(lstrcmp(lpPMConfig->szEnvName, g_szEnglishPreProduction) == 0)
        {
            LoadString(g_hInst, IDS_PREPRODUCTION, pszEnvName, DIMENSION(pszEnvName));
        }
        else if(lstrcmp(lpPMConfig->szEnvName, g_szEnglishBetaPreProduction) == 0)
        {
            LoadString(g_hInst, IDS_BETAPREPRODUCTION, pszEnvName, DIMENSION(pszEnvName));
        }
        else if(lstrcmp(lpPMConfig->szEnvName, g_szEnglishOther) == 0)
        {
            LoadString(g_hInst, IDS_OTHER, pszEnvName, DIMENSION(pszEnvName));
        }
        else // must be Production
        {
            LoadString(g_hInst, IDS_PRODUCTION, pszEnvName, DIMENSION(pszEnvName));
        }

        SetDlgItemText(hWndDlg, IDC_ENVIRONMENT, pszEnvName);
    }

    //
    // HostName
    SetDlgItemText(hWndDlg, IDC_HOSTNAMEEDIT, lpPMConfig->szHostName);
    SendDlgItemMessage(hWndDlg, IDC_HOSTNAMEEDIT, EM_SETLIMITTEXT, INTERNET_MAX_HOST_NAME_LENGTH - 1, 0l);

    //
    // HostIP
    SetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, lpPMConfig->szHostIP);
    SendDlgItemMessage(hWndDlg, IDC_HOSTIPEDIT, EM_SETLIMITTEXT, MAX_IPLEN - 1, 0l);
    //
    // Install Dir
    SetDlgItemText(hWndDlg, IDC_INSTALLDIR, g_szInstallPath);

    // Version
    // SetDlgItemText(hWndDlg, IDC_VERSION, g_szPMVersion);

    // Time Window
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwTimeWindow);
    SetDlgItemText(hWndDlg,     IDC_TIMEWINDOW, szTemp);

    UpdateTimeWindowDisplay(hWndDlg, lpPMConfig->dwTimeWindow);


    // Initialize the force signing values
    CheckDlgButton(hWndDlg, IDC_FORCESIGNIN, lpPMConfig->dwForceSignIn ? BST_CHECKED : BST_UNCHECKED);

    // language ID
    // Initialize the LanguageID dropdown with the known LCIDs
    SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_RESETCONTENT, 0, 0l);
    nSelectedLanguage = -1;
    for (int i = 0; i < sizeof(g_szLanguageIDMap)/sizeof(LANGIDMAP); i++)
    {
        // 667507 - If there is no description string for a locale ID numeric value, don't add it
        //  to the combo box, because we can't display it.
        TCHAR *psz = szLanguageName(g_szLanguageIDMap[i].wLangID);
        if (psz[0] == 0) continue;

        // this locale ID value has a UI string to identify it.  Put it into the combobox droplist
        LRESULT lCurrent = SendDlgItemMessage(hWndDlg,
                              IDC_LANGUAGEID,
                              CB_ADDSTRING,
                              0,
                              (LPARAM) psz);

        SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETITEMDATA, lCurrent, (LPARAM)g_szLanguageIDMap[i].wLangID);

        if(lpPMConfig->dwLanguageID == g_szLanguageIDMap[i].wLangID)
        {
            nSelectedLanguage = i;
		}
    }

    //  Now select the correct item in the list...
    if(nSelectedLanguage == -1)
    {
        // 667507 "English" is no longer item 0.
        //SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETCURSEL, 0, NULL);
        TCHAR *psz = szLanguageName(LOWORD(GetSystemDefaultLCID()));
        if (psz[0] == 0)
        {
            // copy the "Unknown" string to the locale description if unable to convert
            // This should be impossible.
            _tcscpy(psz,g_szUnknown);
        }

        // Locate a match for that language name in the combo box, get the index
        LRESULT  lLanguage = SendDlgItemMessage(hWndDlg,
                                                IDC_LANGUAGEID,
                                                CB_FINDSTRINGEXACT,
                                                -1,
                                                (LPARAM)psz);

        // Select that indexed item in the list
        SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETCURSEL, lLanguage, NULL);
    }
    else
    {
        // 667507: use lookup fn for locale description
        LRESULT  lLanguage = SendDlgItemMessage(hWndDlg,
                                                IDC_LANGUAGEID,
                                                CB_FINDSTRINGEXACT,
                                                -1,
                                                (LPARAM)szLanguageName(g_szLanguageIDMap[nSelectedLanguage].wLangID));

        SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_SETCURSEL, lLanguage, NULL);
    }

    // Update the display of the combo box and the language value
    UpdateLanguageDisplay(hWndDlg, lpPMConfig->dwLanguageID, -1);

    // Co-branding template
    SetDlgItemText(hWndDlg, IDC_COBRANDING_TEMPLATE, lpPMConfig->szCoBrandTemplate);
    SendDlgItemMessage(hWndDlg, IDC_COBRANDING_TEMPLATE, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Site ID
    // bug 8257
    if ((lpPMConfig->dwSiteID < 1) || (lpPMConfig->dwSiteID > MAX_SITEID))
        {
        wsprintf (szTemp, TEXT("1"));
        }
    else
        wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwSiteID); // bug 8832
    SetDlgItemText(hWndDlg, IDC_SITEID, szTemp);

    // Return URL
    SetDlgItemText(hWndDlg, IDC_RETURNURL, lpPMConfig->szReturnURL);
    SendDlgItemMessage(hWndDlg, IDC_RETURNURL, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Cookie domain
    SetDlgItemText(hWndDlg, IDC_COOKIEDOMAIN, lpPMConfig->szTicketDomain);
    SendDlgItemMessage(hWndDlg, IDC_COOKIEDOMAIN, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Cookie path
    SetDlgItemText(hWndDlg, IDC_COOKIEPATH, lpPMConfig->szTicketPath);
    SendDlgItemMessage(hWndDlg, IDC_COOKIEPATH, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Cookie domain
    SetDlgItemText(hWndDlg, IDC_PROFILEDOMAIN, lpPMConfig->szProfileDomain);
    SendDlgItemMessage(hWndDlg, IDC_PROFILEDOMAIN, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Cookie path
    SetDlgItemText(hWndDlg, IDC_PROFILEPATH, lpPMConfig->szProfilePath);
    SendDlgItemMessage(hWndDlg, IDC_PROFILEPATH, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Secure Cookie domain
    SetDlgItemText(hWndDlg, IDC_SECUREDOMAIN, lpPMConfig->szSecureDomain);
    SendDlgItemMessage(hWndDlg, IDC_SECUREDOMAIN, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Secure Cookie path
    SetDlgItemText(hWndDlg, IDC_SECUREPATH, lpPMConfig->szSecurePath);
    SendDlgItemMessage(hWndDlg, IDC_SECUREPATH, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Disaster URL
    SetDlgItemText(hWndDlg, IDC_DISASTERURL, lpPMConfig->szDisasterURL);
    SendDlgItemMessage(hWndDlg, IDC_DISASTERURL, EM_SETLIMITTEXT, INTERNET_MAX_URL_LENGTH -1, 0l);

    // Set the Standalone and Disable Cookies check boxes
    CheckDlgButton(hWndDlg, IDC_STANDALONE, lpPMConfig->dwStandAlone ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(hWndDlg, IDC_DISABLECOOKIES, lpPMConfig->dwDisableCookies ? BST_CHECKED : BST_UNCHECKED);
	CheckDlgButton(hWndDlg, IDC_VERBOSE_MODE, lpPMConfig->dwVerboseMode ? BST_CHECKED : BST_UNCHECKED);

    SetUndoButton(hWndDlg, FALSE);

#ifdef DO_KEYSTUFF

    // Current encryption key
    wsprintf (szTemp, TEXT("%lu"), lpPMConfig->dwCurrentKey);
    SetDlgItemText(hWndDlg, IDC_CURRENTKEY, szTemp);


    // Initialize the Listview control for the Encryption Keys
    hWndListView = GetDlgItem(hWndDlg, IDC_KEYLIST);

    // Setup for full row select
    ListView_SetExtendedListViewStyle(hWndListView, LVS_EX_FULLROWSELECT);

    // Setup the columns
    lvc.mask = LVCF_TEXT;
    lvc.pszText = TEXT("Key Number");
    lvc.iSubItem = 0;
    ListView_InsertColumn(hWndListView, 0, &lvc);

    lvc.mask = LVCF_TEXT;
    lvc.pszText = TEXT("Expires");
    lvc.iSubItem = 1;
    ListView_InsertColumn(hWndListView, 1, &lvc);

    lvc.mask = LVCF_TEXT;
    lvc.pszText = TEXT("Current");
    lvc.iSubItem = 2;
    ListView_InsertColumn(hWndListView, 2, &lvc);

    // Initially size the columns
    ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hWndListView, 1, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hWndListView, 2, LVSCW_AUTOSIZE_USEHEADER);


    // Enumerate the KeyData sub-key to fill in the list
    DWORD   dwRet;
    DWORD   dwIndex = 0;
    TCHAR   szValue[MAX_REGISTRY_STRING];
    DWORD   dwcbValue;
    LVITEM  lvi;

    dwType = REG_SZ;

    do {

        dwcbValue = sizeof(szValue);
        dwcbTemp = sizeof(szTemp);
        szTemp[0] = TEXT('\0');
        szValue[0] = TEXT('\0');
        if (ERROR_SUCCESS == (dwRet = RegEnumValue(hkeyEncryptionKeyData,
                                                     dwIndex,
                                                     szValue,
                                                     &dwcbValue,
                                                     NULL,
                                                     &dwType,
                                                     (LPBYTE)szTemp,
                                                     &dwcbTemp)))
        {
            // Insert the Column
            lvi.mask = LVIF_TEXT;
            lvi.iItem = dwIndex;
            lvi.iSubItem = 0;
            lvi.pszText = szValue;
            lvi.cchTextMax = lstrlen(szValue);

            ListView_InsertItem(hWndListView, &lvi);
            ListView_SetItemText(hWndListView, dwIndex, 1, szTemp);
            // See if this is the current key
            if (g_OriginalSettings.dwCurrentKey == (DWORD)atoi((LPSTR)szValue))
            {
                ListView_SetItemText(hWndListView, dwIndex, 2, g_szYes);
            }
            else
            {
                ListView_SetItemText(hWndListView, dwIndex, 2, g_szNo);
            }
        }

        ++dwIndex;
    } while (dwRet == ERROR_SUCCESS);
#endif

    return TRUE;
}


/**************************************************************************

    Update the computer MRU list based on contents of g_aszComputerMRU

**************************************************************************/
BOOL
UpdateComputerMRU
(
    HWND    hWndDlg
)
{
    BOOL            bReturn;
    HMENU           hMenu;
    HMENU           hComputerMenu;
    int             nIndex;
    MENUITEMINFO    mii;
    TCHAR           achMenuBuf[MAX_PATH];
    DWORD           dwError;

    hMenu = GetMenu(hWndDlg);
    if(hMenu == NULL)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    hComputerMenu = GetSubMenu(hMenu, 1);
    if(hComputerMenu == NULL)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    while(GetMenuItemID(hComputerMenu, 1) != -1)
        DeleteMenu(hComputerMenu, 1, MF_BYPOSITION);

    for(nIndex = 0; nIndex < COMPUTER_MRU_SIZE; nIndex++)
    {
        if(g_ComputerMRU[nIndex] != NULL)
            break;
    }

    if(nIndex == COMPUTER_MRU_SIZE)
    {
        bReturn = TRUE;
        goto Cleanup;
    }

    //  Add the separator.
    ZeroMemory(&mii, sizeof(MENUITEMINFO));
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;

    if(!InsertMenuItem(hComputerMenu, 1, TRUE, &mii))
    {
        dwError = GetLastError();
        bReturn = FALSE;
        goto Cleanup;
    }

    //  Now add each item in the MRU list.
    for(nIndex = 0; nIndex < COMPUTER_MRU_SIZE && g_ComputerMRU[nIndex]; nIndex++)
    {

        ZeroMemory(&mii, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.wID = IDM_COMPUTERMRUBASE + nIndex;

        //
        // It is very unlikely, but is possible to that lstrlen(g_ComputerMRU[nIndex]) > MAX_PATH - 4.
        // If it is, achMenuBuf would be too small. 4 is one digit for nIndex (MAX is COMPUTER_MRU_SIZE) and the
        // rest for & space and ending 0.
        // If g_ComputerMRU[nIndex] is just a WIndows comupter server name, then no buffer overrun would be possible.
        // Let's leave this for the moment.
        //

        wsprintf(achMenuBuf, TEXT("&%d %s"), nIndex + 1, g_ComputerMRU[nIndex]);

        mii.dwTypeData = achMenuBuf;
        mii.cch = lstrlen(achMenuBuf) + 1;

        InsertMenuItem(hComputerMenu, nIndex + 2, TRUE, &mii);
    }

    bReturn = TRUE;

Cleanup:

    return bReturn;
}



/**************************************************************************

    Leaving this config set, prompt for save.

**************************************************************************/
int
SavePrompt
(
    HWND    hWndDlg
)
{
    TCHAR   szPrompt[MAX_RESOURCE];
    TCHAR   szTitle[MAX_RESOURCE];

    LoadString(g_hInst, IDS_SAVE_PROMPT, szPrompt, DIMENSION(szPrompt));
    LoadString(g_hInst, IDS_APP_TITLE, szTitle, DIMENSION(szTitle));

    return MessageBox(hWndDlg, szPrompt, szTitle, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
}


/**************************************************************************

    Switching configurations, check for unsaved changes.

**************************************************************************/
BOOL
DoConfigSwitch
(
    HWND    hWndDlg,
    LPTSTR  szNewComputer,
    LPTSTR  szNewConfigSet
)
{
    BOOL        bReturn;
    int         nOption;
    PMSETTINGS  *pNewSettings = NULL;

    pNewSettings = (PMSETTINGS*)LocalAlloc(LMEM_FIXED, sizeof(PMSETTINGS));
    if (NULL == pNewSettings)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  If switching to current config, do nothing.
    //

    if(lstrcmp(szNewComputer, g_szRemoteComputer) == 0 &&
       lstrcmp(szNewConfigSet, g_szConfigSet) == 0)
    {
        bReturn = TRUE;
        goto Cleanup;
    }

    //
    //  If no changes then return.
    //

    if(0 == memcmp(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS)))
        nOption = IDNO;
    else
        nOption = SavePrompt(hWndDlg);

    switch(nOption)
    {
    case IDYES:
        if(!WriteRegConfigSet(hWndDlg, &g_CurrentSettings, g_szRemoteComputer, g_szConfigSet))
        {
            bReturn = FALSE;
            break;
        }

    case IDNO:
        InitializePMConfigStruct(pNewSettings);
        if (ReadRegConfigSet(hWndDlg,
                             pNewSettings,
                             szNewComputer,
                             szNewConfigSet))
        {
            memcpy(g_szRemoteComputer,  szNewComputer,  sizeof(g_szRemoteComputer));
            memcpy(g_szConfigSet,       szNewConfigSet, sizeof(g_szConfigSet));
            memcpy(&g_CurrentSettings,  pNewSettings,   sizeof(PMSETTINGS));
            memcpy(&g_OriginalSettings, pNewSettings,   sizeof(PMSETTINGS));

            bReturn = TRUE;
        }
        else
        {
            bReturn = FALSE;
        }

        InitMainDlg(hWndDlg, &g_CurrentSettings);
        break;

    case IDCANCEL:
        {
            LRESULT   lSel;
            if(g_szConfigSet[0] == TEXT('\0'))
            {
				lSel = 0;
			}
            else
            {
                lSel = SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_FINDSTRINGEXACT, 0, (LPARAM)g_szConfigSet);
            }

            SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_SETCURSEL, lSel, 0L);

            bReturn = FALSE;
        }
        break;
    }

Cleanup:
    if (pNewSettings)
    {
        LocalFree(pNewSettings);
    }

    return bReturn;
}

/**************************************************************************

    Switching servers, check for unsaved changes.

**************************************************************************/
BOOL
DoServerSwitch
(
    HWND    hWndDlg,
    LPTSTR  szNewComputer
)
{
    BOOL    bReturn;

    if(DoConfigSwitch(hWndDlg, szNewComputer, TEXT("")))
    {
        //  Put computer name on MRU list.
        if(lstrlen(szNewComputer))
            g_ComputerMRU.insert(szNewComputer);
        else
        {
            TCHAR   achTemp[MAX_REGISTRY_STRING];
            LoadString(g_hInst, IDS_LOCALHOST, achTemp, DIMENSION(achTemp));

            g_ComputerMRU.insert(achTemp);
        }

        //  Update MRU menu.
        UpdateComputerMRU(hWndDlg);

        bReturn = TRUE;
    }
    else
        bReturn = FALSE;

    return bReturn;
}

/**************************************************************************

    Closing app, check for unsaved changes.

**************************************************************************/
void
DoExit
(
    HWND    hWndDlg
)
{
    if(0 != memcmp(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS)))
    {
        int     nOption;

        nOption = SavePrompt(hWndDlg);
        switch(nOption)
        {
        case IDYES:
            if(WriteRegConfigSet(hWndDlg, &g_CurrentSettings, g_szRemoteComputer, g_szConfigSet))
                EndDialog(hWndDlg, TRUE);
            break;

        case IDNO:
            EndDialog(hWndDlg, TRUE);
            break;

        case IDCANCEL:
            break;
        }
    }
    else
        EndDialog( hWndDlg, TRUE );
}

HRESULT
LocalRefreshOfNetworkMapping(
   HWND     hWndDlg
)
{
    IPassportAdmin *    pPassportAdmin = NULL;
    VARIANT_BOOL        vbRefreshed;
    VARIANT_BOOL        vbWait; // not used for anything
    TCHAR               szTitle[MAX_TITLE];
    TCHAR               szMessage[MAX_RESOURCE * 2];
    HRESULT             hr;

    vbRefreshed = VARIANT_FALSE;
    vbWait = VARIANT_FALSE;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = CoCreateInstance( CLSID_Admin, 
                           NULL, 
                           CLSCTX_INPROC_SERVER, 
                           IID_IPassportAdmin, 
                           (void**)&pPassportAdmin );

    CoUninitialize();

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = pPassportAdmin->Refresh(vbWait, &vbRefreshed);
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( vbRefreshed == VARIANT_FALSE )
    {
        // put up a dialog box indicating that refresh failed
        LoadString(g_hInst, IDS_OPEN_TITLE, szTitle, DIMENSION(szTitle));
        LoadString(g_hInst, IDS_OPEN_ERROR, szMessage, DIMENSION(szMessage));
        int Choice = IDRETRY;
        while (Choice == IDRETRY)
        {
            hr = pPassportAdmin->Refresh(vbWait, &vbRefreshed);
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            if ( vbRefreshed == VARIANT_FALSE )
            {
                Choice = MessageBox(hWndDlg, szMessage, szTitle, MB_RETRYCANCEL);
            }
            else
            {
                Choice = IDCANCEL;
            }
        }
    }
Cleanup:
    if (NULL != pPassportAdmin)
    {
        pPassportAdmin->Release();
    }

    return hr;
}

/**************************************************************************

    Dialog proc for the main dialog

**************************************************************************/
INT_PTR CALLBACK DlgMain
(
    HWND     hWndDlg,
    UINT     uMsg,
    WPARAM   wParam,
    LPARAM   lParam
)
{
    static BOOL bOkToClose;
    BOOL        fResult;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            if (g_fFromFile)
            {
                // Make a copy of the original setting for editing purposes
                memcpy(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS));
            }
            else
            {
                InitializePMConfigStruct(&g_OriginalSettings);
            }

            if (!ReadRegConfigSet(hWndDlg,
                             &g_OriginalSettings,
                             g_szRemoteComputer,
                             g_szConfigSet))
            {
                EndDialog( hWndDlg, TRUE );
            }

            if (g_fFromFile)
            {
                InitMainDlg(hWndDlg, &g_CurrentSettings);
                UpdateComputerMRU(hWndDlg);
            }
            else
            {
                InitMainDlg(hWndDlg, &g_OriginalSettings);
                UpdateComputerMRU(hWndDlg);

                // Make a copy of the original setting for editing purposes
                memcpy(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS));
            }

            // Change invalid SiteID to 1 so it will be save when exiting
            // bug 8257
            if ((g_CurrentSettings.dwSiteID < 1) || (g_CurrentSettings.dwSiteID > MAX_SITEID))
                g_CurrentSettings.dwSiteID = 1;

            return TRUE;

       case WM_HELP:
        {
            if (((LPHELPINFO) lParam)->iCtrlId == -1) break;
            WinHelp( (HWND)((LPHELPINFO) lParam)->hItemHandle, g_szHelpFileName,
                    HELP_WM_HELP, (ULONG_PTR) s_PMAdminHelpIDs);
            break;
        }

        case WM_CONTEXTMENU:
        {
            WinHelp((HWND) wParam, g_szHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_PMAdminHelpIDs);
            break;
        }

        case WM_COMMAND:
        {
            WORD    wCmd = LOWORD(wParam);
            LPTSTR  lpszStrToUpdate;
            DWORD   cbStrToUpdate;

            switch (wCmd)
            {
                // Handle the Menu Cases
                case IDM_OPEN:
                {
                    if (PMAdmin_GetFileName(hWndDlg,
                                            TRUE,
                                            g_szConfigFile,
                                            DIMENSION(g_szConfigFile)))
                    {
                        if (ReadFileConfigSet(&g_CurrentSettings, g_szConfigFile))
                        {
                            InitMainDlg(hWndDlg, &g_CurrentSettings);
                        }
                    }
                    break;
                }

                case IDM_SAVE:
                {
                    // Have we alread opened or saved a config file, and have a file name
                    // yet?
                    if (TEXT('\0') != g_szConfigFile[0])
                    {
                        // Write out to the current file, and then break
                        WriteFileConfigSet(&g_CurrentSettings, g_szConfigFile);
                        break;
                    }
                    // No file name yet, so fall thru to the Save AS case
                }

                case IDM_SAVEAS:
                {
                    if (PMAdmin_GetFileName(hWndDlg,
                                            FALSE,
                                            g_szConfigFile,
                                            DIMENSION(g_szConfigFile)))
                    {
                        WriteFileConfigSet(&g_CurrentSettings, g_szConfigFile);
                    }
                    break;
                }

                case IDM_EXIT:
                {
                    DoExit(hWndDlg);
                    break;
                }

                case IDM_ABOUT:
                {
                    DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUT_DIALOG), hWndDlg, About);
                    break;
                }
                case IDM_SELECT:
                {
                    if(!PMAdmin_OnCommandConnect(hWndDlg, g_szNewRemoteComputer)) break;

                    if(!DoServerSwitch(hWndDlg, g_szNewRemoteComputer))
                        DoConfigSwitch(hWndDlg, g_szRemoteComputer, g_szConfigSet);

                    break;
                }

/*
                case IDM_REFRESH:
                {
                    DoConfigSwitch(hWndDlg, g_szRemoteComputer, g_szConfigSet);
                    break;
                }
*/
                case IDM_HELP:
                {

/*
                    TCHAR   szPMHelpFile[MAX_PATH];

                    lstrcpy(szPMHelpFile, g_szInstallPath);
                    PathAppend(szPMHelpFile, g_szPMOpsHelpFileRelativePath);

                    HtmlHelp(hWndDlg, szPMHelpFile, HH_DISPLAY_TOPIC, (ULONG_PTR)(LPTSTR)g_szPMAdminBookmark);
*/
					TCHAR   szURL[MAX_PATH];
                    lstrcpy(szURL, _T("http://www.passport.com/SDKDocuments/SDK21/default.htm?Reference%2Foperations%2FPassport%5FAdmin%2Ehtm"));
					ShellExecute(hWndDlg, _T("open"), szURL, NULL, NULL, 0);
                    break;
                }

                // Handle the Dialog Control Cases
                case IDC_COMMIT:
                {
                    TCHAR   szTitle[MAX_TITLE];
                    TCHAR   szMessage[MAX_MESSAGE];
                    TCHAR   szTemp1[MAX_RESOURCE * 2];
                    TCHAR   szTemp2[MAX_RESOURCE];
                    BOOL	bLaunchSite = FALSE, bCancel = FALSE, bToFromProd = FALSE;
                    TCHAR   szURL[MAX_MESSAGE];
                    HINSTANCE ret;

                    if(0 != memcmp(&g_OriginalSettings, &g_CurrentSettings, sizeof(PMSETTINGS)))
                    {
                        LRESULT dwCurrentConfigSel;

                        dwCurrentConfigSel = SendDlgItemMessage(hWndDlg,
                                                                IDC_CONFIGSETS,
                                                                CB_FINDSTRINGEXACT,
                                                                -1,
                                                                (LPARAM)g_szConfigSet);


                        // If the Hostname or IP address is blank for a non-default config, then pop up
                        // an error and refuse to save.  (Bug #9080) KENI
                        //

                        if ((dwCurrentConfigSel != 0 && _tcslen(g_szConfigSet) != 0) && _tcslen(g_CurrentSettings.szHostName) == 0)
                        {
                            ReportControlMessage(hWndDlg, IDC_HOSTNAMEEDIT, VALIDATION_ERROR);
                            return FALSE;
                        }

                        if ((dwCurrentConfigSel != 0 && _tcslen(g_szConfigSet) != 0) && _tcslen(g_CurrentSettings.szHostIP) == 0)
                        {
                            ReportControlMessage(hWndDlg, IDC_HOSTIPEDIT, VALIDATION_ERROR);
                            return FALSE;
                        }


                        if (IDOK == CommitOKWarning(hWndDlg))
                        {
                            if(lstrcmp(g_OriginalSettings.szEnvName, g_szEnglishProduction) == 0 ||
                               lstrcmp(g_CurrentSettings.szEnvName, g_szEnglishProduction) == 0)
                                    bToFromProd = TRUE;

                            // It is OK to commit, and the registry is consistent, or it is OK to
                            // proceed, so write out the current settings
                            if (WriteRegConfigSet(hWndDlg,
                                                  &g_CurrentSettings,
                                                  g_szRemoteComputer,
                                                  g_szConfigSet))
                            {
                                int Choice;

                                LoadString(g_hInst, IDS_CONFIG_COMPLETE_TITLE, szTitle, DIMENSION(szTitle));

                                if ( (lstrcmp(g_OriginalSettings.szEnvName, g_CurrentSettings.szEnvName)  ||
                                      lstrcmp(g_OriginalSettings.szRemoteFile, g_CurrentSettings.szRemoteFile)  ))
                                {
                                    TCHAR *pTempStr;

                                    LoadString(g_hInst, IDS_CONFIG_COMPLETE, szTemp1, DIMENSION(szTemp1));

                                    //
                                    // 2 stands for %s in the string IDS_CONFIG_COMPLETE
                                    //
                                    {

                                        TCHAR   pszEnvName[MAX_RESOURCE];

                                        if(lstrcmp(g_CurrentSettings.szEnvName, g_szEnglishPreProduction) == 0)
                                        {
                                            LoadString(g_hInst, IDS_PREPRODUCTION, pszEnvName, DIMENSION(pszEnvName));
                                        }
                                        else if(lstrcmp(g_CurrentSettings.szEnvName, g_szEnglishBetaPreProduction) == 0)
                                        {
                                            LoadString(g_hInst, IDS_BETAPREPRODUCTION, pszEnvName, DIMENSION(pszEnvName));
                                        }
                                        else if(lstrcmp(g_CurrentSettings.szEnvName, g_szEnglishOther) == 0)
                                        {
                                            LoadString(g_hInst, IDS_OTHER, pszEnvName, DIMENSION(pszEnvName));
                                        }
                                        else // must be Production
                                        {
                                            LoadString(g_hInst, IDS_PRODUCTION, pszEnvName, DIMENSION(pszEnvName));
                                        }

                                        if ((lstrlen(szTemp1) + lstrlen(pszEnvName)) >= MAX_RESOURCE - 2) {

                                            //
                                            //  -1 == chars (%s - NULL)
                                            //

                                            pTempStr = new TCHAR[lstrlen(szTemp1) + lstrlen(pszEnvName) - 1];

                                        } else {

                                            pTempStr = szTemp2;

                                        }

                                        //
                                        // IDS_CONFIG_COMPLETE has only one parameter in it.
                                        //

                                        //wsprintf (szTemp2, szTemp1, g_CurrentSettings.szEnvName, g_CurrentSettings.szEnvName);

                                        wsprintf (pTempStr, szTemp1, pszEnvName);
                                    }

                                    if(MessageBox(hWndDlg, pTempStr, szTitle, MB_OKCANCEL) == IDOK)
                                        bLaunchSite = TRUE;
                                    else
                                        bCancel = TRUE;

                                    if (pTempStr != szTemp2) {
                                        delete [] pTempStr;
                                    }
                                }

                                // The changes where committed, so current becomes original
                                memcpy(&g_OriginalSettings, &g_CurrentSettings, sizeof(PMSETTINGS));
                                SetUndoButton(hWndDlg, FALSE);
                            }
                            else
                            {
                                ReportError(hWndDlg,IDS_COMMITERROR);
                            }
                        }
                    }
                    else if(g_dwRefreshNetMap == 0l)
                    {
                        LoadString(g_hInst, IDS_APP_TITLE, szTitle, DIMENSION(szTitle));
                        LoadString(g_hInst, IDS_NOTHINGTOCOMMIT, szMessage, DIMENSION(szMessage));
                        MessageBox(hWndDlg, szMessage, szTitle, MB_OK);
                    }

                    if(g_dwRefreshNetMap && !bLaunchSite && !bCancel)
                    {
                        LoadString(g_hInst, IDS_CONFIG_COMPLETE_TITLE, szTitle, DIMENSION(szTitle));
                        LoadString(g_hInst, IDS_MANUAL_REFRESH, szTemp1, DIMENSION(szTemp1));

                        if(MessageBox(hWndDlg, szTemp1, szTitle, MB_OKCANCEL) == IDOK)
                            bLaunchSite = TRUE;
					}

					if(bLaunchSite)
					{
                        if (g_szRemoteComputer[0] == TEXT('\0'))
                        {
                            HRESULT hr;

                            hr = LocalRefreshOfNetworkMapping(hWndDlg);
                            if ( FAILED( hr ) )
                            {
                                // put up dialog indicating failure
                            }
                        }
                        else
                        {
						    // launch Validation Site

                            //
                            // Looks like the following lstrcat are OK. The only var is g_szRemoteComputer.
                            // And szURL has 8K space for the result string.
                            //

                            if ((TEXT('\0') != g_szRemoteComputer[0]))
                                {
							    lstrcpy(szURL, _T("http://"));
                                lstrcat(szURL, g_szRemoteComputer);
                                lstrcat(szURL, _T("/passporttest/default.asp?Refresh=True&Env="));
                                }
                            else
							    lstrcpy(szURL, _T("http://localhost/passporttest/default.asp?Refresh=True&Env="));

						    // get env
						    if(lstrcmp(g_CurrentSettings.szEnvName, g_szEnglishPreProduction) == 0)
							    lstrcat(szURL, _T("Prep"));
						    else if(lstrcmp(g_CurrentSettings.szEnvName, g_szEnglishBetaPreProduction) == 0)
							    lstrcat(szURL, _T("Beta"));
						    else if(lstrcmp(g_CurrentSettings.szEnvName, g_szEnglishOther) == 0)
							    lstrcat(szURL, _T("Other"));
						    else // must be Production
							    lstrcat(szURL, _T("Prod"));

						    // NewID=True when switching to or from Prod.
						    if(bToFromProd)
							    lstrcat(szURL, _T("&NewID=True"));
						    else
							    lstrcat(szURL, _T("&NewID=False"));

						    ret = ShellExecute(hWndDlg, _T("open"), szURL, NULL, NULL, 0);
                            if (ret <= (HINSTANCE) 32)
                            {
							    LoadString(g_hInst, IDS_OPEN_TITLE, szTitle, DIMENSION(szTitle));
							    LoadString(g_hInst, IDS_OPEN_ERROR, szTemp1, DIMENSION(szTemp1));
							    int Choice = IDRETRY;
							    while (Choice == IDRETRY)
							    {
								    ret = ShellExecute(hWndDlg, _T("open"), szURL, NULL, NULL, 0);
								    if (ret <= (HINSTANCE) 32)
									    Choice = MessageBox(hWndDlg, szTemp1, szTitle, MB_RETRYCANCEL);
								    else
									    Choice = IDCANCEL;
                                }
                            }
                        }
                    }

					if(g_dwRefreshNetMap == 1l)
					{
						g_dwRefreshNetMap = 0l;
						CheckDlgButton(hWndDlg, IDC_REFRESH_NET, BST_UNCHECKED);
					}

					break;
                }

                case IDC_UNDO:
                {
                    // Restore the original settings, and re-init the current settings
                    InitMainDlg(hWndDlg, &g_OriginalSettings);
                    memcpy(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS));
                    break;
                }

                case IDC_CONFIGSETS:
                {
                    TCHAR   szDefault[MAX_RESOURCE];
                    TCHAR   szConfigSet[MAX_CONFIGSETNAME];

                    if(CBN_SELCHANGE == HIWORD(wParam))
                    {
                        GetDlgItemText(hWndDlg,
                                       IDC_CONFIGSETS,
                                       szConfigSet,
                                       DIMENSION(szConfigSet));

                        //
                        //  Convert <Default> to empty string.
                        //

                        LoadString(g_hInst, IDS_DEFAULT, szDefault, DIMENSION(szDefault));
                        if(lstrcmp(szConfigSet, szDefault) == 0)
                            szConfigSet[0] = TEXT('\0');

                        //
                        //  If it's the current set, do nothing.
                        //

                        if(lstrcmp(szConfigSet, g_szConfigSet) != 0)
                        {
                            DoConfigSwitch(hWndDlg, g_szRemoteComputer, szConfigSet);
                        }

                        break;
                    }

                    break;
                }

				case IDC_ENABLE_MANREFRESH:
				{
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
						{
                            g_CurrentSettings.dwEnableManualRefresh = 1l;
							EnableWindow(GetDlgItem(hWndDlg, IDC_REFRESH_NET), TRUE);
						}
                        else
						{
                            g_CurrentSettings.dwEnableManualRefresh = 0l;
							g_dwRefreshNetMap = 0l;
							EnableWindow(GetDlgItem(hWndDlg, IDC_REFRESH_NET), FALSE);
							CheckDlgButton(hWndDlg, IDC_REFRESH_NET, BST_UNCHECKED);
						}
                    }
					break;
				}

				case IDC_REFRESH_NET:
				{
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
						{
                            g_dwRefreshNetMap = 1l;
						}
                        else
						{
                            g_dwRefreshNetMap = 0l;
						}
                    }
					break;
				}

                case IDC_ENVCHANGE:
                {
                    if(EnvChange(hWndDlg,
                                    g_CurrentSettings.szEnvName,
                                    g_CurrentSettings.cbEnvName) == TRUE)
                    {
						InitMainDlg(hWndDlg, &g_CurrentSettings);
                    }

                    break;
                }

                case IDC_NEWCONFIG:
                {
                    DWORD       dwCurSel;
                    TCHAR       szConfigSet[MAX_CONFIGSETNAME];
                    PMSETTINGS  *pNewConfig;

                    pNewConfig = (PMSETTINGS*)LocalAlloc(LMEM_FIXED, sizeof(PMSETTINGS));
                    if (NULL == pNewConfig)
                    {
                        break;
                    }

                    GetDefaultSettings(pNewConfig);

					_tcscpy(pNewConfig->szRemoteFile, g_CurrentSettings.szRemoteFile);
					_tcscpy(pNewConfig->szEnvName, g_CurrentSettings.szEnvName);
					pNewConfig->dwEnableManualRefresh = g_CurrentSettings.dwEnableManualRefresh;

                    if(!NewConfigSet(hWndDlg,
                                    szConfigSet,
                                    DIMENSION(szConfigSet),
                                    pNewConfig->szHostName,
                                    pNewConfig->cbHostName,
                                    pNewConfig->szHostIP,
                                    pNewConfig->cbHostIP))
                    {
                        LocalFree(pNewConfig);
                        break;
                    }

                    if(WriteRegConfigSet(hWndDlg, pNewConfig, g_szRemoteComputer, szConfigSet))
                    {
                        if(DoConfigSwitch(hWndDlg, g_szRemoteComputer, szConfigSet))
                        {
                            memcpy(g_szConfigSet, szConfigSet, sizeof(g_szConfigSet));
                            memcpy(&g_OriginalSettings, pNewConfig, sizeof(PMSETTINGS));
                            memcpy(&g_CurrentSettings, pNewConfig, sizeof(PMSETTINGS));

                            InitMainDlg(hWndDlg, &g_OriginalSettings);
                        }
                        else
                        {
                            RemoveRegConfigSet(hWndDlg, g_szRemoteComputer, szConfigSet);
                        }
                    }
                    else
                    {
                        ReportError(hWndDlg, IDS_WRITENEW_ERROR);
                    }

                    LocalFree(pNewConfig);
                    break;
                }

                case IDC_REMOVECONFIG:
                {
                    LRESULT dwCurSel;
                    LRESULT dwNumItems;
                    TCHAR   szDefault[MAX_RESOURCE];

                    dwCurSel = SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_GETCURSEL, 0, 0L);
                    if(dwCurSel == 0 || dwCurSel == CB_ERR)
                        break;

                    if(!RemoveConfigSetWarning(hWndDlg))
                        break;

                    if(!RemoveRegConfigSet(hWndDlg, g_szRemoteComputer, g_szConfigSet))
                    {
                        //MessageBox(
                        break;
                    }

                    dwNumItems = SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_GETCOUNT, 0, 0L);


                    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_DELETESTRING, dwCurSel, 0L);

                    //  Was this the last item in the list?
                    if(dwCurSel + 1 == dwNumItems)
                        dwCurSel--;

                    SendDlgItemMessage(hWndDlg, IDC_CONFIGSETS, CB_SETCURSEL, dwCurSel, 0L);

                    GetDlgItemText(hWndDlg, IDC_CONFIGSETS, g_szConfigSet, DIMENSION(g_szConfigSet));
                    LoadString(g_hInst, IDS_DEFAULT, szDefault, DIMENSION(szDefault));
                    if(lstrcmp(g_szConfigSet, szDefault) == 0)
                        g_szConfigSet[0] = TEXT('\0');

                    // [CR] Should warn if changes have not been committed!
                    InitializePMConfigStruct(&g_OriginalSettings);
                    if (ReadRegConfigSet(hWndDlg,
                                         &g_OriginalSettings,
                                         g_szRemoteComputer,
                                         g_szConfigSet))
                    {
                        InitMainDlg(hWndDlg, &g_OriginalSettings);
                        // Make a copy of the original setting for editing purposes
                        memcpy(&g_CurrentSettings, &g_OriginalSettings, sizeof(PMSETTINGS));
                    }

                    break;
                }

                case IDC_TIMEWINDOW:
                {
                    BOOL    bValid = TRUE;
                    DWORD   dwEditValue = GetDlgItemInt(hWndDlg, wCmd, &bValid, FALSE);

                    // Look at the notification code
                    if (EN_KILLFOCUS == HIWORD(wParam))
                    {
                        if (bValid && (dwEditValue >= 100) && (dwEditValue <= MAX_TIME_WINDOW_SECONDS))
                        {
                            g_CurrentSettings.dwTimeWindow = dwEditValue;
                            SetUndoButton(hWndDlg, TRUE);
                            UpdateTimeWindowDisplay(hWndDlg, dwEditValue);
                        }
                        else
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            SetFocus(GetDlgItem(hWndDlg, wCmd));
                            bOkToClose = FALSE;
                        }
                    }

                    break;
                }

                case IDC_LANGUAGEID:
                {
                    // Look at the notification code
                    switch (HIWORD(wParam))
                    {
                        // The user selected a different value in the LangID combo
                        case CBN_SELCHANGE:
                        {
                            // Get the index of the new item selected and update with the approparite
                            // language ID string
                            LRESULT idx = SendDlgItemMessage(hWndDlg, IDC_LANGUAGEID, CB_GETCURSEL, 0, 0);

                            // Update the current Settings
                            g_CurrentSettings.dwLanguageID =
                                        (DWORD) SendDlgItemMessage(hWndDlg,
                                                                   IDC_LANGUAGEID,
                                                                   CB_GETITEMDATA,
                                                                   idx,
                                                                   0);

                            SetUndoButton(hWndDlg, TRUE);
                            break;
                        }
                    }
                    break;
                }

                case IDC_COBRANDING_TEMPLATE:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szCoBrandTemplate;
                    cbStrToUpdate = g_CurrentSettings.cbCoBrandTemplate;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_RETURNURL:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szReturnURL;
                    cbStrToUpdate = g_CurrentSettings.cbReturnURL;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_COOKIEDOMAIN:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szTicketDomain;
                    cbStrToUpdate = g_CurrentSettings.cbTicketDomain;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_COOKIEPATH:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szTicketPath;
                    cbStrToUpdate = g_CurrentSettings.cbTicketPath;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_PROFILEDOMAIN:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szProfileDomain;
                    cbStrToUpdate = g_CurrentSettings.cbProfileDomain;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_PROFILEPATH:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szProfilePath;
                    cbStrToUpdate = g_CurrentSettings.cbProfilePath;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_SECUREDOMAIN:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szSecureDomain;
                    cbStrToUpdate = g_CurrentSettings.cbSecureDomain;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_SECUREPATH:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szSecurePath;
                    cbStrToUpdate = g_CurrentSettings.cbSecurePath;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                case IDC_DISASTERURL:
                    lpszStrToUpdate = (LPTSTR)&g_CurrentSettings.szDisasterURL;
                    cbStrToUpdate = g_CurrentSettings.cbDisasterURL;
                    goto HANDLE_EN_FOR_STRING_CTRLS;

                {

HANDLE_EN_FOR_STRING_CTRLS:
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            if (!g_bCanUndo)
                                SetUndoButton(hWndDlg, TRUE);

                            // Get the updated Value
                            // cbStrToUpdate is BYTE count
                            //
                            GetDlgItemText(hWndDlg,
                                           wCmd,
                                           lpszStrToUpdate,
                                           cbStrToUpdate/sizeof(TCHAR));

                            break;

                        case EN_MAXTEXT:
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            break;
                        }
                    }
                    break;
                }

                case IDC_HOSTNAMEEDIT:
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            {
                                TCHAR   szHostName[INTERNET_MAX_HOST_NAME_LENGTH];

                                if (!g_bCanUndo)
                                    SetUndoButton(hWndDlg, TRUE);

                                // Get the updated Value
                                GetDlgItemText(hWndDlg,
                                               wCmd,
                                               szHostName,
                                               DIMENSION(szHostName));

                                if(lstrlen(szHostName) == 0 && g_szConfigSet[0])
                                {
                                    ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                                    //SetDlgItemText(hWndDlg, IDC_HOSTNAMEEDIT, g_CurrentSettings.szHostName); (commented, bug #9080)
                                    SetFocus(GetDlgItem(hWndDlg, IDC_HOSTNAMEEDIT));
                                }
                                else
                                {
                                    lstrcpy(g_CurrentSettings.szHostName, szHostName);
                                }
                            }
                            break;

                        case EN_MAXTEXT:
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            break;
                        }
                    }
                    break;

                case IDC_HOSTIPEDIT:
                    switch (HIWORD(wParam))
                    {
                        case EN_KILLFOCUS:
                            {
                                TCHAR   szHostIP[MAX_IPLEN];

                                // Get the updated Value
                                GetDlgItemText(hWndDlg,
                                               wCmd,
                                               szHostIP,
                                               DIMENSION(szHostIP));

                                if((lstrlen(szHostIP) > 0 && g_szConfigSet[0] == 0) || !IsValidIP(szHostIP)) //bug 8834
                                {
                                    ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                                    SetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, g_CurrentSettings.szHostIP);
                                    SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                                }
                            }
                            break;

                        case EN_CHANGE:
                            {
                                TCHAR   szHostIP[MAX_IPLEN];

                                if (!g_bCanUndo)
                                    SetUndoButton(hWndDlg, TRUE);

                                // Get the updated Value
                                GetDlgItemText(hWndDlg,
                                               wCmd,
                                               szHostIP,
                                               DIMENSION(szHostIP));

                                if(lstrlen(szHostIP) == 0 && g_szConfigSet[0])
                                {
                                    ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                                    // SetDlgItemText(hWndDlg, IDC_HOSTIPEDIT, g_CurrentSettings.szHostIP); (commented, bug #9080)
                                    SetFocus(GetDlgItem(hWndDlg, IDC_HOSTIPEDIT));
                                }
                                else
                                {
                                    lstrcpy(g_CurrentSettings.szHostIP, szHostIP);
                                }
                            }
                            break;

                        case EN_MAXTEXT:
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            break;
                        }
                    }
                    break;

                case IDC_SITEID:
                {
                    BOOL    bValid = TRUE;
                    DWORD   dwEditValue = GetDlgItemInt(hWndDlg, wCmd, &bValid, FALSE);

                    // Look at the notification code
                    if (EN_CHANGE == HIWORD(wParam))
                    {
                        if (bValid && (dwEditValue >= 1) && (dwEditValue <= MAX_SITEID))
                        {
                            g_CurrentSettings.dwSiteID = dwEditValue;
                            SetUndoButton(hWndDlg, TRUE);
                        }
                        else
                        {
                            ReportControlMessage(hWndDlg, wCmd, VALIDATION_ERROR);
                            SetDlgItemInt(hWndDlg, wCmd, g_CurrentSettings.dwSiteID, FALSE);
                            SetFocus(GetDlgItem(hWndDlg, wCmd));
                        }
                    }
                    break;
                }

                case IDC_STANDALONE:
                {
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
                            g_CurrentSettings.dwStandAlone = 1l;
                        else
                            g_CurrentSettings.dwStandAlone = 0l;
                    }
                    break;
                }


				/////////////////////////////////////////////////////////////
				//JVP 3/2/2000
				/////////////////////////////////////////////////////////////
                case IDC_VERBOSE_MODE:
                {
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
                            g_CurrentSettings.dwVerboseMode = 1l;
                        else
                            g_CurrentSettings.dwVerboseMode = 0l;
                    }
                    break;
                }



                case IDC_DISABLECOOKIES:
                {
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
                            g_CurrentSettings.dwDisableCookies = 1l;
                        else
                            g_CurrentSettings.dwDisableCookies = 0l;
                    }
                    break;
                }

                case IDC_FORCESIGNIN:
                {
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        SetUndoButton(hWndDlg, TRUE);
                        if (BST_CHECKED == IsDlgButtonChecked(hWndDlg, wCmd))
                            g_CurrentSettings.dwForceSignIn = 1l;
                        else
                            g_CurrentSettings.dwForceSignIn = 0l;
                    }
                    break;
                }

                default:
                {
                    if(wCmd >= IDM_COMPUTERMRUBASE && wCmd < IDM_COMPUTERMRUBASE + COMPUTER_MRU_SIZE)
                    {
                        HMENU   hMenu = NULL;
                        TCHAR   achBuf[MAX_PATH];
                        TCHAR   achTemp[MAX_REGISTRY_STRING];
                        LPTSTR  szNewRemoteComputer;

                        //
                        //  Get the selected computer.
                        //
                        if (NULL == (hMenu = GetMenu(hWndDlg)))
                        {
                            break;
                        }

                        if(GetMenuString(hMenu,
                                      wCmd,
                                      achBuf,
                                      MAX_PATH,
                                      MF_BYCOMMAND) == 0)
                            break;

                        //
                        //  Get past the shortcut chars.
                        //

                        szNewRemoteComputer = _tcschr(achBuf, TEXT(' '));
                        if(szNewRemoteComputer == NULL)
                            break;
                        szNewRemoteComputer++;

                        //
                        //  Is it local host?
                        //

                        LoadString(g_hInst, IDS_LOCALHOST, achTemp, DIMENSION(achTemp));
                        if(lstrcmp(szNewRemoteComputer, achTemp) == 0)
                        {
                            achBuf[0] = TEXT('\0');
                            szNewRemoteComputer = achBuf;
                        }

                        //
                        //  Now try to connect and read.
                        //

                        if(!DoServerSwitch(hWndDlg, szNewRemoteComputer))
                            DoConfigSwitch(hWndDlg, g_szRemoteComputer, g_szConfigSet);

                        break;
                    }

                    break;
                }
            }
            break;
        }

        case WM_CLOSE:
            {
                HWND hwndFocus = GetFocus();

                bOkToClose = TRUE;
                SetFocus(NULL);

                if(bOkToClose)
                    DoExit(hWndDlg);
                else
                    SetFocus(hwndFocus);
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pmconfig.rc
//
#define IDI_PMADMIN                     100
#define IDD_MAIN                        106
#define IDD_PMADMINCONNECT              107
#define IDD_CONFIRM_COMMIT              108
#define IDD_ABOUT_DIALOG                110
#define IDR_MAIN_MENU                   111
#define IDD_NEW_CONFIGSET               113
#define IDD_CHOOSE_ENV                  115
#define IDD_ENV_CHANGE                  115
#define IDD_VERIFY_CHANGE               116
#define IDD_CONFIG_CHANGE               118
#define IDD_ENV_CHANGE1                 119
#define CTRL_BASE                       1000
#define IDC_TIMEWINDOW                  1000
#define IDC_FORCESIGNIN                 1001
#define IDC_LANGUAGEID                  1002
#define IDC_COBRANDING_TEMPLATE         1003
#define IDC_SITEID                      1004
#define IDC_RETURNURL                   1005
#define IDC_COOKIEDOMAIN                1006
#define IDC_COOKIEPATH                  1007
#define IDC_STANDALONE                  1008
#define IDC_DISABLECOOKIES              1009
#define IDC_DISASTERURL                 1010
#define IDC_HOSTNAMEEDIT                1011
#define IDC_HOSTIPEDIT                  1012
#define IDC_PROFILEDOMAIN               1013
#define IDC_PROFILEPATH                 1014
#define IDC_SECUREDOMAIN                1015
#define IDC_SECUREPATH                  1016
#define IDC_VERBOSE_MODE                1017
#define IDC_TIMEWINDOW_SECONDS          1018
#define IDC_REMOTEFILE                  1018
//#define IDC_TIMEWINDOW_SPIN             1019
#define IDC_KEYLIST                     1024
#define IDC_PROMOTE_KEY                 1025
#define IDC_INSTALLDIR                  1026
#define IDC_ENVIRONMENT                 1028
#define IDC_CURRENTKEY                  1030
#define IDC_COMMIT                      1032
#define IDC_UNDO                        1033
#define IDC_CHANGEENV                   1034
#define IDC_ENVCHANGE                   1034
#define IDC_LANGUAGEID_LANG             1041
#define IDC_TIMEWINDOW_TIME             1042
#define IDC_SERVERNAME                  1043
#define IDC_BROWSE                      1045
#define IDC_REMOTENAME                  1046
#define IDC_OTHER_TYPE                  1049
#define IDC_COOKIES_TYPE                1050
#define IDC_SITEID_TYPE                 1051
#define IDC_STANDALONE_TYPE             1052
#define IDC_OTHER_WARN                  1053
#define IDC_COOKIES_WARN                1054
#define IDC_SITEID_WARN                 1055
#define IDC_STANDALONE_WARN             1056
#define IDC_CHANGE_ICON                 1057
#define IDC_OTHERPROCESS                1058
#define IDC_PRODUCTID                   1059
#define IDC_PRODUCTVERSION              1060
#define IDC_NEWCONFIG                   1061
#define IDC_REMOVECONFIG                1062
#define IDC_CONFIGSETS                  1063
#define IDC_HOSTNAMETEXT                1066
#define IDC_CONFIGSETEDIT               1067
#define IDC_HOSTIPTEXT                  1068
#define IDC_COOKIEDOMAIN_TEXT           1070
#define IDC_COOKIEPATH_TEXT             1071
#define IDC_ENVIRONMENT_LIST            1075
#define IDC_ENV_LIST                    1075
#define IDC_PRODUCTION                  1077
#define IDC_PREPRODUCTION               1078
#define IDC_BETA_PREPRODUCTION          1079
#define IDC_OTHER                       1080
#define IDC_DESC                        1082
#define IDC_MOREINFO                    1083
#define IDC_ENABLE_MANREFRESH           1084
#define IDC_REFRESH_NET                 1085
#define IDM_EXIT                        2001
#define IDM_SELECT                      2002
#define IDM_REFRESH                     2003
#define IDM_ABOUT                       2004
#define IDM_PRECONFIG                   2005
#define IDM_OPEN                        2006
#define IDM_SAVE                        2007
#define IDM_SAVEAS                      2008
#define IDM_HELP                        2009
#define IDM_COMPUTERMRUBASE             2100
#define IDS_ERROR                       3000
#define IDS_WARNING                     3001
#define IDS_TIMEWINDOW_ERROR            3002
#define IDS_LANGUAGEID_ERROR            3004
#define IDS_SITEID_ERROR                3006
#define IDS_SITEID_WARN                 3007
#define IDS_COBRANDING_ERROR            3009
#define IDS_RETURNURL_ERROR             3011
#define IDS_COOKIEDOMAIN_ERROR          3013
#define IDS_COOKIEPATH_ERROR            3015
#define IDS_STANDALONE_WARN             3017
#define IDS_DISABLECOOKIE_WARN          3018
#define IDS_CONSISTENCY_WARN            3019
#define IDS_ABOUTTOCOMMIT               3020
#define IDS_COMMITERROR                 3021
#define IDS_REGISTRYCHANGED             3022
#define IDS_CONFIGREAD_ERROR            3023
#define IDS_CONNECTNOTLOCAL             3024
#define IDS_CONNECTBADNAME              3025
#define IDS_CONNECTROOTFAILED           3026
#define IDS_SECURECOOKIEPATH_ERROR      3026
#define IDS_CONNECTACCESSDENIED         3027
#define IDS_COMPUTERBROWSETITLE         3028
#define IDS_LOCALHOST                   3029
#define IDS_OPENFILETITLE               3030
#define IDS_SAVEFILETITLE               3031
#define IDS_PMCONFIGDEFEXT              3032
#define IDS_PMOPENFILEFILTER            3033
#define IDS_PMSAVEFILEFILTER            3034
#define IDS_PMHELPFILE                  3035
#define IDS_TIMEWINDOW                  3036
#define IDS_FORCESIGNIN                 3037
#define IDS_LANGUAGEID                  3038
#define IDS_COBRANDTEMPLATE             3039
#define IDS_RETURNURL                   3040
#define IDS_COOKIEDOMAIN                3041
#define IDS_TICKETDOMAIN                3041
#define IDS_COOKIEPATH                  3042
#define IDS_TICKETPATH                  3042
#define IDS_DISASTERURL                 3043
#define IDS_APP_TITLE                   3044
#define IDS_NOTHINGTOCOMMIT             3045
#define IDS_PRODUCTID                   3046
#define IDS_USAGE                       3047
#define IDS_FILENOTFOUND                3048
#define IDS_PRODUCTVERSION              3049
#define IDS_DISASTERURL_ERROR           3050
#define IDS_HOSTNAME                    3051
#define IDS_HOSTIP                      3052
#define IDS_HOSTNAME_ERROR              3053
#define IDS_HOSTIP_ERROR                3054
#define IDS_DEFAULT                     3055
#define IDS_REMOVE_WARNING              3056
#define IDS_REMOVE_TITLE                3057
#define IDS_EMPTYSITENAME               3058
#define IDS_EMPTYHOSTNAME               3059
#define IDS_EMPTYHOSTIP                 3060
#define IDS_WRITENEW_ERROR              3061
#define IDS_SAVE_PROMPT                 3062
#define IDS_INVALIDSITENAME             3063
#define IDS_HOSTNAMETRUNC_WARN          3064
#define IDS_HOSTIPTRUNC_WARN            3065
#define IDS_PROFILEDOMAIN_ERROR         3066
#define IDS_PROFILEPATH_ERROR           3067
#define IDS_PROFILEDOMAIN               3068
#define IDS_PROFILEPATH                 3069
#define IDS_SECUREPATH_ERROR            3070
#define IDS_SECUREDOMAIN                3071
#define IDS_SECUREPATH                  3072
#define IDS_SECUREDOMAIN_ERROR          3073
#define IDS_EXISTINGSITENAME            3074
#define IDS_INVALIDHOSTIP               3075
#define IDS_PRODUCTION                  3075
#define IDS_PREPRODUCTION               3076
#define IDS_BETAPREPRODUCTION           3077
#define IDS_OTHER                       3078
#define IDS_VERIFY_ENV_CHANGE           3079
#define IDS_VERIFY_ENV_CHANGE2          3080
#define IDS_CONFIG_COMPLETE             3081
#define IDS_REMOTEFILE                  3082
#define IDS_ENVNAME                     3083
#define IDS_VERIFY_TITLE                3084
#define IDS_CONFIG_COMPLETE_TITLE       3085
#define IDS_PROD_DESC                   3086
#define IDS_PREP_DESC                   3087
#define IDS_BETA_DESC                   3088
#define IDS_OTHER_DESC                  3089
#define IDS_VERBOSE_MODE                3090
#define IDS_OPEN_ERROR                  3091
#define IDS_OPEN_TITLE                  3092
#define IDS_MANUAL_REFRESH              3093

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         2006
#define _APS_NEXT_CONTROL_VALUE         1085
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\pmhelp.h ===
// Help IDs for Passport Mananger Config 

#define NO_HELP                 ((DWORD) -1) // Disables Help for a control

#define IDH_PMADMIN_CONNECT         1000
#define IDH_PMADMIN_CONNECT_BROWSE  1001
#define IDH_SERVERNAME              1002
#define IDH_INSTALLDIR              1003
#define IDH_VERSION                 1004
#define IDH_TIMEWINDOW              1005
#define IDH_FORCESIGNIN             1006
#define IDH_LANGUAGEID              1007
#define IDH_COBRANDING_TEMPLATE     1008
#define IDH_SITEID                  1009
#define IDH_RETURNURL               1010
#define IDH_COOKIEDOMAIN            1011
#define IDH_COOKIEPATH              1012
#define IDH_STANDALONE              1013
#define IDH_DISABLECOOKIES          1014
#define IDH_COMMIT                  1015
#define IDH_UNDO                    1016
#define IDH_DISASTERURL             1017
#define IDH_CONFIGSETS              1018
#define IDH_NEWCONFIG               1019
#define IDH_REMOVECONFIG            1020
#define IDH_HOSTNAMEEDIT            1021
#define IDH_HOSTIPEDIT              1022
#define IDH_PROFILEDOMAIN           1023
#define IDH_PROFILEPATH             1024
#define IDH_SECUREDOMAIN            1025
#define IDH_SECUREPATH              1026
#define IDH_VERBOSE_MODE            1027
#define IDH_ENVCHANGE               1028
#define IDH_ENVIRONMENT             1029
#define IDH_ENABLEMREFRESH          1030
#define IDH_NSREFRESH               1031
#define IDH_CONFIGSETEDIT           1032
#define IDH_REMOTEFILE              1033
#define IDH_MOREINFO                1034
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\pmnet.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     PMNET.CPP

   PURPOSE:    Source module for Passport Manager config tool, remote
               machine access

   FUNCTIONS:

   COMMENTS:    Borrowed from Regedit
      
**************************************************************************/

#include "pmcfg.h"

const DWORD s_PMAdminConnectHelpIDs[] = 
{
    IDC_REMOTENAME, IDH_PMADMIN_CONNECT,
    IDC_BROWSE,     IDH_PMADMIN_CONNECT_BROWSE,
    0, 0
};

VOID PASCAL PMAdmin_Connect_OnCommandBrowse(HWND hWnd);
INT_PTR CALLBACK PMAdmin_ConnectDlgProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

/*******************************************************************************
*
*  PMAdmin_OnCommandConnect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PMAdmin_OnCommandConnect
(
    HWND    hWnd,
    LPTSTR  lpszRemoteName
)
{

    TCHAR           RemoteName[MAX_PATH];
    LPTSTR          lpUnslashedRemoteName;
    TCHAR           ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD           cbComputerName;

    // Pre-populate the remote name if we already have one
    lstrcpyn(RemoteName, lpszRemoteName, DIMENSION(RemoteName));
        
    //
    //  Query the user for the name of the remote computer to connect to.
    //
    if (DialogBoxParam(g_hInst, 
                       MAKEINTRESOURCE(IDD_PMADMINCONNECT), 
                       hWnd,
                       PMAdmin_ConnectDlgProc, 
                       (LPARAM) (LPTSTR) RemoteName) != IDOK)
        return FALSE;

    lpUnslashedRemoteName = (RemoteName[0] == TEXT('\\') &&
        RemoteName[1] == TEXT('\\')) ? &RemoteName[2] : &RemoteName[0];

    CharLower(lpUnslashedRemoteName);
    CharUpperBuff(lpUnslashedRemoteName, 1);

    //
    //  Check if the user is trying to connect to the local computer and prevent
    //  this.
    //
    cbComputerName = sizeof(ComputerName)/sizeof(TCHAR);

    if (GetComputerName(ComputerName, &cbComputerName)) 
    {
        if (lstrcmpi(lpUnslashedRemoteName, ComputerName) == 0) 
        {
            ReportError(hWnd, IDS_CONNECTNOTLOCAL);
        }
        else
        {
            lstrcpy(lpszRemoteName, lpUnslashedRemoteName);
        }
    }

    return TRUE;
}

/*******************************************************************************
*
*  PMAdmin_ConnectDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

INT_PTR CALLBACK PMAdmin_ConnectDlgProc
(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
)
{

    LPTSTR lpRemoteName;

    switch (Message) 
    {

        case WM_INITDIALOG:
            SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) lParam);
            SendDlgItemMessage(hWnd, IDC_REMOTENAME, EM_SETLIMITTEXT, MAX_PATH, 0);
            SetDlgItemText(hWnd, IDC_REMOTENAME, (LPTSTR) lParam);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            {
                case IDC_BROWSE:
                    PMAdmin_Connect_OnCommandBrowse(hWnd);
                    break;

                case IDOK:
                    lpRemoteName = (LPTSTR) GetWindowLongPtr(hWnd, DWLP_USER);
                    GetDlgItemText(hWnd, IDC_REMOTENAME, lpRemoteName, MAX_PATH);
                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

            }
            break;

        case WM_HELP:
            WinHelp( (HWND)((LPHELPINFO) lParam)->hItemHandle, g_szHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) s_PMAdminConnectHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_szHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) s_PMAdminConnectHelpIDs);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

/*******************************************************************************
*
*  PMAdmin_Connect_OnCommandBrowse
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID PASCAL PMAdmin_Connect_OnCommandBrowse
(
    HWND hWnd
)
{
    BROWSEINFO      BrowseInfo;
    LPITEMIDLIST    pidlComputer;
    TCHAR           RemoteName[MAX_PATH];
    TCHAR           szTitle[MAX_TITLE];
    LPMALLOC        lpMalloc;               // Pointer to shell allocator interface
        
    BrowseInfo.hwndOwner = hWnd;
    BrowseInfo.pidlRoot = (LPITEMIDLIST) MAKEINTRESOURCE(CSIDL_NETWORK);
    BrowseInfo.pszDisplayName = RemoteName;
    
    LoadString(g_hInst, IDS_COMPUTERBROWSETITLE, szTitle, DIMENSION(szTitle));
    BrowseInfo.lpszTitle = szTitle;
    BrowseInfo.ulFlags = BIF_BROWSEFORCOMPUTER;
    BrowseInfo.lpfn = NULL;

    if ((pidlComputer = SHBrowseForFolder(&BrowseInfo)) != NULL) 
    {
        // Free the pidl allocated by the BrowserForFolder call
        if ((NOERROR == SHGetMalloc(&lpMalloc)) && (NULL != lpMalloc)) 
        { 
            lpMalloc->Free(pidlComputer);
            lpMalloc->Release();
        }
        
        SetDlgItemText(hWnd, IDC_REMOTENAME, RemoteName);
        EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\pmconfig\regcfg.cpp ===
/**************************************************************************
   Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.

   MODULE:     REGCFG.CPP

   PURPOSE:    Source module reading/writing PM config sets from the registry

   FUNCTIONS:

   COMMENTS:

**************************************************************************/

/**************************************************************************
   Include Files
**************************************************************************/

#include "pmcfg.h"
#include "keycrypto.h"

// Reg Keys/values that we care about
TCHAR       g_szPassportReg[] = TEXT("Software\\Microsoft\\Passport");
TCHAR       g_szPassportPartner[] = TEXT("Software\\Microsoft\\Passport\\Nexus\\Partner");
TCHAR       g_szPassportEnvironments[] = TEXT("Software\\Microsoft\\Passport\\Environments");
TCHAR       g_szEncryptionKeyData[] = TEXT("KeyData");
TCHAR       g_szKeyTimes[] = TEXT("KeyTimes");
TCHAR       g_szNexus[] = TEXT("Nexus");
TCHAR       g_szPartner[] = TEXT("Partner");
TCHAR       g_szInstallDir[] = TEXT("InstallDir");
TCHAR       g_szVersion[] = TEXT("Version");
TCHAR       g_szTimeWindow[] = TEXT("TimeWindow");
TCHAR       g_szForceSignIn[] = TEXT("ForceSignIn");
TCHAR       g_szNSRefresh[] = TEXT("NSRefresh");
TCHAR       g_szLanguageID[] = TEXT("LanguageID");
TCHAR       g_szCoBrandTemplate[] = TEXT("CoBrandTemplate");
TCHAR       g_szSiteID[] = TEXT("SiteID");
TCHAR       g_szReturnURL[] = TEXT("ReturnURL");
TCHAR       g_szTicketDomain[] = TEXT("TicketDomain");
TCHAR       g_szTicketPath[] = TEXT("TicketPath");
TCHAR       g_szProfileDomain[] = TEXT("ProfileDomain");
TCHAR       g_szProfilePath[] = TEXT("ProfilePath");
TCHAR       g_szSecureDomain[] = TEXT("SecureDomain");
TCHAR       g_szSecurePath[] = TEXT("SecurePath");
TCHAR       g_szCurrentKey[] = TEXT("CurrentKey");
TCHAR       g_szStandAlone[] = TEXT("StandAlone");
TCHAR       g_szDisableCookies[] = TEXT("DisableCookies");
TCHAR       g_szDisasterURL[] = TEXT("DisasterURL");
TCHAR       g_szHostName[] = TEXT("HostName");
TCHAR       g_szHostIP[] = TEXT("HostIP");
//JVP 3/2/2000
TCHAR       g_szVerboseMode[] = TEXT("Verbose");
TCHAR       g_szEnvName[] = TEXT("Environment");
TCHAR       g_szRemoteFile[] = TEXT("CCDRemoteFile");
TCHAR       g_szLocalFile[] = TEXT("CCDLocalFile");
TCHAR       g_szVersion14[] = TEXT("1.4");

TCHAR       g_szSecureLevel[] = TEXT("SecureLevel");


#define  REG_PASSPORT_SITES_VALUE    TEXT("Software\\Microsoft\\Passport\\Sites")
#define  REG_PASSPORT_SITES_LEN      (sizeof(REG_PASSPORT_SITES_VALUE) / sizeof(TCHAR) - 1)

#define REG_CLOSE_KEY_NULL(a) { if ((a) != NULL) { RegCloseKey(a); (a) = NULL; } }


// -------------------------------------------------------------------------------
//
//
// -------------------------------------------------------------------------------
BOOL WriteGlobalConfigSettings(HWND hWndDlg, HKEY hklm, LPPMSETTINGS lpPMConfig, LPTSTR lpszRemoteComputer)
{
	HKEY     hkeyPassport = NULL, hkeyPassportSubKey = NULL;
	long     lRet;
	BOOL     bReturn = FALSE;

	TCHAR    szConfigName[MAX_CONFIGSETNAME];
	TCHAR    szTmpBuf[REG_PASSPORT_SITES_LEN + 1 + MAX_CONFIGSETNAME + 1] = REG_PASSPORT_SITES_VALUE;
	ULONG    nConfigNameSize = MAX_CONFIGSETNAME;
	FILETIME ftime;
	long     nCurrentSubKey;

	// First, open the keys for the default set
	//
	if ((lRet = RegOpenKeyEx(hklm, g_szPassportReg, 0, KEY_ALL_ACCESS, &hkeyPassport)) != ERROR_SUCCESS)
	{
            LPVOID lpMsgBuf;

            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                              NULL,
                              lRet,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                              (LPTSTR) &lpMsgBuf,
                              0,
                              NULL) != 0)
            {
                TCHAR pszTitle[MAX_RESOURCE];

                // Display the string
                LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
                MessageBox( NULL, (LPCTSTR)lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );

                // Free the buffer.
                LocalFree( lpMsgBuf );
            }

            bReturn = FALSE;
            goto Cleanup;
	}

    // Write the value for NSRefresh
    RegSetValueEx(hkeyPassport,
                    g_szNSRefresh,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwEnableManualRefresh,
                    sizeof(DWORD));

    // Write the environment
    RegSetValueEx(hkeyPassport,
                    g_szEnvName,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szEnvName,
                    (lstrlen(lpPMConfig->szEnvName) + 1) * sizeof(TCHAR));

	RegCloseKey(hkeyPassport);
	hkeyPassport = NULL;

        // If the "Sites" key was not found, then there are no Sites to configure
        //
        if ((lRet = RegOpenKeyEx(hklm,
                                 REG_PASSPORT_SITES_VALUE,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hkeyPassport)) != ERROR_SUCCESS)
	{
            bReturn = TRUE;
            goto Cleanup;
	}

	nCurrentSubKey = 0;
	while (lRet = RegEnumKeyEx(hkeyPassport,
                                   nCurrentSubKey++,
                                   szConfigName,
                                   &nConfigNameSize,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &ftime) == ERROR_SUCCESS)
	{
            *(szTmpBuf + REG_PASSPORT_SITES_LEN) = _T('\\');
            *(szTmpBuf + REG_PASSPORT_SITES_LEN + 1) = _T('\0');
            _tcscat(szTmpBuf + REG_PASSPORT_SITES_LEN + 1, szConfigName);

            if ((lRet = RegOpenKeyEx(hklm,
                                     szTmpBuf,
                                     0,
                                     KEY_ALL_ACCESS,
                                     &hkeyPassportSubKey)) != ERROR_SUCCESS)
            {
                ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
                bReturn = FALSE;
                goto Cleanup;
            }


	    // Write the value for NSRefresh
	    RegSetValueEx(hkeyPassportSubKey,
                          g_szNSRefresh,
                          NULL,
                          REG_DWORD,
                          (LPBYTE) &lpPMConfig->dwEnableManualRefresh,
                          sizeof(DWORD));

	    // Write the environment
            RegSetValueEx(hkeyPassportSubKey,
                          g_szEnvName,
                          NULL,
                          REG_SZ,
                          (LPBYTE) lpPMConfig->szEnvName,
                          (lstrlen(lpPMConfig->szEnvName) + 1) * sizeof(TCHAR));

		RegCloseKey(hkeyPassportSubKey);
		hkeyPassportSubKey = NULL;

		nConfigNameSize = MAX_CONFIGSETNAME * sizeof(TCHAR);
	}

	if (lRet == ERROR_SUCCESS)
		bReturn = TRUE;

Cleanup:
	if (hkeyPassport)
		RegCloseKey(hkeyPassport);
	if (hkeyPassportSubKey)
		RegCloseKey(hkeyPassportSubKey);
	return bReturn;
}





/**************************************************************************

    WriteRegTestKey

    Installs the default test key for the named config set.  This is
    only called in the case where a new config set key was created in
    OpenRegConfigSet.

**************************************************************************/
BOOL
WriteRegTestKey
(
    HKEY                    hkeyConfigKey,
    PSECURITY_DESCRIPTOR    pSD
)
{
    BOOL                    bReturn;
    CKeyCrypto              kc;
    HKEY                    hkDataKey = NULL, hkTimeKey = NULL;
    TCHAR                   szKeyNum[2];
    DWORD                   dwKeyVer = 1;

    // Try to encrypt it with MAC address
    BYTE                    original[CKeyCrypto::RAWKEY_SIZE];
    DATA_BLOB               iBlob;
    DATA_BLOB               oBlob;

    SECURITY_ATTRIBUTES     SecAttrib;

    iBlob.cbData = sizeof(original);
    iBlob.pbData = original;

    ZeroMemory(&oBlob, sizeof(oBlob));

    memcpy(original, "123456781234567812345678", CKeyCrypto::RAWKEY_SIZE);
    if (kc.encryptKey(&iBlob, &oBlob) != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    // Now add it to registry

    lstrcpy(szKeyNum, TEXT("1"));

    // set up the security attributes structure for the KeyData reg key
    SecAttrib.nLength = sizeof(SECURITY_ATTRIBUTES);
    SecAttrib.lpSecurityDescriptor = pSD;
    SecAttrib.bInheritHandle = FALSE;


    if(ERROR_SUCCESS != RegCreateKeyEx(hkeyConfigKey,
                                     TEXT("KeyData"),
                                     0,
                                     TEXT(""),
                                     0,
                                     KEY_ALL_ACCESS,
                                     &SecAttrib,
                                     &hkDataKey,
                                     NULL))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(ERROR_SUCCESS != RegCreateKeyEx(hkeyConfigKey,
                                     TEXT("KeyTimes"),
                                     0,
                                     TEXT(""),
                                     0,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hkTimeKey,
                                     NULL))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(ERROR_SUCCESS != RegSetValueEx(hkDataKey,
                                      szKeyNum,
                                      0,
                                      REG_BINARY,
                                      oBlob.pbData,
                                      oBlob.cbData))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if(ERROR_SUCCESS != RegSetValueEx(hkeyConfigKey,
                                      TEXT("CurrentKey"),
                                      0,
                                      REG_DWORD,
                                      (LPBYTE) &dwKeyVer,
                                      sizeof(DWORD)))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:
    if (hkDataKey)
        RegCloseKey(hkDataKey);
    if (hkTimeKey)
        RegCloseKey(hkTimeKey);

    if (oBlob.pbData)
        ::LocalFree(oBlob.pbData);

    return bReturn;
}
/**************************************************************************

    OpenRegConfigSet

    Open and return an HKEY for a named configuration set
    current passport manager config set from the registry

**************************************************************************/
HKEY OpenRegConfigSet
(
    HKEY    hkeyLocalMachine,   //  Local or remote HKLM
    LPTSTR  lpszConfigSetName   //  Name of config set
)
{
    HKEY                    hkeyConfigSets = NULL;
    HKEY                    hkeyConfigSet = NULL;
    DWORD                   dwDisp;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    HKEY                    hDefKeyData = NULL;
    DWORD                   cbSD = 0;
    long                    lRet;

    //
    //  Can't create an unnamed config set.
    //

    if(lpszConfigSetName == NULL ||
       lpszConfigSetName[0] == TEXT('\0'))
    {
        lRet = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (ERROR_SUCCESS != (lRet = RegCreateKeyEx(hkeyLocalMachine,
                                        REG_PASSPORT_SITES_VALUE,
                                        0,
                                        TEXT(""),
                                        0,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hkeyConfigSets,
                                        NULL)))
    {
        goto Cleanup;
    }

    //
    //  Create the key if it doesn't exist, otherwise
    //  open it.
    //

    if (ERROR_SUCCESS != (lRet = RegCreateKeyEx(hkeyConfigSets,
                                        lpszConfigSetName,
                                        0,
                                        TEXT(""),
                                        0,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hkeyConfigSet,
                                        &dwDisp)))
    {
        goto Cleanup;
    }

    //
    //  If we created a new regkey, add encryption keys
    //

    if(dwDisp == REG_CREATED_NEW_KEY)
    {
        // first read the SD from the default key data
        if (ERROR_SUCCESS !=
            RegOpenKeyEx(hkeyLocalMachine,
                         L"Software\\Microsoft\\Passport\\KeyData",
                         0,
                         KEY_READ,
                         &hDefKeyData))
        {
            RegCloseKey(hkeyConfigSet);
            hkeyConfigSet = NULL;
            goto Cleanup;
        }

        if (ERROR_INSUFFICIENT_BUFFER !=
            RegGetKeySecurity(hDefKeyData,
                          DACL_SECURITY_INFORMATION,
                          &cbSD,
                          &cbSD))
        {
            RegCloseKey(hkeyConfigSet);
            hkeyConfigSet = NULL;
            goto Cleanup;
        }

        if (NULL == (pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD)))
        {
            RegCloseKey(hkeyConfigSet);
            hkeyConfigSet = NULL;
            goto Cleanup;
        }

        if (ERROR_SUCCESS !=
            RegGetKeySecurity(hDefKeyData,
                          DACL_SECURITY_INFORMATION,
                          pSD,
                          &cbSD))
        {
            RegCloseKey(hkeyConfigSet);
            hkeyConfigSet = NULL;
            goto Cleanup;
        }

        // create the new key data
        if (!WriteRegTestKey(hkeyConfigSet, pSD))
        {
            RegCloseKey(hkeyConfigSet);
            hkeyConfigSet = NULL;
            goto Cleanup;
        }
    }

Cleanup:
    if (pSD)
    {
        LocalFree(pSD);
    }

    if (hDefKeyData)
    {
        RegCloseKey(hDefKeyData);
    }

    if(hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);
    else {
        LPVOID lpMsgBuf;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          lRet,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL) != 0)
        {
            TCHAR pszTitle[MAX_RESOURCE];

            // Display the string.
            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }
    }

    return hkeyConfigSet;
}

/**************************************************************************

    OpenTopRegKey

    Open the top reg key, if we aren't allowed to then fail.

**************************************************************************/
BOOL OpenTopRegKey
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteComputer,
    HKEY            *phklm,
    HKEY            *phkeyPassport
)
{
    BOOL            bReturn;
    long            lRet;

    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && (TEXT('\0') != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (lRet = RegConnectRegistry(lpszRemoteComputer,
                                   HKEY_LOCAL_MACHINE,
                                   phklm))
        {

            case ERROR_SUCCESS:
                break;
            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        *phklm = HKEY_LOCAL_MACHINE;
    }

    // Open the key we want
    if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(*phklm,
                                      g_szPassportReg,
                                      0,
                                      KEY_ALL_ACCESS,
                                      phkeyPassport)))
    {
        LPVOID lpMsgBuf;
        FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    lRet,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &lpMsgBuf,
                    0,
                    NULL
                );
                // Display the string.
        {
            TCHAR pszTitle[MAX_RESOURCE];

            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );
        }

        // Free the buffer.
        LocalFree( lpMsgBuf );

//        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }
    bReturn = TRUE;
Cleanup:
    return bReturn;
}


/**************************************************************************

    ReadRegConfigSet

    Read the current passport manager config set from the registry

**************************************************************************/
BOOL ReadRegConfigSet
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszConfigSetName
)
{
    BOOL            bReturn;
    HKEY            hkeyPassport = NULL;           // Regkey where Passport Setting live
    HKEY            hkeyConfigSets = NULL;
    HKEY            hkeyConfig = NULL;
    HKEY            hkeyPartner = NULL;
    HKEY            hklm = NULL;
    DWORD           dwcbTemp;
    DWORD           dwType;
    TCHAR           szText[MAX_RESOURCE];
    TCHAR           szTitle[MAX_RESOURCE];
    long            lRet;

    if (!OpenTopRegKey(hWndDlg, lpszRemoteComputer, &hklm, &hkeyPassport))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    // Open Partner key
    if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(hklm,
                                      g_szPassportPartner,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyPartner)))
    {
        LPVOID lpMsgBuf;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          lRet,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL) != 0)
        {
            TCHAR pszTitle[MAX_RESOURCE];

            // Display the string.
            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }

//        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

	// open Site key
    if(lpszConfigSetName && lpszConfigSetName[0] != TEXT('\0'))
    {
        hkeyConfig = OpenRegConfigSet(hklm, lpszConfigSetName);
        if(hkeyConfig == NULL)
        {
            ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
            bReturn = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        hkeyConfig = hkeyPassport;
    }

    // The Install dir and Version number go into globals, because they are read
    // only values that must come from the target machine's registry.

    // Read the Install Dir.
    dwcbTemp = MAX_PATH;
    dwType = REG_SZ;
    g_szInstallPath[0] = TEXT('\0');     // Default value
    RegQueryValueEx(hkeyPassport,
                    g_szInstallDir,
                    NULL,
                    &dwType,
                    (LPBYTE)g_szInstallPath,
                    &dwcbTemp);

    // Read the version Number
    dwcbTemp = MAX_REGISTRY_STRING;
    dwType = REG_SZ;
    g_szPMVersion[0] = TEXT('\0');          // Default value
    RegQueryValueEx(hkeyPassport,
                    g_szVersion,
                    NULL,
                    &dwType,
                    (LPBYTE)&g_szPMVersion,
                    &dwcbTemp);

    // The Remaining settings are read/write and get put into a PMSETTINGS struct

    // Read the Time Window Number
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwTimeWindow = DEFAULT_TIME_WINDOW;
    RegQueryValueEx(hkeyConfig,
                    g_szTimeWindow,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwTimeWindow,
                    &dwcbTemp);

    // Read the value for Forced Signin
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwForceSignIn = 0;       // Don't force a signin by default
    RegQueryValueEx(hkeyConfig,
                    g_szForceSignIn,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwForceSignIn,
                    &dwcbTemp);

	// Read the value for NSRefresh
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwEnableManualRefresh = 0;       // Don't enable NS Manual Refresh by default
    RegQueryValueEx(hkeyConfig,
                    g_szNSRefresh,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwEnableManualRefresh,
                    &dwcbTemp);

    // Read the default language ID
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwLanguageID = DEFAULT_LANGID;                     // english
    RegQueryValueEx(hkeyConfig,
                    g_szLanguageID,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwLanguageID,
                    &dwcbTemp);

    // Get the co-branding template
    dwcbTemp = lpPMConfig->cbCoBrandTemplate;
    dwType = REG_SZ;
    lpPMConfig->szCoBrandTemplate[0] = TEXT('\0');       // Default value
    RegQueryValueEx(hkeyConfig,
                    g_szCoBrandTemplate,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szCoBrandTemplate,
                    &dwcbTemp);

    // Get the SiteID
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwSiteID = 1;                       // Default Site ID
    RegQueryValueEx(hkeyConfig,
                    g_szSiteID,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwSiteID,
                    &dwcbTemp);

    // Get the return URL template
    dwcbTemp = lpPMConfig->cbReturnURL;
    dwType = REG_SZ;
    lpPMConfig->szReturnURL[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szReturnURL,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szReturnURL,
                    &dwcbTemp);

    // Get the ticket cookie domain
    dwcbTemp = lpPMConfig->cbTicketDomain;
    dwType = REG_SZ;
    lpPMConfig->szTicketDomain[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szTicketDomain,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szTicketDomain,
                    &dwcbTemp);

    // Get the ticket cookie path
    dwcbTemp = lpPMConfig->cbTicketPath;
    dwType = REG_SZ;
    lpPMConfig->szTicketPath[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szTicketPath,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szTicketPath,
                    &dwcbTemp);

    // Get the profile cookie domain
    dwcbTemp = lpPMConfig->cbProfileDomain;
    dwType = REG_SZ;
    lpPMConfig->szProfileDomain[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szProfileDomain,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szProfileDomain,
                    &dwcbTemp);

    // Get the profile cookie path
    dwcbTemp = lpPMConfig->cbProfilePath;
    dwType = REG_SZ;
    lpPMConfig->szProfilePath[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szProfilePath,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szProfilePath,
                    &dwcbTemp);

    // Get the secure cookie domain
    dwcbTemp = lpPMConfig->cbSecureDomain;
    dwType = REG_SZ;
    lpPMConfig->szSecureDomain[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szSecureDomain,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szSecureDomain,
                    &dwcbTemp);

    // Get the secure cookie path
    dwcbTemp = lpPMConfig->cbSecurePath;
    dwType = REG_SZ;
    lpPMConfig->szSecurePath[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szSecurePath,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szSecurePath,
                    &dwcbTemp);

    // Get the Disaster URL
    dwcbTemp = lpPMConfig->cbDisasterURL;
    dwType = REG_SZ;
    lpPMConfig->szDisasterURL[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szDisasterURL,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szDisasterURL,
                    &dwcbTemp);

    // Get Standalone mode setting
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwStandAlone = 0;                       // NOT standalone by default
    RegQueryValueEx(hkeyConfig,
                    g_szStandAlone,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwStandAlone,
                    &dwcbTemp);

	/////////////////////////////////////////////////////////////////////////
	//JVP 3/2/2000	START CHANGES
	/////////////////////////////////////////////////////////////////////////
    // Get Verbose mode setting
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwVerboseMode = 0;                       // NOT verbose by default
    RegQueryValueEx(hkeyConfig,
                    g_szVerboseMode,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwVerboseMode,
                    &dwcbTemp);
	/////////////////////////////////////////////////////////////////////////
	//JVP 3/2/2000	END CHANGES
	/////////////////////////////////////////////////////////////////////////

    // Get the current environment
    dwcbTemp = lpPMConfig->cbEnvName;
    dwType = REG_SZ;
    lpPMConfig->szEnvName[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyConfig,
                    g_szEnvName,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szEnvName,
                    &dwcbTemp);

    // Get the current environment
    dwcbTemp = lpPMConfig->cbRemoteFile;
    dwType = REG_SZ;
    lpPMConfig->szRemoteFile[0] = TEXT('\0');    // Set a default for the current value
    RegQueryValueEx(hkeyPartner,
                    g_szRemoteFile,
                    NULL,
                    &dwType,
                    (LPBYTE)lpPMConfig->szRemoteFile,
                    &dwcbTemp);

    // Get DisableCookies mode setting
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwDisableCookies = 0;                   // Cookies ENABLED by default
    RegQueryValueEx(hkeyConfig,
                    g_szDisableCookies,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwDisableCookies,
                    &dwcbTemp);

#ifdef DO_KEYSTUFF
    // Get the current encryption key
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwCurrentKey = 1;
    RegQueryValueEx(hkeyConfig,
                    g_szCurrentKey,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwCurrentKey,
                    &dwcbTemp);
#endif

    // For these next two, since they're required for named configs, we need
    // to check for too much data and truncate it.

    // Get the Host Name
    dwcbTemp = lpPMConfig->cbHostName;
    dwType = REG_SZ;
    lpPMConfig->szHostName[0] = TEXT('\0');    // Set a default for the current value
    if(ERROR_MORE_DATA == RegQueryValueEx(hkeyConfig,
                                          g_szHostName,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)lpPMConfig->szHostName,
                                          &dwcbTemp))
    {
        LPBYTE pb = (LPBYTE)malloc(dwcbTemp);
        if(pb)
        {
            RegQueryValueEx(hkeyConfig,
                            g_szHostName,
                            NULL,
                            &dwType,
                            pb,
                            &dwcbTemp);

            memcpy(lpPMConfig->szHostName, pb, lpPMConfig->cbHostName);
            free(pb);

            ReportError(hWndDlg, IDS_HOSTNAMETRUNC_WARN);
        }
    }

    // Get the Host IP
    dwcbTemp = lpPMConfig->cbHostIP;
    dwType = REG_SZ;
    lpPMConfig->szHostIP[0] = TEXT('\0');    // Set a default for the current value
    if(ERROR_MORE_DATA == RegQueryValueEx(hkeyConfig,
                                          g_szHostIP,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)lpPMConfig->szHostIP,
                                          &dwcbTemp))
    {
        LPBYTE pb = (LPBYTE)malloc(dwcbTemp);
        if(pb)
        {
            RegQueryValueEx(hkeyConfig,
                            g_szHostIP,
                            NULL,
                            &dwType,
                            pb,
                            &dwcbTemp);

            memcpy(lpPMConfig->szHostIP, pb, lpPMConfig->cbHostIP);
            free(pb);

            ReportError(hWndDlg, IDS_HOSTIPTRUNC_WARN);
        }
    }

    // Query for the secure level setting
    dwcbTemp = sizeof(DWORD);
    dwType = REG_DWORD;
    lpPMConfig->dwSecureLevel = 0;    // If this is an existing site then we level set the
                                      // secure level at 0 so that we don't break anyone,
                                      // even though the default for a new site is level 10.
    RegQueryValueEx(hkeyConfig,
                    g_szSecureLevel,
                    NULL,
                    &dwType,
                    (LPBYTE)&lpPMConfig->dwSecureLevel,
                    &dwcbTemp);

    //  If we got empty strings for HostName or
    //  HostIP, and we have a named config it
    //  means someone's been mucking with
    //  the registry.  Give them a warning and
    //  return FALSE.
    if(lpszConfigSetName && lpszConfigSetName[0] &&
        (lpPMConfig->szHostName[0] == TEXT('\0') ||
        lpPMConfig->szHostIP[0] == TEXT('\0')))
    {
        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    if (hkeyConfig && hkeyConfig != hkeyPassport)
        RegCloseKey(hkeyConfig);
    if (hkeyPassport)
        RegCloseKey(hkeyPassport);
    if (hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);
    if (hklm && hklm != HKEY_LOCAL_MACHINE)
        RegCloseKey(hklm);
    if (hkeyPartner)
        RegCloseKey(hkeyPartner);

    return bReturn;
}

/**************************************************************************

    WriteRegConfigSet

    Write the current passport manager config set from the registry

**************************************************************************/

BOOL WriteRegConfigSet
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszConfigSetName
)
{
    BOOL            bReturn;
    HKEY            hkeyPassport = NULL;           // Regkey where Passport Setting live
    HKEY            hkeyConfigSets = NULL;
    HKEY            hkeyPartner = NULL;
    HKEY            hklm = NULL;
    long            lRet;

    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && (TEXT('\0') != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (lRet = RegConnectRegistry(lpszRemoteComputer,
                                   HKEY_LOCAL_MACHINE,
                                   &hklm))
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }


    // Open the key we want
    if(lpszConfigSetName && lpszConfigSetName[0] != TEXT('\0'))
    {
        hkeyPassport = OpenRegConfigSet(hklm, lpszConfigSetName);
        if(hkeyPassport == NULL)
        {
            ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
            bReturn = FALSE;
            goto Cleanup;
        }
    }
    else
    {
        if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(hklm,
                                          g_szPassportReg,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hkeyPassport)))
        {
            LPVOID lpMsgBuf;
            FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        lRet,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                    );

            {
                TCHAR pszTitle[MAX_RESOURCE];

                // Display the string.
                LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
                MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );
            }

            // Free the buffer.
            LocalFree( lpMsgBuf );

//            ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
            bReturn = FALSE;
            goto Cleanup;
        }
    }

	WriteGlobalConfigSettings(hWndDlg, hklm, lpPMConfig, lpszRemoteComputer);

    // Open Partner key
    if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(hklm,
                                      g_szPassportPartner,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyPartner)))
    {
        LPVOID lpMsgBuf;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          lRet,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL) != 0)
        {
            TCHAR pszTitle[MAX_RESOURCE];

            // Display the string.
            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }

//            ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }


    // Write the Time Window Number
    RegSetValueEx(hkeyPassport,
                    g_szTimeWindow,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwTimeWindow,
                    sizeof(DWORD));

    // Write the value for Forced Signin
    RegSetValueEx(hkeyPassport,
                    g_szForceSignIn,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwForceSignIn,
                    sizeof(DWORD));

    // Write the default language ID
    RegSetValueEx(hkeyPassport,
                    g_szLanguageID,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwLanguageID,
                    sizeof(DWORD));

    // Write the co-branding template
    RegSetValueEx(hkeyPassport,
                    g_szCoBrandTemplate,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szCoBrandTemplate,
                    (lstrlen(lpPMConfig->szCoBrandTemplate) + 1) * sizeof(TCHAR));

    // Write the SiteID
    RegSetValueEx(hkeyPassport,
                    g_szSiteID,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwSiteID,
                    sizeof(DWORD));

    // Write the return URL template
    RegSetValueEx(hkeyPassport,
                    g_szReturnURL,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szReturnURL,
                    (lstrlen(lpPMConfig->szReturnURL) + 1) * sizeof(TCHAR));

    // Write the ticket cookie domain
    RegSetValueEx(hkeyPassport,
                    g_szTicketDomain,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szTicketDomain,
                    (lstrlen(lpPMConfig->szTicketDomain) + 1) * sizeof(TCHAR));

    // Write the ticket cookie path
    RegSetValueEx(hkeyPassport,
                    g_szTicketPath,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szTicketPath,
                    (lstrlen(lpPMConfig->szTicketPath) + 1) * sizeof(TCHAR));

    // Write the profile cookie domain
    RegSetValueEx(hkeyPassport,
                    g_szProfileDomain,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szProfileDomain,
                    (lstrlen(lpPMConfig->szProfileDomain) + 1) * sizeof(TCHAR));

    // Write the profile cookie path
    RegSetValueEx(hkeyPassport,
                    g_szProfilePath,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szProfilePath,
                    (lstrlen(lpPMConfig->szProfilePath) + 1) * sizeof(TCHAR));

    // Write the secure cookie domain
    RegSetValueEx(hkeyPassport,
                    g_szSecureDomain,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szSecureDomain,
                    (lstrlen(lpPMConfig->szSecureDomain) + 1) * sizeof(TCHAR));

    // Write the secure cookie path
    RegSetValueEx(hkeyPassport,
                    g_szSecurePath,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szSecurePath,
                    (lstrlen(lpPMConfig->szSecurePath) + 1) * sizeof(TCHAR));

    // Write the DisasterURL
    RegSetValueEx(hkeyPassport,
                    g_szDisasterURL,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szDisasterURL,
                    (lstrlen(lpPMConfig->szDisasterURL) + 1) * sizeof(TCHAR));

    // Write Standalone mode setting
    RegSetValueEx(hkeyPassport,
                    g_szStandAlone,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwStandAlone,
                    sizeof(DWORD));

	/////////////////////////////////////////////////////////////////////////
	//JVP 3/2/2000	START CHANGES
	/////////////////////////////////////////////////////////////////////////
    // Write Verbose mode setting
    RegSetValueEx(hkeyPassport,
                    g_szVerboseMode,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwVerboseMode,
                    sizeof(DWORD));
	/////////////////////////////////////////////////////////////////////////
	//JVP 3/2/2000	END CHANGES
	/////////////////////////////////////////////////////////////////////////


    // Write the Partner RemoteFile
    RegSetValueEx(hkeyPartner,
                    g_szRemoteFile,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szRemoteFile,
                    (lstrlen(lpPMConfig->szRemoteFile) + 1) * sizeof(TCHAR));

	// Write Environment RemoteFile
    if (lstrcmp(g_szPMVersion, g_szVersion14) >= 0) // Write EnvName for 1.4 and later
	    WriteRegEnv(hWndDlg, lpPMConfig, hklm, lpPMConfig->szEnvName);

    // Write DisableCookies mode setting
    RegSetValueEx(hkeyPassport,
                    g_szDisableCookies,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwDisableCookies,
                    sizeof(DWORD));

    // Only write HostName and HostIP for non-default config sets.
    if(lpszConfigSetName && lpszConfigSetName[0])
    {
        // Write the HostName
        RegSetValueEx(hkeyPassport,
                        g_szHostName,
                        NULL,
                        REG_SZ,
                        (LPBYTE)lpPMConfig->szHostName,
                        (lstrlen(lpPMConfig->szHostName) + 1) * sizeof(TCHAR));

        // Write the HostIP
        RegSetValueEx(hkeyPassport,
                        g_szHostIP,
                        NULL,
                        REG_SZ,
                        (LPBYTE)lpPMConfig->szHostIP,
                        (lstrlen(lpPMConfig->szHostIP) + 1) * sizeof(TCHAR));
    }

    // Write the secure level (note this reg value is not exposed through the UI
    // users need to go directly to the registry to edit this value)
    RegSetValueEx(hkeyPassport,
                    g_szSecureLevel,
                    NULL,
                    REG_DWORD,
                    (LPBYTE)&lpPMConfig->dwSecureLevel,
                    sizeof(DWORD));

    bReturn = TRUE;

Cleanup:

    if(hklm && hklm != HKEY_LOCAL_MACHINE)
        RegCloseKey(hklm);
    if(hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);
    if(hkeyPassport)
        RegCloseKey(hkeyPassport);
    if(hkeyPartner)
        RegCloseKey(hkeyPartner);

    return bReturn;
}


/**************************************************************************

    RemoveRegConfigSet

    Verify that the passed in config set is consistent with the current
    values in the registry.

**************************************************************************/
BOOL RemoveRegConfigSet
(
    HWND    hWndDlg,
    LPTSTR  lpszRemoteComputer,
    LPTSTR  lpszConfigSetName
)
{
    BOOL    bReturn;
    HKEY    hklm = NULL;
    HKEY    hkeyPassportConfigSets = NULL;
    long    lRet;

    //  Can't delete the default configuration set.
    if(lpszConfigSetName == NULL || lpszConfigSetName[0] == TEXT('\0'))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    // Open the Passport Configuration Sets Regkey ( either locally or remotly
    if (lpszRemoteComputer && (TEXT('\0') != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer,
                                   HKEY_LOCAL_MACHINE,
                                   &hklm))
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }

    // Open the key we want
    if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(hklm,
                                      REG_PASSPORT_SITES_VALUE,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyPassportConfigSets)))
    {
        LPVOID lpMsgBuf;
        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          lRet,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL) != 0)
        {
            TCHAR   pszTitle[MAX_RESOURCE];

            // Display the string.
            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }

//        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    // Delete the config set key
    if (ERROR_SUCCESS != SHDeleteKey(hkeyPassportConfigSets, lpszConfigSetName))
    {
        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = TRUE;

Cleanup:

    if(hklm && hklm != HKEY_LOCAL_MACHINE)
        RegCloseKey(hklm);
    if(hkeyPassportConfigSets)
        RegCloseKey(hkeyPassportConfigSets);

    return bReturn;
}


/**************************************************************************

    VerifyRegConfigSet

    Verify that the passed in config set is consistent with the current
    values in the registry.

**************************************************************************/
BOOL VerifyRegConfigSet
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszConfigSetName
)
{
    BOOL        fResult = FALSE;
    PMSETTINGS  *pPMCurrent = NULL;

    pPMCurrent = (PMSETTINGS*)LocalAlloc(LMEM_FIXED, sizeof(PMSETTINGS));
    if (NULL == pPMCurrent)
    {
        goto Cleanup;
    }

    InitializePMConfigStruct(pPMCurrent);
    ReadRegConfigSet(hWndDlg, pPMCurrent, lpszRemoteComputer, lpszConfigSetName);

    fResult = (0 == memcmp(pPMCurrent, lpPMConfig, sizeof(PMSETTINGS)));
Cleanup:
    if (pPMCurrent)
    {
        LocalFree(pPMCurrent);
    }

    return fResult;
}

/**************************************************************************

    ReadRegConfigSetNames

    Get back a list of config set names on a local or remote machine.
    Caller is responsible for calling free() on the returned pointer.

    When this function returns TRUE, lppszConfigSetNames will either
    contain NULL or a string containing the NULL delimited config set
    names on the given computer.

    When this function returns FALSE, *lppszConfigSetNames will not
    be modified.

**************************************************************************/
BOOL ReadRegConfigSetNames
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteComputer,
    LPTSTR*         lppszConfigSetNames
)
{
    BOOL        bReturn;
    HKEY        hklm = NULL;
    HKEY        hkeyConfigSets = NULL;
    DWORD       dwIndex;
    DWORD       dwNumSubKeys;
    DWORD       dwMaxKeyNameLen;
    TCHAR       achKeyName[MAX_PATH];
    ULONGLONG   ullAllocSize;
    LPTSTR      lpszConfigSetNames;
    LPTSTR      lpszCur;

    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && (TEXT('\0') != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer,
                                   HKEY_LOCAL_MACHINE,
                                   &hklm))
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(hklm,
                                      REG_PASSPORT_SITES_VALUE,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyConfigSets))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    if (ERROR_SUCCESS != RegQueryInfoKey(hkeyConfigSets,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwNumSubKeys,
                                         &dwMaxKeyNameLen,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL))
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Nothing to do!
    //

    if(dwNumSubKeys == 0)
    {
        bReturn = TRUE;
        *lppszConfigSetNames = NULL;
        goto Cleanup;
    }

    //  Too big?  BUGBUG - We should make sure we check for this
    //  When writing out config sets.
    ullAllocSize = UInt32x32To64(dwNumSubKeys, dwMaxKeyNameLen + 1);
    ullAllocSize = (ullAllocSize+1)*sizeof(TCHAR);
    if(ullAllocSize & 0xFFFFFFFF00000000)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //  This should allocate more space than we need.
    lpszConfigSetNames = (LPTSTR)malloc(((dwNumSubKeys * (dwMaxKeyNameLen + 1)) + 1) * sizeof(TCHAR));
    if(lpszConfigSetNames == NULL)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //  Read all names into the buffer.  Names are NULL delimited and
    //  two NULLs end the entire thing.
    dwIndex = 0;
    lpszCur = lpszConfigSetNames;
    while (ERROR_SUCCESS == RegEnumKey(hkeyConfigSets, dwIndex++, achKeyName, DIMENSION(achKeyName)))
    {
        _tcscpy(lpszCur, achKeyName);
        lpszCur = _tcschr(lpszCur, TEXT('\0')) + 1;
    }

    *lpszCur = TEXT('\0');

    *lppszConfigSetNames = lpszConfigSetNames;
    bReturn = TRUE;

Cleanup:

    if(hklm)
        RegCloseKey(hklm);
    if(hkeyConfigSets)
        RegCloseKey(hkeyConfigSets);

    return bReturn;
}

/**************************************************************************

    WriteRegEnv

    Write the current passport manager env set from the registry

**************************************************************************/

BOOL WriteRegEnv
(
    HWND            hWndDlg,
    LPPMSETTINGS    lpPMConfig,
    HKEY            hklm,
    LPTSTR          lpszEnvName
)
{
    BOOL            bReturn;
    HKEY            hkeyEnv = NULL;
    long            lRet;

     // Open Env key
    TCHAR szTemp[MAX_RESOURCE];
    wsprintf(szTemp, TEXT("%s\\%s"), g_szPassportEnvironments, lpszEnvName);

    if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(hklm,
                                      szTemp,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyEnv)))
    {
        LPVOID lpMsgBuf;
        FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        lRet,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                    );

        {
            TCHAR   pszTitle[MAX_RESOURCE];

            // Display the string.
            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );
        }

        // Free the buffer.
        LocalFree( lpMsgBuf );
//        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    // Write the Env RemoteFile
    RegSetValueEx(hkeyEnv,
                    g_szRemoteFile,
                    NULL,
                    REG_SZ,
                    (LPBYTE)lpPMConfig->szRemoteFile,
                    (lstrlen(lpPMConfig->szRemoteFile) + 1) * sizeof(TCHAR));


    bReturn = TRUE;

Cleanup:
	REG_CLOSE_KEY_NULL(hkeyEnv);

    return bReturn;
}

/**************************************************************************

    ReadRegEnv

    Read the current passport manager env set from the registry

**************************************************************************/

BOOL ReadRegRemoteFile
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteFile,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszEnvName
)
{
    BOOL            bReturn;
    HKEY            hklm = NULL;
    HKEY            hkeyEnv = NULL;
    long            lRet;

    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && (TEXT('\0') != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer,
                                   HKEY_LOCAL_MACHINE,
                                   &hklm))
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }

    // Open Env key
    TCHAR szTemp[MAX_RESOURCE];
    wsprintf(szTemp, TEXT("%s\\%s"), g_szPassportEnvironments, lpszEnvName);
    if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(hklm,
                                      szTemp,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyEnv)))
    {
        LPVOID lpMsgBuf;
        FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        lRet,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                    );

        {
            TCHAR   pszTitle[MAX_RESOURCE];

            // Display the string.
            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );
        }

        // Free the buffer.
        LocalFree( lpMsgBuf );
//        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    // Get the current environment
    DWORD           dwcbTemp;
    DWORD           dwType;
 	TCHAR			szName[INTERNET_MAX_URL_LENGTH];
    dwcbTemp = sizeof(szName);
    dwType = REG_SZ;
    szName[0] = TEXT('\0');    // Set a default for the current value
    if (ERROR_SUCCESS  == RegQueryValueEx(hkeyEnv,
                    g_szRemoteFile,
                    NULL,
                    &dwType,
                    (LPBYTE)szName,
                    &dwcbTemp))
	{
		lstrcpy(lpszRemoteFile, szName);
		bReturn = TRUE;
	}
	else
		bReturn = FALSE;

Cleanup:
	REG_CLOSE_KEY_NULL(hklm);
	REG_CLOSE_KEY_NULL(hkeyEnv);

    return bReturn;
}

/**************************************************************************

    ReadRegEnv

    Read the current passport manager env set from the registry

**************************************************************************/

BOOL ReadRegLocalFile
(
    HWND            hWndDlg,
    LPTSTR          lpszRemoteComputer,
    LPTSTR          lpszLocalFile
)
{
    BOOL            bReturn;
    HKEY            hklm = NULL;
    HKEY            hkeyPartner = NULL;
    long            lRet;

    // Open the Passport Regkey ( either locally or remotly
    if (lpszRemoteComputer && (TEXT('\0') != lpszRemoteComputer[0]))
    {
        //
        //  Attempt to connect to the HKEY_LOCAL_MACHINE of the remote computer.
        //  If this fails, assume that the computer doesn't exist or doesn't have
        //  the registry server running.
        //
        switch (RegConnectRegistry(lpszRemoteComputer,
                                   HKEY_LOCAL_MACHINE,
                                   &hklm))
        {

            case ERROR_SUCCESS:
                break;

            case ERROR_ACCESS_DENIED:
                ReportError(hWndDlg, IDS_CONNECTACCESSDENIED);
                bReturn = FALSE;
                goto Cleanup;

            default:
                ReportError(hWndDlg, IDS_CONNECTBADNAME);
                bReturn = FALSE;
                goto Cleanup;
        }
    }
    else
    {
        hklm = HKEY_LOCAL_MACHINE;
    }

     // Open Partner key
    if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(hklm,
                                      g_szPassportPartner,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkeyPartner)))
    {
        LPVOID lpMsgBuf;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          lRet,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL) != 0)
        {
            TCHAR   pszTitle[MAX_RESOURCE];

            // Display the string.
            LoadString(g_hInst, IDS_ERROR, pszTitle, DIMENSION(pszTitle));
            MessageBox( NULL, (LPCTSTR) lpMsgBuf, pszTitle, MB_OK | MB_ICONINFORMATION );

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }

//        ReportError(hWndDlg, IDS_CONFIGREAD_ERROR);
        bReturn = FALSE;
        goto Cleanup;
    }

    // Get the current environment
    DWORD           dwcbTemp;
    DWORD           dwType;
 	TCHAR			szName[INTERNET_MAX_URL_LENGTH];
    dwcbTemp = sizeof(szName);
    dwType = REG_SZ;
    lpszLocalFile[0] = TEXT('\0');    // Set a default for the current value
    if (ERROR_SUCCESS  == RegQueryValueEx(hkeyPartner,
                    g_szLocalFile,
                    NULL,
                    &dwType,
                    (LPBYTE)szName,
                    &dwcbTemp))
	{
		lstrcpy(lpszLocalFile, szName);
		bReturn = TRUE;
	}
	else
		bReturn = FALSE;

Cleanup:
	REG_CLOSE_KEY_NULL(hklm);
	REG_CLOSE_KEY_NULL(hkeyPartner);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\auth.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        auth.cxx
//
// Contents:    Digest Access creation & validation
//              Main entry points into this dll:
//                DigestIsValid
//                NonceValidate
//                NonceInitialize
//
// History:     KDamour 16Mar00   Created
//
//------------------------------------------------------------------------

#include "global.h"
#include <lmcons.h>     // For Max Passwd Length PWLEN
#include <stdio.h>



//+--------------------------------------------------------------------
//
//  Function:   DigestCalculation
//
//  Synopsis:   Perform Digest Access Calculation
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  This routine can be used for both calculating and verifying
//    the Digest Access nonce value.  The Switching parameter is
//    pDigest->type. Calling routine must provide the space for any
//    returned hashed values (like pReqDigest).
//
//   For clients, the cleartext password must be avilable to generate the
//   session key.
//
//   After the initial ISC/ASC completes, a copy of the sessionkey is kept in
//  in the context and copied over to the Digest structure.  The username, realm
//  and password are not utilized from the UserCreds since we already have a
//  sessionkey.
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestCalculation(
                 IN PDIGEST_PARAMETER pDigest,
                 IN PUSER_CREDENTIALS pUserCreds
                 )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DebugLog((DEB_TRACE_FUNC, "DigestCalculation: Entering\n"));

    Status = DigestIsValid(pDigest);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    switch (pDigest->typeDigest)
    {
    case DIGEST_CLIENT:      // Called by clients to generate Response
    case SASL_CLIENT:      // Called by clients to generate Response
        {
            Status = DigestCalcChalRsp(pDigest, pUserCreds, FALSE);
            break;
        }
    case DIGEST_SERVER:
    case SASL_SERVER:
        {
            Status = DigestCalcChalRsp(pDigest, pUserCreds, TRUE);
            break;
        }
    default:
        {     // No Digest calculations for that yet
            Status = SEC_E_UNSUPPORTED_FUNCTION;
            DebugLog((DEB_ERROR, "NTDigest: Unsupported typeDigest = %d\n", pDigest->typeDigest));
            break;
        }
    }

    DebugLog((DEB_TRACE_FUNC, "DigestCalculation: Leaving     Status 0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestIsValid
//
//  Synopsis:   Simple checks for enough data for Digest calculation
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestIsValid(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;    
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestIsValid: Entering\n"));

    if (!pDigest)
    {     // Fail on no Digest Parameters passed in
        
        DebugLog((DEB_ERROR, "DigestIsValid: no digest pointer arg\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Check for proper struct format for strings
    for (i=0; i< MD5_AUTH_LAST;i++)
    {
        if (!NT_SUCCESS(StringVerify(&(pDigest->refstrParam[i]))))
        {
            DebugLog((DEB_ERROR, "DigestIsValid: Digest String struct bad format\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }
    }

    if (!NT_SUCCESS(StringVerify(&(pDigest->strSessionKey))))
    {
        DebugLog((DEB_ERROR, "DigestIsValid: Digest String struct bad format in SessionKey\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Do some required checks for field-value data
    // Required Username-value, Realm-value, nonce, Method
    //          URI
    if ((!pDigest->refstrParam[MD5_AUTH_NONCE].Length) ||
        (!pDigest->refstrParam[MD5_AUTH_METHOD].Length) ||
        (!pDigest->refstrParam[MD5_AUTH_URI].Length)
       )
    {
        // Failed on a require field-value
        DebugLog((DEB_ERROR, "DigestIsValid: required digest field missing\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestIsValid: Leaving     Status 0x%x\n", Status));
    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestFree
//
//  Synopsis:   Clear out the digest & free memory from Digest struct
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  This should be called when done with a DIGEST_PARAMTER object
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestFree(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "Entering DigestFree\n"));

    if (!pDigest)
    {
        return STATUS_INVALID_PARAMETER;
    }

    StringFree(&pDigest->strSessionKey);

    StringFree(&pDigest->strResponse);
    StringFree(&pDigest->strUsernameEncoded);
    StringFree(&pDigest->strRealmEncoded);

    UnicodeStringFree(&pDigest->ustrRealm);

    UnicodeStringFree(&pDigest->ustrUsername);

    UnicodeStringFree(&pDigest->ustrCrackedAccountName);
    UnicodeStringFree(&pDigest->ustrCrackedDomain);

    UnicodeStringFree(&pDigest->ustrWorkstation);
    
    UnicodeStringFree(&pDigest->ustrTrustedForest);

    if (pDigest->pTrustSid)
    {
#ifndef SECURITY_KERNEL
        MIDL_user_free(pDigest->pTrustSid);
#else
        ASSERT(FALSE);   //  Kernel mode will never have Domain/forest trust informtion set
#endif
        pDigest->pTrustSid = NULL;

    }

    // Release any directive storage
    // This was used to remove backslash encoding from directives
    for (i = 0; i < MD5_AUTH_LAST; i++)
    {
        StringFree(&(pDigest->strDirective[i]));
    }

    DebugLog((DEB_TRACE_FUNC, "Leaving DigestFree\n"));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestInit
//
//  Synopsis:   Initialize a DIGEST_PARAMETER structure
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  This should be called when creating a DIGEST_PARAMTER object
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestInit(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pDigest)
    {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(pDigest, sizeof(DIGEST_PARAMETER));
    
         // Now allocate the fixed length output buffers
    Status = StringAllocate(&(pDigest->strResponse), MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "NTDigest:DigestCalculation No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        return(Status);
    }

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestCalcChalRsp
//
//  Synopsis:   Perform Digest Access Calculation for ChallengeResponse
//
//  Effects: 
//
//  Arguments:  pDigest - pointer to digest access data fields
//              bIsChallenge - if TRUE then check Response provided (for HTTP Response)
//                           - if FALSE then calculate Response (for HTTP Request)

//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  Called from DigestCalculation
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestCalcChalRsp(IN PDIGEST_PARAMETER pDigest,
                  IN PUSER_CREDENTIALS pUserCreds,
                  BOOL IsChallenge)
{
    NTSTATUS Status = STATUS_SUCCESS;
    STRING strHA2 = {0};
    STRING strReqDigest = {0};    // Final request digest access value
    STRING strcQOP = {0};         // String pointing to a constant CZ - no need to free up

    DebugLog((DEB_TRACE_FUNC, "DigestCalcChalRsp: Entering\n"));

    // Make sure that there is a Request-Digest to Compare to (IsChallenge TRUE) or
    // Set (IsChallenge FALSE)
    if (IsChallenge && (!(pDigest->refstrParam[MD5_AUTH_RESPONSE].Length)))
    {
        // Failed on a require field-value
        DebugLog((DEB_ERROR, "DigestCalcChalRsp: No ChallengeResponse\n"));
        Status = STATUS_INVALID_PARAMETER;
        return(Status);
    }

    // Initialize local variables
    Status = StringAllocate(&strHA2, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcChalRsp: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }
    Status = StringAllocate(&strReqDigest, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcChalRsp: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }


    // Establish which QOP utilized
    if (pDigest->typeQOP == AUTH_CONF)
    {
        RtlInitString(&strcQOP, AUTHCONFSTR);
    }
    else if (pDigest->typeQOP == AUTH_INT)
    {
        RtlInitString(&strcQOP, AUTHINTSTR);
    }
    else if (pDigest->typeQOP == AUTH)
    {
        RtlInitString(&strcQOP, AUTHSTR);
    }

    // Check if already calculated H(A1) the session key
    // Well for Algorithm=MD5 it is just H(username:realm:passwd)
    if (!(pDigest->strSessionKey.Length))
    {
        // No Session Key calculated yet - create one & store it
#ifndef SECURITY_KERNEL
        DebugLog((DEB_TRACE, "DigestCalcChalRsp: No session key calculated, generate one\n"));
        Status = DigestCalcHA1(pDigest, pUserCreds);
        if (!NT_SUCCESS(Status))
        {
            goto CleanUp;
        }
#else   // SECURITY_KERNEL
        UNREFERENCED_PARAMETER(pUserCreds);
        DebugLog((DEB_ERROR, "DigestCalcChalRsp: No session key available in context\n"));
        Status = STATUS_NO_USER_SESSION_KEY;
        goto CleanUp;
#endif  // SECURITY_KERNEL
    }
    // We now have calculated H(A1)

    // Calculate H(A2)
    // For QOP unspecified or "auth"  H(A2) = H( Method: URI)
    // For QOP Auth-int or Auth-conf  H(A2) = H( Method: URI: H(entity-body))
    if ((pDigest->typeQOP == AUTH) || (pDigest->typeQOP == NO_QOP_SPECIFIED))
    {
        // Unspecified or Auth
        DebugLog((DEB_TRACE, "DigestCalcChalRsp: H(A2) using AUTH/Unspecified\n"));
        Status = DigestHash7(&(pDigest->refstrParam[MD5_AUTH_METHOD]),
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             NULL, NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp H(A2) failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // Auth-int or Auth-conf
        DebugLog((DEB_TRACE, "DigestCalcChalRsp: H(A2) using AUTH-INT/CONF\n"));
        if (pDigest->refstrParam[MD5_AUTH_HENTITY].Length == 0)
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestCalChalRsp HEntity Missing\n"));
            goto CleanUp;
        }
        Status = DigestHash7(&(pDigest->refstrParam[MD5_AUTH_METHOD]),
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             &(pDigest->refstrParam[MD5_AUTH_HENTITY]),
                             NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp H(A2) auth-int failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    // We now have calculated H(A2)


    // Calculate Request-Digest
    // For QOP of Auth, Auth-int, Auth-conf    Req-Digest = H( H(A1): nonce: nc: cnonce: qop: H(A2))
    // For QOP unspecified (old format)   Req-Digest = H( H(A1): nonce: H(A2))
    if (pDigest->typeQOP != NO_QOP_SPECIFIED)
    {
        // Auth, Auth-int, Auth-conf
        if (pDigest->refstrParam[MD5_AUTH_NC].Length == 0)
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestCalcChalRsp NC Missing\n"));
            goto CleanUp;
        }
        Status = DigestHash7(&(pDigest->strSessionKey),
                             &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                             &(pDigest->refstrParam[MD5_AUTH_NC]),
                             &(pDigest->refstrParam[MD5_AUTH_CNONCE]),
                             &strcQOP,
                             &strHA2, NULL,
                             TRUE, &strReqDigest);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp Req-Digest failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // Unspecified backwards compat for RFC 2069
        Status = DigestHash7(&(pDigest->strSessionKey),
                             &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                             &strHA2,
                             NULL, NULL, NULL, NULL,
                             TRUE, &strReqDigest);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp Req-Digest old format failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }

    if (IsChallenge)
    {
        // We now have the Request-Digest so just compare to see if they match!
        if (!strncmp(pDigest->refstrParam[MD5_AUTH_RESPONSE].Buffer, strReqDigest.Buffer, 2*MD5_HASH_BYTESIZE))
        {
            DebugLog((DEB_TRACE, "DigestCalcChalRsp Request-Digest Matches!\n"));
            Status = STATUS_SUCCESS;
        }
        else
        {
            DebugLog((DEB_TRACE, "DigestCalcChalRsp Request-Digest FAILED.\n"));
            Status = STATUS_WRONG_PASSWORD;
        }

    }
    else
    {

        // We are to calculate the response-value so just set it  (Hash Size + NULL)
        if (pDigest->strResponse.MaximumLength >= (MD5_HASH_HEX_SIZE + 1))
        {
            memcpy(pDigest->strResponse.Buffer, strReqDigest.Buffer, (MD5_HASH_HEX_SIZE + 1));
            pDigest->strResponse.Length = MD5_HASH_HEX_SIZE;  // No Count NULL
            Status = STATUS_SUCCESS;
        }
        else
        {
            DebugLog((DEB_ERROR, "DigestCalcChalRsp Request-Digest Size too small.\n"));
            Status = STATUS_BUFFER_TOO_SMALL;
        }
    }

CleanUp:
    StringFree(&strHA2);
    StringFree(&strReqDigest);
    DebugLog((DEB_TRACE_FUNC, "DigestCalcChalRsp: Leaving   Status 0x%x\n", Status));

    return(Status);
}

#ifndef SECURITY_KERNEL



//+--------------------------------------------------------------------
//
//  Function:   DigestDecodeDirectiveStrings
//
//  Synopsis:   Processed parsed digest auth message and fill in string values
//
//  Effects:
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestDecodeDirectiveStrings(
          IN PDIGEST_PARAMETER pDigest
          )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeDirectiveStrings Entering\n"));

    if (!pDigest)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Free up any allocs on a retry for directive decoding
    UnicodeStringFree(&pDigest->ustrUsername);
    UnicodeStringFree(&pDigest->ustrRealm);

    // Decode the username and realm directives
    if (pDigest->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "DigestDecodeDirectiveStrings:      UTF-8 Character set decoding\n"));

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_USERNAME]),
                                     CP_UTF8,
                                     &pDigest->ustrUsername);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString    error 0x%x\n", Status));
            goto CleanUp;
        }


        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_REALM]),
                                     CP_UTF8,
                                     &pDigest->ustrRealm);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString    error 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else if (pDigest->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "DigestDecodeDirectiveStrings:      ISO-8859-1 Character set decoding\n"));

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_USERNAME]),
                                     CP_8859_1,
                                     &pDigest->ustrUsername);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString  Username  error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = DecodeUnicodeString(&(pDigest->refstrParam[MD5_AUTH_REALM]),
                                     CP_8859_1,
                                     &pDigest->ustrRealm);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: DecodeUnicodeString  Realm  error 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_UNMAPPABLE_CHARACTER;
        DebugLog((DEB_ERROR, "DigestDecodeDirectiveStrings: Unknown CharacterSet encoding for Digest parameters\n"));
        goto CleanUp;
    }


    DebugLog((DEB_TRACE, "DigestDecodeDirectiveStrings: Processing username (%wZ)  realm (%wZ)\n",
               &pDigest->ustrUsername,
               &pDigest->ustrRealm));

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeStrings Leaving\n"));

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   DigestCalcHA1
//
//  Synopsis:   Determine H(A1) for Digest Access
//
//  Effects:    Will calculate the SessionKey and store it in pDigest
//
//  Arguments:  pDigest - pointer to digest access data fields

//
//  Returns:  STATUS_SUCCESS for normal completion
//
//  Notes:  Called from DigestCalChalRsp
//      Sessionkey is H(A1)
//   Username and realm will be taken from the UserCreds
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestCalcHA1(IN PDIGEST_PARAMETER pDigest,
              IN PUSER_CREDENTIALS pUserCreds)
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING ustrTempPasswd = {0};

    STRING strHPwKey = {0};
    STRING strBinaryHPwKey = {0};
    STRING strHA0Base = {0};
    STRING strHA0 = {0};
    STRING strPasswd = {0};
    STRING strUsername = {0};
    STRING strRealm = {0};
    PSTRING pstrAuthzID = NULL;
    BOOL fDefChars = FALSE;
    USHORT usHashOffset = 0;
    BOOL fSASLMode = FALSE;
    BOOL fValidHash = FALSE;
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestCalcHA1: Entering\n"));

    ASSERT(pDigest);
    ASSERT(pUserCreds);

    if (!pUserCreds)
    {
        // No username & domain passed in
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestCalcHA1: No username info passed in\n"));
        goto CleanUp;
    }

    if ((pDigest->typeDigest == SASL_SERVER) || (pDigest->typeDigest == SASL_CLIENT))
    {
        fSASLMode = TRUE;
    }

    // Initialize local variables
    Status = StringAllocate(&strBinaryHPwKey, MD5_HASH_BYTESIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }
    Status = StringAllocate(&strHA0Base, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }
    Status = StringAllocate(&strHA0, MD5_HASH_HEX_SIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }

    // Check outputs
    if (pDigest->strSessionKey.MaximumLength <= MD5_HASH_HEX_SIZE)
    {
        StringFree(&(pDigest->strSessionKey));
        Status = StringAllocate(&(pDigest->strSessionKey), MD5_HASH_HEX_SIZE);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }

    if ((pUserCreds->fIsValidDigestHash == TRUE) && (pUserCreds->wHashSelected > 0))
    {
        // selected pre-calculated hash - retrieve from userCreds
        // read in precalc version number
        if (pUserCreds->strDigestHash.Length < MD5_HASH_BYTESIZE)
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: No Header on Precalc hash\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto CleanUp;
        }

        // check if valid hash number
        usHashOffset = pUserCreds->wHashSelected * MD5_HASH_BYTESIZE;
        if (pUserCreds->strDigestHash.Length < (usHashOffset + MD5_HASH_BYTESIZE))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: Pre-calc hash not found\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto CleanUp;
        }

        // extract pre-calc hash - this is the binary version of the hash
        memcpy(strBinaryHPwKey.Buffer,
               (pUserCreds->strDigestHash.Buffer + usHashOffset),
               MD5_HASH_BYTESIZE);
        strBinaryHPwKey.Length = MD5_HASH_BYTESIZE;

        // all zero for hash indicates invalid hash calculated
        for (i=0; i < (int)strBinaryHPwKey.Length; i++)
        {
            if (strBinaryHPwKey.Buffer[i])
            {
                fValidHash = TRUE;
                break;
            }
        }

        if (fValidHash == FALSE)
        {
            // This is not a defined hash
            DebugLog((DEB_ERROR, "DigestCalcHA1: Invalid hash selected - not defined\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto CleanUp;
        }

        if (fSASLMode == TRUE)
        {
            // SASL mode keeps the Password hash in binary form
            Status = StringDuplicate(&strHPwKey, &strBinaryHPwKey);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
        else
        {
            Status = StringAllocate(&strHPwKey, MD5_HASH_HEX_SIZE);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: No Memory\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            // HTTP mode needs to have HEX() version of password hash - RFC text is correct
            BinToHex((LPBYTE)strBinaryHPwKey.Buffer, MD5_HASH_BYTESIZE, strHPwKey.Buffer);
            strHPwKey.Length = MD5_HASH_HEX_SIZE;             // Do not count the NULL at the end
        }
#if DBG2
        if (fSASLMode == TRUE)
        {
            STRING strTempPwKey = {0};
    
            MyPrintBytes(strHPwKey.Buffer, strHPwKey.Length, &strTempPwKey);
            DebugLog((DEB_TRACE, "DigestCalcHA1: SASL Pre-Calc H(%wZ:%wZ:************) is %Z\n",
                      &pUserCreds->ustrUsername, &pUserCreds->ustrRealm, &strTempPwKey));
    
            StringFree(&strTempPwKey);
        }
        else
        {
            DebugLog((DEB_TRACE, "DigestCalcHA1: HTTP Pre-Calc H(%wZ:%wZ:************) is %Z\n",
                      &pUserCreds->ustrUsername, &pUserCreds->ustrRealm, &strHPwKey));
        }
#endif
    }
    else if (pUserCreds->fIsValidPasswd == TRUE)
    {
        // copy over the passwd and decrypt if necessary
        Status = UnicodeStringDuplicatePassword(&ustrTempPasswd, &(pUserCreds->ustrPasswd));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: Error in dup password, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        if ((pUserCreds->fIsEncryptedPasswd == TRUE) && (ustrTempPasswd.MaximumLength != 0))
        {
            g_LsaFunctions->LsaUnprotectMemory(ustrTempPasswd.Buffer, (ULONG)(ustrTempPasswd.MaximumLength));
        }


        // Need to encode the password for hash calculations
        // We have the cleartext password in ustrTempPasswd,
        //       username in pContext->ustrAccountname,
        //       realm in pContext->ustrDomain
        //   Could do some code size optimization here in the future to shorten this up
        if (pDigest->typeCharset == UTF_8)
        {
            // First check if OK to encode in ISO 8859-1, if not then use UTF-8
            // All characters must be within ISO 8859-1 Character set else fail
            fDefChars = FALSE;
            Status = EncodeUnicodeString(&pUserCreds->ustrUsername, CP_8859_1, &strUsername, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_TRACE, "DigestCalcHA1: Can not encode Username in 8859-1, use UTF-8\n"));
                StringFree(&strUsername);
                Status = EncodeUnicodeString(&pUserCreds->ustrUsername, CP_UTF8, &strUsername, NULL);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                    Status = SEC_E_INSUFFICIENT_MEMORY;
                    goto CleanUp;
                }
            }

            fDefChars = FALSE;
            Status = EncodeUnicodeString(&pUserCreds->ustrRealm, CP_8859_1, &strRealm, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_TRACE, "DigestCalcHA1: Can not encode realm in 8859-1, use UTF-8\n"));
                StringFree(&strRealm);
                Status = EncodeUnicodeString(&pUserCreds->ustrRealm, CP_UTF8, &strRealm, NULL);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                    Status = SEC_E_INSUFFICIENT_MEMORY;
                    goto CleanUp;
                }
            }

            fDefChars = FALSE;
            Status = EncodeUnicodeString(&ustrTempPasswd, CP_8859_1, &strPasswd, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_TRACE, "DigestCalcHA1: Can not encode password in 8859-1, use UTF-8\n"));
                if (strPasswd.Buffer && strPasswd.MaximumLength)
                {
                    SecureZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
                }
                StringFree(&strPasswd);
                Status = EncodeUnicodeString(&ustrTempPasswd, CP_UTF8, &strPasswd, NULL);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd\n"));
                    Status = SEC_E_INSUFFICIENT_MEMORY;
                    goto CleanUp;
                }
            }
        }
        else
        {
            // All characters must be within ISO 8859-1 Character set else fail
            Status = EncodeUnicodeString(&pUserCreds->ustrUsername, CP_8859_1, &strUsername, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username in ISO 8859-1\n"));
                Status = STATUS_UNMAPPABLE_CHARACTER;
                goto CleanUp;
            }

            Status = EncodeUnicodeString(&pUserCreds->ustrRealm, CP_8859_1, &strRealm, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm in ISO 8859-1\n"));
                Status = STATUS_UNMAPPABLE_CHARACTER;
                goto CleanUp;
            }

            Status = EncodeUnicodeString(&ustrTempPasswd, CP_8859_1, &strPasswd, &fDefChars);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
            if (fDefChars == TRUE)
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding passwd in ISO 8859-1\n"));
                Status = STATUS_UNMAPPABLE_CHARACTER;
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "DigestCalcHA1: Username, Realm, Password encoded in ISO 8859-1\n"));
        }

        if (!strUsername.Length)
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1: Must have non-zero length username\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto CleanUp;
        }

        // If specified a no realm (NULL buffer, zero length) then used the REALM provided in the Challenge
        // if Realm specified as NULL string (valid buffer, zero length), then use a "" NULL string realm
        if (!pUserCreds->ustrRealm.Buffer)
        {
            ASSERT(!pUserCreds->ustrRealm.Length);   // never have NULL buffer and a length
            StringFree(&strRealm);
            Status = StringDuplicate(&strRealm, &(pDigest->refstrParam[MD5_AUTH_REALM]));
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Can not duplicate Challenge realm\n"));
                goto CleanUp;
            }
            DebugLog((DEB_ERROR, "DigestCalcHA1: Realm defaulted to Challenge realm value\n"));
        }

        // Calculate H(A1) based on Algorithm type
        // Auth is not specified or "MD5"
        // Use H(A1Base) = H(username-value:realm-value:passwd)
        if (fSASLMode == TRUE)
        {
            Status = DigestHash7(&strUsername,
                                 &strRealm,
                                 &strPasswd,
                                 NULL, NULL, NULL, NULL,
                                 FALSE, &strHPwKey);
        }
        else
        {

            Status = DigestHash7(&strUsername,
                                 &strRealm,
                                 &strPasswd,
                                 NULL, NULL, NULL, NULL,
                                 TRUE, &strHPwKey);
        }
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1:DigestCalcHA1 H(PwKey) failed : 0x%x\n", Status));
            goto CleanUp;
        }

#if DBG2
        if (fSASLMode == TRUE)
        {
            STRING strTempPwKey = {0};
    
            MyPrintBytes(strHPwKey.Buffer, strHPwKey.Length, &strTempPwKey);
            DebugLog((DEB_TRACE, "DigestCalcHA1: SASL Password Calc H(%Z:%Z:************) is %Z ******\n",
                      &strUsername, &strRealm, &strTempPwKey));
    
            StringFree(&strTempPwKey);
        }
        else
        {
            DebugLog((DEB_TRACE, "DigestCalcHA1: HTTP Password Calc H(%Z:%Z:************) is %Z ******\n",
                      &strUsername, &strRealm, &strHPwKey));
        }
#endif
    }
    else
    {
        Status = SEC_E_NO_CREDENTIALS;
        DebugLog((DEB_ERROR, "DigestCalcHA1: No Pre-calc hash or password\n"));
        goto CleanUp;
    }


    // Check if using SASL then need to add in the AuthzID
    if (fSASLMode == TRUE)
    {
        // Set to use AuthzID otherwise keep the NULL
        // set only if AuthzID contains data
        if (pDigest->usFlags & FLAG_AUTHZID_PROVIDED)
        {
            pstrAuthzID = &(pDigest->refstrParam[MD5_AUTH_AUTHZID]);
        }
    }

    DebugLog((DEB_TRACE, "DigestCalcHA1:  Algorithm type %d\n", pDigest->typeAlgorithm));

    // Now check if using MD5-SESS.  We need to form
    // H(A1) = H( H(PwKey) : nonce : cnonce [: authzID])
    // otherwise simply set H(A1) = H(PwKey)
    if (pDigest->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "DigestCalcHA1:  First client-server auth\n"));
        Status = DigestHash7(&strHPwKey,
                             &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                             &(pDigest->refstrParam[MD5_AUTH_CNONCE]),
                             pstrAuthzID,
                             NULL, NULL, NULL,
                             TRUE, &(pDigest->strSessionKey));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalcHA1:  SessionKey failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {        // Keep SessionKey = H(PwKey) for Algoithm = MD5
       memcpy(pDigest->strSessionKey.Buffer, strHPwKey.Buffer, MD5_HASH_HEX_SIZE);
       pDigest->strSessionKey.Length = MD5_HASH_HEX_SIZE;  // Do not count the NULL terminator
    }

    DebugLog((DEB_TRACE, "DigestCalcHA1:  SessionKey is %.10Z**********\n", &(pDigest->strSessionKey)));
    Status = STATUS_SUCCESS;

CleanUp:

    if (strBinaryHPwKey.Buffer && strBinaryHPwKey.MaximumLength)
    {
        SecureZeroMemory(strBinaryHPwKey.Buffer, strBinaryHPwKey.MaximumLength);
    }
    StringFree(&strBinaryHPwKey);

    if (strHPwKey.Buffer && strHPwKey.MaximumLength)
    {
        SecureZeroMemory(strHPwKey.Buffer, strHPwKey.MaximumLength);
    }
    StringFree(&strHPwKey);
    StringFree(&strHA0Base);
    StringFree(&strHA0);
    if (strPasswd.Buffer && strPasswd.MaximumLength)
    {
        SecureZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
    }
    StringFree(&strPasswd);
    StringFree(&strUsername);
    StringFree(&strRealm);

    if (ustrTempPasswd.Buffer && ustrTempPasswd.MaximumLength)
    {   // Zero out password info just to be safe
        SecureZeroMemory(ustrTempPasswd.Buffer, ustrTempPasswd.MaximumLength);
    }
    UnicodeStringFree(&ustrTempPasswd);

    DebugLog((DEB_TRACE_FUNC, "DigestCalcHA1: Leaving\n"));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestHash7
//
//  Synopsis:   Hash and Encode 7 STRINGS SOut = Hex(H(S1 S2 S3 S4 S5 S6 S7))
//
//  Effects:   
//
//  Arguments:  pS1,...,pS6 - STRINGS to hash, pS1 must be specified
//              fHexOut - perform a Hex operation on output
//              pSOut - STRING to hold Hex Encoded Hash
//
//  Returns:   STATUS_SUCCESS for normal completion
//
//  Notes:  pSOut->MaximumLength must be atleast (MD5_HASH_BYTESIZE (or MD5_HASH_HEX_SIZE) + sizeof(NULL))
//        Any pS# args which are NULL are skipped
//        if pS# is not NULL
//            Previously checked that pS# is non-zero length strings
//        You most likely want Sx->Length = strlen(Sx) so as not to include NULL
//   This function combines operations like H(S1 S2 S3), H(S1 S2 S3 S4 S5) ....
//   It is assumed that the char ':' is to be included getween Sn and Sn+1
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestHash7(
           IN PSTRING pS1,
           IN PSTRING pS2,
           IN PSTRING pS3,
           IN PSTRING pS4,
           IN PSTRING pS5,
           IN PSTRING pS6,
           IN PSTRING pS7,
           IN BOOL fHexOut,
           OUT PSTRING pSOut)
{

    NTSTATUS Status = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    BYTE bHashData[MD5_HASH_BYTESIZE];
    DWORD cbHashData = MD5_HASH_BYTESIZE;
    USHORT usSizeRequired = 0;
    char *pbSeparator = COLONSTR;

    DebugLog((DEB_TRACE_FUNC, "DigestHash7: Entering \n"));

    ASSERT(pSOut);

    if (fHexOut == TRUE)
    {
        usSizeRequired = MD5_HASH_HEX_SIZE;
    }
    else
    {
        usSizeRequired = MD5_HASH_BYTESIZE;
    }

    // Check if output is proper size or allocate one
    if (!pSOut->Buffer)
    {
        Status = StringAllocate(pSOut, usSizeRequired);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestHash7: No Memory\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {

        if (pSOut->MaximumLength < (usSizeRequired + 1))
        {
            // Output is not large enough to hold Hex(Hash)
            DebugLog((DEB_ERROR, "DigestHash7: Output buffer too small\n"));
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanUp;
        }
    }


    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "DigestHash7: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    if (pS1)
    {
        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS1->Buffer,
                             pS1->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    if (pS2)
    {

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS2->Buffer,
                             pS2->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    if (pS3)
    {
        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS3->Buffer,
                             pS3->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS4)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS4->Buffer,
                             pS4->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS5)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS5->Buffer,
                             pS5->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS6)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS6->Buffer,
                             pS6->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if (pS7)
    {

        (void)CryptHashData( hHash,
                             (const unsigned char *)pbSeparator,
                             COLONSTR_LEN,
                             0 );

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pS7->Buffer,
                             pS7->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "DigestHash7: CryptHashData failed : 0x%lx\n", GetLastError()));

            CryptDestroyHash( hHash );
            hHash = NULL;
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             bHashData,
                             &cbHashData,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "DigestHash7: CryptGetHashParam failed : 0x%lx\n", GetLastError()));

        CryptDestroyHash( hHash );
        hHash = NULL;
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    CryptDestroyHash( hHash );
    hHash = NULL;

    ASSERT(cbHashData == MD5_HASH_BYTESIZE);

    if (fHexOut == TRUE)
    {
        BinToHex(bHashData, cbHashData, pSOut->Buffer);
        pSOut->Length = MD5_HASH_HEX_SIZE;   // Do not count the NULL at the end
    }
    else
    {
        memcpy(pSOut->Buffer, bHashData, cbHashData);
        pSOut->Length = MD5_HASH_BYTESIZE;      // Do not count the NULL at the end
    }


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestHash7: Leaving    Status 0x%x\n", Status));

    return(Status);
}


// Blob creation/extraction for GenericPassthrough Messages



//+--------------------------------------------------------------------
//
//  Function:   BlobEncodeRequest
//
//  Synopsis:   Encode the Digest Access Parameters fields into a BYTE Buffer
//
//  Effects:    Creates a Buffer allocation which calling function
//     is responsible to delete with call to BlobFreeRequest()
//
//  Arguments:  pDigest - pointer to digest access data fields
//
//  Returns:
//
//  Notes:      STATUS_SUCCESS for normal completion
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
BlobEncodeRequest(
    PDIGEST_PARAMETER pDigest,
    OUT BYTE **ppOutBuffer,
    OUT USHORT *cbOutBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DebugLog((DEB_TRACE_FUNC, "BlobEncodeRequest: Entering\n"));

    USHORT cbBuffer = 0;
    BYTE *pBuffer = NULL;
    char *pch = NULL;
    PDIGEST_BLOB_REQUEST  pHeader;
    int i = 0;
    USHORT cbValue = 0;
    USHORT cbAccountName = 0;
    USHORT cbCrackedDomain = 0;
    USHORT cbWorkstation = 0;

    // Now figure out how many bytes needed to hold field-value NULL terminated
    for (i=0, cbBuffer = 0;i < DIGEST_BLOB_VALUES;i++)
    {
        if (pDigest->refstrParam[i].Buffer && pDigest->refstrParam[i].Length)
        {           // may be able to just count str.length
            cbBuffer = cbBuffer + strlencounted(pDigest->refstrParam[i].Buffer, pDigest->refstrParam[i].MaximumLength);
        }
    }
    cbBuffer = cbBuffer + (DIGEST_BLOB_VALUES * sizeof(char));       // Account for the separating/terminating NULLs

    // Now add in space for the DSCrackName accountname and domain
    if (pDigest->ustrCrackedAccountName.Buffer && pDigest->ustrCrackedAccountName.Length)
    {
        cbAccountName =  ustrlencounted((const short *)pDigest->ustrCrackedAccountName.Buffer,
                                            pDigest->ustrCrackedAccountName.Length) * sizeof(WCHAR);
        cbBuffer = cbBuffer + cbAccountName;
    }

    if (pDigest->ustrCrackedDomain.Buffer && pDigest->ustrCrackedDomain.Length)
    {
        cbCrackedDomain = ustrlencounted((const short *)pDigest->ustrCrackedDomain.Buffer,
                                            pDigest->ustrCrackedDomain.Length) * sizeof(WCHAR);
        cbBuffer = cbBuffer + cbCrackedDomain;
    }
    cbBuffer = cbBuffer + (2 * sizeof(WCHAR));       // Account for the separating/terminating NULLs

    // Now add in space for the workstation/server name
    if (g_ustrWorkstationName.Buffer && g_ustrWorkstationName.Length)
    {
        cbWorkstation =  ustrlencounted((const short *)g_ustrWorkstationName.Buffer,
                                            g_ustrWorkstationName.Length) * sizeof(WCHAR);
        cbBuffer = cbBuffer + cbWorkstation;
    }

    cbBuffer = cbBuffer + sizeof(WCHAR);       // Account for the separating/terminating NULL

    cbValue =  cbBuffer + (sizeof(DIGEST_BLOB_REQUEST));

    pBuffer = (BYTE *)DigestAllocateMemory(cbValue);
    if (!pBuffer)
    {
        DebugLog((DEB_ERROR, "BlobEncodeRequest out of memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "BlobEncodeRequest using %d bytes\n", cbValue));

    *cbOutBuffer = cbValue;    // Return number of bytes we are using for the encoding

    // Now fill in the information
    pHeader = (PDIGEST_BLOB_REQUEST)pBuffer;
    pHeader->MessageType = VERIFY_DIGEST_MESSAGE;
    pHeader->version = DIGEST_BLOB_VERSION;
    pHeader->digest_type = (USHORT)pDigest->typeDigest;
    pHeader->qop_type = (USHORT)pDigest->typeQOP;
    pHeader->alg_type = (USHORT)pDigest->typeAlgorithm;
    pHeader->charset_type = (USHORT)pDigest->typeCharset;
    pHeader->name_format = (USHORT)pDigest->typeName;             // Format of the username
    pHeader->cbCharValues = cbBuffer;
    pHeader->cbBlobSize = cbValue;   // cbCharValues + charvalues
    pHeader->cbAccountName = cbAccountName + sizeof(WCHAR);    // string length includes NULL terminator
    pHeader->cbCrackedDomain = cbCrackedDomain + sizeof(WCHAR);
    pHeader->cbWorkstation = cbWorkstation + sizeof(WCHAR);
    pHeader->usFlags = pDigest->usFlags;

    // Simply copy over the first DIGEST_BLOB_VALUES that are arranged to be 
    for (i = 0,pch = &(pHeader->cCharValues); i < DIGEST_BLOB_VALUES;i++)
    {
           // Make sure that there is valid data to get length from
        if (pDigest->refstrParam[i].Buffer && pDigest->refstrParam[i].Length)
        {
            cbValue = strlencounted(pDigest->refstrParam[i].Buffer, pDigest->refstrParam[i].MaximumLength);  
            // dont use .length since may include multiple NULLS

            memcpy(pch, pDigest->refstrParam[i].Buffer, cbValue);
        }
        else
            cbValue = 0;
        pch += (cbValue + 1);  // This will leave one NULL at end of field-value
    }


       // Now write out any results from DSCrackName
    if (pDigest->ustrCrackedAccountName.Buffer && pDigest->ustrCrackedAccountName.Length)
    {
        memcpy(pch, pDigest->ustrCrackedAccountName.Buffer, cbAccountName);
    }
    pch += (cbAccountName + sizeof(WCHAR));  // This will leave one WCHAR NULL at end of CrackedAccountName

    if (pDigest->ustrCrackedDomain.Buffer && pDigest->ustrCrackedDomain.Length)
    {
        memcpy(pch, pDigest->ustrCrackedDomain.Buffer, cbCrackedDomain);
    }
    pch += (cbCrackedDomain + sizeof(WCHAR));  // This will leave one WCHAR NULL at end of CrackedAccountName

    if (g_ustrWorkstationName.Buffer && g_ustrWorkstationName.Length)
    {
        memcpy(pch, g_ustrWorkstationName.Buffer, cbWorkstation);
    }
    else
    pch += (cbWorkstation + sizeof(WCHAR));  // This will leave one WCHAR NULL at end of Workstation name

    *ppOutBuffer = pBuffer;    // Pass off memory back to calling routine

    DebugLog((DEB_TRACE, "BlobEncodeRequest: message_type 0x%x, version %d, CharValues %d, BlobSize %d\n",
              pHeader->digest_type, pHeader->version, pHeader->cbCharValues, pHeader->cbBlobSize));

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "BlobEncodeRequest: Leaving   Status 0x%x\n", Status));

    return(Status);
}




//+--------------------------------------------------------------------
//
//  Function:   BlobDecodeRequest
//
//  Synopsis:   Decode the Digest Access Parameters fields from a BYTE Buffer
//
//  Arguments:  pBuffer - pointer to BlobEncodeRequestd buffer as input
//              pDigest - pointer to Digest parameter struct to set STRINGS
//                 to point within pBuffer.  No string memory is allocated
//
//  Returns: NTSTATUS
//
//  Notes: 
//      Currently only processes a single version of the packet.  Check MessageType
//  and version number if new message types are supported on the DC.
//
//---------------------------------------------------------------------

NTSTATUS NTAPI BlobDecodeRequest(
                         IN USHORT cbBuffer,
                         IN BYTE *pBuffer,
                         PDIGEST_PARAMETER pDigest
                         )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DIGEST_BLOB_REQUEST Header;
    PDIGEST_BLOB_REQUEST pHeader;
    char *pch = NULL;
    USHORT sLen = 0;
    int i = 0;    // counter
    BOOL  fKnownFormat = FALSE;
    USHORT sMaxRead = 0;
    PWCHAR pusTemp = NULL;
    PWCHAR pusLoc = NULL;
    USHORT usCnt = 0;

    //UNREFERENCED_PARAMETER(cbBuffer);

    DebugLog((DEB_TRACE_FUNC, "BlobDecodeRequest: Entering\n"));

    if (!pBuffer || !pDigest)
    {
        DebugLog((DEB_ERROR, "BlobDecodeRequest: Invalid parameter\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Copy over the header for byte alignment

    if (cbBuffer < sizeof(Header))
    {
        DebugLog((DEB_ERROR, "BlobDecodeRequest: Header block not present\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    memcpy((char *)&Header, (char *)pBuffer, sizeof(Header));


    DebugLog((DEB_TRACE, "BlobDecodeRequest: message_type %lu version %d, CharValues %d, BlobSize %d\n",
              Header.MessageType, Header.version, Header.cbCharValues, Header.cbBlobSize));

    // Process the encoded message - use only the known MessageTypes and versions here on the DC
    // This allows for expansion of protocols supported in the future

    if ((Header.MessageType == VERIFY_DIGEST_MESSAGE) && (Header.version == DIGEST_BLOB_VERSION))
    {
        fKnownFormat = TRUE;
        DebugLog((DEB_TRACE, "BlobDecodeRequest: Blob from server known type and version\n"));
    }

    if (!fKnownFormat)
    {
        DebugLog((DEB_ERROR, "BlobDecodeRequest: Not supported MessageType/Version\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    pDigest->typeDigest = (DIGEST_TYPE)Header.digest_type;
    pDigest->typeQOP = (QOP_TYPE)Header.qop_type;
    pDigest->typeAlgorithm = (ALGORITHM_TYPE)Header.alg_type;
    pDigest->typeCharset = (CHARSET_TYPE)Header.charset_type;
    pDigest->typeName = (NAMEFORMAT_TYPE)Header.name_format;
    pDigest->usFlags = (USHORT)Header.usFlags;

    DebugLog((DEB_TRACE, "BlobDecodeRequest: typeDigest 0x%x, typeQOP %d, typeAlgorithm %d, typeCharset %d NameFormat %d\n",
              pDigest->typeDigest, pDigest->typeQOP, pDigest->typeAlgorithm, pDigest->typeCharset, pDigest->typeName));

    pHeader = (PDIGEST_BLOB_REQUEST)pBuffer;
    pch = &(pHeader->cCharValues);              // strings start on last char of struct
    sMaxRead = Header.cbCharValues;
    for (i = 0; i < DIGEST_BLOB_VALUES;i++)
    {
        sLen = strlencounted(pch, sMaxRead);
        if (!sLen)
        {
            // Null String no value skip to next
            pch++;
            sMaxRead--;
        }
        else
        {     // Simple check to make sure that we do not copy way too much
            if (sLen < (Header.cbCharValues))
            {
                DebugLog((DEB_TRACE, "BlobDecodeRequest: Setting Digest[%d] = %s\n", i, pch));
                pDigest->refstrParam[i].Buffer = pch;
                pDigest->refstrParam[i].Length = sLen;
                pDigest->refstrParam[i].MaximumLength = sLen+1;
                pch += (sLen + 1);   // skip over field-value and NULL
                sMaxRead -= (sLen + 1);
            }
            else
            {
                // This indicates failed NULL separators in BlobData
                // Really should not happen unless encoded wrong
                Status = STATUS_INTERNAL_DB_CORRUPTION;
                memset(pDigest, 0, sizeof(DIGEST_PARAMETER));  // scrubbed all info
                DebugLog((DEB_ERROR, "BlobDecodeRequest: NULL separator missing\n"));
                goto CleanUp;
            }
        }
    }

    // Read in the values that DSCrackName on the server found out
    // Need to place on SHORT boundary for Unicode string processing

    usCnt = sMaxRead + (3 * sizeof(WCHAR));
    pusTemp = (PWCHAR)DigestAllocateMemory(usCnt);   // Force a NULL terminator just to be safe
    if (!pusTemp)
    {
        Status = STATUS_NO_MEMORY;
        DebugLog((DEB_ERROR, "BlobDecodeRequest: Memory Alloc Error\n"));
        goto CleanUp;
    }

    // Format will be Unicode_account_name NULL Unicode_domain_name NULL Unicode_WorkstationName NULL [NULL NULL NULL]
    memcpy((PCHAR)pusTemp, pch, sMaxRead); 

    // Read out the three unicode strings
    Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedAccountName), pusTemp, 0);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"BlobDecodeRequest: Failed to duplicate Account Name: 0x%x\n",Status));
        goto CleanUp;
    }

    pusLoc = pusTemp + (1 + (pDigest->ustrCrackedAccountName.Length / sizeof(WCHAR)));  // Skip NULL
    Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedDomain), pusLoc, 0);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"BlobDecodeRequest: Failed to duplicate Domain Name: 0x%x\n",Status));
        goto CleanUp;
    }

    pusLoc = pusTemp + (2 + ((pDigest->ustrCrackedAccountName.Length + pDigest->ustrCrackedDomain.Length) / sizeof(WCHAR)));  // Skip NULL
    Status = UnicodeStringWCharDuplicate(&(pDigest->ustrWorkstation), pusLoc, 0);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"BlobDecodeRequest: Failed to duplicate Workstation Name: 0x%x\n",Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE,"BlobDecodeRequest: Cracked Account %wZ    Domain %wZ   Workstation %wZ\n",
              &(pDigest->ustrCrackedAccountName),
              &(pDigest->ustrCrackedDomain),
              &(pDigest->ustrWorkstation)));

    // If AuthzID directive was present but no length then create a valid buffer but zero length
    if ((pDigest->usFlags & FLAG_AUTHZID_PROVIDED) &&
        !pDigest->refstrParam[MD5_AUTH_AUTHZID].Buffer)
    {
        pDigest->refstrParam[MD5_AUTH_AUTHZID].Buffer = &(pHeader->cCharValues); // strings start on last char of struct;
        pDigest->refstrParam[MD5_AUTH_AUTHZID].Length = 0;
        pDigest->refstrParam[MD5_AUTH_AUTHZID].MaximumLength = 0;
    }

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "BlobDecodeRequest: Leaving 0x%x\n", Status));

    if (pusTemp)
    {
        DigestFreeMemory(pusTemp);
        pusTemp = NULL;
    }

    return(Status);
}


// Free BYTE Buffer from BlobEncodeRequest
VOID NTAPI BlobFreeRequest(
    BYTE *pBuffer
    )
{
    if (pBuffer)
    {
        DigestFreeMemory(pBuffer);
    }
    return;
}


#else   // SECURITY_KERNEL



//+--------------------------------------------------------------------
//
//  Function:   DigestHash7 - kernel mode
//
//  Synopsis:   Hash and Encode 7 STRINGS SOut = Hex(H(S1 S2 S3 S4 S5 S6 S7))
//
//  Effects:   
//
//  Arguments:  pS1,...,pS6 - STRINGS to hash, pS1 must be specified
//              fHexOut - perform a Hex operation on output
//              pSOut - STRING to hold Hex Encoded Hash
//
//  Returns:   STATUS_SUCCESS for normal completion
//
//  Notes:  pSOut->MaximumLength must be atleast (MD5_HASH_BYTESIZE (or MD5_HASH_HEX_SIZE) + sizeof(NULL))
//        Any pS# args which are NULL are skipped
//        if pS# is not NULL
//            Previously checked that pS# is non-zero length strings
//        You most likely want Sx->Length = strlen(Sx) so as not to include NULL
//   This function combines operations like H(S1 S2 S3), H(S1 S2 S3 S4 S5) ....
//   It is assumed that the char ':' is to be included getween Sn and Sn+1
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestHash7(
           IN PSTRING pS1,
           IN PSTRING pS2,
           IN PSTRING pS3,
           IN PSTRING pS4,
           IN PSTRING pS5,
           IN PSTRING pS6,
           IN PSTRING pS7,
           IN BOOL fHexOut,
           OUT PSTRING pSOut)
{

    NTSTATUS Status = STATUS_SUCCESS;
    MD5_CTX Md5Context;
    USHORT usSizeRequired = 0;
    char *pbSeparator = COLONSTR;

    DebugLog((DEB_TRACE_FUNC, "DigestHash7: Entering \n"));

    // Verify the size of the output digest is what we assume
    ASSERT(MD5DIGESTLEN == MD5_HASH_BYTESIZE);

    ASSERT(pSOut);

    if (fHexOut == TRUE)
    {
        usSizeRequired = MD5_HASH_HEX_SIZE;
    }
    else
    {
        usSizeRequired = MD5_HASH_BYTESIZE;
    }

    // Check if output is proper size or allocate one
    if (!pSOut->Buffer)
    {
        Status = StringAllocate(pSOut, usSizeRequired);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestHash7: No Memory\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        if (pSOut->MaximumLength < (usSizeRequired + 1))
        {
            // Output is not large enough to hold Hex(Hash)
            DebugLog((DEB_ERROR, "DigestHash7: Output buffer too small\n"));
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanUp;
        }
    }


    MD5Init(&Md5Context);

    if (pS1)
    {
        MD5Update(&Md5Context, (const unsigned char *)pS1->Buffer, pS1->Length);
    }
    if (pS2)
    {
        MD5Update(&Md5Context, (const unsigned char *)pbSeparator, COLONSTR_LEN);
        MD5Update(&Md5Context, (const unsigned char *)pS2->Buffer, pS2->Length);
    }
    if (pS3)
    {
        MD5Update(&Md5Context, (const unsigned char *)pbSeparator, COLONSTR_LEN);
        MD5Update(&Md5Context, (const unsigned char *)pS3->Buffer, pS3->Length);
    }
    if (pS4)
    {
        MD5Update(&Md5Context, (const unsigned char *)pbSeparator, COLONSTR_LEN);
        MD5Update(&Md5Context, (const unsigned char *)pS4->Buffer, pS4->Length);
    }
    if (pS5)
    {
        MD5Update(&Md5Context, (const unsigned char *)pbSeparator, COLONSTR_LEN);
        MD5Update(&Md5Context, (const unsigned char *)pS5->Buffer, pS5->Length);
    }
    if (pS6)
    {
        MD5Update(&Md5Context, (const unsigned char *)pbSeparator, COLONSTR_LEN);
        MD5Update(&Md5Context, (const unsigned char *)pS6->Buffer, pS6->Length);
    }
    if (pS7)
    {
        MD5Update(&Md5Context, (const unsigned char *)pbSeparator, COLONSTR_LEN);
        MD5Update(&Md5Context, (const unsigned char *)pS7->Buffer, pS7->Length);
    }

    MD5Final(&Md5Context);

    if (fHexOut == TRUE)
    {
        BinToHex((LPBYTE)Md5Context.digest, MD5_HASH_BYTESIZE, pSOut->Buffer);
        pSOut->Length = MD5_HASH_HEX_SIZE;   // Do not count the NULL at the end
    }
    else
    {
        RtlCopyMemory(pSOut->Buffer, Md5Context.digest, MD5_HASH_BYTESIZE);
        pSOut->Length = MD5_HASH_BYTESIZE;      // Do not count the NULL at the end
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestHash7: Leaving    Status 0x%x\n", Status));

    return(Status);
}

#endif  // SECURITY_KERNEL



// Generate the output buffer from a given Digest
NTSTATUS NTAPI
DigestCreateChalResp(
                 IN PDIGEST_PARAMETER pDigest,
                 IN PUSER_CREDENTIALS pUserCreds,
                 OUT PSecBuffer OutBuffer
                 )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbLenNeeded = 0;
    STRING strcQOP = {0};      // string pointing to a constant value
    STRING strcAlgorithm = {0};
    BOOL fSASLMode = FALSE;
    UINT uCodePage = CP_8859_1; 

    STRING strTempRealm = {0};      // Backslash encoded forms
    STRING strTempUsername = {0};

    STRING strRealm = {0};
    STRING strUsername = {0};
    PSTRING pstrUsername = NULL;
    PSTRING pstrRealm = NULL;

    PCHAR pczTemp = NULL;
    PCHAR pczTemp2 = NULL;

    DebugLog((DEB_TRACE_FUNC, "DigestCreateChalResp: Entering\n"));

    // allocate the buffers for output - in the future can optimze to allocate exact amount needed
    pczTemp = (PCHAR)DigestAllocateMemory((3 * NTDIGEST_SP_MAX_TOKEN_SIZE) + 1);
    if (!pczTemp)
    {
        DebugLog((DEB_ERROR, "DigestCreateChalResp:  No memory for output buffers\n"));
        goto CleanUp;
    }

    pczTemp2 = (PCHAR)DigestAllocateMemory(NTDIGEST_SP_MAX_TOKEN_SIZE + 1);
    if (!pczTemp2)
    {
        DebugLog((DEB_ERROR, "DigestCreateChalResp:  No memory for output buffers\n"));
        goto CleanUp;
    }

    //pczTemp[0] = '\0';  DigestAllocateMemory() should have zeroed the bytes
    //pczTemp2[0] = '\0';

    if ((pDigest->typeDigest == SASL_SERVER) || (pDigest->typeDigest == SASL_CLIENT))
    {
        fSASLMode = TRUE;
    }

    // Establish which QOP utilized
    if (pDigest->typeQOP == AUTH_CONF)
    {
        RtlInitString(&strcQOP, AUTHCONFSTR);
    }
    else if (pDigest->typeQOP == AUTH_INT)
    {
        RtlInitString(&strcQOP, AUTHINTSTR);
    }
    else if (pDigest->typeQOP == AUTH)
    {
        RtlInitString(&strcQOP, AUTHSTR);
    }


    // Determine which code page to utilize
    if (pDigest->typeCharset == UTF_8)
    {
        uCodePage = CP_UTF8;
    }
    else
    {
        uCodePage = CP_8859_1;
    }

    // if provided with UserCred then use them, otherwise use Digest directive values
    if (pUserCreds)
    {
#ifndef SECURITY_KERNEL
        DebugLog((DEB_TRACE, "DigestCreateChalResp: UserCredentials presented - encode and output\n"));

        Status = EncodeUnicodeString(&pUserCreds->ustrUsername, uCodePage, &strUsername, NULL);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "DigestCreateChalResp: Error in encoding username\n"));
            goto CleanUp;
        }

            // Now encode the user directed fields (username, URI, realm)
        Status = BackslashEncodeString(&strUsername, &strTempUsername);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestCreateChalResp: BackslashEncode failed      status 0x%x\n", Status));
            goto CleanUp;
        }

        pstrUsername = &strTempUsername;

        // Make copy of the directive values for LSA to Usermode context
        Status = StringDuplicate(&(pDigest->strUsernameEncoded), pstrUsername);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCreateChalResp: Failed to copy over UsernameEncoded\n"));
            goto CleanUp;
        }

        Status = StringReference(&(pDigest->refstrParam[MD5_AUTH_USERNAME]), &(pDigest->strUsernameEncoded));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCreateChalResp: Failed reference UsernameEncoded\n"));
            goto CleanUp;
        }

        if (pUserCreds->ustrRealm.Buffer)
        {
            Status = EncodeUnicodeString(&pUserCreds->ustrRealm, uCodePage, &strRealm, NULL);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "DigestCreateChalResp: Error in encoding realm\n"));
                goto CleanUp;
            }

            Status = BackslashEncodeString(&strRealm, &strTempRealm);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestCreateChalResp: BackslashEncode failed      status 0x%x\n", Status));
                goto CleanUp;
            }

            pstrRealm = &strTempRealm;

            Status = StringDuplicate(&(pDigest->strRealmEncoded), pstrRealm);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCreateChalResp: Failed to copy over RealmEncoded\n"));
                goto CleanUp;
            }

            Status = StringReference(&(pDigest->refstrParam[MD5_AUTH_REALM]), &(pDigest->strRealmEncoded));
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCreateChalResp: Failed reference RealmEncoded\n"));
                goto CleanUp;
            }

        }
        else
        {
            pstrRealm = &(pDigest->refstrParam[MD5_AUTH_REALM]);
            DebugLog((DEB_ERROR, "DigestCreateChalResp: Realm defaulted to Challenge realm value\n"));
        }

#else    // SECURITY_KERNEL
        DebugLog((DEB_ERROR, "DigestCreateChalResp: User credential processing not permitted\n"));
        Status = STATUS_NOT_SUPPORTED;
        goto CleanUp;
#endif   // SECURITY_KERNEL
    }
    else
    {
        // No usercreds passed in so just use the current digest directive values
        DebugLog((DEB_WARN, "DigestCreateChalResp: No UserCredentials - use provided digest\n"));
        pstrUsername = &(pDigest->refstrParam[MD5_AUTH_USERNAME]);
        pstrRealm = &(pDigest->refstrParam[MD5_AUTH_REALM]);
    }

    // Request-URI will be % encoded  backslash is an excluded character so not backslash encoding

       // Precalc the amount of space needed for output
    cbLenNeeded = CB_CHALRESP;    // MAX byte count for directives and symbols
    cbLenNeeded += pstrUsername->Length;
    cbLenNeeded += pstrRealm->Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_NONCE].Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_URI].Length;
    cbLenNeeded += pDigest->strResponse.Length;
    cbLenNeeded += strcAlgorithm.Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_CNONCE].Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_OPAQUE].Length;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_AUTHZID].Length;
    cbLenNeeded += MAX_AUTH_LENGTH;
    cbLenNeeded += pDigest->refstrParam[MD5_AUTH_NC].Length;
    cbLenNeeded += strcQOP.Length;

    if (cbLenNeeded > NTDIGEST_SP_MAX_TOKEN_SIZE)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestCreateChalResp: output exceed max size or buffer too small  len is %d\n", cbLenNeeded));
        goto CleanUp;
    }

    // In digest calc - already checked username,realm,nonce,method,uri
    // Make sure there are values for the rest needed

    if ((!pDigest->strResponse.Length) ||
        (!pDigest->refstrParam[MD5_AUTH_NC].Length) ||
        (!pDigest->refstrParam[MD5_AUTH_CNONCE].Length))
    {
        // Failed on a require field-value
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestCreateChalResp: Response, NC, or Cnonce is zero length\n"));
        goto CleanUp;
    }

    if (pstrRealm->Length)
    {
        sprintf(pczTemp,
       "username=\"%Z\",realm=\"%Z\",nonce=\"%Z\",%s=\"%Z\"",
                pstrUsername,
                pstrRealm,
                &pDigest->refstrParam[MD5_AUTH_NONCE],
                ((fSASLMode == TRUE) ? DIGESTURI_STR: URI_STR),
                &pDigest->refstrParam[MD5_AUTH_URI]);
    }
    else
    {
        sprintf(pczTemp,
       "username=\"%Z\",realm=\"\",nonce=\"%Z\",%s=\"%Z\"",
                pstrUsername,
                &pDigest->refstrParam[MD5_AUTH_NONCE],
                ((fSASLMode == TRUE) ? DIGESTURI_STR: URI_STR),
                &pDigest->refstrParam[MD5_AUTH_URI]);
    }

    if (pDigest->typeQOP != NO_QOP_SPECIFIED)
    {
        // Do not output cnonce and nc when QOP was not specified
        // this happens only for HTTP mode.  In SASL mode, we default to AUTH if not specified
        sprintf(pczTemp2, ",cnonce=\"%Z\",nc=%Z",
                 &pDigest->refstrParam[MD5_AUTH_CNONCE],
                &pDigest->refstrParam[MD5_AUTH_NC]);
        strcat(pczTemp, pczTemp2);
    }

    if (fSASLMode == TRUE)
    {
        // Do not output algorithm - must be md5-sess and that is assumed
        sprintf(pczTemp2, ",response=%Z", &pDigest->strResponse);
        strcat(pczTemp, pczTemp2);
    }
    else
    {
        if (pDigest->typeAlgorithm == MD5_SESS)
        {
            sprintf(pczTemp2, ",algorithm=MD5-sess,response=\"%Z\"", &pDigest->strResponse);
            strcat(pczTemp, pczTemp2);
        }
        else
        {
            sprintf(pczTemp2, ",response=\"%Z\"", &pDigest->strResponse);
            strcat(pczTemp, pczTemp2);
        }
    }

    // Attach QOP if specified - support older format for no QOP
    // RFC has qop not quoted, but older IIS needed this quoted.
    // Set ClientCompat bit off to conform to RFC
    if (strcQOP.Length)
    {
        if ((fSASLMode == TRUE) || (!(pDigest->usFlags & FLAG_QUOTE_QOP)))
        {
            sprintf(pczTemp2, ",qop=%Z", &strcQOP);
            strcat(pczTemp, pczTemp2);
        }
        else
        {
            sprintf(pczTemp2, ",qop=\"%Z\"", &strcQOP);
            strcat(pczTemp, pczTemp2);
        }
    }

    // Attach Cipher selected if required
    if (pDigest->typeQOP == AUTH_CONF)
    {
        // FIX optimize these into a list for efficiency
        if (pDigest->typeCipher == CIPHER_RC4)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_RC4);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_RC4_56)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_RC4_56);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_RC4_40)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_RC4_40);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_3DES)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_3DES);
            strcat(pczTemp, pczTemp2);
        }
        else if (pDigest->typeCipher == CIPHER_DES)
        {
            sprintf(pczTemp2, ",cipher=%s", STR_CIPHER_DES);
            strcat(pczTemp, pczTemp2);
        }
    }

    // Attach opaque data (but not on SASL)
    if ((fSASLMode == FALSE) && pDigest->refstrParam[MD5_AUTH_OPAQUE].Length)
    {
        sprintf(pczTemp2, ",opaque=\"%Z\"", &pDigest->refstrParam[MD5_AUTH_OPAQUE]);
        strcat(pczTemp, pczTemp2);
    }

    // Attach authzid data (only in SASL mode)
    if ((fSASLMode == TRUE) && (pDigest->usFlags & FLAG_AUTHZID_PROVIDED))                               
    {
        if (pDigest->refstrParam[MD5_AUTH_AUTHZID].Length)
        {
            sprintf(pczTemp2, ",authzid=\"%Z\"", &pDigest->refstrParam[MD5_AUTH_AUTHZID]);
        }
        else
        {
            sprintf(pczTemp2, ",authzid=\"\"");
        }
        strcat(pczTemp, pczTemp2);
    }

    // Attach charset to indicate that UTF-8 character encoding is utilized
    if (pDigest->typeCharset == UTF_8)
    {
        strcat(pczTemp, ",charset=utf-8");
    }


    // total buffer for Challenge (NULL is not included in output buffer - ref:Bug 310201)
    cbLenNeeded = (USHORT)strlen(pczTemp);

    if (cbLenNeeded > NTDIGEST_SP_MAX_TOKEN_SIZE)
    {
        ASSERT(0);    // This never happen since tested MAX size of cbLenNeeded above
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestCreateChalResp: output challengeResponse too long\n"));
        goto CleanUp;
    }

    // Check on allocating output buffer
    if (!OutBuffer->cbBuffer)
    {
        OutBuffer->pvBuffer = DigestAllocateMemory(cbLenNeeded);
        if (!OutBuffer->pvBuffer)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "DigestCreateChalResp: out of memory on challenge output\n"));
            goto CleanUp;
        }
        OutBuffer->cbBuffer = cbLenNeeded;
    }

    if (cbLenNeeded > OutBuffer->cbBuffer)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestCreateChalResp: output buffer too small need %d len is %d\n",
                  cbLenNeeded, OutBuffer->cbBuffer));
        goto CleanUp;
    }

    memcpy(OutBuffer->pvBuffer, pczTemp, cbLenNeeded);
    OutBuffer->cbBuffer = cbLenNeeded;
    OutBuffer->BufferType = SECBUFFER_TOKEN;

CleanUp:

    if (pczTemp)
    {
        DigestFreeMemory(pczTemp);
        pczTemp = NULL;
    }

    if (pczTemp2)
    {
        DigestFreeMemory(pczTemp2);
        pczTemp2 = NULL;
    }

    StringFree(&strTempRealm);
    StringFree(&strTempUsername);
    StringFree(&strRealm);
    StringFree(&strUsername);

    DebugLog((DEB_TRACE_FUNC, "DigestCreateChalResp: Leaving   status 0x%x\n", Status));
    return(Status);
}


NTSTATUS
DigestPrint(PDIGEST_PARAMETER pDigest)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    if (!pDigest)
    {
        return (STATUS_INVALID_PARAMETER); 
    }

    if (pDigest->typeDigest == DIGEST_UNDEFINED)
    {
        DebugLog((DEB_TRACE, "Digest:       DIGEST_UNDEFINED\n"));
    }
    if (pDigest->typeDigest == NO_DIGEST_SPECIFIED)
    {
        DebugLog((DEB_ERROR, "Digest:       NO_DIGEST_SPECIFIED\n"));
    }
    if (pDigest->typeDigest == DIGEST_CLIENT)
    {
        DebugLog((DEB_TRACE, "Digest:       DIGEST_CLIENT\n"));
    }
    if (pDigest->typeDigest == DIGEST_SERVER)
    {
        DebugLog((DEB_TRACE, "Digest:       DIGEST_SERVER\n"));
    }
    if (pDigest->typeDigest == SASL_SERVER)
    {
        DebugLog((DEB_TRACE, "Digest:       SASL_SERVER\n"));
    }
    if (pDigest->typeDigest == SASL_CLIENT)
    {
        DebugLog((DEB_TRACE, "Digest:       SASL_CLIENT\n"));
    }
    if (pDigest->typeQOP == QOP_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Digest:       QOP: Not QOP_UNDEFINED\n"));
    }
    if (pDigest->typeQOP == NO_QOP_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: Not Specified\n"));
    }
    if (pDigest->typeQOP == AUTH)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: AUTH\n"));
    }
    if (pDigest->typeQOP == AUTH_INT)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: AUTH_INT\n"));
    }
    if (pDigest->typeQOP == AUTH_CONF)
    {
        DebugLog((DEB_TRACE, "Digest:       QOP: AUTH_CONF\n"));
    }
    if (pDigest->typeAlgorithm == ALGORITHM_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Digest:       Algorithm: ALGORITHM_UNDEFINED\n"));
    }
    if (pDigest->typeAlgorithm == NO_ALGORITHM_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Digest:       Algorithm: NO_ALGORITHM_SPECIFIED\n"));
    }
    if (pDigest->typeAlgorithm == MD5)
    {
        DebugLog((DEB_TRACE, "Digest:       Algorithm: MD5\n"));
    }
    if (pDigest->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "Digest:       Algorithm: MD5_SESS\n"));
    }
    if (pDigest->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "Digest:       CharSet: ISO-8859-1\n"));
    }
    if (pDigest->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "Digest:       CharSet: UTF-8\n"));
    }

    if (pDigest->usFlags & FLAG_CRACKNAME_ON_DC)
    {
        DebugLog((DEB_TRACE, "Digest:       Flags: CrackName on DC\n"));
    }

    if (pDigest->usFlags & FLAG_AUTHZID_PROVIDED)
    {
        DebugLog((DEB_TRACE, "Digest:       Flags: AuthzID info provided\n"));
    }

    if (pDigest->usFlags & FLAG_SERVERS_DOMAIN)
    {
        DebugLog((DEB_TRACE, "Digest:       Flags: Server's DC\n"));
    }

    if (pDigest->usFlags & FLAG_BS_ENCODE_CLIENT_BROKEN)
    {
        DebugLog((DEB_TRACE, "Digest:       Flags: Client BS encode compatibility\n"));
    }

    if (pDigest->usFlags & FLAG_AUTHZID_PROVIDED)
    {
        DebugLog((DEB_TRACE, "Digest:       Flags: AuthzID provided\n"));
    }

    if (pDigest->usFlags & FLAG_NOBS_DECODE)
    {
        DebugLog((DEB_TRACE, "Digest:       Flags: No Backslash Decoding\n"));
    }

    for (i=0; i < MD5_AUTH_LAST;i++)
    {
        if (pDigest->refstrParam[i].Buffer &&
            pDigest->refstrParam[i].Length)
        {
            DebugLog((DEB_TRACE, "Digest:       Digest[%d] = \"%Z\"\n", i,  &pDigest->refstrParam[i]));
        }
    }


    DebugLog((DEB_TRACE, "Digest:      SessionKey %Z\n", &(pDigest->strSessionKey)));
    DebugLog((DEB_TRACE, "Digest:     Response %Z\n", &(pDigest->strResponse)));
    DebugLog((DEB_TRACE, "Digest:     Username %wZ\n", &(pDigest->ustrUsername)));
    DebugLog((DEB_TRACE, "Digest:     Realm %wZ\n", &(pDigest->ustrRealm)));
    DebugLog((DEB_TRACE, "Digest:     CrackedAccountName %wZ\n", &(pDigest->ustrCrackedAccountName)));
    DebugLog((DEB_TRACE, "Digest:     CrackedDomain %wZ\n", &(pDigest->ustrCrackedDomain)));
    DebugLog((DEB_TRACE, "Digest:     Workstation %wZ\n", &(pDigest->ustrWorkstation)));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\ctxt.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ctxt.cxx
//
// Contents:    Context manipulation functions
//
//
// History:     KDamour  15Mar00   Stolen from NTLM context.cxx
//
//------------------------------------------------------------------------
#include "global.h"

// Globals for manipulating Context Lists

#define             DIGEST_LIST_COUNT             (16)    // count of lists
#define             DIGEST_LIST_LOCK_COUNT_MAX    (4)     // count of locks

LIST_ENTRY          DigestContextList[ DIGEST_LIST_COUNT ];             // list array.
RTL_RESOURCE        DigestContextLock[ DIGEST_LIST_LOCK_COUNT_MAX ];    // lock array
ULONG               DigestContextCount[ DIGEST_LIST_COUNT ];            // count of active contexts
ULONG               DigestContextLockCount;


// Indicate if completed Initialization of Credential Handler
BOOL  g_bContextInitialized = FALSE;



ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    );

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    );


//+--------------------------------------------------------------------
//
//  Function:   SspContextInitialize
//
//  Synopsis:   Initializes the context manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInitialize
//
//---------------------------------------------------------------------
NTSTATUS
CtxtHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NT_PRODUCT_TYPE ProductType;
    ULONG Index;
    ULONG cResourcesInitialized = 0;

    for( Index=0 ; Index < DIGEST_LIST_COUNT ; Index++ )
    {
        InitializeListHead (&DigestContextList[Index]);
    }


    DigestContextLockCount = 1;


    RtlGetNtProductType( &ProductType );

    if( ProductType == NtProductLanManNt ||
        ProductType == NtProductServer )
    {
        SYSTEM_INFO si;

        GetSystemInfo( &si );

        //
        // if not an even power of two, bump it up.
        //

        if( si.dwNumberOfProcessors & 1 )
        {
            si.dwNumberOfProcessors++;
        }

        //
        // insure it fits in the confines of the max allowed.
        //

        if( si.dwNumberOfProcessors > DIGEST_LIST_LOCK_COUNT_MAX )
        {
            si.dwNumberOfProcessors = DIGEST_LIST_LOCK_COUNT_MAX;
        }

        if( si.dwNumberOfProcessors )
        {
            DigestContextLockCount = si.dwNumberOfProcessors;
        }
    }

    //
    // list count is 1, or a power of two, for index purposes.
    //

    ASSERT( (DigestContextLockCount == 1) || ((DigestContextLockCount % 2) == 0) );

    for (Index=0; Index < DigestContextLockCount; Index++)
    {
        __try
        {
            RtlInitializeResource(&DigestContextLock[Index]);
            cResourcesInitialized++; // keep track of Resources that are initialized
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }

    //
    // avoiding deleting RTL_RESOURCEs with un-initialized fields
    //

    if (!NT_SUCCESS(Status))
    {
        for (Index = 0; Index < cResourcesInitialized; Index++)
        {
             RtlDeleteResource(&DigestContextLock[Index]);
        }
    }

    // Simple variable test to make sure all initialized;
    g_bContextInitialized = TRUE;

    return Status;
}


// Add a Context into the Context List
NTSTATUS
CtxtHandlerInsertCred(
    IN PDIGEST_CONTEXT  pDigestCtxt
    )
{
    ULONG ListIndex;
    ULONG LockIndex;

    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerInsertCred: Entering with Context 0x%x RefCount %ld\n", pDigestCtxt, pDigestCtxt->lReferences));
    DebugLog((DEB_TRACE, "CtxtHandlerInsertCred: add into list\n"));
    

    ListIndex = HandleToListIndex( (ULONG_PTR)pDigestCtxt );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceExclusive(&DigestContextLock[LockIndex], TRUE);
    InsertHeadList( &DigestContextList[ListIndex], &pDigestCtxt->Next );
    RtlReleaseResource(&DigestContextLock[LockIndex]);

    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerInsertCred: Leaving with Context 0x%x\n", pDigestCtxt));

    return STATUS_SUCCESS;
}


// Initialize a Context into the IdleState with the data from the Credential provided
NTSTATUS NTAPI
ContextInit(
           IN OUT PDIGEST_CONTEXT pContext,
           IN PDIGEST_CREDENTIAL pCredential
           )
{

    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "ContextInit: Entering\n"));

    if (!pContext || !pCredential)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pContext, sizeof(DIGEST_CONTEXT));

    pContext->typeQOP = QOP_UNDEFINED;
    pContext->typeDigest = DIGEST_UNDEFINED;
    pContext->typeAlgorithm = ALGORITHM_UNDEFINED;
    pContext->typeCipher = CIPHER_UNDEFINED;
    pContext->typeCharset = CHARSET_UNDEFINED;
    pContext->lReferences = 0;
    pContext->ulSendMaxBuf = SASL_MAX_DATA_BUFFER;
    pContext->ulRecvMaxBuf = SASL_MAX_DATA_BUFFER;
    pContext->ContextHandle = (ULONG_PTR)pContext;
    pContext->ExpirationTime = g_TimeForever;        // never expire

    // Now copy over all the info we need from the supplied credential

    pContext->CredentialUseFlags = pCredential->CredentialUseFlags;   // Keep the info on inbound/outbound

    Status = UnicodeStringDuplicate(&(pContext->ustrAccountName), &(pCredential->ustrAccountName));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "ContextInit: Failed to copy Domain into Context\n"));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(&(pContext->ustrDomain), &(pCredential->ustrDomain));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "ContextInit: Failed to copy Domain into Context\n"));
        goto CleanUp;
    }

       // Copy over the Credential Password if known - thread safe - this is encrypted text
    Status = CredHandlerPasswdGet(pCredential, &pContext->ustrPassword);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "ContextInit: CredHandlerPasswdGet error    status 0x%x\n", Status));
        goto CleanUp;
    }

    // Set context flags based on global settings
    if (g_dwParameter_ClientCompat & CLIENTCOMPAT_QQOP)
    {
        pContext->ulFlags |= FLAG_CONTEXT_QUOTE_QOP;
    }

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "ContextInit: Leaving   Status 0x%x\n", Status));
    return Status;

}


// Once done with a context - release the resouces
NTSTATUS NTAPI
ContextFree(
           IN PDIGEST_CONTEXT pContext
           )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT iCnt = 0;

    DebugLog((DEB_TRACE_FUNC, "ContextFree: Entering with Context 0x%x\n", pContext));
    ASSERT(pContext);
    ASSERT(0 == pContext->lReferences);

    if (!pContext)
    {
        return STATUS_INVALID_PARAMETER;
    }

    DebugLog((DEB_TRACE, "ContextFree: Context RefCount %ld\n", pContext->lReferences));

    DebugLog((DEB_TRACE, "ContextFree: Checking TokenHandle for LogonID (%x:%lx)\n",
               pContext->LoginID.HighPart, pContext->LoginID.LowPart));
    if (pContext->TokenHandle)
    {
        DebugLog((DEB_TRACE, "ContextFree: Closing TokenHandle for LogonID (%x:%lx)\n",
                   pContext->LoginID.HighPart, pContext->LoginID.LowPart));
        NtClose(pContext->TokenHandle);
        pContext->TokenHandle = NULL;
    }

    StringFree(&(pContext->strNonce));
    StringFree(&(pContext->strCNonce));
    StringFree(&(pContext->strOpaque));
    StringFree(&(pContext->strSessionKey));
    UnicodeStringFree(&(pContext->ustrDomain));
    UnicodeStringFree(&(pContext->ustrPassword));
    UnicodeStringFree(&(pContext->ustrAccountName));

    StringFree(&(pContext->strResponseAuth));

    for (iCnt = 0; iCnt < MD5_AUTH_LAST; iCnt++)
    {
        StringFree(&(pContext->strDirective[iCnt]));
    }
    
    DigestFreeMemory(pContext);

    DebugLog((DEB_TRACE_FUNC, "ContextFree: Leaving with Context 0x%x\n", pContext));
    return Status;

}



/*++

Routine Description:

    This routine checks to see if the Context is for the specified
    Client Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    ContextHandle - Points to the ContextHandle of the Context
        to be referenced.

    RemoveContext - This boolean value indicates whether the caller
        wants the Context to be removed from the list
        of Contexts.  TRUE indicates the Context is to be removed.
        FALSE indicates the Context is not to be removed.


Return Value:

    NULL - the Context was not found.

    Otherwise - returns a pointer to the referenced Context.

--*/
NTSTATUS NTAPI
CtxtHandlerHandleToContext(
    IN ULONG_PTR ContextHandle,
    IN BOOLEAN RemoveContext,
    OUT PDIGEST_CONTEXT *ppContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CONTEXT Context = NULL;
    LONG lReferences = 0;

    ULONG ListIndex;
    ULONG LockIndex;

    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerHandleToContext: Entering    ContextHandle 0x%lx\n", ContextHandle));

    //
    // Acquire access to the Context list
    //


    ListIndex = HandleToListIndex( ContextHandle );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceShared(&DigestContextLock[LockIndex], TRUE);
    

    //
    // Now walk the list of Contexts looking for a match.
    //

    for ( ListEntry = DigestContextList[ListIndex].Flink;
          ListEntry != &DigestContextList[ListIndex];
          ListEntry = ListEntry->Flink ) {

        Context = CONTAINING_RECORD( ListEntry, DIGEST_CONTEXT, Next );

        //
        // Found a match ... reference this Context
        // (if the Context is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        if ( Context == (PDIGEST_CONTEXT) ContextHandle)
        {
            if (!RemoveContext)
            {
                //
                // Timeout this context if caller is not trying to remove it.
                // We only timeout contexts that are being setup, not
                // fully authenticated contexts.
                //

                if (CtxtHandlerTimeHasElapsed(Context))
                {
                        DebugLog((DEB_ERROR, "CtxtHandlerHandleToContext: Context 0x%lx has timed out.\n",
                                    ContextHandle ));
                        Status = SEC_E_CONTEXT_EXPIRED;
                        goto CleanUp;
                }

                lReferences = InterlockedIncrement(&Context->lReferences);
            }
            else
            {
                RtlConvertSharedToExclusive(&DigestContextLock[LockIndex]);
                RemoveEntryList( &Context->Next );
                
                DebugLog((DEB_TRACE, "CtxtHandlerHandleToContext:Delinked Context 0x%lx\n",Context ));
            }

            DebugLog((DEB_TRACE, "CtxtHandlerHandleToContext: FOUND Context = 0x%x, RemoveContext = %d, ReferenceCount = %ld\n",
                       Context, RemoveContext, Context->lReferences));
            *ppContext = Context;
            goto CleanUp;
        }

    }

    //
    // No match found
    //

    DebugLog((DEB_WARN, "CtxtHandlerHandleToContext: Tried to reference unknown Context 0x%lx\n", ContextHandle ));
    Status =  STATUS_OBJECT_NAME_NOT_FOUND;

CleanUp:

    RtlReleaseResource(&DigestContextLock[LockIndex]);
    
    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerHandleToContext: Leaving\n" ));

    return(Status);
}



/*++

Routine Description:

    This routine checks to see if the LogonId is for the specified
    Server Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    pstrOpaque - Opaque string that uniquely references the SecurityContext


Return Value:

    NULL - the Context was not found.

    Otherwise - returns a pointer to the referenced Context.

--*/
NTSTATUS NTAPI
CtxtHandlerOpaqueToPtr(
    IN PSTRING pstrOpaque,
    OUT PDIGEST_CONTEXT *ppContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CONTEXT Context = NULL;
    LONG rc = 0;
    LONG lReferences = 0;

    ULONG ListIndex;
    ULONG LockIndex = 0;

    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerOpaqueToPtr: Entering    Opaque (%Z)\n", pstrOpaque));

    //
    // Acquire access to the Context list
    //

    for(ListIndex = 0; ListIndex < DIGEST_LIST_COUNT ; ListIndex++)
    {
        LockIndex = ListIndexToLockIndex( ListIndex );

        RtlAcquireResourceShared(&DigestContextLock[LockIndex], TRUE);
        
        //
        // Now walk the list of Contexts looking for a match.
        //
    
        for ( ListEntry = DigestContextList[ListIndex].Flink;
              ListEntry != &DigestContextList[ListIndex];
              ListEntry = ListEntry->Flink ) {
    
            Context = CONTAINING_RECORD( ListEntry, DIGEST_CONTEXT, Next );
    
            //
            // Found a match ... reference this Context
            // (if the Context is being removed, we would increment
            // and then decrement the reference, so don't bother doing
            // either - since they cancel each other out).
            //
    
            rc = RtlCompareString(pstrOpaque, &(Context->strOpaque), FALSE);
            if (!rc)
            {
    
                //
                // Timeout this context if caller is not trying to remove it.
                // We only timeout contexts that are being setup, not
                // fully authenticated contexts.
                //
    
                if (CtxtHandlerTimeHasElapsed(Context))
                {
                    RtlReleaseResource(&DigestContextLock[LockIndex]);
                    DebugLog((DEB_ERROR, "CtxtHandlerOpaqueToPtr: Context 0x%x has timed out.\n",
                                    Context ));
                    Status = SEC_E_CONTEXT_EXPIRED;
                    goto CleanUp;
                }
    
                lReferences = InterlockedIncrement(&Context->lReferences);
    
                RtlReleaseResource(&DigestContextLock[LockIndex]);
                
                DebugLog((DEB_TRACE, "CtxtHandlerOpaqueToPtr: FOUND Context = 0x%x, ReferenceCount = %ld\n",
                           Context, Context->lReferences));
                *ppContext = Context;
                goto CleanUp;
            }
    
        }
    
        RtlReleaseResource(&DigestContextLock[LockIndex]);
    }

    //
    // No match found
    //

    DebugLog((DEB_WARN, "CtxtHandlerOpaqueToPtr: Tried to reference unknown Opaque (%Z)\n", pstrOpaque));
    Status =  STATUS_OBJECT_NAME_NOT_FOUND;

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "CtxtHandlerOpaqueToPtr: Leaving\n" ));

    return(Status);
}



// Check the Creation time with the Current time.
// If the difference is greater than the MAX allowed, Context is no longer valid
BOOL
CtxtHandlerTimeHasElapsed(
    PDIGEST_CONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    return (FALSE);                         // no expiration at this time
}



//+--------------------------------------------------------------------
//
//  Function:   CtxtHandlerRelease
//
//  Synopsis:   Releases the Context by decreasing reference counter
//
//  Arguments:  pContext - pointer to credential to de-reference
//
//  Returns: NTSTATUS
//
//  Notes:  
//
//---------------------------------------------------------------------
NTSTATUS
CtxtHandlerRelease(
    PDIGEST_CONTEXT pContext,
    ULONG ulDereferenceCount)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG lReferences = 0;

    if (ulDereferenceCount == 1)
    {
        lReferences = InterlockedDecrement(&pContext->lReferences);

        DebugLog((DEB_TRACE, "CtxtHandlerRelease: (RefCount)  deref 0x%x  updated references %ld\n",
                   pContext, lReferences));

        ASSERT( lReferences >= 0 );
    }
    else if (ulDereferenceCount > 0)
    {
        //
        // there is no equivalent to InterlockedSubtract.
        // so, turn it into an Add with some signed magic.
        //

        LONG lDecrementToIncrement = 0 - ulDereferenceCount;

        DebugLog((DEB_TRACE, "CtxtHandlerRelease: Dereferencing by %lu count\n", ulDereferenceCount ));

        lReferences = InterlockedExchangeAdd( &pContext->lReferences, lDecrementToIncrement );
        lReferences += lDecrementToIncrement;

        ASSERT( lReferences >= 0 );
    }

    //
    // If the count has dropped to zero, then free all alloced stuff
    //

    if (lReferences == 0)
    {
        DebugLog((DEB_TRACE, "CtxtHandlerRelease: (RefCount)  freed 0x%x\n", pContext));
        Status = ContextFree(pContext);
    }

    return(Status);
}



ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    )
{
    ULONG Number ;
    ULONG Hash;
    ULONG HashFinal;

    Number       = (ULONG)ContextHandle;

    Hash         = Number;
    Hash        += Number >> 8;
    Hash        += Number >> 16;
    Hash        += Number >> 24;

    HashFinal    = Hash;
    HashFinal   += Hash >> 4;

    //
    // insure power of two if not one.
    //

    return ( HashFinal & (DIGEST_LIST_COUNT-1) ) ;
}

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    )
{
    //
    // insure power of two if not one.
    //

    return ( ListIndex & (DigestContextLockCount-1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\cred.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        creds.cxx
//
// Contents:    Credential functions:
//
//
// History:     KDamour  15Mar00   Stolen from NTLM
//
//------------------------------------------------------------------------
#include "global.h"

//
// Crit Sect to protect various globals in this module.
//

RTL_CRITICAL_SECTION l_CredentialCritSect;

LIST_ENTRY l_CredentialList;

// Simple variable to make sure that the package was initialize
BOOL g_bCredentialsInitialized = FALSE;



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerInit
//
//  Synopsis:   Initializes the credential manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInitialize
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the Credential list to be empty.
    //

    Status = RtlInitializeCriticalSection(&l_CredentialCritSect);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "CredHandlerInit: Failed to initialize critsec   0x%x\n", Status));
        goto CleanUp;
    }

    
    InitializeListHead( &l_CredentialList );

    // Simple variable test to make sure all initialized;
    g_bCredentialsInitialized = TRUE;

CleanUp:

    return Status;
}

NTSTATUS
CredHandlerInsertCred(
    IN PDIGEST_CREDENTIAL  pDigestCred
    )
{
    RtlEnterCriticalSection( &l_CredentialCritSect );
    pDigestCred->Unlinked = FALSE;
    InsertHeadList( &l_CredentialList, &pDigestCred->Next );
    RtlLeaveCriticalSection( &l_CredentialCritSect );

    return STATUS_SUCCESS;
}


// Initialize the Credential Structure
NTSTATUS
CredentialInit(
    IN PDIGEST_CREDENTIAL pDigestCred)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ASSERT(pDigestCred);

    if (!pDigestCred)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pDigestCred, sizeof(DIGEST_CREDENTIAL));
    pDigestCred->Unlinked = TRUE;
    pDigestCred->CredentialHandle = (ULONG_PTR)pDigestCred;
    pDigestCred->lReferences = 0;

    return(Status);
}


// Free up memory utilized by Credential the Credential Structure
NTSTATUS
CredentialFree(
    IN PDIGEST_CREDENTIAL pDigestCred)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ASSERT(pDigestCred);
    ASSERT(0 == pDigestCred->lReferences);

    UnicodeStringFree(&(pDigestCred->ustrAccountName));
    UnicodeStringFree(&(pDigestCred->ustrDomainName));

    // Erase any password information
    if (((pDigestCred->ustrPassword).MaximumLength) &&
        ((pDigestCred->ustrPassword).Buffer))
    {
        SecureZeroMemory((pDigestCred->ustrPassword).Buffer, (pDigestCred->ustrPassword).MaximumLength);
    }
    UnicodeStringFree(&(pDigestCred->ustrPassword));
    UnicodeStringFree(&(pDigestCred->ustrDomain));
    UnicodeStringFree(&(pDigestCred->ustrUpn));

    DigestFreeMemory(pDigestCred);

    return(Status);
}



/*++

Routine Description:

    This routine checks to see if the Credential Handle is from a currently
    active client, and references the Credential if it is valid.

    The caller can request that the Credential be dereferenced only.

    For a client's Credential to be valid, the Credential value
    must be on our list of active Credentials.


Arguments:

    CredentialHandle - Points to the CredentialHandle of the Credential
        to be referenced.

    DereferenceCredential - This boolean value indicates whether the caller
        wants the logon process's Credential to be referenced (FALSE) or
        decremented (TRUE)
        

Return Value:

    NULL - the Credential was not found.

    Otherwise - returns a pointer to the referenced credential.

--*/

NTSTATUS
CredHandlerHandleToPtr(
                      IN ULONG_PTR CredentialHandle,
                      IN BOOLEAN DereferenceCredential,
                      OUT PDIGEST_CREDENTIAL * UserCredential
                      )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CREDENTIAL Credential = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_CALL_INFO CallInfo;

    // LONG lDereferenceCount = 1;
    ULONG ulDereferenceCount = 1;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CredHandlerHandleToPtr: Entering   Credential 0x%x\n", CredentialHandle));

      // set default output
    ASSERT(UserCredential);
    *UserCredential = NULL ;


    ZeroMemory( &CallInfo, sizeof(CallInfo) );
    ZeroMemory( &ClientInfo, sizeof(ClientInfo) );


    if(g_LsaFunctions->GetCallInfo(&CallInfo))
    {
        ulDereferenceCount = CallInfo.CallCount;
        DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: CallCount  0x%x\n", CallInfo.CallCount));
        DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Attributes  0x%x\n", CallInfo.Attributes));
        DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: PID %d  Thread %d\n", CallInfo.ProcessId, CallInfo.ThreadId));
    }
    else
    {
        ZeroMemory( &CallInfo, sizeof(CallInfo) );
    }

    Status = g_LsaFunctions->GetClientInfo(&ClientInfo);

    if(!NT_SUCCESS(Status))
    {
        //
        // this call can fail during a cleanup call.  so ignore that for now,
        // and check for cleanup disposition.
        //

        if ((CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0)
        {
            Status = STATUS_SUCCESS;
            RtlZeroMemory(
                &ClientInfo,
                sizeof(SECPKG_CLIENT_INFO)
                );
            ClientInfo.HasTcbPrivilege = TRUE;
            ClientInfo.ProcessID = CallInfo.ProcessId;
        }

        if( !NT_SUCCESS( Status ) )
        {
            DebugLog(( DEB_ERROR, "CredHandlerHandleToPtr: GetClientInfo returned 0x%lx\n", Status));
            return( Status );
        }
    }

    if( CallInfo.Attributes & SECPKG_CALL_CLEANUP )
    {
        DebugLog(( DEB_TRACE, "CredHandlerHandleToPtr: Cleanup Called    pid: 0x%lx handle: %p refcount: %lu\n",
                    ClientInfo.ProcessID, CredentialHandle, ulDereferenceCount));
    }

    //
    // Acquire exclusive access to the Credential list
    //

    RtlEnterCriticalSection( &l_CredentialCritSect );


    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = l_CredentialList.Flink;
        ListEntry != &l_CredentialList;
        ListEntry = ListEntry->Flink )
    {

        Credential = CONTAINING_RECORD( ListEntry, DIGEST_CREDENTIAL, Next );


        //
        // Found a match ... reference this Credential
        // (if the Credential is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        if (( Credential == (PDIGEST_CREDENTIAL) CredentialHandle))
        {

            // Make sure we have the privilege of accessing
            // this handle

            if (!ClientInfo.HasTcbPrivilege &&
               (Credential->ClientProcessID != ClientInfo.ProcessID)
               )
            {
                DebugLog((DEB_ERROR, "CredHandlerHandleToPtr: ProcessIDs are different. Access forbidden.\n"));
                break;
            }

            if (!DereferenceCredential)
            {
                lReferences = InterlockedIncrement(&Credential->lReferences);

                DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Incremented   ReferenceCount %ld\n", lReferences));
            }
            else
            {
                DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Dereferencing credential\n" ));

                ASSERT((ulDereferenceCount > 0));

                // Note: Subtract one off of the deref count, this avoids an extra interlock operation
                //    After exit, SpFreeCredentialsHandle will call CredHandlerRelease


                ulDereferenceCount--;

                if( ulDereferenceCount == 1 )
                {
                    DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Dereferencing by one count\n" ));
                    lReferences = InterlockedDecrement( &Credential->lReferences );

                    ASSERT( (lReferences > 0) );

                }
                else if( ulDereferenceCount > 1 )
                {

                    //
                    // there is no equivalent to InterlockedSubtract.
                    // so, turn it into an Add with some signed magic.
                    //

                    LONG lDecrementToIncrement = 0 - ulDereferenceCount;

                    DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Dereferencing by %lu count\n", ulDereferenceCount ));

                    lReferences = InterlockedExchangeAdd( &Credential->lReferences, lDecrementToIncrement );
                    lReferences += lDecrementToIncrement;

                    ASSERT( (lReferences > 0) );
                }
            }

            // Found the Credential
            *UserCredential = Credential ;
            goto CleanUp;

        }
    }


    //
    // No match found
    //
    DebugLog((DEB_WARN, "CredHandlerHandleToCredential: Tried to reference unknown Credential 0x%lx\n",
              CredentialHandle ));

    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_CredentialCritSect );

    DebugLog((DEB_TRACE_FUNC, "CredHandlerHandleToPtr: Leaving   Credential 0x%x\n", CredentialHandle));

    return(Status);
}


// Locate a Credential based on a LogonId, ProcessID
// For either the Logon list or the Credential list

NTSTATUS
CredHandlerLocatePtr(
                    IN PLUID pLogonId,
                    IN ULONG   CredentialUseFlags,
                    OUT PDIGEST_CREDENTIAL * UserCredential
                    )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_CREDENTIAL Credential = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    // SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_CALL_INFO CallInfo;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CredHandlerLocatePtr: Entering\n"));

    *UserCredential = NULL ;

    // If we do not have a LogonId
    if (!pLogonId)
    {
        return(STATUS_INVALID_HANDLE);
    }

    //
    // Match both flags
    //

    // CredentialUseFlags |= CredentialFlags;

    if (!g_LsaFunctions->GetCallInfo(&CallInfo))
    {
        DebugLog((DEB_ERROR,"CredHandlerLocatePtr: Failed to get call info\n"));
        return(STATUS_INVALID_HANDLE);    // Really this is another error
    }


    //
    // Acquire exclusive access to the Credential list
    //

    RtlEnterCriticalSection( &l_CredentialCritSect );


    //
    // Now walk the list of Credentials looking for a match.
    //

    for ( ListEntry = l_CredentialList.Flink;
        ListEntry != &l_CredentialList;
        ListEntry = ListEntry->Flink )
    {

        Credential = CONTAINING_RECORD( ListEntry, DIGEST_CREDENTIAL, Next );


        //
        // Found a match ... reference this Credential
        // (if the Credential is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        // If this is a session credential then check for appropriate flags (like inbound or outbound)
        if ((Credential->CredentialUseFlags & DIGEST_CRED_MATCH_FLAGS) != CredentialUseFlags)
        {
            continue;
        }

        if (RtlEqualLuid(&(Credential->LogonId), pLogonId) &&
            (Credential->ClientProcessID == CallInfo.ProcessId))
        {
            lReferences = InterlockedIncrement(&Credential->lReferences);

            DebugLog((DEB_TRACE, "CredHandlerLocatePtr: ReferenceCount %ld\n", lReferences));

            // Found the Credential
            *UserCredential = Credential ;

            goto CleanUp;

        }

    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "CredHandlerLocatePtr: Tried to reference unknown LogonId (%x:%lx)\n",
               pLogonId->HighPart, pLogonId->LowPart ));
    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_CredentialCritSect );


    DebugLog((DEB_TRACE_FUNC, "CredHandlerLocatePtr: Leaving     Status 0x%x\n", Status));
    return(Status);

}



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerRelease
//
//  Synopsis:   Releases the Credential by decreasing reference counter
//    if Credential reference count drops to zero, Credential is deleted
//
//  Arguments:  pCredential - pointer to credential to de-reference
//
//  Returns: NTSTATUS
//
//  Notes: Called by ASC. Since multiple threads can have a credential
//   checked out, simply decrease the reference counter on release.
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerRelease(
    PDIGEST_CREDENTIAL pCredential)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "CredHandlerRelease: Entering for  Credential 0x%0x\n", pCredential));

    lReferences = InterlockedDecrement(&pCredential->lReferences);

    DebugLog((DEB_TRACE, "CredHandlerRelease: ReferenceCount %ld\n", lReferences));

    ASSERT( lReferences >= 0 );

    //
    // If the count has dropped to zero, then free all alloced stuff
    // Care must be taken since Cred is still in linked list - need to grab critsec
    // and then test again if zero since another thread might have taken a ref to cred
    //

    if (lReferences == 0)
    {
        RtlEnterCriticalSection( &l_CredentialCritSect );

        // Check to make sure no one took a reference since InterlockDecrement
        if (pCredential->lReferences)
        {
            DebugLog((DEB_TRACE, "CredHandlerRelease: Another thread took a reference. No action taken\n"));
        }
        else
        {
            // Safe to remove from list and delete
            // Check if added into linked list
            if (!pCredential->Unlinked)
            {
                RemoveEntryList( &pCredential->Next );
                DebugLog((DEB_TRACE, "CredHandlerRelease: Unlinked Credential 0x%x\n", pCredential));
            }

            DebugLog((DEB_TRACE, "CredHandlerRelease: Deleting Credential 0x%x\n", pCredential));
            Status = CredentialFree(pCredential);
        }

        RtlLeaveCriticalSection( &l_CredentialCritSect );
    }

    DebugLog((DEB_TRACE_FUNC, "CredHandlerRelease: Leaving  Status 0x%x\n", Status));

    return(Status);
}


// Helper functions for processing fields within the credentials



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerPasswdSet
//
//  Synopsis:   Set the unicode string password in the credential
//
//  Arguments:  pCredential - pointer to credential to use
//              pustrPasswd - pointer to new password
//
//  Returns: NTSTATUS
//
//  Notes:  might want to use record locking in the future instead
//      of an update flag on credentials
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerPasswdSet(
    IN OUT PDIGEST_CREDENTIAL pCredential,
    IN PUNICODE_STRING pustrPasswd)
{
    NTSTATUS Status = STATUS_SUCCESS;

           // Protect writing the info into the credential
    RtlEnterCriticalSection( &l_CredentialCritSect );
    if (pCredential->ustrPassword.Buffer)
    {
        SecureZeroMemory((pCredential->ustrPassword).Buffer, (pCredential->ustrPassword).MaximumLength);
        UnicodeStringFree(&(pCredential->ustrPassword));
    }
    Status = UnicodeStringDuplicatePassword(&(pCredential->ustrPassword),pustrPasswd);
    RtlLeaveCriticalSection( &l_CredentialCritSect );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "CredHandlerPasswdSet: Error in setting Credential password, status 0x%0x\n", Status ));
    }

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   CredHandlerPasswdGet
//
//  Synopsis:   Get the unicode string password in the credential
//              Locking is only necessary for the logon creds and not the session creds
//              but it is just as well to keep it unifom
//
//  Arguments:  pCredential - pointer to credential to use
//              pustrPasswd - pointer to destination copy of password
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS
CredHandlerPasswdGet(
    IN PDIGEST_CREDENTIAL pCredential,
    OUT PUNICODE_STRING pustrPasswd)
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Protect reading/writing the credential password
    RtlEnterCriticalSection( &l_CredentialCritSect );
    if (pustrPasswd->Buffer)
    {
        SecureZeroMemory(pustrPasswd->Buffer, pustrPasswd->MaximumLength);
        UnicodeStringFree(pustrPasswd);
    }
    Status = UnicodeStringDuplicatePassword(pustrPasswd, &(pCredential->ustrPassword));
    RtlLeaveCriticalSection( &l_CredentialCritSect );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "CredHandlerPasswdSet: Error in setting Credential password, status 0x%0x\n", Status ));
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\cred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        cred.h
//
// Contents:    declarations, constants for credential manager
//
//
// History:     KDamour  15Mar00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_CRED_H
#define NTDIGEST_CRED_H      

#define SSP_TOKEN_ACCESS (READ_CONTROL              |\
                          WRITE_DAC                 |\
                          TOKEN_DUPLICATE           |\
                          TOKEN_IMPERSONATE         |\
                          TOKEN_QUERY               |\
                          TOKEN_QUERY_SOURCE        |\
                          TOKEN_ADJUST_PRIVILEGES   |\
                          TOKEN_ADJUST_GROUPS       |\
                          TOKEN_ADJUST_DEFAULT)

//  Supplimental Credential format (provide a specified username, realm, password)
//  to

// Initializes the credential manager package
NTSTATUS CredHandlerInit(VOID);

// Inserts a credential into the linked list
NTSTATUS CredHandlerInsertCred(IN PDIGEST_CREDENTIAL  pDigestCred);

// Initialize the Credential Structure
NTSTATUS CredentialInit(IN PDIGEST_CREDENTIAL pDigestCred);

// Initialize the Credential Structure
NTSTATUS CredentialFree(IN PDIGEST_CREDENTIAL pDigestCred);

//    This routine checks to see if the Credential Handle is from a currently
//    active client, and references the Credential if it is valid.
//    No need to specify UseFlags since we have a reference to the Credential
NTSTATUS CredHandlerHandleToPtr(
       IN ULONG_PTR CredentialHandle,
       IN BOOLEAN DereferenceCredential,
       OUT PDIGEST_CREDENTIAL * UserCredential);

// Locate a Credential based on the LogonId & ProcessID
NTSTATUS CredHandlerLocatePtr(
       IN PLUID pLogonId,
       IN ULONG   CredentialUseFlags,
       OUT PDIGEST_CREDENTIAL * UserCredential);

//  Releases the Credential by decreasing reference counter
NTSTATUS CredHandlerRelease(PDIGEST_CREDENTIAL pCredential);

// Set the unicode string password in the credential
NTSTATUS CredHandlerPasswdSet(
    IN OUT PDIGEST_CREDENTIAL pCredential,
    IN PUNICODE_STRING pustrPasswd);

// Get the unicode string password in the credential
NTSTATUS CredHandlerPasswdGet(
    IN PDIGEST_CREDENTIAL pCredential,
    OUT PUNICODE_STRING pustrPasswd);

NTSTATUS SspGetToken (OUT PHANDLE ReturnedTokenHandle);

SECURITY_STATUS SspDuplicateToken(
    IN HANDLE OriginalToken,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicatedToken);

// Print out the credential information
NTSTATUS CredPrint(PDIGEST_CREDENTIAL pCredential);

// Extract the authz information from supplied buffer
NTSTATUS CredAuthzData(
    IN PVOID pAuthorizationData,
    IN PSECPKG_CALL_INFO pCallInfo,
    IN OUT PULONG NewCredentialUseFlags,
    IN OUT PUNICODE_STRING pUserName,
    IN OUT PUNICODE_STRING pDomainName,
    IN OUT PUNICODE_STRING pPassword);

#endif // NTDIGEST_CRED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\auth.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        auth.h
//
// Contents:    include file for auth.cxx for NTDigest
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_AUTH_H
#define NTDIGEST_AUTH_H

// #include "nonce.h"

#if SECURITY_KERNEL
extern "C"
{
// #include <rc4.h>    // How to use RC4 routine
#include <md5.h>       // For md5init(), md5update(), md5final()
// #include <hmac.h>
}
#endif    // SECURITY_KERNEL

#define MD5_HASH_BYTESIZE 16                             // MD5 hash size
#define MD5_HASH_HEX_SIZE (2*MD5_HASH_BYTESIZE)     // BYTES needed to store a Hash as hex Encoded

// Contains all of the pointers and lengths for directives used in
// calculating the digest access values.  Usually the
// parameters point to an external buffer, pHTTPBuffer

enum DIGEST_TYPE
{
    DIGEST_UNDEFINED,           // Initial state
    NO_DIGEST_SPECIFIED,
    DIGEST_CLIENT,
    DIGEST_SERVER,
    SASL_SERVER,
    SASL_CLIENT
};

enum QOP_TYPE
{
    QOP_UNDEFINED,          // Initial state
    NO_QOP_SPECIFIED,
    AUTH,
    AUTH_INT,
    AUTH_CONF
};
typedef QOP_TYPE *PQOP_TYPE;

enum ALGORITHM_TYPE
{
    ALGORITHM_UNDEFINED,            // Initial state
    NO_ALGORITHM_SPECIFIED,
    MD5,
    MD5_SESS
};

enum CHARSET_TYPE
{
    CHARSET_UNDEFINED,            // Initial state
    ISO_8859_1,
    UTF_8,                        // UTF-8 encoding
    UTF_8_SUBSET                  // ISO_8859_1 subset in UTF-8
};

enum CIPHER_TYPE
{
    CIPHER_UNDEFINED,
    CIPHER_3DES,
    CIPHER_DES,                      // 56bit key
    CIPHER_RC4_40,
    CIPHER_RC4,                      // 128bit key
    CIPHER_RC4_56
};

enum DIGESTMODE_TYPE
{
    DIGESTMODE_UNDEFINED,
    DIGESTMODE_HTTP,
    DIGESTMODE_SASL
};

enum NAMEFORMAT_TYPE
{
    NAMEFORMAT_UNKNOWN,
    NAMEFORMAT_ACCOUNTNAME,
    NAMEFORMAT_UPN,
    NAMEFORMAT_NETBIOS
};

// For list of supported protocols
// Pack supported cyphers into a WORD (2 bytes)
#define SUPPORT_3DES    0x0001
#define SUPPORT_DES     0x0002
#define SUPPORT_RC4_40  0x0004
#define SUPPORT_RC4     0x0008
#define SUPPORT_RC4_56  0x0010

// Strings for the challenge and challengeResponse

#define STR_CIPHER_3DES    "3des"
#define STR_CIPHER_DES     "des"
#define STR_CIPHER_RC4_40  "rc4-40"
#define STR_CIPHER_RC4     "rc4"
#define STR_CIPHER_RC4_56  "rc4-56"

#define WSTR_CIPHER_HMAC_MD5    L"HMAC_MD5"
#define WSTR_CIPHER_RC4         L"RC4"
#define WSTR_CIPHER_DES         L"DES"
#define WSTR_CIPHER_3DES        L"3DES"
#define WSTR_CIPHER_MD5         L"MD5"

// Default string for realm directives in challenges
#define STR_DIGEST_DOMAIN      "Digest"
#define WSTR_DIGEST_DOMAIN     L"Digest"


typedef enum _eSignSealOp {
    eSign,      // MakeSignature is calling
    eVerify,    // VerifySignature is calling
    eSeal,      // SealMessage is calling
    eUnseal     // UnsealMessage is calling
} eSignSealOp;



// Supplimental credentals stored in the DC (pre-calculated Digest Hashes
#define SUPPCREDS_VERSION 1
#define NUMPRECALC_HEADERS  29
#define TOTALPRECALC_HEADERS (NUMPRECALC_HEADERS + 1)

//  Supp Creds format     '1' 0 version numhashes 0 0 0 0 0 0 0 0 0 0 0 0
#define SUPPCREDS_VERSIONLOC 2
#define SUPPCREDS_CNTLOC     3

// Format in supplimental credentials  U UPPER()   D LOWER()    n normal passed in value
#define NAME_HEADER            0
#define NAME_ACCT              1
#define NAME_ACCT_DOWNCASE     2
#define NAME_ACCT_UPCASE       3
#define NAME_ACCT_DUCASE       4
#define NAME_ACCT_UDCASE       5
#define NAME_ACCT_NUCASE       6
#define NAME_ACCT_NDCASE       7
#define NAME_ACCTDNS              8
#define NAME_ACCTDNS_DOWNCASE     9
#define NAME_ACCTDNS_UPCASE       10
#define NAME_ACCTDNS_DUCASE       11
#define NAME_ACCTDNS_UDCASE       12
#define NAME_ACCTDNS_NUCASE       13
#define NAME_ACCTDNS_NDCASE       14
#define NAME_UPN               15
#define NAME_UPN_DOWNCASE      16
#define NAME_UPN_UPCASE        17
#define NAME_NT4               18
#define NAME_NT4_DOWNCASE      19
#define NAME_NT4_UPCASE        20

// Fixed realm to STR_DIGEST_DOMAIN
#define NAME_ACCT_FREALM              21
#define NAME_ACCT_FREALM_DOWNCASE     22
#define NAME_ACCT_FREALM_UPCASE       23
#define NAME_UPN_FREALM               24
#define NAME_UPN_FREALM_DOWNCASE      25
#define NAME_UPN_FREALM_UPCASE        26
#define NAME_NT4_FREALM               27
#define NAME_NT4_FREALM_DOWNCASE      28
#define NAME_NT4_FREALM_UPCASE        29
//
// value names used by MD5 authentication.
//

enum MD5_AUTH_NAME
{
    MD5_AUTH_USERNAME = 0,
    MD5_AUTH_REALM,
    MD5_AUTH_NONCE,
    MD5_AUTH_CNONCE,
    MD5_AUTH_NC,
    MD5_AUTH_ALGORITHM,
    MD5_AUTH_QOP,
    MD5_AUTH_METHOD,
    MD5_AUTH_URI,
    MD5_AUTH_RESPONSE,
    MD5_AUTH_HENTITY,
    MD5_AUTH_AUTHZID,           // for SASL
            // Above this list are Marshalled to DC as BlobData
    MD5_AUTH_DOMAIN,
    MD5_AUTH_STALE,
    MD5_AUTH_OPAQUE,
    MD5_AUTH_MAXBUF,
    MD5_AUTH_CHARSET,
    MD5_AUTH_CIPHER,
    MD5_AUTH_DIGESTURI,          // for SASL mapped to MD5_AUTH_URI
    MD5_AUTH_RSPAUTH,           // verify server has auth data
    MD5_AUTH_NEXTNONCE,
    MD5_AUTH_LAST
};


// Structure to pass around that contains the parameters for the Digest Calculation
typedef struct _DIGEST_PARAMETER
{
    DIGEST_TYPE typeDigest;
    USHORT usFlags;                              // Flags defined in DIGEST_BLOB_REQUEST
    ALGORITHM_TYPE typeAlgorithm;
    QOP_TYPE typeQOP;
    CIPHER_TYPE typeCipher;
    CHARSET_TYPE typeCharset;
    STRING refstrParam[MD5_AUTH_LAST];         // referenced - points to non-owned memory- do not free up these Strings
    USHORT usDirectiveCnt[MD5_AUTH_LAST];      // count of the number of times directive is utilized
    UNICODE_STRING ustrRealm;                  // extracted from the digest auth directive values
    UNICODE_STRING ustrUsername;               // extracted from the digest auth directive values

    // Info extracted from Username & Realm - used for auditing and open SAM useraccount
    NAMEFORMAT_TYPE  typeName;                 
    UNICODE_STRING ustrCrackedAccountName;     // SAMAccount name from extracted from ustrUsername & ustrRealm
    UNICODE_STRING ustrCrackedDomain;          // Domain from ustrUsername & ustrRealm

    UNICODE_STRING ustrWorkstation;           // Name of workstation/server making Digest request

    STRING  strUsernameEncoded;                // contains a copy of the encoded string used in challengeresponse
    STRING  strRealmEncoded;                   // contains a copy of the realm

    STRING  strDirective[MD5_AUTH_LAST];       // NULL terminated strings that contain directive values

    STRING  strSessionKey;                   // String for Sessionkey (points to chSessionKey)

        // STRINGS Alloced by DigestInit and Freed by DigestFree
    STRING strResponse;                     // String for the BinHex Hashed Response


    // Trust information for this request
    ULONG ulTrustDirection;
    ULONG ulTrustType;
    ULONG ulTrustAttributes;
    PSID  pTrustSid;
    UNICODE_STRING  ustrTrustedForest;

} DIGEST_PARAMETER, *PDIGEST_PARAMETER;

// Structure to extract MD5 hashes and passwords for user accounts
typedef struct _USER_CREDENTIALS
{
    UNICODE_STRING ustrUsername;                // username value to use in H(Username:realm:password) calc
    UNICODE_STRING ustrRealm;                   // realm value to use in H(username:realm:password)

    // The following fields might be filled in
    // Will check any precalculated hashes first and then try the password if available
    BOOL           fIsValidPasswd;                 // set true if password is valid
    BOOL           fIsValidDigestHash;             // set true if hash is valid
    BOOL           fIsEncryptedPasswd;             // set to TRUE is passwd encrypted
    SHORT          wHashSelected;                  // if hash valid, index to process
    SHORT          sHashTags[TOTALPRECALC_HEADERS];  // indicate which hashes match username format
    UNICODE_STRING ustrPasswd;
    STRING         strDigestHash;
    USHORT         usDigestHashCnt;                 // number of pre-calc hashes in credential

} USER_CREDENTIALS, *PUSER_CREDENTIALS;


//     Data to use GenericPassthrough to send to the DC for processing
//  The server will create the data, BlobData, and it will be wraped for
//  transport over GenericPassthrough to the DC.  The DC will be presented
//  with only the BlobData to process
//  ALL directive-values have a NULL terminator attached to each directive
//  ALL directive-values are UNQUOTED   unq("X") -> X
//  cbBlobSize has number of bytes to hold header and the string data
//  cbCharValues has number of bytes to hold string data
//  This way future revs can Version++, increase cbBlobSize, and append to message
//
//  Data Format
//
//       USHORT                 Version
//       USHORT                 cbBlobSize
//       USHORT                 DIGEST_TYPE
//       USHORT                 cbCharValues
//
//       CHAR[cbUserName+1]     unq(username-value)
//       CHAR[cbRealm+1]        unq(realm-value)    
//       CHAR[cbNonce+1]        unq(nonce-value)    
//       CHAR[cbCnonce+1]       unq(cnonce-value)    
//       CHAR[cbNC+1]           unq(nc-value)    
//       CHAR[cbAlgorithm+1]           unq(algorithm-value)    
//       CHAR[cbQOP+1]          unq(qop-value)    
//       CHAR[cbMethod+1]       Method    
//       CHAR[cbURI+1]            unq(digest-uri-value)
//       CHAR[cbReqDigest+1]     unq(request-digest)
//       CHAR[cbHEntity+1]      unq(H(entity-body))   * maybe NULL only for qop="auth"
//       CHAR[cbAuthzId+1]     unq(AuthzId-value)
//
//
#define DIGEST_BLOB_VERSION     1
#define DIGEST_BLOB_VALUES        12              // How many field-values are sent over

// Values for separators detweent field-values
#define COLONSTR ":"
#define COLONSTR_LEN 1

#define AUTHSTR "auth"
#define AUTHSTR_LEN 4

#define AUTHINTSTR "auth-int"
#define AUTHINTSTR_LEN 8

#define AUTHCONFSTR "auth-conf"
#define AUTHCONFSTR_LEN 9
#define MAX_AUTH_LENGTH AUTHCONFSTR_LEN

#define MD5STR "MD5"

#define MD5_SESSSTR "MD5-sess"
#define MD5_SESS_SASLSTR "md5-sess"
#define MD5_UTF8STR "utf-8"

#define URI_STR "uri"
#define DIGESTURI_STR "digest-uri"

// SASL paramters
#define AUTHENTICATESTR "AUTHENTICATE"

#define ZERO32STR "00000000000000000000000000000000"

#define SASL_C2S_SIGN_KEY "Digest session key to client-to-server signing key magic constant"
#define SASL_S2C_SIGN_KEY "Digest session key to server-to-client signing key magic constant"

#define SASL_C2S_SEAL_KEY "Digest H(A1) to client-to-server sealing key magic constant"
#define SASL_S2C_SEAL_KEY "Digest H(A1) to server-to-client sealing key magic constant"


// number of bytes to hold ChallengeResponse directives and symbols (actual count is 107) round up for padding
// 14 for charset
#define CB_CHALRESP 375
#define CB_CHAL     400

// Number of characters in the NonceCount (hex digits)
#define NCNUM             8

#define NCFIRST    "00000001"

// Flags used in DIGEST_PARAMETER usFlags and in Digest_blob_request
#define FLAG_CRACKNAME_ON_DC    0x00000001     // Name in Username & Realm needs to be processed on DC
#define FLAG_AUTHZID_PROVIDED   0x00000002
#define FLAG_SERVERS_DOMAIN     0x00000004     // Indicate on Server's DC (first hop from server) so expand group membership
#define FLAG_NOBS_DECODE        0x00000008     // if set to one, the wire communication is done without backslash encoding
#define FLAG_BS_ENCODE_CLIENT_BROKEN   0x00000010     // set to TRUE if backslash encoding is possibly boken on client
#define FLAG_QUOTE_QOP          0x00000020     // set according to the context if quote the QOP - client side only

// For Context Flags
#define FLAG_CONTEXT_AUTHZID_PROVIDED    0x00000002
#define FLAG_CONTEXT_QUOTE_QOP           0x00000004     //  for compat quote the QOP directive on ChallengeResponse 
#define FLAG_CONTEXT_NOBS_DECODE         0x00000008     //  if set to one, the wire communication is done without backslash encoding
#define FLAG_CONTEXT_PARTIAL             0x00000010     // set if context is only partial - not valid for auth processing
#define FLAG_CONTEXT_REFCOUNT            0x00000020     // a securitycontext handle was issued by ASC/ISC - ref count app count
#define FLAG_CONTEXT_SERVER              0x00000040     // context was created in ASC server side if set, otherwise in ISC client


// Overlay header for getting values in Generic Passthrough request
typedef struct _DIGEST_BLOB_REQUEST
{
    ULONG       MessageType;
    USHORT      version;
    USHORT      cbBlobSize;
    USHORT      digest_type;
    USHORT      qop_type;
    USHORT      alg_type;
    USHORT      charset_type;
    USHORT      cbCharValues;
    USHORT      name_format;
    USHORT      usFlags;
    USHORT      cbAccountName;
    USHORT      cbCrackedDomain;
    USHORT      cbWorkstation;
    USHORT      ulReserved3;
    ULONG64     pad1;
    char        cCharValues;    // dummy char to mark start of field-values
} DIGEST_BLOB_REQUEST, *PDIGEST_BLOB_REQUEST;

// Supported MesageTypes
#define VERIFY_DIGEST_MESSAGE          0x1a                 // No specific value is needed
#define VERIFY_DIGEST_MESSAGE_RESPONSE 0x0a                 // No specific value is needed

// The response for the GenericPassthrough call is the status of the Digest Authentication
// Note: This is a fixed length response header - Authdata length not static
// Format for data sent back
//      DIGEST_BLOB_RESPONSE AuthData UnicodeStringAccountName
typedef struct _DIGEST_BLOB_RESPONSE
{
    ULONG       MessageType;
    USHORT      version;
    NTSTATUS    Status;             // Information on Success of Digest Auth
    USHORT      SessionKeyMaxLength;
    ULONG       ulAuthDataSize;
    USHORT      usAcctNameSize;    // size of the NetBIOS name (after AuthData)
    USHORT      ulReserved1;
    ULONG       ulBlobSize;        // size of entire blob sent as response
    ULONG       ulReserved3;
    char        SessionKey[MD5_HASH_HEX_SIZE + 1];
    ULONG64     pad1;
    char        cAuthData;                  // Start of AuthData opaque data
    // Place group info here for LogonUser
} DIGEST_BLOB_RESPONSE, *PDIGEST_BLOB_RESPONSE;

// SASL MAC block
//      Total of 16 bytes per rfc2831 sect 2.3
//            first 10 bytes of HMAC-MD5 [ RFC 2104]
//            2-byte message type number fixed to value 1  (0x0001)
//            4-byte sequence number
// NOTE:  This is using WORD as a 2 byte value and DWORD as a 4 byte value!
#define HMAC_MD5_HASH_BYTESIZE 16                         // MHAC-MD5 hash size per RFC 2104
#define SASL_MAC_HMAC_SIZE 10
#define SASL_MAC_MSG_SIZE  2
#define SASL_MAC_SEQ_SIZE 4
typedef struct _SASL_MAC_BLOCK
{
    UCHAR      hmacMD5[SASL_MAC_HMAC_SIZE];
    WORD       wMsgType;
    DWORD      dwSeqNumber;
} SASL_MAC_BLOCK, *PSASL_MAC_BLOCK;


    // The SASL MAC Block is 16 bytes: RFC 2831 sect 2.4
#define MAC_BLOCK_SIZE   sizeof(SASL_MAC_BLOCK)

#define MAX_PADDING  8         // max padding is currently 8 for DES



// Perform Digest Access Calculation
NTSTATUS NTAPI DigestCalculation(IN PDIGEST_PARAMETER pDigest, IN PUSER_CREDENTIALS pUserCreds);

// Simple checks for enough data for Digest calculation
NTSTATUS NTAPI DigestIsValid(IN PDIGEST_PARAMETER pDigest);

// Initialize the DIGEST_PARAMETER structure
NTSTATUS NTAPI DigestInit(IN PDIGEST_PARAMETER pDigest);

// Clear out the digest & free memory from Digest struct
NTSTATUS NTAPI DigestFree(IN PDIGEST_PARAMETER pDigest);

// Perform Digest Access Calculation for ChallengeResponse
NTSTATUS NTAPI DigestCalcChalRsp(IN PDIGEST_PARAMETER pDigest,
                                 IN PUSER_CREDENTIALS pUserCreds,
                                 BOOL bIsChallenge);

NTSTATUS PrecalcDigestHash(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    OUT PCHAR pHexHash,
    IN OUT PUSHORT piHashSize);

NTSTATUS PrecalcForms(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    IN BOOL fFixedRealm,
    OUT PCHAR pHexHash,
    IN OUT PUSHORT piHashSize);


// Creates the Output SecBuffer for the Challenge Response
NTSTATUS NTAPI DigestCreateChalResp(IN PDIGEST_PARAMETER pDigest, 
                                    IN PUSER_CREDENTIALS pUserCreds,
                                    OUT PSecBuffer OutBuffer);

// Parse input string into Parameter section of Digest
NTSTATUS DigestParser2(PSecBuffer pInputBuf, PSTR *pNameTable,UINT cNameTable, PDIGEST_PARAMETER pDigest);

// Hash and Encode upto 7 STRINGS SOut = Hex(H(S1 ":" S2 ... ":" S7))
NTSTATUS NTAPI DigestHash7(IN PSTRING pS1, IN PSTRING pS2, IN PSTRING pS3,
           IN PSTRING pS4, IN PSTRING pS5, IN PSTRING pS6, IN PSTRING pS7,
           IN BOOL fHexOut,
           OUT PSTRING pSOut);


// Formatted printout of Digest Parameters
NTSTATUS DigestPrint(PDIGEST_PARAMETER pDigest);

#ifndef SECURITY_KERNEL

// Processed parsed digest auth message and fill in string values
NTSTATUS NTAPI DigestDecodeDirectiveStrings(IN OUT PDIGEST_PARAMETER pDigest);

// Determine H(A1) for Digest Access
NTSTATUS NTAPI DigestCalcHA1(IN PDIGEST_PARAMETER pDigest, PUSER_CREDENTIALS pUserCreds);

// Encode the Digest Access Parameters fields into a BYTE Buffer
NTSTATUS NTAPI BlobEncodeRequest(IN PDIGEST_PARAMETER pDigest, OUT BYTE **ppBuffer, OUT USHORT *cbBuffer);

// Decode the Digest Access Parameters fields from a BYTE Buffer
NTSTATUS NTAPI BlobDecodeRequest(IN USHORT cbMessageRequest,
                                 IN BYTE *pBuffer,
                                 PDIGEST_PARAMETER pDigest);

// Free BYTE Buffer from BlobEncodeRequest
VOID NTAPI BlobFreeRequest(BYTE *pBuffer);

#endif  // SECURITY_KERNEL

#endif  // NTDIGEST_AUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2000
//
// File:        credapi.cxx
//
// Contents:    Code for credentials APIs for the NtDigest package
//              Main entry points into this dll:
//                SpAcceptCredentials
//                SpAcquireCredentialsHandle
//                SpFreeCredentialsHandle
//                SpQueryCredentialsAttributes
//                SpSaveCredentials
//                SpGetCredentials
//                SpDeleteCredentials
//
//              Helper functions:
//                CopyClientString
//
// History:     ChandanS   26-Jul-1996   Stolen from kerberos\client2\credapi.cxx
//              KDamour    16Mar00       Stolen from NTLM
//
//------------------------------------------------------------------------
#define NTDIGEST_CREDAPI
#include <global.h>

extern BOOL g_bCredentialsInitialized;



//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              Accountname - Name of the account that logged on
//              PrimaryCredentials - Primary credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - NtLm -Specific blob not used
//
//  Returns:    None
//
//  Notes:
//
//-------------------------------------------------------------------------- ok
NTSTATUS NTAPI
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_LOGONSESSION pNewLogonSession = NULL;
    UNICODE_STRING  ustrTempPasswd = {0};

    DebugLog((DEB_TRACE_FUNC, "SpAcceptCredentials: Entering\n"));
    DebugLog((DEB_TRACE, "SpAcceptCredentials:    Credential: LogonType %d\n", LogonType));

    // AccountName is not currently used for any additional processing
    if (AccountName)
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  Entering AccountName %wZ\n",
                AccountName));
    }
    else
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No AccountName provided\n"));
    }

    if (PrimaryCredentials)
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           DomainName\\DownlevelName %wZ\\%wZ\n",
                    &PrimaryCredentials->DomainName,
                    &PrimaryCredentials->DownlevelName));
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           UPN  DnsDomainName %wZ  %wZ\n",
                    &PrimaryCredentials->Upn,
                    &PrimaryCredentials->DnsDomainName));
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           LogonID (%x:%lx)  Flags 0x%x\n",
                    PrimaryCredentials->LogonId.HighPart,
                    PrimaryCredentials->LogonId.LowPart,
                    PrimaryCredentials->Flags));
    }
    else
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No PrimaryCredentials provided\n"));
        goto CleanUp;
    }

    if (SupplementalCredentials)
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:           Supplemental Creds  Size %d\n",
                    SupplementalCredentials->CredentialSize));
    }
    else
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No Supplemental Credentials provided\n"));
    }

    // If there is no cleartext password then can not do any operations - just leave
    if (!(PrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD)) 
    {
        DebugLog((DEB_TRACE,"SpAcceptCredentials:  No Primary ClearText Password - no active logon created\n"));
        Status = STATUS_SUCCESS;
        goto CleanUp; 
    }

    //
    // If this is an update, just change the password
    //
    if ((PrimaryCredentials->Flags & PRIMARY_CRED_UPDATE) != 0)
    {
        // Make a copy of the password and encrypt it
        Status = UnicodeStringDuplicatePassword(&ustrTempPasswd, &PrimaryCredentials->Password);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup password, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        if (ustrTempPasswd.MaximumLength != 0)
        {
            g_LsaFunctions->LsaProtectMemory(ustrTempPasswd.Buffer, (ULONG)(ustrTempPasswd.MaximumLength));
        }

        // Check to see if this LogonId is already in the list and update password
        Status = LogSessHandlerPasswdSet(&PrimaryCredentials->LogonId, &ustrTempPasswd);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Failed to update LogonSession Password\n"));
        }
        else
        {
            DebugLog((DEB_TRACE, "SpAcceptCredentials: Updated Password for LogonSession\n"));
        }
    }
    else
    {
        DebugLog((DEB_TRACE, "SpAcceptCredentials: Create New LogonSession - not an update\n"));

        // This is a new entry into the list so create a LogonSession listing
        pNewLogonSession = (PDIGEST_LOGONSESSION)DigestAllocateMemory(sizeof(DIGEST_LOGONSESSION));
        if (!pNewLogonSession)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Could not allocate memory for logonsession, error 0x%x\n", Status));
            goto CleanUp;
        }
        LogonSessionInit(pNewLogonSession);

        pNewLogonSession->LogonType = LogonType;
        pNewLogonSession->LogonId = PrimaryCredentials->LogonId;

        DebugLog((DEB_TRACE, "SpAcceptCredentials: Created Digest Logonsession for for LogonID (%x:%lx)\n",
                   PrimaryCredentials->LogonId.HighPart, PrimaryCredentials->LogonId.LowPart ));

        Status = UnicodeStringDuplicate(&(pNewLogonSession->ustrAccountName), &(PrimaryCredentials->DownlevelName));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup AccountName, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        Status = UnicodeStringDuplicate(&(pNewLogonSession->ustrDomainName), &(PrimaryCredentials->DomainName));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup DomainName, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        Status = UnicodeStringDuplicate(&(pNewLogonSession->ustrDnsDomainName), &(PrimaryCredentials->DnsDomainName));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup DnsDomainName, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        Status = UnicodeStringDuplicate(&(pNewLogonSession->ustrUpn), &(PrimaryCredentials->Upn));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup Upn, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        Status = UnicodeStringDuplicatePassword(&(pNewLogonSession->ustrPassword), &(PrimaryCredentials->Password));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptCredentials: Error in dup password, status 0x%0x\n", Status ));
            goto CleanUp;
        }

        if (pNewLogonSession->ustrPassword.MaximumLength != 0)
        {
            g_LsaFunctions->LsaProtectMemory(pNewLogonSession->ustrPassword.Buffer,
                                             (ULONG)(pNewLogonSession->ustrPassword.MaximumLength));
        }

        DebugLog((DEB_TRACE, "SpAcceptCredentials: Added new logonsession into list,  handle 0x%x\n", pNewLogonSession));
        LogSessHandlerInsert(pNewLogonSession);
        pNewLogonSession = NULL;                          // Turned over memory to LogSessHandler
    }

CleanUp:

    if (ustrTempPasswd.Buffer && ustrTempPasswd.MaximumLength)
    {   // Zero out password info just to be safe
        SecureZeroMemory(ustrTempPasswd.Buffer, ustrTempPasswd.MaximumLength);
    }
    UnicodeStringFree(&ustrTempPasswd);

    if (pNewLogonSession)
    {
        (void)LogonSessionFree(pNewLogonSession);
        pNewLogonSession = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "SpAcceptCredentials:  Leaving status 0x%x\n", Status));

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpAcquireCredentialsHandle
//
//  Synopsis:   Contains Digest Server Code for AcquireCredentialsHandle which
//              creates a Credential associated with a logon session.
//
//  Effects:    Creates a DIGEST_CREDENTIAL
//
//  Arguments:  PrincipalName - Name of logon session for which to create credential
//              CredentialUseFlags - Flags indicating whether the credentials
//                  is for inbound or outbound use.
//              LogonId - The logon ID of logon session for which to create
//                  a credential.
//              AuthorizationData - Optional username, domain, password info
//              GetKeyFunction - Unused function to retrieve a session key
//              GetKeyArgument - Unused Argument for GetKeyFunction
//              CredentialHandle - Receives handle to new credential
//              ExpirationTime - Receives expiration time for credential
//
//  Returns:
//    STATUS_SUCCESS -- Call completed successfully
//    SEC_E_NO_SPM -- Security Support Provider is not running
//    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
//    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
//    SEC_E_NOT_OWNER -- caller does not own the specified credentials
//    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory
//    SEC_E_NOT_SUPPORTED - CredentialUse must be Outbound (Inbound once client code added)
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpAcquireCredentialsHandle(
    IN OPTIONAL PUNICODE_STRING pPrincipalName,
    IN ULONG CredentialUseFlags,
    IN OPTIONAL PLUID pLogonId,
    IN OPTIONAL PVOID pAuthorizationData,
    IN PVOID pGetKeyFunction,
    IN PVOID pGetKeyArgument,
    OUT PULONG_PTR ppCredentialHandle,
    OUT PTimeStamp pExpirationTime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_CREDENTIAL pTmpCred = NULL;
    PDIGEST_CREDENTIAL pCredential = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    PDIGEST_CONTEXT pContext = NULL;                    // for delegation info lookup

    ULONG NewCredentialUseFlags = CredentialUseFlags;

    UNICODE_STRING AuthzUserName = {0};
    UNICODE_STRING AuthzDomainName = {0};
    UNICODE_STRING AuthzPassword = {0};
    UNICODE_STRING ustrTempPasswd = {0};

    SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_CALL_INFO CallInfo;
    PLUID pLogonIdToUse = NULL;
    BOOL bAuthzDataProvided = FALSE;

    UNREFERENCED_PARAMETER(pGetKeyFunction);
    UNREFERENCED_PARAMETER(pGetKeyArgument);

    DebugLog((DEB_TRACE_FUNC, "SpAcquireCredentialsHandle:  Entering\n"));

    if (!ppCredentialHandle)
    {
        DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Invalid arg to ACH (possible NULL pointer)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *ppCredentialHandle = NULL;
    if (pExpirationTime)
    {
        *pExpirationTime = g_TimeForever;    // Never times out credential
        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Expiration TimeStamp  high/low 0x%x/0x%x\n",
                  pExpirationTime->HighPart, pExpirationTime->LowPart));
    }

    // This should really not happen - just a quick check
    ASSERT(g_bCredentialsInitialized);
    if (!g_bCredentialsInitialized)
    {
        DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle credential manager not initialized\n"));
        return SEC_E_NO_SPM;
    }

    // Allow only INBOUND or OUTBOUND (not DEFAULT or Reserved)
    if ( (CredentialUseFlags & (DIGEST_CRED_OUTBOUND | DIGEST_CRED_INBOUND)) == 0)
    {
        DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Credential flag not supported\n"));
        Status = SEC_E_NOT_SUPPORTED;
        goto CleanUp;
    }

    //
    // First get information about the caller.
    //

    Status = g_LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: Failed to get client information: 0x%x\n",Status));
        goto CleanUp;
    }

    if( (ClientInfo.ClientFlags & SECPKG_CLIENT_THREAD_TERMINATED) ||
        (ClientInfo.ClientFlags & SECPKG_CLIENT_PROCESS_TERMINATED) )
    {
        Status =  STATUS_ACCESS_DENIED;
        DebugLog(( DEB_ERROR, "SpAcquireCredentialsHandle: GetClientInfo flags returned 0x%lx\n", Status));
        goto CleanUp;
    }


    //
    // Got to have an impersonation level token in order to call ACH.
    // This check used to be in lsa, but moved here to enable
    // some S4Uproxy scenarios to work w/o tcb.
    //
    if (ClientInfo.ImpersonationLevel <= SecurityIdentification)
    {
        DebugLog((DEB_WARN, "Trying to acquire credentials with an token no better than SecurityIdentification\n"));
        Status = SEC_E_NO_CREDENTIALS;
        goto CleanUp;
    }  

    Status = g_LsaFunctions->GetCallInfo(&CallInfo);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: Failed to get call information: 0x%x\n",Status));
        goto CleanUp;
    }


    // Check if acting as the server  (Inbound creds)
    if (NewCredentialUseFlags & DIGEST_CRED_INBOUND)
    {
        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Creating an Inbound Credential\n"));

        // Allocate a credential block and initialize it.
        pTmpCred = (PDIGEST_CREDENTIAL)DigestAllocateMemory(sizeof(DIGEST_CREDENTIAL) );
        if (!pTmpCred)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;      // Out of memory return error
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle Out of Memory\n"));
            goto CleanUp;
        }
        Status = CredentialInit(pTmpCred);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: CredentialInit error 0x%x\n", Status));
            goto CleanUp;
        }

        pTmpCred->CredentialUseFlags = NewCredentialUseFlags;
        memcpy(&(pTmpCred->LogonId), &ClientInfo.LogonId, sizeof(LUID));

        pTmpCred->ClientProcessID = ClientInfo.ProcessID;
        
        //
        // Add it to the list of valid credential handles.
        //

        pTmpCred->lReferences = 1;
        (void)CredPrint(pTmpCred);

        CredHandlerInsertCred(pTmpCred);
        *ppCredentialHandle = (LSA_SEC_HANDLE) pTmpCred;    // link to the output

        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Added Credential 0x%lx\n", pCredential));

        pTmpCred = NULL;                                    // We do not own this memory anymore
    }
    else
    {       //   Called by a client for Outbound direction

        // Locate the LogonSession to utilize for the credential
        // If the caller is a system process with the SE_TCB_NAME privilege, and the caller provides
        // both the name and logon identifier, the function verifies that they match before returning
        // the credentials. If only one is provided, the function returns a handle to that identifier.

        // A caller that is not a system process can only obtain a handle to the credentials under
        // which it is running. The caller can provide the name or the logon identifier, but it must
        // be for the current session or the request fails.


        DebugLog((DEB_TRACE,"SpAcquireCredentialsHandle: Have Outbound Credential request\n"));
        if (ARGUMENT_PRESENT(pLogonId) && ((pLogonId->LowPart != 0) || (pLogonId->HighPart != 0)))
        {
            // If the LUID of request not equal to Client LUID then must have TCBPrivilege, else rejest request
             if (((pLogonId->LowPart != ClientInfo.LogonId.LowPart) ||
                  (pLogonId->HighPart != ClientInfo.LogonId.HighPart)) &&
                  !ClientInfo.HasTcbPrivilege)
            {
                Status = STATUS_PRIVILEGE_NOT_HELD;
                DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: LoginID change forbidden\n"));
                goto CleanUp;
            }

            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle:   Using pLogonID luid (%x:%lx)\n",
                     pLogonId->HighPart, pLogonId->LowPart));

            Status = LogSessHandlerLogonIdToPtr(pLogonId, FALSE, &pLogonSession);
            if (!NT_SUCCESS (Status))
            {            // Could not find the LogonID so fail
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: could not find LogonID    status 0x%x\n", Status));
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto CleanUp;
            }
            pLogonIdToUse = pLogonId;

            // If Principal name supplied, make sure they match with the loginsession
            if (ARGUMENT_PRESENT(pPrincipalName) && pPrincipalName->Length)
            {
                if (!RtlEqualUnicodeString(pPrincipalName,&(pLogonSession->ustrAccountName),TRUE))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: PrincipalName does not match LogonSession\n"));
                    Status = STATUS_NO_SUCH_LOGON_SESSION;
                    goto CleanUp;
                }
            }
        }
        else if (ARGUMENT_PRESENT(pPrincipalName) && (pPrincipalName->Length))
        {
            // Given only the principal name to lookup
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: logonsession principal name lookup %wZ\n", pPrincipalName));
            Status = LogSessHandlerAccNameToPtr(pPrincipalName, &pLogonSession);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: principal name not in logon list    error 0x%x\n", Status));
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto CleanUp;
            }

            // If make sure we have TCB if logonID are different
            if ((((pLogonSession->LogonId).LowPart != ClientInfo.LogonId.LowPart) ||
                 ((pLogonSession->LogonId).HighPart != ClientInfo.LogonId.HighPart)) &&
                 !ClientInfo.HasTcbPrivilege)
           {
               Status = STATUS_PRIVILEGE_NOT_HELD;
               DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: PrincipalName selection forbidden, LoginID differs\n"));
               goto CleanUp;
           }

           // pLogonIdToUse = &ClientInfo.LogonId;
           pLogonIdToUse = &(pLogonSession->LogonId);

        }
        else
        {
            // No LoginID or Principal name provided
            // Use the callers logon id.

            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle:   Using callers Logon (%x:%lx)\n",
                    ClientInfo.LogonId.HighPart,
                    ClientInfo.LogonId.LowPart));

            Status = LogSessHandlerLogonIdToPtr(&ClientInfo.LogonId, FALSE,  &pLogonSession);
            if (!NT_SUCCESS (Status))
            {
                // Could not find the LogonID so fail
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: could not find caller's LogonSession   status 0x%x\n", Status));
                goto CleanUp;
            }
            pLogonIdToUse = &ClientInfo.LogonId;
        }

        // We now must have a pLogonSession - this conditional is not needed after testing completed
        if (!pLogonSession)
        {
            DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Must have LogonSession\n"));
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto CleanUp;
        }

        if (pAuthorizationData)
        {
            Status = CredAuthzData(pAuthorizationData,
                                   &CallInfo,
                                   &NewCredentialUseFlags,
                                   &AuthzUserName,
                                   &AuthzDomainName,
                                   &AuthzPassword);

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"SpAcquireCredentialsHandle: CredAuthzData error in reading authdata status 0x%x\n", Status));
            }
            else
                bAuthzDataProvided = TRUE;
            DebugLog((DEB_TRACE,"SpAcquireCredentialsHandle: AuthData provided Username=%wZ   DomainName=%wZ\n",
                      &AuthzUserName, &AuthzDomainName));
        }

        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Using LogonSession Handle 0x%lx\n", pLogonSession));
        DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle:       Logon luid (%x:%lx)\n",
                (pLogonSession->LogonId).HighPart,
                (pLogonSession->LogonId).LowPart));

        if (!bAuthzDataProvided)
        {          // If no authz data then see if it matches with an existing credential 
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Check to see if cred exists\n"));
            Status = CredHandlerLocatePtr(pLogonIdToUse, NewCredentialUseFlags, &pCredential);
        }

        if (NT_SUCCESS(Status) && !bAuthzDataProvided)
        {
            // We currently have a credential for this ProcessID, LogonId - just make any updates
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: We currently have existing Credentials at 0x%x. Update only\n", pCredential));
            

            Status = LogSessHandlerPasswdGet(pLogonSession, &(ustrTempPasswd));
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error LogSess get TempPasswd   Status 0x%x\n", Status));
                goto CleanUp;
            }
            Status = CredHandlerPasswdSet(pCredential, &(ustrTempPasswd));
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Errors in Passwd set     Status 0x%x\n", Status));
                goto CleanUp;
            }

            *ppCredentialHandle = (LSA_SEC_HANDLE) pCredential;    // link to the output
            pCredential = NULL;                                    // Reference for this context owned by system
        }
        else
        {
            // We need to create a new Credential
            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Creating an Outbound Credential\n"));
            // Allocate a credential block and initialize it.
            pTmpCred = (PDIGEST_CREDENTIAL)DigestAllocateMemory(sizeof(DIGEST_CREDENTIAL) );
            if (!pTmpCred)
            {
                Status = SEC_E_INSUFFICIENT_MEMORY;
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle Out of Memory\n"));
                goto CleanUp;
            }

            Status = CredentialInit(pTmpCred);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: CredentialInit error 0x%x\n", Status));
                goto CleanUp;
            }

            pTmpCred->CredentialUseFlags = NewCredentialUseFlags;
            memcpy(&(pTmpCred->LogonId), &(pLogonSession->LogonId), sizeof(LUID));

            pTmpCred->ClientProcessID = ClientInfo.ProcessID;

            // Copy over the account & password info
            // Some of these might not be utilized in client - may remove as appropriate
            // Only three crednetial fields are used: ustrAccountName, ustrDomain, ustrPassword

            if (!bAuthzDataProvided)
            {
                DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Using default credentials\n"));

                Status = UnicodeStringDuplicate(&(pTmpCred->ustrAccountName), &(pLogonSession->ustrAccountName));
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error string duplicate   Status 0x%x\n", Status));
                    goto CleanUp;
                }

                if (pLogonSession->ustrDnsDomainName.Length)
                {
                    Status = UnicodeStringDuplicate(&(pTmpCred->ustrDomain), &(pLogonSession->ustrDnsDomainName));
                }
                else
                {           // No DNSDomainName filled in - use NT's DomainName
                    Status = UnicodeStringDuplicate(&(pTmpCred->ustrDomain), &(pLogonSession->ustrDomainName));
                }
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error string duplicate   Status 0x%x\n", Status));
                    goto CleanUp;
                }

                // make sure that the username & DNS domain name are lowercase - will be used in ChallengeResponse
                Status = RtlDowncaseUnicodeString(&(pTmpCred->ustrAccountName),
                                                  &(pTmpCred->ustrAccountName),
                                                  FALSE);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Downcase accountname failed    error 0x%x\n", Status));
                    goto CleanUp;
                }
                
                Status = RtlDowncaseUnicodeString(&(pTmpCred->ustrDomain),
                                                  &(pTmpCred->ustrDomain),
                                                  FALSE);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Downcase Domain failed    error 0x%x\n", Status));
                    goto CleanUp;
                }
                
                Status = UnicodeStringDuplicate(&(pTmpCred->ustrUpn), &(pLogonSession->ustrUpn));
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error string duplicate   Status 0x%x\n", Status));
                    goto CleanUp;
                }

                Status = LogSessHandlerPasswdGet(pLogonSession, &(pTmpCred->ustrPassword));
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error LogSess get Passwd   Status 0x%x\n", Status));
                    goto CleanUp;
                }
            }
            else
            {
                // Force in the Authz creds provided

                Status = UnicodeStringDuplicate(&(pTmpCred->ustrAccountName), &AuthzUserName);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error string duplicate   Status 0x%x\n", Status));
                    goto CleanUp;
                }

                Status = UnicodeStringDuplicate(&(pTmpCred->ustrDomain), &AuthzDomainName);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Error string duplicate   Status 0x%x\n", Status));
                    goto CleanUp;
                }

                Status = UnicodeStringDuplicatePassword(&(pTmpCred->ustrPassword), &AuthzPassword);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle: Authz string copies error 0x%x\n", Status));
                    goto CleanUp;
                }

                // Since Auth data is cleartext password MUST encrypt since always keep in encrypted format
                if (pTmpCred->ustrPassword.MaximumLength != 0)
                {
                    g_LsaFunctions->LsaProtectMemory(pTmpCred->ustrPassword.Buffer,
                                                     (ULONG)(pTmpCred->ustrPassword.MaximumLength));
                }
            }

            pTmpCred->lReferences = 1;
            (void)CredPrint(pTmpCred);

            // Add it to the list of valid credential handles.
            CredHandlerInsertCred(pTmpCred);
            *ppCredentialHandle = (LSA_SEC_HANDLE) pTmpCred;    // link to the output

            pTmpCred = NULL;                                    // We do not own this memory anymore
            // pLogonSession = NULL;                               // The Cred has ownership of ref count for logonsession

            DebugLog((DEB_TRACE, "SpAcquireCredentialsHandle: Added Credential 0x%lx\n", *ppCredentialHandle));

        }
    }


CleanUp:

    UnicodeStringFree(&AuthzUserName);
    UnicodeStringFree(&AuthzDomainName);
    if (AuthzPassword.Buffer && AuthzPassword.MaximumLength)
    {   // Zero out password info just to be safe
        SecureZeroMemory(AuthzPassword.Buffer, AuthzPassword.MaximumLength);
    }
    UnicodeStringFree(&AuthzPassword);
    if (ustrTempPasswd.Buffer && ustrTempPasswd.MaximumLength)
    {   // Zero out password info just to be safe
        SecureZeroMemory(ustrTempPasswd.Buffer, ustrTempPasswd.MaximumLength);
    }
    UnicodeStringFree(&ustrTempPasswd);

    if (pTmpCred)
    {
        CredentialFree(pTmpCred);
        pTmpCred = NULL;
    }
    
    if (pLogonSession)
    {
        LogSessHandlerRelease(pLogonSession);
    }

    if (pCredential)
    {
        CredHandlerRelease(pCredential);
    }

    if (pContext)
    {
        CtxtHandlerRelease(pContext, 1);
    }

    DebugLog((DEB_TRACE_FUNC, "SpAcquireCredentialsHandle:  Leaving    Status  0x%x\n", Status));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   SpFreeCredentialsHandle
//
//  Synopsis:   Frees a credential created by AcquireCredentialsHandle.
//
//  Effects:    Dereferences the credential in the global list..
//
//  Arguments:  CredentialHandle - Handle to the credential to free
//              (acquired through AcquireCredentialsHandle)
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpFreeCredentialsHandle(
    IN ULONG_PTR CredentialHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_CREDENTIAL pDigestCred = NULL;

    DebugLog((DEB_TRACE_FUNC, "SpFreeCredentialsHandle: Entering  Handle 0x%x\n", CredentialHandle));

    Status = CredHandlerHandleToPtr(CredentialHandle, TRUE, &pDigestCred);   // unlink from list
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpFreeCredentialsHandle: Can not find ContextHandle in list   Status 0x%x\n", Status));
        goto CleanUp;
    }
       // Now check if we should release the memory
    ASSERT(pDigestCred);

    DebugLog((DEB_TRACE, "SpFreeCredentialsHandle: FreeCredHandle 0x%x    ReferenceCount is %d\n",
              pDigestCred, pDigestCred->lReferences));

    // Dereference the credential, it will also unlink from list if necessary
    Status = CredHandlerRelease(pDigestCred);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpFreeCredentialsHandle: Error in Releasing Credential  Status 0x%x\n", Status));
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpFreeCredentialsHandle: Leaving  Handle 0x%x    Status 0x%x\n", CredentialHandle, Status));

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryCredentialsAttributes
//
//  Synopsis:   retrieves the attributes of a credential, such as the name associated with the credential.
//
//  Effects:    Dereferences the credential in the global list..
//
//  Arguments:  CredentialHandle - Handle of the credentials to be queried
//              CredentialAttribute - Specifies the attribute to query. This parameter can be any of the following attributes
//                                  SECPKG_CRED_ATTR_NAMES 
//              Buffer - Pointer to a buffer that receives the requested attribute
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//   The caller must allocate the structure pointed to by the pBuffer parameter.
//   The security package allocates the buffer for any pointer returned in the pBuffer structure
//   The caller can call the FreeContextBuffer function to free any pointers allocated by the security package.
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpQueryCredentialsAttributes(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG CredentialAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TempStatus = STATUS_SUCCESS;
    PDIGEST_CREDENTIAL pDigestCred = NULL;
    SECPKG_CALL_INFO CallInfo;
    SecPkgCredentials_NamesW Names;

    LPWSTR ContextNames = NULL;
    LPWSTR Where = NULL;

    DWORD cchUserName = 0;
    DWORD cchDomainName = 0;
    ULONG Length = 0;


    DebugLog((DEB_TRACE_FUNC, "SpQueryCredentialsAttributes: Entering  Handle 0x%x\n", CredentialHandle));

    Names.sUserName = NULL;

    Status = g_LsaFunctions->GetCallInfo(&CallInfo);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SpQueryCredentialsAttributes: Failed to get call information: 0x%x\n",Status));
        goto CleanUp;
    }


    if (CredentialAttribute != SECPKG_CRED_ATTR_NAMES)
    {
        DebugLog((DEB_WARN, "SpQueryCredentialsAttributes: Invalid Request Attribute %d\n", CredentialAttribute));
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto CleanUp;
    }


    Status = CredHandlerHandleToPtr(CredentialHandle, FALSE, &pDigestCred);
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: Can not find ContextHandle in list   Status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // specified creds.
    //

    Length = pDigestCred->ustrAccountName.Length + pDigestCred->ustrDomain.Length + (2 * sizeof(WCHAR));

    ContextNames = (LPWSTR)DigestAllocateMemory( Length );
    if( ContextNames == NULL ) {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: Internal Allocate failed   Status 0x%x\n", Status));
        goto CleanUp;
    }

    Where = ContextNames;

    if(pDigestCred->ustrDomain.Length) {
        RtlCopyMemory( ContextNames, pDigestCred->ustrDomain.Buffer, pDigestCred->ustrDomain.Length);
        cchDomainName = pDigestCred->ustrDomain.Length / sizeof(WCHAR);
        ContextNames[ cchDomainName ] = L'\\';
        Where += (cchDomainName+1);
    }


    if(pDigestCred->ustrAccountName.Length) {
        RtlCopyMemory( Where, pDigestCred->ustrAccountName.Buffer, pDigestCred->ustrAccountName.Length);
    }

    cchUserName = pDigestCred->ustrAccountName.Length / sizeof(WCHAR);
    Where[ cchUserName ] = L'\0';


    //
    // Allocate memory in the client's address space
    //

    Status = g_LsaFunctions->AllocateClientBuffer(
                NULL,
                Length,
                (PVOID *) &Names.sUserName
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: AllocateClientBuffer failed   Status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Copy the string there
    //

    Status = g_LsaFunctions->CopyToClientBuffer(
                NULL,
                Length,
                Names.sUserName,
                ContextNames
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: CopyToClientBuffer string failed   Status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Now copy the address of the string there
    //


    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {   // Write out only a 32bit value
        Status = g_LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(ULONG),
                    Buffer,
                    &Names
                    );
    }
    else
    {
        Status = g_LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Names),
                    Buffer,
                    &Names
                    );
    }
    
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: CopyToClientBuffer string address failed   Status 0x%x\n", Status));
        goto CleanUp;
    }


CleanUp:


    // Dereference the credential
    if (pDigestCred)
    {
        TempStatus = CredHandlerRelease(pDigestCred);
        if (!NT_SUCCESS(TempStatus))
        {
            DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes: Error in Releasing Credential  Status 0x%x\n", TempStatus));
        }
    }

    if (!NT_SUCCESS(Status))
    {
        if (Names.sUserName != NULL)
        {
            (VOID) g_LsaFunctions->FreeClientBuffer(
                        NULL,
                        Names.sUserName
                        );
        }
        Names.sUserName = NULL;
    }

    if( ContextNames ) {
        DigestFreeMemory( ContextNames );
    }

    DebugLog((DEB_TRACE_FUNC, "SpQueryCredentialsAttributes: Leaving  Handle 0x%x    Status 0x%x\n", CredentialHandle, Status));

    return(Status);
}


NTSTATUS NTAPI
SpSaveCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    DebugLog((DEB_TRACE_FUNC, "SpSaveCredentials: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS NTAPI
SpGetCredentials(
    IN ULONG_PTR CredentialHandle,
    IN OUT PSecBuffer Credentials
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Credentials);
    DebugLog((DEB_TRACE_FUNC, "SpGetCredentials: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//   Function not implemented.  ok
NTSTATUS NTAPI
SpDeleteCredentials(
    IN ULONG_PTR CredentialHandle,
    IN PSecBuffer Key
    )
{
    UNREFERENCED_PARAMETER(CredentialHandle);
    UNREFERENCED_PARAMETER(Key);
    DebugLog((DEB_TRACE_FUNC, "SpDeleteCredentials:       Entering/Leaving  CredentialHandle 0x%x\n", CredentialHandle));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


NTSTATUS
CredPrint(PDIGEST_CREDENTIAL pCredential)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pCredential)
    {
        return (STATUS_INVALID_PARAMETER); 
    }

    DebugLog((DEB_TRACE, "CredPrint:          Credential 0x%x   \n", pCredential));

    if (pCredential->CredentialUseFlags & DIGEST_CRED_INBOUND)
    {
            DebugLog((DEB_TRACE, "CredPrint:          INBOUND Session Credential   \n"));
    }
    else
    {
            DebugLog((DEB_TRACE, "CredPrint:          OUTBOUND Session Credential   \n"));
    }

    DebugLog((DEB_TRACE, "CredPrint:          AccountName %wZ   \n", &(pCredential->ustrAccountName)));
    // DebugLog((DEB_TRACE, "CredPrint:          Password %wZ   \n", &(pCredential->ustrPassword)));
    DebugLog((DEB_TRACE, "CredPrint:          Domain %wZ   \n", &(pCredential->ustrDomain)));
    DebugLog((DEB_TRACE, "CredPrint:          Upn %wZ   \n", &(pCredential->ustrUpn)));
    DebugLog((DEB_TRACE, "CredPrint:          References %ld   \n", pCredential->lReferences));

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   CredAuthData
//
//  Synopsis:   Copy over supplied auth data.
//
//  Effects:    Fills in string values - calling function must free.
//
//  Arguments:  
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
CredAuthzData(
    IN PVOID AuthorizationData,
    IN PSECPKG_CALL_INFO pCallInfo,
    IN OUT PULONG NewCredentialUseFlags,
    IN OUT PUNICODE_STRING pUserName,
    IN OUT PUNICODE_STRING pDomainName,
    IN OUT PUNICODE_STRING pPassword
    )
{
    UNICODE_STRING UserName = {0};
    UNICODE_STRING DomainName = {0};
    UNICODE_STRING Password = {0};
    PSEC_WINNT_AUTH_IDENTITY pAuthIdentity = NULL;
    BOOLEAN DoUnicode = TRUE;
    PSEC_WINNT_AUTH_IDENTITY_EXW pAuthIdentityEx = NULL;

    PSEC_WINNT_AUTH_IDENTITY_W TmpCredentials = NULL;
    ULONG CredSize = 0;
    ULONG Offset = 0;
    ULONG ulBuffSize = 0;

    SEC_WINNT_AUTH_IDENTITY32 Cred32 ;
    SEC_WINNT_AUTH_IDENTITY_EX32 CredEx32 ;

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Copy over the authorization data into out address
    // space and make a local copy of the strings.
    //

    DebugLog((DEB_TRACE_FUNC, "CredAuthzData: Entering\n"));

    ZeroMemory(&Cred32, sizeof(SEC_WINNT_AUTH_IDENTITY32));
    ZeroMemory(&CredEx32, sizeof(SEC_WINNT_AUTH_IDENTITY_EX32));

    ASSERT(pCallInfo);

    if (AuthorizationData != NULL)
    {
        ulBuffSize = ((sizeof(SEC_WINNT_AUTH_IDENTITY_EXW) > sizeof(SEC_WINNT_AUTH_IDENTITY32)) ?
                      sizeof(SEC_WINNT_AUTH_IDENTITY_EXW) : sizeof(SEC_WINNT_AUTH_IDENTITY32));
        
        pAuthIdentityEx = (PSEC_WINNT_AUTH_IDENTITY_EXW) DigestAllocateMemory(ulBuffSize);


        if (pAuthIdentityEx != NULL)
        {

            if ( pCallInfo->Attributes & SECPKG_CALL_WOWCLIENT )
            {

                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( Cred32 ),
                            pAuthIdentityEx,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    RtlCopyMemory( &Cred32, pAuthIdentityEx, sizeof( Cred32 ) );
                }

            }
            else 
            {
                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY),
                            pAuthIdentityEx,
                            AuthorizationData);
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto CleanUp;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "CredAuthzData: Error from Digest Allocate is 0x%lx\n", Status));
            goto CleanUp;
        }

        //
        // Check for the ex version
        //

        if (pAuthIdentityEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION)
        {
            //
            // It's an EX structure.
            //

            if ( pCallInfo->Attributes & SECPKG_CALL_WOWCLIENT )
            {
                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof( CredEx32 ),
                            &CredEx32,
                            AuthorizationData );

                if ( NT_SUCCESS( Status ) )
                {
                    pAuthIdentityEx->Version = CredEx32.Version ;
                    pAuthIdentityEx->Length = (CredEx32.Length < (ULONG)sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) ? 
                                               (ULONG)sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) : CredEx32.Length );

                    pAuthIdentityEx->User = (PWSTR) UlongToPtr( CredEx32.User );
                    pAuthIdentityEx->UserLength = CredEx32.UserLength ;
                    pAuthIdentityEx->Domain = (PWSTR) UlongToPtr( CredEx32.Domain );
                    pAuthIdentityEx->DomainLength = CredEx32.DomainLength ;
                    pAuthIdentityEx->Password = (PWSTR) UlongToPtr( CredEx32.Password );
                    pAuthIdentityEx->PasswordLength = CredEx32.PasswordLength ;
                    pAuthIdentityEx->Flags = CredEx32.Flags ;
                    pAuthIdentityEx->PackageList = (PWSTR) UlongToPtr( CredEx32.PackageList );
                    pAuthIdentityEx->PackageListLength = CredEx32.PackageListLength ;

                }

            }
            else
            {
                Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                            pAuthIdentityEx,
                            AuthorizationData);
            }


            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto CleanUp;
            }
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) &pAuthIdentityEx->User;
            CredSize = pAuthIdentityEx->Length;
            Offset = FIELD_OFFSET(SEC_WINNT_AUTH_IDENTITY_EXW, User);
        }
        else
        {
            pAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIdentityEx;

            if ( pCallInfo->Attributes & SECPKG_CALL_WOWCLIENT )
            {
                pAuthIdentity->User = (PWSTR) UlongToPtr( Cred32.User );
                pAuthIdentity->UserLength = Cred32.UserLength ;
                pAuthIdentity->Domain = (PWSTR) UlongToPtr( Cred32.Domain );
                pAuthIdentity->DomainLength = Cred32.DomainLength ;
                pAuthIdentity->Password = (PWSTR) UlongToPtr( Cred32.Password );
                pAuthIdentity->PasswordLength = Cred32.PasswordLength ;
                pAuthIdentity->Flags = Cred32.Flags ;
            }
            CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_W);
        }

        if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
        {
            DoUnicode = FALSE;
            //
            // Turn off the marshalled flag because we don't support marshalling
            // with ansi.
            //

            pAuthIdentity->Flags &= ~SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
        }
        else if ((pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) == 0)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "CredAuthzData: Error from pAuthIdentity->Flags is 0x%lx\n", pAuthIdentity->Flags));
            goto CleanUp;
        }
        

        // This is the only place where we can figure out whether null
        // session was requested

        if ((pAuthIdentity->UserLength == 0) &&
            (pAuthIdentity->DomainLength == 0) &&
            (pAuthIdentity->PasswordLength == 0) &&
            (pAuthIdentity->User != NULL) &&
            (pAuthIdentity->Domain != NULL) &&
            (pAuthIdentity->Password != NULL))
        {
            *NewCredentialUseFlags |= DIGEST_CRED_NULLSESSION;
        }

        //
        // Copy over the strings
        //
        if( (pAuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED) != 0 )
        {
            ULONG TmpCredentialSize = 0;
            ULONG_PTR EndOfCreds = NULL;
            ULONG_PTR TmpUser = NULL;
            ULONG_PTR TmpDomain = NULL;
            ULONG_PTR TmpPassword = NULL;

            DebugLog((DEB_TRACE, "CredAuthzData: Marshalled Auth data structure.\n"));

            if( pAuthIdentity->UserLength > UNLEN ||
                pAuthIdentity->PasswordLength > PWLEN ||
                pAuthIdentity->DomainLength > DNS_MAX_NAME_LENGTH ) {

                DebugLog((DEB_ERROR, "CredAuthzData: Supplied credentials illegal length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            //
            // The callers can set the length of field to n chars, but they
            // will really occupy n+1 chars (null-terminator).
            //

            TmpCredentialSize = CredSize +
                             (  pAuthIdentity->UserLength +
                                pAuthIdentity->DomainLength +
                                pAuthIdentity->PasswordLength +
                             (((pAuthIdentity->User != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Domain != NULL) ? 1 : 0) +
                             ((pAuthIdentity->Password != NULL) ? 1 : 0)) ) * (ULONG)sizeof(WCHAR);

            EndOfCreds = (ULONG_PTR) AuthorizationData + TmpCredentialSize;

            //
            // Verify that all the offsets are valid and no overflow will happen
            //

            TmpUser = (ULONG_PTR) pAuthIdentity->User;

            if ((TmpUser != NULL) &&
                ( (TmpUser < (ULONG_PTR) AuthorizationData) ||
                  (TmpUser > EndOfCreds) ||
                  ((TmpUser + (pAuthIdentity->UserLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpUser + (pAuthIdentity->UserLength * sizeof(WCHAR))) < TmpUser)))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Username in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            TmpDomain = (ULONG_PTR) pAuthIdentity->Domain;

            if ((TmpDomain != NULL) &&
                ( (TmpDomain < (ULONG_PTR) AuthorizationData) ||
                  (TmpDomain > EndOfCreds) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpDomain + (pAuthIdentity->DomainLength * sizeof(WCHAR))) < TmpDomain)))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Domainname in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            TmpPassword = (ULONG_PTR) pAuthIdentity->Password;

            if ((TmpPassword != NULL) &&
                ( (TmpPassword < (ULONG_PTR) AuthorizationData) ||
                  (TmpPassword > EndOfCreds) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                  ((TmpPassword + (pAuthIdentity->PasswordLength * sizeof(WCHAR))) < TmpPassword)))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Password in supplied credentials has invalid pointer or length.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto CleanUp;
            }

            //
            // Allocate a chunk of memory for the credentials
            //

            TmpCredentials = (PSEC_WINNT_AUTH_IDENTITY_W) DigestAllocateMemory(TmpCredentialSize - Offset);
            if (TmpCredentials == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto CleanUp;
            }

            //
            // Copy the credentials from the client
            //

            Status = g_LsaFunctions->CopyFromClientBuffer(
                        NULL,
                        TmpCredentialSize - Offset,
                        TmpCredentials,
                        (PUCHAR) AuthorizationData + Offset
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "CredAuthzData: Failed to copy whole auth identity\n"));
                goto CleanUp;
            }

            //
            // Now convert all the offsets to pointers.
            //

            if (TmpCredentials->User != NULL)
            {
                USHORT cbUser;

                TmpCredentials->User = (LPWSTR) RtlOffsetToPointer(
                                                TmpCredentials->User,
                                                (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                );

                ASSERT( (TmpCredentials->UserLength*sizeof(WCHAR)) <= 0xFFFF );

                cbUser = (USHORT)(TmpCredentials->UserLength * sizeof(WCHAR));
                UserName.Buffer = (PWSTR)DigestAllocateMemory( cbUser );

                if (UserName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto CleanUp;
                }

                CopyMemory( UserName.Buffer, TmpCredentials->User, cbUser );
                UserName.Length = cbUser;
                UserName.MaximumLength = cbUser;
            }

            if (TmpCredentials->Domain != NULL)
            {
                USHORT cbDomain;

                TmpCredentials->Domain = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Domain,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );

                ASSERT( (TmpCredentials->DomainLength*sizeof(WCHAR)) <= 0xFFFF );
                cbDomain = (USHORT)(TmpCredentials->DomainLength * sizeof(WCHAR));
                DomainName.Buffer = (PWSTR)DigestAllocateMemory( cbDomain );

                if (DomainName.Buffer == NULL ) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto CleanUp;
                }

                CopyMemory( DomainName.Buffer, TmpCredentials->Domain, cbDomain );
                DomainName.Length = cbDomain;
                DomainName.MaximumLength = cbDomain;
            }

            if (TmpCredentials->Password != NULL)
            {
                USHORT cbPassword;

                TmpCredentials->Password = (LPWSTR) RtlOffsetToPointer(
                                                    TmpCredentials->Password,
                                                    (PUCHAR) TmpCredentials - (PUCHAR) AuthorizationData - Offset
                                                    );


                ASSERT( (TmpCredentials->PasswordLength*sizeof(WCHAR)) <= 0xFFFF );
                cbPassword = (USHORT)(TmpCredentials->PasswordLength * sizeof(WCHAR));
                Password.Buffer = (PWSTR)DigestAllocateMemory( cbPassword );

                if (Password.Buffer == NULL ) {
                    SecureZeroMemory( TmpCredentials->Password, cbPassword );
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto CleanUp;
                }

                CopyMemory( Password.Buffer, TmpCredentials->Password, cbPassword );
                Password.Length = cbPassword;
                Password.MaximumLength = cbPassword;

                SecureZeroMemory( TmpCredentials->Password, cbPassword );
            }


        } else
        {
            if (pAuthIdentity->Password != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Password,
                                pAuthIdentity->PasswordLength,
                                DoUnicode,
                                &Password
                                );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Error from CopyClientString is 0x%lx\n", Status));
                    goto CleanUp;
                }

            }
            
            if (pAuthIdentity->User != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->User,
                                pAuthIdentity->UserLength,
                                DoUnicode,
                                &UserName
                                );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Error from CopyClientString is 0x%lx\n", Status));
                    goto CleanUp;
                }

            }
            
            DebugLog((DEB_TRACE, "CredAuthzData: Domain buffer 0x%x   length %d bytes\n",
                      pAuthIdentity->Domain, pAuthIdentity->DomainLength));
            if (pAuthIdentity->Domain != NULL)
            {
                Status = CopyClientString(
                                pAuthIdentity->Domain,
                                pAuthIdentity->DomainLength,
                                DoUnicode,
                                &DomainName
                                );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Error from CopyClientString is 0x%lx\n", Status));
                    goto CleanUp;
                }

                //
                // Make sure that the domain name length is not greater
                // than the allowed dns domain name
                //

                if (DomainName.Length > DNS_MAX_NAME_LENGTH * sizeof(WCHAR))
                {
                    DebugLog((DEB_ERROR, "CredAuthzData: Invalid supplied domain name %wZ\n",
                        &DomainName ));
                    Status = SEC_E_UNKNOWN_CREDENTIALS;
                    goto CleanUp;
                }

            }
        }
    }   // AuthorizationData != NULL

    pUserName->Buffer = UserName.Buffer;
    pUserName->Length = UserName.Length;
    pUserName->MaximumLength = UserName.MaximumLength;
    UserName.Buffer = NULL;      // give memory to calling process
    
    pDomainName->Buffer = DomainName.Buffer;
    pDomainName->Length = DomainName.Length;
    pDomainName->MaximumLength = DomainName.MaximumLength;
    DomainName.Buffer = NULL;      // give memory to calling process

    pPassword->Buffer = Password.Buffer;
    pPassword->Length = Password.Length;
    pPassword->MaximumLength = Password.MaximumLength;
    Password.Buffer = NULL;      // give memory to calling process


CleanUp:


    if (pAuthIdentityEx != NULL)
    {
        DigestFreeMemory(pAuthIdentityEx);
    }

    if (TmpCredentials != NULL)
    {
        DigestFreeMemory(TmpCredentials);
    }

    if (DomainName.Buffer != NULL)
    {
        DigestFreeMemory(DomainName.Buffer);
    }

    if (UserName.Buffer != NULL)
    {
        DigestFreeMemory(UserName.Buffer);
    }

    if (Password.Buffer != NULL)
    {
        SecureZeroMemory(Password.Buffer, Password.Length);
        DigestFreeMemory(Password.Buffer);
    }

    DebugLog((DEB_TRACE_FUNC, "CredAuthzData: Leaving    Status 0x%x\n", Status));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ctxtapi.cxx
//
// Contents:    Context APIs for the Digest security package
//              Main entry points into this dll:
//                SpDeleteContext
//                SpInitLsaModeContext
//                SpApplyControlToken
//                SpAcceptLsaModeContext
//
// History:   KDamour  16Mar00       Based from NTLM ctxtapi.cxx
//
//------------------------------------------------------------------------

extern "C"
{
#include <stdio.h>
}

#include "global.h"

extern "C"
{
#include <ntdsapi.h>           // DS_USER_PRINCIPAL_NAME
#include <ntdsa.h>           // CrackSingleName
#include <lsarpc.h>
#include <lsaisrv.h>        // LsaIIsDomainWithinForest
#include <align.h>          // ROUND_UP_COUNT
}

#define MAXBUFNUMLEN 9       // VERY BIG number of digits in maxbuf
#define SECONDS_TO_100NANO  10000000        // Convert 100 nanoseconds to seconds


//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteContext
//
//  Synopsis:   Deletes an NtDigest context
//
//    Deletes the local data structures associated with the specified
//    security context in the LSA.
//
//    This API terminates a context on the local machine.
//
//  Effects:
//
//  Arguments:  ContextHandle - The context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_HANDLE
//
//  Notes:    This call is made ONCE to signal the SSP that the LSA is removing this context.
//     There might be outstanding requests in process so the reference count will be decremented
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpDeleteContext(
               IN ULONG_PTR ContextHandle
               )
{
    DebugLog((DEB_TRACE_FUNC, "SpDeleteContext: Entering   ContextHandle 0x%lx\n", ContextHandle ));
    PDIGEST_CONTEXT pContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG ulDereferenceCount = 1;

    SECPKG_CALL_INFO CallInfo = {0};

    //
    // Find the currently existing user context and delink it
    // so that another context cannot Reference it before we
    // Dereference this one.  
    //
    Status = CtxtHandlerHandleToContext(ContextHandle, TRUE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_SUCCESS;
        DebugLog((DEB_TRACE, "SpDeleteContext: CtxtHandlerHandleToContext not found 0x%x\n", Status ));
        goto CleanUp;
    }

    // Need to determine how many reference counts to decrement by - the LSA kept track too
    // This is overly complex logic in that both the LSA and the SSP keep track of the SecurityContext
    // handle reference counts
    if(g_LsaFunctions->GetCallInfo(&CallInfo))
    {
        ulDereferenceCount = CallInfo.CallCount;
        DebugLog((DEB_TRACE, "SpDeleteContext: CallCount for references  0x%x\n", CallInfo.CallCount));
        DebugLog((DEB_TRACE, "SpDeleteContext: Attributes  0x%x\n", CallInfo.Attributes));
        DebugLog((DEB_TRACE, "SpDeleteContext: PID %d  Thread %d\n", CallInfo.ProcessId, CallInfo.ThreadId));
    }

    //  Now deference - there may be other references from pointer references (from Handles)
    //  inside the LSA but will be released
    if (pContext)
    {
        Status = CtxtHandlerRelease(pContext, ulDereferenceCount);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpDeleteContext: DereferenceUserContext error  Status 0x%x\n", Status ));
        }
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpDeleteContext: Leaving ContextHandle 0x%lx    status 0x%x\n",
               ContextHandle, Status ));
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitLsaModeContext
//
//  Synopsis:   Digest implementation of InitializeSecurityContext
//              while in Lsa mode. If we return TRUE in *MappedContext,
//              secur32 will call SpInitUserModeContext with
//              the returned context handle and ContextData
//              as input. Fill in whatever info needed for
//              the user mode APIs
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpInitLsaModeContext(
                    IN OPTIONAL ULONG_PTR CredentialHandle,
                    IN OPTIONAL ULONG_PTR OldContextHandle,
                    IN OPTIONAL PUNICODE_STRING pustrTargetName,
                    IN ULONG fContextReqFlags,
                    IN ULONG TargetDataRep,
                    IN PSecBufferDesc InputBuffers,
                    OUT PULONG_PTR NewContextHandle,
                    IN OUT PSecBufferDesc OutputBuffers,
                    OUT PULONG fContextAttributes,
                    OUT PTimeStamp pExpirationTime,
                    OUT PBOOLEAN MappedContext,
                    OUT PSecBuffer ContextData
                    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "SpInitLsaModeContext: Entering  ContextHandle 0x%x\n", OldContextHandle));

    SecBuffer TempTokens[6];
    PSecBuffer pChalInputToken;
    PSecBuffer pMethodInputToken;
    PSecBuffer pHEntityInputToken;
    PSecBuffer pOutputToken;
    DIGEST_PARAMETER Digest;
    PDIGEST_CONTEXT pNewContext = NULL;            // keep pointer to release new context on error
    PDIGEST_CONTEXT pContext = NULL;               // used to update the context
    BOOL bLockedContext = FALSE;                   // if we obtained a refcount on a Context
    BOOL fDefChars = FALSE;                        // were default chars utilized in Unicode encoding
    USHORT usLen = 0;

    SecBuffer ReplyBuffer;                         // Output is generated in this buffer

    ULONG  fContextAttr = ISC_REQ_REPLAY_DETECT;   // Flags on the Attributes of the context
    DIGEST_TYPE typeDigest = NO_DIGEST_SPECIFIED;
    QOP_TYPE typeQOP = NO_QOP_SPECIFIED;
    ALGORITHM_TYPE typeAlgorithm = NO_ALGORITHM_SPECIFIED;
    CHARSET_TYPE typeCharset = ISO_8859_1;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;  // are we in SASL or HTTP mode


    PDIGEST_CREDENTIAL pCredential = NULL;    
    STRING strcSASLMethod = {0};
    STRING strcSASLHEntity = {0};
    STRING strcNC = {0};
    STRING strTargetName = {0};

    UNREFERENCED_PARAMETER(TargetDataRep);
           
    // Verify Args
    if (!fContextAttributes || !NewContextHandle || !OutputBuffers)
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Invalid arg (possible NULL pointer)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *fContextAttributes = 0;
    *NewContextHandle = NULL;
    if (pExpirationTime)
    {
        *pExpirationTime = g_TimeForever;
    }
    *MappedContext = FALSE;
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;


    // Create pointers to tokens for processing
    pChalInputToken = &TempTokens[0];
    pMethodInputToken = &TempTokens[1];
    pHEntityInputToken = &TempTokens[3];
    pOutputToken = &TempTokens[4];

    ZeroMemory(TempTokens,sizeof(TempTokens));

    ZeroMemory(&ReplyBuffer, sizeof(ReplyBuffer));

    Status = DigestInit(&Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Digest init error status 0x%x\n", Status));
        goto CleanUp;
    }

    // Must have a Credential Handle to perform processing - will ref count 
    Status = CredHandlerHandleToPtr(CredentialHandle, FALSE, &pCredential);
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_UNKNOWN_CREDENTIALS;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Could not locate the Credential\n"));
        goto CleanUp;
    }

    // Verify that credential is marked OUTBOUND for ASC call
    if (!(pCredential->CredentialUseFlags & DIGEST_CRED_OUTBOUND))
    {
        Status = SEC_E_NOT_SUPPORTED;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Credential not marked for Outbound connections\n"));
        goto CleanUp;
    }

    // Retrieve the information from the SecBuffers & check proper formattting
    // Check for NULL input for InputBuffers - as is done for 1st call to ISC
    if (InputBuffers && (InputBuffers->cBuffers))
    {
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 0,   // get the first SECBUFFER_TOKEN
                                 &pChalInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pChalInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (ChalRspInputToken) status 0x%x\n", Status));
            goto CleanUp;
        }
    }

           // Process the output buffer
    if ( !SspGetTokenBufferByIndex( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &pOutputToken,
                             FALSE )  ||
         !ContextIsTokenOK(pOutputToken, 0))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (OutputToken)    status 0x%x\n", Status));
        goto CleanUp;
    }

    if (fContextReqFlags & ISC_REQ_ALLOCATE_MEMORY)
    {
        pOutputToken->pvBuffer = NULL;
        pOutputToken->cbBuffer = 0;
    }

    // To support SASL's call to ISC BEFORE any calls to ASC just return SEC_I_CONTINUE_NEEDED
    if (pChalInputToken->cbBuffer <= 1)
    {
        // Need to create a context for this connection - destroy if unsuccessful auth
        pNewContext = (PDIGEST_CONTEXT)DigestAllocateMemory(sizeof(DIGEST_CONTEXT));
        if (!pNewContext)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: ISC empty context - Out of memory on challenge context\n"));
            goto CleanUp;
        }

        CredPrint(pCredential);

        // Initialize new context
        Status = ContextInit(pNewContext, pCredential);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: ISC empty context - ContextInit error status 0x%x\n", Status));
            goto CleanUp;
        }

        Status = SEC_I_CONTINUE_NEEDED;           // Have no input for processing
        pOutputToken->cbBuffer = 0;          // No output buffer
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: ISC empty context - Called with no Input Buffer    Status 0x%x\n", Status));

        // Add the Newly created Context into the list of Contexts
        pNewContext->lReferences = 1;      // pass reference back to ISC caller
        CtxtHandlerInsertCred(pNewContext);
        // pContext = pNewContext;                        // set to have dereferenced
        *NewContextHandle = (ULONG_PTR)pNewContext;    // Just report back with the updated context
        *fContextAttributes = fContextAttr;            // Return the ISC Attributes set on Context

        // bLockedContext = TRUE;               // Release memory to CtxtHandler
        pNewContext = NULL;                  // We no longer own this memory - turned over to CtxtHandler

        goto CleanUp;
    }

    // Verify SecBuffer inputs - both SASL and HTTP require atleast 1 buffer
    if (!InputBuffers || !InputBuffers->cBuffers)
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Invalid SecBufferDesc\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // We have input in the SECBUFFER 0th location - parse it
    Status = DigestParser2(pChalInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: DigestParser error status 0x%x\n", Status));
        goto CleanUp;
    }

    // Check to see if we have an old context passed in or need to create a new one
    if (OldContextHandle)
    {
        // Old Context passed in - locate the security context and use that
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Passed in OldContextHandle 0x%lx - lookup in list\n", OldContextHandle));
        Status = CtxtHandlerHandleToContext(OldContextHandle, FALSE, &pContext);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: CtxtHandlerHandleToContext error 0x%x\n", Status));
            goto CleanUp;
        }
        bLockedContext = TRUE;
    }
    else
    {
        // Need to create a context for this connection - destroy if unsuccessful auth
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: No OldContextHandle - create new Context\n"));
        pNewContext = (PDIGEST_CONTEXT)DigestAllocateMemory(sizeof(DIGEST_CONTEXT));
        if (!pNewContext)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: out of memory on challenge context\n"));
            goto CleanUp;
        }
    
        CredPrint(pCredential);
    
        // Initialize new context
        Status = ContextInit(pNewContext, pCredential);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: ContextInit error status 0x%x\n", Status));
            goto CleanUp;
        }
        pContext = pNewContext;                       // for filling in the context information
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: New Context Created   0x%x\n", pContext));
    }

    if (pContext && pContext->strResponseAuth.Length)
    {
        // We have already generated session key from challenge response
        // now checking response auth from server

        if (Digest.refstrParam[MD5_AUTH_RSPAUTH].Length != MD5_HASH_HEX_SIZE)
        {
            Status = STATUS_MUTUAL_AUTHENTICATION_FAILED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: RspAuth incorrect size\n"));
            goto CleanUp;
        }

        // Now compare the response auth strings
        if (!RtlEqualString(&(pContext->strResponseAuth),
                           &(Digest.refstrParam[MD5_AUTH_RSPAUTH]),
                           FALSE))
        {
            Status = STATUS_MUTUAL_AUTHENTICATION_FAILED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: RspAuth is incorrect\n"));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpInitLsaModeContext: RspAuth matches!\n"));

        // ResponseAuth is verified - generate mapped context
        *fContextAttributes = pContext->ContextReq; // Return the ISC Attributes set on Context
        *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context
        pOutputToken->cbBuffer = 0;          // No output buffer
        if (pExpirationTime)
        {
            *pExpirationTime = pContext->ExpirationTime;
        }

        Status = SspMapDigestContext(pContext, NULL, FLAG_CONTEXT_REFCOUNT, ContextData);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext, SspMapContext Status 0x%x\n", Status));
            goto CleanUp;
        }

        // this is final call, indicate to map the context
        *MappedContext = TRUE;

        goto CleanUp;
    }


    // Determine if we are in HTTP or SASL mode
    // SASL mode has 1 or less buffers provided,  HTTP has 3
    if (InputBuffers->cBuffers > 1)
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }
    else
    {
        typeDigestMode = DIGESTMODE_SASL;
    }

        // HTTP has special Buffer needs in that it must pass in the METHOD, HEntity
    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 1,   // get the second SECBUFFER_TOKEN 
                                 &pMethodInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pMethodInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {                           // Check to make sure that string is present
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (MethodInputToken) status 0x%x\n", Status));
            goto CleanUp;
        }

        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 2,   // get the third SECBUFFER_TOKEN
                                 &pHEntityInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pHEntityInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspGetTokenBufferByIndex (HEntityInputToken)   status 0x%x\n", Status));
            goto CleanUp;
        }

        // Verify that there is a valid Method provided
        if (!pMethodInputToken->pvBuffer || !pMethodInputToken->cbBuffer ||
            (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }

        usLen = strlencounted((char *)pMethodInputToken->pvBuffer, (USHORT)pMethodInputToken->cbBuffer);
        if (!usLen)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }
        Digest.refstrParam[MD5_AUTH_METHOD].Length = usLen;
        Digest.refstrParam[MD5_AUTH_METHOD].MaximumLength = (unsigned short)(pMethodInputToken->cbBuffer);
        Digest.refstrParam[MD5_AUTH_METHOD].Buffer = (char *)pMethodInputToken->pvBuffer;       // refernce memory - no alloc!!!!

        // Check to see if we have H(Entity) data to utilize


        if (pHEntityInputToken->cbBuffer)
        {
            // Verify that there is a valid Method provided
            if (!pHEntityInputToken->pvBuffer || (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: HEntity SecBuffer must have valid string status 0x%x\n", Status));
                goto CleanUp;
            }

            usLen = strlencounted((char *)pHEntityInputToken->pvBuffer, (USHORT)pHEntityInputToken->cbBuffer);

            if ((usLen != 0) && (usLen != (MD5_HASH_BYTESIZE * 2)))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: HEntity SecBuffer must have valid MD5 Hash data 0x%x\n", Status));
                goto CleanUp;
            }

            if (usLen)
            {
                Digest.refstrParam[MD5_AUTH_HENTITY].Length = usLen;
                Digest.refstrParam[MD5_AUTH_HENTITY].MaximumLength = (unsigned short)(pHEntityInputToken->cbBuffer);
                Digest.refstrParam[MD5_AUTH_HENTITY].Buffer = (char *)pHEntityInputToken->pvBuffer;       // refernce memory - no alloc!!!!
            }
        }

        typeDigest = DIGEST_CLIENT;


        // Determine which Algorithm to support under HTTP
        Status = CheckItemInList(MD5_SESSSTR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // Check if MD5 specified (or none specified so MD5 defaults)
            Status = CheckItemInList(MD5STR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
            if (NT_SUCCESS(Status) || (Digest.refstrParam[MD5_AUTH_ALGORITHM].Length == 0))
            {
                typeAlgorithm = MD5;
                fContextAttr |= (ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT);
                DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows MD5 (or defaulted); selected as algorithm\n"));
            }
            else
            {
                Status = SEC_E_QOP_NOT_SUPPORTED;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: Unknown Server algorithms provided\n"));
                goto CleanUp;
            }
        }
        else
        {
            typeAlgorithm = MD5_SESS;
            fContextAttr |= (ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT);
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows MD5-sess; selected as algorithm\n"));
        }
    }
    else
    {
        // All others follow the SASL Interface so there are default values
        typeDigest = SASL_CLIENT;
        fContextAttr |= ISC_RET_MUTUAL_AUTH;   // require response auth from server

        // SASL supports only MD5-Sess verify that server offered this
        Status = CheckItemInList(MD5_SESS_SASLSTR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Unknown Server algorithm provided\n"));
            goto CleanUp;
        }
        else
        {
            typeAlgorithm = MD5_SESS;
            fContextAttr |= (ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT);
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows MD5-sess; selected as algorithm\n"));
        }


        // Set Method to Authenticate
        RtlInitString(&strcSASLMethod, AUTHENTICATESTR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_METHOD]), &strcSASLMethod);  // refernce memory - no alloc!!!!

        RtlInitString(&strcSASLHEntity, ZERO32STR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_HENTITY]), &strcSASLHEntity);  // refernce memory - no alloc!!!!

    }

    // Determine if we can process the QOP specified - check return in client if consistent
    if (fContextReqFlags & ISC_REQ_CONFIDENTIALITY)
    {
        // make sure that server presented the auth-conf option
        Status = CheckItemInList(AUTHCONFSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // Failed to provide necessary QOP
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Server failed to provide QOP=AUTH-CONF\n"));
            goto CleanUp;
        }
        // OK agreed to QOP
        fContextAttr |= (ISC_RET_CONFIDENTIALITY | ISC_RET_INTEGRITY);
        typeQOP = AUTH_CONF;
    }
    else if (fContextReqFlags & ISC_REQ_INTEGRITY)
    {
        // make sure that server presented the auth-int option
        Status = CheckItemInList(AUTHINTSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // Failed to provide necessary QOP
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Server failed to provide QOP=AUTH-INT\n"));
            goto CleanUp;
        }
        // OK agreed to QOP
        fContextAttr |= ISC_RET_INTEGRITY;
        typeQOP = AUTH_INT;
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Client selected QOP=AUTH-INT\n"));
    }
    else
    {
        // no client specified QOP so use auth if allowed  (backwards compat may have no QOP presented from server)
        Status = CheckItemInList(AUTHSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // either QOP is not specified or all options are unknown
            if (Digest.refstrParam[MD5_AUTH_QOP].Length == 0)
            {
                if (typeDigestMode == DIGESTMODE_HTTP)
                {
                    // Backwards compatibility with RFC 2069
                    typeQOP = NO_QOP_SPECIFIED;
                    DebugLog((DEB_TRACE, "SpInitLsaModeContext: No QOP specified - back compat with RFC 2069\n"));
                }
                else
                {
                    // in SASL mode - if no qop specified, defaults to AUTH
                    typeQOP = AUTH;
                    DebugLog((DEB_TRACE, "SpInitLsaModeContext: no QOP specified - default to AUTH in SASL mode\n"));
                }
            }
            else
            {
                Status = SEC_E_QOP_NOT_SUPPORTED;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: Server failed to provide QOP=AUTH\n"));
                goto CleanUp;
            }
        }
        else
        {
            // defaulting to AUTH
            typeQOP = AUTH;
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Client selected QOP=AUTH by default\n"));
        }
    }

    // Check to see if the Server has provided character set for encoding - only UTF-8 accepted
    Status = CheckItemInList(MD5_UTF8STR, &(Digest.refstrParam[MD5_AUTH_CHARSET]), TRUE);
    if (NT_SUCCESS(Status))
    {
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server allows UTF-8 encoding\n"));

        // Determine which character set to utilize
        if (((typeDigest == SASL_CLIENT) && (g_fParameter_UTF8SASL == TRUE)) ||
            ((typeDigest == DIGEST_CLIENT) && (g_fParameter_UTF8HTTP == TRUE)))
        {
            typeCharset = UTF_8;
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selected UTF-8 encoding\n"));
        }
        else
        {
            typeCharset = ISO_8859_1;
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selected ISO 8859-1 encoding\n"));
        }
    }

    // Pull in the URI provided in TargetName - replace any value in challenge string - link ONLY no allocate
    if (!pustrTargetName)
    {
        Status = SEC_E_TARGET_UNKNOWN;
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: URI TargetName must have valid UnicodeString\n"));
        goto CleanUp;
    }

    Status = EncodeUnicodeString(pustrTargetName, CP_8859_1, &strTargetName, &fDefChars);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "SpInitLsaModeContext: Error in encoding target URI in ISO-8859-1\n"));
        goto CleanUp;
    }

    if (fDefChars == TRUE)
    {
        // We could not encode the provided target URI within ISO 8859-1 characters
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: Target URI can not be encoded in ISO 8859-1\n"));
        Status = STATUS_UNMAPPABLE_CHARACTER;
        goto CleanUp;
    }

    StringReference(&(Digest.refstrParam[MD5_AUTH_URI]), &strTargetName);  // refernce memory - no alloc!!!!

            // Create the CNonce
    Status = OpaqueCreate(&(pContext->strCNonce));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: OpaqueCreate for CNonce      status 0x%x\n", Status));
        goto CleanUp;
    }

    // Establish the Client Nonce
    StringReference(&(Digest.refstrParam[MD5_AUTH_CNONCE]), &(pContext->strCNonce));  // refernce memory - no alloc!!!!


    // Keep a copy of the Nonce and Cnonce for future Delegation requests (actually not used in client ISC)
    Status = StringDuplicate(&pContext->strNonce, &Digest.refstrParam[MD5_AUTH_NONCE]);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: StringDuplicate CNonce failed      status 0x%x\n", Status));
        goto CleanUp;
    }
    
    RtlInitString(&strcNC, NCFIRST);
    StringReference(&(Digest.refstrParam[MD5_AUTH_NC]), &strcNC);  // refernce memory - no alloc!!!!

    // Set the type of Digest Parameters we are to process
    pContext->typeDigest = typeDigest;
    pContext->typeAlgorithm = typeAlgorithm;
    pContext->typeQOP = typeQOP;
    pContext->typeCipher = CIPHER_UNDEFINED;
    pContext->typeCharset = typeCharset;    // Digest parameter will be set in DigestGenerateParameters call

    if (pContext->typeQOP == AUTH_CONF)
    {
        // Check if server offered RC4  Most cases this will be the cipher selected
        Status = CheckItemInList(STR_CIPHER_RC4, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
        if (NT_SUCCESS(Status))
        {
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting RC4 for auth-conf cipher\n"));
            pContext->typeCipher = CIPHER_RC4;
        }
        else
        {
            Status = CheckItemInList(STR_CIPHER_3DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
            if (NT_SUCCESS(Status))
            {
                DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting Triple DES for auth-conf cipher\n"));
                pContext->typeCipher = CIPHER_3DES;
            }
            else
            {
                Status = CheckItemInList(STR_CIPHER_RC4_56, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
                if (NT_SUCCESS(Status))
                {
                    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting RC4-56 for auth-conf cipher\n"));
                    pContext->typeCipher = CIPHER_RC4_56;
                }
                else
                {
                    Status = CheckItemInList(STR_CIPHER_RC4_40, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
                    if (NT_SUCCESS(Status))
                    {
                        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting RC4-40 for auth-conf cipher\n"));
                        pContext->typeCipher = CIPHER_RC4_40;
                    }
                    else
                    {
                        Status = CheckItemInList(STR_CIPHER_DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), FALSE);
                        if (NT_SUCCESS(Status))
                        {
                            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Selecting DES for auth-conf cipher\n"));
                            pContext->typeCipher = CIPHER_DES;
                        }
                        else
                        {
                            DebugLog((DEB_ERROR, "SpInitLsaModeContext: Failed to find known ciper in list\n"));
                            Status = STATUS_CRYPTO_SYSTEM_INVALID;
                            goto CleanUp;
                        }
                    }
                }
            }
        }
    }

    // Check if server specified a MaxBuffer
    if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length && Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer)
    {
        if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length < MAXBUFNUMLEN)
        {
            ULONG ulMaxBuf = 0;
            CHAR  czMaxBuf[MAXBUFNUMLEN + 1];

            ZeroMemory(czMaxBuf, (MAXBUFNUMLEN + 1));
            memcpy(czMaxBuf, Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer, Digest.refstrParam[MD5_AUTH_MAXBUF].Length);

            Status = RtlCharToInteger(czMaxBuf, TENBASE, &ulMaxBuf);
            if (!NT_SUCCESS(Status))
            {
                Status =  SEC_E_ILLEGAL_MESSAGE;
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: MaxBuf directive value malformed 0x%x\n", Status));
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: Server MaxBuf set to %lu\n", ulMaxBuf));
            pContext->ulSendMaxBuf = ulMaxBuf;
        }
        else
        {
            Status =  SEC_E_ILLEGAL_MESSAGE;
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: MaxBuf directive value too large 0x%x\n", Status));
            goto CleanUp;
        }
    }

    // We now have completed setup for the digest fields - time to process the data

    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Digest inputs processing completed\n"));

    ContextPrint(pContext);

    // Verify the directives utilized
    Status = DigestDirectiveCheck(&Digest, typeDigest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: DigestDirectiveCheck error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = DigestGenerateParameters(pContext, &Digest, &ReplyBuffer);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpInitLsaModeContext: DigestGenerateParameters error  status 0x%x\n", Status));
        goto CleanUp;
    }

        // Now transfer the Challenge buffer to the ouput secbuffer
    if ((fContextReqFlags & ISC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if (pOutputToken->cbBuffer < ReplyBuffer.cbBuffer)
        {
            DebugLog((DEB_ERROR,"SpInitLsaModeContext: Output token is too small - sent in %d, needed %d\n",
                pOutputToken->cbBuffer, ReplyBuffer.cbBuffer));
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanUp;
        }

        RtlCopyMemory(pOutputToken->pvBuffer, ReplyBuffer.pvBuffer, ReplyBuffer.cbBuffer);
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
    }
    else
    {
        pOutputToken->pvBuffer = ReplyBuffer.pvBuffer;
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
        fContextAttr |= ISC_RET_ALLOCATED_MEMORY;
    }

    pContext->ContextReq = fContextAttr;
    pContext->ExpirationTime = g_TimeForever;   // never expire

    *fContextAttributes = pContext->ContextReq; // Return the ISC Attributes set on Context
    *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context
    if (pExpirationTime)
    {
        *pExpirationTime = pContext->ExpirationTime;

        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Context Expiration TimeStamp  high/low 0x%x/0x%x\n",
                  pExpirationTime->HighPart, pExpirationTime->LowPart));
    }

    // Check if need to check server's response auth
    if (pContext->ContextReq & ISC_RET_MUTUAL_AUTH)
    {
        // Calculate the expected response auth from the server
        Status = DigestCalculateResponseAuth(&Digest, &(pContext->strResponseAuth));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext, DigestCalculateResponseAuth Status 0x%x\n",
                       Status));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Pre-calculated RspAuth %Z\n",
                  &(pContext->strResponseAuth)));

        // Keep copy of digest values for context map on last ISC call
        for (int iTemp = 0; iTemp < MD5_AUTH_LAST; iTemp++)
        {
            Status = StringDuplicate(&pContext->strDirective[iTemp], &(Digest.refstrParam[iTemp]));
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpInitLsaModeContext: Failed to copy directives   Status 0x%x\n", Status));
                goto CleanUp;
            }
        }

        // Need to verify the output from final ASC call to verify server has session key
        Status = SEC_I_CONTINUE_NEEDED;
    }
    else
    {
        Status = SspMapDigestContext(pContext, &Digest, FLAG_CONTEXT_REFCOUNT, ContextData);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext: SspMapContext Status 0x%x\n", Status));
            goto CleanUp;
        }

        // this is last call, indicate to map the context
        *MappedContext = TRUE;
    }

    // Add the Newly created Context into the list of Contexts unless it was there before
    if (pNewContext)
    {
        DebugLog((DEB_TRACE, "SpInitLsaModeContext: Added context   0x%x\n", pNewContext));
        pNewContext->lReferences = 1;
        CtxtHandlerInsertCred(pNewContext);
        // bLockedContext = TRUE;               // Release memory to CtxtHandler
        pNewContext = NULL;                  // We no longer own this memory - turned over to CtxtHandler
    }

    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Will create UserContext on exit\n"));

CleanUp:

    // Failed to complete operations if non-NULL so clean up
    if (pNewContext)
    {
        ContextFree(pNewContext);
        pNewContext = NULL;
    }

    // On Failure - clean up any allocated memory
    if (!NT_SUCCESS(Status))
    {
        // Clear up any mapped data
        *MappedContext = FALSE;
        if (ContextData->pvBuffer)
        {
            g_LsaFunctions->FreeLsaHeap(ContextData->pvBuffer);
            ContextData->pvBuffer = NULL;
            ContextData->cbBuffer = 0;
        }
    }

    // DeReference - pCredential
    if (pCredential)
    {
        SubStatus = CredHandlerRelease(pCredential);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: CredHandlerRelease error  Status 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
        pCredential = NULL;
    }

    if (bLockedContext && pContext)
    {   // happened only if ref counted a SecurityContext
        SubStatus = CtxtHandlerRelease(pContext, 1);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpInitLsaModeContext: CtxtHandlerRelease error Status 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
        pContext = NULL;
    }

        // Free up any allocated memory from the ouput reply buffer
    if (ReplyBuffer.pvBuffer)
    {
        DigestFreeMemory(ReplyBuffer.pvBuffer);
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
    }

    // Clean up local memory used by Digest
    DigestFree(&Digest);

    StringFree(&strTargetName);

    DebugLog((DEB_TRACE, "SpInitLsaModeContext: Mapped context %d    Flags IN:0x%lx  OUT:0x%lx\n",
               *MappedContext, fContextReqFlags,*fContextAttributes));

    DebugLog((DEB_TRACE_FUNC, "SpInitLsaModeContext: Leaving  Context 0x%x   Status 0x%x\n", *NewContextHandle, Status));

    return(Status);
}



NTSTATUS NTAPI
SpApplyControlToken(
                   IN ULONG_PTR ContextHandle,
                   IN PSecBufferDesc ControlToken
                   )
{
    DebugLog((DEB_TRACE_FUNC, "SpApplyControlToken: Entering/Leaving \n"));
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(ControlToken);
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptLsaModeContext
//
//  Synopsis:   Digest implementation of AcceptSecurityContext call.
//
//  Effects:
//
//  Arguments:
//   CredentialHandle - Handle to the credentials to be used to
//       create the context.
//
//   OldContextHandle - Handle to the partially formed context, if this is
//       a second call (see above) or NULL if this is the first call.
//
//   InputToken - Pointer to the input token.  In the first call this
//       token can either be NULL or may contain security package specific
//       information.
//
//   ContextReqFlags - Requirements of the context, package specific.
//
//      #define ASC_REQ_REPLAY_DETECT    0x00000004
//      #define ASC_REQ_SEQUENCE_DETECT  0x00000008
//      #define ASC_REQ_CONFIDENTIALITY  0x00000010
//      #define ASC_REQ_ALLOCATE_MEMORY 0x00000100
//
//   TargetDataRep - Long indicating the data representation (byte ordering, etc)
//        on the target.  The constant SECURITY_NATIVE_DREP may be supplied
//        by the transport indicating that the native format is in use.
//
//   NewContextHandle - New context handle.  If this is a second call, this
//       can be the same as OldContextHandle.
//
//   OutputToken - Buffer to receive the output token.
//
//   ContextAttributes -Attributes of the context established.
//
//        #define ASC_RET_REPLAY_DETECT     0x00000004
//        #define ASC_RET_SEQUENCE_DETECT   0x00000008
//        #define ASC_RET_CONFIDENTIALITY   0x00000010
//        #define ASC_RET_ALLOCATED_BUFFERS 0x00000100
//
//   ExpirationTime - Expiration time of the context.
//
//
//  Requires:
//
//  Returns:
//    STATUS_SUCCESS - Message handled
//    SEC_I_CONTINUE_NEEDED -- Caller should call again later
//
//    SEC_E_NO_SPM -- Security Support Provider is not running
//    SEC_E_INVALID_TOKEN -- Token improperly formatted
//    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
//    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
//    SEC_E_LOGON_DENIED -- User is no allowed to logon to this server
//    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpAcceptLsaModeContext(
                      IN OPTIONAL ULONG_PTR CredentialHandle,
                      IN OPTIONAL ULONG_PTR OldContextHandle,
                      IN PSecBufferDesc InputBuffers,
                      IN ULONG fContextReqFlags,
                      IN ULONG TargetDataRep,
                      OUT PULONG_PTR NewContextHandle,
                      OUT PSecBufferDesc OutputBuffers,
                      OUT PULONG fContextAttributes,
                      OUT PTimeStamp pExpirationTime,
                      OUT PBOOLEAN MappedContext,
                      OUT PSecBuffer ContextData
                      )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    NTSTATUS AuditLogStatus = STATUS_SUCCESS;
    NTSTATUS AuditLogSubStatus = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "SpAcceptLsaModeContext: Entering  ContextHandle 0x%x\n", OldContextHandle));

    SecBuffer TempTokens[6];
    PSecBuffer pChalRspInputToken;
    PSecBuffer pMethodInputToken;
    PSecBuffer pURIInputToken;
    PSecBuffer pHEntityInputToken;
    PSecBuffer pOutputToken;
    PSecBuffer pRealmInputToken;
    DIGEST_PARAMETER Digest;
    PDIGEST_CONTEXT pNewContext = NULL;            // keep pointer to release new context on error
    BOOL bLockedCredential = FALSE;
    BOOL bLockedContext = FALSE;
    BOOL fLogonSessionCreated = FALSE;

    SecBuffer ReplyBuffer;                         // Output is generated in this buffer

    USHORT usLen = 0;
    char *cptr = NULL;
    ULONG  fContextAttr = ASC_REQ_REPLAY_DETECT;    // Flags on the Attributes of the context
    ULONG  ulFlagOptions = 0;
    DIGEST_TYPE typeDigest = NO_DIGEST_SPECIFIED;
    QOP_TYPE typeQOP = NO_QOP_SPECIFIED;
    ALGORITHM_TYPE typeAlgorithm = NO_ALGORITHM_SPECIFIED;
    CHARSET_TYPE typeCharset = ISO_8859_1;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode

    PDIGEST_CREDENTIAL pCredential = NULL; 
    PDIGEST_CONTEXT pContext = NULL; 

    STRING strcMethod = {0};
    STRING strcHEntity = {0};
    STRING strRealm = {0};
    UNICODE_STRING refustrRealm = {0};
    PUNICODE_STRING  pustrAuditAccountName = NULL;
    PUNICODE_STRING  pusrtAuditDomain = NULL;

    BOOL fDefChars = FALSE;
    BOOL fGenerateAudit = FALSE;
    DWORD dwInfoLen = 0;
    SECPKG_CALL_INFO CallInfo = {0};

    UNREFERENCED_PARAMETER(TargetDataRep);

    // Create pointers to tokens for processing
    pChalRspInputToken = &TempTokens[0];
    pMethodInputToken = &TempTokens[1];
    pURIInputToken = &TempTokens[2];
    pHEntityInputToken = &TempTokens[3];
    pRealmInputToken = &TempTokens[4];
    pOutputToken = &TempTokens[5];

    ZeroMemory(TempTokens,sizeof(TempTokens));

    ZeroMemory(&ReplyBuffer, sizeof(ReplyBuffer));

    Status = DigestInit(&Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Digest init error status 0x%x\n", Status));
        goto CleanUp;
    }

      // Initialize the output values
    if (!fContextAttributes || !NewContextHandle || !InputBuffers || !OutputBuffers)
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Invalid arg (possible NULL pointer)\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *NewContextHandle = (ULONG_PTR)NULL;
    *MappedContext = FALSE;
    *fContextAttributes = 0;
    if (pExpirationTime)
    {
        *pExpirationTime = g_TimeForever;
    }
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;


    if(g_LsaFunctions->GetCallInfo(&CallInfo))
    {
        // For this release - we do not support server side calls in kernel mode
        if ((CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE) != 0)
        {
            DebugLog((DEB_WARN, "SpAcceptLsaModeContext: Server side SSP functions not supported\n"));
            return SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    // Determine if we are in HTTP or SASL mode
    // SASL mode has 1 or less buffers provided,  HTTP has 5
    if (InputBuffers->cBuffers > 1)
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }
    else
    {
        typeDigestMode = DIGESTMODE_SASL;
    }

    // Must have a Credential Handle to perform processing
    Status = CredHandlerHandleToPtr(CredentialHandle, FALSE, &pCredential);
    if (!NT_SUCCESS(Status))
    {
        Status = SEC_E_UNKNOWN_CREDENTIALS;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: No Credential Handle passed\n"));
        goto CleanUp;
    }
    bLockedCredential = TRUE;


    // Verify that credential is marked INBOUND for ASC call
    if (!(pCredential->CredentialUseFlags & DIGEST_CRED_INBOUND))
    {
        Status = SEC_E_NOT_SUPPORTED;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Credential not marked for Inbound connections\n"));
        goto CleanUp;
    }

    // Retrieve the information from the SecBuffers & check proper formattting

    // First check to make sure that that the proper number of buffers were passed
    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        // HTTP has 5 buffers in Input: ChallengeResponse, Method, URI, HEntity, Realm
        if ((InputBuffers->cBuffers < ASC_HTTP_NUM_INPUT_BUFFERS) ||
            (OutputBuffers->cBuffers < ASC_HTTP_NUM_OUTPUT_BUFFERS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Incorrect number of Input/Output HTTP Sec Buffers\n"));
            goto CleanUp;
        }
    }
    else
    {
        // SASL has 1 buffer in Input: ChallengeResponse
        if ((InputBuffers->cBuffers < ASC_SASL_NUM_INPUT_BUFFERS) ||
            (OutputBuffers->cBuffers < ASC_SASL_NUM_OUTPUT_BUFFERS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Incorrect number of Input/Ouput SASL Sec Buffers\n"));
            goto CleanUp;
        }
        fContextAttr |= ASC_RET_MUTUAL_AUTH;   // SASL requires response auth from server
    }

    if ( !SspGetTokenBufferByIndex( InputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &pChalRspInputToken,
                             TRUE ) ||
         !ContextIsTokenOK(pChalRspInputToken,NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (ChalRspInputToken) returns 0x%x\n", Status));
        goto CleanUp;
    }

    if ( !SspGetTokenBufferByIndex( OutputBuffers,
                             0,   // get the first SECBUFFER_TOKEN
                             &pOutputToken,
                             FALSE )  ||
         !ContextIsTokenOK(pOutputToken, 0))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext, SspGetTokenBufferByIndex (OutputToken) returns 0x%x\n", Status));
        goto CleanUp;
    }


    if (fContextReqFlags & ASC_REQ_ALLOCATE_MEMORY)
    {
        pOutputToken->pvBuffer = NULL;
        pOutputToken->cbBuffer = 0;
    }

    // Reset output buffer if provided
    if ((pOutputToken->pvBuffer) && (pOutputToken->cbBuffer >= 1))
    {
        cptr = (char *)pOutputToken->pvBuffer;
        *cptr = '\0';
    }

    //
    // If no ChallengeResponse data provided (only NULL in buffer), then this is the first call
    // Determine a nonce, open up a null context, and return it. Return SEC_E_INCOMPLETE_MESSAGE to
    // indicate that a challenge-response is expected
    //

    if ((!pChalRspInputToken->pvBuffer) || (pChalRspInputToken->cbBuffer <= 1))
    {

        pNewContext = (PDIGEST_CONTEXT)DigestAllocateMemory(sizeof(DIGEST_CONTEXT));
        if (!pNewContext)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: out of memory on challenge context\n"));
            goto CleanUp;
        }
        Status = ContextInit(pNewContext, pCredential);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: ContextInit error 0x%x\n", Status));
            goto CleanUp;
        }
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Context created 0x%x\n", pNewContext));

        if (typeDigestMode == DIGESTMODE_HTTP)
        {
           typeDigest = DIGEST_SERVER;
        }
        else
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: SASL Requested\n"));
            typeDigest = SASL_SERVER;
        }
        pNewContext->typeDigest = typeDigest;

        // Determine which character set to utilize
        if (((typeDigest == SASL_SERVER) && (g_fParameter_UTF8SASL == TRUE)) ||
            ((typeDigest == DIGEST_SERVER) && (g_fParameter_UTF8HTTP == TRUE)))
        {
            typeCharset = UTF_8;
        }
        else
        {
            typeCharset = ISO_8859_1;
        }
        pNewContext->typeCharset = typeCharset;
        
        // We will use the Opaque as the CNonce
        Status = OpaqueCreate(&(pNewContext->strOpaque));
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: OpaqueCreate error 0x%x\n", Status));
            goto CleanUp;
        }

        Status = NonceCreate(&(pNewContext->strNonce));
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: NonceCreate error 0x%x\n", Status));
            goto CleanUp;
        }

        if (pNewContext->typeDigest == DIGEST_SERVER)
        {
           // Now see if a Realm was passed in to use for this challenge - the value could be single byte or Unicode 
           // Order is if realm passed to ASC use that, else  just use the current domain name

           if ( !SspGetTokenBufferByIndex( InputBuffers,
                                    4,   // get the fifth SECBUFFER_TOKEN
                                    &pRealmInputToken,
                                    TRUE ) ||
                !ContextIsTokenOK(pRealmInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
           {
               Status = SEC_E_INVALID_TOKEN;
               DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (RealmInputToken) returns 0x%x\n", Status));
               goto CleanUp;
           }

           if (pRealmInputToken->pvBuffer)
           {
               if (PBUFFERTYPE(pRealmInputToken) != SECBUFFER_PKG_PARAMS)
               {
                   Status = SEC_E_INVALID_TOKEN;
                   DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Realm buffer type invalid   error 0x%x\n", Status));
                   goto CleanUp;
               }

               if (pRealmInputToken->cbBuffer)
               {
                   usLen = ustrlencounted((const short *)pRealmInputToken->pvBuffer, (USHORT)pRealmInputToken->cbBuffer);
                   if (usLen > 0)
                   {
                       refustrRealm.Length = usLen * sizeof(WCHAR);
                       refustrRealm.MaximumLength = (unsigned short)(pRealmInputToken->cbBuffer);
                       refustrRealm.Buffer = (PWSTR)pRealmInputToken->pvBuffer;       // refernce memory - no alloc!!!!

                       // For compat with RFC, the Realm must be encoded in ISO 8859-1
                       Status = EncodeUnicodeString(&refustrRealm, CP_8859_1, &strRealm, &fDefChars);
                       if (!NT_SUCCESS(Status))
                       {
                           DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Input Realm ISO 8859-1 encoding error\n"));
                           goto CleanUp;
                       }
                       if (fDefChars == TRUE)
                       {
                           // We could not encode the provided Realm within ISO 8859-1 characters
                           DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Input Realm can not be encoded in ISO 8859-1\n"));
                           Status = STATUS_UNMAPPABLE_CHARACTER;
                           goto CleanUp;
                       }

                   }
               }
               else
               {
                   DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: a blank realm is requested\n"));
                   Status = StringAllocate(&strRealm, 1);
                   if (!NT_SUCCESS(Status))
                   {
                       DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: setting blank realm   error\n"));
                       goto CleanUp;
                   }
                   strRealm.Length = 0;     // indicate blank realm
               }
           }
           
        }

        typeAlgorithm = MD5_SESS;
        pNewContext->typeAlgorithm = typeAlgorithm;

        // Determine if we can process the QOP specified
        if (fContextReqFlags & ASC_REQ_CONFIDENTIALITY)
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: AUTH-CONF requested\n"));
            fContextAttr |= (ASC_RET_CONFIDENTIALITY | ASC_REQ_INTEGRITY);
            typeQOP = AUTH_CONF;               // Offer AUTH-CONF, AUTH_INT, and AUTH
        }
        else if (fContextReqFlags & ASC_REQ_INTEGRITY)
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: AUTH-INT requested\n"));
            fContextAttr |= ASC_RET_INTEGRITY;
            typeQOP = AUTH_INT;               // Offer AUTH-INT and AUTH
        }
        else
            typeQOP = AUTH;                   // Offer AUTH

        pNewContext->typeQOP = typeQOP;

        // Establish the attribute flags for this security context
        pNewContext->ContextReq = fContextAttr;

        Status = ContextCreateChal(pNewContext, &strRealm, &ReplyBuffer);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Failed to create Challenge   status 0x%x\n", Status));
            goto CleanUp;
        }

            // Now transfer the Challenge buffer to the ouput secbuffer
        if ((fContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if (pOutputToken->cbBuffer < ReplyBuffer.cbBuffer)
            {
                DebugLog((DEB_ERROR,"SpAcceptLsaModeContext:Output token is too small - sent in %d, needed %d\n",
                    pOutputToken->cbBuffer, ReplyBuffer.cbBuffer));
                pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
                Status = STATUS_BUFFER_TOO_SMALL;
                goto CleanUp;
            }

            RtlCopyMemory(pOutputToken->pvBuffer, ReplyBuffer.pvBuffer, ReplyBuffer.cbBuffer);
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
        }
        else
        {
            pOutputToken->pvBuffer = ReplyBuffer.pvBuffer;
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
            ReplyBuffer.pvBuffer = NULL;
            ReplyBuffer.cbBuffer = 0;
            fContextAttr |= ASC_RET_ALLOCATED_MEMORY;
        }

        // Update any new attributes
        pNewContext->ContextReq = fContextAttr;

        // Set the time expiration for this context
        // This time is in 100 Nanoseconds since 1604

        pNewContext->ExpirationTime = g_TimeForever;       // Need to implement stale=true if enable
#if 0
        Status = NtQuerySystemTime (&liContextTime);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Failed to get current time\n"));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Current TimeStamp  high/low 0x%x/0x%x\n",
                  liContextTime.HighPart, liContextTime.LowPart));

        PrintTimeString(liContextTime, TRUE);

        // g_dwParameter_Lifetime is in number of seconds - convert to number of 100 nanoseconds
        liContextTime.QuadPart += ((LONGLONG)g_dwParameter_Lifetime * (LONGLONG)SECONDS_TO_100NANO);
        if (pExpirationTime)
        {
            *pExpirationTime = liContextTime;

            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Context Expiration TimeStamp  high/low 0x%x/0x%x\n",
                      pExpirationTime->HighPart, pExpirationTime->LowPart));

            PrintTimeString(liContextTime, TRUE);
        }
 
        pNewContext->ExpirationTime = liContextTime;
#endif

        pNewContext->lReferences = 1;

        // Map the partially formed context over to application space to support re-connect for ref counts on usercontext
        Status = SspMapDigestContext(pNewContext, &Digest,
                                     (FLAG_CONTEXT_REFCOUNT | FLAG_CONTEXT_PARTIAL | FLAG_CONTEXT_SERVER), ContextData);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext, SspMapContext returns %d\n", Status));
            goto CleanUp;
        }

        *MappedContext = TRUE;

        // Add it into the list of Contexts
        CtxtHandlerInsertCred(pNewContext);
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Context added to list Opaque = %s\n", (pNewContext->strOpaque).Buffer));
        *NewContextHandle = (ULONG_PTR)pNewContext;
        *fContextAttributes = fContextAttr;            // Return the ASC Attributes set on Context
        pNewContext = NULL;                  // We no longer own this memory - turned over to CtxtHandler
        Status = SEC_I_CONTINUE_NEEDED;
        goto CleanUp;
    }

    // Processing ChallengeResponse (challenge was handled right before this
    // We have input in the SECBUFFER 0th location - parse it
    Status = DigestParser2(pChalRspInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestParser error 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: DigestParser Returned OK\n"));

    // HTTP has special Buffer needs in that it must pass in the METHOD, HEntity
    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 1,   // get the second SECBUFFER_TOKEN 
                                 &pMethodInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pMethodInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {                           // Check to make sure that string is present
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (MethodInputToken) returns 0x%x\n", Status));
            goto CleanUp;
        }

        /*                         // Not used in this version, may be used in the future
        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 2,   // get the third SECBUFFER_TOKEN
                                 &pURIInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pURIInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (URIInputToken) returns %d\n", Status));
            goto CleanUp;
        }
        */

        if ( !SspGetTokenBufferByIndex( InputBuffers,
                                 3,   // get the forth SECBUFFER_TOKEN
                                 &pHEntityInputToken,
                                 TRUE ) ||
             !ContextIsTokenOK(pHEntityInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: SspGetTokenBufferByIndex (HEntityInputToken) returns 0x%x\n", Status));
            goto CleanUp;
        }


        // Verify that there is a valid Method provided
        if (!pMethodInputToken->pvBuffer || !pMethodInputToken->cbBuffer ||
            (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }

        usLen = strlencounted((char *)pMethodInputToken->pvBuffer, (USHORT)pMethodInputToken->cbBuffer);
        if (!usLen)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Method SecBuffer must have valid method string status 0x%x\n", Status));
            goto CleanUp;
        }
        Digest.refstrParam[MD5_AUTH_METHOD].Length = usLen;
        Digest.refstrParam[MD5_AUTH_METHOD].MaximumLength = (unsigned short)(pMethodInputToken->cbBuffer);
        Digest.refstrParam[MD5_AUTH_METHOD].Buffer = (char *)pMethodInputToken->pvBuffer;       // refernce memory - no alloc!!!!

        // Check to see if we have H(Entity) data to utilize
        if (pHEntityInputToken->cbBuffer)
        {
            // Verify that there is a valid Method provided
            if (!pHEntityInputToken->pvBuffer || (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: HEntity SecBuffer must have valid string status 0x%x\n", Status));
                goto CleanUp;
            }

            usLen = strlencounted((char *)pHEntityInputToken->pvBuffer, (USHORT)pHEntityInputToken->cbBuffer);

            if ((usLen != 0) && (usLen != (MD5_HASH_BYTESIZE * 2)))
            {
                Status = SEC_E_INVALID_TOKEN;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: HEntity SecBuffer must have valid MD5 Hash data 0x%x\n", Status));
                goto CleanUp;
            }

            if (usLen)
            {
                Digest.refstrParam[MD5_AUTH_HENTITY].Length = usLen;
                Digest.refstrParam[MD5_AUTH_HENTITY].MaximumLength = (unsigned short)(pHEntityInputToken->cbBuffer);
                Digest.refstrParam[MD5_AUTH_HENTITY].Buffer = (char *)pHEntityInputToken->pvBuffer;       // refernce memory - no alloc!!!!
            }
        }

        typeDigest = DIGEST_SERVER;

        // Determine the type of algorithm to utilize - Digest servers will not respond to MD5 requests
        // this is a security concern for cluster environments since that H(A1) returned can be used in MD5_sesss requests
        // Determine which Algorithm to support under HTTP
        Status = CheckItemInList(MD5_SESSSTR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
        if (!NT_SUCCESS(Status))
        {
            // Check if MD5 specified (or none specified so MD5 defaults)
            Status = CheckItemInList(MD5STR, &(Digest.refstrParam[MD5_AUTH_ALGORITHM]), FALSE);
            if (NT_SUCCESS(Status) || (Digest.refstrParam[MD5_AUTH_ALGORITHM].Length == 0))
            {
                typeAlgorithm = MD5;
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client requested MD5 (or defaulted); selected as algorithm\n"));
                Status = SEC_E_QOP_NOT_SUPPORTED;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Server does not support MD5 - allows only MD5-sess\n"));
                goto CleanUp;
            }
            else
            {
                Status = SEC_E_QOP_NOT_SUPPORTED;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Unknown Server algorithms provided\n"));
                goto CleanUp;
            }
        }
        else
        {
            typeAlgorithm = MD5_SESS;
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client requested MD5-sess; selected as algorithm\n"));
        }
    }
    else
    {
        // All others follow the SASL Interface so there are default values
        typeDigest = SASL_SERVER;

        // SASL only supports MD5_SESS - client will not send
        typeAlgorithm = MD5_SESS;

        // Set Method to Authenticate
        RtlInitString(&strcMethod, AUTHENTICATESTR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_METHOD]), &strcMethod);  // refernce memory - no alloc!!!!

        RtlInitString(&strcHEntity, ZERO32STR);
        StringReference(&(Digest.refstrParam[MD5_AUTH_HENTITY]), &strcHEntity);  // refernce memory - no alloc!!!!

    }

    fContextAttr |= (ASC_RET_REPLAY_DETECT | ASC_RET_SEQUENCE_DETECT);

    if (NT_SUCCESS(CheckItemInList(AUTHCONFSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), TRUE)))
    {
        // client requested AUTH-CONF since privacy requested
        fContextAttr |= (ASC_RET_CONFIDENTIALITY | ASC_RET_INTEGRITY);
        typeQOP = AUTH_CONF;
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client selected QOP=AUTH-CONF\n"));
    }
    else if (NT_SUCCESS(CheckItemInList(AUTHINTSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), TRUE)))
    {
            // client requested AUTH-INT since privacy requested
        fContextAttr |= ASC_RET_INTEGRITY;
        typeQOP = AUTH_INT;
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client selected QOP=AUTH-INT\n"));
    }
    else if (NT_SUCCESS(CheckItemInList(AUTHSTR, &(Digest.refstrParam[MD5_AUTH_QOP]), TRUE)))
    {
        // check to see if client specified auth only
        typeQOP = AUTH;
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client selected QOP=AUTH\n"));
    }
    else     
    {        // Client did not specify any QOP
        if (!Digest.refstrParam[MD5_AUTH_QOP].Length)
        {
            if (typeDigestMode == DIGESTMODE_HTTP)
            {
                typeQOP = NO_QOP_SPECIFIED;      // This is OK - acts like AUTH but response different
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client did not specify QOP (HTTP only)\n"));
            }
            else
            {
                typeQOP = AUTH;                 // This is OK - SASL defaults to AUTH
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client did not specify QOP, default to AUTH\n"));
            }
        }
        else
        {
            // Failed to provide recognized QOP
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Client failed to provide recognized QOP\n"));
            goto CleanUp;
        }
    }

    //  If there is no OldContextToken passed in, then check for SecurityContext handle (in opaque) else return error
    if ( !ARGUMENT_PRESENT( OldContextHandle ))
    {
        // Search for Reference to SecurityContextHandle
        Status = CtxtHandlerOpaqueToPtr(&(Digest.refstrParam[MD5_AUTH_OPAQUE]), &pContext);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: CtxtHandlerOpaqueToPtr error 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // We have a SecurityContextHandle to use - see if it is in the ContextList and valid
        Status = CtxtHandlerHandleToContext(OldContextHandle, FALSE, &pContext);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: CtxtHandlerHandleToContext error 0x%x\n", Status));
            goto CleanUp;
        }
    }

    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Acquired Context ptr for 0x%x\n", pContext));
    bLockedContext = TRUE;
        

        // Can only call AcceptSecurityContect Once after ChallengeResponse
        // For non-persistent connections (no OldContextHandle passed in), just return SCH and return
    if (pContext->strSessionKey.Length)
    {
        if (ARGUMENT_PRESENT( OldContextHandle ))
        {
            Status = STATUS_LOGON_FAILURE;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Multiple call to completed ASC\n"));
            goto CleanUp;
        }
        else
        {
            // Map over a context, but really only used to ref count the userSecurityContext handle count           
            Status = SspMapDigestContext(pContext, &Digest, (FLAG_CONTEXT_REFCOUNT | FLAG_CONTEXT_SERVER), ContextData);

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext, SspMapContext returns %d\n", Status));
                goto CleanUp;
            }

            *MappedContext = TRUE;

            Status = SEC_I_COMPLETE_NEEDED;
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Opaque located CtxtHandle, return handle, Complete needed\n"));
            *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context
            pContext = NULL;               
            goto CleanUp;
        }
    }


    // Check to see if the Server has provided character set for encoding - only UTF-8 accepted
    Status = CheckItemInList(MD5_UTF8STR, &(Digest.refstrParam[MD5_AUTH_CHARSET]), TRUE);
    if (NT_SUCCESS(Status))
    {
        // The ChallengeResponse requested UTF-8 encoding, check to see that server allowed this

        if (((typeDigest == SASL_SERVER) && (g_fParameter_UTF8SASL == TRUE)) ||
            ((typeDigest == DIGEST_SERVER) && (g_fParameter_UTF8HTTP == TRUE)))
        {
            typeCharset = UTF_8;
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Server allows UTF-8 encoding\n"));
        }
        else
        {
            // We did not authorize this type of encoding - fail the request
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Client requested UTF-8 server did not offer\n"));
            Status = SEC_E_ILLEGAL_MESSAGE;
            goto CleanUp;
        }
    }

    // We now have a pointer to the Security Context to use, finish up setting up the digestparamter fields

    // Set the type of Digest Parameters we are to process
    pContext->typeDigest = typeDigest;
    pContext->typeAlgorithm = typeAlgorithm;
    pContext->typeQOP = typeQOP;
    pContext->typeCharset = typeCharset;


    if (pContext->typeQOP == AUTH_CONF)
    {
        Status = CheckItemInList(STR_CIPHER_RC4, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
        if (NT_SUCCESS(Status))
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting RC4 for auth-conf cipher\n"));
            pContext->typeCipher = CIPHER_RC4;
        }
        else
        {
            Status = CheckItemInList(STR_CIPHER_3DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
            if (NT_SUCCESS(Status))
            {
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting Triple DES for auth-conf cipher\n"));
                pContext->typeCipher = CIPHER_3DES;
            }
            else
            {
                Status = CheckItemInList(STR_CIPHER_RC4_56, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
                if (NT_SUCCESS(Status))
                {
                    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting RC4-56 for auth-conf cipher\n"));
                    pContext->typeCipher = CIPHER_RC4_56;
                }
                else
                {
                    Status = CheckItemInList(STR_CIPHER_RC4_40, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
                    if (NT_SUCCESS(Status))
                    {
                        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting RC4-40 for auth-conf cipher\n"));
                        pContext->typeCipher = CIPHER_RC4_40;
                    }
                    else
                    {
                        Status = CheckItemInList(STR_CIPHER_DES, &(Digest.refstrParam[MD5_AUTH_CIPHER]), TRUE);
                        if (NT_SUCCESS(Status))
                        {
                            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Selecting DES for auth-conf cipher\n"));
                            pContext->typeCipher = CIPHER_DES;
                        }
                        else
                        {
                            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Failed to find known ciper selected by client\n"));
                            Status = STATUS_CRYPTO_SYSTEM_INVALID;
                            goto CleanUp;
                        }
                    }
                }
            }
        }
    }

    // Check if client specified a MaxBuffer
    if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length && Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer)
    {
        if (Digest.refstrParam[MD5_AUTH_MAXBUF].Length < MAXBUFNUMLEN)
        {
            ULONG ulMaxBuf = 0;
            CHAR  czMaxBuf[MAXBUFNUMLEN + 1];

            ZeroMemory(czMaxBuf, (MAXBUFNUMLEN + 1));
            memcpy(czMaxBuf, Digest.refstrParam[MD5_AUTH_MAXBUF].Buffer, Digest.refstrParam[MD5_AUTH_MAXBUF].Length);

            Status = RtlCharToInteger(czMaxBuf, TENBASE, &ulMaxBuf);
            if (!NT_SUCCESS(Status))
            {
                Status =  SEC_E_ILLEGAL_MESSAGE;
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: MaxBuf directive value malformed 0x%x\n", Status));
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Client MaxBuf set to %lu\n", ulMaxBuf));
            pContext->ulSendMaxBuf = ulMaxBuf;
        }
        else
        {
            Status =  SEC_E_ILLEGAL_MESSAGE;
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: MaxBuf directive value too large 0x%x\n", Status));
            goto CleanUp;
        }
    }

    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Digest inputs processing completed\n"));

    // Verify the directives utilized
    Status = DigestDirectiveCheck(&Digest, typeDigest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestDirectiveCheck error 0x%x\n", Status));
        goto CleanUp;
    }

    // ReplyBuffer will contain the ResponseAuth if generated
    Status = DigestProcessParameters(pContext, &Digest, &ReplyBuffer,
                                     &AuditLogStatus, &AuditLogSubStatus, &fGenerateAudit);
    if (!NT_SUCCESS(Status))
    {
        // Checking for broken clients that do not do the backslash encoding properly
        if ((g_dwParameter_ServerCompat & SERVERCOMPAT_BS_ENCODE) && 
            (typeDigestMode == DIGESTMODE_HTTP) &&
             (Digest.usFlags & FLAG_BS_ENCODE_CLIENT_BROKEN))
        {
            NTSTATUS RetryStatus = STATUS_SUCCESS;
            NTSTATUS AuditLogRetryStatus = STATUS_SUCCESS;
            NTSTATUS AuditLogSubRetryStatus = STATUS_SUCCESS;
            BOOL fGenerateAuditRetry = FALSE;

            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: Retry with no BS decode\n"));
            Digest.usFlags |= FLAG_NOBS_DECODE;

            // Processing ChallengeResponse without doing a backslash decode on directive values
            Status = DigestParser2(pChalRspInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestParser error 0x%x\n", Status));
                goto CleanUp;
            }

            // ReplyBuffer will contain the ResponseAuth if generated
            RetryStatus = DigestProcessParameters(pContext, &Digest, &ReplyBuffer,
                                             &AuditLogRetryStatus, &AuditLogSubRetryStatus, &fGenerateAuditRetry);
            if (!NT_SUCCESS(RetryStatus))
            {
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestProcessParameters retry error 0x%x\n", Status));
                goto CleanUp;
            }
            AuditLogStatus = AuditLogRetryStatus;
            AuditLogSubStatus = AuditLogSubRetryStatus;
            fGenerateAudit = fGenerateAuditRetry;

            // Indicate that Backslash Encoded Broken client worked - future decode use no backslash encoding
            pContext->ulFlags |= FLAG_CONTEXT_NOBS_DECODE;
        }
        else
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestProcessParameters error 0x%x\n", Status));
            goto CleanUp;
        }
    }

    fLogonSessionCreated = TRUE;   // We have successfully authed the request & created LogonID & Token

    if ((fContextReqFlags & ASC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if (pOutputToken->cbBuffer < ReplyBuffer.cbBuffer)
        {
            DebugLog((DEB_ERROR,"SpAcceptLsaModeContext:Output token is too small - sent in %d, needed %d\n",
                pOutputToken->cbBuffer, ReplyBuffer.cbBuffer));
            pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
            Status = STATUS_BUFFER_TOO_SMALL;
            goto CleanUp;
        }

        RtlCopyMemory(pOutputToken->pvBuffer, ReplyBuffer.pvBuffer, ReplyBuffer.cbBuffer);
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
    }
    else
    {
        pOutputToken->pvBuffer = ReplyBuffer.pvBuffer;
        pOutputToken->cbBuffer = ReplyBuffer.cbBuffer;
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
        fContextAttr |= ASC_RET_ALLOCATED_MEMORY;
    }

    // Establish the attribute flags for this security context
    pContext->ContextReq = fContextAttr;

    // Keep a copy of the Cnonce for future Delegation requests
    Status = StringDuplicate(&pContext->strCNonce, &Digest.refstrParam[MD5_AUTH_CNONCE]);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: StringDuplicate CNonce failed      status 0x%x\n", Status));
        goto CleanUp;
    }

    // Now create a LogonSession for the completed LogonToken contained SecurityContext
    // This can be utilized in delegated digest client's ACH
    DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Adding a LogonSession for successful ASC\n"));
    Status = CtxtCreateLogSess(pContext);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: CtxtCreateLogSess failed      status 0x%x\n", Status));
        goto CleanUp;
    }

    if (!ARGUMENT_PRESENT( OldContextHandle ))
    {
        ulFlagOptions = FLAG_CONTEXT_REFCOUNT;      // indicate that a new context handle was provided from ASC
    }

    Status = SspMapDigestContext(pContext, &Digest, (ulFlagOptions  | FLAG_CONTEXT_SERVER), ContextData);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpAcceptLsaModeContext, SspMapContext returns %d\n", Status));
        goto CleanUp;
    }

    *MappedContext = TRUE;

    pContext->ulNC++;                           // Everything verified so increment to next nonce count
    *NewContextHandle = (ULONG_PTR)pContext;    // Just report back with the updated context

    // If this was a re-connect then we need to provide the handle back to calling application
    // This will leave the reference count bumped up one for the re-connect by not calling Release on Context
    if (!ARGUMENT_PRESENT( OldContextHandle ))
    {
        bLockedContext = FALSE;                   // We no longer own this memory - turned over to CtxtHandler
    }

    *fContextAttributes = fContextAttr;            // Return the ASC Attributes set on Context


    if (pExpirationTime)
    {
        *pExpirationTime = pContext->ExpirationTime;
    }

    Status = STATUS_SUCCESS;

CleanUp:

    // Now perform auditlogon Raid #329545
    if (fGenerateAudit == TRUE)
    {
        if (AuditLogStatus == STATUS_SUCCESS)   // Check to see if completed a logon
        {      
            if (pContext)
            {
                // get the SID for the logon user
                // this will reduce the number of calls - worse case will not fill in audit buffer
                PSID pSID = NULL;
                CHAR cTokenUser[256];
                PTOKEN_USER pTokenUser = (PTOKEN_USER)cTokenUser;
                
                if (GetTokenInformation(pContext->TokenHandle, TokenUser,
                                        pTokenUser, 256, &dwInfoLen))
                {

                    pSID = pTokenUser->User.Sid;
                }
                else
                {
                    DWORD err = 0;
                    err = GetLastError();
                    DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: GetTokenInfo  error 0x%x\n", err));
                }

                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Audit success on user %wZ  Domain %wZ  pSID 0x%x\n",
                          &(pContext->ustrAccountName),&(pContext->ustrDomain), pSID));
                g_LsaFunctions->AuditLogon(
                    STATUS_SUCCESS,
                    STATUS_SUCCESS,
                    &(pContext->ustrAccountName),
                    &(pContext->ustrDomain),
                    NULL,
                    pSID,
                    Network,
                    &g_DigestSource,
                    &(pContext->LoginID)
                    );
                
                if (pTokenUser)
                {
                    pSID = NULL;
                }
            }
        }
        else {
            if (pContext)
            {         // Select the most appropriate name to display for a failed logon attempt
                pustrAuditAccountName = &(pContext->ustrAccountName);
                pusrtAuditDomain = &(pContext->ustrDomain);
                if (!pustrAuditAccountName->Length)
                {
                    pustrAuditAccountName = &(Digest.ustrCrackedAccountName);
                }
                if (!pustrAuditAccountName->Length)
                {
                    pustrAuditAccountName = &(Digest.ustrUsername);
                }
                if (!pusrtAuditDomain->Length)
                {
                    pusrtAuditDomain = &(Digest.ustrCrackedDomain);
                }
                if (!pusrtAuditDomain->Length)
                {
                    pusrtAuditDomain = &(Digest.ustrRealm);
                }
                DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: Audit failure on user %wZ  Domain %wZ\n",
                          pustrAuditAccountName, pusrtAuditDomain));
                g_LsaFunctions->AuditLogon(
                    AuditLogStatus,
                    AuditLogSubStatus,
                    pustrAuditAccountName,
                    pusrtAuditDomain,
                    NULL,
                    NULL,
                    Network,
                    &g_DigestSource,
                    &(pContext->LoginID)
                    );
            }
        }
    }

    if (!NT_SUCCESS(Status))
    {       // Failed to complete operations so clean up
        if (fLogonSessionCreated == TRUE)
        {
            // Notify LSA that LogonID is not valid
            SubStatus = g_LsaFunctions->DeleteLogonSession(&(pContext->LoginID));
            if (!NT_SUCCESS(SubStatus))
            {
                DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: cleanup DeleteLogonSession failed\n"));
            }
            fLogonSessionCreated = FALSE;

            // If we created a token then we need to close it
            if (pContext->TokenHandle)
            {
                SubStatus = NtClose(pContext->TokenHandle);
                pContext->TokenHandle = NULL;
            }
        }

        if (pNewContext)
        {
            ContextFree(pNewContext);
        }
        pNewContext = NULL;
        *NewContextHandle = NULL;

        // Clear up any mapped data
        *MappedContext = FALSE;
        if (ContextData->pvBuffer)
        {
            g_LsaFunctions->FreeLsaHeap(ContextData->pvBuffer);
            ContextData->pvBuffer = NULL;
            ContextData->cbBuffer = 0;
        }
    }

    // DeReference - pCredential, pOldContext
    if (bLockedCredential && pCredential)
    {
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CredHandlerRelease to be called for 0x%x\n", pCredential));
        SubStatus = CredHandlerRelease(pCredential);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CredHandlerRelease error 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
    }

    if (bLockedContext && pContext)
    {
        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CtxtHandlerRelease to be called for 0x%x\n", pContext));
        SubStatus = CtxtHandlerRelease(pContext, 1);
        if (!NT_SUCCESS(SubStatus))
        {
            DebugLog((DEB_TRACE, "SpAcceptLsaModeContext: CtxtHandlerRelease error 0x%x\n", SubStatus));
            if (NT_SUCCESS(Status))
            {
                Status = SubStatus;    // Indicate release error
            }
        }
    }

        // Free up any allocated memory from the ouput reply buffer
    if (ReplyBuffer.pvBuffer)
    {
        DigestFreeMemory(ReplyBuffer.pvBuffer);
        ReplyBuffer.pvBuffer = NULL;
        ReplyBuffer.cbBuffer = 0;
    }

    // Clean up local memory used by Digest
    DigestFree(&Digest);

    StringFree(&strRealm);

    DebugLog((DEB_TRACE_FUNC, "SpAcceptLsaModeContext: Leaving  Context 0x%x   Status 0x%x\n", *NewContextHandle, Status));

    return(Status);
}


//   Creates a logon session for the logontoken contained in the SecurityContext
// The Token was created for the authenticated digest by ConvertAuthDataToToken
NTSTATUS
CtxtCreateLogSess(
                 IN PDIGEST_CONTEXT pContext)
{

    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_LOGONSESSION pNewLogonSession = NULL;

    DebugLog((DEB_TRACE_FUNC, "CtxtCreateLogSess: Entering\n"));

    // Create a new entry into LogonSession listing
    pNewLogonSession = (PDIGEST_LOGONSESSION)DigestAllocateMemory(sizeof(DIGEST_LOGONSESSION));
    if (!pNewLogonSession)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "CtxtCreateLogSess: Could not allocate memory for logonsession, error 0x%x\n", Status));
        goto CleanUp;
    }
    LogonSessionInit(pNewLogonSession);

    pNewLogonSession->LogonType = Network;
    pNewLogonSession->LogonId = pContext->LoginID;

    DebugLog((DEB_TRACE, "CtxtCreateLogSess: Created Digest Logonsession for for LogonID (%x:%lx)\n",
               pContext->LoginID.HighPart, pContext->LoginID.LowPart ));

    Status = UnicodeStringDuplicate(&(pNewLogonSession->ustrAccountName), &(pContext->ustrAccountName));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CtxtCreateLogSess: UnicodeStringDuplicate failed      status 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(&(pNewLogonSession->ustrDomainName), &(pContext->ustrDomain));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CtxtCreateLogSess: UnicodeStringDuplicate failed      status 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CtxtCreateLogSess: Added new logonsession into list,  handle 0x%x\n", pNewLogonSession));
    LogSessHandlerInsert(pNewLogonSession);
    pNewLogonSession = NULL;                          // Turned over memory to LogSessHandler


CleanUp:

    if (pNewLogonSession)
    {
        (void)LogonSessionFree(pNewLogonSession);
        pNewLogonSession = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "CtxtCreateLogSess: Leaving  Status 0x%x\n", Status));

    return(Status);
}


// Creats the Challenge in the server to send back to the client
//
//  Args:  pContext  - secruity context to utilize for Challenge Creation
//         pstrRealm - allows for override of the Realm directive by this string
//         OutBuffer - secbuffer to store the output challenge in
NTSTATUS NTAPI
ContextCreateChal(
                 IN PDIGEST_CONTEXT pContext,
                 IN PSTRING pstrRealm,
                 OUT PSecBuffer OutBuffer
                 )
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbLenNeeded = 0;
    BOOL  fSASLMode = FALSE;
    STRING strTempRealm = {0};

    PCHAR pczTemp = NULL;
    PCHAR pczTemp2 = NULL;

    DebugLog((DEB_TRACE_FUNC, "ContextCreateChal: Entering\n"));

    // allocate the buffers for output - in the future can optimze to allocate exact amount needed
    pczTemp = (PCHAR)DigestAllocateMemory((3 * NTDIGEST_SP_MAX_TOKEN_SIZE) + 1);
    if (!pczTemp)
    {
        DebugLog((DEB_ERROR, "ContextCreateChal:  No memory for output buffers\n"));
        goto CleanUp;
    }

    pczTemp2 = (PCHAR)DigestAllocateMemory(NTDIGEST_SP_MAX_TOKEN_SIZE + 1);
    if (!pczTemp2)
    {
        DebugLog((DEB_ERROR, "ContextCreateChal:  No memory for output buffers\n"));
        goto CleanUp;
    }

    pczTemp[0] = '\0';
    pczTemp2[0] = '\0';

    // Check to make sure we have minimal input and outputs
    if ((!pContext) || (!OutBuffer) || (!pstrRealm))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "ContextCreateChal:  Invalid args\n"));
        goto CleanUp;
    }

    //  calculate the MAX possible size for the respose - will be smaller than this value
    cbLenNeeded = CB_CHAL;    // MAX byte count for directives and symbols
    cbLenNeeded += pContext->strNonce.Length;
    cbLenNeeded += pContext->strOpaque.Length;
    cbLenNeeded += (pstrRealm->Length * 2);
    cbLenNeeded += (g_strNtDigestUTF8ServerRealm.Length * 2);   // account for max backslash encode by * 2
    cbLenNeeded += (g_strNTDigestISO8859ServerRealm.Length * 2);  // Really only need one of these but make simple math

    if (cbLenNeeded > NTDIGEST_SP_MAX_TOKEN_CHALLENGE_SIZE)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "ContextCreateChal: challenge exceeded max size  len is %d\n", cbLenNeeded));
        goto CleanUp;
    }

    if (pContext->typeDigest == SASL_SERVER)
    {
        fSASLMode = TRUE;
    }

    if (pContext->typeQOP == AUTH_CONF)
    {
        sprintf(pczTemp, "qop=\"auth,auth-int,auth-conf\",cipher=\"3des,des,rc4-40,rc4,rc4-56\",algorithm=%s,nonce=\"%Z\"",
                ((fSASLMode == TRUE) ? MD5_SESS_SASLSTR: MD5_SESSSTR), &pContext->strNonce);
    }
    else if (pContext->typeQOP == AUTH_INT)
    {
        sprintf(pczTemp, "qop=\"auth,auth-int\",algorithm=%s,nonce=\"%Z\"",
                ((fSASLMode == TRUE) ? MD5_SESS_SASLSTR: MD5_SESSSTR), &pContext->strNonce);
    }
    else
    {
        sprintf(pczTemp, "qop=\"auth\",algorithm=%s,nonce=\"%Z\"",
                ((fSASLMode == TRUE) ? MD5_SESS_SASLSTR: MD5_SESSSTR), &pContext->strNonce);
    }

    // Attach opaque data (but not on SASL_SERVER)
    if ((pContext->strOpaque.Length) && (pContext->typeDigest != SASL_SERVER))
    {
        sprintf(pczTemp2, ",opaque=\"%Z\"", &pContext->strOpaque);
        strcat(pczTemp, pczTemp2);
    }

    // Attach charset to allow UTF-8 character encoding
    if (pContext->typeCharset == UTF_8)
    {
        strcat(pczTemp, ",charset=utf-8");
    }

    // Attach realm - allow the strRealm to override the system DnsDomainName
    if (pstrRealm->Buffer)
    {
        if (pstrRealm->Length)
        {
            Status = BackslashEncodeString(pstrRealm, &strTempRealm);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "ContextCreateChal: BackslashEncode failed      status 0x%x\n", Status));
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "ContextCreateChal: Realm provided  (%Z)  backslash encoded (%Z)\n", pstrRealm, &strTempRealm));
            sprintf(pczTemp2, ",realm=\"%Z\"", &strTempRealm);
            strcat(pczTemp, pczTemp2);
        }
        else
        {
            // valid buffer zero length is a blank string for the realm
            strcat(pczTemp, ",realm=\"\"");
        }
    }
    else
    {
        // determine the realm to present based on charset requested - SASL only; HTTP always us 8859-1
        if ((fSASLMode == TRUE) && (pContext->typeCharset == UTF_8))
        {
            if (g_strNtDigestUTF8ServerRealm.Length)
            {
                Status = BackslashEncodeString(&g_strNtDigestUTF8ServerRealm, &strTempRealm);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "ContextCreateChal: BackslashEncode failed      status 0x%x\n", Status));
                    goto CleanUp;
                }
                DebugLog((DEB_TRACE, "ContextCreateChal: UTF-8 default Realm  (%Z)  backslash encoded (%Z)\n",
                           &g_strNtDigestUTF8ServerRealm, &strTempRealm));
                sprintf(pczTemp2, ",realm=\"%Z\"", &strTempRealm);
                strcat(pczTemp, pczTemp2);
            }
        }
        else
        {
            /*
            if (g_strNTDigestISO8859ServerRealm.Length)
            {
                Status = BackslashEncodeString(&g_strNTDigestISO8859ServerRealm, &strTempRealm);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "ContextCreateChal: BackslashEncode failed      status 0x%x\n", Status));
                    goto CleanUp;
                }
                DebugLog((DEB_TRACE, "ContextCreateChal: ISO 8859-1 default Realm  (%Z)  backslash encoded (%Z)\n",
                           &g_strNTDigestISO8859ServerRealm, &strTempRealm));
                sprintf(pczTemp2, ",realm=\"%Z\"", &strTempRealm);
                strcat(pczTemp, pczTemp2);
            }
            */
            sprintf(pczTemp2, ",realm=\"%s\"", STR_DIGEST_DOMAIN);
            strcat(pczTemp, pczTemp2);
        }

    }

    // Attach stale directive if indicated
    // if (some method to determine if context has expired)
    // {
    //     sprintf(pczTemp2, ",stale=true");
    //     strcat(pczTemp, pczTemp2);
    // }

    // total buffer for Challenge (NULL is not included in output buffer - ref:Bug 310201)
    //            cbLenNeeded = strlen(pczTemp) + sizeof(CHAR);
    cbLenNeeded = (USHORT)strlen(pczTemp);

    // Check on allocating output buffer
    if (!OutBuffer->cbBuffer)
    {
        OutBuffer->pvBuffer = DigestAllocateMemory(cbLenNeeded);
        if (!OutBuffer->pvBuffer)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "ContextCreateChal: out of memory on challenge output\n"));
            goto CleanUp;
        }
        OutBuffer->cbBuffer = cbLenNeeded;
        OutBuffer->BufferType = SECBUFFER_DATA;
    }

    if (cbLenNeeded > OutBuffer->cbBuffer)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "ContextCreateChal: output buffer too small need %d len is %d\n",
                  cbLenNeeded, OutBuffer->cbBuffer));
        goto CleanUp;
    }

    memcpy(OutBuffer->pvBuffer, pczTemp, cbLenNeeded);

    // Now indicate number of bytes utilized in output buffer
    OutBuffer->cbBuffer = cbLenNeeded;

CleanUp:

    if (pczTemp)
    {
        DigestFreeMemory(pczTemp);
        pczTemp = NULL;
    }

    if (pczTemp2)
    {
        DigestFreeMemory(pczTemp2);
        pczTemp2 = NULL;
    }

    StringFree(&strTempRealm);

    DebugLog((DEB_TRACE_FUNC, "ContextCreateChal: Leaving      Status 0x%x\n", Status));
    return(Status);
}



// This is the main section to process a Context with an incoming Digest message to authenticate the
// message on the DC, generate a session key, and get the user Token.  On subsequent calls, the session key
// can be utilized directly and if the Digest is authenticated, the Token can be utilized.
// AuditLogStatus can be used to provide SubStatus in AuditLogging on server
NTSTATUS NTAPI
DigestProcessParameters(
                       IN OUT PDIGEST_CONTEXT pContext,
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken,
                       OUT PNTSTATUS pAuditLogStatus,
                       OUT PNTSTATUS pAuditLogSubStatus,
                       OUT PBOOL pfGenerateAudit)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    ULONG ulNonceCount = 0;
    USHORT cbDigestParamEncoded = 0;     // Contains the number of bytes in Request to send out

    BOOL fLogonSessionCreated = FALSE;    // indicate if the LSA was notified about logon

    // Encoded Digest Parameters to send over Generic Passthrough
    BYTE *pDigestParamEncoded = NULL;

    // Generic Passthrough variables - used to send data to DC for digest verification
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    PMSV1_0_PASSTHROUGH_REQUEST PassthroughRequest = NULL;
    PMSV1_0_PASSTHROUGH_RESPONSE PassthroughResponse = NULL;
    ULONG RequestSize = 0;
    ULONG ResponseSize = 0;
    ULONG ulAuthDataSize = 0;
    PUCHAR Where = NULL;
    PWCHAR pwczTempName = NULL;
    BOOL fDigestValid = FALSE;   // is the returned digest response valid (contains authdata?)


    // AuthData to Logon Token Variables
    SECURITY_LOGON_TYPE LogonType = Network;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityImpersonation;
    PUNICODE_STRING pustrTempDomain = NULL;
    UNICODE_STRING ustrAccountName = {0};
    PUCHAR puTempAuth = NULL;

    DebugLog((DEB_TRACE_FUNC, "DigestProcessParameters: Entering\n"));

    ASSERT(pAuditLogStatus);
    ASSERT(pAuditLogSubStatus);
    ASSERT(pfGenerateAudit);

    *pfGenerateAudit = FALSE;
    *pAuditLogStatus = STATUS_LOGON_FAILURE;
    *pAuditLogSubStatus = STATUS_LOGON_FAILURE;

    // Copy over the context types into the digest structure
    pDigest->typeAlgorithm = pContext->typeAlgorithm;
    pDigest->typeDigest = pContext->typeDigest;
    pDigest->typeQOP = pContext->typeQOP;
    pDigest->typeCharset = pContext->typeCharset;

        // Check to make sure that the nonce sent back originated from this machine and is valid
    Status = NonceIsValid(&(pDigest->refstrParam[MD5_AUTH_NONCE]));
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestProcessParameters: Nonce is not valid\n"));
        goto CleanUp;
    }

        // Make sure that the nonces are the same
    if (RtlCompareString(&(pContext->strNonce), &(pDigest->refstrParam[MD5_AUTH_NONCE]), FALSE))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestProcessParameters: nonce does not mach Context nonce!\n"));
        goto CleanUp;
    }

    // We must have a noncecount specified since we specified a qop in the Challenge
    // If we decide to support no noncecount modes then we need to make sure that qop is not specified
    if (pDigest->refstrParam[MD5_AUTH_NC].Length)
    {
        Status = RtlCharToInteger(pDigest->refstrParam[MD5_AUTH_NC].Buffer, HEXBASE, &ulNonceCount);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestProcessParameters: Nonce Count badly formatted\n"));
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestProcessParameters: Nonce Count not specified\n"));
        goto CleanUp;
    }

    // Check nonceCount is incremented to preclude replay
    if (ulNonceCount < (pContext->ulNC + 1))
    {
        // We failed to verify next noncecount
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestProcessParameters: NonceCount failed to increment!\n"));
        goto CleanUp;
    }

    // Verify that this context matches the content in the Digest Parameters
    // We have already gone to the DC and authenticated the first message
    if (pContext->strSessionKey.Length)
    {
        DebugLog((DEB_TRACE, "DigestProcessParameters: We have a previous session key - use key for auth\n"));

        // Copy the SessionKey from the Context into the Digest Structure to verify against
        // This will have Digest Auth routines use the SessionKey rather than recompute H(A1)
        StringFree(&(pDigest->strSessionKey));
        Status = StringDuplicate(&(pDigest->strSessionKey), &(pContext->strSessionKey));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to copy over SessionKey\n"));
            goto CleanUp;
        }

        // No check locally that Digest is authentic
        Status = DigestCalculation(pDigest, NULL);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Oh no we FAILED Authentication!!!!\n"));
            goto CleanUp;
        }

        // We have an authenticated the request
        // Can utilize logonID
        pContext->ulNC =  ulNonceCount;         // Indicate that we have processed up to this NC
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestProcessParameters: No session key - call DC for auth\n"));

        Status = DigestDecodeDirectiveStrings(pDigest);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpAcceptLsaModeContext: DigestDecodeDirectiveStrings  error 0x%x\n", Status));
            goto CleanUp;
        }

        // Try to process the accountname and domain for the user's DC
        Status = DigestDecodeUserAccount(pDigest);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: DigestDecodeUserAccount failed 0x%x\n", Status));
            goto CleanUp;
        }

        // Always go to the server's DC since you will need to expand the group membership after getting user's group info
        pDigest->usFlags |= FLAG_SERVERS_DOMAIN;
        DebugLog((DEB_TRACE, "DigestProcessParameters: GenericPassthrough to domain [%wZ]\n", &(g_NtDigestSecPkg.DomainName)));

        // Serialize the Digest Parameters (if need to send off box)
        cbDigestParamEncoded = 0;    // Will be allocated by BlobEncodeRequest
        Status = BlobEncodeRequest(pDigest, &pDigestParamEncoded, &cbDigestParamEncoded);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: BlobEncodeRequest failed 0x%x\n", Status));
            goto CleanUp;
        }

        // Send the Serialized Digest to the DC for verification & return of validity & session key
        // If paramters match, perform authentication locally and utilize previous token
        //
        // We have to pass off to the DC so build the request.
        //
        RequestSize = sizeof(MSV1_0_PASSTHROUGH_REQUEST) +
                      (g_NtDigestSecPkg.DomainName).Length +
                      g_ustrNtDigestPackageName.Length +
                      cbDigestParamEncoded;

        PassthroughRequest = (PMSV1_0_PASSTHROUGH_REQUEST) DigestAllocateMemory(RequestSize);
        if (PassthroughRequest == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CleanUp;
        }
        Where = (PUCHAR) (PassthroughRequest + 1);       // Points to byte AFTER passthrough header

        PassthroughRequest->MessageType = MsV1_0GenericPassthrough;

        PassthroughRequest->DomainName.Length = (g_NtDigestSecPkg.DomainName).Length;
        PassthroughRequest->DomainName.MaximumLength = (g_NtDigestSecPkg.DomainName).Length;
        PassthroughRequest->DomainName.Buffer = (LPWSTR) Where;       // this is NOT NULL TERMINATED
        RtlCopyMemory(
                     Where,
                     (g_NtDigestSecPkg.DomainName).Buffer,
                     (g_NtDigestSecPkg.DomainName).Length
                     );
        Where += (g_NtDigestSecPkg.DomainName).Length;

        PassthroughRequest->PackageName.Length = g_ustrNtDigestPackageName.Length;
        PassthroughRequest->PackageName.MaximumLength = g_ustrNtDigestPackageName.Length;
        PassthroughRequest->PackageName.Buffer = (LPWSTR) Where;    // Not NULL terminated - relative reference
        RtlCopyMemory(
                     Where,
                     g_ustrNtDigestPackageName.Buffer,
                     g_ustrNtDigestPackageName.Length
                     );
        Where += g_ustrNtDigestPackageName.Length;
        PassthroughRequest->LogonData = Where;
        PassthroughRequest->DataLength = (ULONG)cbDigestParamEncoded;

        RtlCopyMemory(
                     Where,
                     pDigestParamEncoded,
                     cbDigestParamEncoded
                     );

        //
        // We've build the buffer, now call NTLM to pass it through.
        //
        Status = g_LsaFunctions->CallPackage(
                                            &MsvPackageName,
                                            PassthroughRequest,
                                            RequestSize,                                  // How many bytes to send in Request
                                            (PVOID *) &PassthroughResponse,               // Place the buffers here
                                            &ResponseSize,                                // Passed back the size of the buffer
                                            &SubStatus                                    // Return code from Digest Auth on the DC
                                            );


        DebugLog((DEB_TRACE, "DigestProcessParameters: Server passthrough Responsesize %ld, Status 0x%x, SubStatus 0x%x\n",
                  ResponseSize, Status, SubStatus));

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"DigestProcessParameters: Failed to call MSV package to verify Digest: 0x%x\n",Status));
            if (Status == STATUS_INVALID_INFO_CLASS)
            {
                Status = STATUS_LOGON_FAILURE;
            }
            goto CleanUp;
        }

        *pfGenerateAudit = TRUE;

        if (!NT_SUCCESS(SubStatus))
        {
            Status = SubStatus;
            // Expand the DCs error code into the proper Status and SubStatus (lsa\server\cfiles\adtevent.c)
            switch(SubStatus){
                case STATUS_ACCOUNT_EXPIRED:
                    *pAuditLogStatus = STATUS_ACCOUNT_EXPIRED;
                        break;
                case STATUS_ACCOUNT_LOCKED_OUT:
                    *pAuditLogStatus = STATUS_ACCOUNT_LOCKED_OUT;
                        break;
                case STATUS_LOGON_TYPE_NOT_GRANTED:
                    *pAuditLogStatus = STATUS_ACCOUNT_EXPIRED;
                        break;
                case STATUS_PASSWORD_MUST_CHANGE:
                    *pAuditLogStatus = STATUS_PASSWORD_MUST_CHANGE;
                        break;
                case STATUS_PASSWORD_EXPIRED:
                case STATUS_ACCOUNT_DISABLED:
                case STATUS_INVALID_LOGON_HOURS:
                case STATUS_INVALID_WORKSTATION:
                    *pAuditLogStatus = STATUS_ACCOUNT_RESTRICTION;
                    *pAuditLogSubStatus = SubStatus;
                        break;
                default:
                    *pAuditLogStatus = STATUS_LOGON_FAILURE;
                    *pAuditLogSubStatus = SubStatus;
            }
            DebugLog((DEB_ERROR,"DigestProcessParameters: DC failed to verify Digest Response: 0x%x\n",Status));
            goto CleanUp;
        }

        if (!PassthroughResponse || (ResponseSize == 0) || (PassthroughResponse->DataLength == 0))
        {
            DebugLog((DEB_ERROR,"DigestProcessParameters: PassthroughResponse contains no valid data\n"));
            Status = STATUS_INTERNAL_ERROR;
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "DigestProcessParameters: PassthroughResponse->DataLength %ld\n",
                  PassthroughResponse->DataLength));

        Where = (PUCHAR) (PassthroughResponse + 1);          // start copy after header 

        Status =  DigestDecodeResponse(PassthroughResponse->DataLength,
                                       Where,
                                       &fDigestValid,
                                       &ulAuthDataSize,
                                       &puTempAuth,
                                       &(pContext->strSessionKey),
                                       &(pContext->ustrAccountName),
                                       &(pContext->ustrDomain));
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"DigestProcessParameters: Failed DigestDecodeResponse    0x%x\n",Status));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE,"DigestProcessParameters: Processing DC Response\n"));

        // If authenticated then, create a logon token with the DC returns (unless previous token exists)

        if (fDigestValid == FALSE)
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR,"DigestProcessParameters: Digest Response contains no authdata 0x%x\n",Status));
            goto CleanUp;
        }

        // Filter the Sids on the member boundary
        // The following have not been set so they are NULL (or zero)
        ASSERT(!pDigest->ulTrustDirection);
        ASSERT(!pDigest->ulTrustType);
        ASSERT(!pDigest->ulTrustAttributes);
        ASSERT(!pDigest->pTrustSid);
        Status = DigestCheckPacForSidFiltering(pDigest, &puTempAuth, &ulAuthDataSize);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed member boundary SID filtering Status 0x%x\n",
                      Status));
            StringFree(&(pContext->strSessionKey));    // clear out any password hashed data since not needed
            goto CleanUp;
        }
        DebugLog((DEB_TRACE, "DigestProcessParameters: member boundary sid filtering completed\n"));

        // Now create the logon token with the AuthData buffer
        //    LsaConvertAuthDataToToken()
        // Set the AuthorityName to the DC's Domainname
        // g_DigestSource established at SpInitialize time in the LSA

        if (pContext->ustrDomain.Length)
        {
            pustrTempDomain = &(pContext->ustrDomain);
        }
        
        Status = g_LsaFunctions->ConvertAuthDataToToken(puTempAuth, ulAuthDataSize,
                                                        ImpersonationLevel, &g_DigestSource, LogonType, pustrTempDomain,
                                                        &(pContext->TokenHandle), &(pContext->LoginID), &ustrAccountName, &SubStatus);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to form token from AuthData 0x%x subStatus 0x%x\n",
                      Status, SubStatus));
            pContext->TokenHandle = NULL;   // no valid handle returned
            StringFree(&(pContext->strSessionKey));    // clear out any password hashed data since not needed
            goto CleanUp;
        }

        fLogonSessionCreated = TRUE;    // LSA notified about LogonID

        DebugLog((DEB_TRACE, "DigestProcessParameters: Token Created  Handle 0x%x, LogonID (%x:%lx) \n",
                   pContext->TokenHandle, pContext->LoginID.HighPart, pContext->LoginID.LowPart));
        DebugLog((DEB_TRACE, "DigestProcessParameters:                Token AccountName %wZ \n", &ustrAccountName));
        DebugLog((DEB_TRACE, "       Session Key: %.10Z**********\n", &(pContext->strSessionKey)));

        pContext->ulNC =  ulNonceCount;         // Indicate that we have processed up to this NC

        if (pContext->typeDigest == SASL_SERVER)
        {
            // Form the ResponseAuth according to RFC2831 Sect 2.1.3
            StringFree(&pDigest->strSessionKey);
            Status = StringDuplicate(&pDigest->strSessionKey, &pContext->strSessionKey);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to copy session key\n"));
                goto CleanUp;
            }
            Status = DigestSASLResponseAuth(pDigest, pOutputToken);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestProcessParameters: Failed to generate ResponseAuth\n"));
                goto CleanUp;
            }
        }
    }

    // Token created - Logon OK
    *pAuditLogStatus = STATUS_SUCCESS;
    *pAuditLogSubStatus = STATUS_SUCCESS;

CleanUp:
    BlobFreeRequest(pDigestParamEncoded);

    if (!NT_SUCCESS(Status))
    {
        // If we failed - do extra cleanup
        if (fLogonSessionCreated == TRUE)
        {
            // Notify LSA that LogonID is not valid
            SubStatus = g_LsaFunctions->DeleteLogonSession(&(pContext->LoginID));
            if (!NT_SUCCESS(SubStatus))
            {
                DebugLog((DEB_ERROR, "DigestProcessParameters: cleanup DeleteLogonSession failed\n"));
            }
            fLogonSessionCreated = FALSE;

        }

        // If we created a token then we need to close it
        if (pContext->TokenHandle)
        {
            SubStatus = NtClose(pContext->TokenHandle);
            pContext->TokenHandle = NULL;
        }

    }

    if (PassthroughRequest != NULL)
    {
        DigestFreeMemory(PassthroughRequest);
    }
    if (PassthroughResponse != NULL)
    {
        g_LsaFunctions->FreeReturnBuffer(PassthroughResponse);
    }
    if (ustrAccountName.Buffer)
    {     // Need to free up memory from token creation
        g_LsaFunctions->FreeLsaHeap(ustrAccountName.Buffer);
        ustrAccountName.Buffer = NULL;
        ustrAccountName.Length = ustrAccountName.MaximumLength = 0;
    }
    DigestFreeMemory(puTempAuth);
    DigestFreeMemory(pwczTempName);

    DebugLog((DEB_TRACE_FUNC, "DigestProcessParameters: Leaving    Status  0x%x\n", Status));
    return(Status);
}


//  This call is utilized by Initialize Securitycontext - it is used to create the sessionkey
//  form the response hash. This function is called only as a client process
NTSTATUS NTAPI
DigestGenerateParameters(
                       IN OUT PDIGEST_CONTEXT pContext,
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken)
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING ustrTempPasswd = {0};
    USER_CREDENTIALS UserCreds;

    ZeroMemory(&UserCreds, sizeof(UserCreds));

    DebugLog((DEB_TRACE_FUNC, "DigestGenerateParameters: Entering\n"));

    pDigest->typeDigest = pContext->typeDigest;
    pDigest->typeAlgorithm = pContext->typeAlgorithm;
    pDigest->typeQOP = pContext->typeQOP;
    pDigest->typeCipher = pContext->typeCipher;
    pDigest->typeCharset = pContext->typeCharset;

    if (pContext->ulFlags & FLAG_CONTEXT_QUOTE_QOP)
    {
        pDigest->usFlags |= FLAG_QUOTE_QOP;
    }

    // We must have specified the username and password

    Status = UnicodeStringDuplicate(&(UserCreds.ustrRealm), &(pContext->ustrDomain));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Duplicate Domain string   status 0x%x\n", Status));
        goto CleanUp;
    }
    Status = UnicodeStringDuplicate(&(UserCreds.ustrUsername), &(pContext->ustrAccountName));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Duplicate Username string   status 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicatePassword(&(UserCreds.ustrPasswd), &(pContext->ustrPassword));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Duplicate Password string   status 0x%x\n", Status));
        goto CleanUp;
    }
    UserCreds.fIsValidPasswd = TRUE;
    UserCreds.fIsEncryptedPasswd = TRUE;


    
    DebugLog((DEB_TRACE, "DigestGenerateParameters: Before DigestCalculation\n"));
    (void)DigestPrint(pDigest);

    // Caclulcate the response value - we are in an ISC call
    Status = DigestCalculation(pDigest, &UserCreds);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Could not create Response   status 0x%x\n", Status));
        goto CleanUp;
    }

        // DigestCalculation determined the sessionkey - copy into this context
    StringFree(&(pContext->strSessionKey));
    Status = StringDuplicate( &(pContext->strSessionKey), &(pDigest->strSessionKey));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Failed to copy over SessionKey\n"));
        goto CleanUp;
    }

    // We have an authenticated the request
    // Can utilize logonID

    Status = DigestCreateChalResp(pDigest, &UserCreds, pOutputToken);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestGenerateParameters: Failed to create Output String  status 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestGenerateParameters: After DigestCalculation & copy struct\n"));
    (void)DigestPrint(pDigest);

CleanUp:

    UserCredentialsFree(&UserCreds);
    UnicodeStringFree(&ustrTempPasswd);

    DebugLog((DEB_TRACE_FUNC, "DigestGenerateParameters: Leaving\n"));

    return(Status);
}




// Called by digest (inside LSA) with a buffer routed from a server to the DC running this code
// We need to strip out the header and extract the DIGEST_BLOB_REQUEST
//
//  pcbMessageRequest will return the number of bytes allocated for response
//  ppMessageResponse will contain the pointer to the allocated buffer
//     calling routine must free the buffer (DigestFreeMemory) after it is done with it
NTSTATUS NTAPI
DigestPackagePassthrough(IN USHORT cbMessageRequest,
                         IN BYTE *pMessageRequest,
                         IN OUT ULONG *pulMessageResponse,
                         OUT PBYTE *ppMessageResponse)
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    ASSERT(pMessageRequest);
    ASSERT(pulMessageResponse);
    ASSERT(ppMessageResponse);

    DebugLog((DEB_TRACE_FUNC, "DigestPackagePassthrough: Entering\n"));

    // Function will allocate space for Response - we need to free it after use
    Status = DigestResponseBru(cbMessageRequest, pMessageRequest, pulMessageResponse, ppMessageResponse);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestPackagePassthrough: Error with DigestVerifyResponseBru\n"));
        goto CleanUp;
    }

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "DigestPackagePassthrough: Leaving\n"));
    return(Status);
}


// Routine receives the DigestBlob to process by extracting the password
// and verifying the response-value.  If authenticated, the SessionKey can be returned
// to the server for future authentication
//
// This routine runs under LSA on the DC.  It will do the actual Digest auth and return session keys
//
//   pcbResponse is a pointer to a USHORT which holds amount of bytes in PResponse
//         it also returns the number of bytes actually used
//   The buffer will be allocated in this routine by DigestAllocateMemory and must be freed by DigestFreeMemory by
//   calling routine
NTSTATUS NTAPI
DigestResponseBru(
                 IN USHORT cbMessageRequest,
                 IN BYTE *pMessageRequest,
                 OUT PULONG pulResponse,
                 OUT PBYTE *ppResponse)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusSub = STATUS_LOGON_FAILURE;
    DIGEST_PARAMETER Digest;
    USER_CREDENTIALS UserCreds;
    PUCHAR pucAuthData = NULL;
    PUCHAR pucExpandedAuthData = NULL;
    ULONG  ulAuthDataSize = 0;
    ULONG  ulExpandedAuthDataSize = 0;
    BOOL   fDigestValid = FALSE;
    BOOL   fForwardedRequest = FALSE;
    USHORT indx = 0;
    USHORT indxmax = 0;
    SAMPR_HANDLE UserHandle = NULL;

    DebugLog((DEB_TRACE_FUNC, "DigestResponseBru: Entering\n"));

    ZeroMemory(&UserCreds, sizeof(USER_CREDENTIALS));

    ASSERT(pMessageRequest);
    ASSERT(pulResponse);
    ASSERT(ppResponse);

    // Initialize the outputs
    *pulResponse = 0;
    *ppResponse = NULL;

    Status = DigestInit(&Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed to initialize digest struct\n"));
        goto CleanUp;
    }

    Status = BlobDecodeRequest(cbMessageRequest, pMessageRequest, &Digest);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed to copy over SessionKey 0x%x\n", Status));
        goto CleanUp;
    }

#if DBG
    (void)DigestPrint(&Digest);
#endif

    // Verify that only md5-sess requests will be processed.  Do not allow md5 requests to be verified
    // since the H(a1) from MD5 is returned to server which could be used in future md5-sess requests without
    // client permission
    if (Digest.typeAlgorithm != MD5_SESS)
    {
        Status = SEC_E_QOP_NOT_SUPPORTED;
        DebugLog((DEB_ERROR, "DigestResponseBru: Only MD5-sess algorithm can be processed 0x%x\n", Status));
        goto CleanUp;

    }

    // If there is a domain associated with this cracked username, check to see if it matches the current domain
    // if it does not match, this request will need to be forwarded to the correct DC for the user's account
    if (Digest.ustrCrackedDomain.Length)
    {
        BOOL fIsThisDomain = FALSE;

        fIsThisDomain = DigestCompareDomainNames(&Digest.ustrCrackedDomain,
                                                 &(g_NtDigestSecPkg.DnsDomainName),
                                                 &(g_NtDigestSecPkg.DomainName));
        // Check if need to forward the request to another domain where user's account is located
        if (!fIsThisDomain)
        {
            DebugLog((DEB_WARN, "DigestResponseBru: Request is not for this domain - forward request\n"));
            Status = DigestForwardRequest(&Digest,
                                          &fDigestValid,
                                          &ulAuthDataSize,
                                          &pucAuthData);
            if ( !NT_SUCCESS( Status ) )
            {
                DebugLog((DEB_ERROR, "DigestResponseBru: ForwardRequest Failed    Status = 0x%x\n", Status));
                goto CleanUp;
            }
            else
            {
                DebugLog((DEB_TRACE, "DigestResponseBru: ForwardRequest Succeeded    Status = 0x%x\n", Status));
                fForwardedRequest = TRUE;
                goto Generate_Response;
            }
        }
    }

    // Pull out the username and domain to process
    Status = UserCredentialsExtract(&Digest, &UserCreds);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed UserCredentialsExtract 0x%x\n", Status));
        goto CleanUp;
    }

    // Now attempt to locate the user account in this DC
    Status =  DigestOpenSamUser(&Digest, &UserHandle, &pucAuthData, &ulAuthDataSize);
    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog((DEB_WARN, "DigestResponseBru: DigestOpenSamUser failed for user %wZ, Status = 0x%x\n",
                   &(Digest.ustrUsername), Status));

        // Check if we should try a crackname and call to other DC
        if ((Status == STATUS_NO_SUCH_USER) && (Digest.usFlags & FLAG_CRACKNAME_ON_DC))
        {
            DebugLog((DEB_WARN, "DigestResponseBru: Call Crackname and Redirect as necessary\n"));
            Status = DigestForwardRequest(&Digest,
                                          &fDigestValid,
                                          &ulAuthDataSize,
                                          &pucAuthData);
             if ( !NT_SUCCESS( Status ) )
             {
                  DebugLog((DEB_ERROR, "DigestResponseBru: Failed crackname for user %wZ, Status = 0x%x\n",
                            &(Digest.ustrUsername), Status));
                  goto CleanUp;
             }
             else
             {
                 DebugLog((DEB_TRACE, "DigestResponseBru: Succeeded crackname for user %wZ, Status = 0x%x\n",
                            &(Digest.ustrUsername), Status));
                 fForwardedRequest = TRUE;
                 goto Generate_Response;
             }
        }

        DebugLog((DEB_ERROR, "DigestResponseBru: Failed local open SAM for user %wZ, Status = 0x%x\n",
                   &(Digest.ustrUsername), Status));
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestResponseBru: DigestOpenSamUser Succeeded  AuthData size %ld\n", ulAuthDataSize ));
    }

    // Extract Passwords (Cleartext and hash if available) - select which ones to utilize
    Status = DigestGetPasswd(UserHandle, &Digest, &UserCreds);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed to find password status 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestResponseBru: Got password  valid %d\n", UserCreds.fIsValidPasswd));
    DebugLog((DEB_TRACE, "DigestResponseBru: HashCred size is %d\n", UserCreds.strDigestHash.Length ));


    // We now have passwd - either/both pre-computed hash or passwd
    // Also, an authData blob to marshal back to server
    
    // Now validate the Digest ChallengeResponse
    // Check precalculated hashes first
    fDigestValid = FALSE;
    if (UserCreds.fIsValidDigestHash == TRUE)
    {
        // Need to cycle over the possible matching hashes based on username format
        indx = 1;  // skip the first hash this is the header

        // Determine max number of hashes to inspect
        indxmax = (((USHORT)NUMPRECALC_HEADERS < UserCreds.usDigestHashCnt) ? (USHORT)NUMPRECALC_HEADERS : UserCreds.usDigestHashCnt);
        while ((fDigestValid == FALSE) && (indx <= indxmax))
        {
            if (UserCreds.sHashTags[indx])
            {
                DebugLog((DEB_TRACE, "DigestResponseBru: Checking Precalc hash 0x%x\n", indx));
                UserCreds.wHashSelected = indx;
            }
            else
            {
                indx++;      // skip to the next hash since incorrect format
                continue;
            }

            StringFree(&Digest.strSessionKey);      // clear out any previous session key info
            StatusSub = DigestCalculation(&Digest, &UserCreds);
            if (NT_SUCCESS(StatusSub))
            {        // Precalculated hash matched!
                DebugLog((DEB_TRACE, "DigestResponseBru: Digest valid with precalc hash 0x%x\n", indx));
                fDigestValid = TRUE;
            }
            else if ((StatusSub == STATUS_WRONG_PASSWORD) || (StatusSub == SEC_E_NO_CREDENTIALS))
            {        // Really we know only that the Hash did not compare - could be anything incorrect
                     // We do not provide information that the password was incorrect
                DebugLog((DEB_TRACE, "DigestResponseBru: Digest did not match precalc hash 0x%x\n", indx));
                indx++;
            }
            else
            {
                Status = StatusSub;
                DebugLog((DEB_ERROR, "DigestResponseBru: Digest Verify Failed 0x%x\n", Status));
                goto CleanUp;
            }
        }
        if (fDigestValid == FALSE)
        {
            UserCreds.fIsValidDigestHash = FALSE;    // no need to try to use any of these hashes again
        }
    }

    // If ClearText passwd available, then try to validate the Digest ChallengeResponse
    if ((fDigestValid == FALSE) && (UserCreds.fIsValidPasswd == TRUE))
    {
        StringFree(&Digest.strSessionKey);      // clear out any previous session key info
        StatusSub = DigestCalculation(&Digest, &UserCreds);
        if (NT_SUCCESS(StatusSub))
        {        // Really we know only that the Hash did not compare - could be anything incorrect
                 // We do not provide information that the password was incorrect
            DebugLog((DEB_TRACE, "DigestResponseBru: Digest valid with cleartext password\n"));
            fDigestValid = TRUE;
        }
        else if (StatusSub == STATUS_WRONG_PASSWORD)
        {        // Really we know only that the Hash did not compare - could be anything incorrect
                 // We do not provide information that the password was incorrect
            DebugLog((DEB_WARN, "DigestResponseBru: Digest did not match cleartext passsword\n"));
        }
        else
        {
            Status = StatusSub;
            DebugLog((DEB_ERROR, "DigestResponseBru: Digest Verify Failed 0x%x\n", Status));
            goto CleanUp;
        }
    }


    // Adjust badpassword counter for user based on SubStatus
    // for either STATUS_SUCCESS (fDigestValid must be TRUE) or STATUS_WRONG_PASSWORD
    // do not process other system errors (such as no pre-calc hashes yet and no cleartext password)

    if ((fDigestValid == TRUE) || (StatusSub == STATUS_WRONG_PASSWORD))
    {
        SAM_LOGON_STATISTICS LogonStats;

        RtlZeroMemory(&LogonStats, sizeof(LogonStats));

        if (fDigestValid == TRUE)
        {
            LogonStats.StatisticsToApply = USER_LOGON_NET_SUCCESS_LOGON;
            DebugLog((DEB_TRACE, "DigestResponseBru: Audit logging Successful logon\n"));
        }
        else if (StatusSub == STATUS_WRONG_PASSWORD)
        {
            LogonStats.StatisticsToApply = USER_LOGON_BAD_PASSWORD | USER_LOGON_BAD_PASSWORD_WKSTA;
            (void)UnicodeStringReference(&LogonStats.Workstation, &Digest.ustrWorkstation);
            DebugLog((DEB_TRACE, "DigestResponseBru: Audit logging Bad Password\n"));
        }

        if ( LogonStats.StatisticsToApply != 0 ) {
            NTSTATUS LogonStatus;

            // LogonStats.StatisticsToApply |= USER_LOGON_TYPE_NTLM;

            LogonStatus = DigestUpdateLogonStatistics(
                                          UserHandle,
                                         &LogonStats );
        }

    }

Generate_Response:

    // Update any group memberships of the user with the server's domain info
    if ((fDigestValid == TRUE) &&
        (Digest.usFlags & FLAG_SERVERS_DOMAIN) &&
        ulAuthDataSize &&
        pucAuthData)
    {
        if (fForwardedRequest == TRUE)
        {
            DebugLog((DEB_TRACE, "DigestResponseBru: Filtering the SIDs from forwarded domain\n"));
            Status = DigestCheckPacForSidFiltering(&Digest, &pucAuthData, &ulAuthDataSize);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestResponseBru: Failed DigestCheckPacForSidFiltering 0x%x\n", Status));
                goto CleanUp;
            }
        }

        DebugLog((DEB_TRACE, "DigestResponseBru: Calling ExpandAuthDataforDomain  AuthDataSize  %ld\n", ulAuthDataSize));
        Status = g_LsaFunctions->ExpandAuthDataForDomain(pucAuthData,
                                                         ulAuthDataSize,
                                                         NULL,
                                                         &pucExpandedAuthData,
                                                         &ulExpandedAuthDataSize);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestResponseBru: Failed ExpandAuthDataforDomain 0x%x\n", Status));
            goto CleanUp;
        }
        DebugLog((DEB_TRACE, "DigestResponseBru:  ExpandAuthDataforDomain  Expanded AuthDataSize  %ld\n", ulExpandedAuthDataSize));

        // Replace auth data with Expanded AuthData
        if (pucAuthData)
        {
            g_LsaFunctions->FreeLsaHeap(pucAuthData);
        }
        pucAuthData = pucExpandedAuthData;
        ulAuthDataSize = ulExpandedAuthDataSize;
        ulExpandedAuthDataSize = 0;
        pucExpandedAuthData = NULL;
    }


#ifdef ROGUE_DC
    DebugLog((DEB_TRACE, "DigestResponseBru: Calling DigestInstrumentRoguePac\n"));
    Status = DigestInstrumentRoguePac(&pucAuthData, &ulAuthDataSize);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed DigestInstrumentRoguePac 0x%x\n", Status));
        goto CleanUp;
    }
#endif

    Status = DigestEncodeResponse(fDigestValid,
                                    &Digest,
                                    ulAuthDataSize,
                                    pucAuthData,
                                    pulResponse,
                                    ppResponse);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestResponseBru: Failed DigestEncodeResponse 0x%x\n", Status));
        goto CleanUp;
    }

CleanUp:

    DigestFree(&Digest);
    UserCredentialsFree(&UserCreds);

    // Cleanup any allocated heap from User's AuthData
    if (pucAuthData)
    {
        g_LsaFunctions->FreeLsaHeap(pucAuthData);
        pucAuthData = NULL;
        ulAuthDataSize = 0;
    }

    if (pucExpandedAuthData)
    {
        g_LsaFunctions->FreeLsaHeap(pucExpandedAuthData);
        pucExpandedAuthData = NULL;
        ulExpandedAuthDataSize = 0;
    }

    if (UserHandle)
    {
     StatusSub = DigestCloseSamUser(UserHandle);
     if (!NT_SUCCESS(StatusSub))
     {
         DebugLog((DEB_ERROR,"DigestResponseBru: failed DigestCloseSamUser 0x%x\n", StatusSub));
     }
     UserHandle = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "DigestResponseBru: Leaving   Status 0x%x\n", Status));

    return(Status);
}


NTSTATUS
ContextPrint(PDIGEST_CONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pContext)
    {
        return (STATUS_INVALID_PARAMETER); 
    }

    if (pContext->typeDigest == DIGEST_UNDEFINED)
    {
        DebugLog((DEB_TRACE, "Context:       DIGEST_UNDEFINED\n"));
    }
    if (pContext->typeDigest == NO_DIGEST_SPECIFIED)
    {
        DebugLog((DEB_ERROR, "Context:       NO_DIGEST_SPECIFIED\n"));
    }
    if (pContext->typeDigest == DIGEST_CLIENT)
    {
        DebugLog((DEB_TRACE, "Context:       DIGEST_CLIENT\n"));
    }
    if (pContext->typeDigest == DIGEST_SERVER)
    {
        DebugLog((DEB_TRACE, "Context:       DIGEST_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_SERVER)
    {
        DebugLog((DEB_TRACE, "Context:       SASL_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_CLIENT)
    {
        DebugLog((DEB_TRACE, "Context:       SASL_CLIENT\n"));
    }
    if (pContext->typeQOP == QOP_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Context:       QOP: QOP_UNDEFINED\n"));
    }
    if (pContext->typeQOP == NO_QOP_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: NO_QOP_SPECIFIED\n"));
    }
    if (pContext->typeQOP == AUTH)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: AUTH\n"));
    }
    if (pContext->typeQOP == AUTH_INT)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: AUTH_INT\n"));
    }
    if (pContext->typeQOP == AUTH_CONF)
    {
        DebugLog((DEB_TRACE, "Context:       QOP: AUTH_CONF\n"));
    }
    if (pContext->typeAlgorithm == ALGORITHM_UNDEFINED)
    {
        DebugLog((DEB_ERROR, "Context:       Algorithm: ALGORITHM_UNDEFINED\n"));
    }
    if (pContext->typeAlgorithm == NO_ALGORITHM_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "Context:       Algorithm: NO_ALGORITHM_SPECIFIED\n"));
    }
    if (pContext->typeAlgorithm == MD5)
    {
        DebugLog((DEB_TRACE, "Context:       Algorithm: MD5\n"));
    }
    if (pContext->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "Context:       Algorithm: MD5_SESS\n"));
    }
    if (pContext->typeCipher == CIPHER_RC4)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: RC4\n"));
    }
    if (pContext->typeCipher == CIPHER_RC4_40)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: RC4_40\n"));
    }
    if (pContext->typeCipher == CIPHER_RC4_56)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: RC4_56\n"));
    }
    if (pContext->typeCipher == CIPHER_3DES)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: 3DES\n"));
    }
    if (pContext->typeCipher == CIPHER_DES)
    {
        DebugLog((DEB_TRACE, "Context:       Cipher: DES\n"));
    }
    if (pContext->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "Context:       Charset: ISO-8859-1\n"));
    }
    if (pContext->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "Context:       Charset: UTF-8\n"));
    }

    DebugLog((DEB_TRACE, "Context:      NC %d\n", pContext->ulNC));
    DebugLog((DEB_TRACE, "Context:      LogonId (%x:%lx)\n", pContext->LoginID.HighPart, pContext->LoginID.LowPart ));

    DebugLog((DEB_TRACE, "Context:      strNonce %Z\n", &(pContext->strNonce)));
    DebugLog((DEB_TRACE, "Context:      strCNonce %Z\n", &(pContext->strCNonce)));
    DebugLog((DEB_TRACE, "Context:      strOpaque %Z\n", &(pContext->strOpaque)));
    DebugLog((DEB_TRACE, "Context:      strSessionKey %Z\n", &(pContext->strSessionKey)));
    DebugLog((DEB_TRACE, "Context:      ustrDomain %wZ\n", &(pContext->ustrDomain)));
    DebugLog((DEB_TRACE, "Context:      ustrAccountName %wZ\n", &(pContext->ustrAccountName)));
    DebugLog((DEB_TRACE, "Context:      SendMaxBuf %lu\n", &(pContext->ulSendMaxBuf)));

    return(Status);
}



//   Extracts the username and domain from the digest directives
//   Need to process the character set to properly decode the directive values
//   The major character sets are UTF-8 and ISO-8859-1
//   The forms that may be present in the directive values are:
//         Username               Realm
//   1.    username               domain
//   2.    domain/username        NULL
//   3.    UPN                    NULL
NTSTATUS UserCredentialsExtract(PDIGEST_PARAMETER pDigest,
                                PUSER_CREDENTIALS pUserCreds)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "UserCredentialsExtract: Entering\n"));

    if (!pDigest || !(pDigest->refstrParam[MD5_AUTH_USERNAME].Length))
    {
        Status = STATUS_NO_SUCH_USER;
        DebugLog((DEB_ERROR, "UserCredentialsExtract: Invalid Username or realm\n"));
        goto CleanUp;
    }

    Status = DigestDecodeDirectiveStrings(pDigest);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "UserCredentialsExtract: DigestDecodeDirectiveStrings  error 0x%x\n", Status));
        goto CleanUp;
    }

    // Values to use for the username and realm in hash calculations
    Status = UnicodeStringDuplicate(&(pUserCreds->ustrUsername), &(pDigest->ustrUsername));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "UserCredentialsExtract: UnicodeStringDuplicate  Username  error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(&(pUserCreds->ustrRealm), &(pDigest->ustrRealm));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "UserCredentialsExtract: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
        goto CleanUp;
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "UserCredentialsExtract: Leaving   Status 0x%x\n", Status));

    return(Status);
}


//   Release memory allocated into UserCredentials
NTSTATUS UserCredentialsFree(PUSER_CREDENTIALS pUserCreds)
{
    NTSTATUS Status = STATUS_SUCCESS;

    UnicodeStringFree(&(pUserCreds->ustrUsername));
    if (pUserCreds->ustrPasswd.MaximumLength)
    {
        SecureZeroMemory(pUserCreds->ustrPasswd.Buffer, pUserCreds->ustrPasswd.MaximumLength);
    }
    UnicodeStringFree(&(pUserCreds->ustrPasswd));
    UnicodeStringFree(&(pUserCreds->ustrRealm));
    if (pUserCreds->strDigestHash.MaximumLength)
    {
        SecureZeroMemory(pUserCreds->strDigestHash.Buffer, pUserCreds->strDigestHash.MaximumLength);
    }
    StringFree(&(pUserCreds->strDigestHash));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestSASLResponseAuth
//
//  Synopsis:   Generate the ResponseAuth from the server
//
//  Arguments:  pDigest - pointer to Digest parameter struct
//              pOutputToken - location to send output string to
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------

NTSTATUS DigestSASLResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbLenNeeded = 0;
    STRING strReqAuth = {0};

    PCHAR pczTemp = NULL;

    ASSERT(pDigest);

    DebugLog((DEB_TRACE_FUNC, "DigestSASLResponseAuth: Entering\n"));

    Status = DigestCalculateResponseAuth(pDigest, &strReqAuth);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestSASLResponseAuth: Request Auth failed : 0x%x\n", Status));
        goto CleanUp;
    }

    cbLenNeeded = sizeof(RSPAUTH_STR);
    cbLenNeeded += strReqAuth.Length;

    // allocate the buffers for output - in the future can optimze to allocate exact amount needed
    pczTemp = (PCHAR)DigestAllocateMemory(cbLenNeeded + 1);
    if (!pczTemp)
    {
        DebugLog((DEB_ERROR, "ContextCreateChal:  No memory for output buffers\n"));
        goto CleanUp;
    }

    sprintf(pczTemp, RSPAUTH_STR, &strReqAuth); 

    pOutputToken->cbBuffer = (USHORT)strlen(pczTemp);
    pOutputToken->pvBuffer = pczTemp;


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestSASLResponseAuth: Leaving 0x%x\n", Status));

    StringFree(&strReqAuth);
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestCalculateResponseAuth
//
//  Synopsis:   Calculate the ResponseAuth Hash value
//
//  Arguments:  pDigest - pointer to Digest parameter struct
//              pCoutputToken - location to send output string to
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS DigestCalculateResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSTRING pstrHash)
{
    NTSTATUS Status = STATUS_SUCCESS;
    STRING strHA2 = {0};
    STRING strcQOP = {0};

    ASSERT(pDigest);
    ASSERT(pstrHash);


    DebugLog((DEB_TRACE_FUNC, "DigestCalculateResponseAuth: Entering\n"));

    DigestPrint(pDigest);

    StringFree(pstrHash);


    // Establish which QOP utilized
    if (pDigest->typeQOP == AUTH_CONF)
    {
        RtlInitString(&strcQOP, AUTHCONFSTR);
    }
    else if (pDigest->typeQOP == AUTH_INT)
    {
        RtlInitString(&strcQOP, AUTHINTSTR);
    }
    else if (pDigest->typeQOP == AUTH)
    {
        RtlInitString(&strcQOP, AUTHSTR);
    }
    else
    {
        RtlInitString(&strcQOP, NULL);
    }

    // Calculate H(A2)
    // For QOP unspecified or "auth"  H(A2) = H( : URI)
    // For QOP Auth-int or Auth-conf  H(A2) = H( : URI: H(entity-body))
    if ((pDigest->typeQOP == AUTH) || (pDigest->typeQOP == NO_QOP_SPECIFIED))
    {
        // Unspecified or Auth
        DebugLog((DEB_TRACE, "DigestCalculateResponseAuth: H(A2) using AUTH/Unspecified\n"));
        Status = DigestHash7(NULL,
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             NULL, NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalculateResponseAuthDigestCalculateResponseAuth:  H(A2) failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        // Auth-int or Auth-conf
        DebugLog((DEB_TRACE, "DigestCalculateResponseAuth: H(A2) using AUTH-INT/CONF\n"));
        Status = DigestHash7(NULL,
                             &(pDigest->refstrParam[MD5_AUTH_URI]),
                             &(pDigest->refstrParam[MD5_AUTH_HENTITY]),
                             NULL, NULL, NULL, NULL,
                             TRUE, &strHA2);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalculateResponseAuth H(A2) auth-int failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    // We now have calculated H(A2)


    // Calculate Request-Digest
    // For QOP of Auth, Auth-int, Auth-conf    Req-Digest = H( H(A1): nonce: nc: cnonce: qop: H(A2))
    if ((pDigest->typeQOP == AUTH) || (pDigest->typeQOP == AUTH_INT) || (pDigest->typeQOP == AUTH_CONF))
    {
        Status = DigestHash7(&(pDigest->strSessionKey),
                         &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                         &(pDigest->refstrParam[MD5_AUTH_NC]),
                         &(pDigest->refstrParam[MD5_AUTH_CNONCE]),
                         &strcQOP,
                         &strHA2, NULL,
                         TRUE, pstrHash);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalculateResponseAuth: Request Auth failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else if (pDigest->typeQOP == NO_QOP_SPECIFIED)
    {
        DebugLog((DEB_TRACE, "DigestCalculateResponseAuth: Response calc using Unspecified QOP\n"));
        Status = DigestHash7(&(pDigest->strSessionKey),
                         &(pDigest->refstrParam[MD5_AUTH_NONCE]),
                         &strHA2,
                         NULL,
                         NULL,
                         NULL, NULL,
                         TRUE, pstrHash);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestCalculateResponseAuth: Request Auth failed : 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestCalculateResponseAuth: Unknown Auth Type: 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestCalculateResponseAuth: ResponseAuth is %Z\n", pstrHash));

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestCalculateResponseAuth: Leaving 0x%x\n", Status));

    StringFree(&strHA2);
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestDecodeUserAccount
//
//  Synopsis:   Process the Digest to extract Account Username, Account Domain
//      generic passthrough domain controller, and index for precalculated digest hash
//
//  Arguments:  pDigest - pointer to Digest parameter struct
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS DigestDecodeUserAccount(
    IN PDIGEST_PARAMETER pDigest)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWCHAR pwczAcct = NULL;
    USHORT uNumWChar = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeUserAccount: Entering\n"));

    DebugLog((DEB_TRACE, "DigestDecodeUserAccount: Checking format on username %wZ\n", &pDigest->ustrUsername));

    if (pDigest->ustrUsername.Length / sizeof(WCHAR) > UNLEN)
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "DigestDecodeUserAccount: Username too long 0x%x\n", Status));
        goto CleanUp;
    }

    // On the server, we can only safely check the username for NetBIOS format.  We can not crack UPNs locally.
    DebugLog((DEB_TRACE, "DigestDecodeUserAccount: Checking for NetBios Format\n"));
    if (pDigest->ustrUsername.Length)
    {
        pwczAcct = wcschr(pDigest->ustrUsername.Buffer, L'\\');
        if (pwczAcct)
        {
            DebugLog((DEB_TRACE, "DigestDecodeUserAccount: DS_NT4_ACCOUNT_NAME Succeeded\n"));

            // Output name format always will be domain+'\'+account+'\0'
            // Need account location

            UnicodeStringFree(&(pDigest->ustrCrackedAccountName));    // clear for retry decode
            Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedAccountName), pwczAcct+1, 0);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Username  error 0x%x\n", Status));
                goto CleanUp;
            }

            UnicodeStringFree(&(pDigest->ustrCrackedDomain));    // clear for retry decode
            uNumWChar = (USHORT)(pwczAcct - pDigest->ustrUsername.Buffer);
            if (uNumWChar > 1)
            {   //  we will only copyout the Domain if there is aleast 1 WChar; otherwise it is of the form "\accountname"
                Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedDomain), pDigest->ustrUsername.Buffer, uNumWChar);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "DigestDecodeUserAccount: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
                    goto CleanUp;
                }
            }

            pDigest->typeName = NAMEFORMAT_NETBIOS;
            Status = STATUS_SUCCESS;
            goto CleanUp;
        }

        // Not a NetBIOS format - might be SAMAccount or UPN
        pDigest->usFlags |= FLAG_CRACKNAME_ON_DC;           // we could not crack account name locally - do on DC
        pDigest->typeName = NAMEFORMAT_UNKNOWN;             // We do not know what format this is (could be UPN)
        Status = STATUS_SUCCESS;
        goto CleanUp;
    }
            
    Status = STATUS_INVALID_ADDRESS;
    DebugLog((DEB_ERROR, "DigestDecodeUserAccount: Invalid format for username and realm\n", Status));

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeUserAccount: Leaving 0x%x\n", Status));
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestDirectiveCheck
//
//  Synopsis:   Check the directives parsed out of Challenge or ChalengeResponse
//                sinple checks if directives are present
//
//  Arguments:  pDigest - pointer to Digest parameter struct
//              typeDigestMode - SASL or HTTP mode

//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS
DigestDirectiveCheck(
    IN PDIGEST_PARAMETER pDigest,
    IN DIGEST_TYPE typeDigest)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(pDigest);

    DebugLog((DEB_TRACE_FUNC, "DigestDirectiveCheck: Entering\n"));

    if (pDigest->usDirectiveCnt[MD5_AUTH_USERNAME] > 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: Username directive error 0x%x\n", Status));
        goto CleanUp;
    }

    if (pDigest->usDirectiveCnt[MD5_AUTH_NONCE] != 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: Nonce directives error 0x%x\n", Status));
        goto CleanUp;
    }

    if (pDigest->usDirectiveCnt[MD5_AUTH_STALE] > 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: Stale directives error 0x%x\n", Status));
        goto CleanUp;
    }

    if (pDigest->usDirectiveCnt[MD5_AUTH_MAXBUF] > 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: MaxBuf directives error 0x%x\n", Status));
        goto CleanUp;
    }

    if (pDigest->usDirectiveCnt[MD5_AUTH_CHARSET] > 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: Charset directives error 0x%x\n", Status));
        goto CleanUp;
    }

    if ((typeDigest == SASL_CLIENT) && (pDigest->usDirectiveCnt[MD5_AUTH_ALGORITHM] != 1))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: Algorithm directives error 0x%x\n", Status));
        goto CleanUp;
    }

    // From RFC, realm must be present if server provided one in challenge
    // Since we are the server processing the challengeResonse and we always send
    // a realm, require a realm to be specified.
    if ((typeDigest == SASL_SERVER) && (pDigest->usDirectiveCnt[MD5_AUTH_REALM] != 1))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: Sasl server requires one realm 0x%x\n", Status));
        goto CleanUp;
    }

    if (pDigest->usDirectiveCnt[MD5_AUTH_CIPHER] > 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: Algorithm directives error 0x%x\n", Status));
        goto CleanUp;
    }

    if (pDigest->usDirectiveCnt[MD5_AUTH_NC] > 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestDirectiveCheck: NC directives error 0x%x\n", Status));
        goto CleanUp;
    }

    // Set flags according to directives present
    if (pDigest->usDirectiveCnt[MD5_AUTH_AUTHZID])
    {
        pDigest->usFlags |= FLAG_AUTHZID_PROVIDED;
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestDirectiveCheck: Leaving 0x%x\n", Status));
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestForwardRequest
//
//  Synopsis:   The AccountName provided can not be processed locally.
//     The user's account is not local no this domain.  CrackName will be called if necessary to identify
//    another DC (which should have that user account)
//    The output Response will be directly passed back to the originating server
//
//  Arguments: 
//       OUT PBOOL  pfDigestValid - was the digest request call successful
//       OUT PULONG  ulAuthDataSize - holds the size of the AuthData returned from the forwarded call
//       OUT PUCHAR pucAuthDat - allocated buffer to hold the AuthData (if any) for the digest request
//
//  Returns: NTSTATUS
//
//  Notes:  After the crack name, the Digest_Parameters could be reformed with the newly discovered
//     CrackNameAccount and CrackNameDomain and then set the NameType field. 
//
//---------------------------------------------------------------------

NTSTATUS
DigestForwardRequest(
                 IN PDIGEST_PARAMETER pDigest,
                 OUT PBOOL  pfDigestValid,
                 OUT PULONG pulAuthDataSize,
                 OUT PUCHAR *ppucAuthData)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    ULONG RequestSize = 0;
    ULONG ResponseSize = 0;
    PUCHAR Where = NULL;
    PWCHAR pwczAcct = NULL;
    USHORT usFlagsSaved = 0;
    BOOL fWithinForest = FALSE;
    BOOL fIsThisDomain = FALSE;

    PWCHAR pwszName = NULL;     // name for the account to crack

    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    PUNICODE_STRING pusrtForwardDomain = NULL;

    WCHAR wczCrackedDnsDomain[DNS_MAX_NAME_LENGTH + 1];
    DWORD dwCrackedDnsDomainCnt = sizeof( wczCrackedDnsDomain ) / sizeof( WCHAR );
    WCHAR wczCrackedName[UNLEN+DNS_MAX_NAME_LENGTH + 2];
    DWORD dwCrackedNameCnt = sizeof( wczCrackedName ) / sizeof( WCHAR );
    DWORD dwCrackError = 0;

    USHORT cbDigestParamEncoded = 0;     // Contains the number of bytes in Request to send out
    BYTE  *pDigestParamEncoded = NULL;

    PMSV1_0_PASSTHROUGH_REQUEST PassthroughRequest = NULL;
    PMSV1_0_PASSTHROUGH_RESPONSE PassthroughResponse = NULL;

    ASSERT(pDigest);
    ASSERT(pfDigestValid);
    ASSERT(pulAuthDataSize);
    ASSERT(ppucAuthData);

    // Set default output
    *pfDigestValid = FALSE;
    *pulAuthDataSize = 0;
    *ppucAuthData = NULL;

    DebugLog((DEB_TRACE_FUNC, "DigestForwardRequest: Entering\n"));

    // Verify that this request is being sent from the server's domain
    if (!(pDigest->usFlags & FLAG_SERVERS_DOMAIN))
    {
        Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
        DebugLog((DEB_ERROR,"DigestForwardRequest: Forwarding request allowed only from Server's Domain\n"));
        goto CleanUp;
    }

    // If no CrackedDomain specified, call CrackName on the GC
    // for the AccountName and domain to utilize
    // If format was NT4 NetBIOS, then userCrackedDomain and userCrackedName already filled in
    //     If not, then try to crackname a UPN,
    //        if crackname fails, then use "hint" of realm to go there for SamAccountName

    if (!pDigest->ustrCrackedDomain.Length)
    {
        DebugLog((DEB_ERROR,"DigestForwardRequest: Cracking the name to determine which DC to forward request to\n"));

        if (pDigest->ustrUsername.Length && pDigest->ustrUsername.Buffer)
        {
            pwszName = (PWCHAR)DigestAllocateMemory(pDigest->ustrUsername.Length + sizeof(WCHAR));
            if (!pwszName)
            {
                Status = SEC_E_INSUFFICIENT_MEMORY;
                DebugLog((DEB_ERROR,"DigestForwardRequest: Out of memory for accountname\n"));
                goto CleanUp;
            }
    
            RtlCopyMemory(
                         pwszName,
                         pDigest->ustrUsername.Buffer,
                         pDigest->ustrUsername.Length
                         );
        }
    
        DebugLog((DEB_TRACE, "DigestForwardRequest: Checking with CrackSingleName\n"));
        Status = CrackSingleName(DS_USER_PRINCIPAL_NAME,
                                 DS_NAME_NO_FLAGS,
                                 pwszName,
                                 DS_NT4_ACCOUNT_NAME,
                                 &dwCrackedDnsDomainCnt,
                                 wczCrackedDnsDomain,
                                 &dwCrackedNameCnt,
                                 wczCrackedName,
                                 &dwCrackError);
        if (NT_SUCCESS(Status) && (DS_NAME_NO_ERROR == dwCrackError))
        {
            DebugLog((DEB_TRACE, "DigestForwardRequest: CrackSingleName DS_USER_PRINCIPAL_NAME Succeeded\n"));
            DebugLog((DEB_TRACE, "DigestForwardRequest: CrackSingleName dwErr 0x%x   CrackName %S    CrackDomain %S\n",
                       dwCrackError,
                      wczCrackedName,
                      wczCrackedDnsDomain));
    
            // Output name format always will be domain+'\'+account+'\0'
            // Need account location
            pwczAcct = wcschr(wczCrackedName, L'\\');
            if (!pwczAcct)
            {
                Status = STATUS_INVALID_ADDRESS;
                DebugLog((DEB_ERROR, "DigestForwardRequest: Can not locate Account name  0x%x\n", Status));
                goto CleanUp;
            }
    
            UnicodeStringFree(&(pDigest->ustrCrackedAccountName));
            UnicodeStringFree(&(pDigest->ustrCrackedDomain));
            Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedAccountName), pwczAcct+1,0);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestForwardRequest: UnicodeStringDuplicate  Username  error 0x%x\n", Status));
                goto CleanUp;
            }
    
            Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedDomain), wczCrackedDnsDomain,0);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestForwardRequest: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
                goto CleanUp;
            }
    
            pDigest->typeName =  NAMEFORMAT_UPN;
            pDigest->usFlags =  pDigest->usFlags & (~FLAG_CRACKNAME_ON_DC);   // reset - name is now cracked
            
            pusrtForwardDomain = &(pDigest->ustrCrackedDomain);    // forward request to this domain
        }
        else
        {
            // Failed to CrackName a UPN, check if realm "hint" specified, if so use that
            if (pDigest->ustrRealm.Length)
            {
                // if realm is not the same as this domain (we should have been able to open the sam then)
                fIsThisDomain = DigestCompareDomainNames(&(pDigest->ustrRealm),
                                                         &(g_NtDigestSecPkg.DnsDomainName),
                                                         &(g_NtDigestSecPkg.DomainName));
                if (fIsThisDomain)
                {
                    DebugLog((DEB_TRACE, "DigestForwardRequest: Realm hint provides no forwarding domain\n"));
                    Status = STATUS_LOGON_FAILURE;     // indicate that there was a format problem
                    goto CleanUp;
                }

                pDigest->typeName =  NAMEFORMAT_UNKNOWN;   // We do not know if a local UPN or SAMAccount

                pusrtForwardDomain = &(pDigest->ustrRealm);    // forward request to realm's "hint" domain
            }
            else
            {
                // Can not crackname and there is no realm "hint" so give up
                DebugLog((DEB_TRACE, "DigestForwardRequest: CrackSingleName DS_USER_PRINCIPAL_NAME Failed 0x%x  CrackErr 0x%x\n",
                           Status,
                          dwCrackError));
                if (NT_SUCCESS(Status))
                {
                    Status = STATUS_LOGON_FAILURE;     // indicate that there was a format problem
                }
                goto CleanUp;
            }
        }
        
    }
    else
    {
        pusrtForwardDomain = &(pDigest->ustrCrackedDomain);    // we already have a cracked domain to forward request to
    }

    // Verify that we have a domain to forward request to
    if (!pusrtForwardDomain || (!pusrtForwardDomain->Length))
    {
        DebugLog((DEB_TRACE, "DigestForwardRequest: failed to determine DC to forward request to\n"));
        Status = STATUS_NO_SUCH_DOMAIN;
        goto CleanUp;
    }

    // Verify that the target DC is not an external trust - allow only passthrough within forest - bug 506114
    Status = LsaIIsDomainWithinForest(pusrtForwardDomain,
                                      &fWithinForest,
                                      NULL,
                                      &(pDigest->pTrustSid),
                                      NULL,   // &(pDigest->ulTrustDirection),
                                      NULL,   // &(pDigest->ulTrustType),
                                      NULL);  // &(pDigest->ulTrustAttributes));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestCrackNameAndForward: LsaIIsDomainWithinForest failed 0x%x\n", Status));
        goto CleanUp;
    }
    if (!fWithinForest)
    {
        Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        DebugLog((DEB_ERROR, "DigestCrackNameAndForward: Target DC is outside forest - fail request 0x%x\n", Status));
        goto CleanUp;
    }

    // Since the service domain and the user account domain are in the same forest
    // the following parameters can be fixed
    // Note: this means that WDigest does not honor quarantined domains!!!!!!
    // To enable quarantined domains, we need to have callout processing at each domain hop - which NTLM
    // generic passthrough does not support FIXFIX
    pDigest->ulTrustType       = TRUST_TYPE_UPLEVEL;
    pDigest->ulTrustDirection  = TRUST_DIRECTION_OUTBOUND;
    pDigest->ulTrustAttributes = 0;

    // Re-encode the blob to send over to the other DC
    // Serialize the Digest Parameters

    // Clear the server's domain flag so only a single hop from this domain is allowed
    usFlagsSaved = pDigest->usFlags;
    pDigest->usFlags = pDigest->usFlags & (~FLAG_SERVERS_DOMAIN);

    cbDigestParamEncoded = 0;    // Will be allocated by BlobEncodeRequest
    Status = BlobEncodeRequest(pDigest, &pDigestParamEncoded, &cbDigestParamEncoded);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestForwardRequest: BlobEncodeRequest failed 0x%x\n", Status));
        goto CleanUp;
    }

    // Restore the original flags for this digest request
    pDigest->usFlags = usFlagsSaved;

    // Callpackge over to that domain
    RequestSize = sizeof(MSV1_0_PASSTHROUGH_REQUEST) +
                  pusrtForwardDomain->Length +
                  g_ustrNtDigestPackageName.Length +
                  cbDigestParamEncoded;

    PassthroughRequest = (PMSV1_0_PASSTHROUGH_REQUEST) DigestAllocateMemory(RequestSize);
    if (PassthroughRequest == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanUp;
    }
    Where = (PUCHAR) (PassthroughRequest + 1);       // Points to byte AFTER passthrough header

    PassthroughRequest->MessageType = MsV1_0GenericPassthrough;

    PassthroughRequest->DomainName.Length = pusrtForwardDomain->Length;
    PassthroughRequest->DomainName.MaximumLength = pusrtForwardDomain->Length;
    PassthroughRequest->DomainName.Buffer = (LPWSTR) Where;       // this is NOT NULL TERMINATED
    RtlCopyMemory(
                 Where,
                 pusrtForwardDomain->Buffer,
                 pusrtForwardDomain->Length
                 );
    Where += pusrtForwardDomain->Length;

    PassthroughRequest->PackageName.Length = g_ustrNtDigestPackageName.Length;
    PassthroughRequest->PackageName.MaximumLength = g_ustrNtDigestPackageName.Length;
    PassthroughRequest->PackageName.Buffer = (LPWSTR) Where;    // Not NULL terminated - relative reference
    RtlCopyMemory(
                 Where,
                 g_ustrNtDigestPackageName.Buffer,
                 g_ustrNtDigestPackageName.Length
                 );
    Where += g_ustrNtDigestPackageName.Length;
    PassthroughRequest->LogonData = Where;
    PassthroughRequest->DataLength = (ULONG)cbDigestParamEncoded;

    RtlCopyMemory(
                 Where,
                 pDigestParamEncoded,
                 cbDigestParamEncoded
                 );

    //
    // We've build the buffer, now call NTLM to pass it through.
    //

    DebugLog((DEB_TRACE, "DigestForwardRequest: Sending request via passthrough to %wZ\n", pusrtForwardDomain));

    Status = g_LsaFunctions->CallPackage(
                                        &MsvPackageName,
                                        PassthroughRequest,
                                        RequestSize,                                  // How many bytes to send in Request
                                        (PVOID *) &PassthroughResponse,               // Place the buffers here
                                        &ResponseSize,                                // Passed back the size of the buffer
                                        &SubStatus                                    // Return code from Digest Auth on the DC
                                        );


    DebugLog((DEB_TRACE, "DigestForwardRequest: Server passthrough Responsesize %ld, Status 0x%x, SubStatus 0x%x\n",
              ResponseSize, Status, SubStatus));

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"DigestForwardRequest: Failed to call MSV package to verify Digest: 0x%x\n",Status));
        if (Status == STATUS_INVALID_INFO_CLASS)
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto CleanUp;
    }

    // Now check the status of the request over on the remote DC
    if (!NT_SUCCESS(SubStatus))
    {
        Status = SubStatus;
        DebugLog((DEB_ERROR,"DigestForwardRequest: DC failed to verify Digest Response: 0x%x\n",Status));
        goto CleanUp;
    }

    if (!PassthroughResponse || (ResponseSize == 0) || (PassthroughResponse->DataLength == 0))
    {
        DebugLog((DEB_ERROR,"DigestForwardRequest: PassthroughResponse contains no valid data\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestForwardRequest: PassthroughResponse->DataLength %ld\n",
              PassthroughResponse->DataLength));

    Where = (PUCHAR) (PassthroughResponse + 1);          // start copy after header 
    Status =  DigestDecodeResponse(PassthroughResponse->DataLength,
                                   Where,
                                   pfDigestValid,
                                   pulAuthDataSize,
                                   ppucAuthData,
                                   &(pDigest->strSessionKey),
                                   &(pDigest->ustrCrackedAccountName),
                                   &(pDigest->ustrCrackedDomain));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"DigestForwardRequest: Failed DigestDecodeResponse    0x%x\n",Status));
        goto CleanUp;
    }


CleanUp:

    BlobFreeRequest(pDigestParamEncoded);
    pDigestParamEncoded = NULL;
    cbDigestParamEncoded = 0;


    if (pwszName != NULL)
    {
        DigestFreeMemory(pwszName);
    }

    if (PassthroughRequest != NULL)
    {
        DigestFreeMemory(PassthroughRequest);
    }

    if (PassthroughResponse != NULL)
    {
        g_LsaFunctions->FreeReturnBuffer(PassthroughResponse);
    }

    DebugLog((DEB_TRACE_FUNC, "DigestForwardRequest: Leaving 0x%x\n", Status));
    
    return Status;
}



/*++

Routine Description:

    This routine parses a Token Descriptor and pulls out the useful
    information.

Arguments:

    TokenDescriptor - Descriptor of the buffer containing the token. 

    BufferIndex - Selects which buffer to extract
    
    Token - Handle to the SecBuffer to write selected buffer to.

    ReadonlyOK - TRUE if the token buffer may be readonly.

Return Value:

    TRUE - If token buffer was properly found.

--*/

BOOLEAN
SspGetTokenBufferByIndex(
    IN PSecBufferDesc TokenDescriptor,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    )
{

    NTSTATUS StatusTmp = STATUS_SUCCESS;
    PSecBuffer Buffer = NULL;

    //
    // Verify inputs are valid
    //

    ASSERT(*Token != NULL);
    ASSERT(TokenDescriptor);
    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        return FALSE;
    }

    if (TokenDescriptor->ulVersion != SECBUFFER_VERSION)
    {
        DebugLog((DEB_ERROR,"SspGetTokenBufferByIndex: Wrong Version number\n"));
        return FALSE;
    }

    //
    // Verify that it is a valid location
    //

    if (BufferIndex >= TokenDescriptor->cBuffers)
    {
        DebugLog((DEB_ERROR,"SspGetTokenBufferByIndex: Index out of range for SecBufferDesc\n"));
        return FALSE;
    }

    // DebugLog((DEB_TRACE,"SspGetTokenBufferByIndex: NumberTokens %d\n",TokenDescriptor->cBuffers));

    Buffer = &TokenDescriptor->pBuffers[BufferIndex];

    //
    // If the buffer is readonly and readonly isn't OK,
    // reject the buffer.
    //

    if (!ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY))
    {
        DebugLog((DEB_TRACE,"SspGetTokenBufferByIndex: request write on READONLY Token buffer\n"));
        return  FALSE;
    }

    //
    // Return the requested information
    //
    if (Buffer->cbBuffer && Buffer->pvBuffer)
    {
        StatusTmp = g_LsaFunctions->MapBuffer(Buffer, Buffer);
        if (!NT_SUCCESS(StatusTmp))
        {
            DebugLog((DEB_ERROR,"SspGetTokenBufferByIndex: Unable to MapBuffer 0x%x\n", StatusTmp));
            return FALSE;
        }
    }

    *Token = Buffer;

    return TRUE;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestEncodeResponse
//
//  Synopsis:   Generate the serialized response from the digest processing to send back along generic passthrough
//
//  Arguments: 
//
//  Returns: NTSTATUS
//
//
//---------------------------------------------------------------------
NTSTATUS
DigestEncodeResponse(IN BOOL fDigestValid,
                       IN PDIGEST_PARAMETER pDigest,
                       IN ULONG  ulAuthDataSize,
                       IN PUCHAR pucAuthData,
                       OUT PULONG pulResponse,
                       OUT PBYTE *ppResponse)
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT usAcctNameSize = 0;
    PCHAR  pcLoc = NULL;
    ULONG  ulBuffer = 0;
    PDIGEST_BLOB_RESPONSE pBlobResponse = NULL;

    DebugLog((DEB_TRACE_FUNC, "DigestEncodeResponse: Entering\n"));

    ASSERT(pDigest);
    ASSERT(pulResponse);
    ASSERT(ppResponse);

    *pulResponse = 0; 
    *ppResponse = NULL;

    //     domain\accountname NULL format
    usAcctNameSize = pDigest->ustrCrackedDomain.Length + pDigest->ustrCrackedAccountName.Length + (2 * sizeof(WCHAR));

    // We completed the Auth (it might have failed though)
    // Make sure enough room in output buffer
    ulBuffer = sizeof(DIGEST_BLOB_RESPONSE);
    if (fDigestValid == TRUE)
    {
        // We succeeded in auth so send back AuthData for tokens & AccountName
        ulBuffer += ulAuthDataSize;
        ulBuffer = ulBuffer + usAcctNameSize;
    }
    else
    {
        ulAuthDataSize = 0;    // Do not send back Auth data unless Digest Calc Succeeded
        Status = STATUS_LOGON_FAILURE;     // report back only Logon failuer UnknownUser/BadPassword
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestEncodeResponse: Total size for return buffer is %ld bytes\n", ulBuffer));

    pBlobResponse = (PDIGEST_BLOB_RESPONSE)DigestAllocateMemory(ulBuffer);
    if (!pBlobResponse)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "DigestEncodeResponse: Can not allocate memory for Output Response Buffer\n"));
        goto CleanUp;
    }

    pBlobResponse->MessageType = VERIFY_DIGEST_MESSAGE_RESPONSE;
    pBlobResponse->version = DIGEST_BLOB_VERSION;
    if (fDigestValid == TRUE)
    {
        pBlobResponse->Status = STATUS_SUCCESS;
    }
    else
    {
        pBlobResponse->Status = STATUS_LOGON_FAILURE;
    }
    pBlobResponse->ulAuthDataSize = ulAuthDataSize;
    pBlobResponse->usAcctNameSize = usAcctNameSize;   // size includes a NULL terminator
    pBlobResponse->ulBlobSize =  ulBuffer;

    // Could be an assert too
    if (pDigest->strSessionKey.Length != MD5_HASH_HEX_SIZE)
    {
        DebugLog((DEB_ERROR, "DigestEncodeResponse: Failed SessionKey generation\n"));
        Status = STATUS_INTERNAL_ERROR;      // Program flow failure
        goto CleanUp;
    }
    pBlobResponse->SessionKeyMaxLength = MD5_HASH_HEX_SIZE + 1;   // MD5 hash + NULL
    memcpy(pBlobResponse->SessionKey, pDigest->strSessionKey.Buffer, MD5_HASH_HEX_SIZE);

    pcLoc = &(pBlobResponse->cAuthData);

    if (ulAuthDataSize)
    {   // Copy over the ExpandedAuthData only if DigestCalc succeeded (i.e. ulExpandedAuthDataSize != 0)
        pcLoc = &(pBlobResponse->cAuthData);
        memcpy(pcLoc, pucAuthData, ulAuthDataSize);
        pcLoc = pcLoc + ulAuthDataSize;
    }

    // Copy over the accountname for use in querycontextattributes
    memcpy(pcLoc, pDigest->ustrCrackedDomain.Buffer, pDigest->ustrCrackedDomain.Length);
    pcLoc = pcLoc + pDigest->ustrCrackedDomain.Length;
    memcpy(pcLoc, L"\\", sizeof(WCHAR));
    pcLoc = pcLoc + sizeof(WCHAR);
    memcpy(pcLoc, pDigest->ustrCrackedAccountName.Buffer, pDigest->ustrCrackedAccountName.Length);
    pcLoc = pcLoc + pDigest->ustrCrackedAccountName.Length + sizeof(WCHAR);    // skip the NULL WCHAR

    // OK we are done filling in output Response buffer

    *pulResponse = ulBuffer;                            // Set the size of the response blob
    *ppResponse = (PBYTE)pBlobResponse;                 // set the buffer allocated
    pBlobResponse = NULL;

CleanUp:

    if (!NT_SUCCESS(Status))
    {
        if (pBlobResponse)
        {
            DigestFreeMemory(pBlobResponse);
            pBlobResponse = NULL;
        }
    }

    DebugLog((DEB_TRACE_FUNC, "DigestEncodeResponse: Leaving  Status 0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestDecodeResponse
//
//  Synopsis:   Process the serialized response from Passthrough for forwarded digest's response
//
//  Arguments: 
//
//  Returns: NTSTATUS
//
//
//---------------------------------------------------------------------
NTSTATUS
DigestDecodeResponse(IN ULONG ulResponseDataSize,
                     IN PUCHAR puResponseData,
                     OUT PBOOL pfDigestValid,
                     OUT PULONG pulAuthDataSize,
                     OUT PUCHAR *ppucAuthData,
                     OUT PSTRING pstrSessionKey,
                     OUT OPTIONAL PUNICODE_STRING pustrAccountName,
                     OUT OPTIONAL PUNICODE_STRING pustrAccountDomain
                     )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_BLOB_RESPONSE pDigestResponse = NULL;
    BOOL fKnownFormat = FALSE;
    USHORT usNumWChar = 0;
    PUCHAR puTempAuth = NULL;
    USHORT uNumWChar = 0;
    UNICODE_STRING ustrAccount = {0};
    PUSHORT pwczAcct = NULL;

    ASSERT(pfDigestValid);
    ASSERT(ppucAuthData);
    ASSERT(pulAuthDataSize);
    ASSERT(pstrSessionKey);

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeResponse: Entering\n"));

    *pfDigestValid = FALSE;
    *pulAuthDataSize = 0;
    *ppucAuthData = NULL;
    StringFree(pstrSessionKey);

    // Now pull out info from the Passthrough Response structure
    if (ulResponseDataSize < sizeof(DIGEST_BLOB_RESPONSE))
    {
        // The returned data is not the expected size
        Status = STATUS_INTERNAL_ERROR;
        DebugLog((DEB_ERROR,"DigestDecodeResponse: DC Response wrong data size: 0x%x\n",Status));
        goto CleanUp;
    }

    // Copy it to a structure - can do direct map once we know this works OK
    // Copy to Allocated memory forces aligment of fields
    pDigestResponse = (PDIGEST_BLOB_RESPONSE)DigestAllocateMemory(ulResponseDataSize);
    if (!pDigestResponse)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR,"DigestDecodeResponse: Out of memory for response buffer alloc\n"));
        goto CleanUp;
    }

    RtlCopyMemory(
                 pDigestResponse,
                 puResponseData,
                 ulResponseDataSize
                 );

    // We should now have all the data we need for sessionkeys and if verified auth

    // Check the MessageType and Versions if supported
    if ((pDigestResponse->MessageType == VERIFY_DIGEST_MESSAGE_RESPONSE) && (pDigestResponse->version == DIGEST_BLOB_VERSION))
    {
        fKnownFormat = TRUE;      // We know how to process this blob from the DC
        DebugLog((DEB_TRACE,"DigestDecodeResponse: DC Response known type and version\n"));
    }

    if (!fKnownFormat)
    {
        // The returned data not of a known type or version
        Status = STATUS_INTERNAL_ERROR;
        DebugLog((DEB_ERROR,"DigestDecodeResponse: DC Response unknown type or version\n"));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE,"DigestDecodeResponse: Processing DC Response\n"));

    if (!pDigestResponse->ulAuthDataSize)
    {
        // We do not have any AuthData
        Status = STATUS_INTERNAL_ERROR;
        DebugLog((DEB_ERROR, "DigestDecodeResponse: Failed to determine AuthData\n"));
        goto CleanUp;             
    }

    // Copy over data to place on correct boundary (alloc should force long word boundary)
    puTempAuth = (PUCHAR)DigestAllocateMemory( ROUND_UP_COUNT(pDigestResponse->ulAuthDataSize, 8));
    if (!puTempAuth)
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "DigestDecodeResponse: out of memory on response PAC buffer\n"));
        goto CleanUp;
    }
    memcpy(puTempAuth,&(pDigestResponse->cAuthData),pDigestResponse->ulAuthDataSize);


    // Copy out the SessionKey
    StringFree(pstrSessionKey);
    Status = StringAllocate(pstrSessionKey, pDigestResponse->SessionKeyMaxLength);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestDecodeResponse: Failed to alloc Sessionkey memory\n"));
        goto CleanUp;
    }

    memcpy(pstrSessionKey->Buffer, pDigestResponse->SessionKey, pDigestResponse->SessionKeyMaxLength);
    pstrSessionKey->Length = (USHORT)strlencounted(pstrSessionKey->Buffer, pDigestResponse->SessionKeyMaxLength);

    DebugLog((DEB_TRACE, "DigestDecodeResponse: Response Data from passthrough call\n"));
    DebugLog((DEB_TRACE, "       Session Key: %Z\n", pstrSessionKey));


    // Pull out the NetBios Accountname and domain - optional output
    if (pustrAccountName || pustrAccountDomain)
    {
        UnicodeStringFree(pustrAccountName);
        UnicodeStringFree(pustrAccountDomain);

        if (pDigestResponse->usAcctNameSize > sizeof(WCHAR))
        {
            usNumWChar = pDigestResponse->usAcctNameSize / sizeof(WCHAR);

            Status = UnicodeStringAllocate(&ustrAccount, usNumWChar);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestDecodeResponse: Failed to alloc Account memory\n"));
                goto CleanUp;
            }

            RtlCopyMemory(ustrAccount.Buffer,
                   &(pDigestResponse->cAuthData) + pDigestResponse->ulAuthDataSize,
                   pDigestResponse->usAcctNameSize);
            ustrAccount.Length = ustrlencounted((const short *)ustrAccount.Buffer, pDigestResponse->usAcctNameSize) *
                                 sizeof(WCHAR);

            DebugLog((DEB_TRACE, "DigestDecodeResponse: NetBios AccountName %wZ\n", &ustrAccount));
        }

        // Now extract the accountname and the domain from the NETBios format   domain\username

        pwczAcct = wcschr(ustrAccount.Buffer, L'\\');
        if (pwczAcct)
        {
            // Output name format always will be domain+'\'+account+'\0'
            // Need account location

            if (pustrAccountName)
            {
                Status = UnicodeStringWCharDuplicate(pustrAccountName, pwczAcct+1, 0);
                if (!NT_SUCCESS (Status))
                {
                    DebugLog((DEB_ERROR, "DigestDecodeResponse: UnicodeStringDuplicate  Account  error 0x%x\n", Status));
                    goto CleanUp;
                }
            }

            if (pustrAccountDomain)
            {
                uNumWChar = (USHORT)(pwczAcct - ustrAccount.Buffer);
                if (uNumWChar > 1)
                {   //  we will only copyout the Domain if there is aleast 1 WChar; otherwise it is of the form "\accountname"
                    Status = UnicodeStringWCharDuplicate(pustrAccountDomain, ustrAccount.Buffer, uNumWChar);
                    if (!NT_SUCCESS (Status))
                    {
                        DebugLog((DEB_ERROR, "DigestDecodeResponse: UnicodeStringDuplicate  Domain  error 0x%x\n", Status));
                        goto CleanUp;
                    }
                }
            }

        }

        DebugLog((DEB_TRACE, "DigestDecodeResponse: Account %wZ   Domain %wZ\n",
                  pustrAccountName, pustrAccountDomain));

    }

    DebugLog((DEB_TRACE, "DigestDecodeResponse: AuthData Size %lu\n", pDigestResponse->ulAuthDataSize));
    *pulAuthDataSize = pDigestResponse->ulAuthDataSize;
    *ppucAuthData = puTempAuth;   // sign over the memory
    puTempAuth = NULL;
    *pfDigestValid = TRUE;

CleanUp:

    if (puTempAuth)
    {   // Clear out temp allocation if function failed
        DigestFreeMemory(puTempAuth);
        puTempAuth = NULL;
    }

    UnicodeStringFree(&ustrAccount);


    if (pDigestResponse)
    {
        DigestFreeMemory(pDigestResponse);
    }

    DebugLog((DEB_TRACE_FUNC, "DigestDecodeResponse: Leaving   0x%x\n", Status));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\ctxt.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ctxt.h
//
// Contents:    declarations, constants for context manager
//
//
// History:     KDamour  15Mar00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_CTXT_H
#define NTDIGEST_CTXT_H

#define RSPAUTH_STR "rspauth=%Z"

// Hash locations for pre-calculated DS hashes                      
#define PRECALC_NONE 0
#define PRECALC_ACCOUNTNAME 1
#define PRECALC_UPN 2
#define PRECALC_NETBIOS 3

//  Number of secbuffers for each type  HTTP and SASL
#define ASC_HTTP_NUM_INPUT_BUFFERS 5
#define ASC_SASL_NUM_INPUT_BUFFERS 1
#define ASC_HTTP_NUM_OUTPUT_BUFFERS 1
#define ASC_SASL_NUM_OUTPUT_BUFFERS 1
 
// Initializes the context manager package 
NTSTATUS CtxtHandlerInit(VOID);

// Add a Context into the Cntext List
NTSTATUS CtxtHandlerInsertCred(IN PDIGEST_CONTEXT  pDigestCtxt);

// Initialize all the struct elements in a Context from the Credential
NTSTATUS NTAPI ContextInit(IN OUT PDIGEST_CONTEXT pContext, IN PDIGEST_CREDENTIAL pCredential);

// Release memory utilized by the Context
NTSTATUS NTAPI ContextFree(IN PDIGEST_CONTEXT pContext);

// Find the security context handle by the opaque reference
NTSTATUS NTAPI CtxtHandlerOpaqueToPtr(
                             IN PSTRING pstrOpaque,
                             OUT PDIGEST_CONTEXT *ppContext);

// Find the security context by the security context handle
NTSTATUS NTAPI CtxtHandlerHandleToContext(IN ULONG_PTR ContextHandle, IN BOOLEAN RemoveContext,
    OUT PDIGEST_CONTEXT *ppContext);

// Releases the Context by decreasing reference counter
NTSTATUS CtxtHandlerRelease(
    PDIGEST_CONTEXT pContext,
    ULONG ulDereferenceCount);

// Check to see if COntext is within valid lifetime
BOOL CtxtHandlerTimeHasElapsed(PDIGEST_CONTEXT pContext);

// From ctxtapi.cxx

// Creates the Output SecBuffer for the Challenge
NTSTATUS NTAPI ContextCreateChal(IN PDIGEST_CONTEXT pContext, IN PSTRING pstrRealm, OUT PSecBuffer OutBuffer);


// Called for server incoming messages - verify Digest and generate sessionkey if necessary
NTSTATUS NTAPI DigestProcessParameters(IN OUT PDIGEST_CONTEXT pContext,
                                       IN PDIGEST_PARAMETER pDigest,
                                       OUT PSecBuffer pFirstOutputToken,
                                       OUT PNTSTATUS pAuditLogStatus,
                                       OUT PNTSTATUS pAuditLogSubStatus,
                                       PBOOL fGenerateAudit);

// Called for client outbound messages - generate the response hash
NTSTATUS NTAPI DigestGenerateParameters(IN OUT PDIGEST_CONTEXT pContext,
    IN PDIGEST_PARAMETER pDigest, OUT PSecBuffer pFirstOutputToken);

// LSA calls this function in the Generic Passthrough call
NTSTATUS NTAPI DigestPackagePassthrough(IN USHORT cbMessageRequest, IN BYTE *pMessageRequest,
                         IN OUT ULONG *pulMessageResponse, OUT PBYTE *ppMessageResponse);

// Lookup passwords and perform digest cal auth (runs on the DC)
NTSTATUS NTAPI DigestResponseBru(IN USHORT cbMessageRequest,
                                 IN BYTE *pDigestParamEncoded,
                                 OUT PULONG pculResponse,
                                 OUT PBYTE *ppResponse);

NTSTATUS DigestEncodeResponse(IN BOOL fDigestValid,
                       IN PDIGEST_PARAMETER pDigest,
                       IN ULONG  ulAuthDataSize,
                       IN PUCHAR pucAuthData,
                       OUT PULONG pulResponse,
                       OUT PBYTE *ppResponse);

NTSTATUS DigestDecodeResponse(IN ULONG ulResponseDataSize,
                     IN PUCHAR puResponseData,
                     OUT PBOOL pfDigestValid,
                     OUT PULONG pulAuthDataSize,
                     OUT PUCHAR *ppucAuthData,
                     OUT PSTRING pstrSessionKey,
                     OUT OPTIONAL PUNICODE_STRING pustrAccountName,
                     OUT OPTIONAL PUNICODE_STRING pustrAccountDomain
                     );

// Formatted printout of Context
NTSTATUS ContextPrint(IN PDIGEST_CONTEXT pDigest);

// Create a logonSession for the Authenticated LogonToken in the SecurityContext
NTSTATUS CtxtCreateLogSess(IN PDIGEST_CONTEXT pDigest);

//  Extract the username & domain from the Digest structure directives
NTSTATUS UserCredentialsExtract(PDIGEST_PARAMETER pDigest,
                                PUSER_CREDENTIALS pUserCreds);

//   Release memory allocated into UserCredentials
NTSTATUS UserCredentialsFree(PUSER_CREDENTIALS pUserCreds);

NTSTATUS DigestSASLResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pOutputToken);

NTSTATUS DigestCalculateResponseAuth(
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSTRING pstrHash);

NTSTATUS DigestDecodeUserAccount(
    IN PDIGEST_PARAMETER pDigest);

NTSTATUS DigestForwardRequest(
                 IN PDIGEST_PARAMETER pDigest,
                 OUT PBOOL  pfDigestValid,
                 OUT PULONG pulAuthDataSize,
                 OUT PUCHAR *ppucAuthData);

NTSTATUS DigestDirectiveCheck(
    IN PDIGEST_PARAMETER pDigest,
    IN DIGEST_TYPE typeDigest);


//  This routine selects a Buffer by indexed count in the BufferIndex
BOOLEAN SspGetTokenBufferByIndex(
    IN PSecBufferDesc TokenDescriptor,
    IN ULONG BufferIndex,
    OUT PSecBuffer * Token,
    IN BOOLEAN ReadonlyOK
    );

#endif  // DNTDIGEST_CTXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\func.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ntdigestfunc.h
//
// Contents:    prototypes for export functions
//
//
// History:     KDamour  15Mar00 Stolen from NTLM ntlmfunc.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_NTDIGESTFUNC_H__
#define NTDIGEST_NTDIGESTFUNC_H__

NTSTATUS NTAPI SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    );


NTSTATUS NTAPI SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables
    );

// SpLsaModeInitializeFn           SpLsaModeInitialize;
SpInitializeFn                  SpInitialize;

// SpUserModeInitializeFn          SpUserModeInitialize;
//LSA_AP_INITIALIZE_PACKAGE       LsaApInitializePackage;

SpGetInfoFn                     SpGetInfo;
LSA_AP_LOGON_USER_EX2           LsaApLogonUserEx2;

SpAcceptCredentialsFn           SpAcceptCredentials;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle;
SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         LsaApLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             LsaApCallPackage;
LSA_AP_CALL_PACKAGE             LsaApCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH LsaApCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpQueryContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;
SpGetExtendedInformationFn      SpGetExtendedInformation ;
SpSetExtendedInformationFn      SpSetExtendedInformation ;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes ;


// Local Prototypes for Digest SSP
NTSTATUS SspCreateTokenDacl(HANDLE Token);

#endif // NTDIGEST_NTDIGESTFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\debug.h ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       debug.h
//
// Contents:   debugging information for SSP
//
//             Helper functions:
//
// History:    KDamour  15Mar00   created
//
//---------------------------------------------------------------------

#ifndef NTDIGEST_DEBUG_H
#define NTDIGEST_DEBUG_H


#ifdef SECURITY_KERNEL

// Context Signatures
#define WDIGEST_CONTEXT_SIGNATURE 'TSGD'

#if DBG
extern "C"
{
void KsecDebugOut(ULONG, const char *, ...);
}
#define DebugLog(x) KsecDebugOut x
#else    // DBG
#define DebugLog(x)
#endif   // DBG

#else    // SECURITY_KERNEL

#include "dsysdbg.h"
DECLARE_DEBUG2(Digest);
#if DBG
#define DebugLog(x) DigestDebugPrint x
#else    // DBG
#define DebugLog(x)
#endif   // DBG

#endif   // SECURITY_KERNEL


#define DEB_ERROR      0x00000001
#define DEB_WARN       0x00000002
#define DEB_TRACE      0x00000004
#define DEB_TRACE_ASC  0x00000008
#define DEB_TRACE_ISC  0x00000010
#define DEB_TRACE_LSA  0x00000020
#define DEB_TRACE_USER 0x00000040
#define DEB_TRACE_FUNC 0x00000080
#define DEB_TRACE_MEM  0x00000100
#define TRACE_STUFF    0x00000200


#endif   /* NTDIGEST_DEBUG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\digestsspi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        digestsspi.h
//
// Contents:    credential and context structures
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\ntlmsspi.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_DIGESTSSPI_H
#define NTDIGEST_DIGESTSSPI_H

#include <time.h>
#include <wincrypt.h>

#include "auth.h"

                                                         
////////////////////////////////////////////////////////////////////////
//
// Global Definitions
//
////////////////////////////////////////////////////////////////////////


//
// Description of a logon session - stores the username, domain, password.
//   Notation used for LogonSession  is LogSess
//

typedef struct _DIGEST_LOGONSESSION {

    // Global list of all LogonSessions.
    //  (Serialized by SspLogonSessionCritSect)
    LIST_ENTRY Next;

    // This is the Handle for this LogonSession - same as its memory address - no need to ref count
    ULONG_PTR LogonSessionHandle;

    // Ref Counter Used to prevent this LogonSession from being deleted prematurely.
    // Two cases for initial value
    //     AcceptCredential sets to one and enters it into active logon list.  Call to ApLogonTerminate
    //         decrements count and removes it from list.
    // In both cases, a refcount of zero causes the logonsession to be deleted from memory
    LONG lReferences;

     // Logon ID of the client
    LUID LogonId;

    // Default credentials on client context, on server context UserName
    // Gathered from calls to SpAcceptCredentials
    SECURITY_LOGON_TYPE LogonType;
    UNICODE_STRING ustrAccountName;
    UNICODE_STRING ustrDomainName;      // Netbios domain name where account is located

    // IMPORTANT NOTE - you must use CredHandlerPasswdSet and CredHandlerPasswdGet once the
    // credential is placed into the list.  The main reason for this is that multiple threads
    // will be utilizing the same memory and this value can change as updates come in from
    // SpAcceptCredential
    // It is encrypted with LsaFunctions->LsaProtectMemory( Password->Buffer, (ULONG)Password->Length );
    // Need to decrypt with LsaFunctions->LsaUnprotectMemory( HiddenPassword->Buffer, (ULONG)HiddenPassword->Length );

    // Stores the current plaintext password (if available) with reversible encryption
    UNICODE_STRING ustrPassword;

    UNICODE_STRING ustrDnsDomainName;   // DNS domain name where account is located (if known)
    UNICODE_STRING ustrUpn;             // UPN of account (if known)

} DIGEST_LOGONSESSION, *PDIGEST_LOGONSESSION;

//
// Description of a credential.
//  We use this for a combined list of logon sessions and credentials
//

typedef struct _DIGEST_CREDENTIAL {

    //
    // Global list of all Credentials.
    //  (Serialized by SspCredentialCritSect)
    //

    LIST_ENTRY Next;

    //
    // Used to prevent this Credential from being deleted prematurely.
    //

    LONG lReferences;

    //
    // Flag to indicate that Credential is not attached to CredentialList
    //  once References is 0 and Unlinked is True - this record can be removed from list

    BOOL Unlinked;


    //
    // This is the Handle for this credential - same as its memory address
    //
    ULONG_PTR CredentialHandle;

    //
    // Flag of how credential may be used.
    //
    // SECPKG_CRED_* flags
    //

    ULONG CredentialUseFlags;

    //
    // Default credentials on client context, on server context UserName
    // Gathered from calls to SpAcceptCredentials
    //

    SECURITY_LOGON_TYPE LogonType;
    UNICODE_STRING ustrAccountName;
    LUID LogonId;                       // Logon ID of the client
    UNICODE_STRING ustrDomainName;      // Netbios domain name where account is located

    // Stores the current plaintext (if available) version of the logon users account
    // IMPORTANT NOTE - you must use CredHandlerPasswdSet and CredHandlerPasswdGet once the
    // credential is placed into the list.  The main reason for this is that multiple threads
    // will be utilizing the same memory and this value can change as updates come in from
    // SpAcceptCredential
    // Password will be encryped with LSAFunction as in LogonSession
    UNICODE_STRING ustrPassword;

    UNICODE_STRING ustrDomain;   // NetBios or DNS domain name where account is located will be used in realm directive
    UNICODE_STRING ustrUpn;             // UPN of account (if known)
    //
    // Process Id of client
    //

    ULONG ClientProcessID;

} DIGEST_CREDENTIAL, *PDIGEST_CREDENTIAL;


//
// Description of a Context
//

typedef struct _DIGEST_CONTEXT {

    // Global list of all Contexts
    //  (Serialized by SspContextCritSect)
    LIST_ENTRY Next;

    // This is the Handle for this context - same as its memory address
    ULONG_PTR ContextHandle;

    // Used to prevent this Context from being deleted prematurely.
    //  (Serialized by SspContextCritSect)
    LONG lReferences;

    // Flag to indicate that Context is not attached to List
    BOOL bUnlinked;

    // Maintain the context requirements
    ULONG ContextReq;

    // Flags for context
    //    FLAG_CONTEXT_AUTHZID_PROVIDED
    ULONG ulFlags;

    // Digest Parameters for this context
    DIGEST_TYPE typeDigest;

    // Digest Parameters for this context
    QOP_TYPE typeQOP;

    // Digest Parameters for this context
    ALGORITHM_TYPE typeAlgorithm;

    // Cipher to use for encrypt/decrypt
    CIPHER_TYPE typeCipher;

    // Charset used for digest directive values
    CHARSET_TYPE typeCharset;

    //  Server generated Nonce for Context
    STRING strNonce;

    //  Client generated CNonce for Context
    STRING strCNonce;

    // Nonce count for replay prevention
    ULONG  ulNC;

    // Maximum size for the buffers to send and receive data for auth-int and auth-conf (SASL mode)
    ULONG  ulSendMaxBuf;
    ULONG  ulRecvMaxBuf;

    //  Unique Reference for this Context   BinHex(rand[128])
    //  Utilize the First N chars of this as the CNONCE for InitializeSecurityContect
    STRING strOpaque;

    //  BinHex(H(A1)) sent from DC and stored in context for future
    //  auth without going to the DC
    STRING strSessionKey;

    // Client only -  calculated response auth to be returned from server
    STRING strResponseAuth;

    // Copy of directive values from auth - used for rspauth support
    STRING  strDirective[MD5_AUTH_LAST];


    //  Only valid after ASC has successfully authenticated and converted AuthData to Token

    // Token Handle of authenticated user
    HANDLE TokenHandle;

    // LogonID used in the Token
    LUID  LoginID;


    //
    // Information from Credentials
    //

    //
    //  Maintain a copy of the credential UseFlags (we can tell if inbound or outbound)
    //
    ULONG CredentialUseFlags;

    // Copy of the account info
    UNICODE_STRING ustrDomain;
    UNICODE_STRING ustrPassword;         // Encrypted
    UNICODE_STRING ustrAccountName;

    // Set time when Context is to Expire
    TimeStamp ExpirationTime;

} DIGEST_CONTEXT, *PDIGEST_CONTEXT;



// This structure contains the state info for the User mode
// security context. It is passwd between the LSAMode and the UserMode address spaces
// In UserMode, this is unpacked into the DIGEST_USERCONTEXT struct
typedef struct _DIGEST_PACKED_USERCONTEXT{

    ULONG  ulFlags;            // Flags to control processing of packed UserContext

    //
    // Timeout the context after awhile.
    //
    TimeStamp ExpirationTime;                // Time inwhich session key expires

    //
    // Maintain the context requirements
    //

    ULONG ContextReq;

    //
    //  Maintain a copy of the credential UseFlags (we can tell if inbound or outbound)
    //

    ULONG CredentialUseFlags;

    //
    // Digest Parameters for this context
    //

    ULONG typeDigest;

    //
    // Digest Parameters for this context
    //

    ULONG typeQOP;

    //
    // Digest Parameters for this context
    //

    ULONG typeAlgorithm;

    //
    // Cipher to use for encrypt/decrypt
    //

    ULONG typeCipher;

    //
    // Charset used for digest directive values
    //

    ULONG typeCharset;

    //
    //  Max-size of message buffer to allow for auth-int & auth-conf processing
    //  This is the combined size of (HEADER + Data + Trailer)
    //  in SASL Header is zero length, max Trailer size if padding+HMAC
    //
    ULONG ulSendMaxBuf;
    ULONG ulRecvMaxBuf;

    //
    // Token Handle of authenticated user
    //  Only valid when in AuthenticatedState.
    //     Filled in only by AcceptSecurityContext
    //     It will be NULL is struct is from InitializeSecurityContext
    //  Must cast this to a HANDLE once back into the usermode context
    //

    ULONG ClientTokenHandle;

    //  Size of each component set over
    ULONG   uSessionKeyLen;
    ULONG   uAccountNameLen;
    ULONG   uDigestLen[MD5_AUTH_LAST];

    // All directive data will be passed as single byte charaters
    // Order is the same as in auth.h (MD5_AUTH_NAME)
    // username, realm, nonce, cnonce ...  then sessionkey
    UCHAR    ucData;


} DIGEST_PACKED_USERCONTEXT, * PDIGEST_PACKED_USERCONTEXT;


// This structure contains the state info for the User mode
// security context.
typedef struct _DIGEST_USERCONTEXT{

    //
    // Global list of all Contexts
    //  (Serialized by UserContextCritSect)
    //
    LIST_ENTRY           Next;

    //
    // Handle to the LsaContext
    //     This will have the handle to the context in LSAMode Address space
    //
    ULONG_PTR            LsaContext;

    //
    // Timeout the context after awhile.
    //
    TimeStamp ExpirationTime;                // Time inwhich session key expires

    //
    // Used to prevent this Context from being deleted prematurely.
    // This is used ONLY for internal SSP pointer references.  For application handles
    // lReferenceHandles is used.  This was necessary to do to keep the count separate for
    // internal pointer references and handles that are passed to the application.  This will
    // prevent the application from calling DeleteSecurityContext() too many times and accidently
    // dereferencing an internal pointer.
    //

    LONG      lReferences;                    // ref count on SSP pointers issued
    LONG      lReferenceHandles;              // ref count on application securityContext handles issued

    //
    // Flag to indicate that Context is not attached to List - skip when scanning list
    //

    BOOL      bUnlinked;

    //
    // Digest Parameters for this context
    //

    DIGEST_TYPE typeDigest;

    //
    // QOP selected for this context
    //

    QOP_TYPE typeQOP;

    //
    // Digest Parameters for this context
    //

    ALGORITHM_TYPE typeAlgorithm;

    //
    // Cipher to use for encrypt/decrypt
    //

    CIPHER_TYPE typeCipher;

    //
    // Charset used for digest directive values
    //
    CHARSET_TYPE typeCharset;

    //
    // Token Handle of authenticated user
    //  Only valid when in AuthenticatedState.
    //     Filled in only by AcceptSecurityContext                     - so we are the server
    //     Mapped to UserMode Client space from LSA TokenHandle
    //     It will be NULL is struct is from InitializeSecurityContext - so we are client
    //

    HANDLE ClientTokenHandle;


    //
    // Maintain the context requirements
    //

    ULONG ContextReq;

    //
    //  Maintain a copy of the credential UseFlags (we can tell if inbound or outbound)
    //

    ULONG CredentialUseFlags;

    // Flags
    //     FLAG_CONTEXT_AUTHZID_PROVIDED
    ULONG         ulFlags;


    // Nonce Count
    ULONG         ulNC;

    // Maxbuffer for auth-int and auth-conf processing
    ULONG         ulSendMaxBuf;
    ULONG         ulRecvMaxBuf;

    // SASL sequence numbering
    DWORD  dwSendSeqNum;                        // Makesignature/verifysignature server to client sequence number
    DWORD  dwRecvSeqNum;                        // Makesignature/verifysignature server to client sequence number

    // SASL Sign and Seal Keys.  Save calculated values on sequence number = 0
    BYTE bKcSealHashData[MD5_HASH_BYTESIZE];
    BYTE bKiSignHashData[MD5_HASH_BYTESIZE];
    BYTE bKcUnsealHashData[MD5_HASH_BYTESIZE];
    BYTE bKiVerifyHashData[MD5_HASH_BYTESIZE];

    BYTE bSealKey[MD5_HASH_BYTESIZE];
    BYTE bUnsealKey[MD5_HASH_BYTESIZE];

    HCRYPTKEY hSealCryptKey;   // Handle to Cryptkey based on Byte keys
    HCRYPTKEY hUnsealCryptKey;

    //
    //  Hex(H(A1)) sent from DC and stored in context for future
    //  auth without going to the DC. Binary version is derived from HEX(H(A1))
    //  and is used in SASL mode for integrity protection and encryption
    //

    STRING    strSessionKey;
    BYTE      bSessionKey[MD5_HASH_BYTESIZE];

    // Account name used in token creation for securityContext session
    UNICODE_STRING ustrAccountName;

    //
    //  Values utilized in the Initial Digest Auth ChallResponse
    //
    STRING strParam[MD5_AUTH_LAST];         // points to owned memory - will need to free up!


} DIGEST_USERCONTEXT, * PDIGEST_USERCONTEXT;


#endif // ifndef NTDIGEST_DIGESTSSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\global.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NTDigest security package
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_GLOBAL_H
#define NTDIGEST_GLOBAL_H

//  This parameter is for TESTING only - it must never be set for released builds
// #define ROGUE_DC 1


#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>

#ifdef SECURITY_KERNEL
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#define SECURITY_WDIGEST
#include <security.h>
#include <secint.h>
#include <wdigest.h>

#include "digestsspi.h"
#include "debug.h"         
#include "auth.h"
#include "util.h"

#else  // SECURITY_KERNEL

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32

#define SECURITY_PACKAGE
#define SECURITY_NTLM
#define SECURITY_WDIGEST
#include <security.h>
#include <secint.h>

#include <windns.h>

#include <lm.h>

#include <wdigest.h>

// Local includes for NT Digest Access SSP
#include "debug.h"          /* Support for dsysdbg logging */
#include "ntdigest.h"       /* Prototype functions for package */
#include "digestsspi.h"
#include "func.h"           // Forward declearations of functions
#include "lsaap.h"

#include "ctxt.h"
#include "cred.h"
#include "logsess.h"
#include "nonce.h"
#include "auth.h"
#include "user.h"
#include "util.h"


//  General Macros
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }


//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTDIGEST_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTDIGEST_GLOBAL


typedef enum _NTDIGEST_STATE {
    NtDigestLsaMode = 1,
    NtDigestUserMode
} NTDIGEST_STATE, *PNTDIGEST_STATE;

EXTERN NTDIGEST_STATE g_NtDigestState;

EXTERN ULONG_PTR g_NtDigestPackageId;

// Indicate if running on Domain Controller - used in auth.cxx
EXTERN BOOL g_fDomainController;

EXTERN SECPKG_FUNCTION_TABLE g_NtDigestFunctionTable;

// Package name - used only in Generic Passthrough operations
EXTERN UNICODE_STRING g_ustrNtDigestPackageName;

// Helper routines for use by a Security package handed over by Lsa
// User functions established in userapi.cxx
EXTERN SECPKG_USER_FUNCTION_TABLE g_NtDigestUserFuncTable;
EXTERN PSECPKG_DLL_FUNCTIONS g_UserFunctions;

// Save the PSECPKG_PARAMETERS sent in by SpInitialize
EXTERN PLSA_SECPKG_FUNCTION_TABLE g_LsaFunctions;
EXTERN SECPKG_PARAMETERS g_NtDigestSecPkg;

// Parameters set via Registry

//  Lifetime is the number seconds a NONCE is valid for before marked Stale 
EXTERN DWORD g_dwParameter_Lifetime;

//  Max number os contexts to keep; 0 means no limit 
EXTERN DWORD g_dwParameter_MaxCtxtCount;

// BOOL if local policy permits Negotiation Protocol
EXTERN BOOL g_fParameter_Negotiate;

// BOOL if local policy permits UTF-8 encoding of username and realm for HTTP requests & SASL
EXTERN BOOL g_fParameter_UTF8HTTP;
EXTERN BOOL g_fParameter_UTF8SASL;

// enables various server and client backwards compatibility modes
EXTERN DWORD g_dwParameter_ServerCompat;
EXTERN DWORD g_dwParameter_ClientCompat;

// Value for AcquireCredentialHandle
EXTERN TimeStamp g_TimeForever;

// Amount of time in milliseconds for the garbage collector of expired contexts to sleep
EXTERN DWORD g_dwExpireSleepInterval;

// TokenSource for AuthData to Token Creation
EXTERN TOKEN_SOURCE g_DigestSource;

// TokenSource for AuthData to Token Creation
EXTERN UNICODE_STRING g_ustrWorkstationName;

// Precalculate the UTF8 and ISO versions of the Server's Realm
EXTERN STRING g_strNtDigestUTF8ServerRealm;
EXTERN STRING g_strNTDigestISO8859ServerRealm;

EXTERN PSID g_NtDigestGlobalLocalSystemSid;
EXTERN PSID g_NtDigestGlobalAliasAdminsSid;

// Memory management variables

#endif // SECURITY_KERNEL

extern PSTR MD5_AUTH_NAMES[];

// Code page for latin-1  ISO-8859-1  (for unicode conversion)
#define CP_8859_1  28591

// Utilized for Str to int conversion                  
#define HEXBASE 16
#define TENBASE 10


// Values for UseFlags
#define DIGEST_CRED_INBOUND       SECPKG_CRED_INBOUND
#define DIGEST_CRED_OUTBOUND      SECPKG_CRED_OUTBOUND
#define DIGEST_CRED_MATCH_FLAGS    (DIGEST_CRED_INBOUND | DIGEST_CRED_OUTBOUND)
#define DIGEST_CRED_NULLSESSION  SECPKG_CRED_RESERVED


// Various character definiations
#define CHAR_BACKSLASH '\\'
#define CHAR_DQUOTE    '"'
#define CHAR_EQUAL     '='
#define CHAR_COMMA     ','
#define CHAR_NULL      '\0'
#define CHAR_LPAREN '('
#define CHAR_RPAREN ')'
#define CHAR_LESSTH '<'
#define CHAR_GRTRTH '>'
#define CHAR_AT     '@'
#define CHAR_SEMIC  ';'
#define CHAR_COLON  '('
#define CHAR_FSLASH '/'
#define CHAR_LSQBRK  '['
#define CHAR_RSQBRK  ']'
#define CHAR_QUESTION  '?'
#define CHAR_LCURLY  '{'
#define CHAR_SP      ' '
#define CHAR_TAB     '\t'


// Establish a limit to the sizes of the Auth header values
// From RFC Draft SASL max size if 4096 bytes - seems arbitrary
//   the challenge is limited to 2048 bytes
#define NTDIGEST_SP_MAX_TOKEN_SIZE            4096
#define NTDIGEST_SP_MAX_TOKEN_CHALLENGE_SIZE  2048


#define NTDIGEST_SP_COMMENT_A         "Digest Authentication for Windows"
#define NTDIGEST_SP_COMMENT           L"Digest Authentication for Windows"

#define NTDIGEST_SP_CAPS           (SECPKG_FLAG_TOKEN_ONLY | \
                               SECPKG_FLAG_IMPERSONATION | \
                               SECPKG_FLAG_ACCEPT_WIN32_NAME)
                               // SECPKG_FLAG_LOGON | )                               
                               // SECPKG_FLAG_DELEGATION | \
                               // SECPKG_FLAG_INTEGRITY | \
//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)
#define PBUFFERTYPE(_x_) ((_x_)->BufferType & ~SECBUFFER_ATTRMASK)


#ifdef ROGUE_DC
NTSTATUS DigestInstrumentRoguePac(
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize);
#endif


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NTDIGEST_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\logsess.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        logsess.cxx
//
// Contents:    LogonSession functions:
//
//
// History:     KDamour  15Mar00   Stolen from NTLM
//
//------------------------------------------------------------------------
#include "global.h"

//
// Crit Sect to protect various globals in this module.
//

RTL_CRITICAL_SECTION l_LogSessCritSect;

LIST_ENTRY l_LogSessList;

// Simple variable to make sure that the package was initialize
BOOL g_bLogSessInitialized = FALSE;



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerInit
//
//  Synopsis:   Initializes the LogonSession manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInitialize
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the LogonSession list to be empty.
    //

    Status = RtlInitializeCriticalSection(&l_LogSessCritSect);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "LogSessHandlerInit: Failed to initialize critsec   0x%x\n", Status));
        goto CleanUp;
    }
    
    InitializeListHead( &l_LogSessList );

    // Simple variable test to make sure all initialized;
    g_bLogSessInitialized = TRUE;

CleanUp:

    return Status;
}

NTSTATUS
LogSessHandlerInsert(
    IN PDIGEST_LOGONSESSION  pDigestLogSess
    )
{
    RtlEnterCriticalSection( &l_LogSessCritSect );
    InsertHeadList( &l_LogSessList, &pDigestLogSess->Next );
    RtlLeaveCriticalSection( &l_LogSessCritSect );

    return STATUS_SUCCESS;
}


// Initialize the LogSess Structure
NTSTATUS
LogonSessionInit(
    IN PDIGEST_LOGONSESSION pLogonSession)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pLogonSession)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pLogonSession, sizeof(DIGEST_LOGONSESSION));
    pLogonSession->LogonSessionHandle = (ULONG_PTR)pLogonSession;
    pLogonSession->lReferences = 1;

    return(Status);
}


// Free up memory utilized by LogonSession Structure
NTSTATUS
LogonSessionFree(
    IN PDIGEST_LOGONSESSION pDigestLogSess)
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Free up all Unicode & String structures
    UnicodeStringFree(&(pDigestLogSess->ustrAccountName));
    UnicodeStringFree(&(pDigestLogSess->ustrDomainName));
    if ((pDigestLogSess->ustrPassword).Buffer)
    {
        SecureZeroMemory((pDigestLogSess->ustrPassword).Buffer, (pDigestLogSess->ustrPassword).MaximumLength);
    }
    UnicodeStringFree(&(pDigestLogSess->ustrPassword));
    UnicodeStringFree(&(pDigestLogSess->ustrDnsDomainName));
    UnicodeStringFree(&(pDigestLogSess->ustrUpn));

    DigestFreeMemory(pDigestLogSess);

    return(Status);
}




/*++

Routine Description:

    This routine checks to see if the LogonID is from a currently
    active client, and references the LogSess if it is valid.

    The caller may optionally request that the client's LogSess be
    removed from the list of valid LogonSession - preventing future
    requests from finding this LogSess.

    For a client's LogSess to be valid, the LogSess value
    must be on our list of active LogonSession.


Arguments:

    LogonSessionHandle - Points to the LogonSession Handle of the LogSess
        to be referenced.

    ForceRemove - This boolean value indicates whether the caller
        wants the logon process's LogSess to be removed from the list
        of LogonSession.  TRUE indicates the LogSess is to be removed.
        FALSE indicates the LogSess is not to be removed.
        

Return Value:

    STATUS_INVALID_HANDLE - the LogSess was not found.

    STATUS_SUCCESS - returns a pointer to the referenced LogonSession.
        

--*/
NTSTATUS
LogSessHandlerLogonIdToPtr(
                             IN PLUID pLogonId,
                             IN BOOLEAN ForceRemove,
                             OUT PDIGEST_LOGONSESSION * ppUserLogonSession
                             )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    LONG  lReferences = 0;

    *ppUserLogonSession = NULL ;

    //
    // Acquire exclusive access to the LogonSession list
    //

    RtlEnterCriticalSection( &l_LogSessCritSect );


    //
    // Now walk the list of LogonSession looking for a match.
    //

    for ( ListEntry = l_LogSessList.Flink;
        ListEntry != &l_LogSessList;
        ListEntry = ListEntry->Flink )
    {

        pLogonSession = CONTAINING_RECORD( ListEntry, DIGEST_LOGONSESSION, Next );

        if (RtlEqualLuid(&(pLogonSession->LogonId), pLogonId))
        {
            // Found the LogonSession

            DebugLog((DEB_TRACE, "LogSessHandlerLogonIdToPtr: Found LogSess for LogonID (%x:%lx)\n",
                       pLogonId->HighPart, pLogonId->LowPart ));

            if (!ForceRemove)
            {
                lReferences = InterlockedIncrement(&pLogonSession->lReferences);

                DebugLog((DEB_TRACE, "CredHandlerHandleToPtr: Incremented ReferenceCount %ld\n", lReferences));
            }
            else
            {
                // ForceRemove of True will unlink this LogonSession from the list of active LogonSessions
                // The structure pointet will be returned for the calling function to free up if required
                // Would call LogSessHandlerRelease to dereference the counter (and maybe free up)
                
                DebugLog((DEB_TRACE, "LogSessHandlerLogonIdToPtr: Unlinking 0x%lx    Refcount = %d\n",
                          pLogonSession, pLogonSession->lReferences));

                RemoveEntryList( &pLogonSession->Next );
            }

            // Return a pointer to the LogSess found
            *ppUserLogonSession = pLogonSession ;

            goto CleanUp;
        }
    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "LogSessHandlerLogonIdToPtr: Tried to reference unknown LogonID (%x:%lx)\n",
                pLogonId->HighPart, pLogonId->LowPart ));
    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_LogSessCritSect );

    return(Status);
}



// Locate a LogonSession based on a Principal Name (UserName) ok
NTSTATUS
LogSessHandlerAccNameToPtr(
                             IN PUNICODE_STRING pustrAccountName,
                             OUT PDIGEST_LOGONSESSION *ppUserLogonSession
                             )
{
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    LONG lReferences = 0;


    *ppUserLogonSession = NULL ;

    if ((!pustrAccountName) || (!pustrAccountName->Length))
    {
        DebugLog((DEB_ERROR, "LogSessHandlerAccNameToPtr: No AccountName provided\n"));
        Status = STATUS_INVALID_PARAMETER_1;
        return(Status);
    }

    //
    // Acquire exclusive access to the LogonSession list
    //

    RtlEnterCriticalSection( &l_LogSessCritSect );


    //
    // Now walk the list of LogonSession looking for a match.
    //

    for ( ListEntry = l_LogSessList.Flink;
        ListEntry != &l_LogSessList;
        ListEntry = ListEntry->Flink )
    {

        pLogonSession = CONTAINING_RECORD( ListEntry, DIGEST_LOGONSESSION, Next );


        if ((pLogonSession->ustrAccountName).Length)
        {
            DebugLog((DEB_TRACE, "LogSessHandlerAccNameToPtr: Checking %wZ against AccountName %wZ\n",
                       &(pLogonSession->ustrAccountName), pustrAccountName ));

            if (RtlEqualUnicodeString(&(pLogonSession->ustrAccountName), pustrAccountName, TRUE))
            {
                lReferences = InterlockedIncrement(&pLogonSession->lReferences);

                DebugLog((DEB_TRACE, "LogSessHandlerAccNameToPtr: Incremented ReferenceCount %ld\n", lReferences));
    
                // Found the LogonSession
                *ppUserLogonSession = pLogonSession ;
    
                goto CleanUp;
            }
        }

    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "LogSessHandlerAccNameToPtr: Tried to reference unknown AccountName %wZ\n",
               pustrAccountName ));

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

CleanUp:

    RtlLeaveCriticalSection( &l_LogSessCritSect );

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerRelease
//
//  Synopsis:   Releases the LogonSession by decrementing reference counter
//
//  Arguments:  pLogonSession - pointer to logonsession to de-reference
//
//  Returns: NTSTATUS
//
//  Notes: Called by ACH & AcceptCredentials. Since multiple threads can have a context
//   checked out, simply decrease the reference counter on release. LsaApLogonTerminated
//   is called by LSA to remove the LogonSession from the Active LIst.
//   There can be atmost only 1 reference for a handle (owned by LSA and release by call
//   to this function).  The other references will be pointer references so these can
//   be decremented without it being attached to active logonsession list.
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerRelease(
    PDIGEST_LOGONSESSION pLogonSession)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LONG lReferences = 0;


    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerRelease: Entering for  LogonSession 0x%0x   LogonID (%x:%lx) \n",
              pLogonSession, pLogonSession->LogonId.HighPart, pLogonSession->LogonId.LowPart));

    lReferences = InterlockedDecrement(&pLogonSession->lReferences);

    DebugLog((DEB_TRACE, "LogSessHandlerRelease: Decremented to ReferenceCount %ld\n", lReferences));

    ASSERT( lReferences >= 0 );
    //
    // If the count has dropped to zero, then free all alloced stuff
    //

    if (lReferences == 0)
    {
        DebugLog((DEB_TRACE, "LogSessHandlerRelease: Deleting LogonSession\n"));
        Status = LogonSessionFree(pLogonSession);
    }

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerRelease: Leaving  Status 0x%x\n", Status));

    return(Status);
}



// Helper functions for processing fields within the logonsessions



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerPasswdSet
//
//  Synopsis:   Set the unicode string password in the LogonSession
//
//  Arguments:  pLogonID - pointer to LogonSession LogonID to use
//              pustrPasswd - pointer to new password
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerPasswdSet(
    IN PLUID pLogonId,
    IN PUNICODE_STRING pustrPasswd)
{

    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;


    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdSet: Entering   LogonID (%x:%lx)\n",
              pLogonId->HighPart, pLogonId->LowPart));

    //
    // Acquire exclusive access to the LogonSession list
    //

    RtlEnterCriticalSection( &l_LogSessCritSect );

    //
    // Now walk the list of LogonSession looking for a match.
    //

    for ( ListEntry = l_LogSessList.Flink;
        ListEntry != &l_LogSessList;
        ListEntry = ListEntry->Flink )
    {

        pLogonSession = CONTAINING_RECORD( ListEntry, DIGEST_LOGONSESSION, Next );

        if (RtlEqualLuid(&(pLogonSession->LogonId), pLogonId))
        {
            // Found the LogonSession

            DebugLog((DEB_TRACE, "LogSessHandlerLogonIdToPtr: Found LogSess with  LogonID (%x:%lx)\n",
                       pLogonId->HighPart, pLogonId->LowPart ));

            if (pLogonSession->ustrPassword.Buffer)
            {
                SecureZeroMemory((pLogonSession->ustrPassword).Buffer, (pLogonSession->ustrPassword).MaximumLength);
                UnicodeStringFree(&(pLogonSession->ustrPassword));
            }
            Status = UnicodeStringDuplicatePassword(&(pLogonSession->ustrPassword), pustrPasswd);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "LogSessHandlerPasswdGet: Error in setting LogonSession password, status 0x%0x\n", Status ));
                goto CleanUp;
            }

            DebugLog((DEB_TRACE, "LogSessHandlerPasswdSet: updated password\n"));

            goto CleanUp;
        }
    }

    //
    // No match found
    //
    DebugLog((DEB_WARN, "LogSessHandlerPasswdSet: Unable to locate LogonID (%x:%lx) \n",
               pLogonId->HighPart, pLogonId->LowPart ));

    Status = STATUS_INVALID_HANDLE;

CleanUp:

    RtlLeaveCriticalSection( &l_LogSessCritSect );

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdSet: Exiting   LogonID (%x:%lx)\n",
              pLogonId->HighPart, pLogonId->LowPart));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   LogSessHandlerPasswdGet
//
//  Synopsis:   Get the unicode string password in the logonsession
//
//  Arguments:  pLogonSession - pointer to LogonSession to use
//              pustrPasswd - pointer to destination copy of password
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS
LogSessHandlerPasswdGet(
    IN PDIGEST_LOGONSESSION pLogonSession,
    OUT PUNICODE_STRING pustrPasswd)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdGet: Entering\n" ));

    if (pustrPasswd->Buffer)
    {
        SecureZeroMemory(pustrPasswd->Buffer, pustrPasswd->MaximumLength);
        UnicodeStringFree(pustrPasswd);
    }
            // Protect reading from the LogonSession
    RtlEnterCriticalSection( &l_LogSessCritSect );
    Status = UnicodeStringDuplicatePassword(pustrPasswd, &(pLogonSession->ustrPassword));
    RtlLeaveCriticalSection( &l_LogSessCritSect );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "LogSessHandlerPasswdGet: Error in getting LogonSession password, status 0x%0x\n", Status ));
    }

    DebugLog((DEB_TRACE_FUNC, "LogSessHandlerPasswdGet: Exiting, status 0x%0x\n", Status ));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\lsaap.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        LsaAp.h
//
// Contents:    prototypes for export functions
//
//
// History:     KDamour  15Mar00  Created (based on NTLM)
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_LSAAP_H
#define NTDIGEST_LSAAP_H

#include <samrpc.h>
#include <samisrv.h>


///////////////////////////////////////////////////////////////////////
//                                                                   //
// Authentication package dispatch routine definitions               //
//                                                                   //
///////////////////////////////////////////////////////////////////////

NTSTATUS
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PSTRING Database OPTIONAL,
    IN PSTRING Confidentiality OPTIONAL,
    OUT PSTRING *AuthenticationPackageName
    );

NTSTATUS
LsaApLogonUser(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority
    );

NTSTATUS
LsaApCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaApCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    );

VOID
LsaApLogonTerminated(
    IN PLUID LogonId
    );

NTSTATUS
DigestGetPasswd(
    IN SAMPR_HANDLE UserHandle,
    IN PDIGEST_PARAMETER pDigest,
    IN PUSER_CREDENTIALS pUserCreds
    );

NTSTATUS
DigestOpenSamUser(
    IN PDIGEST_PARAMETER pDigest,
    OUT SAMPR_HANDLE   *ppUserHandle,
    OUT PUCHAR * ppucUserAuthData,
    OUT PULONG pulAuthDataSize
    );

NTSTATUS
DigestCloseSamUser(
    IN SAMPR_HANDLE  UserHandle);

NTSTATUS
DigestUpdateLogonStatistics(
    IN SAM_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats);

NTSTATUS
DigestOpenSam(void);

NTSTATUS
DigestCloseSam(void);

BOOL 
DigestCompareDomainNames( 
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING AmbiguousName,
    IN PUNICODE_STRING FlatName OPTIONAL
    );

NTSTATUS
DigestCheckPacForSidFiltering(
    IN PDIGEST_PARAMETER pDigest,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize
    );

PVOID
MIDL_user_allocate(
    IN size_t BufferSize
    );

VOID
MIDL_user_free(
    IN PVOID Buffer
    );

#endif // NTDIGEST_LSAAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\logsess.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        logsess.h
//
// Contents:    declarations, constants for logonsession manager
//
//
// History:     KDamour  13May 00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_LOGSESS_H
#define NTDIGEST_LOGSESS_H      

//  Initializes the LogonSession manager package
NTSTATUS LogSessHandlerInit(VOID);

NTSTATUS LogSessHandlerInsert(IN PDIGEST_LOGONSESSION  pDigestLogSess);

// Initialize the LogSess Structure
NTSTATUS LogonSessionInit(IN PDIGEST_LOGONSESSION pLogonSession);

// Free up memory utilized by LogonSession Structure
NTSTATUS LogonSessionFree(IN PDIGEST_LOGONSESSION pDigestLogSess);

// Locate a LogonSession based on a LogonId
NTSTATUS LogSessHandlerLogonIdToPtr(
                             IN PLUID pLogonId,
                             IN BOOLEAN ForceRemove,
                             OUT PDIGEST_LOGONSESSION * pUserLogonSession);

// Locate a LogonSession based on a Principal Name (UserName)
NTSTATUS LogSessHandlerAccNameToPtr(
                             IN PUNICODE_STRING pustrAccountName,
                             OUT PDIGEST_LOGONSESSION * pUserLogonSession);

NTSTATUS LogSessHandlerRelease(PDIGEST_LOGONSESSION pLogonSession);

// Set the unicode string password in the LogonSession
NTSTATUS LogSessHandlerPasswdSet(
                                IN PLUID pLogonId,
                                IN PUNICODE_STRING pustrPasswd);

// Get the unicode string password in the logonsession
NTSTATUS LogSessHandlerPasswdGet(
                             IN PDIGEST_LOGONSESSION pLogonSession,
                             OUT PUNICODE_STRING pustrPasswd);

#endif // NTDIGEST_LOGSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\lsaap.cxx ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       lsaap.cxx
//
// Contents:   Authentication package dispatch routines
//               LsaApInitializePackage (Not needed done in SpInitialize)
//               LsaApLogonUser2
//               LsaApCallPackage
//               LsaApCallPackagePassthrough
//               LsaApLogonTerminated
//
//             Helper functions:
//  This file also has all routines that access the SAM through SamR* and SamI* routines
//
// History:    KDamour  10Mar00   Based on msv_sspi\msv1_0.c
//
//---------------------------------------------------------------------



#include "global.h"

extern "C"
{
#include <align.h>         // ROUND_UP_COUNT
#include <lsarpc.h>
#include <samrpc.h>
#include <logonmsv.h>
#include <lsaisrv.h>
}

#include <pac.hxx>     // MUST be outside of the Extern C since libs are exported as C++


// Local prototypes
NTSTATUS
DigestFilterSids(
    IN PDIGEST_PARAMETER pDigest,
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo
    );

#define SAM_CLEARTEXT_CREDENTIAL_NAME L"CLEARTEXT"
#define SAM_WDIGEST_CREDENTIAL_NAME   WDIGEST_SP_NAME     // Name of the Supplemental (primary) cred blob for MD5 hashes

const ULONG USER_ALL_DIGEST_INFO =
         USER_ALL_USERNAME |
         USER_ALL_BADPASSWORDCOUNT |
         USER_ALL_LOGONCOUNT |
         USER_ALL_PASSWORDMUSTCHANGE |
         USER_ALL_PASSWORDCANCHANGE |
         USER_ALL_WORKSTATIONS |
         USER_ALL_LOGONHOURS |
         USER_ALL_ACCOUNTEXPIRES |
         USER_ALL_PRIMARYGROUPID |
         USER_ALL_USERID |
         USER_ALL_USERACCOUNTCONTROL;

// Local variables for access to SAM - used only on domain controller
SAMPR_HANDLE l_AccountSamHandle = NULL;
SAMPR_HANDLE l_AccountDomainHandle = NULL;

   
/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage().

--*/
NTSTATUS
LsaApCallPackage (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

{
    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(ProtocolSubmitBuffer);
    UNREFERENCED_PARAMETER(ClientBufferBase);
    UNREFERENCED_PARAMETER(SubmitBufferLength);
    UNREFERENCED_PARAMETER(ProtocolReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferLength);
    UNREFERENCED_PARAMETER(ProtocolStatus);
    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackage: Entering/Leaving \n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for untrusted clients.


--*/
NTSTATUS
LsaApCallPackageUntrusted (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )

{
    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(ProtocolSubmitBuffer);
    UNREFERENCED_PARAMETER(ClientBufferBase);
    UNREFERENCED_PARAMETER(SubmitBufferLength);
    UNREFERENCED_PARAMETER(ProtocolReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferLength);
    UNREFERENCED_PARAMETER(ProtocolStatus);
    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackageUntrusted: Entering/Leaving \n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



/*++

Routine Description:

    This routine is the dispatch routine for
    LsaCallAuthenticationPackage() for passthrough logon requests.
    When the passthrough is called (from AcceptSecurityCOntext)
    a databuffer is sent to the DC and this function is called.

Arguments:

    ClientRequest - Is a pointer to an opaque data structure
        representing the client's request.

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    ClientBufferBase - Provides the address within the client
        process at which the protocol message was resident.
        This may be necessary to fix-up any pointers within the
        protocol message buffer.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Is used to return the address of the
        protocol buffer in the client process.  The authentication
        package is responsible for allocating and returning the
        protocol buffer within the client process.  This buffer is
        expected to have been allocated with the
        AllocateClientBuffer() service.

        The format and semantics of this buffer are specific to the
        authentication package.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned protocol buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the return
        buffer could not could not be allocated because the client
        does not have sufficient quota.




--*/
NTSTATUS
LsaApCallPackagePassthrough (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusProtocol = STATUS_SUCCESS;
    ULONG MessageType = 0;
    ULONG ulReturnBuffer = 0;
    BYTE *pReturnBuffer = NULL;

    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(ClientBufferBase);

    ASSERT(ProtocolSubmitBuffer);
    ASSERT(ProtocolReturnBuffer);
    ASSERT(ReturnBufferLength);
    ASSERT(ProtocolStatus);

    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackagePassthrough: Entering \n"));

    
    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(DIGEST_BLOB_REQUEST) ) {
        DebugLog((DEB_ERROR, "LsaApCallPackagePassthrough: FAILED message size to contain Digest Request\n"));
        return STATUS_INVALID_PARAMETER;
    }

    memcpy((char *)&MessageType, (char *)ProtocolSubmitBuffer, sizeof(MessageType));

    if ( MessageType != VERIFY_DIGEST_MESSAGE)
    {
        DebugLog((DEB_ERROR, "FAILED to have correct message type\n"));
        return STATUS_ACCESS_DENIED;
    }

    //
    // Allow the DigestCalc routine to only set the return buffer information
    // on success conditions.
    //

    DebugLog((DEB_TRACE, "LsaApCallPackagePassthrough: setting return buffers to NULL\n"));
    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

       // We will need to free any memory allocated in the Returnbuffer
    StatusProtocol = DigestPackagePassthrough((USHORT)SubmitBufferLength, (BYTE *)ProtocolSubmitBuffer,
                         &ulReturnBuffer, &pReturnBuffer);
    if (!NT_SUCCESS(StatusProtocol))
    {
        DebugLog((DEB_ERROR,"LsaApCallPackagePassthrough: DigestPackagePassthrough failed  0x%x\n", StatusProtocol));
        ulReturnBuffer = 0;
        goto CleanUp;
    }

    // DebugLog((DEB_TRACE, "LsaApCallPackagePassthrough: setting return auth status to STATUS_SUCCEED\n"));
    // DebugLog((DEB_TRACE, "LsaApCallPackagePassthrough: Total Return Buffer size %ld bytes\n", ulReturnBuffer));

    // Now place the data back to the client (the server calling this)
    ASSERT(ulReturnBuffer);                // we should always have data on successful logon to send back
    if (ulReturnBuffer)
    {
        Status = g_LsaFunctions->AllocateClientBuffer(
                    NULL,
                    ulReturnBuffer,
                    ProtocolReturnBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            goto CleanUp;
        }
        Status = g_LsaFunctions->CopyToClientBuffer(
                    NULL,
                    ulReturnBuffer,
                    *ProtocolReturnBuffer,
                    pReturnBuffer
                    );
        if (!NT_SUCCESS(Status))
        {     // Failed to copy over the data to the client
            g_LsaFunctions->FreeClientBuffer(
                NULL,
                *ProtocolReturnBuffer
                );
            *ProtocolReturnBuffer = NULL;
        }
        else
        {
            *ReturnBufferLength = ulReturnBuffer;
        }
    }
    else
    {
        DebugLog((DEB_ERROR, "LsaApCallPackagePassthrough: Zero length return buffer\n"));
        Status = STATUS_INTERNAL_ERROR;
    }

CleanUp:

    *ProtocolStatus = StatusProtocol;

    if (pReturnBuffer)
    {
       DigestFreeMemory(pReturnBuffer);
       pReturnBuffer = NULL;
       ulReturnBuffer = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "LsaApCallPackagePassthrough: Leaving  Status 0x%x\n", Status));
    return(Status);
}


/*++

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    the user's initial logon.  A new LSA logon session will be established
    for the user and validation information for the user will be returned.
    
    Unused function in Digest
    
--*/
NTSTATUS
LsaApLogonUserEx2 (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * SupplementalCredentials
    )
{
    UNREFERENCED_PARAMETER(ClientRequest);
    UNREFERENCED_PARAMETER(LogonType);
    UNREFERENCED_PARAMETER(ProtocolSubmitBuffer);
    UNREFERENCED_PARAMETER(ClientBufferBase);
    UNREFERENCED_PARAMETER(SubmitBufferSize);
    UNREFERENCED_PARAMETER(ProfileBuffer);
    UNREFERENCED_PARAMETER(ProfileBufferSize);
    UNREFERENCED_PARAMETER(LogonId);
    UNREFERENCED_PARAMETER(SubStatus);
    UNREFERENCED_PARAMETER(TokenInformationType);
    UNREFERENCED_PARAMETER(TokenInformation);
    UNREFERENCED_PARAMETER(AccountName);
    UNREFERENCED_PARAMETER(AuthenticatingAuthority);
    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(PrimaryCredentials);
    UNREFERENCED_PARAMETER(SupplementalCredentials);

    DebugLog((DEB_TRACE_FUNC, "LsaApLogonUserEx2: Entering/Leaving \n"));
    return (SEC_E_UNSUPPORTED_FUNCTION);
}


/*++

Routine Description:

    This routine is used to notify each authentication package when a logon
    session terminates.  A logon session terminates when the last token
    referencing the logon session is deleted.

Arguments:

    LogonId - Is the logon ID that just logged off.

Return Status:

    None.
--*/
VOID
LsaApLogonTerminated (
    IN PLUID pLogonId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_LOGONSESSION pLogonSession = NULL;
    LONG lReferences = 0;

    DebugLog((DEB_TRACE_FUNC, "LsaApLogonTerminated: Entering LogonID (%x:%lx) \n",
              pLogonId->HighPart, pLogonId->LowPart));

    //
    // Find the entry, dereference, and de-link it from the active logon table.
    //

    Status = LogSessHandlerLogonIdToPtr(pLogonId, TRUE, &pLogonSession);
    if (!NT_SUCCESS(Status))
    {
        goto CleanUp;    // No LongonID found in Active list - simply exit quietly
    }

    DebugLog((DEB_TRACE, "LsaApLogonTerminated: Found LogonID (%x:%lx) \n",
              pLogonId->HighPart, pLogonId->LowPart));


    // This relies on the LSA terminating all of the credentials before killing off
    // the LogonSession.

    lReferences = InterlockedDecrement(&pLogonSession->lReferences);

    DebugLog((DEB_TRACE, "LsaApLogonTerminated: Refcount %ld \n", lReferences));

    ASSERT( lReferences >= 0 );

    if (lReferences)
    {
        DebugLog((DEB_WARN, "LsaApLogonTerminated: WARNING Terminate LogonID (%x:%lx) non-zero RefCount!\n",
                  pLogonId->HighPart, pLogonId->LowPart));
    }
    else
    {
        DebugLog((DEB_TRACE, "LsaApLogonTerminated: Removed LogonID (%x:%lx) from Active List! \n",
                  pLogonId->HighPart, pLogonId->LowPart));

        LogonSessionFree(pLogonSession);
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "LsaApLogonTerminated: Exiting LogonID (%x:%lx) \n",
              pLogonId->HighPart, pLogonId->LowPart));

    return;
}


// Routine to acquire the plaintext password for a given user
// If supplemental credentials exist that contain the Digest Hash values
//    then return them also.
// This routine runs on the domain controller
// Must provide STRING strPasswd

NTSTATUS
DigestGetPasswd(
    SAMPR_HANDLE UserHandle,
    IN PDIGEST_PARAMETER pDigest,
    IN OUT PUSER_CREDENTIALS pUserCreds
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ustrcPackageName = {0};

    UNICODE_STRING ustrcTemp = {0};
    STRING strcTemp = {0};
    PVOID pvPlainPwd = NULL;
    PVOID pvHashCred = NULL;
    ULONG ulLenPassword = 0;
    ULONG ulLenHash = 0;

    DebugLog((DEB_TRACE_FUNC,"DigestGetPasswd: Entering\n"));

    pUserCreds->fIsValidDigestHash = FALSE;
    pUserCreds->fIsValidPasswd = FALSE;

    ASSERT(pDigest);
    ASSERT(pUserCreds);

    if (!g_fDomainController)
    {
        DebugLog((DEB_ERROR,"DigestGetPasswd: Not on a domaincontroller - can not get credentials\n"));
        Status =  STATUS_INVALID_SERVER_STATE;
        goto CleanUp;
    }

    //
    // Retrieve the MD5 hashed pre-calculated values if they exist for this user
    //
    // NOTE : On NT 5, this API only works on Domain Controllers !!
    //
    RtlInitUnicodeString(&ustrcPackageName, SAM_WDIGEST_CREDENTIAL_NAME);

    Status = SamIRetrievePrimaryCredentials( UserHandle,
                                             &ustrcPackageName,
                                             &pvHashCred,
                                             &ulLenHash);

    if (!NT_SUCCESS( Status ))
    {
        pvHashCred = NULL;
        DebugLog((DEB_TRACE,"DigestGetPasswd: NO Pre-calc Hashes were found for user\n"));
    }
    else
    {
        if ((ulLenHash >= MD5_HASH_BYTESIZE) && (ulLenHash < MAXUSHORT))    // must have a valid header size header
        {
            strcTemp.Buffer = (PCHAR) pvHashCred;
            strcTemp.Length = strcTemp.MaximumLength = (USHORT) ulLenHash;

            Status = StringDuplicate(&(pUserCreds->strDigestHash), &strcTemp);
            if (!NT_SUCCESS( Status ))
            {
                DebugLog((DEB_ERROR, "DigestGetPasswd: Failed to copy precalc hashes, error 0x%x\n", Status));
                goto CleanUp;
            }


            /* RC1 supp creds does not have SUPPCREDS_CNTLOC so use the supp cred length for now
            // Extract the number of pre-calculated digest hashes - just an extra check on supp cred size
            pUserCreds->usDigestHashCnt = (USHORT) *(strcTemp.Buffer + SUPPCREDS_CNTLOC);
            DebugLog((DEB_TRACE,"DigestGetPasswd: Read in %d Pre-calc Hashes  size = %lu\n",
                      pUserCreds->usDigestHashCnt, ulLenHash));

            if (ulLenHash != ((ULONG)(pUserCreds->usDigestHashCnt + 1) * MD5_HASH_BYTESIZE))
            {
                Status = SEC_E_NO_CREDENTIALS;
                DebugLog((DEB_ERROR, "DigestGetPasswd: Mismatch count with hash size  count %d, error 0x%x\n",
                          pUserCreds->usDigestHashCnt,  Status));
                goto CleanUp;
            }
            */

            pUserCreds->usDigestHashCnt = (USHORT) (ulLenHash / MD5_HASH_BYTESIZE) - 1; 
            DebugLog((DEB_TRACE,"DigestGetPasswd: Read in %d Pre-calc Hashes  size = %lu\n",
                      pUserCreds->usDigestHashCnt, ulLenHash));

            // setup the hashes to utilize  - get format from the notify.cxx hash calcs
            switch (pDigest->typeName)
            {
            case NAMEFORMAT_ACCOUNTNAME:
                pUserCreds->sHashTags[NAME_ACCT] = 1;
                pUserCreds->sHashTags[NAME_ACCT_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_UPCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_DUCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_UDCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_NUCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_NDCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCTDNS] = 1;
                pUserCreds->sHashTags[NAME_ACCTDNS_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCTDNS_UPCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCTDNS_DUCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCTDNS_UDCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCTDNS_NUCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCTDNS_NDCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_FREALM] = 1;
                pUserCreds->sHashTags[NAME_ACCT_FREALM_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_ACCT_FREALM_UPCASE] = 1;
                break;
            case NAMEFORMAT_UPN:
                pUserCreds->sHashTags[NAME_UPN] = 1;
                pUserCreds->sHashTags[NAME_UPN_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_UPN_UPCASE] = 1;
                pUserCreds->sHashTags[NAME_UPN_FREALM] = 1;
                pUserCreds->sHashTags[NAME_UPN_FREALM_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_UPN_FREALM_UPCASE] = 1;
                break;
            case NAMEFORMAT_NETBIOS:
                pUserCreds->sHashTags[NAME_NT4] = 1;
                pUserCreds->sHashTags[NAME_NT4_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_NT4_UPCASE] = 1;
                pUserCreds->sHashTags[NAME_NT4_FREALM] = 1;
                pUserCreds->sHashTags[NAME_NT4_FREALM_DOWNCASE] = 1;
                pUserCreds->sHashTags[NAME_NT4_FREALM_UPCASE] = 1;
                break;
            default:
                break;
            }

            pUserCreds->fIsValidDigestHash = TRUE;
        }
        else
        {
            DebugLog((DEB_ERROR,"DigestGetPasswd: Invalid header on pre-calc hashes\n"));
        }

    }
    
    //
    // Retrieve the plaintext password
    //
    // NOTE : On NT 5, this API only works on Domain Controllers !!
    //
    RtlInitUnicodeString(&ustrcPackageName, SAM_CLEARTEXT_CREDENTIAL_NAME);

    // Note:  Would be nice to have this as a LSAFunction
    Status = SamIRetrievePrimaryCredentials( UserHandle,
                                             &ustrcPackageName,
                                             &pvPlainPwd,
                                             &ulLenPassword);

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_WARN, "DigestGetPasswd: Could not retrieve plaintext password, status 0x%x\n", Status));

        if (pUserCreds->fIsValidDigestHash == FALSE)
        {
            // We have no pre-computed MD5 hashes and also no cleartext password
            // we can not perform any Digest Auth operations
            //
            // Explicitly set the status to be "wrong password" instead of whatever
            // is returned by SamIRetrievePrimaryCredentials
            //
            Status = STATUS_WRONG_PASSWORD;
            DebugLog((DEB_ERROR,"DigestGetPasswd: Can not obtain cleartext or Hashed Creds\n"));
            goto CleanUp;
        }
        Status = STATUS_SUCCESS;               // we have valid pre-calc hash so continue with no error

    }
    else
    {
        ustrcTemp.Buffer = (PUSHORT) pvPlainPwd;
        ustrcTemp.Length = ustrcTemp.MaximumLength = (USHORT) ulLenPassword;

        Status = UnicodeStringDuplicate(&(pUserCreds->ustrPasswd), &ustrcTemp);
        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "DigestGetPasswd: Failed to copy plaintext password, error 0x%x\n", Status));
            goto CleanUp;
        }

        // DebugLog((DEB_TRACE,"DigestGetPasswd: Have the PASSWORD %wZ\n", &(pUserCreds->ustrPasswd)));

        pUserCreds->fIsValidPasswd = TRUE;

        DebugLog((DEB_TRACE,"DigestGetPasswd: Password retrieved\n"));
    }

CleanUp:

    // Release any memory from SamI* calls         Would be nice to have this as a LSAFunction
    
    if (pvPlainPwd)
    {
        if (ulLenPassword > 0)
        {
            SecureZeroMemory(pvPlainPwd, ulLenPassword);
        }
        LocalFree(pvPlainPwd);
        pvPlainPwd = NULL;
    }

    if (pvHashCred)
    {
        if (ulLenHash > 0)
        {
            SecureZeroMemory(pvHashCred, ulLenHash);
        }
        LocalFree(pvHashCred);
        pvHashCred = NULL;
    }

    DebugLog((DEB_TRACE_FUNC,"DigestGetPasswd: Leaving   0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestOpenSamUser
//
//  Synopsis:   Opens the Sam User database for an account
//
//  Arguments:  pusrtUserName   - Unicode string for the AccountName (UPN or SAMAccountName)
//              pUserHandle     - output handle to the opened User account
//
//  Returns: NTSTATUS
//
//  Notes: this call will attempt to locally open an account specified by UPN or SAMAccountName.  If it is 
//     a UPN, SAM will attemp to crackName locally.  If this fails, an error will be returned.
//
//---------------------------------------------------------------------
NTSTATUS
DigestOpenSamUser(
    IN PDIGEST_PARAMETER pDigest,
    OUT SAMPR_HANDLE  *ppUserHandle,
    OUT PUCHAR * ppucUserAuthData,
    OUT PULONG pulAuthDataSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusSub = STATUS_SUCCESS;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL ;
    PSAMPR_USER_ALL_INFORMATION UserAll = NULL ;
    SID_AND_ATTRIBUTES_LIST GroupMembership = {0};

    LARGE_INTEGER CurrentTime = {0};
    LARGE_INTEGER LogoffTime = {0};
    LARGE_INTEGER KickoffTime = {0};
    PLARGE_INTEGER pTempTime = NULL;

    PPACTYPE Pac = NULL;

    ASSERT(ppUserHandle);
    ASSERT(ppucUserAuthData);
    ASSERT(pulAuthDataSize);

    DebugLog((DEB_TRACE_FUNC, "DigestOpenSamUser: Entering\n"));

    *ppucUserAuthData = NULL;
    *pulAuthDataSize = 0L;
    *ppUserHandle = NULL;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime );

    Status = DigestOpenSam();

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestOpenSamUser: DigestOpenSam failed   0x%x\n", Status));
        goto CleanUp;
    }

    // Figure out which name format is used in account
    //  If it was NetBIOS, then this was cracked locally on the server

    if (pDigest->ustrCrackedAccountName.Length)
    {
        ASSERT(pDigest->typeName != NAMEFORMAT_UNKNOWN);    // Should ALWAYS know format if cracked

        Status = SamIGetUserLogonInformationEx(l_AccountDomainHandle,
                                             0,                 // Defaults to SamAccount Name
                                             &(pDigest->ustrCrackedAccountName),
                                             USER_ALL_DIGEST_INFO,
                                             &UserAllInfo,
                                             &GroupMembership,
                                             ppUserHandle);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestOpenSamUser: GetUserLogonInformation Cracked AccountName failed   0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
    {
        //  Username format could be SamAccount name or UPN
        //     UPN could be a local UPN or need to CrackName and then make genericpassthrough to another DC

        // Try opening up just the SamAccount name first
        Status = SamIGetUserLogonInformationEx(l_AccountDomainHandle,
                                             0,
                                             &(pDigest->ustrUsername),
                                             USER_ALL_DIGEST_INFO,
                                             &UserAllInfo,
                                             &GroupMembership,
                                             ppUserHandle);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_TRACE, "DigestOpenSamUser: GetUserLogonInformation for SamAccount  failed   0x%x\n", Status));
            Status = SamIGetUserLogonInformationEx(l_AccountDomainHandle,
                                                 SAM_OPEN_BY_UPN_OR_ACCOUNTNAME,
                                                 &(pDigest->ustrUsername),
                                                 USER_ALL_DIGEST_INFO,
                                                 &UserAllInfo,
                                                 &GroupMembership,
                                                 ppUserHandle);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestOpenSamUser: GetUserLogonInformation failed   0x%x\n", Status));
                goto CleanUp;
            }

            // Succeeded in finding account by UPN (SamAccount would have matched before)
            pDigest->typeName = NAMEFORMAT_UPN;
        }
        else
        {
            // We suceeded opening up account by SamAccount name
            pDigest->typeName = NAMEFORMAT_ACCOUNTNAME;
        }
    }


    UserAll = &UserAllInfo->All ;

    // Fill in the account name & domain
    UnicodeStringFree(&(pDigest->ustrCrackedAccountName));
    UnicodeStringFree(&(pDigest->ustrCrackedDomain));
    Status = UnicodeStringWCharDuplicate(&(pDigest->ustrCrackedAccountName),
                                         UserAll->UserName.Buffer,
                                         UserAll->UserName.Length / sizeof(WCHAR));
    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog((DEB_ERROR, "DigestOpenSamUser: Account copy failed     0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(&(pDigest->ustrCrackedDomain), &g_NtDigestSecPkg.DomainName);
    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog((DEB_ERROR, "DigestOpenSamUser: Domain copy failed     0x%x\n", Status));
        goto CleanUp;
    }

    pDigest->usFlags =  pDigest->usFlags & (~FLAG_CRACKNAME_ON_DC);   // reset - name is now cracked
    
    DebugLog((DEB_TRACE,"DigestOpenSamUser: BadPasswordCount %u    Logon Count  %u\n",
               UserAll->BadPasswordCount, UserAll->LogonCount));

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED )
    {
        Status = STATUS_ACCOUNT_DISABLED;
        goto CleanUp;
    }

    if ( UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED )
    {
        Status = STATUS_ACCOUNT_LOCKED_OUT;
        goto CleanUp ;
    }

    if ( UserAll->UserAccountControl & USER_SMARTCARD_REQUIRED )
    {
        Status = STATUS_SMARTCARD_LOGON_REQUIRED;
        goto CleanUp ;
    }

    //
    // Check the restrictions SAM doesn't:
    //

    pTempTime = (PLARGE_INTEGER) &UserAll->AccountExpires;
    if ((pTempTime->QuadPart != 0) &&
        (pTempTime->QuadPart < CurrentTime.QuadPart))
    {
        Status = STATUS_ACCOUNT_EXPIRED;
        goto CleanUp;
    }

    //
    // For user accounts, check if the password has expired.
    //

    if (UserAll->UserAccountControl & USER_NORMAL_ACCOUNT)
    {
        pTempTime = (PLARGE_INTEGER) &UserAll->PasswordMustChange;

        if (pTempTime->QuadPart < CurrentTime.QuadPart)
        {
            if (pTempTime->QuadPart == 0)
            {
                Status = STATUS_PASSWORD_MUST_CHANGE;
            }
            else
            {
                Status = STATUS_PASSWORD_EXPIRED;
            }
            DebugLog((DEB_ERROR, "DigestOpenSamUser: Failed PasswordMustChange     0x%x\n", Status));
            goto CleanUp;
        }
    }

    // One final check on status of password - this should be duplicate test from previous one
    if ( UserAll->UserAccountControl & USER_PASSWORD_EXPIRED )
    {
        Status = STATUS_PASSWORD_EXPIRED;
        goto CleanUp ;
    }
    
    Status = SamIAccountRestrictions(
                *ppUserHandle,
                &pDigest->ustrWorkstation,
                (PUNICODE_STRING) &UserAll->WorkStations,
                (PLOGON_HOURS) &UserAll->LogonHours,
                &LogoffTime,
                &KickoffTime
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestOpenSamUser: Failed TOD AccountRestrictions     0x%x\n", Status));
        goto CleanUp;
    }

    // Now create the PAC for this user
    Status = PAC_Init( UserAll,
                       NULL,
                       &GroupMembership,
                       g_NtDigestSecPkg.DomainSid,
                       &(g_NtDigestSecPkg.DnsDomainName),
                       &g_ustrWorkstationName,
                       0,               // no signature
                       0,               // no additional data
                       NULL,            // no additional data
                       &Pac );


    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog((DEB_ERROR, "DigestOpenSamUser: Failed to Init PAC     0x%x\n", Status));
        goto CleanUp;
    }

    *pulAuthDataSize = PAC_GetSize( Pac );

    *ppucUserAuthData = (PUCHAR)MIDL_user_allocate( *pulAuthDataSize );

    if ( *ppucUserAuthData )
    {
       PAC_Marshal( Pac, *pulAuthDataSize, *ppucUserAuthData );
    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

    MIDL_user_free( Pac );


CleanUp:

    if ( UserAllInfo )
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if (GroupMembership.SidAndAttributes != NULL)
    {
        SamIFreeSidAndAttributesList(&GroupMembership);
    }


    if (!NT_SUCCESS(Status))
    {     // Cleanup functions since there was a failure
        if (*ppucUserAuthData)
        {
            MIDL_user_free(*ppucUserAuthData);
            *ppucUserAuthData = NULL;
            *pulAuthDataSize = 0L;
        }

        if (*ppUserHandle)
        {
         StatusSub = DigestCloseSamUser(*ppUserHandle);
         if (!NT_SUCCESS(StatusSub))
         {
             DebugLog((DEB_ERROR,"DigestOpenSamUser: failed DigestCloseSamUser on error 0x%x\n", StatusSub));
         }
         *ppUserHandle = NULL;
        }
    }

    DebugLog((DEB_TRACE_FUNC, "DigestOpenSamUser: Leaving 0x%x\n", Status));
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestCloseSamUser
//
//  Synopsis:   Closes the Sam User database for an account
//
//  Arguments:  pUserHandle     - output handle to the opened User account
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS
DigestCloseSamUser(
    IN SAMPR_HANDLE  UserHandle)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "DigestCloseSamUser: Entering\n"));

        // used to use LsaCloseSamUser()
    Status = SamrCloseHandle( &UserHandle );

    DebugLog((DEB_TRACE_FUNC, "DigestCloseSamUser: Leaving 0x%x\n", Status));
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestUpdateLogonStatistics
//
//  Synopsis:   Update the logon stats for a user (bad passwd attempts ....)
//
//  Arguments:  pUserHandle     - output handle to the opened User account
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS
DigestUpdateLogonStatistics(
    IN SAM_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS pLogonStats)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "DigestUpdateLogonStatistics: Entering\n"));

    Status = SamIUpdateLogonStatistics(
                                  UserHandle,
                                  pLogonStats );


    DebugLog((DEB_TRACE_FUNC, "DigestUpdateLogonStatistics: Leaving 0x%x\n", Status));
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestOpenSam
//
//  Synopsis:   Opens the Sam  - done only on a domain controller
//
//  Arguments:
//
//  Returns: NTSTATUS
//
//  Notes:  Can be called in multithreaded mode - no need to acquire at startup
//
//---------------------------------------------------------------------
NTSTATUS
DigestOpenSam()
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_HANDLE SamHandle = NULL;
    SAMPR_HANDLE DomainHandle = NULL;

    // if already have valid handle to SAM
    if (l_AccountDomainHandle)
        return STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "DigestOpenSam: Entering\n"));

    //
    // Open SAM to get the account information
    //

    Status = SamIConnect(
                NULL,                   // no server name
                &SamHandle,
                0,                      // no desired access
                TRUE                    // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestOpenSam: SamIConnect failed   0x%x\n", Status));
        goto CleanUp;
    }

    if(InterlockedCompareExchangePointer(
                    &l_AccountSamHandle,
                    SamHandle,
                    NULL
                    ) != NULL)
    {
        SamrCloseHandle( &SamHandle );
    }


    Status = SamrOpenDomain(
                    l_AccountSamHandle,
                    0,                  // no desired access
                    (PRPC_SID) g_NtDigestSecPkg.DomainSid,
                    &DomainHandle
                    );
    if (!NT_SUCCESS(Status))
    {
        goto CleanUp;
    }

    if(InterlockedCompareExchangePointer(
                    &l_AccountDomainHandle,
                    DomainHandle,
                    NULL
                    ) != NULL)
    {
        SamrCloseHandle( &DomainHandle );
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestOpenSam: Leaving 0x%x\n", Status));
    
    return Status;
}



//+--------------------------------------------------------------------
//
//  Function:   DigestCloseSam
//
//  Synopsis:   Closes the Sam
//
//  Arguments: 
//
//  Returns: NTSTATUS
//
//  Notes: 
//
//---------------------------------------------------------------------
NTSTATUS
DigestCloseSam()
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (l_AccountDomainHandle)
    {
        SamrCloseHandle( &l_AccountDomainHandle );
        l_AccountDomainHandle = NULL;
    }


    if (l_AccountSamHandle)
    {
        SamrCloseHandle( &l_AccountSamHandle );
        l_AccountSamHandle = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "DigestCloseSamUser: Leaving\n"));
    
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   Allocation routine for use by RPC client stubs
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  BufferSize - size of buffer, in bytes, to allocate
//
//  Requires:
//
//  Returns:    Buffer pointer or NULL on allocation failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
MIDL_user_allocate(
    IN size_t BufferSize
    )
{
    return (DigestAllocateMemory( ROUND_UP_COUNT((ULONG) BufferSize, 8) ) );
}


//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   Memory free routine for RPC client stubs
//
//  Effects:    frees the buffer with LsaFunctions.FreeLsaHeap
//
//  Arguments:  Buffer - Buffer to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
MIDL_user_free(
    IN PVOID Buffer
    )
{
    DigestFreeMemory( Buffer );
}



// The following two routines were copied from the LSA server policy utilities dbluutil.c
// LSANullTerminateUnicodeString and LsapCompareDomainNames
NTSTATUS
DigestNullTerminateUnicodeString( 
    IN  PUNICODE_STRING String,
    OUT LPWSTR *pBuffer,
    OUT BOOLEAN *fFreeBuffer
    )
/*++

Routine Description:

    This routine accepts a UNICODE_STRING and returns its internal buffer,
    ensuring that it is NULL terminated.
    
    If the buffer is NULL terminated it will be returned in pBuffer.                                                        
                                                        
    If the buffer isn't NULL terminated it will be reallocated, NULL terminated,
    and returned in pBuffer.  fFreeBuffer will be set to TRUE indicating the
    caller is responsible for deallocating pBuffer.
    
    If an error occurs then pBuffer will be NULL, fFreeBuffer will be FALSE, and
    no memory will be allocated.   
    
Arguments:

    String - Pointer to a UNICODE_STRING      
    
    pBuffer - Pointer to a pointer to return the buffer 
    
    fFreeBuffer - Pointer to a BOOLEAN to indicate whether the caller needs to
                  deallocate pBuffer or not.
                                                         
Return Values:

    STATUS_SUCCESS   - *pBuffer points to a NULL terminated version of String's
                       internal buffer.  Check *fFreeBuffer to determine if
                       pBuffer must be freed by the caller.
    
    STATUS_NO_MEMORY - The routine failed to NULL terminate String's internal
                       buffer.  *pBuffer is NULL and *fFreeBuffer is FALSE.
       
--*/

{
    BOOLEAN fNullTerminated;
    NTSTATUS Status = STATUS_SUCCESS;
    
    ASSERT(pBuffer);
    ASSERT(fFreeBuffer);
    
    //
    // Initialize input parameters
    //
    *pBuffer = NULL;
    *fFreeBuffer = FALSE;
    
    //
    // Short circuit for strings that are already NULL terminated.
    //
    fNullTerminated = (String->MaximumLength > String->Length &&
                String->Buffer[String->Length / sizeof(WCHAR)] == UNICODE_NULL);
    
    if (!fNullTerminated) {
        
        //
        // Allocate enough memory to include a terminating NULL character
        //
        *pBuffer = (WCHAR*)midl_user_allocate(String->Length + sizeof(WCHAR));
        
        if ( NULL == *pBuffer ) {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            //
            // Copy the buffer into pBuffer and NULL terminate it.
            //
            *fFreeBuffer = TRUE;
            
            RtlCopyMemory(*pBuffer, String->Buffer, String->Length);
            
            (*pBuffer)[String->Length / sizeof(WCHAR)] = UNICODE_NULL; 
        }   
    }
    else
    {
        //
        // String's internal buffer is already NULL terminated, return it.
        //
        *pBuffer = String->Buffer;    
    }
        
    return Status;
    
}


BOOL 
DigestCompareDomainNames( 
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING AmbiguousName,
    IN PUNICODE_STRING FlatName OPTIONAL
    )
/*++

Routine Description:

    This routine performs a case insensitive comparison between a string
    and a domain name.  If both the NetBIOS and Dns name forms are known then
    the caller must pass the NetBIOS domain name as FlatName and the Dns domain
    name as AmbiguousName.  A non-NULL value for FlatName indicates the caller
    knows both name forms and will result in a more optimal comparison.  If the
    caller has only one name form and it is ambiguous, that is it may be NetBIOS
    or Dns, then the caller must pass NULL for FlatName.  The routine will try
    both a NetBIOS comparison using RtlEqualDomainName and a Dns comparison
    using DnsNameCompare_W.  If either comparison results in equality the TRUE 
    is returned, otherwise FALSE.
    
    This routine provides centralized logic for robust domain name comparison
    consistent with domain name semantics in Lsa data structures. Lsa trust 
    information structures are interpreted in the following way.
    
        LSAPR_TRUST_INFORMATION.Name - Either NetBIOS or Dns 
    
        The following structures have both a FlatName and DomainName (or Name)
        field.  In this case they are interpreted as follows:
                                          
        LSAPR_TRUST_INFORMATION_EX
        LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
        LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2
    
        If the FlatName field is NULL then the other name field is ambiguous.
        If the FlatName field is non NULL, then the other name field is Dns.
    
    NetBIOS comparison is performed using RtlEqualDomainName which enforces the 
    proper OEM character equivelencies.  DNS name comparison is performed using 
    DnsNameCompare_W to ensure proper handling of trailing dots and character
    equivelencies.
            
Arguments:

    String         -- Potentially ambiguous domain name to compare against 
                      AmbiguousName, and FlatName if non-NULL.
    
    AmbiguousName  -- Is treated as an ambiguous name form unless FlatName
                      is also specified.  If FlatName is non-NULL then
                      AmbiguousName is treated as a Dns domain name.
                                   
    FlatName       -- This parameter is optional.  If present it must be the
                      flat name of the domain.  Furthermore, passing this 
                      parameter indicates that AmbiguousName is in fact a
                      Dns domain name.
                                                         
Return Values:

    TRUE  - String is equivelent to one of FlatDomainName or DnsDomainName
    
    FALSE - String is not equivelent to either domain name   
    
    If any parameter isn't a valid UNICODE_STRING then FALSE is returned.
    
Notes:

    The number of comparisons required to determine equivelency will depend 
    on the ammount of information passed in by the caller.  If both the 
    NetBIOS and Dns domain names are known, pass them both to ensure the minimal
    number of comparisons.
    
--*/
{
    NTSTATUS Status;
    BOOLEAN  fEquivalent = FALSE;
    LPWSTR   StringBuffer = NULL;
    LPWSTR   AmbiguousNameBuffer = NULL;
    BOOLEAN  fFreeStringBuffer = FALSE;
    BOOLEAN  fFreeAmbiguousBuffer = FALSE;
    
    //
    // Validate input strings
    //
    ASSERT(String);
    ASSERT(AmbiguousName);                                  
    ASSERT(NT_SUCCESS(RtlValidateUnicodeString( 0, String )));       
    ASSERT(NT_SUCCESS(RtlValidateUnicodeString( 0, AmbiguousName ))); 
    
    //
    // Ensure the UNICODE_STRING data buffers are NULL terminated before
    // passing them to DnsNameCompare_W
    //
    Status = DigestNullTerminateUnicodeString( String,
                                             &StringBuffer,
                                             &fFreeStringBuffer
                                           );        
    if (NT_SUCCESS(Status)) {
        Status = DigestNullTerminateUnicodeString( AmbiguousName,
                                                 &AmbiguousNameBuffer,
                                                 &fFreeAmbiguousBuffer 
                                               );    
    }
    
    if (NT_SUCCESS(Status)) {
        
        if ( NULL == FlatName ) { 
            //
            // AmbiguousName is truly ambiguous, we must perform both 
            // types of comparison between String
            //
            fEquivalent = ( RtlEqualDomainName( String, AmbiguousName ) ||
                            DnsNameCompare_W( StringBuffer, 
                                              AmbiguousNameBuffer )
                           );
        }
        else
        {
            ASSERT(NT_SUCCESS(RtlValidateUnicodeString( 0, FlatName )));
            
            //
            // We are sure of the name forms so lets just use the 
            // appropriate comparison routines on each.
            //
            fEquivalent = ( RtlEqualDomainName( String, FlatName ) ||
                            DnsNameCompare_W( StringBuffer, 
                                              AmbiguousNameBuffer )
                           );                               
        }
    }
    
    if ( fFreeStringBuffer ) {
        MIDL_user_free( StringBuffer );
    }
    
    if ( fFreeAmbiguousBuffer ) {
        MIDL_user_free( AmbiguousNameBuffer );
    }
                     
    if (fEquivalent)
        return(TRUE);
    else
        return(FALSE);
}
               

//+-------------------------------------------------------------------------
//
//  Function:   DigestCheckPacForSidFiltering
//
//  Synopsis:   If the ticket info has a TDOSid then the function
//              makes a check to make sure the SID from the TDO matches
//              the client's home domain SID.  A call to LsaIFilterSids
//              is made to do the check.  If this function fails with
//              STATUS_TRUST_FAILURE then an audit log is generated.
//              Otherwise the function succeeds but SIDs are filtered
//              from the PAC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:   taken from updated kerberos code
//
//
//--------------------------------------------------------------------------
NTSTATUS
DigestCheckPacForSidFiltering(
    IN PDIGEST_PARAMETER pDigest,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPAC_INFO_BUFFER LogonInfo;
    PPACTYPE OldPac;
    ULONG OldPacSize;
    PPACTYPE NewPac = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    SAMPR_PSID_ARRAY ZeroResourceGroups;
    ULONG OldExtraSidCount;
    PPACTYPE RemarshalPac = NULL;
    ULONG RemarshalPacSize = 0;

    OldPac = (PPACTYPE) *PacData;
    OldPacSize = *PacSize;

    DebugLog((DEB_TRACE_FUNC,"DigestCheckPacForSidFiltering: Entering\n"));

    if (PAC_UnMarshal(OldPac, OldPacSize) == 0)
    {
        DebugLog((DEB_ERROR,"DigestCheckPacForSidFiltering: Failed to unmarshal pac\n"));
        Status = SEC_E_CANNOT_PACK;
        goto Cleanup;
    }

    //
    // Must remember to remarshal the PAC prior to returning
    //

    RemarshalPac = OldPac;
    RemarshalPacSize = OldPacSize;

    RtlZeroMemory(
        &ZeroResourceGroups,
        sizeof(ZeroResourceGroups));  // allows us to use PAC_InitAndUpdateGroups to remarshal the PAC

    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    OldPac,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if (LogonInfo == NULL)
    {
        DebugLog((DEB_WARN,"DigestCheckPacForSidFiltering: No logon info for PAC - not making SID filtering check\n"));
        goto Cleanup;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //

    Status = PAC_UnmarshallValidationInfo(
                        &ValidationInfo,
                        LogonInfo->Data,
                        LogonInfo->cbBufferSize);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"DigestCheckPacForSidFiltering: Failed to unmarshall validation info!   0x%x\n", Status));
        goto Cleanup;
    }

    //
    // Save the old extra SID count (so that if KdcFilterSids compresses
    // the SID array, we can avoid allocating memory for the other-org SID later)
    //

    OldExtraSidCount = ValidationInfo->SidCount;

    //
    // Call lsaifiltersids().
    //

    Status = DigestFilterSids(
                 pDigest,
                 ValidationInfo
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"DigestCheckPacForSidFiltering: Failed filtering SIDs\n"));
        goto Cleanup;
    }

    // Other org prcoessing was here - not supported currently for digest

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                ValidationInfo,
                &ZeroResourceGroups,
                OldPac,
                &NewPac
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"DigestCheckPacForSidFiltering: Failed pac init and updating groups    0x%x\n", Status));
        goto Cleanup;
    }

    RemarshalPacSize = PAC_GetSize(NewPac);
    RemarshalPac = NewPac;

Cleanup:

    if ( RemarshalPac != NULL )
    {
        if (!PAC_ReMarshal(RemarshalPac, RemarshalPacSize))
        {
            // PAC_Remarshal Failed
            ASSERT(0);
            Status = SEC_E_CANNOT_PACK;
        }
        else if ( NewPac != NULL &&
                  *PacData != (PBYTE)NewPac )
        {
            MIDL_user_free(*PacData);
            *PacData = (PBYTE) NewPac;
            NewPac = NULL;
            *PacSize = RemarshalPacSize;
        }
    }

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    DebugLog((DEB_TRACE_FUNC,"DigestCheckPacForSidFiltering: Leaving    0x%x\n", Status));

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   DigestFilterSids
//
//  Synopsis:   Function that just call LsaIFilterSids.
//
//  Effects:
//
//  Arguments:  ServerInfo      structure containing attributes of the trust
//              ValidationInfo  authorization information to filter
//
//  Requires:
//
//  Returns:    See LsaIFilterSids
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
DigestFilterSids(
    IN PDIGEST_PARAMETER pDigest,
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING pustrTrustedForest = NULL;

    DebugLog((DEB_TRACE_FUNC, "DigestFilterSids: Entering\n"));

    // Currently we do not allow auth for domains outside forests so this should never fire
    /*
    if ((pDigest->ulTrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0)
    {
        ASSERT(0);    // this should not happen until cross forest is supported
        pustrTrustedForest = &(pDigest->ustrTrustedForest);
        DebugLog((DEB_TRACE, "DigestFilterSids: Filtering Sids for forest %wZ\n", pustrTrustedForest));
    }
    */

    //  This call is used for both intra-forest domain filtering (where the pTrustSid is non-NULL
    //  and for member-to-DC boundary filtering - where the pTrustSid is NULL

    Status = LsaIFilterSids(
                 pustrTrustedForest,           // Pass domain name here
                 pDigest->ulTrustDirection,
                 pDigest->ulTrustType,
                 pDigest->ulTrustAttributes,
                 pDigest->pTrustSid,
                 NetlogonValidationSamInfo2,
                 ValidationInfo,
                 NULL,
                 NULL,
                 NULL
                 );

    if (!NT_SUCCESS(Status))
    {
        //
        // Create an audit log if it looks like the SID has been tampered with  - ToDo
        //

        /*
        if ((STATUS_DOMAIN_TRUST_INCONSISTENT == Status) &&
            SecData.AuditKdcEvent(KDC_AUDIT_TGS_FAILURE))
        {
            DWORD Dummy = 0;

            KdcLsaIAuditKdcEvent(
                SE_AUDITID_TGS_TICKET_REQUEST,
                &ValidationInfo->EffectiveName,
                &ValidationInfo->LogonDomainName,
                NULL,
                &ServerInfo->AccountName,
                NULL,
                &Dummy,
                (PULONG) &Status,
                NULL,
                NULL,                               // no preauth type
                GET_CLIENT_ADDRESS(NULL),
                NULL                                // no logon guid
                );
        }
        */

        DebugLog((DEB_ERROR,"DigestFilterSids: Failed to filter SIDS (LsaIFilterSids): 0x%x\n",Status));
    }
    else
    {
        DebugLog((DEB_TRACE,"DigestFilterSids: successfully filtered sids\n",Status));
    }

    DebugLog((DEB_TRACE_FUNC, "DigestFilterSids: Leaving   Status 0x%x\n", Status));

    return Status;
}

/*
//+---------------------------------------------------------------------------
//
//  Function:   LsaConvertAuthDataToToken
//
//  Synopsis:   Convert an opaque PAC structure into a token.
//
//  Arguments:  [UserAuthData]         --
//              [UserAuthDataSize]     --
//              [TokenInformation]     --
//              [TokenInformationType] --
//
//  History:    3-14-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
LsaConvertAuthDataToToken(
    IN PVOID UserAuthData,
    IN ULONG UserAuthDataSize,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN PTOKEN_SOURCE TokenSource,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AuthorityName,
    OUT PHANDLE TokenHandle,
    OUT PLUID LogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PNTSTATUS SubStatus
    )
{
    NTSTATUS Status ;
    PPACTYPE Pac = NULL ;
    PPAC_INFO_BUFFER LogonInfo = NULL ;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL ;
    PLSA_TOKEN_INFORMATION_V1 TokenInfo = NULL ;

    LogonId->HighPart = LogonId->LowPart = 0;
    *TokenHandle = NULL;
    RtlInitUnicodeString(
        AccountName,
        NULL
        );

    *SubStatus = STATUS_SUCCESS;

    Pac = (PPACTYPE) UserAuthData ;

    if ( PAC_UnMarshal( Pac, UserAuthDataSize ) == 0 )
    {
        DebugLog(( DEB_ERROR, "Failed to unmarshall pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto CreateToken_Cleanup ;
    }

    LogonInfo = PAC_Find( Pac, PAC_LOGON_INFO, NULL );

    if ( !LogonInfo )
    {
        DebugLog(( DEB_ERROR, "Failed to find logon info in pac\n" ));

        Status = STATUS_INVALID_PARAMETER ;

        goto CreateToken_Cleanup ;
    }

    Status = PAC_UnmarshallValidationInfo(
                &ValidationInfo,
                LogonInfo->Data,
                LogonInfo->cbBufferSize
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x\n",
            Status));

        goto CreateToken_Cleanup;
    }

    //
    // Now we need to build a LSA_TOKEN_INFORMATION_V1 from the validation
    // information
    //

    Status = LsapMakeTokenInformationV1(
                ValidationInfo,
                &TokenInfo
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to make token informatin v1: 0x%x\n",
            Status));
        goto CreateToken_Cleanup;
    }

    //
    // Now, copy the user name.
    //

    Status = LsapDuplicateString( AccountName, &ValidationInfo->EffectiveName );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreateToken_Cleanup ;
    }

    //
    // Now create a logon session
    //

    Status = LsapCreateLogonSession( LogonId );

    if (!NT_SUCCESS(Status))
    {
        goto CreateToken_Cleanup;
    }

    //
    // Now create the token
    //

    Status = LsapCreateToken(
                LogonId,
                TokenSource,
                LogonType,
                ImpersonationLevel,
                LsaTokenInformationV1,
                TokenInfo,
                NULL,                   // no token groups
                AccountName,
                AuthorityName,
                NULL,
                &ValidationInfo->ProfilePath,
                TokenHandle,
                SubStatus
                );

    //
    // NULL out the TokenInfo pointer.  LsapCreateToken will
    // free the memory under all conditions
    //

    TokenInfo = NULL ;

    if (!NT_SUCCESS(Status))
    {
        goto CreateToken_Cleanup;
    }

    //
    // We don't need to free the token information because CreateToken does
    // that for us.
    //

    MIDL_user_free(ValidationInfo);
    return Status ;

CreateToken_Cleanup:

    if ( TokenInfo )
    {
        LsaFreeTokenInfo( LsaTokenInformationV1, TokenInfo );
    }

    if ((LogonId->LowPart != 0) || (LogonId->HighPart != 0))
    {
        LsapDeleteLogonSession(LogonId);
    }

    LsapFreeString(
        AccountName
        );

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    return Status ;
}

*/


#ifdef ROGUE_DC

#pragma message( "COMPILING A ROGUE DC!!!" )
#pragma message( "MUST NOT SHIP THIS BUILD!!!" )

#pragma warning(disable:4127) // Disable warning/error for conditional expression is constant

#define MAX_SID_LEN (sizeof(SID) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)


extern "C"
{
#include "sddl.h"
#include "stdlib.h"
}

extern HKEY g_hDigestRogueKey;

NTSTATUS
DigestInstrumentRoguePac(
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize
    )
{
    NTSTATUS Status;
    PNETLOGON_VALIDATION_SAM_INFO3 OldValidationInfo = NULL;
    NETLOGON_VALIDATION_SAM_INFO3 NewValidationInfo = {0};
    SAMPR_PSID_ARRAY ZeroResourceGroups = {0};
    PPACTYPE NewPac = NULL;
    ULONG NewPacSize;
    PPAC_INFO_BUFFER LogonInfo;

    PPACTYPE OldPac = NULL;
    ULONG OldPacSize;

    PSID LogonDomainId = NULL;
    PSID ResourceGroupDomainSid = NULL;
    PGROUP_MEMBERSHIP GroupIds = NULL;
    PGROUP_MEMBERSHIP ResourceGroupIds = NULL;
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids = NULL;
    BYTE FullUserSidBuffer[MAX_SID_LEN];
    SID * FullUserSid = ( SID * )FullUserSidBuffer;
    CHAR * FullUserSidText = NULL;

    DWORD dwType;
    DWORD cbData = 0;
    PCHAR Buffer;
    PCHAR Value = NULL;

    BOOLEAN PacChanged = FALSE;

    DebugLog((DEB_TRACE_FUNC,"DigestInstrumentRoguePac: Entering\n"));

    //
    // Optimization: no "rogue" key in registry - nothing for us to do
    //

    if ( g_hDigestRogueKey == NULL )
    {
        return STATUS_SUCCESS;
    }


    OldPac = (PPACTYPE) *PacData;
    OldPacSize = *PacSize;

    //
    // Unmarshall the old PAC
    //

    if ( PAC_UnMarshal(OldPac, OldPacSize) == 0 )
    {
        DebugLog((DEB_ERROR,"DigestInstrumentRoguePac: Failed to unmarshal pac\n"));
        Status = SEC_E_CANNOT_PACK;
        goto Cleanup;
    }

    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    OldPac,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if ( LogonInfo == NULL )
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: No logon info on PAC - not performing substitution\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //

    if ( !NT_SUCCESS(PAC_UnmarshallValidationInfo(
                         &OldValidationInfo,
                         LogonInfo->Data,
                         LogonInfo->cbBufferSize )))
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Unable to unmarshal validation info\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Construct the text form of the full user's SID (logon domain ID + user ID)
    //

    DsysAssert( sizeof( FullUserSidBuffer ) >= MAX_SID_LEN );

    RtlCopySid(
        sizeof( FullUserSidBuffer ),
        FullUserSid,
        OldValidationInfo->LogonDomainId
        );

    FullUserSid->SubAuthority[FullUserSid->SubAuthorityCount] = OldValidationInfo->UserId;
    FullUserSid->SubAuthorityCount += 1;

    if ( FALSE == ConvertSidToStringSidA(
                      FullUserSid,
                      &FullUserSidText ))
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Unable to convert user's SID\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now look in the registry for the SID matching the validation info
    //

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              g_hDigestRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: No substitution info available for %s\n", FullUserSidText));
        Status = STATUS_SUCCESS;
        goto Error;
    }

    // SafeAllocaAllocate( Value, cbData );
    Value = (PCHAR)DigestAllocateMemory(cbData);
    if ( Value == NULL )
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Out of memory allocating substitution buffer\n", FullUserSidText));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              g_hDigestRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              (PBYTE)Value,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Error reading from registry\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Substituting the PAC for %s\n", FullUserSidText));

    Buffer = Value;

    //
    // New validation info will be overloaded with stuff from the file
    //

    NewValidationInfo = *OldValidationInfo;

    //
    // Read the input file one line at a time
    //

    while ( *Buffer != '\0' )
    {
        switch( Buffer[0] )
        {
        case 'l':
        case 'L': // logon domain ID

            if ( LogonDomainId != NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Logon domain ID specified more than once - only first one kept\n"));
                break;
            }

            DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Substituting logon domain ID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &LogonDomainId ))
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( LogonDomainId == NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Out of memory allocating LogonDomainId\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            NewValidationInfo.LogonDomainId = LogonDomainId;
            LogonDomainId = NULL;
            PacChanged = TRUE;

            break;

        case 'd':
        case 'D': // resource group domain SID

            if ( ResourceGroupDomainSid != NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Resource group domain SID specified more than once - only first one kept\n"));
                break;
            }

            DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Substituting resource group domain SID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &ResourceGroupDomainSid ))
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( ResourceGroupDomainSid == NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Out of memory allocating ResourceGroupDomainSid\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            NewValidationInfo.ResourceGroupDomainSid = ResourceGroupDomainSid;
            ResourceGroupDomainSid = NULL;
            PacChanged = TRUE;

            break;

        case 'p':
        case 'P': // primary group ID

            DebugLog((DEB_WARN, "DigestInstrumentRoguePac: Substituting primary group ID by %s\n", &Buffer[1]));

            NewValidationInfo.PrimaryGroupId = atoi(&Buffer[1]);
            PacChanged = TRUE;

            break;

        case 'u':
        case 'U': // User ID

            DebugLog((DEB_WARN, "DigestInstrumentRoguePac: Substituting user ID by %s\n", &Buffer[1]));

            NewValidationInfo.UserId = atoi(&Buffer[1]);
            PacChanged = TRUE;

            break;

        case 'e':
        case 'E': // Extra SID

            DebugLog((DEB_WARN, "DigestInstrumentRoguePac: Adding an ExtraSid: %s\n", &Buffer[1]));

            if ( ExtraSids == NULL )
            {
                NewValidationInfo.ExtraSids = NULL;
                NewValidationInfo.SidCount = 0;

                ExtraSids = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapAlloc(
                                GetProcessHeap(),
                                0,
                                sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                );
            }
            else
            {
                ExtraSids = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapReAlloc(
                                GetProcessHeap(),
                                0,
                                NewValidationInfo.ExtraSids,
                                ( NewValidationInfo.SidCount + 1 ) * sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                );
            }

            if ( ExtraSids == NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Out of memory allocating ExtraSids\n"));
                ExtraSids = NewValidationInfo.ExtraSids;
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual SID
            //

            NewValidationInfo.ExtraSids = ExtraSids;

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Sid ))
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Sid == NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Out of memory allocating an extra SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;

            NewValidationInfo.SidCount += 1;
            PacChanged = TRUE;

            break;

        case 'g':
        case 'G': // Group ID

            DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Adding a GroupId: %s\n", &Buffer[1]));

            if ( GroupIds == NULL )
            {
                NewValidationInfo.GroupIds = NULL;
                NewValidationInfo.GroupCount = 0;

                GroupIds = ( PGROUP_MEMBERSHIP )HeapAlloc(
                               GetProcessHeap(),
                               0,
                               sizeof( GROUP_MEMBERSHIP )
                               );
            }
            else
            {
                GroupIds = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                               GetProcessHeap(),
                               0,
                               NewValidationInfo.GroupIds,
                               ( NewValidationInfo.GroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                               );
            }

            if ( GroupIds == NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Out of memory allocating Group IDs\n"));
                GroupIds = NewValidationInfo.GroupIds;
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual ID
            //

            NewValidationInfo.GroupIds = GroupIds;
            NewValidationInfo.GroupIds[NewValidationInfo.GroupCount].RelativeId = atoi(&Buffer[1]);
            NewValidationInfo.GroupIds[NewValidationInfo.GroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            NewValidationInfo.GroupCount += 1;
            PacChanged = TRUE;

            break;

        case 'r':
        case 'R': // Resource groups

            DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Adding a ResourceGroupId: %s\n", &Buffer[1]));

            if ( ResourceGroupIds == NULL )
            {
                NewValidationInfo.ResourceGroupIds = NULL;
                NewValidationInfo.ResourceGroupCount = 0;

                ResourceGroupIds = ( PGROUP_MEMBERSHIP )HeapAlloc(
                                       GetProcessHeap(),
                                       0,
                                       sizeof( GROUP_MEMBERSHIP )
                                       );
            }
            else
            {
                ResourceGroupIds = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                                       GetProcessHeap(),
                                       0,
                                       NewValidationInfo.ResourceGroupIds,
                                       ( NewValidationInfo.ResourceGroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                                       );
            }

            if ( ResourceGroupIds == NULL )
            {
                DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Out of memory allocating Resource Group IDs\n"));
                ResourceGroupIds = NewValidationInfo.ResourceGroupIds;
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual ID
            //

            NewValidationInfo.ResourceGroupIds = ResourceGroupIds;
            NewValidationInfo.ResourceGroupIds[NewValidationInfo.ResourceGroupCount].RelativeId = atoi(&Buffer[1]);
            NewValidationInfo.ResourceGroupIds[NewValidationInfo.ResourceGroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            NewValidationInfo.ResourceGroupCount += 1;
            PacChanged = TRUE;

            break;

        default:   // unrecognized

            DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Entry \'%c\' unrecognized\n", Buffer[0]));

            break;
        }

        //
        // Move to the next line
        //

        while (*Buffer++ != '\0');
    }

    if ( !PacChanged )
    {
        DebugLog((DEB_TRACE, "DigestInstrumentRoguePac: Nothing to substitute for %s\n", FullUserSidText));
        Status = STATUS_SUCCESS;
        goto Error;
    }

    //
    // If resource group IDs were added, indicate that by setting the corresponding flag
    //

    if ( ResourceGroupIds )
    {
        NewValidationInfo.UserFlags |= LOGON_RESOURCE_GROUPS;
    }

    //
    // If extra SIDs were added, indicate that by setting the corresponding flag
    //

    if ( ExtraSids )
    {
        NewValidationInfo.UserFlags |= LOGON_EXTRA_SIDS;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                 &NewValidationInfo,
                 &ZeroResourceGroups,
                 OldPac,
                 &NewPac
                 );

    if ( !NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Error 0x%x from PAC_InitAndUpdateGroups\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    NewPacSize = PAC_GetSize( NewPac );

    if (!PAC_ReMarshal(NewPac, NewPacSize))
    {
        DsysAssert(!"DigestInstrumentRoguePac: PAC_Remarshal Failed");
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    MIDL_user_free( *PacData );   // Free up the OldPac structure
    *PacData = (PBYTE) NewPac;
    NewPac = NULL;
    *PacSize = NewPacSize;

    Status = STATUS_SUCCESS;

Cleanup:

    MIDL_user_free( OldValidationInfo );
    LocalFree( FullUserSidText );
    LocalFree( ResourceGroupDomainSid );
    LocalFree( LogonDomainId );
    HeapFree( GetProcessHeap(), 0, ResourceGroupIds );
    HeapFree( GetProcessHeap(), 0, GroupIds );

    if ( ExtraSids )
    {
        for ( ULONG i = 0; i < NewValidationInfo.SidCount; i++ )
        {
            HeapFree( GetProcessHeap(), 0, ExtraSids[i].Sid );
        }

        HeapFree( GetProcessHeap(), 0, ExtraSids );
    }

    MIDL_user_free( NewPac );

    // SafeAllocaFree( Value );
    DigestFreeMemory( Value );

    DebugLog((DEB_TRACE_FUNC, "DigestInstrumentRoguePac: Leaving   Status 0x%x\n", Status));

    return Status;

Error:

    if ( !NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "DigestInstrumentRoguePac: Substitution encountered an error, not performed\n"));
    }

    if ( !PAC_ReMarshal(OldPac, OldPacSize))
    {
        // PAC_Remarshal Failed
        DsysAssert(!"DigestInstrumentRoguePac: PAC_Remarshal Failed");
        Status = SEC_E_CANNOT_PACK;
    }

    goto Cleanup;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\nonce.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        nonce.h
//
// Contents:    Constants for the Nonce Generator/Validator

//
// History:     
//              KDamour  21Mar00       Created
//
//------------------------------------------------------------------------
#ifndef NTDIGEST_NONCE_H
#define NTDIGEST_NONCE_H


// NONCE FORMAT
//   rand-data = rand[16]
//   nonce_binary = time-stamp  rand-data H(time-stamp ":" rand-data ":" nonce_private_key)
//   nonce = hex(nonce_binary)

// SIZE implies number of ASCII chars
// BYTESIZE is the number of bytes of Data (binary)
#define NONCE_PRIVATE_KEY_BYTESIZE 16                    // Generate 128 bit random private key
#define RANDDATA_BYTESIZE 16                             // # of random bytes at beginning of nonce
#define TIMESTAMP_BYTESIZE sizeof(FILETIME)              // size of timestamp in nonce binary 8 bytes

#define PRECALC_HASH_BASEFORMS 3                          // Number of forms for each username:realm:password combo
#define PRECALC_HASH_ALLFORMS 7                           // Number of forms with non-zero length Realm

// For Hex encoding need 2chars per byte encoded
#define NONCE_SIZE ((2*TIMESTAMP_BYTESIZE) + (2*RANDDATA_BYTESIZE) + (2*MD5_HASH_BYTESIZE))
#define NONCE_TIME_LOC 0
#define NONCE_RANDDATA_LOC (2 * TIMESTAMP_BYTESIZE)
#define NONCE_HASH_LOC (NONCE_RANDDATA_LOC + (2 * RANDDATA_BYTESIZE))

#define OPAQUE_RANDATA_SIZE 16                    // Make 128bits of rand data for reference
#define OPAQUE_SIZE (OPAQUE_RANDATA_SIZE * 2)

#define MAX_URL_SIZE        512


#ifndef SECURITY_KERNEL

#include <wincrypt.h>

// Handle into the CryptoAPI
extern HCRYPTPROV g_hCryptProv;
extern WORD       g_SupportedCrypto;

NTSTATUS NTAPI NonceInitialize(VOID);

NTSTATUS NTAPI NonceCreate(OUT PSTRING pstrNonce);

// Primary function to call to check validity of a nonce
NTSTATUS NonceIsValid(PSTRING pstrNonce);

// Helper function for NonceIsValid to check if Hash is correct
BOOL NonceIsTampered(PSTRING pstrNonce);


BOOL HashData(BYTE *pbData, DWORD cbData, BYTE *pbHash );

// Create the Hash for the Nonce Parameters
NTSTATUS NTAPI NonceHash( IN LPBYTE pbTime, IN DWORD cbTime,
           IN LPBYTE pbRandom, IN DWORD cbRandom,
           IN LPBYTE pbKey, IN DWORD cbKey,
           OUT LPBYTE pbHash);

NTSTATUS NTAPI OpaqueCreate(IN OUT PSTRING pstrOpaque);

//  Set the bitmask for the supported crypto CSP installed
NTSTATUS NTAPI SetSupportedCrypto(VOID);

#endif  // SECURITY_KERNEL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\notify.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        notify.cxx
//
// Contents:    Credential functions:
//
//
// History:     KDamour  29Mar01   Created
//
//------------------------------------------------------------------------

#include <stdio.h>
#include "global.h"

// For notify.cxx  DsGetDcName
#include <dsgetdc.h>

//
// Precomputed digest hash functions
//
//  This is the ordered list of digest hash functions contained in the supplemental (primary)
//  credential for the user in the DS on the DC.  The order is imporant to preserve and new
//  versions of the hash functions can be appended to the list the the DigestSelectHash()
//  function updated
//
//      H(davemo:redmond:MyPassword) - I think this form is used for some sasl implementations
//              and is the default way our client side packages the info when you use the auth
//              identity structure.
//
//      H(redmond\davemo:corp.microsoft.com:MyPassword) - this form will handle backwards compatibility
//              with older IE clients. Currently a Digest IE client will type in a username that is the
//              netbios domain\user form and the client will return the realm hint. The realm hint will
//              be provided by new Digest (IIS) servers and determined by a call to
//              DsRoleGetPrimaryDomainInformation to retrieve DomainForestName.
//
//      H(davemo@redmond.microsoft.com:corp.microsoft.com:MyPassword) - We want to eventually move
//              everyone to UPNs and this gives us forward compatiblity. The realm value comes from the
//              same method as above.
//
//     Each format will have argument formatted, uppercase, lowercase formats.


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateNotify
//
//  Synopsis:   This routine is called from LSA in order to obtain
//              new Digest Hash credentials to be stored as supplemental
//              credentials when ever a user's password is set/changed.
//              These precalculated hashes can be used instead of turning
//              on Reversible Encryption on the DC
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   ClearPassword      -- the clear text password
//  IN   OldCredentials     -- the previous digest credentials
//  IN   OldCredentialsSize -- size of OldCredentials
//  IN   UserAccountControl -- info about the user
//  IN   UPN                -- user principal name of the account (Optional)
//  IN   UserName           -- the SAM account name of the account
//  IN   DnsDomainName      -- DNS domain name of the account
//  OUT  NewCredentials     -- space allocated for SAM containing
//                             the credentials based on the input parameters
//                             to be freed by CredentialUpdateFree
//  OUT  NewCredentialSize  -- size of NewCredentials
//
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes:      WDigest.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//              We are called when the password changes. This routine is not
//              called when the username, UPN, or DNSDomainName changes. It is
//              a known issue and noted that the users must change their passwords
//              to populate a updated hash after a domainname change.
//              Need to set key 
//                 \Registry\Machine\System\CurrentControlSet\Control\LSA   Notification Packages
//
//
//--------------------------------------------------------------------------
NTSTATUS
CredentialUpdateNotify (
    IN PUNICODE_STRING ClearPassword,
    IN PVOID OldCredentials,
    IN ULONG OldCredentialsSize,
    IN ULONG UserAccountControl,
    IN PUNICODE_STRING UPN,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING DnsDomainName,
    OUT PVOID *NewCredentials,
    OUT ULONG *NewCredentialsSize
    )
{

   // Structure will be composed of a series of binary hash values
   // Each hash is a binary version of a MD5 hash of  H(username:realm:password)
   // Each hash is MD5_HASH_BYTESIZE (16 bytes) in length.  The Hex version of
   // that is  32 bytes in length.
   //  The supplimental creds will have the following structure
    // All versions will have the similar start of 16 byte header - version number
    //   Version 1 supplimental creds looks like
    //        Header  (version number as ASCII string <sp> number of pre-calculated hashes)  i.e  "1 6\0\0...\0"
    //        H(username, short domain name, password)              (16 bytes)
    //        H(UPN, NULL string, password)

    NTSTATUS Status = STATUS_SUCCESS;
    PCHAR  pWhere = NULL;
    PCHAR  pcSuppCreds = NULL;
    USHORT  usSuppCredSize = 0;
    USHORT usLength = 0;
    USHORT usTotalByteCount = 0;
    USHORT usNumWChars = 0;
    PWCHAR pwBS = L"\\";
    UNICODE_STRING ustrFlatDomainName = {0};
    UNICODE_STRING ustrNetBios = {0};
    UNICODE_STRING ustrEmpty = {0};
    UNICODE_STRING ustrcFRealm = {0};

    UNREFERENCED_PARAMETER(OldCredentials);
    UNREFERENCED_PARAMETER(OldCredentialsSize);
    UNREFERENCED_PARAMETER(UserAccountControl);

    DebugLog((DEB_TRACE_FUNC, "CredentialUpdateNotify: Entering\n"));
    DebugLog((DEB_TRACE, "CredentialUpdateNotify: UPN (%wZ), Username (%wZ), DNSDomainName (%wZ)\n",
              UPN, UserName, DnsDomainName));

    ASSERT(NewCredentials);
    ASSERT(NewCredentialsSize);

    *NewCredentials = NULL;
    *NewCredentialsSize = NULL;


    usSuppCredSize = TOTALPRECALC_HEADERS * MD5_HASH_BYTESIZE;
    pcSuppCreds = (PCHAR)DigestAllocateMemory(usSuppCredSize);
    if (!pcSuppCreds)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Error from Digest Allocate is 0x%lx\n", Status));
        goto CleanUp;
    }

    usNumWChars =  (NetbiosDomainName->Length + sizeof(WCHAR)) / sizeof(WCHAR);
    Status = UnicodeStringAllocate(&ustrFlatDomainName, usNumWChars);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Copy Domain error 0x%x\n", Status));
        goto CleanUp;
    }

    RtlCopyUnicodeString(&ustrFlatDomainName, NetbiosDomainName);

    Status = RtlUpcaseUnicodeString(&ustrFlatDomainName, &ustrFlatDomainName, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Upcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CredentialUpdateNotify: Flat DomainName (%wZ)\n", &ustrFlatDomainName));

    // Hash 0   Header information
    //  '1' 0 version numhashes 0 0 0 0 0 0 0 0 0 0 0 0
    //    where version is a single byte revision number for the hashes
    //          numhashes is a byte unsigned short with number of headers
    pWhere = pcSuppCreds;
    // sprintf(pWhere, "%d %d", SUPPCREDS_VERSION, NUMPRECALC_HEADERS);
    *pWhere = '1';   // for RC1 server used ascii version info - not needed after RC2 ships
    *(pWhere + SUPPCREDS_VERSIONLOC) = SUPPCREDS_VERSION;   // version
    *(pWhere + SUPPCREDS_CNTLOC) = NUMPRECALC_HEADERS;   // number of pre-calculed hashes

    pWhere += MD5_HASH_BYTESIZE;
    usTotalByteCount += MD5_HASH_BYTESIZE; 


    // Now write out the pre-calculated hashes
    //  IMPORTANT to make sure that NUMPRECALC_HEADERS is updated if new hashes added !!!!!!

    // Hash 1   username:FlatDomainName:password
    usLength = usSuppCredSize - usTotalByteCount;
    Status = PrecalcForms(UserName, &ustrFlatDomainName, ClearPassword, FALSE, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    usTotalByteCount = usTotalByteCount + usLength;

    // Hash 2   username:DNSDomainName:password
    usLength = usSuppCredSize - usTotalByteCount;
    Status = PrecalcForms(UserName, DnsDomainName, ClearPassword, FALSE, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    usTotalByteCount = usTotalByteCount + usLength;

    // Hash 3   UPN::password
    usLength = usSuppCredSize - usTotalByteCount;
    Status = PrecalcForms(UPN, &ustrEmpty, ClearPassword, FALSE, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    usTotalByteCount = usTotalByteCount + usLength;

    // Hash 4   NetBIOS::password
    //         NetBIOS name   flatdomain\username

    usNumWChars =  (ustrFlatDomainName.Length + UserName->Length + sizeof(WCHAR)) / sizeof(WCHAR);
    Status = UnicodeStringAllocate(&ustrNetBios, usNumWChars);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Copy Domain error 0x%x\n", Status));
        goto CleanUp;
    }

    RtlCopyUnicodeString(&ustrNetBios, &ustrFlatDomainName);
    
    Status = RtlAppendUnicodeToString(&ustrNetBios, pwBS);    
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Append Separator error 0x%x\n", Status));
        goto CleanUp;
    }
    Status = RtlAppendUnicodeStringToString(&ustrNetBios, UserName);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: Append username error 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CredentialUpdateNotify: NetBIOS name %wZ\n", &ustrNetBios));

    usLength = usSuppCredSize - usTotalByteCount;
    Status = PrecalcForms(&ustrNetBios, &ustrEmpty, ClearPassword, FALSE, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    usTotalByteCount = usTotalByteCount + usLength;

    // Hash 5  user forms (SAM, UPN, NetBIOS):fixed realm value:password
    RtlInitUnicodeString(&ustrcFRealm, WSTR_DIGEST_DOMAIN);

    usLength = usSuppCredSize - usTotalByteCount;
    Status = PrecalcForms(UserName, &ustrcFRealm, ClearPassword, TRUE, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    usTotalByteCount = usTotalByteCount + usLength;

    usLength = usSuppCredSize - usTotalByteCount;
    Status = PrecalcForms(UPN, &ustrcFRealm, ClearPassword, TRUE, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += usLength;
    usTotalByteCount = usTotalByteCount + usLength;

    usLength = usSuppCredSize - usTotalByteCount;
    Status = PrecalcForms(&ustrNetBios, &ustrcFRealm, ClearPassword, TRUE, pWhere, &usLength);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CredentialUpdateNotify: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    usTotalByteCount = usTotalByteCount + usLength;



    ASSERT(usTotalByteCount == usSuppCredSize);

    // Provide the supplimental credentials
    *NewCredentials = pcSuppCreds;
    *NewCredentialsSize = (LONG)usSuppCredSize;

    DebugLog((DEB_TRACE, "CredentialUpdateNotify: Succeeded in pre-calc of digest hashes  Aux cred size 0x%x\n",
              usSuppCredSize ));

CleanUp:

    UnicodeStringFree(&ustrFlatDomainName);
    UnicodeStringFree(&ustrNetBios);

    DebugLog((DEB_TRACE_FUNC, "CredentialUpdateNotify: Leaving   Status 0x%x\n", Status));

    return Status;
}



//
// Free's the memory allocated by CredentialUpdateNotify
//
VOID
CredentialUpdateFree(
    PVOID p
    )
{
    if (p) {
        DigestFreeMemory(p);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   CredentialUpdateRegister
//
//  Synopsis:   This routine is called from LSA in order to obtain
//              the name of the supplemental credentials passed into this package
//              when a password is changed or set.
//
//  Effects:    Register with LSA that we want to be notified on PWD change
//
//  Arguments:
//
//  OUT CredentialName -- the name of credential tag in the supplemental
//                        credentials.  Note this memory is never freed
//                        by SAM, but must remain valid for the lifetime
//                        of the process.
//
//  Requires:   no global requirements
//
//  Returns:    TRUE
//
//  Notes:      wdigest.DLL needs to be registered (in the registry) as a
//              package that SAM calls out to in order for this routine
//              to be involked.
//              This will be run only on the DC
//
//
//--------------------------------------------------------------------------
BOOLEAN
CredentialUpdateRegister(
    OUT UNICODE_STRING *CredentialName
    )
{
    ASSERT(CredentialName);

    RtlInitUnicodeString(CredentialName, WDIGEST_SP_NAME);

    return TRUE;
}




//+--------------------------------------------------------------------
//
//  Function:   PrecalcForms
//
//  Synopsis:   given a username, realm, password form
//                H(username, realm, password)
//                H(UPPER(username), UPPER(realm), password)
//                H(LOWER(username), LOWER(realm), password)
//        Following hashes are formed only if realm is present
//                H(username, UPPER(realm), password)
//                H(username, LOWER(realm), password)
//                H(UPPER(username), LOWER(realm), password)
//                H(LOWER(username), UPPER(realm), password)
//
//  Effects:    None
//
//  Arguments:  pustrUsername - pointer to unicode_string struct with account name
//              pustrRealm - pointer to unicode_string struct with realm
//              pustrPassword - pointer to unicode_string struct with cleartext password
//              fFixedRealm - controls if the realm string fixed - do not change case
//              pHash - pointer to byte buffer for ouput passwrd hash
//              piHashSize - pointer to size of the binary buffer passed in & bytes written on output
//
//  Returns:  STATUS_SUCCESS for normal completion
//            STATUS_BUFFER_TOO_SMALL - Hash buffer too small, iHashSize contains min size
//
//  Notes:  Form three versions:
//                format provided, Uppercase and Lowercase versions
//
//---------------------------------------------------------------------
NTSTATUS PrecalcForms(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    IN BOOL fFixedRealm,
    OUT PCHAR pHash,
    IN OUT PUSHORT piHashSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCHAR  pWhere = NULL;
    USHORT usLength = 0;
    USHORT usSizeRequired = 0;
    UNICODE_STRING ustrTempLowerUsername = {0};
    UNICODE_STRING ustrTempLowerRealm = {0};
    UNICODE_STRING ustrTempUpperUsername = {0};
    UNICODE_STRING ustrTempUpperRealm = {0};

    DebugLog((DEB_TRACE_FUNC, "PrecalcForms: Entering\n"));

    if (!fFixedRealm && pustrRealm && pustrRealm->Length)
    {
        usSizeRequired = (MD5_HASH_BYTESIZE * PRECALC_HASH_ALLFORMS);
    }
    else
    {
        usSizeRequired = (MD5_HASH_BYTESIZE * PRECALC_HASH_BASEFORMS);
    }

    if (*piHashSize < usSizeRequired)
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "PrecalcForms: Buffer size too small for multiple hashes   0x%x\n", Status));
        goto CleanUp;
    }
    
    pWhere = pHash;

    // Create local copies for case modificaiton
    Status = UnicodeStringDuplicate(&ustrTempLowerUsername, pustrUsername);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Username copy     error 0x%x\n", Status));
        goto CleanUp;
    }


    Status = UnicodeStringDuplicate(&ustrTempLowerRealm, pustrRealm);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Realm copy     error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(&ustrTempUpperUsername, pustrUsername);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Username copy     error 0x%x\n", Status));
        goto CleanUp;
    }


    Status = UnicodeStringDuplicate(&ustrTempUpperRealm, pustrRealm);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Realm copy     error 0x%x\n", Status));
        goto CleanUp;
    }

    // Now form lowercase version

    Status = RtlDowncaseUnicodeString(&ustrTempLowerUsername, &ustrTempLowerUsername, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Downcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = RtlDowncaseUnicodeString(&ustrTempLowerRealm, &ustrTempLowerRealm, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Downcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    // and uppercase version

    Status = RtlUpcaseUnicodeString(&ustrTempUpperUsername, &ustrTempUpperUsername, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Upcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }

    Status = RtlUpcaseUnicodeString(&ustrTempUpperRealm, &ustrTempUpperRealm, FALSE);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: Upcase failed    error 0x%x\n", Status));
        goto CleanUp;
    }


    // First hash - use the input credentials
    usLength = MD5_HASH_BYTESIZE;
    Status = PrecalcDigestHash(pustrUsername,
                               pustrRealm,
                               pustrPassword,
                               pWhere,
                               &usLength);
    if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += MD5_HASH_BYTESIZE;


    usLength = MD5_HASH_BYTESIZE;
    Status = PrecalcDigestHash(&ustrTempLowerUsername,
                               (fFixedRealm ? pustrRealm : &ustrTempLowerRealm),
                               pustrPassword,
                               pWhere,
                               &usLength);
    if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += MD5_HASH_BYTESIZE;

    usLength = MD5_HASH_BYTESIZE;
    Status = PrecalcDigestHash(&ustrTempUpperUsername,
                               (fFixedRealm ? pustrRealm : &ustrTempUpperRealm),
                               pustrPassword,
                               pWhere,
                               &usLength);
    if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
    {
        DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
        goto CleanUp;
    }
    pWhere += MD5_HASH_BYTESIZE;

    // Do not form other hashes for fixed realm value - above forms include all
    if (!fFixedRealm && pustrRealm && pustrRealm->Length)
    {

        usLength = MD5_HASH_BYTESIZE;
        Status = PrecalcDigestHash(pustrUsername,
                                   &ustrTempUpperRealm,
                                   pustrPassword,
                                   pWhere,
                                   &usLength);
        if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
        {
            DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
            goto CleanUp;
        }
        pWhere += MD5_HASH_BYTESIZE;

        usLength = MD5_HASH_BYTESIZE;
        Status = PrecalcDigestHash(pustrUsername,
                                   &ustrTempLowerRealm,
                                   pustrPassword,
                                   pWhere,
                                   &usLength);
        if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
        {
            DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
            goto CleanUp;
        }
        pWhere += MD5_HASH_BYTESIZE;

        usLength = MD5_HASH_BYTESIZE;
        Status = PrecalcDigestHash(&ustrTempUpperUsername,
                                   &ustrTempLowerRealm,
                                   pustrPassword,
                                   pWhere,
                                   &usLength);
        if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
        {
            DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
            goto CleanUp;
        }
        pWhere += MD5_HASH_BYTESIZE;

        usLength = MD5_HASH_BYTESIZE;
        Status = PrecalcDigestHash(&ustrTempLowerUsername,
                                   &ustrTempUpperRealm,
                                   pustrPassword,
                                   pWhere,
                                   &usLength);
        if ((!NT_SUCCESS (Status)) && (Status != STATUS_UNMAPPABLE_CHARACTER))
        {
            DebugLog((DEB_ERROR, "PrecalcForms: PrecalcDigestHash error 0x%x\n", Status));
            goto CleanUp;
        }
        pWhere += MD5_HASH_BYTESIZE;
    }

    // Indicate that we used three MD5 hashes
    *piHashSize = usSizeRequired;
    Status = STATUS_SUCCESS;

CleanUp:

    UnicodeStringFree(&ustrTempLowerUsername);
    UnicodeStringFree(&ustrTempLowerRealm);
    UnicodeStringFree(&ustrTempUpperUsername);
    UnicodeStringFree(&ustrTempUpperRealm);

    DebugLog((DEB_TRACE_FUNC, "PrecalcForms: Leaving   0x%x\n", Status));

    return (Status);
}



//+--------------------------------------------------------------------
//
//  Function:   PrecalcDigestHash
//
//  Synopsis:   Calculate PasswordHash  H(accountname:realm:password) 
//
//  Effects:    None
//
//  Arguments:  pustrUsername - pointer to unicode_string struct with account name
//              pustrRealm - pointer to unicode_string struct with realm
//              pustrPassword - pointer to unicode_string struct with cleartext password
//              pHash - pointer to byte buffer for ouput passwrd hash
//              piHashSize - pointer to size of the binary buffer passed in & bytes written on output
//
//  Returns:  STATUS_SUCCESS for normal completion
//            STATUS_BUFFER_TOO_SMALL - Binary Hash buffer too small, iHashSize contains min size
//
//  Notes:  For each parameter, if it can be encoded fully in ISO 8859-1 then do so.
//     If not (there are extended characters), then encode in UTF-8.  Each component is tested separately.
//
//---------------------------------------------------------------------
NTSTATUS PrecalcDigestHash(
    IN PUNICODE_STRING pustrUsername, 
    IN PUNICODE_STRING pustrRealm,
    IN PUNICODE_STRING pustrPassword,
    OUT PCHAR pHash,
    IN OUT PUSHORT piHashSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;


    STRING strUsername = {0};
    STRING strRealm = {0};
    STRING strPasswd = {0};
    STRING strHash = {0};
    BOOL fDefChars = FALSE;

    DebugLog((DEB_TRACE_FUNC, "PrecalcDigestHash: Entering\n"));

    if (*piHashSize < MD5_HASH_BYTESIZE)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        DebugLog((DEB_TRACE_FUNC, "PrecalcDigestHash: Hash output buffer too small\n"));
        *piHashSize = MD5_HASH_BYTESIZE;   // return how many bytes are needed to write out value
    }

    // First check if OK to encode in ISO 8859-1, if not then use UTF-8
    // All characters must be within ISO 8859-1 Character set else fail

    if (pustrUsername && pustrUsername->Length && pustrUsername->Buffer)
    {
        fDefChars = FALSE;
        Status = EncodeUnicodeString(pustrUsername, CP_8859_1, &strUsername, &fDefChars);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding username\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
        if (fDefChars == TRUE)
        {
            DebugLog((DEB_TRACE, "PrecalcDigestHash: Can not encode Username in 8859-1, use UTF-8\n"));
            StringFree(&strUsername);
            Status = EncodeUnicodeString(pustrUsername, CP_UTF8, &strUsername, NULL);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding username\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
    }


    if (pustrRealm && pustrRealm->Length && pustrRealm->Buffer)
    {
        fDefChars = FALSE;
        Status = EncodeUnicodeString(pustrRealm, CP_8859_1, &strRealm, &fDefChars);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding realm\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
        if (fDefChars == TRUE)
        {
            DebugLog((DEB_TRACE, "PrecalcDigestHash: Can not encode realm in 8859-1, use UTF-8\n"));
            StringFree(&strRealm);
            Status = EncodeUnicodeString(pustrRealm, CP_UTF8, &strRealm, NULL);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "DigestCalcHA1: Error in encoding realm\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
    }


    if (pustrPassword && pustrPassword->Length && pustrPassword->Buffer)
    {
        fDefChars = FALSE;
        Status = EncodeUnicodeString(pustrPassword, CP_8859_1, &strPasswd, &fDefChars);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding passwd\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
        if (fDefChars == TRUE)
        {
            DebugLog((DEB_TRACE, "PrecalcDigestHash: Can not encode password in 8859-1, use UTF-8\n"));
            if (strPasswd.Buffer && strPasswd.MaximumLength)
            {
                SecureZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
            }
            StringFree(&strPasswd);
            Status = EncodeUnicodeString(pustrPassword, CP_UTF8, &strPasswd, NULL);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "PrecalcDigestHash: Error in encoding passwd\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto CleanUp;
            }
        }
    }

    Status = StringAllocate(&strHash, MD5_HASH_BYTESIZE);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "PrecalcDigestHash: No Memory\n"));
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto CleanUp;
    }

    // Use PasswdHash = H(username-value:realm-value:passwd)
    Status = DigestHash7(&strUsername,
                         &strRealm,
                         &strPasswd,
                         NULL, NULL, NULL, NULL,
                         FALSE, &strHash);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "PrecalcDigestHash: H(U:R:PW) failed : 0x%x\n", Status));
        goto CleanUp;
    }
    
#if DBG2
    {
        STRING strTempPwKey = {0};

        MyPrintBytes(strHash.Buffer, strHash.Length, &strTempPwKey);
        DebugLog((DEB_TRACE, "DigestCalcHA1: Binary H(%Z:%Z:************) is %Z\n",
                   &strUsername, &strRealm, &strTempPwKey));

        StringFree(&strTempPwKey);
    }
#endif

    memcpy(pHash, strHash.Buffer, MD5_HASH_BYTESIZE);
    *piHashSize = MD5_HASH_BYTESIZE;

CleanUp:

    if (Status == STATUS_UNMAPPABLE_CHARACTER)
    {
        // We were unable to make the mapping to the selected codepage
        // Case exists if inputs are unicode characters not contained in ISO 8859-1 and codepage is ISO 8859-1
        // Zero out the hash
        SecureZeroMemory(pHash, sizeof(MD5_HASH_BYTESIZE));
        *piHashSize = MD5_HASH_BYTESIZE;   // return how many bytes are needed to write out value
    }

    if (strPasswd.MaximumLength && strPasswd.Buffer)
    {
        // Make sure to erase any password info
        SecureZeroMemory(strPasswd.Buffer, strPasswd.MaximumLength);
    }

    StringFree(&strUsername);
    StringFree(&strRealm);
    StringFree(&strPasswd);
    StringFree(&strHash);

    DebugLog((DEB_TRACE_FUNC, "PrecalcDigestHash: Leaving  Status 0x%x\n", Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\ntdigest.cxx ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       ntdigest.c
//
// Contents:   main entrypoints for the digest security package
//               SpLsaModeInitialize
//               SpInitialize
//               SpShutdown
//               SpGetInfo
//
//             Helper functions:
//
// History:    KDamour  10Mar00   Stolen from msv_sspi\ntlm.cxx
//
//---------------------------------------------------------------------
#define NTDIGEST_GLOBAL
#include "global.h"

#if defined (_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201) // Disable warning/error for nameless struct/union
#endif

#include <wow64t.h>

#if defined (_MSC_VER) && ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)   // Disable warning/error for nameless struct/union
#endif
#endif
   
/* Debugging information setup */
DEFINE_DEBUG2(Digest);

DEBUG_KEY  MyDebugKeys[] = {{DEB_ERROR, "Error"},
    {DEB_WARN, "Warning"},
    {DEB_TRACE, "Trace"},
    {DEB_TRACE_ASC, "TraceASC"},
    {DEB_TRACE_ISC, "TraceISC"},
    {DEB_TRACE_LSA, "TraceLSA"},
    {DEB_TRACE_USER, "TraceUser"},
    {DEB_TRACE_FUNC, "TraceFuncs"},
    {DEB_TRACE_MEM, "TraceMem"},
    {TRACE_STUFF, "Stuff"},
    {0, NULL}
};

//   set to TRUE once initialized 
BOOL l_bDebugInitialized = FALSE;
BOOL l_bDigestInitialized = FALSE;

// Registry reading
HKEY   g_hkBase      = NULL;
HANDLE g_hParamEvent = NULL;
HANDLE g_hWait       = NULL;

#define COMPUTER_NAME_SIZE (MAX_COMPUTERNAME_LENGTH + 1)


#ifdef ROGUE_DC
HKEY g_hDigestRogueKey = NULL;
// Select same location as Kerberos
#define REG_DIGEST_ROGUE_BASE  L"System\\CurrentControlSet\\Services\\Kdc\\Rogue"
#endif



//+--------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   This function is called by the LSA when this DLL is loaded.
//              It returns security package function tables for all
//              security packages in the DLL.
//
//  Arguments:  LsaVersion - Version number of the LSA
//              PackageVersion - Returns version number of the package
//              Tables - Returns array of function tables for the package
//              TableCount - Returns number of entries in array of
//                      function tables.
//
//  Returns:    PackageVersion (as above)
//              Tables (as above)
//              TableCount (as above)
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    )
{
#if DBG
    DebugInitialize();
#endif

    DebugLog((DEB_TRACE_FUNC, "SpLsaModeInitialize: Entering\n"));


    SECURITY_STATUS Status = SEC_E_OK;

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR, "SpLsaModeInitialize: Invalid LSA version: %d\n", LsaVersion));
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    // Fill in the dispatch table for functions exported by ssp
    g_NtDigestFunctionTable.InitializePackage        = NULL;
    g_NtDigestFunctionTable.LogonUser                = NULL;
    g_NtDigestFunctionTable.CallPackage              = LsaApCallPackage;
    g_NtDigestFunctionTable.LogonTerminated          = LsaApLogonTerminated;
    g_NtDigestFunctionTable.CallPackageUntrusted     = LsaApCallPackageUntrusted;
    g_NtDigestFunctionTable.LogonUserEx              = NULL;
    g_NtDigestFunctionTable.LogonUserEx2             = LsaApLogonUserEx2;
    g_NtDigestFunctionTable.Initialize               = SpInitialize;
    g_NtDigestFunctionTable.Shutdown                 = SpShutdown;
    g_NtDigestFunctionTable.GetInfo                  = SpGetInfo;
    g_NtDigestFunctionTable.AcceptCredentials        = SpAcceptCredentials;
    g_NtDigestFunctionTable.AcquireCredentialsHandle = SpAcquireCredentialsHandle;
    g_NtDigestFunctionTable.FreeCredentialsHandle    = SpFreeCredentialsHandle;
    g_NtDigestFunctionTable.SaveCredentials          = SpSaveCredentials;
    g_NtDigestFunctionTable.GetCredentials           = SpGetCredentials;
    g_NtDigestFunctionTable.DeleteCredentials        = SpDeleteCredentials;
    g_NtDigestFunctionTable.InitLsaModeContext       = SpInitLsaModeContext;
    g_NtDigestFunctionTable.AcceptLsaModeContext     = SpAcceptLsaModeContext;
    g_NtDigestFunctionTable.DeleteContext            = SpDeleteContext;
    g_NtDigestFunctionTable.ApplyControlToken        = SpApplyControlToken;
    g_NtDigestFunctionTable.GetUserInfo              = SpGetUserInfo;
    g_NtDigestFunctionTable.QueryCredentialsAttributes = SpQueryCredentialsAttributes ;
    g_NtDigestFunctionTable.GetExtendedInformation   = SpGetExtendedInformation ;
    g_NtDigestFunctionTable.SetExtendedInformation   = SpSetExtendedInformation ;
    g_NtDigestFunctionTable.CallPackagePassthrough   = LsaApCallPackagePassthrough;


    *PackageVersion = SECPKG_INTERFACE_VERSION;
    *Tables = &g_NtDigestFunctionTable;
    *TableCount = 1;

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpLsaModeInitialize:Leaving\n"));

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Initializes the Security package
//
//  Arguments:  PackageId - Contains ID for this package assigned by LSA
//              Parameters - Contains machine-specific information
//              FunctionTable - Contains table of LSA helper routines
//
//  Returns: None
//
//  Notes: Everything that was done in LsaApInitializePackage
//         should be done here. Lsa assures us that only
//         one thread is executing this at a time. Don't
//         have to worry about concurrency problems.(BUGBUG verify)
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpInitialize(
    IN ULONG_PTR pPackageId,
    IN PSECPKG_PARAMETERS pParameters,
    IN PLSA_SECPKG_FUNCTION_TABLE pFunctionTable
    )
{

    SECURITY_STATUS Status = SEC_E_OK;
    NT_PRODUCT_TYPE NtProductType = NtProductWinNt;
    WCHAR wszComputerName[COMPUTER_NAME_SIZE];
    DWORD dwComputerNameLen = COMPUTER_NAME_SIZE;

    DebugLog((DEB_TRACE_FUNC, "SpInitialize: Entering\n"));

    // Indicate that we completed initialization
    ASSERT(l_bDigestInitialized == FALSE);   // never called more than once
    l_bDigestInitialized = TRUE;

    // Initialize global values
    ZeroMemory(&g_strNtDigestUTF8ServerRealm, sizeof(g_strNtDigestUTF8ServerRealm));
    ZeroMemory(&g_strNTDigestISO8859ServerRealm, sizeof(g_strNTDigestISO8859ServerRealm));


    // Define time for AcquirCredentialHandle
    // We really need this to be a day less than maxtime so when callers
    // of sspi convert to utc, they won't get time in the past.

    g_TimeForever.HighPart = 0x7FFFFFFF;
    g_TimeForever.LowPart  = 0xFFFFFFFF;

    //
    // All the following are global
    //

    g_NtDigestState                  = NtDigestLsaMode;   /* enum */
    g_NtDigestPackageId              = pPackageId;

    //
    // Save away the Lsa functions
    //

    g_LsaFunctions    = pFunctionTable;

    // Initialize access to Registry and read in the values
    NtDigestInitReadRegistry();


    //
    // Establish the packagename
    //
    RtlInitUnicodeString(
        &g_ustrNtDigestPackageName,
        WDIGEST_SP_NAME
        );


    // Set the WorkstationName
    if (!GetComputerNameExW(ComputerNameNetBIOS, wszComputerName, &dwComputerNameLen))
    {
        ZeroMemory(&g_ustrWorkstationName, sizeof(g_ustrWorkstationName));
        DebugLog((DEB_ERROR, "SpInitialize: Get ComputerName  error 0x%x\n", GetLastError()));
    }
    else
    {
        Status = UnicodeStringWCharDuplicate(&g_ustrWorkstationName, wszComputerName, 0);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitialize: ComputerName copy   status 0x%x\n", Status));
            goto CleanUp;
        }
    }


    // Need to initialize Crypto stuff and nonce creations
    Status = NonceInitialize();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from NonceInitialize   status 0x%x\n", Status));
        goto CleanUp;
    }


    //
    // Determine if this machine is running Windows NT or Lanman NT.
    //  LanMan NT runs on a domain controller.
    //

    if ( !RtlGetNtProductType( &NtProductType ) ) {
        //  Nt Product Type undefined - WinNt assumed
        NtProductType = NtProductWinNt;
    }

    if (NtProductType == NtProductLanManNt)
    {
        g_fDomainController = TRUE;              // Allow password checking only on DomainControllers
    }

    //
    // Save the Parameters info to a global struct
    //
    g_NtDigestSecPkg.MachineState = pParameters->MachineState;
    g_NtDigestSecPkg.SetupMode = pParameters->SetupMode;
    g_NtDigestSecPkg.Version = pParameters->Version;

    Status = UnicodeStringDuplicate(
                                 &g_NtDigestSecPkg.DnsDomainName,
                                 &(pParameters->DnsDomainName));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from UnicodeStringDuplicate    status 0x%x\n", Status));
        goto CleanUp;
    }

    Status = UnicodeStringDuplicate(
                                 &g_NtDigestSecPkg.DomainName,
                                 &(pParameters->DomainName));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from UnicodeStringDuplicate   status 0x%x\n", Status));
        goto CleanUp;
    }


    if (pParameters->DomainSid != NULL) {
        Status = SidDuplicate( &g_NtDigestSecPkg.DomainSid,
                                pParameters->DomainSid );
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "SpInitialize: Error from SidDuplicate   status 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else
        g_NtDigestSecPkg.DomainSid = NULL;

    DebugLog((DEB_TRACE, "SpInitialize: DNSDomain = %wZ, Domain = %wZ\n", &(g_NtDigestSecPkg.DnsDomainName),
               &(g_NtDigestSecPkg.DomainName)));


    // For server challenges, precalculate the UTF-8 and ISO versions of the realm

    Status = EncodeUnicodeString(&(g_NtDigestSecPkg.DnsDomainName), CP_8859_1, &g_strNTDigestISO8859ServerRealm, NULL);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "SpInitialize: Error in encoding domain in ISO-8859-1\n"));
        ZeroMemory(&g_strNTDigestISO8859ServerRealm, sizeof(STRING));
    }

    Status = EncodeUnicodeString(&(g_NtDigestSecPkg.DnsDomainName), CP_UTF8, &g_strNtDigestUTF8ServerRealm, NULL);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "SpInitialize: Error in encoding domain in UTF-8\n"));
        ZeroMemory(&g_strNtDigestUTF8ServerRealm, sizeof(STRING));
    }

    //
    // Initialize the digest token source
    //

    RtlCopyMemory(
        g_DigestSource.SourceName,
        NTDIGEST_TOKEN_NAME_A,
        sizeof(NTDIGEST_TOKEN_NAME_A)
        );

    NtAllocateLocallyUniqueId(&g_DigestSource.SourceIdentifier);


    //
    // Init the LogonSession stuff
    //
    Status = LogSessHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from LogSessHandlerInit   status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Init the Credential stuff
    //
    Status = CredHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from CredHandlerInit   status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Init the Context stuff
    //
    Status = CtxtHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInitialize: Error from ContextInitialize    status 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Read in the registry values for SSP configuration - in LSA space
    //
    SPLoadRegOptions();

CleanUp:

    if (!NT_SUCCESS (Status))
    {
        SPUnloadRegOptions();
        SpShutdown();
    }

    DebugLog((DEB_TRACE_FUNC, "SpInitialize: Leaving\n"));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   SpShutdown
//
//  Synopsis:   Exported function to shutdown the Security package.
//
//  Effects:    Forces the freeing of all credentials, contexts
//              and frees all global data
//
//  Arguments:  none
//
//  Returns:
//
//  Notes:      SEC_E_OK in all cases
//         Most of the stuff was taken from SspCommonShutdown()
//         from svcdlls\ntlmssp\common\initcomn.c
//
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpShutdown(
    VOID
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpShutdown: Entering\n"));

    // Need to identify how to shutdown without causing faults with
    // incoming messages

    DebugLog((DEB_TRACE_FUNC, "SpShutdown: Leaving\n"));

    return(SEC_E_OK);
}



//+--------------------------------------------------------------------
//
//  Function:   SpGetInfo
//
//  Synopsis:   Returns information about the package
//
//  Effects:    returns pointers to global data
//
//  Arguments:  PackageInfo - Receives security package information
//
//  Returns:    SEC_E_OK in all cases
//
//  Notes:      Pointers to constants ok. Lsa will copy the data
//              before sending it to someone else. This function required
//              to return SUCCESS for the package to stay loaded.
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
SpGetInfo(
    OUT PSecPkgInfo PackageInfo
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpGetInfo:  Entering\n"));

    PackageInfo->fCapabilities    = NTDIGEST_SP_CAPS;
    PackageInfo->wVersion         = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    PackageInfo->wRPCID           = RPC_C_AUTHN_DIGEST;
    PackageInfo->cbMaxToken       = NTDIGEST_SP_MAX_TOKEN_SIZE;
    PackageInfo->Name             = WDIGEST_SP_NAME;
    PackageInfo->Comment          = NTDIGEST_SP_COMMENT;

    DebugLog((DEB_TRACE_FUNC, "SpGetInfo: Leaving\n"));

    return(SEC_E_OK);
}

// Misc SECPKG Functions

NTSTATUS NTAPI
SpGetUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpGetUserInfo: Entering/Leaving\n"));

    // FIXIFX Fields of UserData are username, domain, server

    UNREFERENCED_PARAMETER(LogonId);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(UserData);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpGetExtendedInformation
//
//  Synopsis:   Return extended information to the LSA
//
//  Arguments:  [Class] -- Information Class
//              [pInfo] -- Returned Information Pointer
//
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
SpGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSECPKG_EXTENDED_INFORMATION Information = NULL;
    ULONG Size = 0;


    DebugLog((DEB_TRACE_FUNC, "SpGetExtendedInformation:  Entering\n"));

    switch ( Class )
    {

        case SecpkgWowClientDll:

            //
            // This indicates that we're smart enough to handle wow client processes
            //

            Information = (PSECPKG_EXTENDED_INFORMATION)
                                DigestAllocateMemory( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                              (MAX_PATH * sizeof(WCHAR) ) );

            if ( Information == NULL )
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DebugLog((DEB_ERROR, "SpGetExtendedInformation:  Allocate Memory failed\n"));
                goto Cleanup ;
            }

            Information->Class = SecpkgWowClientDll ;
            Information->Info.WowClientDll.WowClientDllPath.Buffer = (PWSTR) (Information + 1);
            Size = ExpandEnvironmentStrings(
                        L"%SystemRoot%\\" WOW64_SYSTEM_DIRECTORY_U L"\\" NTDIGEST_DLL_NAME,
                        Information->Info.WowClientDll.WowClientDllPath.Buffer,
                        MAX_PATH );
            if (Size == 0)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DebugLog((DEB_ERROR, "SpGetExtendedInformation:  ExpandEnvironmentStrings failed 0x%x\n", GetLastError()));
                goto Cleanup ;
            }
            Information->Info.WowClientDll.WowClientDllPath.Length = (USHORT) (Size * sizeof(WCHAR));
            Information->Info.WowClientDll.WowClientDllPath.MaximumLength = (USHORT) ((Size + 1) * sizeof(WCHAR) );
            *ppInformation = Information ;
            Information = NULL ;

            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
    }

Cleanup:

    if ( Information != NULL )
    {
        DigestFreeMemory( Information );
    }

    DebugLog((DEB_TRACE_FUNC, "SpGetExtendedInformation:  Leaving    Status 0x%x\n", Status));

    return Status ;
}



NTSTATUS NTAPI
SpSetExtendedInformation(
    IN SECPKG_EXTENDED_INFORMATION_CLASS Class,
    IN PSECPKG_EXTENDED_INFORMATION Info
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpSetExtendedInformation: Entering/Leaving \n"));

    UNREFERENCED_PARAMETER(Class);
    UNREFERENCED_PARAMETER(Info);
    return(SEC_E_UNSUPPORTED_FUNCTION) ;
}

//
// Registry Reading routines
//  This routine is called in single-threaded mode from the LSA for SpInitialize and SPInstanceInit
//  In user applications only SPInstanceInit calls this function
//
BOOL SPLoadRegOptions(void)
{
    if (NULL != g_hParamEvent)
    {
        // Already called - no need to re-execute
        DebugLog((DEB_TRACE, "SPLoadRegOptions: Already initialized - Leaving \n"));
        return TRUE;
    }

    g_hParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    DigestWatchParamKey(g_hParamEvent, FALSE);

    return TRUE;
}


void SPUnloadRegOptions(void)
{
    if (NULL != g_hWait) 
    {
        RtlDeregisterWaitEx(g_hWait, (HANDLE)-1);
        g_hWait = NULL;
    }

    if(NULL != g_hkBase)
    {
        RegCloseKey(g_hkBase);
        g_hkBase = NULL;
    }

    if(NULL != g_hParamEvent)
    {
        CloseHandle(g_hParamEvent);
        g_hParamEvent = NULL;
    }

}


// Helper function to read in a DWORD - sets value if not present in registry
void
ReadDwordRegistrySetting(
    HKEY    hReadKey,
    HKEY    hWriteKey,
    LPCTSTR pszValueName,
    DWORD * pdwValue,
    DWORD   dwDefaultValue)
{
    DWORD dwSize = 0;
    DWORD dwType = 0;

    dwSize = sizeof(DWORD);
    if(RegQueryValueEx(hReadKey, 
                       pszValueName, 
                       NULL, 
                       &dwType, 
                       (PUCHAR)pdwValue, 
                       &dwSize) != STATUS_SUCCESS)
    {
        *pdwValue = dwDefaultValue;

        if(hWriteKey)
        {
            RegSetValueEx(hWriteKey, 
                          pszValueName, 
                          0, 
                          REG_DWORD, 
                          (PUCHAR)pdwValue, 
                          sizeof(DWORD));
        }
    }
}


// Can be called at any time to change the default values
// As long as a DWORD assignment can be done in a single step
BOOL
NtDigestReadRegistry(BOOL fFirstTime)
{
    DWORD  dwVal = 0;

    HKEY        hWriteKey = 0;

    UNREFERENCED_PARAMETER(fFirstTime);

    // Open top-level key that has write access.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_DIGEST_BASE,
                    0,
                    KEY_READ | KEY_SET_VALUE,
                    &hWriteKey) != STATUS_SUCCESS)
    {
        hWriteKey = 0;
    }


    // "LifeTime"
    /*
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_LIFETIME,
        &g_dwParameter_Lifetime,
        PARAMETER_LIFETIME);
    */

    // "Negotiate" Supported - BOOL value
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_NEGOTIATE,
        &dwVal,
        PARAMETER_NEGOTIATE);
    if (dwVal)
        g_fParameter_Negotiate = TRUE;
    else
        g_fParameter_Negotiate = FALSE;

    // UTF8 Supported in HTTP mode - BOOL value
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_UTF8HTTP,
        &dwVal,
        PARAMETER_UTF8_HTTP);
    if (dwVal)
        g_fParameter_UTF8HTTP = TRUE;
    else
        g_fParameter_UTF8HTTP = FALSE;

    // UTF8 supported in SASL - BOOL value
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_UTF8SASL,
        &dwVal,
        PARAMETER_UTF8_SASL);
    if (dwVal)
        g_fParameter_UTF8SASL = TRUE;
    else
        g_fParameter_UTF8SASL = FALSE;

    // Read in ServerCompat bits
    ReadDwordRegistrySetting(
        g_hkBase,
        0,
        REG_DIGEST_OPT_SERVERCOMPAT,
        &g_dwParameter_ServerCompat,
        PARAMETER_SERVERCOMPAT);

    // Read in ServerCompat bits
    ReadDwordRegistrySetting(
        g_hkBase,
        0,
        REG_DIGEST_OPT_CLIENTCOMPAT,
        &g_dwParameter_ClientCompat,
        PARAMETER_CLIENTCOMPAT);

#if DBG
    // DebugLevel
    ReadDwordRegistrySetting(
        g_hkBase,
        hWriteKey,
        REG_DIGEST_OPT_DEBUGLEVEL,
        &dwVal,
        0);
    DigestInfoLevel = dwVal;   // Turn on/off selected messages

#endif

    if(hWriteKey)
    {
        RegCloseKey(hWriteKey);
        hWriteKey = 0;
    }

    DebugLog((DEB_TRACE, "NtDigestReadRegistry:  Lifetime %lu, Negotiate %d, UTF-8 HTTP %d, UTF-8 SASL %d, DebugLevel 0x%x\n",
              g_dwParameter_Lifetime,
              g_fParameter_Negotiate,
              g_fParameter_UTF8HTTP,
              g_fParameter_UTF8SASL,
              dwVal));

    return TRUE;
}

//  This routine is called in single-threaded mode from the LSA for SpLsaModeInitialize and SPInstanceInit
//  In user applications only SPInstanceInit calls this function
void
DebugInitialize(void)
{
#if DBG
    if (l_bDebugInitialized == TRUE)
    {
        return;
    }
    l_bDebugInitialized = TRUE;
    DigestInitDebug(MyDebugKeys);
    DigestInfoLevel = 0x0;             // Turn on OFF messages - Registry read will adjust which ones to keep on
#endif
    return;
}

////////////////////////////////////////////////////////////////////
//
//  Name:       DigestWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
DigestWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    LONG        lRes = ERROR_SUCCESS;
    BOOL        fFirstTime = FALSE;

    UNREFERENCED_PARAMETER(fWaitStatus);

    if(g_hkBase == NULL)
    {
        DebugLog((DEB_WARN,"Failed to open WDigest key access: 0x%x\n", Status));
        return;
    }

    if(pCtxt != NULL)
    {
        if (NULL != g_hWait) 
        {
            Status = RtlDeregisterWait(g_hWait);
            if(!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
                goto Reregister;
            }
        }

        lRes = RegNotifyChangeKeyValue(
                    g_hkBase,
                    TRUE,
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                    (HANDLE)pCtxt,
                    TRUE);

        if (ERROR_SUCCESS != lRes) 
        {
            DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
            // we're tanked now. No further notifications, so get this one
        }
    }

    NtDigestReadRegistry(fFirstTime);

Reregister:

    if(pCtxt != NULL)
    {
        Status = RtlRegisterWait(&g_hWait,
                                 (HANDLE)pCtxt,
                                 DigestWatchParamKey,
                                 (HANDLE)pCtxt,
                                 INFINITE,
                                 WT_EXECUTEINPERSISTENTIOTHREAD|
                                 WT_EXECUTEONLYONCE);
    }
}                       

// Initialize the handle to access registry and read in the current parameters
BOOL
NtDigestInitReadRegistry()
{
    LONG lRes = ERROR_SUCCESS;
    DWORD disp = 0;

    if(g_hkBase == NULL)
    {
        // First time we've been called.
        lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                REG_DIGEST_BASE,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &g_hkBase,
                                &disp);
        if(lRes)
        {
            DebugLog((DEB_WARN,"NtDigestInitReadRegistry: Failed to open WDigest key: 0x%x\n", lRes));
            return FALSE;
        }

        NtDigestReadRegistry(TRUE);
    }


#ifdef ROGUE_DC

    if(g_hDigestRogueKey == NULL)
    {
        if ( ERROR_SUCCESS != RegOpenKeyExW(
                                  HKEY_LOCAL_MACHINE,
                                  REG_DIGEST_ROGUE_BASE,
                                  0,
                                  KEY_READ,
                                  &g_hDigestRogueKey ))
        {
            DebugLog((DEB_WARN,"Failed to open \"rogue\" wdigest key\n" ));
            g_hDigestRogueKey = NULL;
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\nonce.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        nonce.cxx
//
// Contents:    Context APIs for the Digest security package
//              Main entry points into this dll:
//                NonceCreate
//                NonceValidate
//                NonceInitialize
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\ctxtapi.cxx
//              KDamour  16Mar00       Stolen from NTLM ctxtapi.cxx
//
//------------------------------------------------------------------------
#include <global.h>
#include <time.h>

// Hold the Hex representation plus the NULL
char g_cNoncePrivateKey[(2*NONCE_PRIVATE_KEY_BYTESIZE) + 1];


//
//  Globals
//

HCRYPTPROV g_hCryptProv = 0;             // Handle for CryptoAPI
WORD       g_SupportedCrypto = 0;        // Supported Crypt Functions bitmask (i.e. SUPPORT_DES)

//+--------------------------------------------------------------------
//
//  Function:   NonceInitialize
//
//  Synopsis:   This function is to be called
//
//  Arguments:  None
//
//  Returns:    
//
//  Notes:
//      CryptReleaseContext( g_hCryptProv, 0 ) to release the cypt context
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
NonceInitialize(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE abTemp[NONCE_PRIVATE_KEY_BYTESIZE];

    DebugLog((DEB_TRACE_FUNC, "NonceInitialize: Entering\n"));

    if (g_hCryptProv)
    {         // Catch cases where LSA and Usermode running in same addr space
        DebugLog((DEB_TRACE, "NonceInitialize: Already Inited Leaving\n"));
        return STATUS_SUCCESS;
    }

    //
    // Get a handle to the CSP we'll use for all our hash functions etc
    //
    if ( !CryptAcquireContext( &g_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        DebugLog((DEB_ERROR, "NonceInitialize:CryptCreateHash() failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return(Status);
    }


    //
    // Generate and copy over the random bytes
    //
    if ( !CryptGenRandom( g_hCryptProv,
                          NONCE_PRIVATE_KEY_BYTESIZE,
                          abTemp ) )
    {
        DebugLog((DEB_ERROR, "NonceInitialize:NonceInitialize CryptGenRandom() failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return (Status);
    }

    BinToHex((LPBYTE) abTemp, NONCE_PRIVATE_KEY_BYTESIZE, (LPSTR) g_cNoncePrivateKey);

    SetSupportedCrypto();
    

    DebugLog((DEB_TRACE_FUNC, "NonceInitialize:Leaving NonceInitialize\n"));

    return (Status);
}


//+--------------------------------------------------------------------
//
//  Function:   SetSupportedCrypto
//
//  Synopsis:   Set the bitmask for the supported crypto CSP installed
//
//  Arguments:   none
//
//  Returns:  STATUS_DATA_ERROR - error in reading CSP capabilities 
//            STATUS_SUCCESS - operation completed normally
//
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
SetSupportedCrypto(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    g_SupportedCrypto = SUPPORT_3DES | SUPPORT_DES | SUPPORT_RC4_40 | SUPPORT_RC4 | SUPPORT_RC4_56;

    // FIXFIX  use CryptGetProvParam to set to actual installed CSP

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   NonceCreate
//
//  Synopsis:   This function is to be called once during User Mode initialization
//
//  Arguments:   pczNonce - pointer to a STRING to fillin
//                      with a new nonce
//
//  Returns:  STATUS_DATA_ERROR - input NONCE not enough space 
//            STATUS_SUCCESS - operation completed normally
//
//  Notes:   Function will return error if Nonce UNICODE_STRING is not empty
//        NONCE FORMAT
//        rand-data = rand[16]
//        nonce_binary = time-stamp  rand-data H(time-stamp ":" rand-data ":" nonce_private_key)
//        nonce = hex(nonce_binary)
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
NonceCreate(
    IN OUT PSTRING pstrNonce 
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE  abRandomData[RANDDATA_BYTESIZE];
    char  acRandomHex[(2*RANDDATA_BYTESIZE) + 1];

    FILETIME tcurrent = {0};

    GetSystemTimeAsFileTime(&tcurrent);

    DebugLog((DEB_TRACE_FUNC, "NonceCreate: Entering\n"));

        // Check to make sure that there is enough space on ouput string
        // Need room for the Nonce and the NULL terminator
    if (!pstrNonce->Buffer)
    {
        Status = StringAllocate(pstrNonce, NONCE_SIZE);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NonceCreate: StringAllocate error 0x%x\n", Status));
            goto CleanUp;
        }

    }
    if (pstrNonce->MaximumLength < (NONCE_SIZE + 1))
    {
        DebugLog((DEB_ERROR, "NonceCreate: Input STRING too small\n"));
        Status = STATUS_BUFFER_TOO_SMALL;
        goto CleanUp;
    }


        // Copy over the current time
    BinToHex((LPBYTE)&tcurrent, sizeof(tcurrent), (LPSTR) pstrNonce->Buffer);


    //
    // Generate and copy over the random bytes
    //
    if ( !CryptGenRandom( g_hCryptProv,
                          RANDDATA_BYTESIZE,
                          abRandomData ) )
    {
        DebugLog((DEB_TRACE, "NonceCreate: CryptGenRandom() failed : 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return (Status);
    }

    //
    // Convert to ASCII, doubling the length, and add to nonce 
    //
    BinToHex( abRandomData, RANDDATA_BYTESIZE, acRandomHex);
    memcpy(pstrNonce->Buffer + NONCE_RANDDATA_LOC, acRandomHex, (2 * RANDDATA_BYTESIZE));

    //
    // Now calculate the Hash. It will be NULL terminated but STRING length does not include NULL
    //

    Status = NonceHash((LPBYTE) pstrNonce->Buffer, (2 * sizeof(time_t)),
                       (LPBYTE) acRandomHex, (2 * RANDDATA_BYTESIZE),
                       (LPBYTE) g_cNoncePrivateKey, (2 * NONCE_PRIVATE_KEY_BYTESIZE),
                       (LPBYTE) (pstrNonce->Buffer + NONCE_HASH_LOC));
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "NonceCreate: failed %d\n", Status));
        goto CleanUp;
    }

    pstrNonce->Length = NONCE_SIZE;
    
CleanUp:

    if (!NT_SUCCESS(Status))
    {
        pstrNonce->Length = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "NonceCreate: Leaving\n"));

    return (Status);
}

//+--------------------------------------------------------------------
//
//  Function:   NonceIsValid
//
//  Synopsis:   Called with a pointer to a Nonce and returns NTSTATUS  This is the
//     main function that checks for a valid nonce.
//
//  Arguments:  None
//
//  Returns:   NTSTATUS  STATUS_SUCCESS if NONCE generated locally and is valid  
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS
NonceIsValid(
    PSTRING pstrNonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "NonceIsValid: Entering\n"));

    // Check the size first
    if (pstrNonce->Length != NONCE_SIZE)
    {
        DebugLog((DEB_ERROR, "NonceIsValid: Incorrect size for the Nonce\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if (!pstrNonce->Buffer)
    {
        DebugLog((DEB_ERROR, "NonceIsValid: NULL pointer for the Nonce\n"));
        return STATUS_UNSUCCESSFUL;
    }
    
    if (NonceIsTampered(pstrNonce))
    {
        DebugLog((DEB_ERROR, "NonceIsValid: Nonce hash does not match\n"));
        return STATUS_UNSUCCESSFUL;
    }

    DebugLog((DEB_TRACE_FUNC, "NonceIsValid: Leaving\n"));

    return (Status);
}

/*++

Routine Description:

    Creates MD5 hash of input buffer

Arguments:

    pbData - data to hash
    cbData - size of data pointed to by pbData
    pbHash - buffer that receives hash; is assumed to be big enough to contain MD5 hash

Return Value:

    TRUE if successful, FALSE if not

--*/
BOOL HashData( BYTE *pbData,
               DWORD cbData,
               BYTE *pbHash )
{
    HCRYPTHASH hHash = NULL;

    DebugLog((DEB_TRACE_FUNC, "HashData: Entering\n"));

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "HashData: CryptCreateHash  failed : 0x%lx\n", GetLastError()));
        return FALSE;
    }

    if ( !CryptHashData( hHash,
                         pbData,
                         cbData,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "HashData: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        
        CryptDestroyHash( hHash );
        return FALSE;
    }

    DWORD cbHash = MD5_HASH_BYTESIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pbHash,
                             &cbHash,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "HashData: CryptCreateHash failed : 0x%lx\n", GetLastError()));

        CryptDestroyHash( hHash );
        return FALSE;
    }

    CryptDestroyHash( hHash );

    DebugLog((DEB_TRACE_FUNC, "HashData: Leaving\n"));
    return TRUE;
}


/*++

Routine Description:

    Creates MD5 hash of the Nonce values

Arguments:

    pbTime - pointer to char buffer encoded Time()
    cbTime - number of bytes in encoded Time() buffer to process
    pbRandom - pointer to char buffer encoded random sequence
    cbRandom - number of bytes in encoded random buffer to process
    pbTKey - pointer to char buffer encoded private key
    cbKey - number of bytes in encoded private key buffer to process
    pbHash - pointer to char buffer encoded Nonce Hash
    cbHash - number of bytes in encoded Time() buffer to process

Return Value:

    STATUS_SUCCESS - normal completion

--*/
NTSTATUS NTAPI
NonceHash( IN LPBYTE  pbTime,
           IN DWORD cbTime,
           IN LPBYTE  pbRandom,
           IN DWORD cbRandom,
           IN LPBYTE pbKey,
           IN DWORD cbKey,
           OUT LPBYTE pbHash)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    DWORD cbHash = MD5_HASH_BYTESIZE;    // Number of bytes for MD5 hash
    unsigned char abHashBin[MD5_HASH_BYTESIZE];
    char *pbSeparator = COLONSTR;

    DebugLog((DEB_TRACE_FUNC, "NonceHash: Entering\n"));

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         pbTime,
                         cbTime,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         (const unsigned char *)pbSeparator,
                         COLONSTR_LEN,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         pbRandom,
                         cbRandom,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         (const unsigned char *)pbSeparator,
                         COLONSTR_LEN,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         pbKey,
                         cbKey,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             abHashBin,
                             &cbHash,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "NonceHash: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

        // Now convert the Hash to hex
    BinToHex(abHashBin, MD5_HASH_BYTESIZE, (char *)pbHash);

CleanUp:
    if (hHash)
    {
        CryptDestroyHash( hHash );
        hHash = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "NonceHash: Leaving\n"));
    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   NonceIsTampered
//
//  Synopsis:   Check the hash matches for the Nonce
//
//  Arguments:  None
//
//  Returns:   TRUE/FALSE if Nonce hash fails check 
//
//  Notes:   Called from NonceIsValid
//
//---------------------------------------------------------------------
BOOL NonceIsTampered(PSTRING pstrNonce)
{
    BOOL bStatus = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    unsigned char abHashHex[(2*MD5_HASH_BYTESIZE) + 1];

    DebugLog((DEB_TRACE_FUNC, "NonceIsTampered:Entering \n"));

    Status = NonceHash((LPBYTE) (pstrNonce->Buffer + NONCE_TIME_LOC), (2 * sizeof(time_t)),
                       (LPBYTE) (pstrNonce->Buffer + NONCE_RANDDATA_LOC), (2 * RANDDATA_BYTESIZE),
                       (LPBYTE) g_cNoncePrivateKey, (2 * NONCE_PRIVATE_KEY_BYTESIZE),
                       (LPBYTE) abHashHex);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "NonceIsTampered: NonceHash has failed %d\n", Status));
        bStatus = TRUE;
        goto CleanUp;
    }

    if (memcmp(abHashHex, (pstrNonce->Buffer + NONCE_HASH_LOC), (2 * MD5_HASH_BYTESIZE)))
    {
        DebugLog((DEB_ERROR, "NonceIsTampered: memcmp failed\n"));
        bStatus = TRUE;
        goto CleanUp;
    }

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "NonceIsTampered: Leaving\n"));
    return bStatus;
}




//+--------------------------------------------------------------------
//
//  Function:   OpaqueCreate
//
//  Synopsis:  Creates an Opaque string composed of OPAQUE_SIZE of random data
//
//  Arguments:   pstrOpque - pointer to a STRING to fillin
//                      with a new opaque
//
//  Returns:  STATUS_DATA_ERROR - input NONCE not enough space 
//            STATUS_SUCCESS - operation completed normally
//
//  Notes:   Function will return error if Nonce STRING is not empty
//        OPAQUE FORMAT
//        opaque_binary = rand[OPAQUE_SIZE]
//        nonce = Hex(opaque_binary)
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
OpaqueCreate(
    IN OUT PSTRING pstrOpaque 
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BYTE  abRandomData[OPAQUE_RANDATA_SIZE];
    DebugLog((DEB_TRACE_FUNC, "OpaqueCreate: Entering\n"));

        // Check to make sure that there is enough space on ouput string
        // Need room for the Nonce and the NULL terminator
    if (!pstrOpaque->Buffer)
    {
        Status = StringAllocate(pstrOpaque, OPAQUE_SIZE);
        if (!NT_SUCCESS (Status))
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "OpaqueCreate: StringAllocate error 0x%x\n", Status));
            goto CleanUp;
        }
    }
    else if (pstrOpaque->MaximumLength < ((2 * OPAQUE_RANDATA_SIZE) + 1))
    {
        DebugLog((DEB_ERROR, "OpaqueCreate: Input STRING too small\n"));
        Status = STATUS_BUFFER_TOO_SMALL;
        goto CleanUp;
    }

    //
    // Generate and copy over the random bytes
    //
    if ( !CryptGenRandom( g_hCryptProv,
                          OPAQUE_RANDATA_SIZE,
                          abRandomData ) )
    {
        DebugLog((DEB_TRACE, "OpaqueCreate: CryptGenRandom() failed : 0x%lx\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        return (Status);
    }

    //
    // Convert to ASCII, doubling the length, and add to nonce 
    //
    BinToHex( abRandomData, OPAQUE_RANDATA_SIZE, pstrOpaque->Buffer);

    pstrOpaque->Length = (2 * OPAQUE_RANDATA_SIZE);
    
CleanUp:

    if (!NT_SUCCESS(Status))
    {
        pstrOpaque->Length = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "OpaqueCreate: Leaving\n"));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\parser.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        parser.cxx
//
// Contents:    Digest Access Parser for directives
//              Main entry points into this dll:
//                ParseForNames
//   Very primitive parser.  Most strings are quoted except for NC
//
// History:     KDamour 16Mar00   Based on IIS authfilt.cxx
//
//------------------------------------------------------------------------

#include <global.h>

// Local function prototypes

// Check for backslash character in a counted string of chars
BOOL CheckBSlashChar(
    IN PSTR pcStr,
    IN USHORT len);

// Helper function to DigestParser2
NTSTATUS DigestProcessEntry(
    IN PSTR pcBeginName,
    IN PSTR pcEndName,
    IN PSTR pcBeginValue,
    IN PSTR pcEndValue,
    IN PSTR *pNameTable,
    IN UINT cNameTable,
    IN BOOL fBSlashEncoded,
    OUT PDIGEST_PARAMETER pDigest);



    // Used by parser to find the keywords
    // Keep insync with enum MD5_AUTH_NAME
PSTR MD5_AUTH_NAMES[] = {
    "username",
    "realm",
    "nonce",
    "cnonce",
    "nc",
    "algorithm",
    "qop",
    "method",
    "uri",
    "response",
    "hentity",
    "authzid",
    "domain",
    "stale",
    "opaque",
    "maxbuf",
    "charset",
    "cipher",
    "digest-uri",
    "rspauth",
    "nextnonce"
    ""              // Not really needed
};



enum STATE_TYPE
{
    READY,
    DIRECTIVE,
    COMMAFIND,
    EQUALFIND,
    ASSIGNMENT,
    QUOTEDVALUE,
    VALUE,
    ENDING,
    PROCESS_ENTRY,
    FAILURE
};


//+--------------------------------------------------------------------
//
//  Function:   DigestParser2
//
//  Synopsis:  Parse list of name=value pairs for known names
//
//  Effects:  
//
//  Arguments:     pszStr - line to parse ( '\0' delimited - terminated)
//    pNameTable - table of known names
//    cNameTable - number of known names
//    pDigest - set all of the directives in pDigest->strParams[x}
//
//  Returns:  STATUS_SUCCESS if success, otherwise error
//
//  Notes:
//     Buffers are not wide Unicode!
//
//
//---------------------------------------------------------------------
NTSTATUS DigestParser2(
    PSecBuffer pInputBuf,
    PSTR *pNameTable,
    UINT cNameTable,
    OUT PDIGEST_PARAMETER pDigest
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSTR pcBeginName = NULL;
    PSTR pcEndName = NULL;
    PSTR pcBeginValue = NULL;
    PSTR pcEndValue = NULL;
    PSTR pcEndBuffer = NULL;    // End of buffer to prevent NC increment from going past end
    PSTR pcCurrent = NULL;
    STATE_TYPE parserstate = DIRECTIVE;
    BOOL fEscapedChar = FALSE;

    // Verify that buffer exists and is of type single byte characters (not Unicode)
    if (!pInputBuf || (pInputBuf->cbBuffer && !pInputBuf->pvBuffer) ||
        (PBUFFERTYPE(pInputBuf) != SECBUFFER_TOKEN))
    {                                                    
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestParser2: Incorrect digest buffer format    status 0x%x\n", Status));
        goto CleanUp;
    }

    if (!pInputBuf->cbBuffer)
    {
        return STATUS_SUCCESS;    // Nothing to process  happens with makesignature
    }

    pcEndBuffer = (char *)pInputBuf->pvBuffer + pInputBuf->cbBuffer;

    for (pcCurrent = (char *)pInputBuf->pvBuffer; pcCurrent < pcEndBuffer; pcCurrent++)
    {
        if (parserstate == FAILURE)
        {
            break;
        }
        if (*pcCurrent == CHAR_NULL)
        {   //  If we hit a premature End of String then Exit immediately from scan
            break;
        }
        if (parserstate == COMMAFIND)
        {
            if (isspace((int) (unsigned char)*pcCurrent))
            {
                continue;    // get next char within for loop
            }
            if (*pcCurrent == CHAR_COMMA)
            {
                pcBeginName = NULL;
                pcEndName = NULL;
                pcBeginValue = pcEndValue = NULL;
                parserstate = DIRECTIVE;
                continue;
            }
            else
            {
                DebugLog((DEB_ERROR, "DigestParser2: CommaFind bad char  0x%x\n", *pcCurrent));
                parserstate = FAILURE; // only leading spaces or a comma is expected
                continue;
            }
        }
        if (parserstate == DIRECTIVE)
        {
            if (*pcCurrent == CHAR_EQUAL)
            {
                parserstate = ASSIGNMENT;
                continue;
            }
            if (isspace((int) (unsigned char)*pcCurrent))
            {
                if (!pcBeginName)
                {
                    continue;    // leading space chars so get next char
                }
                else
                {
                    parserstate = EQUALFIND; // spaces are not allowed - directive is a single token
                    continue;
                }
            }
            if (!pcBeginName)
            {
                pcBeginName = pcCurrent;     // mnark begining of token
            }
            pcEndName = pcCurrent;
            continue;
        }
        if (parserstate == EQUALFIND)
        {
            if (isspace((int) (unsigned char)*pcCurrent))
            {
                continue;    // get next char within for loop
            }
            if (*pcCurrent == CHAR_EQUAL)
            {
                parserstate = ASSIGNMENT;
                continue;
            }
            else
            {
                parserstate = FAILURE; // only leading spaces or a equal is expected
                continue;
            }
        }
        if (parserstate == ASSIGNMENT)
        {
            if (*pcCurrent == CHAR_DQUOTE)
            {
                parserstate = QUOTEDVALUE;
                continue;
            }
            if (isspace((int) (unsigned char)*pcCurrent))
            {
                continue;    // get next char within for loop
            }
            pcBeginValue = pcCurrent;
            pcEndValue = pcCurrent;
            parserstate = VALUE;
            continue;
        }
        if (parserstate == QUOTEDVALUE)
        {
            if ((*pcCurrent == CHAR_BACKSLASH) && (fEscapedChar == FALSE))
            {
                // used to escape the following character
                fEscapedChar = TRUE;
                if (!pcBeginValue)
                {
                    pcBeginValue = pcCurrent;
                    pcEndValue = pcCurrent;
                    continue;
                }
                continue;
            }
            if ((*pcCurrent == CHAR_DQUOTE) && (fEscapedChar == FALSE))
            {
                Status = DigestProcessEntry(pcBeginName, pcEndName, pcBeginValue, pcEndValue,
                                            pNameTable, cNameTable, TRUE, pDigest);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestParser2: Failed to process directive    0x%x\n", Status));
                    goto CleanUp;
                }
                parserstate = COMMAFIND;   // start again statemachine
                continue;
            }
            fEscapedChar = FALSE;    // reset to not escaped state
            if (!pcBeginValue)
            {
                pcBeginValue = pcCurrent;
                pcEndValue = pcCurrent;
                continue;
            }
            pcEndValue = pcCurrent;
            continue;
        }
        if (parserstate == VALUE)
        {
            if (*pcCurrent == CHAR_COMMA)
            {
                Status = DigestProcessEntry(pcBeginName, pcEndName, pcBeginValue, pcEndValue,
                                            pNameTable, cNameTable, FALSE, pDigest);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestParser2: Failed to process directive    0x%x\n", Status));
                    goto CleanUp;
                }
                pcBeginName = NULL;
                pcEndName = NULL;
                pcBeginValue = pcEndValue = NULL;
                parserstate = DIRECTIVE;   // find separator if any
                continue;
            }
            // token ends on first white space
            if (isspace((int) (unsigned char)*pcCurrent))
            {
                Status = DigestProcessEntry(pcBeginName, pcEndName, pcBeginValue, pcEndValue,
                                            pNameTable, cNameTable, FALSE, pDigest);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestParser2: Failed to process directive    0x%x\n", Status));
                    goto CleanUp;
                }
                parserstate = COMMAFIND;   // find separator if any
                continue;
            }
            else
            {
                pcEndValue = pcCurrent;
            }
        }
    }

    if ((parserstate == FAILURE) || (parserstate == QUOTEDVALUE) ||
        (parserstate == ASSIGNMENT) || (parserstate == DIRECTIVE) ||
        (parserstate == EQUALFIND))
    {
        Status = SEC_E_ILLEGAL_MESSAGE;
        goto CleanUp;
    }

    // There might be a NULL terminated directive value to process
    if ((parserstate == VALUE))
    {
        Status = DigestProcessEntry(pcBeginName, pcEndName, pcBeginValue, pcEndValue,
                                    pNameTable, cNameTable, FALSE, pDigest);
    }


CleanUp:
    DebugLog((DEB_TRACE, "DigestParser: leaving status  0x%x\n", Status));
    return(Status);
}


NTSTATUS DigestProcessEntry(
    IN PSTR pcBeginName,
    IN PSTR pcEndName,
    IN PSTR pcBeginValue,
    IN PSTR pcEndValue,
    IN PSTR *pNameTable,
    IN UINT cNameTable,
    IN BOOL fBSlashEncoded,
    IN OUT PDIGEST_PARAMETER pDigest
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT  cbName = 0;
    USHORT  cbValue = 0;
    UINT iN = 0;
    BOOL fBSPresent = FALSE;
    PCHAR pcTemp = NULL;
    PSTR pcDst = NULL;
    PSTR pcLoc = NULL;
    USHORT iCnt = 0;

    // DebugLog((DEB_TRACE_FUNC, "DigestProcessEntry: Entering\n"));

    if (!pcBeginName || !pcEndName)
    {
        DebugLog((DEB_ERROR, "DigestProcessEntry: Badly formed directive\n"));
        return (STATUS_UNSUCCESSFUL);
    }
    cbName = (USHORT)(pcEndName - pcBeginName) + 1;

    if (pcBeginValue && pcEndValue)
    {
        cbValue = (USHORT)(pcEndValue - pcBeginValue) + 1;
    }
    else
        cbValue = 0;

    for ( iN = 0 ; iN < cNameTable ; ++iN )
    {
        if ( !_strnicmp( pNameTable[iN], pcBeginName, cbName ) )
        {
            // DebugLog((DEB_TRACE, "DigestParser: directive found\n"));
            break;
        }
    }

    if ( iN < cNameTable )   // We found a match!!!!!
    {
        if (iN == MD5_AUTH_DIGESTURI)
        {
            iN = MD5_AUTH_URI;          // Map SASL's "digest-uri" to "uri"
        }

        pDigest->usDirectiveCnt[iN] = pDigest->usDirectiveCnt[iN] + 1;   // indicate that directive was found

        if (cbValue)
        {
            // For space optimization, if not Backslash encoded then use orginal memory buffer
            //  To simply code, can removed all refernces and just use a copy of the original
            //  while removing the backslash characters
            if ((fBSlashEncoded == TRUE) &&
                ( !(pDigest->usFlags & FLAG_NOBS_DECODE)))
            {
                // quick search to see if there is a BackSlash character there
                fBSPresent = CheckBSlashChar(pcBeginValue, cbValue);
                if (fBSPresent == TRUE)
                {
                    pcDst = (PCHAR)DigestAllocateMemory(cbValue + 1);
                    if (!pcDst)
                    {
                        Status = SEC_E_INSUFFICIENT_MEMORY;
                        DebugLog((DEB_ERROR, "DigestProcessEntry: allocate error   0x%x\n", Status));
                        goto CleanUp;
                    }

                       // Now copy over the string removing and back slash encoding
                    pcLoc = pcBeginValue;
                    pcTemp = pcDst;
                    while (pcLoc <= pcEndValue)
                    {
                        if (*pcLoc == CHAR_BACKSLASH)
                        {
                            pcLoc++;   // eat the backslash

                            // Indicate possible broken BS encoding by client
                            // check only the username and look for any BS chars without BS BS pattern (proper encoding)
                            if ((iN == MD5_AUTH_USERNAME) && (*pcLoc != CHAR_BACKSLASH))
                            {
                                DebugLog((DEB_WARN, "DigestProcessEntry: possible broken BS encoding by client\n"));
                                pDigest->usFlags =  pDigest->usFlags | FLAG_BS_ENCODE_CLIENT_BROKEN;
                            }
                        }
                        *pcTemp++ = *pcLoc++;
                        iCnt++;
                    }
                      // give the memory to member structure
                      // clear out any previous memory alloc (if called on a retry)
                    StringFree(&(pDigest->strDirective[iN]));
                    pDigest->strDirective[iN].Buffer = pcDst;
                    pDigest->strDirective[iN].Length = iCnt;
                    pDigest->strDirective[iN].MaximumLength = cbValue+1;
                    pcDst = NULL;

                    pDigest->refstrParam[iN].Buffer = pDigest->strDirective[iN].Buffer;
                    pDigest->refstrParam[iN].Length = pDigest->strDirective[iN].Length;
                    pDigest->refstrParam[iN].MaximumLength = pDigest->strDirective[iN].MaximumLength;

                }
                else
                {
                    pDigest->refstrParam[iN].Buffer = pcBeginValue;
                    pDigest->refstrParam[iN].Length = cbValue;
                    pDigest->refstrParam[iN].MaximumLength = cbValue;
                }

            }
            else
            {
                pDigest->refstrParam[iN].Buffer = pcBeginValue;
                pDigest->refstrParam[iN].Length = cbValue;
                pDigest->refstrParam[iN].MaximumLength = cbValue;
            }
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE_FUNC, "DigestProcessEntry: Leaving    0x%x\n", Status));

    return(Status);
}


//+--------------------------------------------------------------------
//
//  Function:   CheckBSlashChar
//
//  Synopsis:  Search a string for a Back Slash character
//
//  Effects:
//
//  Arguments: 
//    pcStr - pointer to string of characters
//    len - number of characters to search
//
//  Returns:  TRUE if found, FALSE otherwise
//
//  Notes:
//
//
//---------------------------------------------------------------------
BOOL CheckBSlashChar(
    IN PSTR pcStr,
    IN USHORT len)
{
    BOOL fFound = FALSE;
    USHORT i = 0;

    for (i = 0; i < len; i++)
    {
        if (*pcStr++ == CHAR_BACKSLASH)
        {
            fFound = TRUE;
            break;
        }
    }

    return (fFound);
}

/*

//+--------------------------------------------------------------------
//
//  Function:   DigestTokenVerify
//
//  Synopsis:  Verify that a token conforms to RFC 2616 sect 2.2
//
//  Effects:
//
//  Arguments: 
//    pcBeginToken - character pointer to beginning of token
//    pcEndToken - character pointer to ending of token
//
//  Returns:  TRUE if conforms to token defination, FALSE otherwise
//
//  Notes:
//
//
//---------------------------------------------------------------------
BOOLEAN DigestTokenVerify(
    IN PSTR pcBeginToken,
    IN PSTR pcEndToken
    )
{
    BOOLEAN fToken = FALSE;
    USHORT  cbToken = 0;
    USHORT  cbValue = 0;
    USHORT iCnt = 0;

    if (!pcBeginName || !pcEndName)
    {
        DebugLog((DEB_ERROR, "DigestProcessEntry: Badly formed directive\n"));
        return FALSE;
    }
    cbToken = (USHORT)(pcEndName - pcBeginName) + 1;

    for (iCnt = 0; iCnt < cbToken; iCnt++)
    {

    }


CleanUp:

    return(Status);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\ntdigest.h ===
//+--------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:       ntdigest.h
//
// Contents:   some general defines for SSP NTDigest
//
//             Helper functions:
//
// History:    KDamour  10Mar00   Created
//
//---------------------------------------------------------------------

#ifndef NTDIGEST_NTDIGEST_H
#define NTDIGEST_NTDIGEST_H


#define NTDIGEST_TOKEN_NAME_A         "WDIGEST"
#define NTDIGEST_DLL_NAME             L"wdigest.dll"

#define NTDIGEST_SP_VERSION          1

//  Registry Information
#define REG_DIGEST_BASE     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\WDigest")

// Values
#define REG_DIGEST_OPT_LIFETIME  TEXT("Lifetime")
#define REG_DIGEST_OPT_EXPIRESLEEP  TEXT("Expiresleep")
#define REG_DIGEST_OPT_DELEGATION  TEXT("Delegation")
#define REG_DIGEST_OPT_NEGOTIATE  TEXT("Negotiate")
#define REG_DIGEST_OPT_DEBUGLEVEL  TEXT("Debuglevel")
#define REG_DIGEST_OPT_MAXCTXTCOUNT  TEXT("MaxContext")
#define REG_DIGEST_OPT_UTF8HTTP  TEXT("UTF8HTTP")     // allow UTF-8 encoding for HTTP mode
#define REG_DIGEST_OPT_UTF8SASL  TEXT("UTF8SASL")     // allow UTF-8 encoding for SASL mode
#define REG_DIGEST_OPT_SERVERCOMPAT  TEXT("ServerCompat")     // See ServerCompat*
#define REG_DIGEST_OPT_CLIENTCOMPAT  TEXT("ClientCompat")     // see ClientCompat*


//  Lifetime for a Nonce - 10 hours
#define PARAMETER_LIFETIME (36000)

#define SASL_MAX_DATA_BUFFER   65536

// Max number of context entries to keep before tossing out old ones
#define PARAMETER_MAXCTXTCOUNT  30000

//  BOOL is Delegation is allowed on machine - default is FALSE
#define PARAMETER_DELEGATION        FALSE

//  BOOL is Nego support is allowed on machine - default is FALSE
#define PARAMETER_NEGOTIATE         FALSE

// MILLISECONDS for Sleep for the garbage collector for expired context entries
// Every 15 minutes is a reasonable default 1000*60*15 = 
#define PARAMETER_EXPIRESLEEPINTERVAL 900000

// Boolean if challenges should be sent with UTF8 support 
#define PARAMETER_UTF8_HTTP          TRUE
#define PARAMETER_UTF8_SASL          TRUE

// ServerCompat bits
// SERVERCOMPAT_BS_ENCODE - should server retry for BS encoded broken clients
#define SERVERCOMPAT_BS_ENCODE       0x0000001          
// Select which bits of the ServerCompat want to have as default
#define PARAMETER_SERVERCOMPAT       (SERVERCOMPAT_BS_ENCODE)

// ClientCompat
// CLIENTCOMPAT_QQOP - HTTPmode should client qop be quoted
#define CLIENTCOMPAT_QQOP            0x0000001          
// Select which bits of the ClientCompat want to have as default
#define PARAMETER_CLIENTCOMPAT       (CLIENTCOMPAT_QQOP)

// Function Prototypes
void DebugInitialize(void);


VOID DigestWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);


BOOL NtDigestReadRegistry(
    BOOL fFirstTime);

BOOL NtDigestInitReadRegistry(void);

void ReadDwordRegistrySetting(
    HKEY    hReadKey,
    HKEY    hWriteKey,
    LPCTSTR pszValueName,
    DWORD * pdwValue,
    DWORD   dwDefaultValue);

void SPUnloadRegOptions(void);

BOOL SPLoadRegOptions(void);

// Some common max sizes
#define NTDIGEST_MAX_REALM_SIZE   256    // should be based on a NT domain size


#endif // NTDIGEST_NTGDIGEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\user.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        user.cxx
//
// Contents:    Context manipulation functions
//
//
// History:     KDamour  15Mar00   Derrived from NTLM context.cxx
//
//------------------------------------------------------------------------
#include "global.h"

// This list contains all of the User Contexts
LIST_ENTRY           l_UserCtxtList;

// Lock for access to UserCtxtList
RTL_CRITICAL_SECTION l_UserCtxtCritSect;


// Indicate if completed Initialization of Credential Handler
BOOL  g_bUserContextInitialized = FALSE;



//+--------------------------------------------------------------------
//
//  Function:   UserCtxtHandlerInit
//
//  Synopsis:   Initializes the context manager package
//
//  Arguments:  none
//
//  Returns: NTSTATUS
//
//  Notes: Called by SpInstanceInit
//
//---------------------------------------------------------------------
NTSTATUS
UserCtxtHandlerInit(VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize the Context list to be empty.
    //

    Status = RtlInitializeCriticalSection(&l_UserCtxtCritSect);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "UserCtxtHandlerInit: Failed to initialize critsec   0x%x\n", Status));
        goto CleanUp;
    }
    
    InitializeListHead( &l_UserCtxtList );


    // Simple variable test to make sure all initialized;
    g_bUserContextInitialized = TRUE;

CleanUp:

    return Status;
}


// Add a Context into the UserMode Context List
NTSTATUS
UserCtxtHandlerInsertCred(
    IN PDIGEST_USERCONTEXT  pUserContext
    )
{
    RtlEnterCriticalSection( &l_UserCtxtCritSect );
    DebugLog((DEB_TRACE, "UserCtxtHandlerRelease: (RefCount) linked 0x%x\n", pUserContext->LsaContext));
    InsertHeadList( &l_UserCtxtList, &pUserContext->Next );
    RtlLeaveCriticalSection( &l_UserCtxtCritSect );

    return STATUS_SUCCESS;
}


// Initialize a UserMode Context
NTSTATUS NTAPI
UserCtxtInit(
           PDIGEST_USERCONTEXT pContext
           )
{

    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "UserCtxtInit: Entering\n"));
    ASSERT(pContext);

    if (!pContext)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ZeroMemory(pContext, sizeof(DIGEST_USERCONTEXT));

    DebugLog((DEB_TRACE_FUNC, "UserCtxtInit: Leaving \n"));
    return Status;
}


// Once done with a context - release the resouces
NTSTATUS NTAPI
UserCtxtFree(
           IN PDIGEST_USERCONTEXT pContext
           )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    DebugLog((DEB_TRACE_FUNC, "UserCtxtFree: Entering  with LSA context 0x%x\n", pContext->LsaContext));
    ASSERT(pContext);
    ASSERT(pContext->lReferences == 0);
    ASSERT(pContext->lReferenceHandles == 0);

    if (!pContext)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (pContext->ClientTokenHandle)
    {
        NTSTATUS IgnoreStatus;
        IgnoreStatus = NtClose(pContext->ClientTokenHandle);
        // ASSERT (NT_SUCCESS (IgnoreStatus));
        if (!NT_SUCCESS(IgnoreStatus))
        {
            DebugLog((DEB_ERROR, "UserCtxtFree: Could not Close the TokenHandle!!!!\n"));
        }
        pContext->ClientTokenHandle = NULL;
    }

    if (pContext->hSealCryptKey)
    {
        CryptDestroyKey( pContext->hSealCryptKey );
        pContext->hSealCryptKey = NULL;
    }

    if (pContext->hUnsealCryptKey)
    {
        CryptDestroyKey( pContext->hUnsealCryptKey );
        pContext->hUnsealCryptKey = NULL;
    }

    StringFree(&(pContext->strSessionKey));
    UnicodeStringFree(&(pContext->ustrAccountName));

    //
    //  Values utilized in the Initial Digest Auth ChallResponse
    //  Can be utilized for defaults in future MakeSignature/VerifySignature
    //
    for (i=0; i < MD5_AUTH_LAST; i++)
    {
        StringFree(&(pContext->strParam[i]));
    }

    DigestFreeMemory(pContext);

    DebugLog((DEB_TRACE_FUNC, "UserCtxtFree: Leaving\n"));
    return Status;
}



/*++

Routine Description:

    This routine checks to see if the Context is for the specified
    Client Connection, and references the Context if it is valid.

    The caller may optionally request that the Context be
    removed from the list of valid Contexts - preventing future
    requests from finding this Context.

Arguments:

    ContextHandle - Points to the ContextHandle of the Context
        to be referenced.

    DerefContext - This boolean value indicates whether the caller
        wants the Context to be removed from the list
        of Contexts.  TRUE indicates the Context is to be removed.
        FALSE indicates the Context is not to be removed.


Return Value:

    NULL - the Context was not found.

    Otherwise - returns a pointer to the referenced Context.

--*/
NTSTATUS NTAPI
UserCtxtHandlerHandleToContext(
                              IN ULONG_PTR ContextHandle,
                              IN BOOLEAN fDerefContextHandle,
                              IN BOOLEAN fRefContextHandle,
                              OUT PDIGEST_USERCONTEXT *ppContext
                              )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry = NULL;
    PDIGEST_USERCONTEXT pContext = NULL;

    ASSERT(!(fDerefContextHandle & fRefContextHandle));    // should not ref and deref at same time

    DebugLog((DEB_TRACE_FUNC, "UserCtxtHandlerHandleToContext: Entering\n" ));


    //
    // Acquire exclusive access to the Context list
    //  For performance, this could be distributed into a set of CritSects for preventing contention
    //

    RtlEnterCriticalSection( &l_UserCtxtCritSect );

    //
    // Now walk the list of Contexts looking for a match.
    //

    for ( ListEntry = l_UserCtxtList.Flink;
        ListEntry != &l_UserCtxtList;
        ListEntry = ListEntry->Flink )
    {

        pContext = CONTAINING_RECORD( ListEntry, DIGEST_USERCONTEXT, Next );

        //
        // Found a match ... reference this Context
        // (if the Context is being removed, we would increment
        // and then decrement the reference, so don't bother doing
        // either - since they cancel each other out).
        //

        DebugLog((DEB_TRACE, "UserCtxtHandlerHandleToContext: Checking context %lx for userctxt %lx\n",
                  pContext->LsaContext, ContextHandle ));

        if (pContext->LsaContext != ContextHandle)
        {
            continue;
        }


        // Called to dereference an application SecurityContext Handle
        if (fDerefContextHandle)
        {
            if (pContext->lReferenceHandles > 0)
            {
                pContext->lReferenceHandles--;           // thread safe due to l_UserCtxtCritSect
            }
            else
            {
                DebugLog((DEB_ERROR, "UserCtxtHandlerHandleToContext: nonpositive App SecurityCtxt count  Context = 0x%x, References = %ld, ReferenceHandles = %ld\n",
                           pContext, pContext->lReferences, pContext->lReferenceHandles));
                Status =  STATUS_OBJECT_NAME_NOT_FOUND;
                *ppContext = NULL;
                goto CleanUp;
            }
        }

        // Called to add in a Reference an application SecurityContext Handle
        if (fRefContextHandle)
        {
            pContext->lReferenceHandles++;           // thread safe due to l_UserCtxtCritSect
        }

        DebugLog((DEB_TRACE, "UserCtxtHandlerHandleToContext: Context = 0x%x, References = %ld, ReferenceHandles = %ld\n",
                   pContext, pContext->lReferences, pContext->lReferenceHandles));

        pContext->lReferences++;     // reference counters are thread safe due to l_UserCtxtCritSect
        *ppContext = pContext;
        goto CleanUp;

    }

    //
    // No match found
    //

    DebugLog((DEB_WARN, "UserCtxtHandlerHandleToContext: Tried to reference unknown Context 0x%lx\n", ContextHandle ));
    Status =  STATUS_OBJECT_NAME_NOT_FOUND;
    *ppContext = NULL;

CleanUp:

    RtlLeaveCriticalSection( &l_UserCtxtCritSect );
    DebugLog((DEB_TRACE_FUNC, "UserCtxtHandlerHandleToContext: Leaving  Status 0x%x\n", Status ));

    return(Status);
}



// Check the Creation time with the Current time.
// If the difference is greater than the MAX allowed, Context is no longer valid
BOOL
UserCtxtHandlerTimeHasElapsed(
    PDIGEST_USERCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    return (FALSE);                         // no expiration at this time
}



//+--------------------------------------------------------------------
//
//  Function:   CtxtHandlerRelease
//
//  Synopsis:   Releases the Context by decreasing reference counter
//
//  Arguments:  pContext - pointer to credential to de-reference
//
//  Returns: NTSTATUS
//
//  Notes: Since multiple threads must wait for ownership
//   of a context, reference count must be either 0 (unused) or 1 (in process)
//
//---------------------------------------------------------------------
NTSTATUS
UserCtxtHandlerRelease(
    PDIGEST_USERCONTEXT pUserContext)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DebugLog((DEB_TRACE_FUNC, "UserCtxtHandlerRelease: Entering\n" ));
    
    ASSERT( pUserContext->lReferences > 0);

    //
    // Acquire exclusive access to the Context list
    //  For performance, this could be distributed into a set of CritSects for preventing contention
    //

    RtlEnterCriticalSection( &l_UserCtxtCritSect );

    pUserContext->lReferences--;

    DebugLog((DEB_TRACE, "UserCtxtHandlerRelease: UserContextInit Context 0x%x  references %ld\n",
               pUserContext->LsaContext, pUserContext->lReferences));

    //
    // If the count has dropped to zero for both application SecurityContext handles and internal SSP references
    // then delink from the list and free up context
    //

    if (!pUserContext->lReferences && !pUserContext->lReferenceHandles)
    {
        DebugLog((DEB_TRACE, "UserCtxtHandlerRelease: UserContextInit unlinked and freed  userContext 0x%x\n", pUserContext));
        RemoveEntryList( &pUserContext->Next );
        Status = UserCtxtFree(pUserContext);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "UserCtxtHandlerRelease: UserCtxtFree error 0x%x\n", Status));
        }
    }

    RtlLeaveCriticalSection( &l_UserCtxtCritSect );

    DebugLog((DEB_TRACE_FUNC, "UserCtxtHandlerRelease: Leaving  Status 0x%x\n", Status ));

    return(Status);
}


// Following functions make use of the lock for insuring single threaded operation


/*++

RoutineDescription:

    Creates a new DACL for the token granting the server and client
    all access to the token.

Arguments:

    Token - Handle to an impersonation token open for TOKEN_QUERY and
        WRITE_DAC

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - insufficient memory to complete
        the function.

    Errors from NtSetSecurityObject

--*/
NTSTATUS
SspCreateTokenDacl(
    HANDLE Token
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOKEN_USER ProcessTokenUser = NULL;
    PTOKEN_USER ThreadTokenUser = NULL;
    PTOKEN_USER ImpersonationTokenUser = NULL;
    HANDLE ProcessToken = NULL;
    HANDLE ImpersonationToken = NULL;
    BOOL fInsertImpersonatingUser = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG AclLength = 0;
    PACL NewDacl = NULL;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    BOOL fReleaseContextLock = FALSE;


    DebugLog((DEB_TRACE_FUNC, "SspCreateTokenDacl: Entering  Token is 0x%x\n", Token));

    //
    // Build the two well known sids we need.
    //

    if (g_NtDigestGlobalLocalSystemSid == NULL || g_NtDigestGlobalAliasAdminsSid == NULL ) {

        RtlEnterCriticalSection(&l_UserCtxtCritSect);
        fReleaseContextLock = TRUE;

        if (g_NtDigestGlobalLocalSystemSid == NULL)
        {
            PSID pLocalSidSystem = NULL;
            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init LocalSystem SID\n"));
            Status = RtlAllocateAndInitializeSid(
                        &NtAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0,0,0,0,0,0,0,
                        &pLocalSidSystem
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SspCreateTokenDacl: RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
                goto Cleanup;
            }
            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init LocalSystem SID  DONE\n"));
            g_NtDigestGlobalLocalSystemSid = pLocalSidSystem;
        }

        if (g_NtDigestGlobalAliasAdminsSid == NULL)
        {
            PSID pLocalSidAdmins = NULL;

            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init AliasAdmin SID\n"));
            Status = RtlAllocateAndInitializeSid(
                        &NtAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0,0,0,0,0,0,
                        &pLocalSidAdmins
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SspCreateTokenDacl, RtlAllocateAndInitializeSid returns 0x%lx\n", Status ));
                goto Cleanup;
            }

            DebugLog((DEB_TRACE, "SspCreateTokenDacl: Allocate and Init AliasAdmin SID  DONE\n"));
            g_NtDigestGlobalAliasAdminsSid = pLocalSidAdmins;
        }

        RtlLeaveCriticalSection(&l_UserCtxtCritSect);
        fReleaseContextLock = FALSE;
    }

    //
    // it's possible that the current thread is impersonating a user.
    // if that's the case, get it's token user, and revert to insure we
    // can open the process token.
    //

    Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_QUERY | TOKEN_IMPERSONATE,
                            TRUE,
                            &ImpersonationToken
                            );

    if( NT_SUCCESS(Status) )
    {
        //
        // stop impersonating.
        //

        RevertToSelf();

        //
        // get the token user for the impersonating user.
        //
        Status = SspGetTokenUser(
                    ImpersonationToken,
                    &ImpersonationTokenUser
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SspCreateTokenDacl: SspGetTokenUser (1) returns 0x%lx\n", Status ));
            goto Cleanup;
        }
    }

    //
    // Open the process token to find out the user sid
    //

    Status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY,
                &ProcessToken
                );

    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: NtOpenProcessToken returns 0x%lx\n", Status ));
        goto Cleanup;
    }

    //
    // get the token user for the process token.
    //
    Status = SspGetTokenUser(
                ProcessToken,
                &ProcessTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: SspGetTokenUser (2) returns 0x%lx\n", Status ));
        goto Cleanup;
    }


    //
    // Now get the token user for the thread.
    //
    Status = SspGetTokenUser(
                Token,
                &ThreadTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: SspGetTokenUser (3) returns 0x%lx\n", Status ));
        goto Cleanup;
    }


    AclLength = 4 * sizeof( ACCESS_ALLOWED_ACE ) - 4 * sizeof( ULONG ) +
                RtlLengthSid( ProcessTokenUser->User.Sid ) +
                RtlLengthSid( ThreadTokenUser->User.Sid ) +
                RtlLengthSid( g_NtDigestGlobalLocalSystemSid ) +
                RtlLengthSid( g_NtDigestGlobalAliasAdminsSid ) +
                sizeof( ACL );

    //
    // determine if we need to add impersonation token sid onto the token Dacl.
    //

    if( ImpersonationTokenUser &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ProcessTokenUser->User.Sid ) &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ThreadTokenUser->User.Sid )
        )
    {
        AclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof( ULONG )) +
                RtlLengthSid( ImpersonationTokenUser->User.Sid );

        fInsertImpersonatingUser = TRUE;
    }


    NewDacl = (PACL)DigestAllocateMemory(AclLength );

    if (NewDacl == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "SspCreateTokenDacl: NtLmallocate returns 0x%lx\n", NewDacl));
        goto Cleanup;
    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    ASSERT(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ProcessTokenUser->User.Sid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ThreadTokenUser->User.Sid
                 );
    ASSERT( NT_SUCCESS( Status ));

    if( fInsertImpersonatingUser )
    {
        Status = RtlAddAccessAllowedAce (
                     NewDacl,
                     ACL_REVISION2,
                     TOKEN_ALL_ACCESS,
                     ImpersonationTokenUser->User.Sid
                     );
        ASSERT( NT_SUCCESS( Status ));
    }

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 g_NtDigestGlobalAliasAdminsSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 g_NtDigestGlobalLocalSystemSid
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    ASSERT( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = NtSetSecurityObject(
                 Token,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    ASSERT( NT_SUCCESS( Status ));


Cleanup:

    if( fReleaseContextLock )
        RtlLeaveCriticalSection(&l_UserCtxtCritSect);

    if (ImpersonationToken != NULL)
    {
        //
        // put the thread token back if we were impersonating.
        //

        (void)SetThreadToken( NULL, ImpersonationToken );
        NtClose(ImpersonationToken);
    }

    if (ThreadTokenUser != NULL) {
        DigestFreeMemory( ThreadTokenUser );
    }

    if (ProcessTokenUser != NULL) {
        DigestFreeMemory( ProcessTokenUser );
    }

    if (ImpersonationTokenUser != NULL) {

        DigestFreeMemory( ImpersonationTokenUser );
    }

    if (NewDacl != NULL) {
        DigestFreeMemory( NewDacl );
    }

    if (ProcessToken != NULL)
    {
        NtClose(ProcessToken);
    }

    DebugLog((DEB_TRACE_FUNC, "SspCreateTokenDacl: Leaving  Token is 0x%x\n", Token));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\user.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        user.h
//
// Contents:    declarations, constants for UserMode context manager
//
//
// History:     KDamour  13Apr00   Created
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_USER_H
#define NTDIGEST_USER_H

#include "nonce.h"

#define DES_BLOCKSIZE 8
#define RC4_BLOCKSIZE 1

// For import of plain text keys
typedef struct _PLAINTEXTBLOB
{
  BLOBHEADER Blob;
  DWORD      dwKeyLen;
  CHAR       bKey[MD5_HASH_BYTESIZE];
} PLAINTEXTBLOB;

// Initializes the context manager package 
NTSTATUS UserCtxtHandlerInit(VOID);

// Add a Context into the Cntext List
NTSTATUS UserCtxtHandlerInsertCred(IN PDIGEST_USERCONTEXT  pDigestCtxt);

// Initialize all the struct elements in a Context
NTSTATUS NTAPI UserCtxtInit(IN PDIGEST_USERCONTEXT pContext);

// Release memory utilized by the Context
NTSTATUS NTAPI UserCtxtFree(IN PDIGEST_USERCONTEXT pContext);

// Find the security context by the security context handle
NTSTATUS NTAPI
UserCtxtHandlerHandleToContext(
                              IN ULONG_PTR ContextHandle,
                              IN BOOLEAN fDerefContextHandle,
                              IN BOOLEAN fRefContextHandle,
                              OUT PDIGEST_USERCONTEXT *ppContext
                              );

// Releases the Context by decreasing reference counter
NTSTATUS UserCtxtHandlerRelease(PDIGEST_USERCONTEXT pContext);

// Check to see if Context is within valid lifetime
BOOL UserCtxtHandlerTimeHasElapsed(PDIGEST_USERCONTEXT pContext);

// Creates a new DACL for the token granting the server and client
NTSTATUS SspCreateTokenDacl(HANDLE Token);

// From userapi.cxx

// SECURITY_STATUS SEC_ENTRY FreeContextBuffer(void SEC_FAR *  pvContextBuffer);

NTSTATUS SspGetTokenUser(HANDLE Token, PTOKEN_USER * pTokenUser);

// Create a local context for a real context
NTSTATUS SspMapDigestContext(IN PDIGEST_CONTEXT pLsaContext,
                             IN PDIGEST_PARAMETER pDigest,
                             IN ULONG ulFlagOptions,
                             OUT PSecBuffer  ContextData);

NTSTATUS NTAPI DigestUserProcessParameters(
                       IN OUT PDIGEST_USERCONTEXT pContext,
                       IN PDIGEST_PARAMETER pDigest,
                       OUT PSecBuffer pFirstOutputToken);


NTSTATUS NTAPI DigestUserHTTPHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN eSignSealOp Op,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserSignHelperMulti(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserSealHelperMulti(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserUnsealHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

NTSTATUS NTAPI DigestUserVerifyHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pMessage,
                        IN ULONG MessageSeqNo
                        );

// Unpack the context from LSA mode into the User mode Context
NTSTATUS DigestUnpackContext(
    IN PDIGEST_PACKED_USERCONTEXT pPackedUserContext,
    OUT PDIGEST_USERCONTEXT pContext);

// Printout the fields present in usercontext pContext
NTSTATUS UserContextPrint(PDIGEST_USERCONTEXT pContext);

// Create a symmetric key with a given cleartext shared secret
NTSTATUS SEC_ENTRY CreateSymmetricKey(
    IN ALG_ID     Algid,
    IN DWORD      cbKey,
    IN UCHAR      *pbKey,
    IN UCHAR      *pbIV,
    OUT HCRYPTKEY *phKey
    );

NTSTATUS SEC_ENTRY EncryptData2Multi(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbBlocklength,
    IN PSecBufferDesc pSecBuff,
    IN ULONG      cbSignature,
    IN OUT UCHAR  *pbSignature
    );

NTSTATUS SEC_ENTRY LinkBuffersToEncrypt(
    IN HCRYPTKEY  hKey,
    IN ULONG cbBlocklength,
    IN PSecBufferDesc pSecBuff,
    IN OUT PULONG pulIndex,
    IN OUT PULONG pcbDataBytesUsed,
    IN PUCHAR pbSignature,
    IN ULONG  cbSignature
    );

NTSTATUS SEC_ENTRY DecryptData(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbData,
    IN OUT UCHAR  *pbData
    );

// Calculate the HMAC block for SASL messaging
NTSTATUS
SEC_ENTRY
CalculateSASLHMAC(
    IN PDIGEST_USERCONTEXT pContext,
    IN BOOL  fSign,
    IN PSTRING pstrSignKeyConst,
    IN DWORD dwSeqNum,
    IN PBYTE pdata,                        // location of data to HMAC
    IN ULONG cbdata,                       // How many bytes of data to process
    OUT PSASL_MAC_BLOCK pMacBlock
    );

// Calculate the HMAC block for SASL messaging (multiData SecBuffer)
NTSTATUS
SEC_ENTRY
CalculateSASLHMACMulti(
    IN PDIGEST_USERCONTEXT pContext,
    IN BOOL  fSign,
    IN PSTRING pstrSignKeyConst,
    IN DWORD dwSeqNum,
    IN PSecBufferDesc pSecBuff,            // location of data buffers to HMAC
    OUT PSASL_MAC_BLOCK pMacBlock
    );

// For encrypt (seal)/ decrypt (unseal) calculate the value of Kc RFC 2831 sect 2.4
NTSTATUS
SEC_ENTRY
CalculateKc(
    IN PBYTE pbSessionKey,
    IN USHORT cbHA1n,
    IN PSTRING pstrSealKeyConst,
    IN PBYTE pHashData
    );

void
SetDESParity(
        PBYTE           pbKey,
        DWORD           cbKey
        );

NTSTATUS
AddDESParity(
    IN PBYTE           pbSrcKey,
    IN DWORD           cbSrcKey,
    OUT PBYTE          pbDstKey,
    OUT PDWORD         pcbDstKey
    );


NTSTATUS
CalculateDataCount(
         IN PSecBufferDesc pSecBuff,
         OUT PULONG pulData
                        );

NTSTATUS
SEC_ENTRY
DigestUserCompareDirectives(
    IN PDIGEST_USERCONTEXT pContext,
    IN PDIGEST_PARAMETER pDigest
    );


#endif  // DIGEST_USER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\userapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to the NtDigest security package
//
//              Main user mode entry points into this dll:
//                SpUserModeInitialize
//                SpInstanceInit
//                SpDeleteUserModeContext
//                SpInitUserModeContext
//                SpMakeSignature
//                SpVerifySignature
//                SpSealMessage
//                SpUnsealMessage
//                SpGetContextToken
//                SpQueryContextAttributes
//                SpCompleteAuthToken
//                SpFormatCredentials
//                SpMarshallSupplementalCreds
//                SpExportSecurityContext
//                SpImportSecurityContext
//
//              Helper functions:
//                SspCreateTokenDacl
//                SspMapContext (this is called in Lsa mode)
//
// History:     ChandanS 26-Jul-1996   Stolen from kerberos\client2\userapi.cxx
//              KDamour  18Mar00       Stolen from NTLM userapi.cxx
//
//------------------------------------------------------------------------

//
//  This area is still under determination as to support for userlevel functions
//

#include "global.h"
#include <stdio.h>         // For sprintf

#if (DBG | DBG2)
#define TEMPSIZE 4000
#endif

// Winsock-ish host/network byte order converters for short and long integers.
//
#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

#define htonl(x)        ((((x) >> 24) & 0x000000FFL) | \
                        (((x) >>  8) & 0x0000FF00L) | \
                        (((x) <<  8) & 0x00FF0000L) | \
                        (((x) << 24) & 0xFF000000L))



//+-------------------------------------------------------------------------
//
//  Function:   SpUserModeInitialize
//
//  Synopsis:   Initialize an the Digest DLL in a client's
//              address space also called in LSA
//
//  Effects:
//
//  Arguments:  LsaVersion - Version of the security dll loading the package
//              PackageVersion - Version of the Digest package
//              UserFunctionTable - Receives a copy of Digests's user mode
//                  function table
//              pcTables - Receives count of tables returned.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS  - normal completion
//              STATUS_INVALID_PARAMETER - LsaVersion specified is incorrect
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables
    )
{
#if DBG
    DebugInitialize();
#endif

    DebugLog((DEB_TRACE_FUNC, "SpUserModeInitialize: Entering\n" ));

    NTSTATUS Status = STATUS_SUCCESS;

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION;

    g_NtDigestUserFuncTable.InstanceInit          = SpInstanceInit;
    g_NtDigestUserFuncTable.MakeSignature         = SpMakeSignature;
    g_NtDigestUserFuncTable.VerifySignature       = SpVerifySignature;
    g_NtDigestUserFuncTable.SealMessage           = SpSealMessage;
    g_NtDigestUserFuncTable.UnsealMessage         = SpUnsealMessage;
    g_NtDigestUserFuncTable.GetContextToken       = SpGetContextToken;
    g_NtDigestUserFuncTable.QueryContextAttributes = SpQueryContextAttributes;
    g_NtDigestUserFuncTable.CompleteAuthToken     = SpCompleteAuthToken;
    g_NtDigestUserFuncTable.InitUserModeContext   = SpInitUserModeContext;
    g_NtDigestUserFuncTable.DeleteUserModeContext = SpDeleteUserModeContext;
    g_NtDigestUserFuncTable.FormatCredentials     = SpFormatCredentials;
    g_NtDigestUserFuncTable.MarshallSupplementalCreds = SpMarshallSupplementalCreds;
    g_NtDigestUserFuncTable.ExportContext         = SpExportSecurityContext;
    g_NtDigestUserFuncTable.ImportContext         = SpImportSecurityContext;

    *UserFunctionTable = &g_NtDigestUserFuncTable;
    *pcTables = 1;

CleanUp:
    DebugLog((DEB_TRACE_FUNC, "SpUserModeInitialize: Leaving    Status 0x%x\n", Status));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   SpInstanceInit
//
//  Synopsis:   Initialize an instance of the NtDigest package in a client's
//              address space. Also called once in LSA
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//                         and it is Unused and Un-initialized
//              FunctionTable - Contains helper routines for use by NtDigest
//                         and it is fixed static
//              UserFunctions - Receives a copy of NtDigest's user mode
//                  function table - NOPE - has No information at all
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpInstanceInit: Entering\n" ));
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(UserFunctionTable);
    UNREFERENCED_PARAMETER(Version);

    // Save the Alloc/Free functions
    // Check if called in LSA or from Usermode - LSA calls SPInitialize then SPInstanceInit

    if (g_NtDigestState != NtDigestLsaMode)
    {
        g_NtDigestState = NtDigestUserMode;   // indicate in user address space
    }
    g_UserFunctions = DllFunctionTable;

    //  Initialize reading of registry and load in values
    NtDigestInitReadRegistry();

    // Need to initialize Crypto stuff and nonce creations
    Status = NonceInitialize();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInstanceInit: Error from NonceInitialize is %d\n", Status));
        goto CleanUp;
    }

    //
    // Init the UserMode Context stuff
    //
    Status = UserCtxtHandlerInit();
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "SpInstanceInit: Error from UserCtxtHandlerInit 0x%x\n", Status));
        goto CleanUp;
    }

    //
    // Read in the registry values for SSP configuration - in user mode space
    //
    SPLoadRegOptions();

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpInstanceInit: Leaving    Status = 0x%lx\n", Status ));
    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//        If this is an exported context, send a flag back to the LSA so that
//        Lsa does not call the SecpDeleteSecurityContext in the lsa process
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN ULONG_PTR ContextHandle
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpDeleteUserModeContext: Entering   ContextHandle 0x%lx\n", ContextHandle ));
    PDIGEST_USERCONTEXT pUserContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Find the currently existing user context and dereference the app SecurityContext Handle
    //
    Status = UserCtxtHandlerHandleToContext(ContextHandle, TRUE, FALSE, &pUserContext);
    if (!NT_SUCCESS(Status))
    {
        //
        // pContext is legally NULL when we are dealing with an incomplete
        // context.  This can often be the case when the second call to
        // InitializeSecurityContext() fails.
        //
        ///        Status = STATUS_INVALID_HANDLE;
        Status = STATUS_SUCCESS;
        DebugLog((DEB_WARN, "SpDeleteUserModeContext: UserCtxtHandlerHandleToContext not found 0x%x\n", Status ));
        goto CleanUp;
    }

    Status = UserCtxtHandlerRelease(pUserContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpDeleteUserModeContext: UserCtxtHandlerRelease error  Status 0x%x\n", Status ));
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SpDeleteUserModeContext: Leaving ContextHandle 0x%lx    status 0x%x\n",
               ContextHandle, Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates/updates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:     This function is called from ISC() or ASC() when there is Context
//    data to map over to Usermode Application space.  This context might be a partial
//    context (which is not valid until fully auth'ed) or an update to indicate
//    that ASC() has provided the application with a re-connect (so you just increment the
//    ref count on the context if it already exists)
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN ULONG_PTR ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusSub = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    PDIGEST_USERCONTEXT pContextSearch = NULL;
    PDIGEST_PACKED_USERCONTEXT pPackedUserContext = NULL;
    BOOLEAN fRefCount = FALSE;

    DebugLog((DEB_TRACE_FUNC, "SpInitUserModeContext: Entering  ContextHandle 0x%lx\n", ContextHandle ));
    
    ASSERT(PackedContext);


    // If Marshalled data is too small for holding a Client Context - reject it
    if (PackedContext->cbBuffer < sizeof(DIGEST_PACKED_USERCONTEXT))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "SpInitUserModeContext:  ContextData size < DIGEST_PACKED_USERCONTEXT\n" ));
        goto CleanUp;
    }

    pPackedUserContext = (PDIGEST_PACKED_USERCONTEXT) DigestAllocateMemory(PackedContext->cbBuffer);
    if (!pPackedUserContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "SpInitUserModeContext: DigestAllocateMemory for Packed Copy returns NULL\n" ));
        goto CleanUp;
    }

    // Copy the Packed User Context from LSA to local memory so it wil be long word aligned
    memcpy(pPackedUserContext, PackedContext->pvBuffer, PackedContext->cbBuffer);

    DebugLog((DEB_TRACE, "SpInitUserModeContext: FlagOptions 0x%x\n", pPackedUserContext->ulFlags));

    // Check to see if Context should be refcounted.  With session reconnect - this will be set
    // since a new SecurityContext Handle will be returned from ASC().  If an OldSecurityContextHandle
    // is passed into ASC() then this will not be set
    if (pPackedUserContext->ulFlags & FLAG_CONTEXT_REFCOUNT)
    {
        fRefCount = TRUE;
        DebugLog((DEB_TRACE, "SpInitUserModeContext: RefCounting Context\n"));
    }

    // Check to see if this is an update of reference count or add new context
    // If the context is found, increment the application SecurityContext Handle ref count
    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, fRefCount, &pContextSearch);
    if (NT_SUCCESS(Status))
    {
        // Found the app user SecurityContext - just update as needed
        // Most of the calls from ASC() will be to update and complete a partial context here
        // Some will be for a simple ref-count on a reconnect as called with ASC() return SEC_I_COMPLETE_NEEDED
        // No need to release the pContextSearch since in both cases we want to increment ref count from ASC() call

        DebugLog((DEB_TRACE, "SpInitUserModeContext: Found UserContext - update and ref count\n"));

        if (pContextSearch->ulFlags & FLAG_CONTEXT_PARTIAL)
        {
            // update the context as it is only a initial partial context and not used yet
            Status = DigestUnpackContext(pPackedUserContext, pContextSearch);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "SpInitUserModeContext: DigestUnpackContext for update context error 0x%x\n", Status));
                goto CleanUp;
            }

            UserContextPrint(pContextSearch);
        }

    }
    else if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        DebugLog((DEB_TRACE, "SpInitUserModeContext: UserContextInit creating 0x%x\n", pContext));

        // Now we will unpack this transfered LSA context into UserMode space Context List
        pContext = (PDIGEST_USERCONTEXT) DigestAllocateMemory( sizeof(DIGEST_USERCONTEXT) );
        if (!pContext)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "SpInitUserModeContext: DigestAllocateMemory returns NULL\n" ));
            goto CleanUp;
        }

        Status = UserCtxtInit(pContext);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitUserModeContext: UserContextInit error 0x%x\n", Status));
            goto CleanUp;
        }

        // Store the location of the context in the LSA
        pContext->LsaContext =  ContextHandle;
        pContext->ulNC = 1;                    // Force to one to account for ISC/ASC first message verify
        pContext->lReferenceHandles = 1;       // Indicate that a handle has been given to the application

        Status = DigestUnpackContext(pPackedUserContext, pContext);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitUserModeContext: DigestUnpackContext for new context error 0x%x\n", Status));
            goto CleanUp;
        }

        UserContextPrint(pContext);

        // App SecurityContext not located - add in a new one for this call
        Status = UserCtxtHandlerInsertCred(pContext);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "SpInitUserModeContext: UserCtxtHandlerInsertCred error  status 0x%x\n", Status));
            goto CleanUp;
        }

        pContext = NULL;   // turned memory over to CtxtHandler

        DebugLog((DEB_TRACE, "SpInitUserModeContext: (RefCount) created & listed 0x%x\n", pContext));
    }
    else
    {
        Status = StatusSub;
        DebugLog((DEB_ERROR, "SpInitUserModeContext: Could not find UserContextHandle  Status 0x%x\n", Status));
        goto CleanUp;
    }


CleanUp:

    if (pContext)
    {
        // Release the User context on error if allocated
        UserCtxtFree(pContext);
        pContext = NULL;
    }

    if (pContextSearch)
    {
        StatusSub = UserCtxtHandlerRelease(pContextSearch);
        if (!NT_SUCCESS(StatusSub))
        {
            if (NT_SUCCESS(Status))
            {
                Status = StatusSub;               // replace status only on success
            }
            DebugLog((DEB_ERROR, "SpInitUserModeContext: UserCtxtHandlerInsertCred error  statussub 0x%x\n", StatusSub));
        }
    }

    if (pPackedUserContext)
    {
        DigestFreeMemory(pPackedUserContext);
        pPackedUserContext = NULL;
    }

    // Let FreeContextBuffer handle freeing the virtual allocs

    if (PackedContext->pvBuffer != NULL)
    {
        FreeContextBuffer(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
        PackedContext->cbBuffer = 0;
    }

    DebugLog((DEB_TRACE_FUNC, "SpInitUserModeContext: Leaving      status 0x%x\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpMakeSignature(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL    bServer = FALSE;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode

    DebugLog((DEB_TRACE_FUNC, "SpMakeSignature:Entering   ContextHandle 0x%lx\n", ContextHandle ));
    UNREFERENCED_PARAMETER(fQOP);


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpMakeSignature: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Since we are in UserMode we MUST have a sessionkey to use - if not then can not process
    if (!pContext->strSessionKey.Length)
    {
        Status = STATUS_NO_USER_SESSION_KEY;
        DebugLog((DEB_ERROR, "SpMakeSignature: No Session Key contained in UserContext\n"));
        goto CleanUp;
    }

    // Check to see if Integrity is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((pContext->typeDigest == SASL_CLIENT) ||
        (pContext->typeDigest == SASL_SERVER))
    {
        typeDigestMode = DIGESTMODE_SASL;
    }
    else
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }

    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        DebugLog((DEB_TRACE, "SpMakeSignature: HTTP SignMessage selected\n"));
        Status = DigestUserHTTPHelper(
                            pContext,
                            eSign,
                            pMessage,
                            MessageSeqNo
                            );
    }
    else
    {
        if ((bServer && !(pContext->ContextReq & ASC_REQ_INTEGRITY)) ||
            (!bServer && !(pContext->ContextReq & ISC_REQ_INTEGRITY)) )
        {
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpMakeSignature: Did not negotiate INTEGRITY\n" ));
            goto CleanUp;
        }

        DebugLog((DEB_TRACE, "SpMakeSignature: SASL SignMessage selected\n"));
        Status = DigestUserSignHelperMulti(
                            pContext,
                            pMessage,
                            MessageSeqNo
                            );
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpMakeSignature: DigestUserHTTP/SASLSignHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpMakeSignature:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating the Digest Access
//              for data bufferswith the current Security Context state.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Unused ULONG
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This routine should be called AFTER you have a valid security context
//      from (usually) acceptsecuritycontext.  The usermode context has a nonce
//      count that is automatically incremented for each successful verify signature
//      function call.  Therefore, calling this functio with the same noncecount
//      will return a failed status message.
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpVerifySignature(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL    bServer = FALSE;
    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode

    DebugLog((DEB_TRACE_FUNC, "SpVerifySignature:Entering   ContextHandle 0x%lx\n", ContextHandle ));

    // Reset output flags
    if (pfQOP)
    {
        *pfQOP = 0;
    }

    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpVerifySignature: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Since we are in UserMode we MUST have a sessionkey to use - if not then can not process
    if (!pContext->strSessionKey.Length)
    {
        Status = STATUS_NO_USER_SESSION_KEY;
        DebugLog((DEB_ERROR, "SpVerifySignature: No Session Key contained in UserContext\n"));
        goto CleanUp;
    }

    // Check to see if Integrity is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((pContext->typeDigest == SASL_CLIENT) ||
        (pContext->typeDigest == SASL_SERVER))
    {
        typeDigestMode = DIGESTMODE_SASL;
    }
    else
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }

    if (typeDigestMode == DIGESTMODE_HTTP)
    {
        DebugLog((DEB_TRACE, "SpVerifySignature: HTTP VerifyMessage selected\n"));
        Status = DigestUserHTTPHelper(
                            pContext,
                            eVerify,
                            pMessage,
                            MessageSeqNo
                            );
    }
    else
    {
        if ((bServer && !(pContext->ContextReq & ASC_REQ_INTEGRITY)) ||
            (!bServer && !(pContext->ContextReq & ISC_REQ_INTEGRITY)) )
        {
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpVerifySignature: Did not negotiate INTEGRITY\n" ));
            goto CleanUp;
        }
        else
        {
            DebugLog((DEB_TRACE, "SpVerifySignature: SASL VerifyMessage selected\n"));
            Status = DigestUserVerifyHelper(
                                pContext,
                                pMessage,
                                MessageSeqNo
                                );
        }
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpVerifySignature: DigestUserHTTP/SASLSignHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpVerifySignature:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpSealMessage(
    IN ULONG_PTR ContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL     bServer = FALSE;

    DebugLog((DEB_TRACE_FUNC, "SpSealMessage:Entering   ContextHandle 0x%lx\n", ContextHandle ));
    UNREFERENCED_PARAMETER(fQOP);


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpSealMessage: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Since we are in UserMode we MUST have a sessionkey to use - if not then can not process
    if (!pContext->strSessionKey.Length)
    {
        Status = STATUS_NO_USER_SESSION_KEY;
        DebugLog((DEB_ERROR, "SpSealMessage: No Session Key contained in UserContext\n"));
        goto CleanUp;
    }

    // Check to see if Confidentiality is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((bServer && !(pContext->ContextReq & ASC_RET_CONFIDENTIALITY)) ||
        (!bServer && !(pContext->ContextReq & ISC_RET_CONFIDENTIALITY)) )
    {
        // Since CONFIDENTIALITY not negoiated - check if integrity selected
        if ((bServer && (pContext->ContextReq & ASC_RET_INTEGRITY)) ||
            (!bServer && (pContext->ContextReq & ISC_RET_INTEGRITY)) )
        {
            DebugLog((DEB_TRACE, "SpSealMessage: No Confidentiality selected - use Integrity ONLY\n"));
            // Just call the Sign routine only
            Status = DigestUserSignHelperMulti(
                                pContext,
                                pMessage,
                                MessageSeqNo
                                );
        }
        else
        {
            DebugLog((DEB_ERROR, "SpSealMessage: Neither Confidentiality  nor Integrity selected\n"));
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpSealMessage: Did not negotiate CONFIDENTIALITY\n" ));
            goto CleanUp;
        }
    }
    else
    {
        if (fQOP & SECQOP_WRAP_NO_ENCRYPT) {
            DebugLog((DEB_ERROR, "SpSealMessage: Negotiated Confidentiality but selected Sign only\n"));
            Status = SEC_E_QOP_NOT_SUPPORTED;
            goto CleanUp;
        }
        // Use SignHelper for both SASL  - HTTP not speced
        Status = DigestUserSealHelperMulti(
                            pContext,
                            pMessage,
                            MessageSeqNo
                            );
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpSealMessage: DigestUserSASLHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpSealMessage:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpUnsealMessage(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;
    BOOL  bServer = FALSE;    // acting as the server ?

    DebugLog((DEB_TRACE_FUNC, "SpUnsealMessage:Entering   ContextHandle 0x%lx\n", ContextHandle ));

    // Reset output flags
    if (pfQOP)
    {
        *pfQOP = 0;
    }


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SpUnsealMessage: Could not find ContextHandle\n" ));
        goto CleanUp;
    }

    UserContextPrint(pContext);

    // Since we are in UserMode we MUST have a sessionkey to use - if not then can not process
    if (!pContext->strSessionKey.Length)
    {
        Status = STATUS_NO_USER_SESSION_KEY;
        DebugLog((DEB_ERROR, "SpUnsealMessage: No Session Key contained in UserContext\n"));
        goto CleanUp;
    }

    // Check to see if Confidentiality is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;
    if ((bServer && !(pContext->ContextReq & ASC_RET_CONFIDENTIALITY)) ||
        (!bServer && !(pContext->ContextReq & ISC_RET_CONFIDENTIALITY)) )
    {
        if ((bServer && (pContext->ContextReq & ASC_RET_INTEGRITY)) ||
            (!bServer && (pContext->ContextReq & ISC_RET_INTEGRITY)) )
        {
            DebugLog((DEB_TRACE, "SpUnsealMessage: No Confidentiality selected - use Integrity ONLY\n"));
            Status = DigestUserVerifyHelper(
                                pContext,
                                pMessage,
                                MessageSeqNo
                                );

            // signal QOP was only for integrity
            if (pfQOP)
            {
                *pfQOP = SECQOP_WRAP_NO_ENCRYPT;
            }
        }
        else
        {
            DebugLog((DEB_ERROR, "SpUnsealMessage: Neither Confidentiality  nor Integrity selected\n"));
            Status = SEC_E_QOP_NOT_SUPPORTED;
            DebugLog((DEB_ERROR, "SpUnsealMessage: Did not negotiate CONFIDENTIALITY\n" ));
            goto CleanUp;
        }
    }
    else
    {
        Status = DigestUserUnsealHelper(
                            pContext,
                            pMessage,
                            MessageSeqNo
                            );
    }

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpUnsealMessage: DigestUserSASLHelper returns %lx\n", Status ));
        goto CleanUp;
    }

CleanUp:

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);

        // Don't destroy previous status

        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
        }
    }
    
    DebugLog((DEB_TRACE_FUNC, "SpUnsealMessage:Leaving   status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: Used in ImpersonateSecurityContext SSPI Call
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpGetContextToken(
    IN ULONG_PTR ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    DebugLog((DEB_TRACE_FUNC, "SpGetContextToken: Entering   ContextHandle 0x%lx\n", ContextHandle ));

    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;

    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpGetContextToken: UserCtxtHandlerHandleToContext error 0x%x\n", Status));
    }

    if (pContext && pContext->ClientTokenHandle)
    {
        DebugLog((DEB_TRACE, "SpGetContextToken:       Client ImpersonationToken  0x%lx\n", pContext->ClientTokenHandle ));
        *ImpersonationToken = pContext->ClientTokenHandle;
        goto CleanUp;
    }

    Status = STATUS_INVALID_HANDLE;
    DebugLog((DEB_ERROR, "SpGetContextToken: no token handle\n" ));

CleanUp:

    if (pContext != NULL)
    {
        Status = UserCtxtHandlerRelease(pContext);
    }

    DebugLog((DEB_TRACE_FUNC, "SpGetContextToken: Leaving  Status 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_NOT_SUPPORTED -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpQueryContextAttributes(
    IN ULONG_PTR ContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    PDIGEST_USERCONTEXT pContext = NULL;

    DebugLog((DEB_TRACE_FUNC, "SpQueryContextAttributes: Entering ContextHandle 0x%lx\n", ContextHandle ));

    PSecPkgContext_Sizes ContextSizes = NULL;
    PSecPkgContext_DceInfo ContextDceInfo = NULL;
    PSecPkgContext_Names ContextNames = NULL;
    PSecPkgContext_PackageInfo PackageInfo = NULL;
    PSecPkgContext_NegotiationInfo NegInfo = NULL;
    PSecPkgContext_PasswordExpiry PasswordExpires = NULL;
    PSecPkgContext_KeyInfo KeyInfo = NULL;
    PSecPkgContext_AccessToken AccessToken = NULL;
    PSecPkgContext_StreamSizes StreamSizes = NULL;
    PSecPkgContext_AuthzID ContextAuthzID = NULL;
    PSecPkgContext_Target ContextTarget = NULL;

    ULONG PackageInfoSize = 0;
    BOOL    bServer = FALSE;
    LPWSTR pszEncryptAlgorithmName = NULL;
    LPWSTR pszSignatureAlgorithmName = NULL;
    ULONG ulBytes = 0;
    ULONG ulMaxMessage = 0;

    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode


    Status = UserCtxtHandlerHandleToContext(ContextHandle, FALSE, FALSE, &pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SpQueryContextAttributes: HandleToContext error 0x%x\n", Status));
        Status = STATUS_INVALID_HANDLE;
        goto CleanUp;
    }


    // Check to see if Integrity is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    if ((pContext->typeDigest == SASL_CLIENT) ||
        (pContext->typeDigest == SASL_SERVER))
    {
        typeDigestMode = DIGESTMODE_SASL;
    }
    else
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }

    //
    // Handle each of the various queried attributes
    //

    DebugLog((DEB_TRACE, "SpQueryContextAttributes : 0x%lx\n", Attribute ));
    switch ( Attribute) {
    case SECPKG_ATTR_SIZES:

        ContextSizes = (PSecPkgContext_Sizes) Buffer;
        ZeroMemory(ContextSizes, sizeof(SecPkgContext_Sizes));
        ContextSizes->cbMaxToken = NTDIGEST_SP_MAX_TOKEN_SIZE;
        if (typeDigestMode == DIGESTMODE_HTTP)
        {      // HTTP has signature the same as token in Authentication Header info
            ContextSizes->cbMaxSignature = NTDIGEST_SP_MAX_TOKEN_SIZE;
        }
        else
        {    // SASL has specialized signature block
            ContextSizes->cbMaxSignature = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        if ((pContext->typeCipher == CIPHER_3DES) || 
            (pContext->typeCipher == CIPHER_DES))
        {
            ContextSizes->cbBlockSize = DES_BLOCKSIZE;
            ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else if ((pContext->typeCipher == CIPHER_RC4) || 
                 (pContext->typeCipher == CIPHER_RC4_40) ||
                 (pContext->typeCipher == CIPHER_RC4_56))
        {
            ContextSizes->cbBlockSize = RC4_BLOCKSIZE;
            ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else
        {
            ContextSizes->cbBlockSize = 0;
            if (typeDigestMode == DIGESTMODE_HTTP)
            {      // HTTP has signature the same as token in Authentication Header info
                ContextSizes->cbSecurityTrailer = 0;
            }
            else
            {    // SASL has specialized signature block
                ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;   // handle Auth-int case
            }
        }
        break;
    
    case SECPKG_ATTR_DCE_INFO:

        ContextDceInfo = (PSecPkgContext_DceInfo) Buffer;
        ZeroMemory(ContextDceInfo, sizeof(SecPkgContext_DceInfo));
        ContextDceInfo->AuthzSvc = 0;

        break;

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names) Buffer;
        ZeroMemory(ContextNames, sizeof(SecPkgContext_Names));

        if (pContext->ustrAccountName.Length && pContext->ustrAccountName.Buffer)
        {
            ulBytes = pContext->ustrAccountName.Length + sizeof(WCHAR);
            ContextNames->sUserName = (LPWSTR)g_UserFunctions->AllocateHeap(ulBytes);
            if (ContextNames->sUserName)
            {
                ZeroMemory(ContextNames->sUserName, ulBytes);
                memcpy(ContextNames->sUserName, pContext->ustrAccountName.Buffer, pContext->ustrAccountName.Length);
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;

    case SECPKG_ATTR_TARGET:

        ContextTarget = (PSecPkgContext_Target) Buffer;
        ZeroMemory(ContextTarget, sizeof(SecPkgContext_Target));

        if (pContext->strParam[MD5_AUTH_URI].Length && pContext->strParam[MD5_AUTH_URI].Buffer)
        {
            ulBytes = pContext->strParam[MD5_AUTH_URI].Length;
            ContextTarget->Target = (LPSTR)g_UserFunctions->AllocateHeap(ulBytes);
            if (ContextTarget->Target)
            {
                memcpy(ContextTarget->Target, pContext->strParam[MD5_AUTH_URI].Buffer, ulBytes);
                ContextTarget->TargetLength = ulBytes;
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SECPKG_ATTR_AUTHENTICATION_ID:
        ContextAuthzID = (PSecPkgContext_AuthzID) Buffer;
        ZeroMemory(ContextAuthzID, sizeof(SecPkgContext_AuthzID));
        
        if (pContext->ulFlags & FLAG_CONTEXT_AUTHZID_PROVIDED)
        {
            if (pContext->strParam[MD5_AUTH_AUTHZID].Length && pContext->strParam[MD5_AUTH_AUTHZID].Buffer)
            {
                ulBytes = pContext->strParam[MD5_AUTH_AUTHZID].Length;
                ContextAuthzID->AuthzID = (LPSTR)g_UserFunctions->AllocateHeap(ulBytes);
                if (ContextAuthzID->AuthzID)
                {
                    memcpy(ContextAuthzID->AuthzID, pContext->strParam[MD5_AUTH_AUTHZID].Buffer, ulBytes);
                    ContextAuthzID->AuthzIDLength = ulBytes;
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {    // a valid buffer and a zero length indicate a NULL strign was supplied by calling application
                ContextAuthzID->AuthzID = (LPSTR)g_UserFunctions->AllocateHeap(1);
                if (ContextAuthzID->AuthzID)
                {
                    ContextAuthzID->AuthzIDLength = 0;      // to indicate that "" was used
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }
        break;

    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        if ((Attribute == SECPKG_ATTR_NEGOTIATION_INFO) && (g_fParameter_Negotiate == FALSE))
        {
            Status = STATUS_NOT_SUPPORTED;
            goto CleanUp;
        }

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        ZeroMemory(PackageInfo, sizeof(SecPkgContext_PackageInfo));
        PackageInfoSize = sizeof(SecPkgInfoW) + sizeof(WDIGEST_SP_NAME) + sizeof(NTDIGEST_SP_COMMENT);
        PackageInfo->PackageInfo = (PSecPkgInfoW) g_UserFunctions->AllocateHeap(PackageInfoSize);
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CleanUp;
        }
        PackageInfo->PackageInfo->Name = (LPWSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPWSTR) ((((PBYTE) PackageInfo->PackageInfo->Name)) + sizeof(WDIGEST_SP_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            WDIGEST_SP_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            NTDIGEST_SP_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = RPC_C_AUTHN_DIGEST;
        PackageInfo->PackageInfo->fCapabilities = NTDIGEST_SP_CAPS;
        PackageInfo->PackageInfo->cbMaxToken    = NTDIGEST_SP_MAX_TOKEN_SIZE;

        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
        }

        break;

    case SECPKG_ATTR_PASSWORD_EXPIRY:
        PasswordExpires = (PSecPkgContext_PasswordExpiry) Buffer;
        if (pContext->ExpirationTime.QuadPart != 0)
        {
            PasswordExpires->tsPasswordExpires = pContext->ExpirationTime;
        }
        else
            Status = STATUS_NOT_SUPPORTED;
        break;

    case SECPKG_ATTR_KEY_INFO:
        KeyInfo = (PSecPkgContext_KeyInfo) Buffer;
        ZeroMemory(KeyInfo, sizeof(SecPkgContext_KeyInfo));
        if (typeDigestMode == DIGESTMODE_HTTP)
        {
            // HTTP mode
            KeyInfo->SignatureAlgorithm = CALG_MD5;
            pszSignatureAlgorithmName = WSTR_CIPHER_MD5;
            KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                g_UserFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG)wcslen(pszSignatureAlgorithmName) + 1));
            if (KeyInfo->sSignatureAlgorithmName != NULL)
            {
                wcscpy(
                    KeyInfo->sSignatureAlgorithmName,
                    pszSignatureAlgorithmName
                    );
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            // SASL mode
            KeyInfo->KeySize = 128;       // All modes use a 128 bit key - may have less entropy though (i.e. rc4-XX)
            KeyInfo->SignatureAlgorithm = CALG_HMAC;
            pszSignatureAlgorithmName = WSTR_CIPHER_HMAC_MD5;
            switch (pContext->typeCipher)
            {
                case CIPHER_RC4:
                case CIPHER_RC4_40:
                case CIPHER_RC4_56:
                    KeyInfo->KeySize = 16 * 8;    // All modes use a 128 bit key - may have less entropy though (i.e. rc4-XX)
                    KeyInfo->EncryptAlgorithm = CALG_RC4;
                    pszEncryptAlgorithmName = WSTR_CIPHER_RC4;
                    break;
                case CIPHER_DES:
                    KeyInfo->KeySize = 7 * 8;
                    KeyInfo->EncryptAlgorithm = CALG_DES;
                    pszEncryptAlgorithmName = WSTR_CIPHER_DES;
                    break;
                case CIPHER_3DES:
                    KeyInfo->KeySize = 14 * 8;
                    KeyInfo->EncryptAlgorithm = CALG_3DES_112;
                    pszEncryptAlgorithmName = WSTR_CIPHER_3DES;
                    break;
            }
            if (pszEncryptAlgorithmName)
            {
                KeyInfo->sEncryptAlgorithmName = (LPWSTR)
                    g_UserFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG)wcslen(pszEncryptAlgorithmName) + 1));
                if (KeyInfo->sEncryptAlgorithmName != NULL)
                {
                    wcscpy(
                        KeyInfo->sEncryptAlgorithmName,
                        pszEncryptAlgorithmName
                        );
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            if (pszSignatureAlgorithmName)
            {
                KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                    g_UserFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG)wcslen(pszSignatureAlgorithmName) + 1));
                if (KeyInfo->sSignatureAlgorithmName != NULL)
                {
                    wcscpy(
                        KeyInfo->sSignatureAlgorithmName,
                        pszSignatureAlgorithmName
                        );
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        // Make sure that EncryptAlgorithmName and SignatureAlgorithmName is a valid NULL terminated string #601928
        if (NT_SUCCESS(Status) && !KeyInfo->sEncryptAlgorithmName)
        {
            KeyInfo->sEncryptAlgorithmName = (LPWSTR)
                g_UserFunctions->AllocateHeap(sizeof(WCHAR));

            if (KeyInfo->sEncryptAlgorithmName)
            {
                KeyInfo->sEncryptAlgorithmName[0] = L'\0';
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status) && !KeyInfo->sSignatureAlgorithmName)
        {
            KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                g_UserFunctions->AllocateHeap(sizeof(WCHAR));

            if (KeyInfo->sSignatureAlgorithmName)
            {
                KeyInfo->sSignatureAlgorithmName[0] = L'\0';
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;
    case SECPKG_ATTR_STREAM_SIZES:
        StreamSizes = (PSecPkgContext_StreamSizes) Buffer;
        ZeroMemory(StreamSizes, sizeof(SecPkgContext_StreamSizes));

        if (typeDigestMode == DIGESTMODE_HTTP)
        { 
        }
        else
        {    // SASL
            ulMaxMessage = pContext->ulRecvMaxBuf;
            if (pContext->ulSendMaxBuf < ulMaxMessage)
            {
                ulMaxMessage = pContext->ulSendMaxBuf;
            }
            StreamSizes->cbMaximumMessage = ulMaxMessage - (MAC_BLOCK_SIZE + MAX_PADDING);
        }

        if ((pContext->typeCipher == CIPHER_3DES) || 
            (pContext->typeCipher == CIPHER_DES))
        {
            StreamSizes->cbBlockSize = DES_BLOCKSIZE;
            StreamSizes->cbTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else if ((pContext->typeCipher == CIPHER_RC4) || 
                 (pContext->typeCipher == CIPHER_RC4_40) ||
                 (pContext->typeCipher == CIPHER_RC4_56))
        {
            StreamSizes->cbBlockSize = RC4_BLOCKSIZE;
            StreamSizes->cbTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        break;
    case SECPKG_ATTR_ACCESS_TOKEN:
        AccessToken = (PSecPkgContext_AccessToken) Buffer;
        //
        // ClientTokenHandle can be NULL, for instance:
        // 1. client side context.
        // 2. incomplete server context.
        //      Token is not duped - caller must not CloseHandle
        AccessToken->AccessToken = (void*)pContext->ClientTokenHandle;
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }


CleanUp:

    if (!NT_SUCCESS(Status))
    {
        switch (Attribute) {

        case SECPKG_ATTR_NAMES:

            if (ContextNames && ContextNames->sUserName )
            {
                g_UserFunctions->FreeHeap(ContextNames->sUserName);
                ContextNames->sUserName = NULL;
            }
            break;

        case SECPKG_ATTR_DCE_INFO:

            if (ContextDceInfo && ContextDceInfo->pPac)
            {
                g_UserFunctions->FreeHeap(ContextDceInfo->pPac);
                ContextDceInfo->pPac = NULL;
            }
            break;

        case SECPKG_ATTR_KEY_INFO:
            if (KeyInfo && KeyInfo->sEncryptAlgorithmName)
            {
                g_UserFunctions->FreeHeap(KeyInfo->sEncryptAlgorithmName);
                KeyInfo->sEncryptAlgorithmName = NULL;
            }
            if (KeyInfo && KeyInfo->sSignatureAlgorithmName)
            {
                g_UserFunctions->FreeHeap(KeyInfo->sSignatureAlgorithmName);
                KeyInfo->sSignatureAlgorithmName = NULL;
            }
            break;
        }
    }

    if (pContext != NULL)
    {
        SubStatus = UserCtxtHandlerRelease(pContext);
    }

    DebugLog((DEB_TRACE_FUNC, "SpQueryContextAttributes: Leaving ContextHandle 0x%lx    status 0x%x\n",
               ContextHandle, Status ));
    return(Status);
    
}



//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context  - used to perform user mode verification of
//          challenge response for non-persistent connections re-established via ASC
//          call.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  Called after a Opaque Context lookup of SecurityContext.  ASC will determine that
//    this is a completed context and inform the app that it must call CompleteAuthToken.  Currently,
//    only HTTP mode has this processing done.
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpCompleteAuthToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulQOP = 0;

    DebugLog((DEB_TRACE_FUNC, "SpCompleteAuthToken: Entering    ContextHandle 0x%lx\n", ContextHandle ));

    Status = SpVerifySignature(ContextHandle, InputBuffer, 0, &ulQOP);

    DebugLog((DEB_TRACE_FUNC, "SpCompleteAuthToken: Leaving    ContextHandle 0x%lx    Status = 0x%x\n",
               ContextHandle, Status));

    return(Status);
}


NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (FormattedCredentials);
    DebugLog((DEB_TRACE_FUNC, "SpFormatCredentials: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    UNREFERENCED_PARAMETER (CredentialSize);
    UNREFERENCED_PARAMETER (Credentials);
    UNREFERENCED_PARAMETER (MarshalledCredSize);
    UNREFERENCED_PARAMETER (MarshalledCreds);
    DebugLog((DEB_TRACE_FUNC, "SpMarshallSupplementalCreds: Entering/Leaving\n"));
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NtDigestMakePackedContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the caller's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NtDigestMakePackedContext(
    IN PDIGEST_USERCONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData,
    IN ULONG Flags
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(MappedContext);
    UNREFERENCED_PARAMETER(ContextData);
    UNREFERENCED_PARAMETER(Flags);

    DebugLog((DEB_TRACE_FUNC, "NtDigestMakePackedContext: Entering/Leaving\n"));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SpExportSecurityContext(
    IN ULONG_PTR ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(PackedContext);
    UNREFERENCED_PARAMETER(TokenHandle);

    DebugLog((DEB_TRACE_FUNC, "SpExportSecurityContext:Entering/Leaving     ContextHandle 0x%x\n", ContextHandle ));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpImportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SpImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PULONG_PTR ContextHandle
    )
{
    UNREFERENCED_PARAMETER(PackedContext);
    UNREFERENCED_PARAMETER(Token);
    UNREFERENCED_PARAMETER(ContextHandle);

    DebugLog((DEB_TRACE_FUNC, "SpImportSecurityContext: Entering/Leaving   ContextHandle 0x%x\n", ContextHandle));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}



/*++

RoutineDescription:

    Gets the TOKEN_USER from an open token

Arguments:

    Token - Handle to a token open for TOKEN_QUERY access

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to complete the
        function.

    Errors from NtQueryInformationToken.

--*/

NTSTATUS
SspGetTokenUser(
    HANDLE Token,
    PTOKEN_USER * pTokenUser
    )
{
    PTOKEN_USER LocalTokenUser = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TokenUserSize = 0;

    DebugLog((DEB_TRACE_FUNC, "SspGetTokenUser:  Entering  Token 0x%x    pTokenUser 0x%x\n", Token, pTokenUser));

    //
    // Query the token user.  First pass in NULL to get back the
    // required size.
    //

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                NULL,
                0,
                &TokenUserSize
                );

    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        ASSERT(Status != STATUS_SUCCESS);
        DebugLog((DEB_ERROR, "SspGetTokenUser: NtQueryInformationToken (1st call) returns 0x%lx for Token 0x%x\n", Status, Token ));
        goto CleanUp;
    }

    //
    // Now allocate the required ammount of memory and try again.
    //

    LocalTokenUser = (PTOKEN_USER) DigestAllocateMemory(TokenUserSize);
    if (LocalTokenUser == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanUp;
    }
    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                LocalTokenUser,
                TokenUserSize,
                &TokenUserSize
                );

    if (NT_SUCCESS(Status))
    {
        *pTokenUser = LocalTokenUser;
    }
    else
    {
        DigestFreeMemory(LocalTokenUser);
        DebugLog((DEB_ERROR, "SspGetTokenUser: NtQueryInformationToken (2nd call) returns 0x%lx for Token 0x%x\n", Status, Token ));
    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SspGetTokenUser:  Leaving  Token 0x%x with Status 0x%x\n", Token, Status));
    return(Status);
}



/*++

RoutineDescription:

    Create a local context for a real context
    Don't link it to out list of local contexts.
    Called inside LSA to prep packed Context buffer to send to UserMode addr space

Arguments:
   pLsaContext - pointer to a Context in LSA to map over to User space
   pDigest - pointer to digest auth parameters - may be NULL and use Context instead
   ulFlagOptions - options set for this context - will be OR'ed into ulFlag for mapped context
   ContextData - packed Context information to send to usermode process

Return Value:

--*/
NTSTATUS
SspMapDigestContext(
    IN PDIGEST_CONTEXT   pLsaContext,           // LSA Context
    IN PDIGEST_PARAMETER pDigest,
    IN ULONG ulFlagOptions,
    OUT PSecBuffer  ContextData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_PACKED_USERCONTEXT pPackedUserCtxt = NULL;      // Return buffer to on good auth to UserMode addr space
    USHORT cbLenNeeded = 0;
    PUCHAR  pucLoc = NULL;
    HANDLE  hTemp = NULL;
    int iAuth = 0;
    USHORT usAcctNameSize = 0;

    DebugLog((DEB_TRACE_FUNC, "SspMapContext: Entering  for LSA context %lx\n", pLsaContext));
    ASSERT(ContextData);
    ASSERT(pLsaContext);

    if (!pLsaContext)
    {
        Status = STATUS_INVALID_HANDLE;
        DebugLog((DEB_ERROR, "SspMapContext: pLsaContext invalid\n"));
        goto CleanUp;
    }

    // Copy over only selected fields
    cbLenNeeded = sizeof(DIGEST_PACKED_USERCONTEXT);
    if (pDigest)
    {
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_USERNAME].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_REALM].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_NONCE].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_CNONCE].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_ALGORITHM].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_QOP].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_URI].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_AUTHZID].Length;
        cbLenNeeded = cbLenNeeded + pDigest->refstrParam[MD5_AUTH_OPAQUE].Length;
    }
    else
    {
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_USERNAME].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_REALM].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_NONCE].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_CNONCE].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_ALGORITHM].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_QOP].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_URI].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_AUTHZID].Length;
        cbLenNeeded = cbLenNeeded + pLsaContext->strDirective[MD5_AUTH_OPAQUE].Length;
    }

    // Next Output the session key only if nonce and cnonce are used
    if (pLsaContext->typeAlgorithm == MD5_SESS)
    {
        cbLenNeeded = cbLenNeeded + pLsaContext->strSessionKey.Length;
    }

    // Now output the unicode domain\accountname
    usAcctNameSize = pLsaContext->ustrAccountName.Length + pLsaContext->ustrDomain.Length + sizeof(WCHAR); // for \ char
    cbLenNeeded = cbLenNeeded + usAcctNameSize;

    DebugLog((DEB_TRACE, "SspMapContext:  Packed Digest will be %d bytes \n", cbLenNeeded));

    //   DigestAllocateMemory will use g_LsaFunctions->AllocateLsaHeap()
    pPackedUserCtxt = (PDIGEST_PACKED_USERCONTEXT)g_LsaFunctions->AllocateLsaHeap(cbLenNeeded);
    if (!pPackedUserCtxt)
    {
        // Failed to allocate memory to send info to usermode space
        ContextData->cbBuffer = 0;
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "SspMapContext: out of memory on usermode contextdata\n"));
        goto CleanUp;
    }

       // Now initialize the UserMode Context struct to return
    ZeroMemory(pPackedUserCtxt, cbLenNeeded);
    pPackedUserCtxt->ExpirationTime = pLsaContext->ExpirationTime;
    pPackedUserCtxt->typeAlgorithm = (ULONG)pLsaContext->typeAlgorithm;
    pPackedUserCtxt->typeCipher = (ULONG)pLsaContext->typeCipher;
    pPackedUserCtxt->typeCharset = (ULONG)pLsaContext->typeCharset;
    pPackedUserCtxt->typeDigest = (ULONG)pLsaContext->typeDigest;
    pPackedUserCtxt->typeQOP = (ULONG)pLsaContext->typeQOP;
    pPackedUserCtxt->ulSendMaxBuf = pLsaContext->ulSendMaxBuf;
    pPackedUserCtxt->ulRecvMaxBuf = pLsaContext->ulRecvMaxBuf;
    pPackedUserCtxt->ContextReq = pLsaContext->ContextReq;
    pPackedUserCtxt->CredentialUseFlags = pLsaContext->CredentialUseFlags;

    // Incorporate any options set for this context (such as FLAG_CONTEXT_REFCOUNT)
    pPackedUserCtxt->ulFlags = pLsaContext->ulFlags | ulFlagOptions;

    // Now mark that there is data for these items  ONLY non-zero items will be written out!!!
    if (pDigest)
    {
        pPackedUserCtxt->uDigestLen[MD5_AUTH_USERNAME] = (ULONG)pDigest->refstrParam[MD5_AUTH_USERNAME].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_REALM] = (ULONG)pDigest->refstrParam[MD5_AUTH_REALM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_NONCE] = (ULONG)pDigest->refstrParam[MD5_AUTH_NONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_CNONCE] = (ULONG)pDigest->refstrParam[MD5_AUTH_CNONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_ALGORITHM] = (ULONG)pDigest->refstrParam[MD5_AUTH_ALGORITHM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_QOP] = (ULONG)pDigest->refstrParam[MD5_AUTH_QOP].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_URI] = (ULONG)pDigest->refstrParam[MD5_AUTH_URI].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_AUTHZID] = (ULONG)pDigest->refstrParam[MD5_AUTH_AUTHZID].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_OPAQUE] = (ULONG)pDigest->refstrParam[MD5_AUTH_OPAQUE].Length;
    }
    else
    {
        pPackedUserCtxt->uDigestLen[MD5_AUTH_USERNAME] = (ULONG)pLsaContext->strDirective[MD5_AUTH_USERNAME].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_REALM] = (ULONG)pLsaContext->strDirective[MD5_AUTH_REALM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_NONCE] = (ULONG)pLsaContext->strDirective[MD5_AUTH_NONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_CNONCE] = (ULONG)pLsaContext->strDirective[MD5_AUTH_CNONCE].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_ALGORITHM] = (ULONG)pLsaContext->strDirective[MD5_AUTH_ALGORITHM].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_QOP] = (ULONG)pLsaContext->strDirective[MD5_AUTH_QOP].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_URI] = (ULONG)pLsaContext->strDirective[MD5_AUTH_URI].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_AUTHZID] = (ULONG)pLsaContext->strDirective[MD5_AUTH_AUTHZID].Length;
        pPackedUserCtxt->uDigestLen[MD5_AUTH_OPAQUE] = (ULONG)pLsaContext->strDirective[MD5_AUTH_OPAQUE].Length;
    }

    // the session key is mapped only if nonce and cnonce are used
    if (pLsaContext->typeAlgorithm == MD5_SESS)
    {
        pPackedUserCtxt->uSessionKeyLen = (ULONG)pLsaContext->strSessionKey.Length;
    }
    else
    {
        pPackedUserCtxt->uSessionKeyLen = 0;
    }

    pPackedUserCtxt->uAccountNameLen = (ULONG)usAcctNameSize;


    // dup token if it exists
    if (pLsaContext->TokenHandle != NULL)
    {
        Status = g_LsaFunctions->DuplicateHandle(
                           pLsaContext->TokenHandle,
                           &(hTemp));

        if (!NT_SUCCESS(Status))
        {
            if (pPackedUserCtxt)
            {
                DigestFreeMemory(pPackedUserCtxt);
                pPackedUserCtxt = NULL;
            }
            ContextData->cbBuffer = 0;
            DebugLog((DEB_ERROR, "SspMapContext: DuplicateHandle returns 0x%lx\n", Status));
            goto CleanUp;
        }
        // Must pack the HANDLE into a fixed size structure for IA64 and i32 formats
        pPackedUserCtxt->ClientTokenHandle = (ULONG) ((ULONG_PTR)hTemp);
        DebugLog((DEB_TRACE, "SspMapContext: DuplicateHandle successful  ClientTokenHandle 0x%x\n", pPackedUserCtxt->ClientTokenHandle));
    }

    // Now copy over the string data elements
    pucLoc = &(pPackedUserCtxt->ucData);
    if (pDigest)
    {
        for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
        {
           if (pPackedUserCtxt->uDigestLen[iAuth])
           {
               memcpy(pucLoc, pDigest->refstrParam[iAuth].Buffer, pPackedUserCtxt->uDigestLen[iAuth]);
               pucLoc += pPackedUserCtxt->uDigestLen[iAuth];
           }
        }

        if (pDigest->usFlags & FLAG_AUTHZID_PROVIDED)
        {
            pPackedUserCtxt->ulFlags |= FLAG_CONTEXT_AUTHZID_PROVIDED;
        }
    }
    else
    {
        for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
        {
           if (pPackedUserCtxt->uDigestLen[iAuth])
           {
               memcpy(pucLoc, pLsaContext->strDirective[iAuth].Buffer, pPackedUserCtxt->uDigestLen[iAuth]);
               pucLoc += pPackedUserCtxt->uDigestLen[iAuth];
           }
        }
    }

    if (pPackedUserCtxt->uSessionKeyLen)
    {
        memcpy(pucLoc, pLsaContext->strSessionKey.Buffer, pPackedUserCtxt->uSessionKeyLen);
        pucLoc += pPackedUserCtxt->uSessionKeyLen;
    }

    if (usAcctNameSize)
    {
        memcpy(pucLoc, pLsaContext->ustrDomain.Buffer, pLsaContext->ustrDomain.Length);
        pucLoc = pucLoc + pLsaContext->ustrDomain.Length;
        memcpy(pucLoc, L"\\", sizeof(WCHAR));
        pucLoc = pucLoc + sizeof(WCHAR);
        memcpy(pucLoc, pLsaContext->ustrAccountName.Buffer, pLsaContext->ustrAccountName.Length);
        pucLoc = pucLoc + pLsaContext->ustrAccountName.Length;
    }

    ContextData->pvBuffer = pPackedUserCtxt;
    ContextData->cbBuffer = cbLenNeeded;
    ContextData->BufferType = SECBUFFER_TOKEN;


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "SspMapContext: Leaving  LsaContext  %lx    Status 0x%x\n", pLsaContext, Status));
    return(Status);
}




//+--------------------------------------------------------------------
//
//  Function:   DigestUserHTTPHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with HTTP for auth after initial ASC/ISC exchange
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserHTTPHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN eSignSealOp Op,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG     ulSeqNo = 0;
    PSecBuffer pChalRspInputToken = NULL;
    PSecBuffer pMethodInputToken = NULL;
    PSecBuffer pURIInputToken = NULL;
    PSecBuffer pHEntityInputToken = NULL;
    PSecBuffer pFirstOutputToken = NULL;
    DIGEST_PARAMETER Digest;
    USHORT usLen = 0;
    int iAuth = 0;
    char *cptr = NULL;
    char  szNCOverride[2*NCNUM];             // Overrides the provided NC if non-zero using only NCNUM digits
    STRING strURI = {0};

    DebugLog((DEB_TRACE_FUNC, "DigestUserHTTPHelper: Entering \n"));

    Status = DigestInit(&Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Digest init error status 0x%x\n", Status));
        goto CleanUp;
    }

    if (pSecBuff->cBuffers < 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Not enough input buffers 0x%x\n", Status));
        goto CleanUp;
    }
    pChalRspInputToken = &(pSecBuff->pBuffers[0]);
    if (!ContextIsTokenOK(pChalRspInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (ChalRspInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Set any digest processing parameters based on Context
    if (pContext->ulFlags & FLAG_CONTEXT_NOBS_DECODE)
    {
        Digest.usFlags |= FLAG_NOBS_DECODE;      
    }

    // We have input in the SECBUFFER 0th location - parse it
    Status = DigestParser2(pChalRspInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: DigestParser error 0x%x\n", Status));
        goto CleanUp;
    }

       // Now determine all of the other buffers

    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: pContext->ContextReq 0x%lx \n", pContext->ContextReq));

    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: HTTP SecBuffer Format\n"));
    // Retrieve the information from the SecBuffers & check proper formattting
    if (pSecBuff->cBuffers < 4)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Not enough input buffers 0x%x\n", Status));
        goto CleanUp;
    }
    
    pMethodInputToken = &(pSecBuff->pBuffers[1]);
    if (!ContextIsTokenOK(pMethodInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {                           // Check to make sure that string is present
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (MethodInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    pURIInputToken = &(pSecBuff->pBuffers[2]);
    if (!ContextIsTokenOK(pURIInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (URIInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    pHEntityInputToken = &(pSecBuff->pBuffers[3]);
    if (!ContextIsTokenOK(pHEntityInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: ContextIsTokenOK (HEntityInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Take care of the output buffer
    if (Op == eSign)
    {
        if (pSecBuff->cBuffers < 5)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: No Output Buffers %d\n", Status));
            goto CleanUp;
        }
        pFirstOutputToken = &(pSecBuff->pBuffers[4]);
        if (!ContextIsTokenOK(pFirstOutputToken, 0))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper, ContextIsTokenOK (FirstOutputToken) failed  0x%x\n", Status));
            goto CleanUp;
        }

        // Reset output buffer
        if (pFirstOutputToken && (pFirstOutputToken->pvBuffer) && (pFirstOutputToken->cbBuffer >= 1))
        {
            cptr = (char *)pFirstOutputToken->pvBuffer;
            *cptr = '\0';
        }

    }
    else
    {
        pFirstOutputToken = NULL;    // There is no output buffer
    }

    // Verify that there is a valid Method provided
    if (!pMethodInputToken->pvBuffer || !pMethodInputToken->cbBuffer ||
        (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Method SecBuffer must have valid method string status 0x%x\n", Status));
        goto CleanUp;
    }

    usLen = strlencounted((char *)pMethodInputToken->pvBuffer, (USHORT)pMethodInputToken->cbBuffer);
    if (!usLen)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Method SecBuffer must have valid method string status 0x%x\n", Status));
        goto CleanUp;
    }
    Digest.refstrParam[MD5_AUTH_METHOD].Length = usLen;
    Digest.refstrParam[MD5_AUTH_METHOD].MaximumLength = (unsigned short)(pMethodInputToken->cbBuffer);
    Digest.refstrParam[MD5_AUTH_METHOD].Buffer = (char *)pMethodInputToken->pvBuffer;       // refernce memory - no alloc!!!!


    // Check to see if we have H(Entity) data to utilize
    if (pHEntityInputToken->cbBuffer)
    {
        // Verify that there is a valid Method provided
        if (!pHEntityInputToken->pvBuffer || (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: HEntity SecBuffer must have valid string status 0x%x\n", Status));
            goto CleanUp;
        }

        usLen = strlencounted((char *)pHEntityInputToken->pvBuffer, (USHORT)pHEntityInputToken->cbBuffer);

        if ((usLen != 0) && (usLen != (MD5_HASH_BYTESIZE * 2)))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: HEntity SecBuffer must have valid MD5 Hash data 0x%x\n", Status));
            goto CleanUp;
        }

        if (usLen)
        {
            Digest.refstrParam[MD5_AUTH_HENTITY].Length = usLen;
            Digest.refstrParam[MD5_AUTH_HENTITY].MaximumLength = (unsigned short)(pHEntityInputToken->cbBuffer);
            Digest.refstrParam[MD5_AUTH_HENTITY].Buffer = (char *)pHEntityInputToken->pvBuffer;       // refernce memory - no alloc!!!!
        }
    }


    // Import the URI if it is a sign otherwise verify URI match if verify
    if (Op == eSign)
    {
        // Pull in the URI provided in SecBuffer
        if (!pURIInputToken || !pURIInputToken->cbBuffer || !pURIInputToken->pvBuffer)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: URI SecBuffer must have valid string 0x%x\n", Status));
            goto CleanUp;
        }


        if (PBUFFERTYPE(pURIInputToken) == SECBUFFER_PKG_PARAMS)
        {
            usLen = strlencounted((char *)pURIInputToken->pvBuffer, (USHORT)pURIInputToken->cbBuffer);

            if (usLen > 0)
            {
                Status = StringCharDuplicate(&strURI, (char *)pURIInputToken->pvBuffer, usLen);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestUserHTTPHelper: StringCharDuplicate   error 0x%x\n", Status));
                    goto CleanUp;
                }
            }
        }
        else
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: URI buffer type invalid   error %d\n", Status));
            goto CleanUp;
        }

        StringReference(&(Digest.refstrParam[MD5_AUTH_URI]), &strURI);  // refernce memory - no alloc!!!!
    }

    // If we have a NonceCount in the MessageSequenceNumber then use that
    if (MessageSeqNo)
    {
        ulSeqNo = MessageSeqNo;
    }
    else
    {
        ulSeqNo = pContext->ulNC + 1;           // Else use the next sequence number
    }

    sprintf(szNCOverride, "%0.8x", ulSeqNo); // Buffer is twice as big as we need (for safety) so just clip out first 8 characters
    szNCOverride[NCNUM] = '\0';         // clip to 8 digits
    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: Message Sequence NC is %s\n", szNCOverride));
    Digest.refstrParam[MD5_AUTH_NC].Length = (USHORT)NCNUM;
    Digest.refstrParam[MD5_AUTH_NC].MaximumLength = (unsigned short)(NCNUM+1);
    Digest.refstrParam[MD5_AUTH_NC].Buffer = (char *)szNCOverride;          // refernce memory - no alloc!!!!

    // Now link in the stored context values into the digest if this is a SignMessage
    // If there are values there from the input auth line then override them with context's value
    if (Op == eSign)
    {
        for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
        {
            if ((iAuth != MD5_AUTH_URI) &&
                (iAuth != MD5_AUTH_HENTITY) &&
                (iAuth != MD5_AUTH_METHOD) &&
                pContext->strParam[iAuth].Length)
            {       // Link in only if passed into the user context from the LSA context
                Digest.refstrParam[iAuth].Length = pContext->strParam[iAuth].Length;
                Digest.refstrParam[iAuth].MaximumLength = pContext->strParam[iAuth].MaximumLength;
                Digest.refstrParam[iAuth].Buffer = pContext->strParam[iAuth].Buffer;          // reference memory - no alloc!!!!
            }
        }
    }

    // Verify that ChallengeResponses directive values are the same as in original ChallangeResponse
    if (Op == eVerify)
    {
        Status = DigestUserCompareDirectives(pContext, &Digest);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestUserHTTPHelper: DigestUserCompareDirectives     error 0x%x\n", Status));
            goto CleanUp;
        }
    }

    DebugLog((DEB_TRACE, "DigestUserHTTPHelper: Digest inputs processing completed\n"));

    Status = DigestUserProcessParameters(pContext, &Digest, pFirstOutputToken);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: DigestUserProcessParameters     error 0x%x\n", Status));
        goto CleanUp;
    }

    pContext->ulNC = ulSeqNo;                           // Everything verified so increment to next nonce count

    // Keep a copy of the new URI in ChallengeResponse
    StringFree(&(pContext->strParam[MD5_AUTH_URI]));
    Status = StringDuplicate(&(pContext->strParam[MD5_AUTH_URI]), &(Digest.refstrParam[MD5_AUTH_URI])); 
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserHTTPHelper: Failed to copy URI\n"));
        goto CleanUp;
    }

CleanUp:

    DigestFree(&Digest);

    StringFree(&strURI);

    DebugLog((DEB_TRACE_FUNC, "DigestUserHTTPHelper: Leaving    Status 0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestUserSignHelperMulti
//
//  Synopsis:   Process multiple SecBuffers with a given User Security Context
//              Used with SASL section 2.3 RFC
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserSignHelperMulti(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PSecBuffer pSecBufToken = NULL;
    PSecBuffer pSecBufPad = NULL;

    PSecBuffer pSecBufHMAC = NULL;          // Points to the HMAC appended to the data block

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock = {0};
    STRING  strcSignKeyConst = {0};     // pointer to a constant valued string

    ULONG Index = 0;

    UNREFERENCED_PARAMETER(MessageSeqNo);    

    DebugLog((DEB_TRACE_FUNC, "DigestUserSignHelperMulti: Entering \n"));

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            pSecBufToken = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_PADDING)
        {
            pSecBufPad = &pSecBuff->pBuffers[Index];
        }
    }

    if ((!pSecBufPad) || (!pSecBufPad->cbBuffer))
    {   // If no SECBUFFER_PADDING, use SECBUFFER_TOKEN
        pSecBufHMAC = pSecBufToken;
    }
    else
    {
        pSecBufHMAC = pSecBufPad;
        if (pSecBufToken)
        {
            pSecBufToken->cbBuffer = 0;
        }
    }
    if (!pSecBufHMAC || !ContextIsTokenOK(pSecBufHMAC, 0) || (pSecBufHMAC->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestUserSignHelperMulti: ContextIsTokenOK (SignatureToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Determine the sequence number & Constant Key Sring to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserSignHelperMulti: Signing in Server Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserSignHelperMulti: Signing in Client Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }

    Status = CalculateSASLHMACMulti(pContext, TRUE, &strcSignKeyConst, *pdwSeqNum,
                               pSecBuff, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserSignHelperMulti: Error in CalculateSASLHMACMulti   status 0x%x\n", Status));
        goto CleanUp;
    }

        // Write the calculated MAC block out to the SecBuffer
    memcpy(pSecBufHMAC->pvBuffer, &MacBlock, MAC_BLOCK_SIZE);
    DebugLog((DEB_TRACE, "DigestUserSignHelper: Wrote out the calculated MAC Block.\n"));
    pSecBufHMAC->cbBuffer = MAC_BLOCK_SIZE;           // indicate number of bytes we used for padding and HMAC block

    // completed all tasks down to here.  Need to update the sequence number
    (*pdwSeqNum)++;
    DebugLog((DEB_TRACE, "DigestUserSignHelperMulti: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserSignHelperMulti: Leaving    Status 0x%x\n", Status));

    return(Status);
}




//+--------------------------------------------------------------------
//
//  Function:   DigestUserVerifyHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with SASL section 2.3 RFC
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserVerifyHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PBYTE     pMsgHMAC  = NULL;             // Location of the HMAC in the message
    PSecBuffer pSecBufData = NULL;
    PSecBuffer pSecBufStream = NULL;
    PSecBuffer pSecBufMsg = NULL;          // Points to the data section

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock = {0};
    SASL_MAC_BLOCK  TokenMacBlock = {0};
    STRING  strcSignKeyConst = {0};
    ULONG cbSecBufMsgIntegrity = 0;        // Number of bytes in message to calc HMAC on

    ULONG Index = 0;

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);
#endif
    
    UNREFERENCED_PARAMETER(MessageSeqNo);    

    DebugLog((DEB_TRACE_FUNC, "DigestUserVerifyHelper: Entering \n"));

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            pSecBufData = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_STREAM)
        {
            pSecBufStream = &pSecBuff->pBuffers[Index];
        }
    }


    // Must be for decrypt/verify
    if ((!pSecBufStream) || (!pSecBufStream->cbBuffer))
    {   // If no SECBUFFER_STREAM, use SECBUFFER_DATA
        pSecBufMsg = pSecBufData;
    }
    else
    {
        pSecBufMsg = pSecBufStream;
    }

    if (!pSecBufMsg || (!ContextIsTokenOK(pSecBufMsg, 0)) || (pSecBufMsg->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: ContextIsTokenOK (SecBufMsg) decrypt/verify failed  0x%x\n", Status));
        goto CleanUp;
    }
    
    // Strip off the MsgType and the Sequence Number
    cbSecBufMsgIntegrity = pSecBufMsg->cbBuffer - (MAC_BLOCK_SIZE);


    // Determine the sequence number to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Verifying in Server Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Verifying in Client Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }



    Status = CalculateSASLHMAC(pContext, FALSE, &strcSignKeyConst, *pdwSeqNum,
                               (PBYTE)pSecBufMsg->pvBuffer, cbSecBufMsgIntegrity, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: Error in CalculateSASLHMAC   status 0x%x\n", Status));
        goto CleanUp;
    }


    DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Ready to compare MacBlocks\n"));

    // Check validity of MAC block ONLY do not write it out
    pMsgHMAC =  (PBYTE)pSecBufMsg->pvBuffer + cbSecBufMsgIntegrity;
    memcpy(&TokenMacBlock, pMsgHMAC, MAC_BLOCK_SIZE); 
    if (MacBlock.dwSeqNumber != TokenMacBlock.dwSeqNumber)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: SASL MAC blocks out of sequence. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    if (memcmp(&MacBlock, &TokenMacBlock, MAC_BLOCK_SIZE))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        DebugLog((DEB_ERROR, "DigestUserVerifyHelper: SASL MAC blocks do not match. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestUserVerifyHelper: SASL MAC blocks match!\n"));
    }


    // completed all tasks down to here.  Need to update the sequence number

    (*pdwSeqNum)++;

    // Update the Data information (without the attached HMAC info block
    if (pSecBufData)
    {
        pSecBufData->cbBuffer = pSecBufMsg->cbBuffer - MAC_BLOCK_SIZE;
        pSecBufData->pvBuffer = pSecBufMsg->pvBuffer;
    }
    DebugLog((DEB_TRACE, "DigestUserVerifyHelper: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserVerifyHelper: Leaving    Status 0x%x\n", Status));

    return(Status);

}



//+--------------------------------------------------------------------
//
//  Function:   DigestUserSealHelperMulti
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with SASL section 2.3 RFC Supports Multiple Data Secbuffers
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------

NTSTATUS NTAPI
DigestUserSealHelperMulti(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;


    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PSecBuffer pSecBufToken = NULL;
    PSecBuffer pSecBufPad = NULL;
    PSecBuffer pSecBufHMAC = NULL;          // Points to the HMAC appended to the data block

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock = {0};
    STRING  strcSignKeyConst = {0};
    STRING  strcSealKeyConst = {0};
    PUCHAR  pbIV = NULL;

    BYTE bKcTempData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3

    ULONG Index = 0;
    USHORT cbHA1n = 0;         // Number of bytes for Ha1 in Kcc/Kcs
    DWORD cbKey = 0;             // Number of bytes of Kcc/Kcs to use for the key
    DWORD cbKeyNoParity = 0;             // Number of bytes of Kcc/Kcs to use for the key with no parity
    DWORD cbTempKey = 0;
    ULONG cbBlockSize = RC4_BLOCKSIZE;    // Blocksize for the given cipher
    ULONG cbPrefixPadding = 0;   // number of bytes needed for padding out to blocksize
    ULONG cbBlocks = 0;
    PBYTE pHMACTemp = NULL;
    ALG_ID Algid = 0;
    ULONG cbTotalData = 0;           // total number of bytes to process in Data SecBuffers

    UNREFERENCED_PARAMETER(MessageSeqNo);    

    DebugLog((DEB_TRACE_FUNC, "DigestUserSealHelperMulti: Entering \n"));

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            pSecBufToken = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_PADDING)
        {
            pSecBufPad = &pSecBuff->pBuffers[Index];
        }
    }

    if ((!pSecBufPad) || (!pSecBufPad->cbBuffer))
    {   // If no SECBUFFER_PADDING, use SECBUFFER_TOKEN
        pSecBufHMAC = pSecBufToken;
    }
    else
    {
        pSecBufHMAC = pSecBufPad;
        if (pSecBufToken)
        {
            pSecBufToken->cbBuffer = 0;
        }
    }
    if (!pSecBufHMAC || !ContextIsTokenOK(pSecBufHMAC, 0) || (pSecBufHMAC->cbBuffer < (MAC_BLOCK_SIZE + MAX_PADDING)))
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestUserSealHelperMulti: ContextIsTokenOK (SignatureToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Determine the sequence number & Constant Key Sring to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_S2C_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserSealHelperMulti: Signing in Server Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwSendSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_C2S_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserSealHelperMulti: Signing in Client Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }

    // Based on the Cypher selected - establish the byte count parameters - magic numbers from RFC

    if (pContext->typeCipher == CIPHER_RC4)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_40)
    {
        cbHA1n = 5;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_56)
    {
        cbHA1n = 7;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 8;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 7;
        cbBlockSize = DES_BLOCKSIZE;  // DES uses a blocksize of 8
        Algid = CALG_DES;
    }
    else if (pContext->typeCipher == CIPHER_3DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 14;
        cbBlockSize = DES_BLOCKSIZE;  // DES uses a blocksize of 8
        Algid = CALG_3DES_112;
    }
    else
    {
        Status = SEC_E_CRYPTO_SYSTEM_INVALID;
        DebugLog((DEB_ERROR, "DigestUserSealHelperMulti: ContextIsTokenOK (SecBufMsg) failed  0x%x\n", Status));
        goto CleanUp;
    }

    Status = CalculateDataCount(pSecBuff, &cbTotalData);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserSealHelperMulti: Error in CalculateDataCount   status 0x%x\n", Status));
        goto CleanUp;
    }

    // If the cipher is not a stream cipher - the place prefix padding before SASL MAC
    //  Modified to include padding based on message datasize + the 10 byte HMAC
    if (cbBlockSize != 1)
    {
        cbBlocks =  (cbTotalData + SASL_MAC_HMAC_SIZE) / cbBlockSize;         // integer divison
        cbPrefixPadding = cbBlockSize - ((cbTotalData + SASL_MAC_HMAC_SIZE) - (cbBlockSize * cbBlocks));
        if (!cbPrefixPadding)
        {
            cbPrefixPadding = cbBlockSize;      // if padding is zero set it to the blocksize - i.e. always pad
        }
        DebugLog((DEB_TRACE, "DigestUserSealHelperMulti: TotalDataSize %lu  BlockSize %lu  Padding %lu\n",
                   cbTotalData, cbBlockSize, cbPrefixPadding));
    }

    Status = CalculateSASLHMACMulti(pContext, TRUE, &strcSignKeyConst, *pdwSeqNum,
                               pSecBuff, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserSealHelper: Error in CalculateSASLHMACMulti   status 0x%x\n", Status));
        goto CleanUp;
    }

        // Write the calculated MAC block out to the SecBuffer
        // Put the padding as the prefix
    pHMACTemp = (PBYTE)pSecBufHMAC->pvBuffer;
    memset(pHMACTemp, cbPrefixPadding, cbPrefixPadding);
    memcpy(pHMACTemp + cbPrefixPadding, &MacBlock, MAC_BLOCK_SIZE);
    DebugLog((DEB_TRACE, "DigestUserSealHelperMulti: Wrote out the calculated MAC Block.\n"));
    pSecBufHMAC->cbBuffer = MAC_BLOCK_SIZE + cbPrefixPadding;  // indicate number of bytes we used for padding and HMAC block

        // Completed the Integrity calculation, now encrypt the data if requested
        // Encrypt the message, padding and first SASL_MAC_HMAC_SIZE (10) bytes of HMAC (the integrity value)

    // Compute Kc for encryption (seal) & generate Cryptkey
    if (pContext->hSealCryptKey == NULL)
    {
        ASSERT(*pdwSeqNum == 0);    // Should be first call into package

        // Compute on first time call to encrypt - save for other sequence numbers
        Status = CalculateKc(pContext->bSessionKey, cbHA1n, &strcSealKeyConst, pContext->bKcSealHashData);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserSealHelperMulti: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }

        // code to expand the DES key into multiple of 8 bytes (key with parity)
        if ((pContext->typeCipher == CIPHER_DES) || (pContext->typeCipher == CIPHER_3DES))
        {
            Status = AddDESParity(pContext->bKcSealHashData,
                                  cbKeyNoParity,
                                  bKcTempData,
                                  &cbTempKey);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestUserSealHelperMulti: Error in AddDESParity   status 0x%x\n", Status));
                goto CleanUp;
            }
            // replace with DES parity version
            ASSERT(cbKey == cbTempKey);
            memcpy(pContext->bSealKey, bKcTempData, cbTempKey);
            pbIV = &(pContext->bKcSealHashData[8]);
        }
        else
        {
            memcpy(pContext->bSealKey, pContext->bKcSealHashData, MD5_HASH_BYTESIZE);
            pbIV = NULL;
        }

        //  generate symmetric key from the cleartext
        Status = CreateSymmetricKey(Algid, cbKey, pContext->bSealKey, pbIV, &pContext->hSealCryptKey);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserSealHelperMulti: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }

    }

    Status = EncryptData2Multi(pContext->hSealCryptKey,
                          cbBlockSize,
                          pSecBuff,
                          (cbPrefixPadding + SASL_MAC_HMAC_SIZE),
                          pHMACTemp);

    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserSealHelperMulti: Error in EncryptData3   status 0x%x\n", Status));
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "DigestUserSealHelperMulti: Data encrypted\n"));

    // completed all tasks down to here.  Need to update the sequence number
    (*pdwSeqNum)++;
    DebugLog((DEB_TRACE, "DigestUserSealHelperMulti: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserSealHelperMulti: Leaving    Status 0x%x\n", Status));
    

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestUserUnsealHelper
//
//  Synopsis:   Process a SecBuffer with a given User Security Context
//              Used with SASL section 2.3 RFC
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestUserUnsealHelper(
                        IN PDIGEST_USERCONTEXT pContext,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDWORD    pdwSeqNum = NULL;             // points to the Sequence number to use
    PSecBuffer pSecBufData = NULL;
    PSecBuffer pSecBufStream = NULL;
    PSecBuffer pSecBufMsg = NULL;          // Points to the data section

    BOOL bServer = FALSE;
    SASL_MAC_BLOCK  MacBlock = {0};
    SASL_MAC_BLOCK  TokenMacBlock = {0};         // Extract the HMAC block imbedded in the message
    STRING  strcSignKeyConst = {0};
    STRING  strcSealKeyConst = {0};
    PBYTE  pMsgHMAC = NULL;

    BYTE bKcTempData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3
    PUCHAR pbIV = NULL;

    ULONG Index = 0;
    USHORT cbHA1n = 0;          // Number of bytes for Ha1 in Kcc/Kcs
    DWORD cbKey = 0;             // Number of bytes of Kcc/Kcs to use for the key
    DWORD cbKeyNoParity = 0;     // Number of bytes of Kcc/Kcs to use for the key with no parity
    DWORD cbTempKey = 0;
    ULONG cbBlockSize = 1;    // Blocksize for the given cipher
    UCHAR cbPrefixPadding = 0;   // number of bytes needed for padding out to blocksize
    ULONG cbMsg = 0;            // number of bytes in the actual message
    PBYTE pMsgPadding = NULL;   // Location of a padding byte
    ALG_ID Algid = 0;

    ULONG cbSecBufMsgPrivacy = 0;            // Number of bytes to decrypt (unseal)

#if DBG
    char szTemp[TEMPSIZE];
    ULONG  iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
#endif
    
    UNREFERENCED_PARAMETER(MessageSeqNo);    

    DebugLog((DEB_TRACE_FUNC, "DigestUserUnsealHelper: Entering\n"));

    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    
    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            pSecBufData = &pSecBuff->pBuffers[Index];
        }
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_STREAM)
        {
            pSecBufStream = &pSecBuff->pBuffers[Index];
        }
    }

    // Must be for decrypt/verify
    if ((!pSecBufStream) || (!pSecBufStream->cbBuffer))
    {   // If no SECBUFFER_STREAM, use SECBUFFER_DATA
        pSecBufMsg = pSecBufData;
    }
    else
    {
        pSecBufMsg = pSecBufStream;
    }

    if (!pSecBufMsg || (!ContextIsTokenOK(pSecBufMsg, 0)) || (pSecBufMsg->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: ContextIsTokenOK (SecBufMsg) decrypt/verify failed  0x%x\n", Status));
        goto CleanUp;
    }
    
    // Strip off the MsgType and the Sequence Number
    cbSecBufMsgPrivacy = pSecBufMsg->cbBuffer - (SASL_MAC_MSG_SIZE + SASL_MAC_SEQ_SIZE);

    if (!pSecBufMsg || !ContextIsTokenOK(pSecBufMsg, 0) || (pSecBufMsg->cbBuffer < MAC_BLOCK_SIZE))
    {
        Status = SEC_E_BUFFER_TOO_SMALL;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: ContextIsTokenOK (SignatureToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Determine the sequence number & Constant Key Sring to utilize acting as the server
    if (bServer)
    {
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_C2S_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_C2S_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Signing in Server Mode (Message StoC)  SeqNum %d\n", *pdwSeqNum));
    }
    else
    {             // acting as the client
        pdwSeqNum = &(pContext->dwRecvSeqNum);
        RtlInitString(&strcSignKeyConst, SASL_S2C_SIGN_KEY);
        RtlInitString(&strcSealKeyConst, SASL_S2C_SEAL_KEY);
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Signing in Client Mode (Message CtoS)  SeqNum %d\n", *pdwSeqNum));
    }

    // Based on the Cypher selected - establish the byte count parameters - magic numbers from RFC

    if (pContext->typeCipher == CIPHER_RC4)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_40)
    {
        cbHA1n = 5;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_RC4_56)
    {
        cbHA1n = 7;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        Algid = CALG_RC4;
    }
    else if (pContext->typeCipher == CIPHER_DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 8;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 7;
        cbBlockSize = 8;  // DES uses a blocksize of 8
        Algid = CALG_DES;
    }
    else if (pContext->typeCipher == CIPHER_3DES)
    {
        cbHA1n = 16;    // RFC 2831 sect 2.4
        cbKey = 16;    // number of bytes to use from Kcc/Kcs
        cbKeyNoParity = 14;
        cbBlockSize = 8;  // DES uses a blocksize of 8
        Algid = CALG_3DES_112;
    }
    else
    {
        Status = SEC_E_CRYPTO_SYSTEM_INVALID;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: ContextIsTokenOK (SecBufMsg) failed  0x%x\n", Status));
        goto CleanUp;
    }

        // Decrypt the message, padding and first SASL_MAC_HMAC_SIZE (10) bytes of HMAC (the integrity value)

    // Compute Kc for encryption (seal)
    if (pContext->hUnsealCryptKey == NULL)
    {
        ASSERT(*pdwSeqNum == 0);
        // Compute on first time call to encrypt - save for other sequence numbers
        Status = CalculateKc(pContext->bSessionKey, cbHA1n, &strcSealKeyConst, pContext->bKcUnsealHashData);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }

        // code to expand the DES key into multiple of 8 bytes (key with parity)
        if ((pContext->typeCipher == CIPHER_DES) || (pContext->typeCipher == CIPHER_3DES))
        {
            Status = AddDESParity(pContext->bKcUnsealHashData,
                                  cbKeyNoParity,
                                  bKcTempData,
                                  &cbTempKey);
            if (!NT_SUCCESS (Status))
            {
                DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in AddDESParity   status 0x%x\n", Status));
                goto CleanUp;
            }
            // replace with DES parity version
            ASSERT(cbKey == cbTempKey);
            memcpy(pContext->bUnsealKey, bKcTempData, cbKey);
            pbIV = &(pContext->bKcUnsealHashData[8]);
        }
        else
        {
            // For RC4 ciphers
            memcpy(pContext->bUnsealKey, pContext->bKcUnsealHashData, MD5_HASH_BYTESIZE);
            pbIV = NULL;
        }

        //  generate the symmetric key from the cleartext
        Status = CreateSymmetricKey(Algid, cbKey, pContext->bUnsealKey, pbIV, &pContext->hUnsealCryptKey);
        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in CalculateKc   status 0x%x\n", Status));
            goto CleanUp;
        }
    }


    if ((pContext->typeCipher == CIPHER_3DES) || (pContext->typeCipher == CIPHER_DES))
    {

             // Specify IV  - take only the last 8 bytes per RFC 2831 sect 2.4
        Status = DecryptData(pContext->hUnsealCryptKey, cbSecBufMsgPrivacy,
                             (PUCHAR)pSecBufMsg->pvBuffer);

        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in DecryptData   status 0x%x\n", Status));
            goto CleanUp;
        }

        // Padding length is indicated in the actual padding - get the pad byte near HMAC
        if (pSecBufMsg->cbBuffer  < (MAC_BLOCK_SIZE + 1))
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Determining padding not enough space   status 0x%x\n", Status));
            goto CleanUp;
        }
        pMsgPadding =  (PBYTE)pSecBufMsg->pvBuffer + (pSecBufMsg->cbBuffer - (MAC_BLOCK_SIZE + 1));

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        if ((MAC_BLOCK_SIZE + 1) < iTempLen)
        {
            iTempLen = (MAC_BLOCK_SIZE + 1);
        }
        BinToHex(pMsgPadding, iTempLen, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "DecryptData: HMAC & padding byte Data bytes (%dof%d bytes) %s\n",
                      iTempLen, (MAC_BLOCK_SIZE + 1), szTemp));
        }
        DebugLog((DEB_TRACE, "DecryptData:  MAC block size %d bytes\n", MAC_BLOCK_SIZE));
#endif

        cbPrefixPadding = *pMsgPadding;
        if (cbPrefixPadding > MAX_PADDING)
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Padding selected (%d) too large   status 0x%x\n",
                      cbPrefixPadding, Status));
            goto CleanUp;
        }

        if (pSecBufMsg->cbBuffer  < (MAC_BLOCK_SIZE + cbPrefixPadding))
        {
            Status = STATUS_INTERNAL_ERROR;
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Message incorrect length   status 0x%x\n", Status));
            goto CleanUp;
        }
        cbMsg = pSecBufMsg->cbBuffer - (MAC_BLOCK_SIZE + cbPrefixPadding);

        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Padding found to be %d bytes\n", cbPrefixPadding));
    }
    else
    {
        Status = DecryptData(pContext->hUnsealCryptKey, cbSecBufMsgPrivacy,
                             (PUCHAR)pSecBufMsg->pvBuffer);

        if (!NT_SUCCESS (Status))
        {
            DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in EncryptData   status 0x%x\n", Status));
            goto CleanUp;
        }

        // There is no padding on stream ciphers, so just remove the SASL HMAC block
        cbMsg = pSecBufMsg->cbBuffer - MAC_BLOCK_SIZE;
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Stream Cipher - No padding\n"));
    }

    // Locate the beginning of the message
    pMsgHMAC =  (PBYTE)pSecBufMsg->pvBuffer + (pSecBufMsg->cbBuffer - MAC_BLOCK_SIZE);

    Status = CalculateSASLHMAC(pContext, FALSE, &strcSignKeyConst, *pdwSeqNum,
                               (PBYTE)pSecBufMsg->pvBuffer, cbMsg, &MacBlock);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: Error in CalculateSASLHMAC   status 0x%x\n", Status));
        goto CleanUp;
    }


    DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Ready to compare MacBlocks\n"));

    // Check validity of MAC block ONLY do not write it out
    memcpy(&TokenMacBlock, pMsgHMAC, MAC_BLOCK_SIZE); 
    if (MacBlock.dwSeqNumber != TokenMacBlock.dwSeqNumber)
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: SASL MAC blocks out of sequence. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    if (memcmp(&MacBlock, &TokenMacBlock, MAC_BLOCK_SIZE))
    {
        Status = SEC_E_MESSAGE_ALTERED;
        DebugLog((DEB_ERROR, "DigestUserUnsealHelper: SASL MAC blocks do not match. Failed verify.  Status 0x%x\n", Status));
#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&TokenMacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Token's HMAC-MD5 block %s\n", szTemp));
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)&MacBlock, MAC_BLOCK_SIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: TComputed HMAC-MD5 block %s\n", szTemp));
#endif
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestUserUnsealHelper: SASL MAC blocks match!\n"));
    }

    // Write out to SECBUFFERDATA the length and location of message
    if (pSecBufData)
    {
        pSecBufData->cbBuffer = cbMsg;
        pSecBufData->pvBuffer = pSecBufMsg->pvBuffer;
    }

    // completed all tasks down to here.  Need to update the sequence number
    (*pdwSeqNum)++;
    DebugLog((DEB_TRACE, "DigestUserUnsealHelper: Updated SeqNum to %d\n", *pdwSeqNum));


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserUnsealHelper: Leaving    Status 0x%x\n", Status));

    return(Status);
}


// Process the Digest information with the context info and generate any output token info
NTSTATUS NTAPI
DigestUserProcessParameters(
                           IN PDIGEST_USERCONTEXT pContext,
                           IN PDIGEST_PARAMETER pDigest,
                           OUT PSecBuffer pFirstOutputToken)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulNonceCount = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestUserProcessParameters: Entering\n"));


    // Some common input verification tests

    // We must have a noncecount specified since we specified a qop in the Challenge
    // If we decide to support no noncecount modes then we need to make sure that qop is not specified
    if (pDigest->refstrParam[MD5_AUTH_NC].Length)
    {
        Status = RtlCharToInteger(pDigest->refstrParam[MD5_AUTH_NC].Buffer, HEXBASE, &ulNonceCount);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestUserProcessParameters: Nonce Count badly formatted\n"));
            goto CleanUp;
        }
    }

    // Check nonceCount is incremented to preclude replay
    if (!(ulNonceCount > pContext->ulNC))
    {
        // We failed to verify next noncecount
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestUserProcessParameters: NonceCount failed to increment!\n"));
        goto CleanUp;
    }

    // Copy the SessionKey from the Context into the Digest Structure to verify against
    // This will have Digest Auth routines use the SessionKey rather than recompute H(A1)
    StringFree(&(pDigest->strSessionKey));
    Status = StringDuplicate(&(pDigest->strSessionKey), &(pContext->strSessionKey));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserProcessParameters: Failed to copy over SessionKey\n"));
        goto CleanUp;
    }

    // Set the type of Digest Parameters we are to process
    pDigest->typeDigest = pContext->typeDigest;
    pDigest->typeQOP = pContext->typeQOP;
    pDigest->typeAlgorithm = pContext->typeAlgorithm;
    pDigest->typeCharset = pContext->typeCharset;

    if (pContext->ulFlags & FLAG_CONTEXT_QUOTE_QOP)
    {
        pDigest->usFlags |= FLAG_QUOTE_QOP;
    }

    DigestPrint(pDigest);

    // No check locally that Digest is authentic
    Status = DigestCalculation(pDigest, NULL);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestUserProcessParameters: Oh no we FAILED Authentication!!!!\n"));
        goto CleanUp;
    }

       // Send to output buffer only if there is an output buffer
       // This allows this routine to be used in UserMode
    if (pFirstOutputToken)
    {
        Status = DigestCreateChalResp(pDigest, NULL, pFirstOutputToken);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestUserProcessParameters: Failed to create Output String\n"));
            goto CleanUp;
        }
    }

CleanUp:
    
    DebugLog((DEB_TRACE_FUNC, "DigestUserProcessParameters: Leaving   Status 0x%x\n", Status));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   DigestUnpackContext
//
//  Synopsis:   Unpack the context from LSA mode into the User mode Context
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN PDIGEST_PACKED_USERCONTEXT pPackedUserContext    -- packed Context data
//  OUT PDIGEST_USERCONTEXT pContext    -- pointer to the UserContext to unpack data into
// 
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes:  This routine is called by the LSA from ISC() and ASC() based on setting MappedContext
//     on the completion of these routines.
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
DigestUnpackContext(
    IN PDIGEST_PACKED_USERCONTEXT pPackedUserContext,
    OUT PDIGEST_USERCONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR  pucLoc = NULL;
    USHORT uNumWChars = 0;
    int iAuth = 0;

    ASSERT(pPackedUserContext);
    ASSERT(pContext);

    DebugLog((DEB_TRACE_FUNC, "DigestUnpackContext: Entering\n"));

    if (pPackedUserContext->ulFlags & FLAG_CONTEXT_PARTIAL)
    {
        // This partial context has no real data that we must process so just leave context alone for now
        // This is needed for proper ref counting
        DebugLog((DEB_TRACE, "DigestUnpackContext: partial context - no unpack needed  context 0x%x\n",
                  pContext->LsaContext ));
        pContext->ulFlags = pPackedUserContext->ulFlags;
        goto CleanUp;
    }

    if (pContext->ulFlags & FLAG_CONTEXT_PARTIAL)
    {
        DebugLog((DEB_TRACE, "DigestUnpackContext: Completing partial context to full context\n" ));
    }
    
    //
    // We now pass explicit flags to indicate ASC or ISC context
    // Right now FLAG_CONTEXT_PARTIAL will catch ASC calls without a ClientTokenHandle,
    // but this explicit check is better than checking on the TokenHandle should some ASC update calls not provide
    // a TokenHandle
    //
    if (pPackedUserContext->ulFlags & FLAG_CONTEXT_SERVER)
    {
        DebugLog((DEB_TRACE, "DigestUnpackContext: Called from ASC\n" ));
        if (pPackedUserContext->ClientTokenHandle != NULL)
        {
            ASSERT(pContext->ClientTokenHandle == NULL);
            pContext->ClientTokenHandle = (HANDLE) ((ULONG_PTR)pPackedUserContext->ClientTokenHandle);
            if (FAILED(SspCreateTokenDacl(pContext->ClientTokenHandle)))
            {
                Status = STATUS_INVALID_HANDLE;
                DebugLog((DEB_ERROR, "DigestUnpackContext: SspCreateTokenDacl failed\n" ));
                goto CleanUp;
            }
            DebugLog((DEB_TRACE, "DigestUnpackContext: SspCreateTokenDacl has created the DACL\n" ));
        }
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestUnpackContext: Called from ISC\n" ));
    }

    //
    // Copy over all of the other fields - some data might be binary so
    // use RtlCopyMemory(Dest, Src, len)
    //
    pContext->ExpirationTime = pPackedUserContext->ExpirationTime;
    pContext->typeAlgorithm = (ALGORITHM_TYPE)pPackedUserContext->typeAlgorithm;
    pContext->typeCharset = (CHARSET_TYPE)pPackedUserContext->typeCharset;
    pContext->typeCipher = (CIPHER_TYPE)pPackedUserContext->typeCipher;
    pContext->typeDigest = (DIGEST_TYPE)pPackedUserContext->typeDigest;
    pContext->typeQOP = (QOP_TYPE)pPackedUserContext->typeQOP;
    pContext->ulSendMaxBuf = pPackedUserContext->ulSendMaxBuf;
    pContext->ulRecvMaxBuf = pPackedUserContext->ulRecvMaxBuf;
    pContext->ContextReq = pPackedUserContext->ContextReq;
    pContext->CredentialUseFlags = pPackedUserContext->CredentialUseFlags;
    pContext->ulFlags = pPackedUserContext->ulFlags;

    // Now check on the strings attached
    pucLoc = &(pPackedUserContext->ucData);
    for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
    {
        if (pPackedUserContext->uDigestLen[iAuth])
        {
            Status = StringAllocate(&(pContext->strParam[iAuth]), (USHORT)pPackedUserContext->uDigestLen[iAuth]);
            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DebugLog((DEB_ERROR, "DigestUnpackContext: DigestAllocateMemory for Params returns NULL\n" ));
                goto CleanUp;
            }
            memcpy(pContext->strParam[iAuth].Buffer, pucLoc, (USHORT)pPackedUserContext->uDigestLen[iAuth]);
            pContext->strParam[iAuth].Length = (USHORT)pPackedUserContext->uDigestLen[iAuth];
            pucLoc +=  (USHORT)pPackedUserContext->uDigestLen[iAuth];
            // DebugLog((DEB_TRACE, "DigestUnpackContext: Param[%d] is length %d - %.50s\n",
            //           iAuth, pPackedUserContext->uDigestLen[iAuth], pContext->strParam[iAuth].Buffer ));
        }
    }
        // Now do the SessionKey
    if (pPackedUserContext->uSessionKeyLen)
    {
        ASSERT(pPackedUserContext->uSessionKeyLen == MD5_HASH_HEX_SIZE);
        if (pPackedUserContext->uSessionKeyLen != MD5_HASH_HEX_SIZE)
        {
            Status = STATUS_NO_USER_SESSION_KEY;
            DebugLog((DEB_ERROR, "DigestUnpackContext: Session key length incorrect\n" ));
            goto CleanUp;
        }

        Status = StringAllocate(&(pContext->strSessionKey), (USHORT)pPackedUserContext->uSessionKeyLen);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "DigestUnpackContext: DigestAllocateMemory for SessionKey returns NULL\n" ));
            goto CleanUp;
        }
        memcpy(pContext->strSessionKey.Buffer, pucLoc, pPackedUserContext->uSessionKeyLen);
        pContext->strSessionKey.Length = (USHORT)pPackedUserContext->uSessionKeyLen;
        pucLoc +=  (USHORT)pPackedUserContext->uSessionKeyLen;

        // Now determine the binary version of the SessionKey from HEX() version
        HexToBin(pContext->strSessionKey.Buffer, MD5_HASH_HEX_SIZE, pContext->bSessionKey);
    }
    
        // Now do the AccountName
    if (pPackedUserContext->uAccountNameLen)
    {
        uNumWChars = (USHORT)pPackedUserContext->uAccountNameLen / sizeof(WCHAR);
        Status = UnicodeStringAllocate(&(pContext->ustrAccountName), uNumWChars);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "DigestUnpackContext: DigestAllocateMemory for AccountName returns NULL\n" ));
            goto CleanUp;
        }
        memcpy(pContext->ustrAccountName.Buffer, pucLoc, pPackedUserContext->uAccountNameLen);
        pContext->ustrAccountName.Length = (USHORT)pPackedUserContext->uAccountNameLen;
        pucLoc +=  (USHORT)pPackedUserContext->uAccountNameLen;
    }


#if DBG2
    {
        char szTemp[TEMPSIZE];
        ZeroMemory(szTemp, TEMPSIZE);

        BinToHex(pContext->bSessionKey, MD5_HASH_BYTESIZE, szTemp);
        DebugLog((DEB_TRACE, "DigestUnpackContext: verify SessionKey %Z is binary %s\n",
                  &(pContext->strSessionKey), szTemp));
    }
#endif

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUnpackContext: Leaving       Status 0x%x\n", Status));
    return(Status);
}


// Printout the fields present in usercontext pContext
NTSTATUS
UserContextPrint(PDIGEST_USERCONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    if (!pContext)
    {
        return (STATUS_INVALID_PARAMETER); 
    }


    DebugLog((DEB_TRACE_FUNC, "UserContext:      Entering for Context Handle at 0x%x\n", pContext));

    DebugLog((DEB_TRACE, "UserContext:      NC %ld\n", pContext->ulNC));

    DebugLog((DEB_TRACE, "UserContext:      LSA Context 0x%x\n", pContext->LsaContext));


    if (pContext->typeDigest == DIGEST_CLIENT)
    {
        DebugLog((DEB_TRACE, "UserContext:       DIGEST_CLIENT\n"));
    }
    if (pContext->typeDigest == DIGEST_SERVER)
    {
        DebugLog((DEB_TRACE, "UserContext:       DIGEST_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_SERVER)
    {
        DebugLog((DEB_TRACE, "UserContext:       SASL_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_CLIENT)
    {
        DebugLog((DEB_TRACE, "UserContext:       SASL_CLIENT\n"));
    }

    if (pContext->typeQOP == AUTH)
    {
        DebugLog((DEB_TRACE, "UserContext:       QOP: AUTH\n"));
    }
    if (pContext->typeQOP == AUTH_INT)
    {
        DebugLog((DEB_TRACE, "UserContext:       QOP: AUTH_INT\n"));
    }
    if (pContext->typeQOP == AUTH_CONF)
    {
        DebugLog((DEB_TRACE, "UserContext:       QOP: AUTH_CONF\n"));
    }
    if (pContext->typeAlgorithm == MD5)
    {
        DebugLog((DEB_TRACE, "UserContext:       Algorithm: MD5\n"));
    }
    if (pContext->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "UserContext:       Algorithm: MD5_SESS\n"));
    }


    if (pContext->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "UserContext:       Charset: ISO 8859-1\n"));
    }
    if (pContext->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "UserContext:       Charset: UTF-8\n"));
    }

    if (pContext->typeCipher == CIPHER_RC4)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_RC4\n"));
    }
    else if (pContext->typeCipher == CIPHER_RC4_40)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_RC4_40\n"));
    }
    else if (pContext->typeCipher == CIPHER_RC4_56)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_RC4_56\n"));
    }
    else if (pContext->typeCipher == CIPHER_DES)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_DES\n"));
    }
    else if (pContext->typeCipher == CIPHER_3DES)
    {
        DebugLog((DEB_TRACE, "UserContext:       Cipher: CIPHER_3DES\n"));
    }

    DebugLog((DEB_TRACE, "UserContext:       ContextReq 0x%lx     CredentialUseFlags 0x%x\n",
              pContext->ContextReq,
              pContext->CredentialUseFlags));

    for (i=0; i < MD5_AUTH_LAST;i++)
    {
        if (pContext->strParam[i].Buffer &&
            pContext->strParam[i].Length)
        {
            DebugLog((DEB_TRACE, "UserContext:       Digest[%d] = \"%Z\"\n", i,  &pContext->strParam[i]));
        }
    }

    if (pContext->strSessionKey.Length)
    {
        DebugLog((DEB_TRACE, "UserContext:      SessionKey %.10Z*********\n", &pContext->strSessionKey));
    }

    if (pContext->ustrAccountName.Length)
    {
        DebugLog((DEB_TRACE, "UserContext:      AccountName %wZ\n", &pContext->ustrAccountName));
    }

    DebugLog((DEB_TRACE_FUNC, "UserContext:      Leaving\n"));

    return(Status);
}

// CryptoAPI function support

NTSTATUS
SEC_ENTRY
CreateSymmetricKey(
    IN ALG_ID     Algid,
    IN DWORD       cbKey,
    IN UCHAR      *pbKey,
    IN UCHAR      *pbIV,
    OUT HCRYPTKEY *phKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLAINTEXTBLOB PlainBlob = {0};

    DebugLog((DEB_TRACE_FUNC, "CreateSymmetricKey: Entering\n"));

    ASSERT(*phKey == NULL);

    if (cbKey > MD5_HASH_BYTESIZE)
    {
        DebugLog((DEB_ERROR, "CreateSymmetricKey: Shared key too long\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }

#if DBG
        char szTemp[TEMPSIZE];
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(pbKey, cbKey, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CreateSymmetricKey: Creating symmetric for  %s\n", szTemp));
        }
#endif

    PlainBlob.Blob.bType = PLAINTEXTKEYBLOB;
    PlainBlob.Blob.bVersion = CUR_BLOB_VERSION;
    PlainBlob.Blob.reserved = 0;
    PlainBlob.Blob.aiKeyAlg = Algid;
    memcpy(PlainBlob.bKey, pbKey, cbKey);
    PlainBlob.dwKeyLen = cbKey;


    // import thw simpleblob to get a handle to the symmetric key
    if (!CryptImportKey(g_hCryptProv,
                        (BYTE *)&PlainBlob,
                        sizeof(PlainBlob),
                        0,
                        0,
                        phKey))
    {
        DebugLog((DEB_ERROR, "CreateSymmetricKey: CryptImportKey failed     error 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
    }


    if ((Algid == CALG_DES) || (Algid == CALG_3DES_112))
    {

       if (!pbIV)
       {
           DebugLog((DEB_WARN, "CreateSymmetricKey: No IV selected for DES\n"));
       }
       else
       {
#if DBG
                // Now convert the Hash to Hex  - for TESTING ONLY
           ZeroMemory(szTemp, TEMPSIZE);
           BinToHex(pbIV, 8, szTemp);
           if (szTemp)
           {
               DebugLog((DEB_TRACE, "CreateSymmetricKey: IV bytes set to  %s\n", szTemp));
           }
#endif
           if (!CryptSetKeyParam(*phKey, KP_IV, pbIV, 0))
           {
               DebugLog((DEB_ERROR, "CreateSymmetricKey:CryptSetKeyParam() failed : 0x%x\n", GetLastError()));
               Status = STATUS_INTERNAL_ERROR;
               goto CleanUp;
           }
       }

    }

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "CreateSymmetricKey: Leaving     status 0x%x\n", Status));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   EncryptData2Multi
//
//  Synopsis:   Encrypt a data buffers
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   hKey               -- symmetric key to utilize
//  IN   cbBlocklength      -- natural block length for encoding (RC will be 1 and DES will be 8)
//  IN   pSecBuff           -- SecBuffer list containing data buffers to encrypt
//  IN   cbSignature        -- number of signature bytes to encrypt after Data is encrypted
//  IN   pbSignature        -- number of bytes in signature to encrypt
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
EncryptData2Multi(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbBlocklength,
    IN PSecBufferDesc pSecBuff,    // List of databuffers to Encrypt. May be 1 or more SecBuffers
    IN ULONG      cbSignature,
    IN OUT UCHAR  *pbSignature
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    cbBlocks = 0;
    ULONG    cbDataExtra = 0;
    ULONG    cbDataBytesUsed = 0;        // Number of bytes already processed from current buffer (data or padding SecBuffer)
    PBYTE    pbData = NULL;              // location for start of extra memory bytes
    ULONG    ulIndex = 0;
    BOOL     fDataBuffers = TRUE;
    DWORD    dwBytesEncrypt = 0;

    DebugLog((DEB_TRACE_FUNC, "EncryptData2Multi: Entering\n"));

    ASSERT(pSecBuff);
    ASSERT(pbSignature);

    // Scan through the SecBuffer list for data buffers to encrypt
    // Currently look at SecBUffer[Index] and increment Index over all SecBuffers
    cbDataBytesUsed = 0;              // Number of databytes already processed in current buffer
    while (fDataBuffers == TRUE)
    {
        if (ulIndex < pSecBuff->cBuffers)
        {
            // Locate a SecBuffer Data that has data to encrypt
            if ((pSecBuff->pBuffers[ulIndex].BufferType != SECBUFFER_DATA) ||
                (!pSecBuff->pBuffers[ulIndex].cbBuffer))
            {
                ulIndex++;    // Inspect the next SecBuffer
                continue;   // restart while loop
            }
        }
        else
        {
            // No more SecBuffers Data to process
            fDataBuffers = FALSE;
            continue;
        }

        // If SecBuffer Data size greater than zero, encrypt maximum multiple of blockcount
        DebugLog((DEB_TRACE, "EncryptData2Multi: located buffer %d   %ld bytes to encrypt\n",
                  ulIndex, (pSecBuff->pBuffers[ulIndex].cbBuffer - cbDataBytesUsed)));
        ASSERT(cbDataBytesUsed < cbBlocklength);                   // should always have used less than blocksize bytes 
        // Identify if there are extra bytes beyond blocksize for cipher
        cbBlocks = (pSecBuff->pBuffers[ulIndex].cbBuffer - cbDataBytesUsed) / cbBlocklength;    // integer division
        cbDataExtra =  (pSecBuff->pBuffers[ulIndex].cbBuffer - cbDataBytesUsed) - (cbBlocklength * cbBlocks);

        DebugLog((DEB_TRACE, "EncryptData2Multi: in buffer %lu  blocks %lu   extrbytes %lu\n",
                  ulIndex, cbBlocks, cbDataExtra));

        // If there are blocks to encrypt - do that
        if (cbBlocks)
        {
            dwBytesEncrypt = cbBlocklength * cbBlocks;
            DebugLog((DEB_TRACE, "EncryptData2Multi:    buffer %lu  start at %lu   length %lu\n", 
                      ulIndex, cbDataBytesUsed, dwBytesEncrypt));
            pbData = (PBYTE)pSecBuff->pBuffers[ulIndex].pvBuffer + cbDataBytesUsed;
            if (!CryptEncrypt(hKey, 0, FALSE, 0, pbData, &dwBytesEncrypt, dwBytesEncrypt))
            {
                DebugLog((DEB_ERROR, "EncryptData2Multi:CryptEncrypt first buffer (blocklength) failed : 0x%x\n", GetLastError()));
                Status = STATUS_INTERNAL_ERROR;
                goto CleanUp;
            }
            cbDataBytesUsed = cbDataBytesUsed + dwBytesEncrypt;
        }
        
        // Handle the extra bytes not block encrypted
        if (cbDataExtra)
        {
            // This will have to link potentially multiple SecBuffers or the Padding to fill in a blocklength
            // of data to encrypt.  The value of ulIndex and cbDataBytesUsed can change.  If ulIndex points outside
            // range of SecBuffers, then cbDataBytesUsed value refers to the padding SecBuffer state.
            DebugLog((DEB_TRACE, "EncryptData2Multi:    buffer %lu has %lu bytes to process. Use link.\n", 
                      ulIndex, cbDataExtra));
            Status = LinkBuffersToEncrypt(hKey, cbBlocklength, pSecBuff, &ulIndex, &cbDataBytesUsed, pbSignature, cbSignature); 
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "EncryptData2Multi: LinkBuffer failed   0x%x\n", Status ));
                goto CleanUp;
            }

        }
        else
        {
            // No extra bytes in this SecBuffer to process, go to next Buffer
            ulIndex++;
            cbDataBytesUsed = 0;
        }

    }

    // Encrypt remaining bytes in signature - assert that it must be a multiple of blocksize
    DebugLog((DEB_TRACE, "EncryptData2Multi:  Now process Signature buffer. link processed %lu of %lu bytes already\n", 
              cbDataBytesUsed, cbSignature));
    ASSERT(cbDataBytesUsed < cbSignature);
    dwBytesEncrypt = cbSignature - cbDataBytesUsed;

    DebugLog((DEB_TRACE, "EncryptData2Multi:  Encrypt %lu signature bytes\n", dwBytesEncrypt));
    if (!CryptEncrypt(hKey, 0, FALSE, 0, (pbSignature + cbDataBytesUsed), &dwBytesEncrypt, dwBytesEncrypt))
    {
        DebugLog((DEB_ERROR, "EncryptData2Multi:CryptEncrypt one buffer failed : 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "EncryptData2Multi: Leaving     status 0x%x\n", Status));

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   LinkBuffersToEncrypt
//
//  Synopsis:   Encrypt the boundary bytes that span over multiple data SecBuffers and Padding
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   hKey               -- symmetric key to utilize
//  IN   cbBlocklength      -- BlockLength for symmetric cipher (should be greater than 1)
//  IN   pSecBuff           -- pointer to SecBuffers containing data to encrypt
//  IN OUT pSecBuff         -- pointer to current SecBuffer to process (must be a Data buffer)
//  IN OUT pulIndex         -- pointer to current SecBuffer to process (must be a Data buffer)
//  IN OUT pcbDataBytesUsed -- pointer to number of bytes processed in current SecBuffer
//  IN   pbSignature        -- pointer to buffer for signature block (contains padding plus HMAC)
//  IN   cbSignature        -- number of bytes in signature block
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes:  This function will handle the blocklength encryption boundaries between data SecBuffers and
//    the padding bytes.  The value
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
LinkBuffersToEncrypt(
    IN HCRYPTKEY  hKey,
    IN ULONG cbBlocklength,
    IN PSecBufferDesc pSecBuff,
    IN OUT PULONG pulIndex,
    IN OUT PULONG pcbDataBytesUsed,
    IN PUCHAR pbSignature,
    IN ULONG  cbSignature)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE    pbTempBuff = NULL;             // temp alloc for merge of cross buffer bytes (sized to BlockLength)
    ULONG    cbTempBuff = 0;
    ULONG    ulScanIndex = 0;               // scan along the SecBuffers
    ULONG    cbScanDataBytesUsed = 0;       // number of bytes used in ulScanIndex's SecBuffer
    ULONG    cbScanDataBytesLeft = 0;       // number of bytes remaining in ulScanIndex's SecBuffer
    DWORD    dwBytesEncrypt = 0;
    ULONG    cbBytesNeeded = 0;
    PBYTE    pbSecBuff = NULL;

    DebugLog((DEB_TRACE_FUNC, "LinkBuffersToEncrypt: Entering\n"));

    ASSERT(cbBlocklength > 1);
    ASSERT(cbSignature > SASL_MAC_HMAC_SIZE);    // check to make sure that Signature inlcudes padding plus HMAC

    UNREFERENCED_PARAMETER(cbSignature);

    // Allocate memory to store cross data buffer bytes
    pbTempBuff = (PBYTE)DigestAllocateMemory(cbBlocklength);
    if (!pbTempBuff)
    {
            DebugLog((DEB_ERROR, "LinkBuffersToEncrypt:out of memory\n"));
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
    }

    // pulIndex points to the current data buffer with pcbDataBytesUsed already processed
    // Start reading in bytes to fill TempBuff up to BlockLength. Normally the next buffer in sequence (data or padding)
    // will have enough bytes to cover filling up the TempBuffer, but someone could send in a tiny buffer and cause
    // 3 or more buffers to have to be utilized

    ulScanIndex = *pulIndex;                          // set a marker to where to start processing
    cbScanDataBytesUsed = *pcbDataBytesUsed;

    // Since we were called, there must be left over bytes in SecBuffer to process
    ASSERT(cbScanDataBytesUsed < pSecBuff->pBuffers[ulScanIndex].cbBuffer);
    
    while ((cbTempBuff != cbBlocklength) && (ulScanIndex < pSecBuff->cBuffers))
    {
        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Link buffer has %lu bytes - needs %lu. Scan Buffers\n",
                  cbTempBuff, cbBlocklength));
        if ((pSecBuff->pBuffers[ulScanIndex].BufferType != SECBUFFER_DATA) ||
            (!pSecBuff->pBuffers[ulScanIndex].cbBuffer))
        {
            DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Scan skip SecBuffer Index %lu\n", ulScanIndex));
            ulScanIndex++;                // Inspect the next SecBuffer
            cbScanDataBytesUsed = 0;
            continue;                     // restart while loop
        }

        // How many bytes can we process in this buffer
        cbScanDataBytesLeft = pSecBuff->pBuffers[ulScanIndex].cbBuffer - cbScanDataBytesUsed;

        // copy over the bytes into the temp location
        cbBytesNeeded = cbBlocklength - cbTempBuff;

        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Temp buffer needs %lu bytes, SecBuffer has %lu bytes\n",
                  cbBytesNeeded, cbScanDataBytesLeft));
        pbSecBuff = (PBYTE)pSecBuff->pBuffers[ulScanIndex].pvBuffer;

        if (cbScanDataBytesLeft < cbBytesNeeded)
        {
            // Can not fill up with only this buffer - need more data buffers
            DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Can not fill Link with Index %lu. Need more data\n", ulScanIndex));
            memcpy((pbTempBuff + cbTempBuff), 
                   (pbSecBuff + cbScanDataBytesUsed),
                    cbScanDataBytesLeft);
            cbTempBuff = cbTempBuff + cbScanDataBytesLeft;
            ulScanIndex++;                  // move to next SecBuffer and for possible data
            cbScanDataBytesUsed = 0;
        }
        else
        {
            // We can fill up the reset of the Temp link Buffer with Scan SecBuffer
            DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Can fill Link with Index %lu\n", ulScanIndex));
            ASSERT(cbScanDataBytesUsed == 0);                  // this should be a new buffer to be processed
            memcpy((pbTempBuff + cbTempBuff), 
                    pbSecBuff,
                    cbBytesNeeded);
            cbTempBuff = cbTempBuff + cbBytesNeeded;
            ASSERT(cbTempBuff == cbBlocklength);      // will exit while loop now that buffer is full
            cbScanDataBytesUsed = cbBytesNeeded;      // show number of bytes already processed in new SecBuffer
        }
    }

    if (cbTempBuff < cbBlocklength)
    {
        // processesed all of the data SecBuffers - now use the padding in the Signature buffer
        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Link buffer has %lu bytes - needs %lu. Use padding.\n",
                  cbTempBuff, cbBlocklength));
        ASSERT(ulScanIndex == pSecBuff->cBuffers);           // should have exhausted all of the SecBuffers

        cbBytesNeeded = cbBlocklength - cbTempBuff;

        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Need %lu bytes from Signature buffer\n",
                  cbBytesNeeded));
        memcpy((pbTempBuff + cbTempBuff), 
                pbSignature,
                cbBytesNeeded);
        cbTempBuff = cbTempBuff + cbBytesNeeded;
        cbScanDataBytesUsed = cbBytesNeeded;
    }

    // We now should have a full link buffer to encrypt
    ASSERT(cbTempBuff == cbBlocklength);
    
    dwBytesEncrypt = cbBlocklength;
    if (!CryptEncrypt(hKey, 0, FALSE, 0, pbTempBuff, &dwBytesEncrypt, cbBlocklength))
    {
        DebugLog((DEB_ERROR, "LinkBuffersToEncrypt:CryptEncrypt link buffer failed : 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }
    DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: encrypted link buffer\n"));


    // Now place data back into proper locations - perform same operations as above but put data back
    ulScanIndex = *pulIndex;                          // set a marker to where to start processing
    cbScanDataBytesUsed = *pcbDataBytesUsed;
    cbTempBuff = 0;                                  // we have placed zero bytes back into SecBuffers

    // Since we were called, there must be left over bytes in SecBuffer to process
    ASSERT(cbScanDataBytesUsed < pSecBuff->pBuffers[ulScanIndex].cbBuffer);
    
    while ((cbTempBuff != cbBlocklength) && (ulScanIndex < pSecBuff->cBuffers))
    {
        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: (put)Link buffer has %lu bytes - needs %lu. Scan Buffers\n",
                  cbTempBuff, cbBlocklength));
        if ((pSecBuff->pBuffers[ulScanIndex].BufferType != SECBUFFER_DATA) ||
            (!pSecBuff->pBuffers[ulScanIndex].cbBuffer))
        {
            DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: (put)Scan skip SecBuffer Index %lu\n", ulScanIndex));
            ulScanIndex++;                // Inspect the next SecBuffer
            cbScanDataBytesUsed = 0;
            continue;                     // restart while loop
        }

        // How many bytes can we process in this buffer
        cbScanDataBytesLeft = pSecBuff->pBuffers[ulScanIndex].cbBuffer - cbScanDataBytesUsed;

        // copy over the bytes into the temp location
        cbBytesNeeded = cbBlocklength - cbTempBuff;

        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: (put)Temp buffer needs %lu bytes, SecBuffer has %lu bytes\n",
                  cbBytesNeeded, cbScanDataBytesLeft));
        pbSecBuff = (PBYTE)pSecBuff->pBuffers[ulScanIndex].pvBuffer;

        if (cbScanDataBytesLeft < cbBytesNeeded)
        {
            // Can not fill up with only this buffer - need more data buffers
            DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Can not place Link into Index %lu. Need more data\n", ulScanIndex));
            memcpy((pbSecBuff + cbScanDataBytesUsed),
                   (pbTempBuff + cbTempBuff),                    
                    cbScanDataBytesLeft);
            cbTempBuff = cbTempBuff + cbScanDataBytesLeft;
            ulScanIndex++;                  // move to next SecBuffer and for possible data
            cbScanDataBytesUsed = 0;
        }
        else
        {
            // We can fill up the reset of the Temp link Buffer with Scan SecBuffer
            DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Can place Link into Index %lu\n", ulScanIndex));
            ASSERT(cbScanDataBytesUsed == 0);                  // this should be a new buffer to be processed
            memcpy(pbSecBuff,
                   (pbTempBuff + cbTempBuff),                   
                    cbBytesNeeded);
            cbTempBuff = cbTempBuff + cbBytesNeeded;
            ASSERT(cbTempBuff == cbBlocklength);      // will exit while loop now that buffer is full
            cbScanDataBytesUsed = cbBytesNeeded;      // show number of bytes already processed in new SecBuffer
        }
    }

    if (cbTempBuff < cbBlocklength)
    {
        // processesed all of the data SecBuffers - now use the padding in the Signature buffer
        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Link buffer has %lu bytes - needs %lu. Place into padding.\n",
                  cbTempBuff, cbBlocklength));
        ASSERT(ulScanIndex == pSecBuff->cBuffers);           // should have exhausted all of the SecBuffers

        cbBytesNeeded = cbBlocklength - cbTempBuff;

        DebugLog((DEB_TRACE, "LinkBuffersToEncrypt: Put %lu bytes into Signature buffer (should be padding bytes)\n",
                  cbBytesNeeded));
        memcpy(pbSignature,
               (pbTempBuff + cbTempBuff),               
                cbBytesNeeded);
        cbTempBuff = cbTempBuff + cbBytesNeeded;
        cbScanDataBytesUsed = cbBytesNeeded;
    }

    // Update current Index and number of DataBytesUsed
    // If ulScanIndex is equal to the number of SecBuffers, then we used padding to complete link
    *pulIndex = ulScanIndex;                          // set a marker to where finished link processing
    *pcbDataBytesUsed = cbScanDataBytesUsed;

CleanUp:

    if (pbTempBuff)
    {
        DigestFreeMemory(pbTempBuff);
        pbTempBuff = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "LinkBuffersToEncrypt: Leaving     status 0x%x\n", Status));

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   DecryptData
//
//  Synopsis:   Decrypt a data buffer
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   hKey               -- symmetric key to utilize
//  IN   cbData             -- number of data bytes to encrypt
//  IN   pbData             -- pointer to data bytes to encrypt
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS
SEC_ENTRY
DecryptData(
    IN HCRYPTKEY  hKey,
    IN ULONG      cbData,
    IN OUT UCHAR  *pbData
    )
{
    ULONG    cb = cbData;
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG
    char szTemp[TEMPSIZE];
    ULONG  iTempLen = 20;
#endif

    DebugLog((DEB_TRACE_FUNC, "DecryptData: Entering   %lu bytes at 0x%x\n", cbData, pbData));

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cbData < iTempLen)
    {
        iTempLen = cbData;
    }
    BinToHex(pbData, iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Encrypted Data bytes (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }

    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cbData < iTempLen)
    {
        iTempLen = cbData;
    }
    BinToHex((pbData + cbData - iTempLen), iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Encrypted end of buffer (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }
#endif
    
    // import the simpleblob to get a handle to the symmetric key
    if (!CryptDecrypt(hKey, 0, FALSE, 0, pbData, &cb))
    {
        DebugLog((DEB_ERROR, "DecryptData:CryptCreateHash() failed : 0x%x\n", GetLastError()));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }


#if DBG

    DebugLog((DEB_TRACE, "DecryptData:  Decrypted number of bytes %lu\n", cb));

            // Now convert the Hash to Hex  - for TESTING ONLY
    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cb < iTempLen)
    {
        iTempLen = cb;
    }
    BinToHex(pbData, iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Decrypted Data bytes (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }

    iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
    if (cb < iTempLen)
    {
        iTempLen = cb;
    }
    BinToHex((pbData + cb - iTempLen), iTempLen, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "DecryptData: Decrypted end of buffer (%dof%d bytes) %s\n",
                  iTempLen, cbData, szTemp));
    }
#endif

CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DecryptData: Leaving     status 0x%x\n", Status));

    return(Status);
}


NTSTATUS
SEC_ENTRY
CalculateSASLHMAC(
    IN PDIGEST_USERCONTEXT pContext,
    IN BOOL  fSign,
    IN PSTRING pstrSignKeyConst,
    IN DWORD dwSeqNum,                     // Sequence number to process
    IN PBYTE pData,                        // location of data to HMAC
    IN ULONG cbData,                       // How many bytes of data to process
    OUT PSASL_MAC_BLOCK pMacBlock)
{
    NTSTATUS Status = STATUS_SUCCESS;

    HCRYPTHASH hHash = NULL;
    HCRYPTKEY hCryptKey = NULL;
    HMAC_INFO hmacinfo = {0};

    BYTE bKiHashData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3
    DWORD cbKiHashData = 0;                 // Size of Message integrity keys

    BYTE bHMACData[HMAC_MD5_HASH_BYTESIZE];
    DWORD cbHMACData = 0;

#if DBG
    char szTemp[TEMPSIZE];
    ULONG  iTempLen = 20;
    ZeroMemory(szTemp, TEMPSIZE);
#endif

    ASSERT(pMacBlock);


    DebugLog((DEB_TRACE_FUNC, "CalculateSASLHMAC: Entering\n"));
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Processing %d bytes in data block\n", cbData));

    // Clear the output
    ZeroMemory(pMacBlock, sizeof(SASL_MAC_BLOCK));

    // Initialize local variables
    ZeroMemory(bKiHashData, MD5_HASH_BYTESIZE);
    ZeroMemory(bHMACData, HMAC_MD5_HASH_BYTESIZE);


    // Always do an integrety calculation on the input data
    // We should have clear text data at this stage
    if (!dwSeqNum)
    {
        if ( !CryptCreateHash( g_hCryptProv,
                               CALG_MD5,
                               0,
                               0,
                               &hHash ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptCreateHash failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pContext->bSessionKey,
                             MD5_HASH_BYTESIZE,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptHashData failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if (pstrSignKeyConst->Length)
        {
            if ( !CryptHashData( hHash,
                                 (const unsigned char *)pstrSignKeyConst->Buffer,
                                 pstrSignKeyConst->Length,
                                 0 ) )
            {
                DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptHashData failed : 0x%lx\n", GetLastError()));
                Status = STATUS_ENCRYPTION_FAILED;
                goto CleanUp;
            }
        }

        cbKiHashData = MD5_HASH_BYTESIZE;
        if ( !CryptGetHashParam( hHash,
                                 HP_HASHVAL,
                                 bKiHashData,
                                 &cbKiHashData,
                                 0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: CryptGetHashParam failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        CryptDestroyHash( hHash );
        hHash = NULL;

        ASSERT(cbKiHashData == MD5_HASH_BYTESIZE);

        // save the key for later sign/verify use
        if (fSign == TRUE)
        {
            memcpy(pContext->bKiSignHashData, bKiHashData, MD5_HASH_BYTESIZE);
        }
        else
        {
            memcpy(pContext->bKiVerifyHashData, bKiHashData, MD5_HASH_BYTESIZE);
        }

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(bKiHashData, MD5_HASH_BYTESIZE, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: Calculated Ki hash is %s\n", szTemp));
        }
#endif

    }
    else
    {
        // retrieve it from the saved context info
        if (fSign == TRUE)
        {
            memcpy(bKiHashData, pContext->bKiSignHashData, MD5_HASH_BYTESIZE);
        }
        else
        {
            memcpy(bKiHashData, pContext->bKiVerifyHashData, MD5_HASH_BYTESIZE);
        }
        cbKiHashData = MD5_HASH_BYTESIZE;
#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(bKiHashData, MD5_HASH_BYTESIZE, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: Ki retrieved from context is %s\n", szTemp));
        }
#endif

    }

    DebugLog((DEB_TRACE, "CalculateSASLHMAC: Ready to start the HMAC calculation\n"));

    // We now have Kic or Kis depending on if we are running as server or client
    // Now calculate the SASL_MAC_BLOCK structure to compare or set for message

    pMacBlock->wMsgType    = htons(1);
    pMacBlock->dwSeqNumber = htonl(dwSeqNum);
    
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: SeqNumber is %ld\n", dwSeqNum));


    // Need to create the symmetric key from the cleartext shared secret
    // Specified CALC_RC4 since we need to provide a valid encrypt type for import key
    // not actually utilized when we do the HMAC which is simply a hash function
    Status = CreateSymmetricKey(CALG_RC4, MD5_HASH_BYTESIZE, bKiHashData, NULL, &hCryptKey);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: Error in CreateSymmetricKey     Status 0x%x\n", Status));
        goto CleanUp;
    }

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_HMAC,
                           hCryptKey,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    hmacinfo.HashAlgid = CALG_MD5;     // Use MD5 as the hashing function for the HMAC
    hmacinfo.cbOuterString = 0;        // use default 64 byte outerstring
    hmacinfo.cbInnerString = 0;        // use default 64 byte innerstring

    if ( !CryptSetHashParam( hHash,
                           HP_HMAC_INFO,
                           (PBYTE)&hmacinfo,
                           0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptSetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }
           // Prepend SeqNum to the data stream to perform HMAC on
           //  Need to form the network order version first

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex((PUCHAR)&pMacBlock->dwSeqNumber, sizeof(DWORD), szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC component SeqNum %s\n", szTemp));
        }
#endif
    if ( !CryptHashData( hHash,
                         (const unsigned char *)&pMacBlock->dwSeqNumber,
                         sizeof(DWORD),
                         0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptHashData failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    // Now HMAC the data to protect

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        if (cbData < iTempLen)
        {
            iTempLen = cbData;
        }
        BinToHex(pData, iTempLen, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC component Data (%dof%d bytes) %s\n",
                      iTempLen, cbData, szTemp));
        }
#endif
    if (cbData)
    {
        if ( !CryptHashData( hHash,
                             pData,
                             cbData,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptHashData failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    cbHMACData = HMAC_MD5_HASH_BYTESIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             bHMACData,
                             &cbHMACData,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC CryptGetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC hash length  %d bytes\n", cbHMACData));
    ASSERT(cbHMACData == HMAC_MD5_HASH_BYTESIZE);

    CryptDestroyKey( hCryptKey );
    hCryptKey = NULL;

    CryptDestroyHash( hHash );
    hHash = NULL;


    // We now have the HMAC so form up the MAC block for SASL

    // Now convert the Hash to Hex  - for TESTING ONLY
    if (cbHMACData != HMAC_MD5_HASH_BYTESIZE)
    {
        // This should never happen
        DebugLog((DEB_ERROR, "CalculateSASLHMAC: HMAC-MD5 result length incorrect\n"));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex(bHMACData, HMAC_MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC-MD5 is %s\n", szTemp));
#endif

    memcpy(pMacBlock->hmacMD5, bHMACData, SASL_MAC_HMAC_SIZE);

#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)pMacBlock, HMAC_MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMAC: HMAC-MD5 block is %s\n", szTemp));
#endif


CleanUp:

        // Release Key resources
    if (hCryptKey)
    {
        CryptDestroyKey( hCryptKey );
        hCryptKey = NULL;
    }
        // Release Hash resources
    if (hHash)
    {
        CryptDestroyHash( hHash );
        hHash = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "CalculateSASLHMAC: Leaving     status 0x%x\n", Status));

    return(Status);
}




NTSTATUS
SEC_ENTRY
CalculateKc(
    IN PBYTE pbSessionKey,
    IN USHORT cbHA1n,
    IN PSTRING pstrSealKeyConst,
    IN PBYTE pHashData)                    // MD5 hash for Kc
{
    NTSTATUS Status = STATUS_SUCCESS;

    HCRYPTHASH hHash = NULL;

    DWORD cbKcHashData = 0;                 // Size of Message integrity keys

    ASSERT(cbHA1n <= MD5_HASH_BYTESIZE);
    ASSERT(cbHA1n > 0);

    DebugLog((DEB_TRACE_FUNC, "CalculateKc: Entering\n"));

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);

    BinToHex(pbSessionKey, MD5_HASH_BYTESIZE, szTemp);

    DebugLog((DEB_TRACE_FUNC, "CalculateKc: Binary SessionKey %s\n", szTemp));
    DebugLog((DEB_TRACE_FUNC, "CalculateKc: cbHA1n %d\n", cbHA1n));
    DebugLog((DEB_TRACE_FUNC, "CalculateKc: SealKeyConst %Z\n", pstrSealKeyConst));
#endif


    // Clear the output
    ZeroMemory(pHashData, MD5_HASH_BYTESIZE);


    // Kc = MD5( {H(A1)[0...cbHA1n], ConstantString})    take only the first cbHA1n bytes of H(A1)
    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "CalculateKc: CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    if ( !CryptHashData( hHash,
                         (const unsigned char *)pbSessionKey,
                         cbHA1n,
                         0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateKc: CryptHashData failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    if (pstrSealKeyConst->Length)
    {
        if ( !CryptHashData( hHash,
                             (const unsigned char *)pstrSealKeyConst->Buffer,
                             pstrSealKeyConst->Length,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateKc: CryptHashData failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }
    }

    cbKcHashData = MD5_HASH_BYTESIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pHashData,
                             &cbKcHashData,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateKc: CryptGetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    CryptDestroyHash( hHash );
    hHash = NULL;

    DebugLog((DEB_TRACE, "CalculateKc: readback hash with %d bytes\n", cbKcHashData));

#if DBG
        // Now convert the Hash to Hex  - for TESTING ONLY
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex(pHashData, MD5_HASH_BYTESIZE, szTemp);

    if (szTemp)
    {
        DebugLog((DEB_TRACE, "CalculateKc: Kc hash is %s\n", szTemp));
    }
#endif


CleanUp:

        // Release Hash resources
    if (hHash)
    {
        CryptDestroyHash( hHash );
        hHash = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "CalculateKc: Leaving     status 0x%x\n", Status));

    return(Status);
}




BYTE DESParityTable[] = {0x00,0x01,0x01,0x02,0x01,0x02,0x02,0x03,
                      0x01,0x02,0x02,0x03,0x02,0x03,0x03,0x04};

//
// set the parity on the DES key - ODD parity
// NOTE : must be called before deskey
// key must be cbKey number of bytes
// routine from RSA lib
//
void
SetDESParity(
        PBYTE           pbKey,
        DWORD           cbKey
        )
{
    DWORD i;

    for (i=0;i<cbKey;i++)
    {
        if (!((DESParityTable[pbKey[i]>>4] + DESParityTable[pbKey[i]&0x0F]) % 2))
            pbKey[i] = pbKey[i] ^ 0x01;
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   addDESParity
//
//  Synopsis:   This routine is called for DES plaintext keys to add in Odd parity bits
//              Input of 7 bytes will be expanded to 8bytes with parity
//              Input of 14 bytes will be expanded to 14 bytes
//
//  Effects:    no global effect.
//
//  Arguments:
//
//  IN   pbSrckey              -- buffer with key to expand
//  IN   cbKey             -- size of input non-parity expanded key
//  OUT   pbOutputkey              -- buffer with key to expand
//
//  Requires:   no global requirements
//
//  Returns:    STATUS_SUCCESS, or resource error
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS
AddDESParity(
    IN PBYTE           pbSrcKey,
    IN DWORD           cbSrcKey,
    OUT PBYTE          pbDstKey,
    OUT PDWORD          pcbDstKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(pbSrcKey);
    ASSERT(pbDstKey);
    ASSERT(pcbDstKey);

    ZeroMemory(pbDstKey, MD5_HASH_BYTESIZE);

    if ((cbSrcKey != 7) && (cbSrcKey != 14))
    {
        DebugLog((DEB_ERROR, "AddDESParity: wrong input size buffer\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto CleanUp;
    }


	pbDstKey[0] =  pbSrcKey[0];
    pbDstKey[1] = (pbSrcKey[1] >> 1) | ((pbSrcKey[0] & 0x01) << 7);
	pbDstKey[2] = (pbSrcKey[2] >> 2) | ((pbSrcKey[1] & 0x03) << 6);
	pbDstKey[3] = (pbSrcKey[3] >> 3) | ((pbSrcKey[2] & 0x07) << 5);
	pbDstKey[4] = (pbSrcKey[4] >> 4) | ((pbSrcKey[3] & 0x0F) << 4);
	pbDstKey[5] = (pbSrcKey[5] >> 5) | ((pbSrcKey[4] & 0x1F) << 3);
	pbDstKey[6] = (pbSrcKey[6] >> 6) | ((pbSrcKey[5] & 0x3F) << 2);
	pbDstKey[7] = (pbSrcKey[6] << 1);

    SetDESParity(pbDstKey, 8);
    *pcbDstKey = 8;

    // Now check if need to expand the 14 bytes into the full 16 byte buffer
    if (cbSrcKey == 14)
    {
        pbDstKey[0 + 8] =  pbSrcKey[0 + 7];
        pbDstKey[1 + 8] = (pbSrcKey[1 + 7] >> 1) | ((pbSrcKey[0 + 7] & 0x01) << 7);
        pbDstKey[2 + 8] = (pbSrcKey[2 + 7] >> 2) | ((pbSrcKey[1 + 7] & 0x03) << 6);
        pbDstKey[3 + 8] = (pbSrcKey[3 + 7] >> 3) | ((pbSrcKey[2 + 7] & 0x07) << 5);
        pbDstKey[4 + 8] = (pbSrcKey[4 + 7] >> 4) | ((pbSrcKey[3 + 7] & 0x0F) << 4);
        pbDstKey[5 + 8] = (pbSrcKey[5 + 7] >> 5) | ((pbSrcKey[4 + 7] & 0x1F) << 3);
        pbDstKey[6 + 8] = (pbSrcKey[6 + 7] >> 6) | ((pbSrcKey[5 + 7] & 0x3F) << 2);
        pbDstKey[7 + 8] = (pbSrcKey[6 + 7] << 1);
        SetDESParity(pbDstKey + 8, 8);
        *pcbDstKey = 16;
    }

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);

    BinToHex(pbSrcKey, (UINT)cbSrcKey, szTemp);
    DebugLog((DEB_TRACE, "AddDESParity: Key no-parity : %s\n", szTemp));


    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex(pbDstKey, (UINT)*pcbDstKey, szTemp);
    DebugLog((DEB_TRACE, "AddDESParity: Key expanded with parity : %s\n", szTemp));
#endif

CleanUp:

    return Status;
}


//+--------------------------------------------------------------------
//
//  Function:   CalculateDataCount
//
//  Synopsis:   Determine the number of data bytes to process in the SecBuffers
//            
//
//  Arguments:  pContext - UserMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//                    
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS
CalculateDataCount(
        IN PSecBufferDesc pSecBuff,
        OUT PULONG pulData
        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Index = 0;
    ULONG ulcb = 0;            // number of bytes in the actual message

    ASSERT(pulData);
    ASSERT(pSecBuff);

    for (Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            ulcb = ulcb + pSecBuff->pBuffers[Index].cbBuffer;
        }
    }

    *pulData = ulcb;

    return(Status);
}


// Multiple Data buffers in SecBuffer version of CalculateSASLHMAC
// This was added to allow LDAP server to do gather-scatter processing
NTSTATUS
SEC_ENTRY
CalculateSASLHMACMulti(
    IN PDIGEST_USERCONTEXT pContext,
    IN BOOL  fSign,
    IN PSTRING pstrSignKeyConst,
    IN DWORD dwSeqNum,                     // Sequence number to process
    IN PSecBufferDesc pSecBuff,            // location of data buffers to HMAC
    OUT PSASL_MAC_BLOCK pMacBlock)
{
    NTSTATUS Status = STATUS_SUCCESS;

    HCRYPTHASH hHash = NULL;
    HCRYPTKEY hCryptKey = NULL;
    HMAC_INFO hmacinfo = {0};

    BYTE bKiHashData[MD5_HASH_BYTESIZE];    // Message integrity keys RFC 2831 sec 2.3
    DWORD cbKiHashData = 0;                 // Size of Message integrity keys

    BYTE bHMACData[HMAC_MD5_HASH_BYTESIZE];
    DWORD cbHMACData = 0;

#if DBG
    char szTemp[TEMPSIZE];
    ZeroMemory(szTemp, TEMPSIZE);
#endif


    DebugLog((DEB_TRACE_FUNC, "CalculateSASLHMACMulti: Entering\n"));

    // Clear the output
    ZeroMemory(pMacBlock, sizeof(SASL_MAC_BLOCK));

    // Initialize local variables
    ZeroMemory(bKiHashData, MD5_HASH_BYTESIZE);
    ZeroMemory(bHMACData, HMAC_MD5_HASH_BYTESIZE);


    // Always do an integrety calculation on the input data
    // We should have clear text data at this stage
    if (!dwSeqNum)
    {
        if ( !CryptCreateHash( g_hCryptProv,
                               CALG_MD5,
                               0,
                               0,
                               &hHash ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: CryptCreateHash failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if ( !CryptHashData( hHash,
                             (const unsigned char *)pContext->bSessionKey,
                             MD5_HASH_BYTESIZE,
                             0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: CryptHashData failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        if (pstrSignKeyConst->Length)
        {
            if ( !CryptHashData( hHash,
                                 (const unsigned char *)pstrSignKeyConst->Buffer,
                                 pstrSignKeyConst->Length,
                                 0 ) )
            {
                DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: CryptHashData failed : 0x%lx\n", GetLastError()));
                Status = STATUS_ENCRYPTION_FAILED;
                goto CleanUp;
            }
        }

        cbKiHashData = MD5_HASH_BYTESIZE;
        if ( !CryptGetHashParam( hHash,
                                 HP_HASHVAL,
                                 bKiHashData,
                                 &cbKiHashData,
                                 0 ) )
        {
            DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: CryptGetHashParam failed : 0x%lx\n", GetLastError()));
            Status = STATUS_ENCRYPTION_FAILED;
            goto CleanUp;
        }

        CryptDestroyHash( hHash );
        hHash = NULL;

        ASSERT(cbKiHashData == MD5_HASH_BYTESIZE);

        // save the key for later sign/verify use
        if (fSign == TRUE)
        {
            memcpy(pContext->bKiSignHashData, bKiHashData, MD5_HASH_BYTESIZE);
        }
        else
        {
            memcpy(pContext->bKiVerifyHashData, bKiHashData, MD5_HASH_BYTESIZE);
        }

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(bKiHashData, MD5_HASH_BYTESIZE, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: Calculated Ki hash is %s\n", szTemp));
        }
#endif

    }
    else
    {
        // retrieve it from the saved context info
        if (fSign == TRUE)
        {
            memcpy(bKiHashData, pContext->bKiSignHashData, MD5_HASH_BYTESIZE);
        }
        else
        {
            memcpy(bKiHashData, pContext->bKiVerifyHashData, MD5_HASH_BYTESIZE);
        }
        cbKiHashData = MD5_HASH_BYTESIZE;
#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex(bKiHashData, MD5_HASH_BYTESIZE, szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: Ki retrieved from context is %s\n", szTemp));
        }
#endif

    }

    DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: Ready to start the HMAC calculation\n"));

    // We now have Kic or Kis depending on if we are running as server or client
    // Now calculate the SASL_MAC_BLOCK structure to compare or set for message

    pMacBlock->wMsgType    = htons(1);
    pMacBlock->dwSeqNumber = htonl(dwSeqNum);
    
    DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: SeqNumber is %ld\n", dwSeqNum));


    // Need to create the symmetric key from the cleartext shared secret
    // Specified CALC_RC4 since we need to provide a valid encrypt type for import key
    // not actually utilized when we do the HMAC which is simply a hash function
    Status = CreateSymmetricKey(CALG_RC4, MD5_HASH_BYTESIZE, bKiHashData, NULL, &hCryptKey);
    if (!NT_SUCCESS (Status))
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: Error in CreateSymmetricKey     Status 0x%x\n", Status));
        goto CleanUp;
    }

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_HMAC,
                           hCryptKey,
                           0,
                           &hHash ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: HMAC CryptCreateHash failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    hmacinfo.HashAlgid = CALG_MD5;     // Use MD5 as the hashing function for the HMAC
    hmacinfo.cbOuterString = 0;        // use default 64 byte outerstring
    hmacinfo.cbInnerString = 0;        // use default 64 byte innerstring

    if ( !CryptSetHashParam( hHash,
                           HP_HMAC_INFO,
                           (PBYTE)&hmacinfo,
                           0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: HMAC CryptSetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }
           // Prepend SeqNum to the data stream to perform HMAC on
           //  Need to form the network order version first

#if DBG
            // Now convert the Hash to Hex  - for TESTING ONLY
        ZeroMemory(szTemp, TEMPSIZE);
        BinToHex((PUCHAR)&pMacBlock->dwSeqNumber, sizeof(DWORD), szTemp);
    
        if (szTemp)
        {
            DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: HMAC component SeqNum %s\n", szTemp));
        }
#endif
    if ( !CryptHashData( hHash,
                         (const unsigned char *)&pMacBlock->dwSeqNumber,
                         sizeof(DWORD),
                         0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: HMAC CryptHashData failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    // Now HMAC the data to protect
    // Now scan the SecBuffers for Data buffers to process

    for (ULONG Index = 0; Index < pSecBuff->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(pSecBuff->pBuffers[Index]) == SECBUFFER_DATA)
        {
            if (pSecBuff->pBuffers[Index].cbBuffer && pSecBuff->pBuffers[Index].pvBuffer)
            {
                if ( !CryptHashData( hHash,
                                     (PBYTE)pSecBuff->pBuffers[Index].pvBuffer,
                                     pSecBuff->pBuffers[Index].cbBuffer,
                                     0 ) )
                {
                    DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: HMAC CryptHashData failed : 0x%lx\n", GetLastError()));
                    Status = STATUS_ENCRYPTION_FAILED;
                    goto CleanUp;
                }
            }
        }
    }

    cbHMACData = HMAC_MD5_HASH_BYTESIZE;
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             bHMACData,
                             &cbHMACData,
                             0 ) )
    {
        DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: HMAC CryptGetHashParam failed : 0x%lx\n", GetLastError()));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

    DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: HMAC hash length  %d bytes\n", cbHMACData));
    ASSERT(cbHMACData == HMAC_MD5_HASH_BYTESIZE);

    CryptDestroyKey( hCryptKey );
    hCryptKey = NULL;

    CryptDestroyHash( hHash );
    hHash = NULL;


    // We now have the HMAC so form up the MAC block for SASL

    // Now convert the Hash to Hex  - for TESTING ONLY
    if (cbHMACData != HMAC_MD5_HASH_BYTESIZE)
    {
        // This should never happen
        DebugLog((DEB_ERROR, "CalculateSASLHMACMulti: HMAC-MD5 result length incorrect\n"));
        Status = STATUS_ENCRYPTION_FAILED;
        goto CleanUp;
    }

#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex(bHMACData, HMAC_MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: HMAC-MD5 is %s\n", szTemp));
#endif

    memcpy(pMacBlock->hmacMD5, bHMACData, SASL_MAC_HMAC_SIZE);

#if DBG
    ZeroMemory(szTemp, TEMPSIZE);
    BinToHex((PUCHAR)pMacBlock, HMAC_MD5_HASH_BYTESIZE, szTemp);
    DebugLog((DEB_TRACE, "CalculateSASLHMACMulti: HMAC-MD5 block is %s\n", szTemp));
#endif


CleanUp:

        // Release Key resources
    if (hCryptKey)
    {
        CryptDestroyKey( hCryptKey );
        hCryptKey = NULL;
    }
        // Release Hash resources
    if (hHash)
    {
        CryptDestroyHash( hHash );
        hHash = NULL;
    }

    DebugLog((DEB_TRACE_FUNC, "CalculateSASLHMACMulti: Leaving     status 0x%x\n", Status));

    return(Status);
}


// Compare the directive values passed in from client on ChallengeResponse to make
// sure that they are the same for subsequent ChallengeResponses
NTSTATUS
SEC_ENTRY
DigestUserCompareDirectives(
    IN PDIGEST_USERCONTEXT pContext,
    IN PDIGEST_PARAMETER pDigest)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int iAuth = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestUserCompareDirectives: Entering\n"));

    for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
    {
        switch (iAuth)
        {
        case MD5_AUTH_USERNAME:
        case MD5_AUTH_REALM:
        case MD5_AUTH_NONCE:
        case MD5_AUTH_CNONCE:
            if (!RtlEqualString(&(pContext->strParam[iAuth]),
                                 &(pDigest->refstrParam[iAuth]),
                                 FALSE))
            {
                Status = SEC_E_ILLEGAL_MESSAGE;
                DebugLog((DEB_ERROR, "DigestUserCompareDirectives: Directive value %d mismatch     status 0x%x\n",
                          iAuth, Status));
                goto CleanUp;

            }
        }
    }


CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestUserCompareDirectives: Leaving     status 0x%x\n", Status));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\util.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        util.h
//
// Contents:    headerfile for util.cxx and parser.cxx
//
//
// History:     KDamour  15Mar00   Created
//
//------------------------------------------------------------------------

#ifndef DIGEST_UTIL_H
#define DIGEST_UTIL_H

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// Allocates cb wide chars to UNICODE_STRING Buffer
NTSTATUS UnicodeStringAllocate(IN PUNICODE_STRING pString, IN USHORT cNumWChars);

// Duplicate a UnicodeString (memory alloc and copy)
NTSTATUS UnicodeStringDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString);

// Copies a unicode string if destination has enough room to store it
NTSTATUS UnicodeStringCopy(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString);

//  Function to duplicate Unicode passwords with padding for cipher
NTSTATUS UnicodeStringDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString);

// Clears a UnicodeString and releases the memory
NTSTATUS UnicodeStringClear(OUT PUNICODE_STRING pString);

// Copies a SzUnicodeString to a String (memory alloc and copy)
NTSTATUS UnicodeStringWCharDuplicate(OUT PUNICODE_STRING DestinationString,
                                     IN OPTIONAL WCHAR *szSource,
                                     IN OPTIONAL USHORT uWCharCnt);
    
// Duplicates a String (memory alloc and copy)
NTSTATUS StringDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString);

// Copies a string if destination has enough room to store it
NTSTATUS StringCopy(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString);

// Reference a String - no buffer memory copied
NTSTATUS StringReference(
    OUT PSTRING pDestinationString,
    IN  PSTRING pSourceString
    );

// Reference a Unicode_String - no buffer memory copied
NTSTATUS UnicodeStringReference(
    OUT PUNICODE_STRING pDestinationString,
    IN  PUNICODE_STRING pSourceString
    );

// Copies a CzString to a String (memory alloc and copy)
NTSTATUS StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource,
    IN OPTIONAL USHORT uCnt);

// Duplicates a SID (memory alloc and copy)
NTSTATUS SidDuplicate(
    OUT PSID * DestinationSid,
    IN PSID SourceSid);

NTSTATUS CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString);

// Allocate memory in LSA or user mode
PVOID DigestAllocateMemory(IN ULONG BufferSize);

// De-allocate memory from DigestAllocateMemory
VOID DigestFreeMemory(IN PVOID Buffer);

// Allocates cb bytes to STRING Buffer
NTSTATUS StringAllocate(IN PSTRING pString, IN USHORT cb);

// Clears a String and releases the memory
NTSTATUS StringFree(IN PSTRING pString);

// Quick check on String struct allocations validity
NTSTATUS StringVerify(OUT PSTRING pString);

// Clears a Uniicde_String and releases the memory
NTSTATUS UnicodeStringFree(OUT PUNICODE_STRING pString);

// Hex Encoders and Decoders
VOID BinToHex(LPBYTE pSrc,UINT cSrc, LPSTR pDst);
VOID HexToBin(LPSTR pSrc,UINT cSrc, LPBYTE pDst);

//  Scan a Comma Deliminated STRING for an Item
NTSTATUS CheckItemInList(PCHAR pszItem, PSTRING pstrList, BOOL fOneItem);

// determine strlen for a counted string buffer which may or may not be terminated
USHORT strlencounted(const char *string, USHORT maxcnt);

// determine Unicode strlen for a counted string buffer which may or may not be terminated
USHORT ustrlencounted(const short *string, USHORT maxcnt);

// Performs a percent encoding of the source string into the destination string RFC 2396
NTSTATUS BackslashEncodeString(IN PSTRING pstrSrc,  OUT PSTRING pstrDst);

// Printout the Hex representation of a buffer
NTSTATUS MyPrintBytes(void *pbuff, USHORT uNumBytes, PSTRING pstrOutput);

// Check SecurityToken for corredct structure format
BOOL ContextIsTokenOK(IN PSecBuffer pTempToken, IN ULONG ulMaxSize);

#ifndef SECURITY_KERNEL

// Print out the date and time from a given TimeStamp (converted to localtime)
NTSTATUS PrintTimeString(TimeStamp tsValue, BOOL fLocalTime);

// Decode a string into Unicode
NTSTATUS DecodeUnicodeString(
    IN PSTRING pstrSource,
    IN UINT CodePage,
    OUT PUNICODE_STRING pustrDestination
    );

// Encode a unicode string with a given charset
NTSTATUS EncodeUnicodeString(
    IN PUNICODE_STRING pustrSource,
    IN UINT CodePage,
    OUT PSTRING pstrDestination,
    IN OUT PBOOL pfUsedDefaultChar
    );

#endif  // SECURURITY_KERNEL

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // DIGEST_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\kernel\krnldgst.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        krnldgst.h
//
// Contents:    declarations, constants for Kernel Mode context manager
//
//
// History:     KDamour  13Apr00   Created
//
//------------------------------------------------------------------------


#ifndef NTDIGEST_KRNLDGST_H
#define NTDIGEST_KRNLDGST_H

#ifndef UNICODE
#define UNICODE
#endif // UNICODE

#define DES_BLOCKSIZE 8
#define RC4_BLOCKSIZE 1


// This structure contains the state info for the User mode
// security context.
// For longhorn - pull out the common context info between usermode
// and kernel mode to share helper functions for verify/make signature...
typedef struct _DIGEST_KERNELCONTEXT{

    //
    // Global list of all Contexts
    //  (Serialized by UserContextCritSect)
    //
    KSEC_LIST_ENTRY      List;

    //
    // Handle to the LsaContext
    //     This will have the handle to the context in LSAMode Address space
    //
    ULONG_PTR            LsaContext;

    //
    // Timeout the context after awhile.
    //
    TimeStamp ExpirationTime;                // Time inwhich session key expires

    //
    // Used to prevent this Context from being deleted prematurely.
    //  (Serialized by Interlocked*)
    //

    LONG      lReferences;

    //
    // Flag to indicate that Context is not attached to List - skip when scanning list
    //

    BOOL      bUnlinked;

    //
    // Digest Parameters for this context
    //

    DIGEST_TYPE typeDigest;

    //
    // QOP selected for this context
    //

    QOP_TYPE typeQOP;

    //
    // Digest Parameters for this context
    //

    ALGORITHM_TYPE typeAlgorithm;

    //
    // Cipher to use for encrypt/decrypt
    //

    CIPHER_TYPE typeCipher;

    //
    // Charset used for digest directive values
    //
    CHARSET_TYPE typeCharset;

    //
    // Token Handle of authenticated user
    //  Only valid when in AuthenticatedState.
    //     Filled in only by AcceptSecurityContext                     - so we are the server
    //     Mapped to UserMode Client space from LSA TokenHandle
    //     It will be NULL is struct is from InitializeSecurityContext - so we are client
    //

    HANDLE ClientTokenHandle;


    //
    // Maintain the context requirements
    //

    ULONG ContextReq;

    //
    //  Maintain a copy of the credential UseFlags (we can tell if inbound or outbound)
    //

    ULONG CredentialUseFlags;

    // Flags FLAG_CONTEXT_AUTHZID_PROVIDED
    ULONG         ulFlags;


    // Nonce Count
    ULONG         ulNC;

    // Maxbuffer for auth-int and auth-conf processing
    ULONG         ulSendMaxBuf;
    ULONG         ulRecvMaxBuf;

    // SASL sequence numbering
    DWORD  dwSendSeqNum;                        // Makesignature/verifysignature server to client sequence number
    DWORD  dwRecvSeqNum;                        // Makesignature/verifysignature server to client sequence number

    //
    //  Hex(H(A1)) sent from DC and stored in context for future
    //  auth without going to the DC. Binary version is derived from HEX(H(A1))
    //  and is used in SASL mode for integrity protection and encryption
    //

    STRING    strSessionKey;
    BYTE      bSessionKey[MD5_HASH_BYTESIZE];

    // Account name used in token creation for securityContext session
    UNICODE_STRING ustrAccountName;

    //
    //  Values utilized in the Initial Digest Auth ChallResponse
    //
    STRING strParam[MD5_AUTH_LAST];         // points to owned memory - will need to free up!


} DIGEST_KERNELCONTEXT, * PDIGEST_KERNELCONTEXT;



extern "C"
{
KspInitPackageFn       WDigestInitKernelPackage;
KspDeleteContextFn     WDigestDeleteKernelContext;
KspInitContextFn       WDigestInitKernelContext;
KspMapHandleFn         WDigestMapKernelHandle;
KspMakeSignatureFn     WDigestMakeSignature;
KspVerifySignatureFn   WDigestVerifySignature;
KspSealMessageFn       WDigestSealMessage;
KspUnsealMessageFn     WDigestUnsealMessage;
KspGetTokenFn          WDigestGetContextToken;
KspQueryAttributesFn   WDigestQueryContextAttributes;
KspCompleteTokenFn     WDigestCompleteToken;
SpExportSecurityContextFn WDigestExportSecurityContext;
SpImportSecurityContextFn WDigestImportSecurityContext;
KspSetPagingModeFn     WDigestSetPagingMode ;

//
// Useful macros
//

#define WDigestKAllocate( _x_ ) ExAllocatePoolWithTag( WDigestPoolType, (_x_) ,  'CvsM')
#define WDigestKFree( _x_ ) ExFreePool(_x_)

#define MAYBE_PAGED_CODE() \
    if ( WDigestPoolType == PagedPool )    \
    {                                   \
        PAGED_CODE();                   \
    }


#define WDigestReferenceContext( Context, Remove ) \
            KSecReferenceListEntry( (PKSEC_LIST_ENTRY) Context, \
                                    WDIGEST_CONTEXT_SIGNATURE, \
                                    Remove )



NTSTATUS NTAPI WDigestInitKernelPackage(
    IN PSECPKG_KERNEL_FUNCTIONS pKernelFunctions);

NTSTATUS NTAPI WDigestDeleteKernelContext(
    IN ULONG_PTR pKernelContextHandle,
    OUT PULONG_PTR pLsaContextHandle);

VOID WDigestDerefContext(
    PDIGEST_KERNELCONTEXT pContext);

NTSTATUS WDigestFreeKernelContext (
    PDIGEST_KERNELCONTEXT pKernelContext);

NTSTATUS NTAPI WDigestInitKernelContext(
    IN ULONG_PTR LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PULONG_PTR NewContextHandle);

NTSTATUS DigestKernelUnpackContext(
    IN PDIGEST_PACKED_USERCONTEXT pPackedUserContext,
    OUT PDIGEST_KERNELCONTEXT pContext);

NTSTATUS KernelContextPrint(
    PDIGEST_KERNELCONTEXT pContext);


NTSTATUS NTAPI WDigestMapKernelHandle(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle);

NTSTATUS NTAPI DigestKernelHTTPHelper(
    IN PDIGEST_KERNELCONTEXT pContext,
    IN eSignSealOp Op,
    IN OUT PSecBufferDesc pSecBuff,
    IN ULONG MessageSeqNo);


NTSTATUS NTAPI WDigestMakeSignature(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo);

NTSTATUS NTAPI WDigestVerifySignature(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP);

NTSTATUS NTAPI DigestKernelProcessParameters(
   IN PDIGEST_KERNELCONTEXT pContext,
   IN PDIGEST_PARAMETER pDigest,
   OUT PSecBuffer pFirstOutputToken);


NTSTATUS NTAPI WDigestSealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo);

NTSTATUS NTAPI WDigestUnsealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP);

NTSTATUS NTAPI WDigestGetContextToken(
    IN ULONG_PTR KernelContextHandle,
    OUT PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN *RawToken);

NTSTATUS NTAPI WDigestQueryContextAttributes(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer);

NTSTATUS NTAPI WDigestCompleteToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer);

NTSTATUS WDigestImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN OPTIONAL HANDLE TokenHandle,
    OUT PULONG_PTR ContextHandle);

NTSTATUS WDigestImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN OPTIONAL HANDLE TokenHandle,
    OUT PULONG_PTR ContextHandle);

NTSTATUS WDigestSetPagingMode(
    BOOLEAN Pagable);


} // extern "C"

#endif  // NTDIGEST_KRNLDGST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\util.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        ntdigestutil.cxx
//
// Contents:    Utility functions for NtDigest package:
//                UnicodeStringDuplicate
//                SidDuplicate
//                DigestAllocateMemory
//                DigestFreeMemory
//
//
// History:     KDamour  15Mar00   Stolen from NTLM ntlmutil.cxx
//
//------------------------------------------------------------------------
#include "global.h"

#include <stdio.h>
#include <malloc.h>
#include <des.h>


//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringDuplicate
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destination will be too. Assumes Destination has
//              no string info (called FreeUnicodeString)
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with DigestAllocateMemory
//
//  Notes:      will add a NULL character to resulting UNICODE_STRING
//              not really necessary but would need to handle Pointer valid with zero length
//              if we did not do this.
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering DuplicateUnicodeString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(SourceString->Length + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(WCHAR);
            RtlCopyMemory(
                         DestinationString->Buffer,
                         SourceString->Buffer,
                         SourceString->Length
                         );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: UnicodeStringDuplicate, Allocate returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving UnicodeStringDuplicate\n"));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringCopy
//
//  Synopsis:   Copies a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too. If there is enough room
//              in the destination, no new memory will be allocated
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringCopy(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCopy\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    // DestinationString->Buffer = NULL;
    // DestinationString->Length = 0;
    // DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL) &&
        (SourceString->Length))
    {

        if ((DestinationString->Buffer != NULL) &&
            (DestinationString->MaximumLength >= (SourceString->Length + sizeof(WCHAR))))
        {

            DestinationString->Length = SourceString->Length;
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            DestinationString->Length = 0;
            DebugLog((DEB_ERROR, "UnicodeStringCopy: DestinationString not enough space\n"));
            goto CleanUp;
        }
    }
    else
    {   // Indicate that there is no content in this string
        DestinationString->Length = 0;
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeDuplicatePassword
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The MaximumLength contains
//              room for encryption padding data.
//
//  Effects:    allocates memory with LsaFunctions.AllocatePrivateHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "Entering UnicodeDuplicatePassword\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        USHORT PaddingLength;

        PaddingLength = DESX_BLOCKLEN - (SourceString->Length % DESX_BLOCKLEN);

        if( PaddingLength == DESX_BLOCKLEN )
        {
            PaddingLength = 0;
        }

        DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(
                                                    SourceString->Length +
                                                    PaddingLength
                                                    );

        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + PaddingLength;

            if( DestinationString->MaximumLength == SourceString->MaximumLength )
            {
                //
                // duplicating an already padded buffer -- pickup the original
                // pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->MaximumLength
                    );
            } else {

                //
                // duplicating an unpadded buffer -- pickup only the string
                // and leave the padding bytes 0.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->Length
                    );
            }

        }
        else
        {
            Status = STATUS_NO_MEMORY;
            DebugLog((DEB_ERROR, "UnicodeDuplicatePassword, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "Entering UnicodeDuplicatePassword\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringAllocate
//
//  Synopsis:   Allocates cb wide chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringAllocate(
    IN PUNICODE_STRING pString,
    IN USHORT cNumWChars
    )
{
    // DebugLog((DEB_TRACE, "Entering UnicodeStringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cb = 0;

    ASSERT(pString);
    ASSERT(!pString->Buffer);

    cb = cNumWChars + 1;   // Add in extra room for the terminating NULL

    cb = cb * sizeof(WCHAR);    // now convert to wide characters


    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (PWSTR)DigestAllocateMemory((ULONG)(cb));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;    // this value is in terms of bytes not WCHAR count
        }
        else
        {
            pString->MaximumLength = 0;
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "Leaving UnicodeStringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringClear
//
//  Synopsis:   Clears a UnicodeString and releases the memory
//
//  Arguments:  pString - pointer to UnicodeString to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringFree(
    OUT PUNICODE_STRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering UnicodeStringClear\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving UnicodeStringClear\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringVerify
//
//  Synopsis:   If STRING length non-zero, Buffer exist
//
//  Arguments:  pString - pointer to String to check
//
//  Returns:    STATUS_SUCCESS - released memory succeeded
//              STATUS_INVALID_PARAMETER - String bad format
//
//  Requires:
//
//  Effects:
//
//  Notes: If Strings are created properly, this should never fail
//
//--------------------------------------------------------------------------
NTSTATUS
StringVerify(
    OUT PSTRING pString
    )
{
    if (!pString)
    {
        return STATUS_INVALID_PARAMETER;
    }
        // If there is a length, buffer must exist
        // MaxSize can not be smaller than string length
    if (pString->Length &&
        (!pString->Buffer ||
         (pString->MaximumLength < pString->Length)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   StringDuplicate
//
//  Synopsis:   Duplicates a STRING. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(
                       SourceString->Length + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: StringDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringCopy
//
//  Synopsis:   Copies a STRING. If the source string buffer is
//              NULL the destionation will be too. If there is enough room
//              in the destination, no new memory will be allocated
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCopy(
    OUT PSTRING DestinationString,
    IN OPTIONAL PSTRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCopy\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    // DestinationString->Buffer = NULL;
    // DestinationString->Length = 0;
    // DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL) &&
        (SourceString->Length))
    {

        if ((DestinationString->Buffer != NULL) &&
            (DestinationString->MaximumLength >= (SourceString->Length + sizeof(CHAR))))
        {

            DestinationString->Length = SourceString->Length;
            RtlCopyMemory(
                DestinationString->Buffer,
                SourceString->Buffer,
                SourceString->Length
                );

            DestinationString->Buffer[SourceString->Length/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            DestinationString->Length = 0;
            DebugLog((DEB_ERROR, "StringCopy: DestinationString not enough space\n"));
            goto CleanUp;
        }
    }
    else
    {   // Indicate that there is no content in this string
        DestinationString->Length = 0;
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringReference
//
//  Synopsis:   Reference the source string to the destination.  No memory allocated
//
//  Arguments:  DestinationString - Receives a reference of the source string
//              SourceString - String to reference
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringReference(
    OUT PSTRING pDestinationString,
    IN  PSTRING pSourceString
    )
{
    if (!pDestinationString || !pSourceString)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // This will only create a reference - no string buffer memory actually copied
    memcpy(pDestinationString, pSourceString, sizeof(STRING));

    return STATUS_SUCCESS; 
}



//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//              uCnt - number of characters to copy over (0 if copy until NULL)
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource,
    IN OPTIONAL USHORT uCnt
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceCz = 0;

    //ASSERT(DestinationString);
    //ASSERT(!DestinationString->Buffer);  // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if (!ARGUMENT_PRESENT(czSource)) {
        return (Status);
    }

    // If uCnt specified then use that as max length, otherwise locate NULL terminator
    if (uCnt)
    {
        cbSourceCz = uCnt;
    }
    else
    {
        cbSourceCz = (USHORT)strlen(czSource);
    }

    if (cbSourceCz != 0)
    {
        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(cbSourceCz + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = cbSourceCz;
            DestinationString->MaximumLength = cbSourceCz + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                czSource,
                cbSourceCz
                );
            // Since AllocateMemory zeroes out buffer, already NULL terminated
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//              uWCharCnt - number of WCHars to copy; if zero - then copy until NULL terminator
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringWCharDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL WCHAR *szSource,
    IN OPTIONAL USHORT uWCharCnt
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceSz = 0;

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);   // catch any memory leaks

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if (!ARGUMENT_PRESENT(szSource)) 
    {
        return (Status);
    }


    // If uCnt specified then use that as max length, otherwise locate NULL terminator
    if (uWCharCnt)
    {
        cbSourceSz = uWCharCnt;
    }
    else
    {
        cbSourceSz = (USHORT)wcslen(szSource);
    }

    if (cbSourceSz != 0)
    {

        DestinationString->Buffer = (PWSTR) DigestAllocateMemory((cbSourceSz * sizeof(WCHAR)) + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = (cbSourceSz * sizeof(WCHAR));
            DestinationString->MaximumLength = (DestinationString->Length + sizeof(WCHAR));    // Account for NULL WCHAR at end
            RtlCopyMemory(
                DestinationString->Buffer,
                szSource,
                DestinationString->Length
                );

            DestinationString->Buffer[cbSourceSz] = '\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringReference
//
//  Synopsis:   Reference the source unicode_string to the destination.  No memory allocated
//
//  Arguments:  DestinationString - Receives a reference of the source string
//              SourceString - String to reference
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    no allocation of memory
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringReference(
    OUT PUNICODE_STRING pDestinationString,
    IN  PUNICODE_STRING pSourceString
    )
{
    if (!pDestinationString || !pSourceString)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // This will only create a reference - no string buffer memory actually copied
    memcpy(pDestinationString, pSourceString, sizeof(UNICODE_STRING));

    return STATUS_SUCCESS; 
}



//+-------------------------------------------------------------------------
//
//  Function:   StringFree
//
//  Synopsis:   Clears a String and releases the memory
//
//  Arguments:  pString - pointer to String to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
StringFree(
    IN PSTRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringFree\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringFree\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringAllocate
//
//  Synopsis:   Allocates cb chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
StringAllocate(
    IN PSTRING pString,
    IN USHORT cb
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(pString);
    ASSERT(!pString->Buffer);   // catch any memory leaks

    cb = cb + 1;   // Add in extra room for the terminating NULL

    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (char *)DigestAllocateMemory((ULONG)(cb * sizeof(CHAR)));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;
        }
        else
        {
            pString->MaximumLength = 0;
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   SidDuplicate
//
//  Synopsis:   Duplicates a SID
//
//  Arguments:  DestinationSid - Receives a copy of the SourceSid
//              SourceSid - SID to copy
//
//  Returns:    STATUS_SUCCESS - the copy succeeded
//              STATUS_INSUFFICIENT_RESOURCES - the call to allocate memory
//                  failed
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SidDuplicate(
    OUT PSID * DestinationSid,
    IN PSID SourceSid
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering SidDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SidSize;

    // ASSERT(RtlValidSid(SourceSid));

    SidSize = RtlLengthSid(SourceSid);

    *DestinationSid = (PSID) DigestAllocateMemory( SidSize );

    if (ARGUMENT_PRESENT(*DestinationSid))
    {
        RtlCopyMemory(
            *DestinationSid,
            SourceSid,
            SidSize
            );
    }
    else
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "NTDigest: SidDuplicate, DigestAllocateMemory returns NULL\n"));
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving SidDuplicate\n"));
    return(Status);
}

#ifndef SECURITY_KERNEL


//+-------------------------------------------------------------------------
//
//  Function:   DecodeUnicodeString
//
//  Synopsis:   Convert an encoded string into Unicode 
//
//  Arguments:  pstrSource - pointer to String with encoded input
//              
//              pustrDestination - pointer to a destination Unicode string
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets UNICODE_STRING sizes
//
//  Notes:  Must call UnicodeStringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
DecodeUnicodeString(
    IN PSTRING pstrSource,
    IN UINT CodePage,
    OUT PUNICODE_STRING pustrDestination
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    int      cNumWChars = 0;     // number of wide characters
    DWORD    dwError = 0;

    // Handle case if there is no characters to convert
    if (!pstrSource->Length)
    {
         pustrDestination->Length = 0;
         pustrDestination->MaximumLength = 0;
         pustrDestination->Buffer = NULL;
         goto CleanUp;
    }

    // Determine number of characters needed in unicode string
    cNumWChars = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              NULL,
                              0);
    if (cNumWChars <= 0)
    {
        Status = STATUS_UNMAPPABLE_CHARACTER;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "DecodeUnicodeString: failed to determine wchar count  error 0x%x\n", dwError));
        goto CleanUp;
    }

    Status = UnicodeStringAllocate(pustrDestination, (USHORT)cNumWChars);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DecodeUnicodeString: Failed Unicode allocation\n"));
        goto CleanUp;
    }

    // We now have the space allocated so convert encoded unicode
    cNumWChars = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              pustrDestination->Buffer,
                              cNumWChars);
    if (cNumWChars == 0)
    {
        UnicodeStringFree(pustrDestination);    // Free up allocation on error
        Status = STATUS_UNMAPPABLE_CHARACTER;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "DecodeUnicodeString: failed to decode source string  error 0x%x\n", dwError));
        goto CleanUp;
    }

    // decoding successful set size of unicode string

    pustrDestination->Length = (USHORT)(cNumWChars * sizeof(WCHAR));

    //DebugLog((DEB_TRACE, "DecodeUnicodeString: string (%Z) is unicode (%wZ)\n", pstrSource, pustrDestination));
    //DebugLog((DEB_TRACE, "DecodeUnicodeString: unicode length %d   maxlength %d\n", 
              //pustrDestination->Length, pustrDestination->MaximumLength));

CleanUp:

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   EncodeUnicodeString
//
//  Synopsis:   Encode a Unicode string into a charset string 
//
//  Arguments:  pustrSource - pointer to Unicode_String with  input
//              
//              pstrDestination - pointer to a destination encoded string
//
//              pfUsedDefaultChar - pointer to BOOL if default character had to be used since
//                  the Source contains characters outside the character set specified
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
EncodeUnicodeString(
    IN PUNICODE_STRING pustrSource,
    IN UINT CodePage,
    OUT PSTRING pstrDestination,
    IN OUT PBOOL pfUsedDefaultChar
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int      cNumChars = 0;     // number of wide characters
    DWORD    dwError = 0;
    PBOOL    pfUsedDef = NULL;
    DWORD    dwFlags = 0;

    // Handle case if there is no characters to convert
    if (!pustrSource->Length)
    {
         pstrDestination->Length = 0;
         pstrDestination->MaximumLength = 0;
         pstrDestination->Buffer = NULL;
         goto CleanUp;
    }

    // If UTF-8 then do not allow default char mapping (ref MSDN)
    if (CodePage != CP_UTF8)
    {
        pfUsedDef = pfUsedDefaultChar;
        dwFlags = WC_NO_BEST_FIT_CHARS;
    }

    // Determine number of characters needed in unicode string
    cNumChars = WideCharToMultiByte(CodePage,
                                      dwFlags,
                                      pustrSource->Buffer,
                                      (pustrSource->Length / sizeof(WCHAR)),
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);
    if (cNumChars <= 0)
    {
        Status = STATUS_UNMAPPABLE_CHARACTER;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "EncodeUnicodeString: failed to determine char count  error 0x%x\n", dwError));
        goto CleanUp;
    }

    Status = StringAllocate(pstrDestination, (USHORT)cNumChars);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "EncodeUnicodeString: Failed String allocation\n"));
        goto CleanUp;
    }

    // We now have the space allocated so convert to encoded unicode
    cNumChars = WideCharToMultiByte(CodePage,
                              dwFlags,
                              pustrSource->Buffer,
                              (pustrSource->Length / sizeof(WCHAR)),
                              pstrDestination->Buffer,
                              cNumChars,
                              NULL,
                              pfUsedDef);
    if (cNumChars == 0)
    {
        Status = STATUS_UNMAPPABLE_CHARACTER;
        dwError = GetLastError();
        DebugLog((DEB_ERROR, "EncodeUnicodeString: failed to decode source string  error 0x%x\n", dwError));
        StringFree(pstrDestination);    // Free up allocation on error
        goto CleanUp;
    }

    // decoding successful set size of unicode string

    pstrDestination->Length = (USHORT)cNumChars;

CleanUp:

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DigestAllocateMemory
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
DigestAllocateMemory(
    IN ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    // DebugLog((DEB_TRACE, "Entering DigestAllocateMemory\n"));

    if (g_NtDigestState == NtDigestLsaMode)
    {
        Buffer = g_LsaFunctions->AllocateLsaHeap(BufferSize);
        if (Buffer != NULL)
        {
            RtlZeroMemory(Buffer, BufferSize);
        }
        DebugLog((DEB_TRACE_MEM, "Memory: LSA alloc %lu bytes at 0x%x\n", BufferSize, Buffer ));
    }
    else
    {
        ASSERT(g_NtDigestState == NtDigestUserMode);
        Buffer = LocalAlloc(LPTR, BufferSize);
        DebugLog((DEB_TRACE_MEM, "Memory: Local alloc %lu bytes at 0x%x\n", BufferSize, Buffer ));
    }

    // DebugLog((DEB_TRACE, "Leaving DigestAllocateMemory\n"));
    return Buffer;
}



//+-------------------------------------------------------------------------
//
//  Function:   DigestFreeMemory
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
DigestFreeMemory(
    IN PVOID Buffer
    )
{
    // DebugLog((DEB_TRACE, "Entering DigestFreeMemory\n"));

    if (ARGUMENT_PRESENT(Buffer))
    {
        if (g_NtDigestState == NtDigestLsaMode)
        {
            DebugLog((DEB_TRACE_MEM, "DigestFreeMemory: LSA free at 0x%x\n", Buffer ));
            g_LsaFunctions->FreeLsaHeap(Buffer);
        }
        else
        {
            ASSERT(g_NtDigestState == NtDigestUserMode);
            DebugLog((DEB_TRACE_MEM, "DigestFreeMemory: Local free at 0x%x\n", Buffer ));
            LocalFree(Buffer);
        }
    }

    // DebugLog((DEB_TRACE, "Leaving DigestFreeMemory\n"));
}

#endif // SECURITY_KERNEL

// Helper functions
/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/
VOID
BinToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )
{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = (CHAR)TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = (CHAR)TOHEX( v );
    }
    pDst[y] = (CHAR)'\0';
}

/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - ASCII data to convert to binary
    cSrc - length of ASCII data
    pDst - buffer receiving binary representation of pSrc

Return Value:

    Nothing

--*/
VOID
HexToBin(
    LPSTR  pSrc,
    UINT   cSrc,
    LPBYTE pDst
    )
{
#define TOBIN(a) ((a)>='a' ? (a)-'a'+10 : (a)-'0')

    for ( UINT x = 0, y = 0 ; x < cSrc ; x = x + 2 )
    {
        BYTE v;
        v = (BYTE)(TOBIN(pSrc[x])<<4);
        pDst[y++] = (BYTE)(v + TOBIN(pSrc[x+1]));
    }
}

#ifndef SECURITY_KERNEL

//+-------------------------------------------------------------------------
//
//  Function:   CopyClientString
//
//  Synopsis:   copies a client string to local memory, including
//              allocating space for it locally.
//
//  Arguments:
//              SourceString  - Could be Ansi or Wchar in client process
//              SourceLength  - bytes
//              DoUnicode     - whether the string is Wchar
//
//  Returns:
//              DestinationString - Unicode String in Lsa Process
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
CopyClientString(
    IN PWSTR SourceString,
    IN ULONG SourceLength,
    IN BOOLEAN DoUnicode,
    OUT PUNICODE_STRING DestinationString
    )
{
    // DebugLog((DEB_TRACE,"NTDigest: Entering CopyClientString\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    STRING TemporaryString = {0};
    ULONG SourceSize = 0;
    ULONG CharacterSize = sizeof(CHAR);

    ASSERT(DestinationString);
    ASSERT(!DestinationString->Buffer);    

    //
    // First initialize the string to zero, in case the source is a null
    // string
    //

    DestinationString->Length = DestinationString->MaximumLength = 0;
    DestinationString->Buffer = NULL;

    if (SourceString != NULL)
    {

        //
        // If the length is zero, allocate one byte for a "\0" terminator if non-zero pointer only
        // Zero length and nonzero pointer indicates a NULL string ""
        // zero length and NULL pointer, indicates value not set
        //

        if (SourceLength == 0)
        {
            DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(sizeof(WCHAR));
            if (DestinationString->Buffer == NULL)
            {
                DebugLog((DEB_ERROR,"CopyClientString: Out of memory\n"));
                Status = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            DestinationString->MaximumLength = sizeof(WCHAR);
            
            // No need to fill the zero, DigestAllocateMemory() already did this.
            //*DestinationString->Buffer = L'\0';

        }
        else
        {
            //
            // Allocate a temporary buffer to hold the client string. We may
            // then create a buffer for the unicode version. The length
            // is the length in characters, so  possible expand to hold unicode
            // characters and a null terminator.
            //

            if (DoUnicode)
            {
                CharacterSize = sizeof(WCHAR);
            }

            SourceSize = (SourceLength + 1) * CharacterSize;

            //
            // insure no overflow aggainst UNICODE_STRING
            //

            if ( (SourceSize - CharacterSize) > 0xFFFF)
            {
                Status = STATUS_INVALID_PARAMETER;
                DebugLog((DEB_ERROR,"CopyClientString: SourceSize is too large\n"));
                goto Cleanup;
            }


            TemporaryString.Buffer = (LPSTR) DigestAllocateMemory(SourceSize);
            if (TemporaryString.Buffer == NULL)
            {
                Status = SEC_E_INSUFFICIENT_MEMORY;
                DebugLog((DEB_ERROR,"CopyClientString: Out of memory\n"));
                goto Cleanup;
            }
            TemporaryString.Length = (USHORT) (SourceSize - CharacterSize);
            TemporaryString.MaximumLength = (USHORT) SourceSize;


            //
            // Finally copy the string from the client
            //

            Status = g_LsaFunctions->CopyFromClientBuffer(
                            NULL,
                            SourceSize - CharacterSize,
                            TemporaryString.Buffer,
                            SourceString
                            );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"CopyClientString: Error from LsaFunctions->CopyFromClientBuffer is 0x%lx\n", Status));
                goto Cleanup;
            }

            //
            // If we are doing unicode, finish up now
            //
            if (DoUnicode)
            {
                DestinationString->Buffer = (LPWSTR) TemporaryString.Buffer;
                DestinationString->Length = (USHORT) (SourceSize - CharacterSize);
                DestinationString->MaximumLength = (USHORT) SourceSize;
                TemporaryString.Buffer = NULL;  // give the memory over to calling function
            }
            else
            {
                DebugLog((DEB_TRACE,"CopyClientString: Converting Ansi creds to Unicode\n"));
                Status = UnicodeStringAllocate(DestinationString, TemporaryString.Length);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"CopyClientString: Out of memory\n"));
                    goto Cleanup;
                }

                Status = RtlAnsiStringToUnicodeString(
                            DestinationString,
                            &TemporaryString,
                            FALSE
                            );      // pre-allocated destination
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"CopyClientString: Error from RtlAnsiStringToUnicodeString is 0x%lx\n", Status));
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:

    if (TemporaryString.Buffer)
    {
        DigestFreeMemory(TemporaryString.Buffer);
        TemporaryString.Buffer = NULL;
    }

    // On error clean up any memory
    if (!NT_SUCCESS(Status))
    {
        UnicodeStringFree(DestinationString);
    }

    // DebugLog((DEB_TRACE,"NTDigest: Leaving CopyClientString\n"));

    return(Status);
}


// Print out the date and time from a given TimeStamp (converted to localtime)
NTSTATUS PrintTimeString(TimeStamp ConvertTime, BOOL fLocalTime)
{
    NTSTATUS Status = STATUS_SUCCESS;

    LARGE_INTEGER LocalTime;
    LARGE_INTEGER SystemTime;

    SystemTime = (LARGE_INTEGER)ConvertTime;
    LocalTime.HighPart = 0;
    LocalTime.LowPart = 0;

    if (ConvertTime.HighPart == 0x7FFFFFFF)
    {
        DebugLog((DEB_TRACE, "PrintTimeString: Never ends\n"));
    }

    if (fLocalTime)
    {
        Status = RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
        if (!NT_SUCCESS( Status )) {
            DebugLog((DEB_ERROR, "PrintTimeString: Can't convert time from GMT to Local time\n"));
            LocalTime = ConvertTime;
        }
    }
    else
    {
        LocalTime = ConvertTime;
    }

    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields( &LocalTime, &TimeFields );

    DebugLog((DEB_TRACE, "PrintTimeString: %ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Year,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second));

    return Status;
}

#endif  // SECUIRITY_KERNEL


// determine strlen for a counted string buffer which may or may not be terminated
USHORT strlencounted(const char *string,
                     USHORT maxcnt)
{
    USHORT cnt = 0;
    if (maxcnt == 0)
    {
        return 0;
    }

    while (maxcnt--)
    {
        if (!*string)
        {
            break;
        }
        cnt++;
        string++;
    }

    return cnt;
}


// determine strlen for a counted string buffer which may or may not be terminated
// maxcnt is the max number of BYTES (so number of unicode chars is 1/2 the maxcnt)
USHORT ustrlencounted(const short *string,
                     USHORT maxcnt)
{
    USHORT cnt = 0;
    if (maxcnt == 0)
    {
        return 0;
    }

    maxcnt = maxcnt / 2;    // determine number of unicode characters to search

    while (maxcnt--)
    {
        if (!*string)
        {
            break;
        }
        cnt++;
        string++;
    }

    return cnt;
}

// Performs a Backslash encoding of the source string into the destination string per RFC 2831
// Section 7.2 and RFC 2616 sect 2.2
NTSTATUS BackslashEncodeString(IN PSTRING pstrSrc,  OUT PSTRING pstrDst)
{
    NTSTATUS Status = S_OK;
    USHORT  uCharsMax = 0;
    PCHAR pcSrc = NULL;
    PCHAR pcDst = NULL;
    USHORT  uCharsUsed = 0;
    USHORT  uCharSrcCnt = 0;

    StringFree(pstrDst);

    if (!pstrSrc || !pstrDst || !pstrSrc->Length)
    {
        return S_OK;
    }

    uCharsMax = pstrSrc->Length * 2;  // Max size if each character needs to be encoded
    Status = StringAllocate(pstrDst, uCharsMax);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"BackshlashEncodeString: String allocation failed   0x%x\n", Status));
        goto CleanUp;
    }

    // now map over each character - encode as necessary
    pcSrc = pstrSrc->Buffer;
    pcDst = pstrDst->Buffer;
    while (uCharSrcCnt < pstrSrc->Length)
    {
        switch (*pcSrc)
        {
            case CHAR_DQUOTE:
            case CHAR_BACKSLASH:
                *pcDst++ = CHAR_BACKSLASH;
                *pcDst++ = *pcSrc++;
                uCharsUsed+= 2;
                break;
            default:
                *pcDst++ = *pcSrc++;
                uCharsUsed++;
                break;
        }
        uCharSrcCnt++;
    }

    pstrDst->Length = uCharsUsed;

CleanUp:
    return Status;
}


// Printout the Hex representation of a buffer
NTSTATUS MyPrintBytes(void *pbuff, USHORT uNumBytes, PSTRING pstrOutput)
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT  uNumTotal = 0;
    PCHAR pctr = NULL;
    PCHAR pOut = NULL;
    USHORT i = 0;

    // Each byte will be encoded as   XX <sp>

    uNumTotal = (uNumBytes * 3) + 1;
    
    Status = StringAllocate(pstrOutput, uNumTotal);
    if (!NT_SUCCESS (Status))
    {
        Status = SEC_E_INSUFFICIENT_MEMORY;
        DebugLog((DEB_ERROR, "ContextInit: StringAllocate error 0x%x\n", Status));
        goto CleanUp;
    }

    pOut = (PCHAR)pstrOutput->Buffer;

    for (i = 0, pctr = (PCHAR)pbuff; i < uNumBytes; i++)
    {
       sprintf(pOut, "%02x ", (*pctr & 0xff));
       pOut += 3;
       pctr++;
    }
    pstrOutput->Length = uNumBytes * 3;

CleanUp:

    return Status;
}


// Some quick checks to make sure SecurityToken buffers are OK
//
//
// Args
//     ulMaxSize - if non-zero then buffer must not be larger than this value, if zero  no check is done
BOOL
ContextIsTokenOK(
                IN PSecBuffer pTempToken,
                IN ULONG ulMaxSize)
{
    if (!pTempToken)
    {
        DebugLog((DEB_ERROR, "ContextIsTokenOK: Error  Bad input\n"));
        return FALSE;
    }

    // If Buffer pointer is NULL then cbBuffer length must be zero
    if ((!pTempToken->pvBuffer) && (pTempToken->cbBuffer))
    {
        DebugLog((DEB_ERROR, "ContextIsTokenOK: Error  Buffer NULL, length non-zero\n"));
        return FALSE;
    }

    // Verify that the input authentication string length is not too large
    if (ulMaxSize && (pTempToken->cbBuffer > ulMaxSize))
    {
        DebugLog((DEB_ERROR, "ContextIsTokenOK: Error  Buffer size too big (Max %lu  Buffer %lu)\n",
                    ulMaxSize, pTempToken->cbBuffer));
        return FALSE;
    }

    return TRUE;
}



//+--------------------------------------------------------------------
//
//  Function:   CheckItemInList
//
//  Synopsis:  Searches a comma delimited list for specified string
//
//  Effects:
//
//  Arguments: 
//    pstrItem - pointer to string Item to look for
//    pstrList - pointer to string of comma delimited list
//    fOneItem - enforce that only 1 item is in List provided (no comma lists)
//
//  Returns:  STATUS_SUCCESS if found, otherwise error
//
//  Notes:
//
//
//---------------------------------------------------------------------
NTSTATUS CheckItemInList(
    PCHAR pszItem,
    PSTRING pstrList,
    BOOL  fOneItem
    )
{
    int cbItem = 0;
    int cbListItem = 0;
    char *pch = NULL;
    char *pchStart = NULL;
    USHORT cbCnt = 0;

    ASSERT(pszItem);
    ASSERT(pstrList);

      // check to make sure that there is data in the list
    if (!pstrList->Length)
    {
        return(STATUS_NOT_FOUND);
    }

    // There MUST be a bu
    ASSERT(pstrList->Buffer);

    pch = pstrList->Buffer;
    pchStart = NULL;
    cbItem = (int)strlen(pszItem);

    // If oneItem selected then item MUST match list
    if (fOneItem)
    {
        if ((cbItem == pstrList->Length) && 
            (!_strnicmp(pszItem, pstrList->Buffer, cbItem)))
        {
            return(STATUS_SUCCESS);
        }
        else
        {
            return(STATUS_NOT_FOUND);
        }
    }

    // Scan List until NULL
    while ((*pch != '\0') && (cbCnt < pstrList->Length))
    {
       // At start of next item in list
       // skip any whitespaces
       if (isspace((int) (unsigned char)*pch) || (*pch == ','))
       {
           pch++;
           cbCnt++;
           continue;     // skip to the next while
       }

       // pointing at start of next item

       pchStart = pch;

       // scan for end of item
       while ((*pch != ',') && (*pch != '\0') && (cbCnt < pstrList->Length))
       {
           pch++;
           cbCnt++;
       }

       // pch points to end of item
       cbListItem = (int)(pch - pchStart);

       // Check it item matches item in list
       if (cbListItem == cbItem)
       {
           if (!_strnicmp(pszItem, pchStart, cbItem))
           {
               // found a match
               return(STATUS_SUCCESS);
           }
       }

       // If not end of List then skip to next character
       if (*pch != '\0')
       {
           pch++;
           cbCnt++;
       }

    }

    return(STATUS_NOT_FOUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\testb\testglobal.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NTDigest security package
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_GLOBAL_H
#define NTDIGEST_GLOBAL_H


#ifndef UNICODE
#define UNICODE
#endif // UNICODE


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
// #include <dsysdbg.h>
#include <lsarpc.h>
#include <lsaitf.h>
#include <dns.h>
#include <dnsapi.h>
#include <lmcons.h>

#include <md5.h>
#include <hmac.h>

#include <pac.hxx>

// Local includes for NT Digest Access SSP
#include "wdigest.h"       /* Prototype functions for package */

//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTDIGEST_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTDIGEST_GLOBAL


// Copies a CzString to a String (memory alloc and copy)
NTSTATUS StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource);


// Allocates cb bytes to STRING Buffer
NTSTATUS StringAllocate(IN PSTRING pString, IN USHORT cb);

// Clears a String and releases the memory
NTSTATUS StringFree(IN PSTRING pString);


// Allocate memory in LSA or user mode
PVOID DigestAllocateMemory(IN ULONG BufferSize);

// De-allocate memory from DigestAllocateMemory
VOID DigestFreeMemory(IN PVOID Buffer);



#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NTDIGEST_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\testb\test.cpp ===
// Test.cpp : Defines the entry point for the console application.
//

#include "testglobal.h"


#include <stdio.h>      // printf


#include <security.h>   // General definition of a Security Support Provider



#define AUTH_USERNAME "test1"
#define AUTH_USERNAME_W L"test1"
#define AUTH_REALM   "simple_digest"
#define AUTH_REALM_W L"simple_digest\"_widechar"
#define AUTH_NONCE "9b38dce631309cc25a653ebaad5b18ee01c8bf385260b26db0574a302be4c11367"
#define AUTH_METHOD "GET"
#define AUTH_ALGORITHM "md5-sess"
#define AUTH_QOP "auth"
#define AUTH_PASSWD "secret"
#define AUTH_CNONCE "34c52218425a779f41d5075931fe6c93"
#define AUTH_URI "/dir/index.html"
#define AUTH_URI_W L"/dir/index.html"
#define AUTH_URI2 "/simple_digest/progress.html"
#define AUTH_URI2_W L"/simple_digest/progress.html"
#define AUTH_NC  "0000000b"
#define AUTH_NC1  "00000001"
#define AUTH_NC2  "00000002"
#define AUTH_NC3  "00000003"
#define AUTH_NC4  "00000004"
#define AUTH_REQDIGEST "60cac55049f9887c9fb853f485128368"


#define STR_BUF_SIZE   4000


// Prototypes
void PrintStatus(SECURITY_STATUS NetStatus);
void MyPrintTime(LPSTR Comment,TimeStamp ConvertTime);


int __cdecl
main(int argc, char* argv[])
{
    int  bPass = 1;
    SECURITY_STATUS Status = STATUS_SUCCESS;

    char cTemp[STR_BUF_SIZE];  // temp buffer for scratch data
    char cOutputTemp[STR_BUF_SIZE];
    char szOutSecBuf[STR_BUF_SIZE];
    char szChallenge[STR_BUF_SIZE];
    char szISCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ISC
    char szASCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ASC

    // SSPI Interface tests

    ULONG PackageCount = 0;
    int i = 0;
    PSecPkgInfo pPackageInfo = NULL;
    PSecPkgInfo pPackageTmp = NULL;
    SECURITY_STATUS TmpStatus = STATUS_SUCCESS;
    HANDLE hClientToken = NULL;
    CredHandle ServerCred;
    CredHandle ClientCred;
    TimeStamp Lifetime;
    BOOL bServerCred = FALSE;
    BOOL bClientCred = FALSE;
    BOOL bRC = FALSE;


    ULONG ContextReqFlags = 0;
    ULONG ContextFlagsUtilized = 0;
    ULONG TargetDataRep = 0;
    ULONG ContextAttributes = 0;


    CtxtHandle OldContextHandle;
    CtxtHandle ServerCtxtHandle;
    CtxtHandle ClientCtxtHandle;

    SecBufferDesc InputBuffers;
    SecBufferDesc OutputBuffers;
    SecBuffer TempTokensIn[6];
    SecBuffer TempTokensOut[6];

    SecPkgContext_Names SecServerName;
    SecPkgCredentials_Names SecCredClientName;
    SecPkgContext_StreamSizes StreamSizes;
    TimeStamp SecContextExpiry;

    PCHAR pcPtr = NULL;
    int iLen = 0;

    STRING strChallenge;
    STRING strMethod;
    STRING strURL;
    STRING strHEntity;
    STRING strOutBuffer;

    UNICODE_STRING ustrUsername;
    UNICODE_STRING ustrPassword;
    UNICODE_STRING ustrDomain;
    STRING strTemp;

    ULONG ulMessSeqNo = 0;
    ULONG ulQOP = 0;

    SEC_WINNT_AUTH_IDENTITY_W AuthData;

    printf("Begining TESTB...\n");

    ZeroMemory(&ClientCred, sizeof(CredHandle));
    ZeroMemory(&ServerCred, sizeof(CredHandle));
    ZeroMemory(&OldContextHandle, sizeof(CtxtHandle));
    ZeroMemory(&ServerCtxtHandle, sizeof(CtxtHandle));
    ZeroMemory(&ClientCtxtHandle, sizeof(CtxtHandle));
    ZeroMemory(&SecServerName, sizeof(SecPkgContext_Names));
    ZeroMemory(&SecCredClientName, sizeof(SecPkgCredentials_Names));
    ZeroMemory(&SecContextExpiry, sizeof(SecContextExpiry));

    ZeroMemory(&ustrUsername, sizeof(ustrUsername));
    ZeroMemory(&ustrPassword, sizeof(ustrPassword));
    ZeroMemory(&ustrDomain, sizeof(ustrDomain));
    ZeroMemory(&strTemp, sizeof(strTemp));
    ZeroMemory(&StreamSizes, sizeof(StreamSizes));

    // Pull out any command line args
    if (argc > 1)
    {
        for (i = 1; i < argc; i++)
        {
            pcPtr = argv[i];
            if (*pcPtr == '-')
            {
                iLen = strlen(pcPtr);
                if (iLen >= 2)
                {
                    switch (*(pcPtr + 1))
                    {
                    case 'u':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrUsername, (pcPtr + 2));
                        break;
                    case 'd':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrDomain, (pcPtr + 2));
                        break;
                    case 'p':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrPassword, (pcPtr + 2));
                        break;
                    case '?':
                    default:
                        printf("Usage: %s -uUsername -pPassword -ddomain\n", argv[0]);
                        return(-1);
                        break;

                    }
                }
            }
        }
    }

    //
    // Get info about the security packages.
    //

    Status = EnumerateSecurityPackages( &PackageCount, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:     EnumerateSecurityPackages failed: 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< (int)PackageCount; i++)
      {
        pPackageTmp = (pPackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pPackageTmp->Name, pPackageTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageTmp->fCapabilities,
                pPackageTmp->wVersion,
                pPackageTmp->wRPCID,
                pPackageTmp->cbMaxToken );
      }

    //
    // Get info about the security packages.
    //

    Status = QuerySecurityPackageInfo( WDIGEST_SP_NAME, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:    QuerySecurityPackageInfo failed:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

        printf( "Name: %ws Comment: %ws\n", pPackageInfo->Name, pPackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageInfo->fCapabilities,
                pPackageInfo->wVersion,
                pPackageInfo->wRPCID,
                pPackageInfo->cbMaxToken );


    //
    // Acquire a credential handle for the server side
    //

    printf("Server  AcquireCredentialHandle\n");
    Status = AcquireCredentialsHandle(
                    NULL,           // New principal
                    WDIGEST_SP_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ServerCred,
                    &Lifetime );

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:    AcquireCredentialsHandle failed:  status 0x%x\n", Status);
        // TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        ZeroMemory(&ServerCred, sizeof(CredHandle));
        goto CleanUp;
    }
    bServerCred = TRUE;
    MyPrintTime("Server ACH LifeTime: ", Lifetime);

    //
    // Acquire a credential handle for the client side
    //
    printf("Client  AcquireCredentialHandle\n");

    if (ustrUsername.Length || ustrPassword.Length || ustrDomain.Length)
    {
        printf("ACH Using supplied credentials\n");
        printf("      Username %wZ    Domain  %wZ    Password %wZ\n",
                &ustrUsername, &ustrDomain, &ustrPassword);

        ZeroMemory(&AuthData, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        AuthData.Domain = ustrDomain.Buffer;
        AuthData.DomainLength = ustrDomain.Length / sizeof(WCHAR);
        AuthData.Password = ustrPassword.Buffer;
        AuthData.PasswordLength = ustrPassword.Length / sizeof(WCHAR);
        AuthData.User = ustrUsername.Buffer;
        AuthData.UserLength = ustrUsername.Length / sizeof(WCHAR);
        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        &AuthData,    // Make NULL not to use any AuthData for cred
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }
    else
    {
        printf("ACH Using default credentials\n");
        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }

    if (!NT_SUCCESS(Status)) {
        printf( "FAILED:      AcquireCredentialsHandle failed:   status 0x%x\n", Status);
        // TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        // ZeroMemory(&ClientCred, sizeof(CredHandle));
        goto CleanUp;
    }
    else
        bClientCred = TRUE;


        printf( "ClientCred: 0x%lx 0x%lx   ",
                ClientCred.dwLower, ClientCred.dwUpper );
        printf( "ServerCred: 0x%lx 0x%lx   \n",
                ServerCred.dwLower, ServerCred.dwUpper );
        MyPrintTime( "Client ACH Lifetime: ", Lifetime );


    // Big time - call Accept with no parameters to get a challenge


    StringAllocate(&strChallenge, 1);

    StringCharDuplicate(&strMethod, "GET");
    StringCharDuplicate(&strURL, AUTH_URI);
    StringAllocate(&strHEntity, NULL);

    Status = StringAllocate(&strOutBuffer, 4000);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:     Outputbuffer allocate:  status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }


    // ZeroMemory(TempTokensIn, sizeof(TempTokensIn));
    // ZeroMemory(TempTokensOut, sizeof(TempTokensOut));
    ZeroMemory(&InputBuffers, sizeof(InputBuffers));
    ZeroMemory(&OutputBuffers, sizeof(OutputBuffers));


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 5;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 0;  // for NULL
    TempTokensIn[0].pvBuffer = NULL;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = 0;  // for NULL
    TempTokensIn[1].pvBuffer = NULL;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = 0;  // for NULL
    TempTokensIn[2].pvBuffer = NULL;
    TempTokensIn[3].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[3].cbBuffer = 0;  //  strHEntity.Length + 1;  // for NULL
    TempTokensIn[3].pvBuffer = NULL;  // strHEntity.Buffer;
    TempTokensIn[4].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[4].cbBuffer = 0; // (wcslen(AUTH_REALM_W) + 1) * sizeof(WCHAR);  //  Realm size count  to use for this challenge
    TempTokensIn[4].pvBuffer = NULL; //  AUTH_REALM_W;            // Realm to use for this challenge


    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = 0;      //   strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = NULL;   //   strOutBuffer.Buffer;

    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION | ASC_REQ_ALLOCATE_MEMORY;

    printf("ASC will create the output buffer\n");

    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   NULL,
                                   &InputBuffers,
                                   ContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ContextAttributes,
                                   &Lifetime);

    if ((Status != SEC_I_CONTINUE_NEEDED) && 
        (Status != STATUS_SUCCESS))      // Indicates that this is the challenge
    {
        printf("FAILED:    SpAcceptLsaModeContext error   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    if (!OutputBuffers.pBuffers[0].pvBuffer && OutputBuffers.pBuffers[0].cbBuffer)
    {
        printf("FAILED:    SpAcceptLsaModeContext invalid output buffer pointer with length provided\n");
        Status = SEC_E_INTERNAL_ERROR;
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szChallenge, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szChallenge[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    Status = FreeContextBuffer(OutputBuffers.pBuffers[0].pvBuffer);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:     FreeContextBuffer error:  status 0x%x\n", Status);
        TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextAttributes); 

    printf("Challenge Output Buffer is:\n%s\n\n", cOutputTemp);

    MyPrintTime("Server ASC LifeTime: ", Lifetime);

    printf("Now call the SSPI InitializeSecCtxt to generate the ChallengeResponse\n");


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 3;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(szChallenge) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = szChallenge;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = strMethod.Length + 1;  // for NULL
    TempTokensIn[1].pvBuffer = strMethod.Buffer;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = 0;  //  strHEntity.Length + 1;  // for NULL
    TempTokensIn[2].pvBuffer = NULL;  // strHEntity.Buffer;


    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    ContextReqFlags = ISC_REQ_REPLAY_DETECT | ISC_REQ_CONNECTION;

    Status = InitializeSecurityContext(&ClientCred,
                                       NULL,
                                       AUTH_URI_W,
                                       ContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ContextFlagsUtilized,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:      InitializeSecurityContext error:  status 0x%x\n", Status);
        TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("InitializeSecurityContext SUCCEEDED with Context Handle (0x%x,0x%x)\n",
           ClientCtxtHandle.dwLower, ClientCtxtHandle.dwUpper );


    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextFlagsUtilized); 
    MyPrintTime("Client ISC LifeTime: ", Lifetime);

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szISCChallengeResponse, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szISCChallengeResponse[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("\nISC: Challenge Response Output Buffer is\n%s\n\n", szISCChallengeResponse);

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 5;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = strMethod.Length + 1;  // for NULL
    TempTokensIn[1].pvBuffer = strMethod.Buffer;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = strURL.Length + 1;  // for NULL
    TempTokensIn[2].pvBuffer = strURL.Buffer;
    TempTokensIn[3].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[3].cbBuffer = 0;  //  strHEntity.Length + 1;  // for NULL
    TempTokensIn[3].pvBuffer = NULL;  // strHEntity.Buffer;
    TempTokensIn[4].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[4].cbBuffer = 0;                   //  Realm not used for challengeresponse
    TempTokensIn[4].pvBuffer = NULL;                //  not used for challengeresponse


    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = 0;     // strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer =  NULL;   // strOutBuffer.Buffer;

    ContextReqFlags = ASC_REQ_REPLAY_DETECT | ASC_REQ_CONNECTION | ASC_REQ_ALLOCATE_MEMORY;


    printf("Calling the AcceptSC with a ChallengeResponse (should talk to the DC)!\n");
    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   NULL,
                                   &InputBuffers,
                                   ContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ContextAttributes,
                                   &Lifetime);
                                   
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:      AcceptSecurityContext 2nd Call:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    strcpy(szASCChallengeResponse, (char *)InputBuffers.pBuffers[0].pvBuffer);

    printf("ASC has accepted the Challenge Resposne\n");

    printf("Now have a valid Security Context handle from ISC and ASC\n\n");

    printf("Context Flags  Req  0x%lx    Ret 0x%lx\n", ContextReqFlags, ContextAttributes);

    MyPrintTime("Server ASC LifeTime: ", Lifetime);


    Status = FreeContextBuffer(OutputBuffers.pBuffers[0].pvBuffer);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    FreeContextBuffer error:   status 0x%x\n", Status);
        TmpStatus = GetLastError();
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    // Now get some info on the securitycontexts
    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_NAMES, &SecServerName);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    if (SecServerName.sUserName)
    {
        printf("QueryContextAttributes reports that Username is %S\n", SecServerName.sUserName);
    }

    // Now get some info on the securitycontexts
    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_PASSWORD_EXPIRY, &SecContextExpiry);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    MyPrintTime("QueryContextAttributes reports server context expires: ", SecContextExpiry);


    // Now get some info on the securitycontexts
    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes SECPKG_ATTR_STREAM_SIZES error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("Server Context(StreamSizes): MaxBuf %lu   Blocksize %lu\n",
           StreamSizes.cbMaximumMessage, StreamSizes.cbBlockSize);

    // Now get some info on the securitycontexts
    Status = QueryCredentialsAttributes(&ClientCred, SECPKG_CRED_ATTR_NAMES, &SecCredClientName);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:  QueryCredentialAttributes error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    if (SecCredClientName.sUserName)
    {
        printf("QueryCredentialAttributes reports that Username is %S\n", SecCredClientName.sUserName);
    }

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 5;
    InputBuffers.pBuffers = TempTokensIn;

        // The first call to MakeSignature this represents the SECOND request on this Nonce!
    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 0;     // strlen(szISCChallengeResponse) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = NULL;  //  szISCChallengeResponse;
    TempTokensIn[1].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[1].cbBuffer = strMethod.Length + 1;  // for NULL
    TempTokensIn[1].pvBuffer = strMethod.Buffer;
    TempTokensIn[2].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[2].cbBuffer = (strlen(AUTH_URI2) + 1) * sizeof(CHAR);  //  Realm size count  to use for this challenge
    TempTokensIn[2].pvBuffer = AUTH_URI2;            // Realm to use for this challenge
    TempTokensIn[3].BufferType = SECBUFFER_PKG_PARAMS;
    TempTokensIn[3].cbBuffer = 0;   // strHEntity.Length + 1;  // for NULL
    TempTokensIn[3].pvBuffer = NULL;  //  strHEntity.Buffer;
    TempTokensIn[4].BufferType = SECBUFFER_PKG_PARAMS;             // There is no OutputBuffers
    TempTokensIn[4].cbBuffer = 4000;                               // So tack on another bufffer on end for output
    TempTokensIn[4].pvBuffer = szOutSecBuf;

    Status = MakeSignature(&ClientCtxtHandle,
                           ulQOP,
                           &InputBuffers,
                           0);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    MakeSignature error:   status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }

    printf("\nMakeSig: Challenge Response Output Buffer for 2nd message is\n%s\n", szOutSecBuf);


    // You now send Output buffer to Server - in this case the buffer is szOutSecBuf

    printf("Now verify that the 2nd message is Authenticate\n");

            // The First message to VerifySignature is the Input to the final call of ASC
    strcpy(cOutputTemp, szOutSecBuf);
    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    Status = VerifySignature(&ServerCtxtHandle,
                             &InputBuffers,
                             ulMessSeqNo,
                             &ulQOP);                                   
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    VerifySignature 1st Call  error :  status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = 0;
        goto CleanUp;
    }
    printf("Now have a authenticated 1st message under context 0x%x !\n", ServerCtxtHandle);

    printf("VerifySig: Check if still OK: Output Buffer (Verify should not have modified it) is\n%s\n\n", cOutputTemp);

    Status = VerifySignature(&ServerCtxtHandle,
                             &InputBuffers,
                             ulMessSeqNo,
                             &ulQOP);                                   
    if (NT_SUCCESS(Status))
    {
        printf("FAILED:     VerifySignature 2nd Call  should not have succeeded  status 0x%x\n", Status);
        bPass = 0;
        goto CleanUp;
    }
    printf("Verified that replay does not work!!\n");

    goto CleanUp;



CleanUp:

    printf("Leaving NT Digest testb\n\n\n");

    if (pPackageInfo)
    {
        FreeContextBuffer(pPackageInfo);
    }

    if (SecServerName.sUserName)
    {
        FreeContextBuffer(SecServerName.sUserName);
    }

    if (SecCredClientName.sUserName)
    {
        FreeContextBuffer(SecCredClientName.sUserName);
    }



    printf("About to call deletesecuritycontext\n");

    //
    // Free the security context handle
    //
    if (ServerCtxtHandle.dwLower || ServerCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ServerCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ServerCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }

    if (ClientCtxtHandle.dwLower || ClientCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ClientCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ClientCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }
    //
    // Free the credential handles
    //

    printf("Now calling to Free the ServerCred\n");
    if (bServerCred)
    {
        Status = FreeCredentialsHandle( &ServerCred );

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ServerCred: " );
            PrintStatus(Status);
        }
    }

    printf("Now calling to Free the ServerCred\n");
    if (bClientCred)
    {
        Status = FreeCredentialsHandle(&ClientCred);

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ClientCred: " );
            PrintStatus( Status );
        }
    }

    StringFree(&strChallenge);
    StringFree(&strMethod);
    StringFree(&strURL);
    StringFree(&strHEntity);
    StringFree(&strOutBuffer);


    if (bPass != 1)
    {
        printf("FAILED test run with one or more tests failing.\n");
    }
    else
    {
        printf("All tests passed.\n");
    }

    return 0;
}


void
PrintStatus(
    SECURITY_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = 0x%lx",NetStatus );

    switch (NetStatus) {

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;
    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;
    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;
    }

    printf( "\n" );
}



void
MyPrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;
    NTSTATUS Status;

    printf( "%s  High/low 0x%x/0x%x:    ", Comment,  ConvertTime.HighPart, ConvertTime.LowPart);

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( (ConvertTime.HighPart == 0x7FFFFFFF) && (ConvertTime.LowPart == 0xFFFFFFFF) ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        LocalTime.HighPart = 0;
        LocalTime.LowPart = 0;

        Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
        if (!NT_SUCCESS( Status )) {
            printf( "Can't convert time from GMT to Local time\n" );
            LocalTime = ConvertTime;
        }

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}




// Support Routines


//+-------------------------------------------------------------------------
//
//  Function:   StringAllocate
//
//  Synopsis:   Allocates cb chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
StringAllocate(
    IN PSTRING pString,
    IN USHORT cb
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    cb = cb + 1;   // Add in extra room for the terminating NULL

    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (char *)DigestAllocateMemory((ULONG)(cb * sizeof(CHAR)));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;
        }
        else
        {
            pString->MaximumLength = 0;
            Status = STATUS_NO_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringFree
//
//  Synopsis:   Clears a String and releases the memory
//
//  Arguments:  pString - pointer to String to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
StringFree(
    IN PSTRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringFree\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringFree\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceCz = 0;

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(czSource)) &&
        ((cbSourceCz = strlen(czSource)) != 0))
    {

        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(cbSourceCz + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = cbSourceCz;
            DestinationString->MaximumLength = cbSourceCz + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                czSource,
                cbSourceCz
                );

            DestinationString->Buffer[cbSourceCz/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            // DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   DigestAllocateMemory
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
DigestAllocateMemory(
    IN ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    // DebugLog((DEB_TRACE, "Entering DigestAllocateMemory\n"));

        Buffer = LocalAlloc(LPTR, BufferSize);

    // DebugLog((DEB_TRACE, "Leaving DigestAllocateMemory\n"));
    return Buffer;
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
DigestFreeMemory(
    IN PVOID Buffer
    )
{
    // DebugLog((DEB_TRACE, "Entering DigestFreeMemory\n"));

            LocalFree(Buffer);

    // DebugLog((DEB_TRACE, "Leaving DigestFreeMemory\n"));
}

/*

//+-------------------------------------------------------------------------
//
//  Function:   DecodeUnicodeString
//
//  Synopsis:   Convert an encoded string into Unicode 
//
//  Arguments:  pstrSource - pointer to String with encoded input
//              
//              pustrDestination - pointer to a destination Unicode string
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets UNICODE_STRING sizes
//
//  Notes:  Must call UnicodeStringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
DecodeUnicodeString(
    IN PSTRING pstrSource,
    IN UINT CodePage,
    OUT PUNICODE_STRING pustrDestination
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    int      cNumWChars = 0;     // number of wide characters
    int      cb = 0;      // number of bytes to allocate
    int      iRC = 0;     // return code
    DWORD    dwError = 0;

    // Handle case if there is no characters to convert
    if (!pstrSource->Length)
    {
         pustrDestination->Length = 0;
         pustrDestination->MaximumLength = 0;
         pustrDestination->Buffer = NULL;
         goto CleanUp;
    }

    // Determine number of characters needed in unicode string
    cNumWChars = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              NULL,
                              0);
    if (cNumWChars <= 0)
    {
        Status = E_FAIL;
        dwError = GetLastError();
        goto CleanUp;
    }

    Status = UnicodeStringAllocate(pustrDestination, (USHORT)cNumWChars);
    if (!NT_SUCCESS(Status))
    {
        goto CleanUp;
    }

    // We now have the space allocated so convert encoded unicode
    iRC = MultiByteToWideChar(CodePage,
                              0,
                              pstrSource->Buffer,
                              pstrSource->Length,
                              pustrDestination->Buffer,
                              cNumWChars);
    if (iRC == 0)
    {
        UnicodeStringFree(pustrDestination);    // Free up allocation on error
        Status = E_FAIL;
        dwError = GetLastError();
        goto CleanUp;
    }

    // decoding successful set size of unicode string

    pustrDestination->Length = (USHORT)(iRC * sizeof(WCHAR));


CleanUp:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringDuplicate
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too. Assumes Destination has
//              no string info (called ClearUnicodeString)
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with DigestAllocateMemory
//
//  Notes:      will add a NULL character to resulting UNICODE_STRING
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringDuplicate(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering DuplicateUnicodeString\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {

        DestinationString->Buffer = (LPWSTR) DigestAllocateMemory(SourceString->Length + sizeof(WCHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + sizeof(WCHAR);
            RtlCopyMemory(
                         DestinationString->Buffer,
                         SourceString->Buffer,
                         SourceString->Length
                         );

            DestinationString->Buffer[SourceString->Length/sizeof(WCHAR)] = L'\0';
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving UnicodeStringDuplicate\n"));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringAllocate
//
//  Synopsis:   Allocates cb wide chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringAllocate(
    IN PUNICODE_STRING pString,
    IN USHORT cNumWChars
    )
{
    // DebugLog((DEB_TRACE, "Entering UnicodeStringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cb = 0;

    cb = cNumWChars + 1;   // Add in extra room for the terminating NULL

    cb = cb * sizeof(WCHAR);    // now convert to wide characters


    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (PWSTR)DigestAllocateMemory((ULONG)(cb));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;    // this value is in terms of bytes not WCHAR count
        }
        else
        {
            pString->MaximumLength = 0;
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   UnicodeStringClear
//
//  Synopsis:   Clears a UnicodeString and releases the memory
//
//  Arguments:  pString - pointer to UnicodeString to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
UnicodeStringFree(
    OUT PUNICODE_STRING pString
    )
{

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    return(Status);

}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\kernel\krnlapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        krnlapi.cxx
//
// Contents:    Kernel-mode APIs to the WDigest security packageSSP
//              Main kernel mode entry points into this dll:
//    WDigestInitKernelPackage,
//    WDigestDeleteKernelContext,
//    WDigestInitKernelContext,
//    WDigestMapKernelHandle,
//    WDigestMakeSignature,
//    WDigestVerifySignature,
//    WDigestSealMessage,
//    WDigestUnsealMessage,
//    WDigestGetContextToken,
//    WDigestQueryContextAttributes,
//    WDigestCompleteToken,
//    WDigestExportSecurityContext,
//    WDigestImportSecurityContext,
//    WDigestSetPagingMode
//
//              Helper functions:
//          
//              
//
// History:     KDamour  18Mar00       Based on NTLM's kernel mode functions
//        We could merge the digest processing parameters into unified code for longhorn
//
//------------------------------------------------------------------------


#include "..\global.h"
#include "krnldgst.h"
#include <stdio.h>         // For sprintf


#if defined (_MSC_VER)
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201) // Disable warning/error for nameless struct/union
#endif

extern "C"
{
#include <ntosp.h>
// #include <ntlsa.h>
// #include <ntsam.h>
}

#if defined (_MSC_VER) && ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)   // Disable warning/error for nameless struct/union
#endif
#endif

SECPKG_KERNEL_FUNCTION_TABLE WDigestFunctionTable = {
    WDigestInitKernelPackage,
    WDigestDeleteKernelContext,
    WDigestInitKernelContext,
    WDigestMapKernelHandle,
    WDigestMakeSignature,
    WDigestVerifySignature,
    WDigestSealMessage,
    WDigestUnsealMessage,
    WDigestGetContextToken,
    WDigestQueryContextAttributes,
    WDigestCompleteToken,
    WDigestExportSecurityContext,
    WDigestImportSecurityContext,
    WDigestSetPagingMode
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, WDigestInitKernelPackage)
#pragma alloc_text(PAGE, WDigestDeleteKernelContext)
#pragma alloc_text(PAGE, WDigestInitKernelContext)
#pragma alloc_text(PAGE, WDigestMapKernelHandle)
#pragma alloc_text(PAGEMSG, WDigestMakeSignature)
#pragma alloc_text(PAGEMSG, WDigestVerifySignature)
#pragma alloc_text(PAGEMSG, WDigestSealMessage)
#pragma alloc_text(PAGEMSG, WDigestUnsealMessage)
#pragma alloc_text(PAGEMSG, WDigestGetContextToken)
#pragma alloc_text(PAGEMSG, WDigestQueryContextAttributes)
#pragma alloc_text(PAGEMSG, WDigestDerefContext )
#pragma alloc_text(PAGE, WDigestCompleteToken)
#pragma alloc_text(PAGE, WDigestExportSecurityContext)
#pragma alloc_text(PAGE, WDigestImportSecurityContext)
#pragma alloc_text(PAGEMSG, WDigestFreeKernelContext )
#endif


PSECPKG_KERNEL_FUNCTIONS g_LsaKernelFunctions = NULL;
POOL_TYPE WDigestPoolType = PagedPool;

PVOID WDigestPagedList = NULL;
PVOID WDigestNonPagedList = NULL;
PVOID WDigestActiveList = NULL;

ULONG WDigestPackageId = 0;




//+-------------------------------------------------------------------------
//
//  Function:   WDigestInitKernelPackage
//
//  Synopsis:   Initialize an instance of the WDigest package in
//              a client's (kernel) address space
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestInitKernelPackage(
    IN PSECPKG_KERNEL_FUNCTIONS KernelFunctions
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "Entering WDigestInitKernelPackage\n" ));

    g_LsaKernelFunctions = KernelFunctions;

    //
    // Set up Context list support:
    //

    WDigestPoolType = PagedPool ;
    WDigestPagedList = g_LsaKernelFunctions->CreateContextList( KSecPaged );

    if ( !WDigestPagedList )
    {
        return STATUS_NO_MEMORY ;
    }

    WDigestActiveList = WDigestPagedList;

    DebugLog(( DEB_TRACE, "Leaving WDigestInitKernelPackage 0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   WDigestDeleteKernelContext
//
//  Synopsis:   Deletes a kernel mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to delete
//              LsaContextHandle    - The Lsa mode handle
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestDeleteKernelContext(
    IN ULONG_PTR pKernelContextHandle,
    OUT PULONG_PTR pLsaContextHandle
    )
{

    PDIGEST_KERNELCONTEXT pContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestDeleteKernelContext: Entering\n" ));


    Status = WDigestReferenceContext( pKernelContextHandle, TRUE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PDIGEST_KERNELCONTEXT) pKernelContextHandle ;

    }
    else
    {
        *pLsaContextHandle = pKernelContextHandle;
        DebugLog(( DEB_ERROR,
          "WDigestDeleteKernelContext: Bad kernel context 0x%lx\n", pKernelContextHandle));
        goto CleanUp;

    }

    *pLsaContextHandle = pContext->LsaContext;


CleanUp:


    if (pContext != NULL)
    {
        WDigestDerefContext( pContext );

    }

    DebugLog(( DEB_TRACE, "WDigestDeleteKernelContext: Leaving 0x%lx\n", Status ));
    return(Status);
}



//+---------------------------------------------------------------------------
//
//  Function:   WDigestDerefContext
//
//  Synopsis:   Dereference a kernel context
//
//  Arguments:  [Context] --
//
//  History:    7-07-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WDigestDerefContext(
    PDIGEST_KERNELCONTEXT pContext
    )
{
    BOOLEAN Delete ;

    MAYBE_PAGED_CODE();

    KSecDereferenceListEntry(
                    &pContext->List,
                    &Delete );

    if ( Delete )
    {
        WDigestFreeKernelContext( pContext );
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   WDigestFreeKernelContext
//
//  Synopsis:   frees alloced pointers in this context and
//              then frees the context
//
//  Arguments:  KernelContext  - the unlinked kernel context
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WDigestFreeKernelContext (
    PDIGEST_KERNELCONTEXT pKernelContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestFreeKernelContext: Entering\n" ));

    if (!pKernelContext)
    {
        Status =  STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }
    
    if (pKernelContext->ClientTokenHandle)
    {
        NTSTATUS IgnoreStatus;
        IgnoreStatus = NtClose(pKernelContext->ClientTokenHandle);
        // ASSERT (NT_SUCCESS (IgnoreStatus));
        if (!NT_SUCCESS(IgnoreStatus))
        {
            DebugLog((DEB_ERROR, "WDigestFreeKernelContext: Could not Close the TokenHandle!!!!\n"));
        }
        pKernelContext->ClientTokenHandle = NULL;
    }
    
    StringFree(&(pKernelContext->strSessionKey));
    UnicodeStringFree(&(pKernelContext->ustrAccountName));
    
    //
    //  Values utilized in the Initial Digest Auth ChallResponse
    //  Can be utilized for defaults in future MakeSignature/VerifySignature
    //
    for (i=0; i < MD5_AUTH_LAST; i++)
    {
        StringFree(&(pKernelContext->strParam[i]));
    }
    
    DebugLog(( DEB_TRACE, "WDigestFreeKernelContext:  Deleting Context 0x%lx\n", pKernelContext));

    DigestFreeMemory(pKernelContext);

CleanUp:

    DebugLog(( DEB_TRACE, "WDigestFreeKernelContext: Leaving   0x%lx\n", Status ));

    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   WDigestInitKernelContext
//
//  Synopsis:   Creates a kernel-mode context from a packed LSA mode context
//
//  Arguments:  LsaContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
WDigestInitKernelContext(
    IN ULONG_PTR LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PULONG_PTR NewContextHandle
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_KERNELCONTEXT pContext = NULL;
    PDIGEST_PACKED_USERCONTEXT pPackedUserContext = NULL;

    PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestInitKernelContext: Entering\n" ));

    *NewContextHandle = NULL;

    if (PackedContext->cbBuffer < sizeof(DIGEST_PACKED_USERCONTEXT))
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_ERROR,
          "WDigestInitKernelContext: Bad size of Packed context 0x%lx\n", PackedContext->cbBuffer));
        goto CleanUp;
    }


    pPackedUserContext = (PDIGEST_PACKED_USERCONTEXT) DigestAllocateMemory(PackedContext->cbBuffer);
    if (!pPackedUserContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "WDigestInitKernelContext: DigestAllocateMemory for Packed Copy returns NULL\n" ));
        goto CleanUp;
    }

    // Copy the Packed User Context from LSA to local memory so it wil be long word aligned
    memcpy(pPackedUserContext, PackedContext->pvBuffer, PackedContext->cbBuffer);


    // Now we will unpack this transfered LSA context into UserMode space Context List
    pContext = (PDIGEST_KERNELCONTEXT) DigestAllocateMemory( sizeof(DIGEST_KERNELCONTEXT) );
    if (!pContext)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DebugLog((DEB_ERROR, "WDigestInitKernelContext: DigestAllocateMemory returns NULL\n" ));
        goto CleanUp;
    }

    KsecInitializeListEntry( &pContext->List, WDIGEST_CONTEXT_SIGNATURE );
    pContext->LsaContext = LsaContextHandle;


    Status = DigestKernelUnpackContext(pPackedUserContext, pContext);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "WDigestInitKernelContext: DigestUnpackContext error 0x%x\n", Status));
        goto CleanUp;
    }

    KernelContextPrint(pContext);

    KSecInsertListEntry(
            WDigestActiveList,
            &pContext->List );

    WDigestDerefContext( pContext );

    *NewContextHandle = (ULONG_PTR) pContext;

CleanUp:

    if (!NT_SUCCESS(Status))
    {
        if (pContext != NULL)
        {
            WDigestFreeKernelContext( pContext );
        }
    }

    if (pPackedUserContext)
    {
        DigestFreeMemory(pPackedUserContext);
        pPackedUserContext = NULL;
    }

    if (PackedContext->pvBuffer != NULL)
    {
        g_LsaKernelFunctions->FreeHeap(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
        PackedContext->cbBuffer = 0;
    }

    DebugLog(( DEB_TRACE, "WDigestInitKernelContext: Leaving    status 0x%lx\n", Status ));
    return(Status);
}




// Unpack the context from LSA mode into the User mode Context
NTSTATUS DigestKernelUnpackContext(
    IN PDIGEST_PACKED_USERCONTEXT pPackedUserContext,
    OUT PDIGEST_KERNELCONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR  pucLoc = NULL;
    USHORT uNumWChars = 0;
    int iAuth = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestKernelUnpackContext: Entering\n"));

    ASSERT(pContext);

    //
    // If TokenHandle is NULL, we are being called as
    // as an effect of InitializeSecurityContext, else we are
    // being called because of AcceptSecurityContext
    //

    if (pPackedUserContext->ClientTokenHandle != NULL)
    {
        Status = STATUS_NOT_SUPPORTED;
        //  put support here for ASC calls
        DebugLog((DEB_ERROR, "DigestKernelUnpackContext: ASC contexts not supported\n" ));
        goto CleanUp;
    }
    else
    {
        DebugLog((DEB_TRACE, "DigestUnpackContext: Called from ISC\n" ));
    }

    //
    // Copy over all of the other fields - some data might be binary so
    // use RtlCopyMemory(Dest, Src, len)
    //
    pContext->ExpirationTime = pPackedUserContext->ExpirationTime;
    pContext->typeAlgorithm = (ALGORITHM_TYPE)pPackedUserContext->typeAlgorithm;
    pContext->typeCharset = (CHARSET_TYPE)pPackedUserContext->typeCharset;
    pContext->typeCipher = (CIPHER_TYPE)pPackedUserContext->typeCipher;
    pContext->typeDigest = (DIGEST_TYPE)pPackedUserContext->typeDigest;
    pContext->typeQOP = (QOP_TYPE)pPackedUserContext->typeQOP;
    pContext->ulSendMaxBuf = pPackedUserContext->ulSendMaxBuf;
    pContext->ulRecvMaxBuf = pPackedUserContext->ulRecvMaxBuf;
    pContext->ulNC = 1;                    // Force to one to account for ISC/ASC first message verify
    pContext->lReferences = 1;
    pContext->ContextReq = pPackedUserContext->ContextReq;
    pContext->CredentialUseFlags = pPackedUserContext->CredentialUseFlags;
    pContext->ulFlags = pPackedUserContext->ulFlags;

    // Now check on the strings attached
    pucLoc = &(pPackedUserContext->ucData);
    for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
    {
        if (pPackedUserContext->uDigestLen[iAuth])
        {
            Status = StringAllocate(&(pContext->strParam[iAuth]), (USHORT)pPackedUserContext->uDigestLen[iAuth]);
            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DebugLog((DEB_ERROR, "DigestKernelUnpackContext: DigestAllocateMemory for Params returns NULL\n" ));
                goto CleanUp;
            }
            memcpy(pContext->strParam[iAuth].Buffer, pucLoc, (USHORT)pPackedUserContext->uDigestLen[iAuth]);
            pContext->strParam[iAuth].Length = (USHORT)pPackedUserContext->uDigestLen[iAuth];
            pucLoc +=  (USHORT)pPackedUserContext->uDigestLen[iAuth];
            DebugLog((DEB_TRACE, "DigestKernelUnpackContext: Param[%d] is length %d - %.50s\n",
                       iAuth, pPackedUserContext->uDigestLen[iAuth], pContext->strParam[iAuth].Buffer ));
        }
    }

        // Now do the SessionKey
    if (pPackedUserContext->uSessionKeyLen)
    {
        ASSERT(pPackedUserContext->uSessionKeyLen == MD5_HASH_HEX_SIZE);
        if (pPackedUserContext->uSessionKeyLen != MD5_HASH_HEX_SIZE)
        {
            Status = STATUS_NO_USER_SESSION_KEY;
            DebugLog((DEB_ERROR, "DigestUnpackContext: Session key length incorrect\n" ));
            goto CleanUp;
        }

        Status = StringAllocate(&(pContext->strSessionKey), (USHORT)pPackedUserContext->uSessionKeyLen);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "DigestUnpackContext: DigestAllocateMemory for SessionKey returns NULL\n" ));
            goto CleanUp;
        }
        memcpy(pContext->strSessionKey.Buffer, pucLoc, pPackedUserContext->uSessionKeyLen);
        pContext->strSessionKey.Length = (USHORT)pPackedUserContext->uSessionKeyLen;
        pucLoc +=  (USHORT)pPackedUserContext->uSessionKeyLen;

        // Now determine the binary version of the SessionKey from HEX() version
        HexToBin(pContext->strSessionKey.Buffer, MD5_HASH_HEX_SIZE, pContext->bSessionKey);
    }
        
        // Now do the AccountName
    if (pPackedUserContext->uAccountNameLen)
    {
        uNumWChars = (USHORT)pPackedUserContext->uAccountNameLen / sizeof(WCHAR);
        Status = UnicodeStringAllocate(&(pContext->ustrAccountName), uNumWChars);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DebugLog((DEB_ERROR, "DigestKernelUnpackContext: DigestAllocateMemory for AccountName returns NULL\n" ));
            goto CleanUp;
        }
        memcpy(pContext->ustrAccountName.Buffer, pucLoc, pPackedUserContext->uAccountNameLen);
        pContext->ustrAccountName.Length = (USHORT)pPackedUserContext->uAccountNameLen;
        pucLoc +=  (USHORT)pPackedUserContext->uAccountNameLen;
    }
    
CleanUp:

    DebugLog((DEB_TRACE_FUNC, "DigestKernelUnpackContext: Leaving       Status 0x%x\n", Status));
    return(Status);
}


 

//+-------------------------------------------------------------------------
//
//  Function:   DigestAllocateMemory
//
//  Synopsis:   Allocate memory in kernel mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  Replacements for functions in SSP but for kernel mode
//
//--------------------------------------------------------------------------
PVOID
DigestAllocateMemory(
    IN ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    // DebugLog((DEB_TRACE, "Entering DigestAllocateMemory\n"));

    Buffer = WDigestKAllocate(BufferSize);

    if (Buffer)
    {
        ZeroMemory(Buffer, BufferSize);
    }
    DebugLog((DEB_TRACE_MEM, "Memory: Local alloc %lu bytes at 0x%x\n", BufferSize, Buffer ));

    // DebugLog((DEB_TRACE, "Leaving DigestAllocateMemory\n"));
    return Buffer;
}



//+-------------------------------------------------------------------------
//
//  Function:   DigestFreeMemory
//
//  Synopsis:   Free memory in kernel mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
DigestFreeMemory(
    IN PVOID Buffer
    )
{
    // DebugLog((DEB_TRACE, "Entering DigestFreeMemory\n"));

    if (ARGUMENT_PRESENT(Buffer))
    {
            DebugLog((DEB_TRACE_MEM, "DigestFreeMemory: Local free at 0x%x\n", Buffer ));
            WDigestKFree(Buffer);
    }

    // DebugLog((DEB_TRACE, "Leaving DigestFreeMemory\n"));
}




//+-------------------------------------------------------------------------
//
//  Function:   WDigestMapKernelHandle
//
//  Synopsis:   Maps a kernel handle into an LSA handle
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to map
//              LsaContextHandle - Receives LSA context handle of the context
//                      to map
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
WDigestMapKernelHandle(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_KERNELCONTEXT pContext = NULL;

    PAGED_CODE();

    DebugLog((DEB_TRACE,"WDigestMapKernelHandle: Entering\n"));

    Status = WDigestReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PDIGEST_KERNELCONTEXT) KernelContextHandle ;

        *LsaContextHandle = pContext->LsaContext ;

        WDigestDerefContext( pContext );

    }
    else
    {
        DebugLog(( DEB_WARN, "WDigestMapKernelHandle: Invalid context handle - %x\n",
                    KernelContextHandle ));
        *LsaContextHandle = KernelContextHandle ;
    }

    DebugLog((DEB_TRACE,"WDigestMapKernelHandle:  Leaving   0x%lx\n", Status));

    return (Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   WDigestMakeSignature
//
//  Synopsis:   Computes the Digest Auth response and and creates challengeResponse
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Returns:    STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//              STATUS_SUCCESS - completed normally
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestMakeSignature(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDIGEST_KERNELCONTEXT pContext = NULL;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestMakeSignature: Entering\n" ));

    UNREFERENCED_PARAMETER(fQOP);

    Status = WDigestReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PDIGEST_KERNELCONTEXT) KernelContextHandle ;
    }
    else
    {
        DebugLog(( DEB_ERROR,
          "WDigestMakeSignature: Bad kernel context 0x%lx\n", KernelContextHandle));
        goto CleanUp_NoDeref;

    }

    // Since we are in UserMode we MUST have a sessionkey to use - if not then can not process
    if (!pContext->strSessionKey.Length)
    {
        Status = STATUS_NO_USER_SESSION_KEY;
        DebugLog((DEB_ERROR, "WDigestMakeSignature: No Session Key contained in UserContext\n"));
        goto CleanUp;
    }

    Status = DigestKernelHTTPHelper(
                        pContext,
                        eSign,
                        pMessage,
                        MessageSeqNo
                        );

    if( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "WDigestMakeSignature: SspSignSealHelper returns %lx\n", Status ));
        goto CleanUp;
    }


CleanUp:

    WDigestDerefContext( pContext );

CleanUp_NoDeref:

    DebugLog(( DEB_TRACE, "WDigestMakeSignature: Leaving    0x%lx\n", Status ));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   WDigestVerifySignature
//
//  Synopsis:   Verifies a a challengeResponse on a server (not implemented in kernel mode)
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Returns:    STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestVerifySignature(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestVerifySignature Entering\n" ));

    UNREFERENCED_PARAMETER(KernelContextHandle);
    UNREFERENCED_PARAMETER(pMessage);
    UNREFERENCED_PARAMETER(MessageSeqNo);
    UNREFERENCED_PARAMETER(pfQOP);

    DebugLog(( DEB_TRACE, "WDigestVerifySignature: Leaving   0x%lx\n", Status ));
    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestKernelHTTPHelper
//
//  Synopsis:   Process a SecBuffer with a given Kernel Security Context
//              Used with HTTP for auth after initial ASC/ISC exchange
//
//  Arguments:  pContext - KernelMode Context for the security state
//              Op - operation to perform on the Sec buffers
//              pMessage - sec buffers to processs and return output
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
NTSTATUS NTAPI
DigestKernelHTTPHelper(
                        IN PDIGEST_KERNELCONTEXT pContext,
                        IN eSignSealOp Op,
                        IN OUT PSecBufferDesc pSecBuff,
                        IN ULONG MessageSeqNo
                        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG     ulSeqNo = 0;
    PSecBuffer pChalRspInputToken = NULL;
    PSecBuffer pMethodInputToken = NULL;
    PSecBuffer pURIInputToken = NULL;
    PSecBuffer pHEntityInputToken = NULL;
    PSecBuffer pFirstOutputToken = NULL;
    DIGEST_PARAMETER Digest;
    USHORT usLen = 0;
    int iAuth = 0;
    char *cptr = NULL;
    char  szNCOverride[2*NCNUM];             // Overrides the provided NC if non-zero using only NCNUM digits
    STRING strURI = {0};

    DebugLog((DEB_TRACE, "DigestKernelHTTPHelper: Entering \n"));

    Status = DigestInit(&Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: Digest init error status 0x%x\n", Status));
        goto CleanUp;
    }

    if (pSecBuff->cBuffers < 1)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: Not enough input buffers 0x%x\n", Status));
        goto CleanUp;
    }
    pChalRspInputToken = &(pSecBuff->pBuffers[0]);
    if (!ContextIsTokenOK(pChalRspInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: ContextIsTokenOK (ChalRspInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Set any digest processing parameters based on Context
    if (pContext->ulFlags & FLAG_CONTEXT_NOBS_DECODE)
    {
        Digest.usFlags |= FLAG_NOBS_DECODE;      
    }

    // We have input in the SECBUFFER 0th location - parse it
    Status = DigestParser2(pChalRspInputToken, MD5_AUTH_NAMES, MD5_AUTH_LAST, &Digest);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: DigestParser error 0x%x\n", Status));
        goto CleanUp;
    }

       // Now determine all of the other buffers

    DebugLog((DEB_TRACE, "DigestKernelHTTPHelper: pContext->ContextReq 0x%lx \n", pContext->ContextReq));

    DebugLog((DEB_TRACE, "DigestKernelHTTPHelper: HTTP SecBuffer Format\n"));
    // Retrieve the information from the SecBuffers & check proper formattting
    if (pSecBuff->cBuffers < 4)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: Not enough input buffers 0x%x\n", Status));
        goto CleanUp;
    }
    
    pMethodInputToken = &(pSecBuff->pBuffers[1]);
    if (!ContextIsTokenOK(pMethodInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {                           // Check to make sure that string is present
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: ContextIsTokenOK (MethodInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    pURIInputToken = &(pSecBuff->pBuffers[2]);
    if (!ContextIsTokenOK(pURIInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: ContextIsTokenOK (URIInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    pHEntityInputToken = &(pSecBuff->pBuffers[3]);
    if (!ContextIsTokenOK(pHEntityInputToken, NTDIGEST_SP_MAX_TOKEN_SIZE))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: ContextIsTokenOK (HEntityInputToken) failed  0x%x\n", Status));
        goto CleanUp;
    }

    // Take care of the output buffer
    if (Op == eSign)
    {
        if (pSecBuff->cBuffers < 5)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: No Output Buffers %d\n", Status));
            goto CleanUp;
        }
        pFirstOutputToken = &(pSecBuff->pBuffers[4]);
        if (!ContextIsTokenOK(pFirstOutputToken, 0))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestKernelHTTPHelper, ContextIsTokenOK (FirstOutputToken) failed  0x%x\n", Status));
            goto CleanUp;
        }

        // Reset output buffer
        if (pFirstOutputToken && (pFirstOutputToken->pvBuffer) && (pFirstOutputToken->cbBuffer >= 1))
        {
            cptr = (char *)pFirstOutputToken->pvBuffer;
            *cptr = '\0';
        }

    }
    else
    {
        pFirstOutputToken = NULL;    // There is no output buffer
    }

    // Verify that there is a valid Method provided
    if (!pMethodInputToken->pvBuffer || !pMethodInputToken->cbBuffer ||
        (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: Method SecBuffer must have valid method string status 0x%x\n", Status));
        goto CleanUp;
    }

    usLen = strlencounted((char *)pMethodInputToken->pvBuffer, (USHORT)pMethodInputToken->cbBuffer);
    if (!usLen)
    {
        Status = SEC_E_INVALID_TOKEN;
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: Method SecBuffer must have valid method string status 0x%x\n", Status));
        goto CleanUp;
    }
    Digest.refstrParam[MD5_AUTH_METHOD].Length = usLen;
    Digest.refstrParam[MD5_AUTH_METHOD].MaximumLength = (unsigned short)(pMethodInputToken->cbBuffer);
    Digest.refstrParam[MD5_AUTH_METHOD].Buffer = (char *)pMethodInputToken->pvBuffer;       // refernce memory - no alloc!!!!


    // Check to see if we have H(Entity) data to utilize
    if (pHEntityInputToken->cbBuffer)
    {
        // Verify that there is a valid Method provided
        if (!pHEntityInputToken->pvBuffer || (PBUFFERTYPE(pMethodInputToken) != SECBUFFER_PKG_PARAMS))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: HEntity SecBuffer must have valid string status 0x%x\n", Status));
            goto CleanUp;
        }

        usLen = strlencounted((char *)pHEntityInputToken->pvBuffer, (USHORT)pHEntityInputToken->cbBuffer);

        if ((usLen != 0) && (usLen != (MD5_HASH_BYTESIZE * 2)))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: HEntity SecBuffer must have valid MD5 Hash data 0x%x\n", Status));
            goto CleanUp;
        }

        if (usLen)
        {
            Digest.refstrParam[MD5_AUTH_HENTITY].Length = usLen;
            Digest.refstrParam[MD5_AUTH_HENTITY].MaximumLength = (unsigned short)(pHEntityInputToken->cbBuffer);
            Digest.refstrParam[MD5_AUTH_HENTITY].Buffer = (char *)pHEntityInputToken->pvBuffer;       // refernce memory - no alloc!!!!
        }
    }


    // Import the URI if it is a sign otherwise verify URI match if verify
    if (Op == eSign)
    {
        // Pull in the URI provided in SecBuffer
        if (!pURIInputToken || !pURIInputToken->cbBuffer || !pURIInputToken->pvBuffer)
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: URI SecBuffer must have valid string 0x%x\n", Status));
            goto CleanUp;
        }


        if (PBUFFERTYPE(pURIInputToken) == SECBUFFER_PKG_PARAMS)
        {
            usLen = strlencounted((char *)pURIInputToken->pvBuffer, (USHORT)pURIInputToken->cbBuffer);

            if (usLen > 0)
            {
                Status = StringCharDuplicate(&strURI, (char *)pURIInputToken->pvBuffer, usLen);
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: StringCharDuplicate   error 0x%x\n", Status));
                    goto CleanUp;
                }
            }
        }
        else
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: URI buffer type invalid   error %d\n", Status));
            goto CleanUp;
        }

        StringReference(&(Digest.refstrParam[MD5_AUTH_URI]), &strURI);  // refernce memory - no alloc!!!!
    }

    // If we have a NonceCount in the MessageSequenceNumber then use that
    if (MessageSeqNo)
    {
        ulSeqNo = MessageSeqNo;
    }
    else
    {
        ulSeqNo = pContext->ulNC + 1;           // Else use the next sequence number
    }

    sprintf(szNCOverride, "%0.8x", ulSeqNo); // Buffer is twice as big as we need (for safety) so just clip out first 8 characters
    szNCOverride[NCNUM] = '\0';         // clip to 8 digits
    DebugLog((DEB_TRACE, "DigestKernelHTTPHelper: Message Sequence NC is %s\n", szNCOverride));
    Digest.refstrParam[MD5_AUTH_NC].Length = (USHORT)NCNUM;
    Digest.refstrParam[MD5_AUTH_NC].MaximumLength = (unsigned short)(NCNUM+1);
    Digest.refstrParam[MD5_AUTH_NC].Buffer = (char *)szNCOverride;          // refernce memory - no alloc!!!!

    // Now link in the stored context values into the digest if this is a SignMessage
    // If there are values there from the input auth line then override them with context's value
    if (Op == eSign)
    {
        for (iAuth = 0; iAuth < MD5_AUTH_LAST; iAuth++)
        {
            if ((iAuth != MD5_AUTH_URI) &&
                (iAuth != MD5_AUTH_HENTITY) &&
                (iAuth != MD5_AUTH_METHOD) &&
                pContext->strParam[iAuth].Length)
            {       // Link in only if passed into the user context from the LSA context
                Digest.refstrParam[iAuth].Length = pContext->strParam[iAuth].Length;
                Digest.refstrParam[iAuth].MaximumLength = pContext->strParam[iAuth].MaximumLength;
                Digest.refstrParam[iAuth].Buffer = pContext->strParam[iAuth].Buffer;          // reference memory - no alloc!!!!
            }
        }
    }
    DebugLog((DEB_TRACE, "DigestKernelHTTPHelper: Digest inputs processing completed\n"));

    Status = DigestKernelProcessParameters(pContext, &Digest, pFirstOutputToken);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: DigestUserProcessParameters     error 0x%x\n", Status));
        goto CleanUp;
    }

    pContext->ulNC = ulSeqNo;                           // Everything verified so increment to next nonce count

    // Keep a copy of the new URI in ChallengeResponse
    StringFree(&(pContext->strParam[MD5_AUTH_URI]));
    Status = StringDuplicate(&(pContext->strParam[MD5_AUTH_URI]), &(Digest.refstrParam[MD5_AUTH_URI]));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestKernelHTTPHelper: Failed to copy over new URI\n"));
        goto CleanUp;
    }

CleanUp:

    DigestFree(&Digest);

    StringFree(&strURI);

    DebugLog((DEB_TRACE, "DigestKernelHTTPHelper: Leaving    Status 0x%x\n", Status));

    return(Status);
}



//+--------------------------------------------------------------------
//
//  Function:   DigestKernelProcessParameters
//
//  Synopsis:   Process the Digest information with the context info
//               and generate any output token info
//
//  Arguments:  pContext - KernelMode Context for the security state
//              pDigest - Digest parameters to process into output buffer
//              pFirstOutputToken - sec buffers to processs and return output
//
//  Returns: NTSTATUS
//
//  Notes:
//
//---------------------------------------------------------------------
// 
NTSTATUS NTAPI
DigestKernelProcessParameters(
                           IN PDIGEST_KERNELCONTEXT pContext,
                           IN PDIGEST_PARAMETER pDigest,
                           OUT PSecBuffer pFirstOutputToken)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulNonceCount = 0;

    DebugLog((DEB_TRACE_FUNC, "DigestKernelProcessParameters: Entering\n"));


    // Some common input verification tests

    // We must have a noncecount specified since we specified a qop in the Challenge
    // If we decide to support no noncecount modes then we need to make sure that qop is not specified
    if (pDigest->refstrParam[MD5_AUTH_NC].Length)
    {
        Status = RtlCharToInteger(pDigest->refstrParam[MD5_AUTH_NC].Buffer, HEXBASE, &ulNonceCount);
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog((DEB_ERROR, "DigestKernelProcessParameters: Nonce Count badly formatted\n"));
            goto CleanUp;
        }
    }

    // Check nonceCount is incremented to preclude replay
    if (!(ulNonceCount > pContext->ulNC))
    {
        // We failed to verify next noncecount
        Status = SEC_E_OUT_OF_SEQUENCE;
        DebugLog((DEB_ERROR, "DigestKernelProcessParameters: NonceCount failed to increment!\n"));
        goto CleanUp;
    }

    // Since we are in UserMode we MUST have a sessionkey to use - if non then can not process
    if (!pContext->strSessionKey.Length)
    {
        Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;    // indicate that we needed a call to ASC or ISC first
        DebugLog((DEB_ERROR, "DigestKernelProcessParameters: No Session Key contained in UserContext\n"));
        goto CleanUp;
    }

    // Copy the SessionKey from the Context into the Digest Structure to verify against
    // This will have Digest Auth routines use the SessionKey rather than recompute H(A1)
    StringFree(&(pDigest->strSessionKey));
    Status = StringDuplicate(&(pDigest->strSessionKey), &(pContext->strSessionKey));
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestKernelProcessParameters: Failed to copy over SessionKey\n"));
        goto CleanUp;
    }

    // Set the type of Digest Parameters we are to process
    pDigest->typeDigest = pContext->typeDigest;
    pDigest->typeQOP = pContext->typeQOP;
    pDigest->typeAlgorithm = pContext->typeAlgorithm;
    pDigest->typeCharset = pContext->typeCharset;

    if (pContext->ulFlags & FLAG_CONTEXT_QUOTE_QOP)
    {
        pDigest->usFlags |= FLAG_QUOTE_QOP;
    }

    (void)DigestPrint(pDigest);

    // No check locally that Digest is authentic
    Status = DigestCalculation(pDigest, NULL);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "DigestKernelProcessParameters: Oh no we FAILED Authentication!!!!\n"));
        goto CleanUp;
    }

       // Send to output buffer only if there is an output buffer
       // This allows this routine to be used in UserMode
    if (pFirstOutputToken)
    {
        Status = DigestCreateChalResp(pDigest, NULL, pFirstOutputToken);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "DigestKernelProcessParameters: Failed to create Output String\n"));
            goto CleanUp;
        }
    }

CleanUp:
    
    DebugLog((DEB_TRACE_FUNC, "DigestKernelProcessParameters: Leaving   Status 0x%x\n", Status));
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   WDigestSealMessage
//
//  Synopsis:   Not implemented
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestSealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestSealMessage: Entering\n" ));

    UNREFERENCED_PARAMETER(KernelContextHandle);
    UNREFERENCED_PARAMETER(fQOP);
    UNREFERENCED_PARAMETER(pMessage);
    UNREFERENCED_PARAMETER(MessageSeqNo);

    DebugLog(( DEB_TRACE, "WDigestSealMessage: Leaving    0x%lx\n", Status ));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   WDigestUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: 
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestUnsealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestUnsealMessage: Entering\n" ));

    UNREFERENCED_PARAMETER(KernelContextHandle);
    UNREFERENCED_PARAMETER(pMessage);
    UNREFERENCED_PARAMETER(MessageSeqNo);
    UNREFERENCED_PARAMETER(pfQOP);

    DebugLog(( DEB_TRACE, "WDigestUnsealMessage: Leaving      0x%lx\n", Status ));
    return (Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   WDigestGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestGetContextToken(
    IN ULONG_PTR KernelContextHandle,
    OUT PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN *RawToken
    )
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    MAYBE_PAGED_CODE();

    DebugLog(( DEB_TRACE, "WDigestGetContextToken: Entering\n" ));

    UNREFERENCED_PARAMETER(KernelContextHandle);
    UNREFERENCED_PARAMETER(ImpersonationToken);
    UNREFERENCED_PARAMETER(RawToken);

    DebugLog(( DEB_TRACE, "WDigestGetContextToken: Leaving  0x%lx\n", Status ));
    return (Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   WDigestQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//        #define SECPKG_ATTR_SIZES    0
//        #define SECPKG_ATTR_NAMES    1
//        #define SECPKG_ATTR_LIFESPAN 2
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_UNSUPPORTED_FUNCTION -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestQueryContextAttributes(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PDIGEST_KERNELCONTEXT pContext = NULL;

    MAYBE_PAGED_CODE();

    DebugLog((DEB_TRACE_FUNC, "WDigestQueryContextAttributes: Entering ContextHandle 0x%lx\n", KernelContextHandle ));

    PSecPkgContext_Sizes ContextSizes = NULL;
    PSecPkgContext_DceInfo ContextDceInfo = NULL;
    PSecPkgContext_Names ContextNames = NULL;
    PSecPkgContext_PackageInfo PackageInfo = NULL;
    PSecPkgContext_NegotiationInfo NegInfo = NULL;
    PSecPkgContext_PasswordExpiry PasswordExpires = NULL;
    PSecPkgContext_KeyInfo KeyInfo = NULL;
    PSecPkgContext_AccessToken AccessToken = NULL;
    PSecPkgContext_StreamSizes StreamSizes = NULL;

    ULONG PackageInfoSize = 0;
    BOOL    bServer = FALSE;
    LPWSTR pszEncryptAlgorithmName = NULL;
    LPWSTR pszSignatureAlgorithmName = NULL;
    DWORD dwBytes = 0;
    ULONG ulMaxMessage = 0;

    DIGESTMODE_TYPE typeDigestMode = DIGESTMODE_UNDEFINED;   // Are we in SASL or HTTP mode


    Status = WDigestReferenceContext( KernelContextHandle, FALSE );

    if ( NT_SUCCESS( Status ) )
    {
        pContext = (PDIGEST_KERNELCONTEXT) KernelContextHandle ;
    }
    else
    {
            DebugLog(( DEB_ERROR,
            "WDigestQueryContextAttributes: Bad kernel context 0x%lx\n", KernelContextHandle));
            goto CleanUp;
    }

    // Check to see if Integrity is negotiated for SC
    bServer = pContext->CredentialUseFlags & DIGEST_CRED_INBOUND;

    if ((pContext->typeDigest == SASL_CLIENT) ||
        (pContext->typeDigest == SASL_SERVER))
    {
        typeDigestMode = DIGESTMODE_SASL;
    }
    else
    {
        typeDigestMode = DIGESTMODE_HTTP;
    }

    //
    // Handle each of the various queried attributes
    //

    DebugLog((DEB_TRACE, "WDigestQueryContextAttributes : Attribute 0x%lx\n", Attribute ));
    switch ( Attribute) {
    case SECPKG_ATTR_SIZES:

        ContextSizes = (PSecPkgContext_Sizes) Buffer;
        ZeroMemory(ContextSizes, sizeof(SecPkgContext_Sizes));
        ContextSizes->cbMaxToken = NTDIGEST_SP_MAX_TOKEN_SIZE;
        if (typeDigestMode == DIGESTMODE_HTTP)
        {      // HTTP has signature the same as token in Authentication Header info
            ContextSizes->cbMaxSignature = NTDIGEST_SP_MAX_TOKEN_SIZE;
        }
        else
        {    // SASL has specialized signature block
            ContextSizes->cbMaxSignature = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        if ((pContext->typeCipher == CIPHER_3DES) || 
            (pContext->typeCipher == CIPHER_DES))
        {
            ContextSizes->cbBlockSize = DES_BLOCKSIZE;
            ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else if ((pContext->typeCipher == CIPHER_RC4) || 
                 (pContext->typeCipher == CIPHER_RC4_40) ||
                 (pContext->typeCipher == CIPHER_RC4_56))
        {
            ContextSizes->cbBlockSize = RC4_BLOCKSIZE;
            ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else
        {
            ContextSizes->cbBlockSize = 0;
            if (typeDigestMode == DIGESTMODE_HTTP)
            {      // HTTP has signature the same as token in Authentication Header info
                ContextSizes->cbSecurityTrailer = 0;
            }
            else
            {    // SASL has specialized signature block
                ContextSizes->cbSecurityTrailer = MAC_BLOCK_SIZE + MAX_PADDING;   // handle Auth-int case
            }
        }
        break;
    
    case SECPKG_ATTR_DCE_INFO:

        ContextDceInfo = (PSecPkgContext_DceInfo) Buffer;
        ZeroMemory(ContextDceInfo, sizeof(SecPkgContext_DceInfo));
        ContextDceInfo->AuthzSvc = 0;

        break;

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names) Buffer;
        ZeroMemory(ContextNames, sizeof(SecPkgContext_Names));

        if (pContext->ustrAccountName.Length && pContext->ustrAccountName.Buffer)
        {
            dwBytes = pContext->ustrAccountName.Length + sizeof(WCHAR);
            ContextNames->sUserName = (LPWSTR)g_LsaKernelFunctions->AllocateHeap(dwBytes);
            if (ContextNames->sUserName)
            {
                ZeroMemory(ContextNames->sUserName, dwBytes);
                memcpy(ContextNames->sUserName, pContext->ustrAccountName.Buffer, pContext->ustrAccountName.Length);
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;
    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        // if ((Attribute == SECPKG_ATTR_NEGOTIATION_INFO) && (g_fParameter_Negotiate == FALSE))
        if (Attribute == SECPKG_ATTR_NEGOTIATION_INFO)
        {
            Status = STATUS_NOT_SUPPORTED;
            goto CleanUp;
        }

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        ZeroMemory(PackageInfo, sizeof(SecPkgContext_PackageInfo));
        PackageInfoSize = sizeof(SecPkgInfoW) + sizeof(WDIGEST_SP_NAME) + sizeof(NTDIGEST_SP_COMMENT);
        PackageInfo->PackageInfo = (PSecPkgInfoW)g_LsaKernelFunctions->AllocateHeap(PackageInfoSize);
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CleanUp;
        }
        PackageInfo->PackageInfo->Name = (LPWSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPWSTR) ((((PBYTE) PackageInfo->PackageInfo->Name)) + sizeof(WDIGEST_SP_NAME));
        wcscpy(
            PackageInfo->PackageInfo->Name,
            WDIGEST_SP_NAME
            );

        wcscpy(
            PackageInfo->PackageInfo->Comment,
            NTDIGEST_SP_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = RPC_C_AUTHN_DIGEST;
        PackageInfo->PackageInfo->fCapabilities = NTDIGEST_SP_CAPS;
        PackageInfo->PackageInfo->cbMaxToken    = NTDIGEST_SP_MAX_TOKEN_SIZE;

        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            NegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
        }

        break;

    case SECPKG_ATTR_PASSWORD_EXPIRY:
        PasswordExpires = (PSecPkgContext_PasswordExpiry) Buffer;
        if (pContext->ExpirationTime.QuadPart != 0)
        {
            PasswordExpires->tsPasswordExpires = pContext->ExpirationTime;
        }
        else
            Status = STATUS_NOT_SUPPORTED;
        break;

    case SECPKG_ATTR_KEY_INFO:
        KeyInfo = (PSecPkgContext_KeyInfo) Buffer;
        ZeroMemory(KeyInfo, sizeof(SecPkgContext_KeyInfo));
        if (typeDigestMode == DIGESTMODE_HTTP)
        {
            // HTTP mode
            KeyInfo->SignatureAlgorithm = CALG_MD5;
            pszSignatureAlgorithmName = WSTR_CIPHER_MD5;
            KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                g_LsaKernelFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG)wcslen(pszSignatureAlgorithmName) + 1));
            if (KeyInfo->sSignatureAlgorithmName != NULL)
            {
                wcscpy(
                    KeyInfo->sSignatureAlgorithmName,
                    pszSignatureAlgorithmName
                    );
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            // SASL mode
            KeyInfo->KeySize = 128;       // All modes use a 128 bit key - may have less entropy though (i.e. rc4-XX)
            KeyInfo->SignatureAlgorithm = CALG_HMAC;
            pszSignatureAlgorithmName = WSTR_CIPHER_HMAC_MD5;
            switch (pContext->typeCipher)
            {
                case CIPHER_RC4:
                case CIPHER_RC4_40:
                case CIPHER_RC4_56:
                    KeyInfo->KeySize = 16 * 8;    // All modes use a 128 bit key - may have less entropy though (i.e. rc4-XX)
                    KeyInfo->SignatureAlgorithm = CALG_RC4;
                    pszEncryptAlgorithmName = WSTR_CIPHER_RC4;
                    break;
                case CIPHER_DES:
                    KeyInfo->KeySize = 7 * 8;
                    KeyInfo->SignatureAlgorithm = CALG_DES;
                    pszEncryptAlgorithmName = WSTR_CIPHER_DES;
                    break;
                case CIPHER_3DES:
                    KeyInfo->KeySize = 14 * 8;
                    KeyInfo->SignatureAlgorithm = CALG_3DES_112;
                    pszEncryptAlgorithmName = WSTR_CIPHER_3DES;
                    break;
            }
            if (pszEncryptAlgorithmName)
            {
                KeyInfo->sEncryptAlgorithmName = (LPWSTR)
                    g_LsaKernelFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG)wcslen(pszEncryptAlgorithmName) + 1));
                if (KeyInfo->sEncryptAlgorithmName != NULL)
                {
                    wcscpy(
                        KeyInfo->sEncryptAlgorithmName,
                        pszEncryptAlgorithmName
                        );
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            if (pszSignatureAlgorithmName)
            {
                KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                    g_LsaKernelFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG)wcslen(pszSignatureAlgorithmName) + 1));
                if (KeyInfo->sSignatureAlgorithmName != NULL)
                {
                    wcscpy(
                        KeyInfo->sSignatureAlgorithmName,
                        pszSignatureAlgorithmName
                        );
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        // Make sure that EncryptAlgorithmName and SignatureAlgorithmName is a valid NULL terminated string #601928
        if (NT_SUCCESS(Status) && !KeyInfo->sEncryptAlgorithmName)
        {
            KeyInfo->sEncryptAlgorithmName = (LPWSTR)
                g_LsaKernelFunctions->AllocateHeap(sizeof(WCHAR));

            if (KeyInfo->sEncryptAlgorithmName)
            {
                KeyInfo->sEncryptAlgorithmName[0] = L'\0';
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status) && !KeyInfo->sSignatureAlgorithmName)
        {
            KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                g_LsaKernelFunctions->AllocateHeap(sizeof(WCHAR));

            if (KeyInfo->sSignatureAlgorithmName)
            {
                KeyInfo->sSignatureAlgorithmName[0] = L'\0';
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        break;
    case SECPKG_ATTR_STREAM_SIZES:
        StreamSizes = (PSecPkgContext_StreamSizes) Buffer;
        ZeroMemory(StreamSizes, sizeof(SecPkgContext_StreamSizes));

        if (typeDigestMode == DIGESTMODE_HTTP)
        { 
        }
        else
        {    // SASL
            ulMaxMessage = pContext->ulRecvMaxBuf;
            if (pContext->ulSendMaxBuf < ulMaxMessage)
            {
                ulMaxMessage = pContext->ulSendMaxBuf;
            }
            StreamSizes->cbMaximumMessage = ulMaxMessage - (MAC_BLOCK_SIZE + MAX_PADDING);
        }

        if ((pContext->typeCipher == CIPHER_3DES) || 
            (pContext->typeCipher == CIPHER_DES))
        {
            StreamSizes->cbBlockSize = DES_BLOCKSIZE;
            StreamSizes->cbTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        else if ((pContext->typeCipher == CIPHER_RC4) || 
                 (pContext->typeCipher == CIPHER_RC4_40) ||
                 (pContext->typeCipher == CIPHER_RC4_56))
        {
            StreamSizes->cbBlockSize = RC4_BLOCKSIZE;
            StreamSizes->cbTrailer = MAC_BLOCK_SIZE + MAX_PADDING;
        }
        break;
    case SECPKG_ATTR_ACCESS_TOKEN:
        AccessToken = (PSecPkgContext_AccessToken) Buffer;
        //
        // ClientTokenHandle can be NULL, for instance:
        // 1. client side context.
        // 2. incomplete server context.
        //      Token is not duped - caller must not CloseHandle
        AccessToken->AccessToken = (void*)pContext->ClientTokenHandle;
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }


CleanUp:

    if (!NT_SUCCESS(Status))
    {
        switch (Attribute) {

        case SECPKG_ATTR_NAMES:

            if (ContextNames != NULL && ContextNames->sUserName )
            {
                g_LsaKernelFunctions->FreeHeap(ContextNames->sUserName);
                ContextNames->sUserName = NULL;
            }
            break;

        case SECPKG_ATTR_DCE_INFO:

            if (ContextDceInfo != NULL && ContextDceInfo->pPac)
            {
                g_LsaKernelFunctions->FreeHeap(ContextDceInfo->pPac);
                ContextDceInfo->pPac = NULL;
            }
            break;

        case SECPKG_ATTR_KEY_INFO:
            if (KeyInfo != NULL && KeyInfo->sEncryptAlgorithmName)
            {
                g_LsaKernelFunctions->FreeHeap(KeyInfo->sEncryptAlgorithmName);
                KeyInfo->sEncryptAlgorithmName = NULL;
            }
            if (KeyInfo != NULL && KeyInfo->sSignatureAlgorithmName)
            {
                g_LsaKernelFunctions->FreeHeap(KeyInfo->sSignatureAlgorithmName);
                KeyInfo->sSignatureAlgorithmName = NULL;
            }
            break;
        }
    }

    if( pContext ) {
        WDigestDerefContext( pContext );
    }

    DebugLog((DEB_TRACE_FUNC, "WDigestQueryContextAttributes: Leaving\n"));
    return(Status);
    
}



//+-------------------------------------------------------------------------
//
//  Function:   WDigestCompleteToken
//
//  Synopsis:    Completes a context  - used to perform user mode verification of
//          challenge response for non-persistent connections re-established via ASC
//          call.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:    Not implemented - server function not needed right now
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
WDigestCompleteToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    UNREFERENCED_PARAMETER (ContextHandle);
    UNREFERENCED_PARAMETER (InputBuffer);
    PAGED_CODE();
    DebugLog(( DEB_TRACE, "Entering WDigestCompleteToken: Entering\n" ));
    DebugLog(( DEB_TRACE, "Leaving WDigestCompleteToken: Leaving \n" ));
    return(STATUS_NOT_SUPPORTED);
}



//+-------------------------------------------------------------------------
//
//  Function:  WDigestExportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
WDigestExportSecurityContext(
    IN ULONG_PTR ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    IN OUT PHANDLE TokenHandle
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER (ContextHandle);
    UNREFERENCED_PARAMETER (Flags);
    UNREFERENCED_PARAMETER (PackedContext);
    UNREFERENCED_PARAMETER (TokenHandle);

    DebugLog(( DEB_TRACE, "WDigestExportSecurityContext: Entering\n" ));
    DebugLog(( DEB_TRACE, "WDigestExportSecurityContext: Leaving\n" ));

    return(STATUS_NOT_SUPPORTED);
}



//+-------------------------------------------------------------------------
//
//  Function:  WDigestImportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
WDigestImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN OPTIONAL HANDLE TokenHandle,
    OUT PULONG_PTR ContextHandle
    )
{
    PAGED_CODE();
    
    UNREFERENCED_PARAMETER (PackedContext);
    UNREFERENCED_PARAMETER (TokenHandle);
    UNREFERENCED_PARAMETER (ContextHandle);
    
    DebugLog((DEB_TRACE,"WDigestImportSecurityContext: Entering\n"));
    DebugLog((DEB_TRACE,"WDigestImportSecurityContext: Leaving\n"));


    return(STATUS_NOT_SUPPORTED);
}


//+---------------------------------------------------------------------------
//
//  Function:   WDigestSetPagingMode
//
//  Synopsis:   Switch the paging mode for cluster support
//
//  Arguments:  [Pagable] --
//
//  History:    7-07-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
WDigestSetPagingMode(
    BOOLEAN Pagable
    )
{
    if ( Pagable )
    {
        WDigestPoolType = PagedPool ;
        WDigestActiveList = WDigestPagedList ;
    }
    else
    {
        if ( WDigestNonPagedList == NULL )
        {
            WDigestNonPagedList = g_LsaKernelFunctions->CreateContextList( KSecNonPaged );
            if ( WDigestNonPagedList == NULL )
            {
                return STATUS_NO_MEMORY ;
            }
        }

        WDigestActiveList = WDigestNonPagedList ;

        WDigestPoolType = NonPagedPool ;
    }
    return STATUS_SUCCESS ;

}


// Printout the fields present in usercontext pContext
NTSTATUS
KernelContextPrint(PDIGEST_KERNELCONTEXT pContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i = 0;

    if (!pContext)
    {
        return (STATUS_INVALID_PARAMETER); 
    }


    DebugLog((DEB_TRACE_FUNC, "KernelContextPrint:      Entering for Context Handle at 0x%x\n", pContext));

    DebugLog((DEB_TRACE, "KernelContextPrint:      NC %ld\n", pContext->ulNC));

    DebugLog((DEB_TRACE, "KernelContextPrint:      LSA Context 0x%x\n", pContext->LsaContext));


    if (pContext->typeDigest == DIGEST_CLIENT)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       DIGEST_CLIENT\n"));
    }
    if (pContext->typeDigest == DIGEST_SERVER)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       DIGEST_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_SERVER)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       SASL_SERVER\n"));
    }
    if (pContext->typeDigest == SASL_CLIENT)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       SASL_CLIENT\n"));
    }

    if (pContext->typeQOP == AUTH)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       QOP: AUTH\n"));
    }
    if (pContext->typeQOP == AUTH_INT)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       QOP: AUTH_INT\n"));
    }
    if (pContext->typeQOP == AUTH_CONF)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       QOP: AUTH_CONF\n"));
    }
    if (pContext->typeAlgorithm == MD5)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Algorithm: MD5\n"));
    }
    if (pContext->typeAlgorithm == MD5_SESS)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Algorithm: MD5_SESS\n"));
    }


    if (pContext->typeCharset == ISO_8859_1)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Charset: ISO 8859-1\n"));
    }
    if (pContext->typeCharset == UTF_8)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Charset: UTF-8\n"));
    }

    if (pContext->typeCipher == CIPHER_RC4)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Cipher: CIPHER_RC4\n"));
    }
    else if (pContext->typeCipher == CIPHER_RC4_40)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Cipher: CIPHER_RC4_40\n"));
    }
    else if (pContext->typeCipher == CIPHER_RC4_56)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Cipher: CIPHER_RC4_56\n"));
    }
    else if (pContext->typeCipher == CIPHER_DES)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Cipher: CIPHER_DES\n"));
    }
    else if (pContext->typeCipher == CIPHER_3DES)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:       Cipher: CIPHER_3DES\n"));
    }

    DebugLog((DEB_TRACE, "KernelContextPrint:       ContextReq 0x%lx     CredentialUseFlags 0x%x\n",
              pContext->ContextReq,
              pContext->CredentialUseFlags));

    for (i=0; i < MD5_AUTH_LAST;i++)
    {
        if (pContext->strParam[i].Buffer &&
            pContext->strParam[i].Length)
        {
            DebugLog((DEB_TRACE, "KernelContextPrint:       Digest[%d] = \"%Z\"\n", i,  &pContext->strParam[i]));
        }
    }

    if (pContext->strSessionKey.Length)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:      SessionKey %Z\n", &pContext->strSessionKey));
    }

    if (pContext->ustrAccountName.Length)
    {
        DebugLog((DEB_TRACE, "KernelContextPrint:      AccountName %wZ\n", &pContext->ustrAccountName));
    }

    DebugLog((DEB_TRACE_FUNC, "KernelContextPrint:      Leaving\n"));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\testc\test.cpp ===
// Test.cpp : Defines the entry point for the console application. This code uses SASL calling convention
//

#include "testglobal.h"

#include <stdio.h>      // printf

#include <security.h>   // General definition of a Security Support Provider


#define AUTH_USERNAME "test1"
#define AUTH_USERNAME_W L"test1"

#define AUTH_NONCE "9b38dce631309cc25a653ebaad5b18ee01c8bf385260b26db0574a302be4c11367"
#define AUTH_URI_W L"imap/elwood.innosoft.com"
#define AUTH_NC  "0000000b"
#define AUTH_NC1  "00000001"
#define AUTH_NC2  "00000002"
#define AUTH_NC3  "00000003"
#define AUTH_NC4  "00000004"

#define AUTHDATA_USERNAME L"test1"
// #define AUTHDATA_DOMAIN   L"kdamour2w.damourlan.nttest.microsoft.com"
// #define AUTHDATA_DOMAIN   L"damourlan"
#define AUTHDATA_DOMAIN   L"damourlan"
#define AUTHDATA_PASSWORD L"test1"


#define STR_BUF_SIZE   4000

char g_czTestPasswd[257];


BOOLEAN QuietMode = FALSE; // Don't be verbose


// Prototypes
void PrintStatus(SECURITY_STATUS NetStatus);
void PrintTime(LPSTR Comment,TimeStamp ConvertTime);

void ISCRETFlags(ULONG ulFlags);
void ASCRETFlags(ULONG ulFlags);

VOID BinToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    );

int __cdecl
main(int argc, char* argv[])
{
    BOOL bPass = TRUE;
    SECURITY_STATUS Status = STATUS_SUCCESS;

    char cTemp[STR_BUF_SIZE];  // temp buffer for scratch data
    char cTemp2[STR_BUF_SIZE];  // temp buffer for scratch data
    char cTemp3[STR_BUF_SIZE];  // temp buffer for scratch data
    char cTempPadding[STR_BUF_SIZE];  // temp buffer for scratch data
    char cOutputTemp[STR_BUF_SIZE];
    char szOutSecBuf[STR_BUF_SIZE];
    char szChallenge[STR_BUF_SIZE];
    char szISCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ISC
    char szASCChallengeResponse[STR_BUF_SIZE];   // Output buffer from ASC
    char szASCResponseAuth[STR_BUF_SIZE];   // Output buffer from ASC

    // SSPI Interface tests

    ULONG PackageCount = 0;
    int i = 0;
    PSecPkgInfo pPackageInfo = NULL;
    PSecPkgInfo pPackageTmp = NULL;
    SECURITY_STATUS TmpStatus = STATUS_SUCCESS;
    CredHandle ServerCred;
    CredHandle ClientCred;
    TimeStamp Lifetime;
    BOOL bServerCred = FALSE;
    BOOL bClientCred = FALSE;

    PBYTE pTemp = NULL;
    ULONG ulTemp = 0;
    int j = 0;

    SecPkgContext_StreamSizes StreamSizes;

    ULONG ClientContextReqFlags = ISC_REQ_INTEGRITY | ISC_REQ_CONFIDENTIALITY | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONNECTION;
    ULONG ServerContextReqFlags = ASC_REQ_INTEGRITY | ASC_REQ_CONFIDENTIALITY;
    ULONG ClientContextRetFlags = 0;
    ULONG ServerContextRetFlags = 0;
    ULONG TargetDataRep = 0;


    CtxtHandle OldContextHandle;
    CtxtHandle ServerCtxtHandle;
    CtxtHandle ClientCtxtHandle;

    SecBufferDesc InputBuffers;
    SecBufferDesc OutputBuffers;
    SecBuffer TempTokensIn[10];
    SecBuffer TempTokensOut[6];

    PCHAR pcPtr = NULL;
    int iLen = 0;

    UNICODE_STRING ustrUsername;
    UNICODE_STRING ustrPassword;
    UNICODE_STRING ustrDomain;
    STRING strTemp;

    STRING strChallenge;
    STRING strMethod;
    STRING strHEntity;
    STRING strOutBuffer;

    ULONG ulMessSeqNo = 0;
    ULONG ulQOP = 0;

    SEC_WINNT_AUTH_IDENTITY_W AuthData;

    printf("Begining TESTC...\n");


    ZeroMemory(&ClientCred, sizeof(CredHandle));
    ZeroMemory(&ServerCred, sizeof(CredHandle));
    ZeroMemory(&OldContextHandle, sizeof(CtxtHandle));
    ZeroMemory(&ServerCtxtHandle, sizeof(CtxtHandle));
    ZeroMemory(&ClientCtxtHandle, sizeof(CtxtHandle));

    ZeroMemory(&ustrUsername, sizeof(ustrUsername));
    ZeroMemory(&ustrPassword, sizeof(ustrPassword));
    ZeroMemory(&ustrDomain, sizeof(ustrDomain));
    ZeroMemory(&strTemp, sizeof(strTemp));
    ZeroMemory(&StreamSizes, sizeof(StreamSizes));

    // Pull out any command line args
    if (argc > 1)
    {
        for (i = 1; i < argc; i++)
        {
            pcPtr = argv[i];
            if (*pcPtr == '-')
            {
                iLen = strlen(pcPtr);
                if (iLen >= 2)
                {
                    switch (*(pcPtr + 1))
                    {
                    case 'u':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrUsername, (pcPtr + 2));
                        break;
                    case 'd':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrDomain, (pcPtr + 2));
                        break;
                    case 'p':
                        Status = RtlCreateUnicodeStringFromAsciiz(&ustrPassword, (pcPtr + 2));
                        break;
                    case '?':
                    default:
                        printf("Usage: %s -uUsername -pPassword -ddomain\n", argv[0]);
                        return(-1);
                        break;

                    }
                }
            }
        }
    }

    //
    // Get info about the security packages.
    //

    Status = EnumerateSecurityPackages( &PackageCount, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "EnumerateSecurityPackages failed: 0x%x", Status);
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    if ( !QuietMode ) {
      printf( "PackageCount: %ld\n", PackageCount );
      for ( i= 0; i< (int)PackageCount; i++)
      {
        pPackageTmp = (pPackageInfo + i);
        printf( "Name: %ws Comment: %ws\n", pPackageTmp->Name, pPackageTmp->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageTmp->fCapabilities,
                pPackageTmp->wVersion,
                pPackageTmp->wRPCID,
                pPackageTmp->cbMaxToken );
      }
    }

    //
    // Get info about the security packages.
    //

    Status = QuerySecurityPackageInfo( WDIGEST_SP_NAME, &pPackageInfo );
    TmpStatus = GetLastError();

    if (!NT_SUCCESS(Status)) {
        printf( "QuerySecurityPackageInfo failed: " );
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    if ( !QuietMode ) {
        printf( "Name: %ws Comment: %ws\n", pPackageInfo->Name, pPackageInfo->Comment );
        printf( "Cap: %ld Version: %ld RPCid: %ld MaxToken: %ld\n\n",
                pPackageInfo->fCapabilities,
                pPackageInfo->wVersion,
                pPackageInfo->wRPCID,
                pPackageInfo->cbMaxToken );
    }


    //
    // Acquire a credential handle for the server side
    //

    printf("Server  AcquireCredentialHandle\n");
    Status = AcquireCredentialsHandle(
                    NULL,           // New principal
                    WDIGEST_SP_NAME, // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &ServerCred,
                    &Lifetime );

    if (!NT_SUCCESS(Status)) {
        printf( "AcquireCredentialsHandle failed: ");
        printf( "FAILED:    AcquireCredentialsHandle failed:  status 0x%x\n", Status);
        PrintStatus( Status );
        bPass = FALSE;
        ZeroMemory(&ServerCred, sizeof(CredHandle));
        goto CleanUp;
    }
    bServerCred = TRUE;


    //
    // Acquire a credential handle for the client side
    //
    printf("Client  AcquireCredentialHandle\n");

    if (ustrUsername.Length || ustrPassword.Length || ustrDomain.Length)
    {
        printf("ACH Using supplied credentials\n");
        printf("      Username %wZ    Domain  %wZ    Password %wZ\n",
                &ustrUsername, &ustrDomain, &ustrPassword);

        ZeroMemory(&AuthData, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        AuthData.Domain = ustrDomain.Buffer;
        AuthData.DomainLength = ustrDomain.Length / sizeof(WCHAR);
        AuthData.Password = ustrPassword.Buffer;
        AuthData.PasswordLength = ustrPassword.Length / sizeof(WCHAR);
        AuthData.User = ustrUsername.Buffer;
        AuthData.UserLength = ustrUsername.Length / sizeof(WCHAR);
        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        &AuthData,    // Make NULL not to use any AuthData for cred
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }
    else
    {
        printf("ACH Using default credentials\n");
        Status = AcquireCredentialsHandle(
                        NULL,  //  AUTH_USERNAME_W,           // get the creds for user digest
                        WDIGEST_SP_NAME, // Package Name
                        SECPKG_CRED_OUTBOUND,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &ClientCred,
                        &Lifetime );
    }

    if (!NT_SUCCESS(Status)) {
        printf( "AcquireCredentialsHandle failed: for user %s: ", AUTH_USERNAME);
        PrintStatus( Status );
        // bPass = FALSE;
        // ZeroMemory(&ClientCred, sizeof(CredHandle));
        // goto CleanUp;
    }
    else
        bClientCred = TRUE;


    if ( !QuietMode ) {
        printf( "ClientCred: 0x%lx 0x%lx   ",
                ClientCred.dwLower, ClientCred.dwUpper );
        printf( "ServerCred: 0x%lx 0x%lx   ",
                ServerCred.dwLower, ServerCred.dwUpper );
        PrintTime( "Lifetime: ", Lifetime );
    }


    // Big time - call Accept with no parameters to get a challenge


    StringAllocate(&strChallenge, 0);

    StringCharDuplicate(&strMethod, "GET");
    StringAllocate(&strHEntity, 0);

    StringAllocate(&strOutBuffer, 4000);


    ZeroMemory(TempTokensIn, sizeof(TempTokensIn));
    ZeroMemory(TempTokensOut, sizeof(TempTokensOut));
    ZeroMemory(&InputBuffers, sizeof(SecBufferDesc));
    ZeroMemory(&OutputBuffers, sizeof(SecBufferDesc));


           // SASL first calls ISC with no-input
    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = 1;                         // no data passed in
    TempTokensIn[0].pvBuffer = cTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = InitializeSecurityContext(&ClientCred,
                                       NULL,
                                       AUTH_URI_W,
                                       ClientContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       NULL,    // &InputBuffers,   MSDN allows NULL for 1st call
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ClientContextRetFlags,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("InitializeSecurityContext  SASL 1st call returned: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("ISC Context Flags  Req  0x%lx    Ret 0x%lx\n", ClientContextReqFlags, ClientContextRetFlags);
    ISCRETFlags(ClientContextRetFlags);

    printf("InitializeSecurityContext SASL 1st call  Output buffer size %d\n",
           TempTokensOut[0].cbBuffer );


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strChallenge.Length + 1;  // for NULL
    TempTokensIn[0].pvBuffer = strChallenge.Buffer;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   NULL,
                                   &InputBuffers,
                                   ServerContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ServerContextRetFlags,
                                   &Lifetime);

    if (Status != SEC_I_CONTINUE_NEEDED)   // Indicates that this is the challenge
    {
        printf("SpAcceptLsaModeContext FAILED 0x%x\n", Status);
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szChallenge, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szChallenge[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("ASC Context Flags  Req  0x%lx    Ret 0x%lx\n", ServerContextReqFlags, ServerContextRetFlags);
    ASCRETFlags(ServerContextRetFlags);

    printf("Challenge Output Buffer is:\n%s\n\n", cOutputTemp);

    printf("Now call the SSPI InitializeSecCtxt to generate the ChallengeResponse\n");


    sprintf(cTemp, "username=\"%s\",%s,uri=\"%S\",nc=%0.8x",
              AUTH_USERNAME,
              szChallenge,
              AUTH_URI_W,
              1);


    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = InitializeSecurityContext(&ClientCred,
                                       &ClientCtxtHandle,
                                       AUTH_URI_W,
                                       ClientContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ClientContextRetFlags,
                                       &Lifetime);


    if (Status != SEC_I_CONTINUE_NEEDED)   // Indicates that this is the challengeresponse - wait for mutual auth
    {
        printf("SpAcceptLsaModeContext FAILED 0x%x\n", Status);
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("InitializeSecurityContext SUCCEEDED with Context Handle (0x%x,0x%x)\n",
           ClientCtxtHandle.dwLower, ClientCtxtHandle.dwUpper );


    printf("ISC Context Flags  Req  0x%lx    Ret 0x%lx\n", ClientContextReqFlags, ClientContextRetFlags); 
    ISCRETFlags(ClientContextRetFlags);


    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szChallenge, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szISCChallengeResponse, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szISCChallengeResponse[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("ISC: Challenge Response Output Buffer is\n%s\n\n", szISCChallengeResponse);

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    printf("Calling the AcceptSC with a ChallengeResponse (should talk to the DC)!\n");
    Status = AcceptSecurityContext(
                                   &ServerCred,
                                   &ServerCtxtHandle,
                                   &InputBuffers,
                                   ServerContextReqFlags,
                                   TargetDataRep,
                                   &ServerCtxtHandle,
                                   &OutputBuffers,
                                   &ServerContextRetFlags,
                                   &Lifetime);
                                   
    if (!NT_SUCCESS(Status))
    {
        printf("AcceptSecurityContext 2nd Call: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    strcpy(szASCChallengeResponse, (char *)InputBuffers.pBuffers[0].pvBuffer);


    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    ZeroMemory(szASCResponseAuth, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';
    strncpy(szASCResponseAuth, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    szASCResponseAuth[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("ASC has accepted the Challenge Resposne and generated rspauth for mutual auth back to client\n");

    printf("ASC Context Flags  Req  0x%lx    Ret 0x%lx\n", ServerContextReqFlags, ServerContextRetFlags);
    ASCRETFlags(ServerContextRetFlags);

    printf("ASC: Response Auth Output Buffer is\n%s\n\n", szASCResponseAuth);


    printf("Now have a valid Security Context handle from ASC\n\n");

    InputBuffers.ulVersion = SECBUFFER_VERSION;
    InputBuffers.cBuffers = 1;
    InputBuffers.pBuffers = TempTokensIn;

    TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
    TempTokensIn[0].cbBuffer = strlen(cOutputTemp) + 1;  // for NULL
    TempTokensIn[0].pvBuffer = cOutputTemp;

    OutputBuffers.ulVersion = SECBUFFER_VERSION;
    OutputBuffers.cBuffers = 1;
    OutputBuffers.pBuffers = TempTokensOut;

    TempTokensOut[0].BufferType = SECBUFFER_TOKEN;
    TempTokensOut[0].cbBuffer = strOutBuffer.MaximumLength;  // use any space here
    TempTokensOut[0].pvBuffer = strOutBuffer.Buffer;

    Status = InitializeSecurityContext(&ClientCred,
                                       &ClientCtxtHandle,
                                       AUTH_URI_W,
                                       ClientContextReqFlags,
                                       NULL,
                                       SECURITY_NATIVE_DREP,
                                       &InputBuffers,
                                       NULL,
                                       &ClientCtxtHandle,
                                       &OutputBuffers,
                                       &ClientContextRetFlags,
                                       &Lifetime);


    if (!NT_SUCCESS(Status))
    {
        printf("InitializeSecurityContext on Response Auth FAILED: ");
        PrintStatus( Status );
        bPass = FALSE;
        goto CleanUp;
    }

    printf("InitializeSecurityContext SUCCEEDED with Context Handle (0x%x,0x%x)\n",
           ClientCtxtHandle.dwLower, ClientCtxtHandle.dwUpper );


    printf("ISC Context Flags  Req  0x%lx    Ret 0x%lx\n", ClientContextReqFlags, ClientContextRetFlags); 
    ISCRETFlags(ClientContextRetFlags);

    ZeroMemory(cOutputTemp, STR_BUF_SIZE);    // contains the output buffer
    strncpy(cOutputTemp, (char *)OutputBuffers.pBuffers[0].pvBuffer, OutputBuffers.pBuffers[0].cbBuffer);
    cOutputTemp[OutputBuffers.pBuffers[0].cbBuffer] = '\0';

    printf("\nISC: Mutual auth Output Buffer is\n%s\n\n", cOutputTemp);

    printf("Now have a valid Security Context handle from ISC and ASC\n\n");


    // Now get some info on the securitycontexts

    Status = QueryContextAttributes(&ServerCtxtHandle, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes SECPKG_ATTR_STREAM_SIZES error:   status 0x%x\n", Status);
        PrintStatus( Status );
    }
    else
    {
        printf("Server Context Stream Sizes: MaxBuf %lu   Blocksize %lu  Trailer %lu\n",
               StreamSizes.cbMaximumMessage, StreamSizes.cbBlockSize,
               StreamSizes.cbTrailer);
    }

    Status = QueryContextAttributes(&ClientCtxtHandle, SECPKG_ATTR_STREAM_SIZES, &StreamSizes);
    if (!NT_SUCCESS(Status))
    {
        printf("FAILED:    QueryContextAttributes SECPKG_ATTR_STREAM_SIZES error:   status 0x%x\n", Status);
        PrintStatus( Status );
    }
    else
    {
        printf("Client Context Stream Sizes: MaxBuf %lu   Blocksize %lu  Trailer %lu\n",
               StreamSizes.cbMaximumMessage, StreamSizes.cbBlockSize,
               StreamSizes.cbTrailer);
    }
 
    // Now have authenticated connection
    // Try MakeSignature and VerifySignature

    for (i = 0; i < 9; i++)
    {
        printf("Loop %d\n", i);
        ZeroMemory(cTemp, sizeof(cTemp));
        strcpy(cTemp, AUTH_NONCE);            // Create message to sign
    
        InputBuffers.ulVersion = SECBUFFER_VERSION;
        InputBuffers.cBuffers = 5;
        InputBuffers.pBuffers = TempTokensIn;
        
        TempTokensIn[0].BufferType = SECBUFFER_TOKEN;
        TempTokensIn[0].cbBuffer = 0;  
        TempTokensIn[0].pvBuffer = NULL;
        TempTokensIn[1].BufferType = SECBUFFER_DATA;        // select some data to sign
        TempTokensIn[1].cbBuffer = 10;
        TempTokensIn[1].pvBuffer = cTemp;
        TempTokensIn[2].BufferType = SECBUFFER_PADDING;
        TempTokensIn[2].cbBuffer = STR_BUF_SIZE;  // for NULL
        TempTokensIn[2].pvBuffer = cTempPadding;

        TempTokensIn[3].BufferType = SECBUFFER_DATA;        // select some data to sign
        TempTokensIn[3].cbBuffer = 5;   // for NULL  use i to test non-blocksize buffers
        TempTokensIn[3].pvBuffer = cTemp + 10;

        TempTokensIn[4].BufferType = SECBUFFER_DATA;        // select some data to sign
        // TempTokensIn[4].cbBuffer = strlen(AUTH_NONCE) + 1 -2 - 12 - i;   // for NULL  use i to test non-blocksize buffers
        TempTokensIn[4].cbBuffer = 40 + 1 -10 - 5 - i;   // for NULL  use i to test non-blocksize buffers
        TempTokensIn[4].pvBuffer = cTemp + 10 + 5;
    
        if (TempTokensIn[1].cbBuffer)
        {
            printf("Input Message to process is %d bytes in SecBuffer 1\n", TempTokensIn[1].cbBuffer);
            BinToHex((PBYTE)TempTokensIn[1].pvBuffer, TempTokensIn[1].cbBuffer, cTemp2);
            printf("Message: %s\n", cTemp2);
        }
    
        if (TempTokensIn[3].cbBuffer)
        {
            printf("Input Message to process is %d bytes in SecBuffer 3\n", TempTokensIn[3].cbBuffer);
            BinToHex((PBYTE)TempTokensIn[3].pvBuffer, TempTokensIn[3].cbBuffer, cTemp2);
            printf("Message: %s\n", cTemp2);
        }
    
        if (TempTokensIn[4].cbBuffer)
        {
            printf("Input Message to process is %d bytes in SecBuffer 4\n", TempTokensIn[4].cbBuffer);
            BinToHex((PBYTE)TempTokensIn[4].pvBuffer, TempTokensIn[4].cbBuffer, cTemp2);
            printf("Message: %s\n", cTemp2);
        }
    
        Status = EncryptMessage(&ClientCtxtHandle,
                               ulQOP,
                               &InputBuffers,
                               0);
        if (!NT_SUCCESS(Status))
        {
            printf("TestCredAPI: EncryptMessage FAILED: ");
            PrintStatus( Status );
            bPass = FALSE;
            goto CleanUp;
        }
    
    
        // put all of the parts together
        pTemp = (PBYTE)&cTemp3[0];
        ulTemp = 0;
        j = 1;
        memcpy(pTemp, (PBYTE)TempTokensIn[j].pvBuffer, TempTokensIn[j].cbBuffer);
        pTemp = pTemp + TempTokensIn[j].cbBuffer;
        ulTemp = ulTemp + TempTokensIn[j].cbBuffer;
        j = 3;
        memcpy(pTemp, (PBYTE)TempTokensIn[j].pvBuffer, TempTokensIn[j].cbBuffer);
        pTemp = pTemp + TempTokensIn[j].cbBuffer;
        ulTemp = ulTemp + TempTokensIn[j].cbBuffer;
        j = 4;
        memcpy(pTemp, (PBYTE)TempTokensIn[j].pvBuffer, TempTokensIn[j].cbBuffer);
        pTemp = pTemp + TempTokensIn[j].cbBuffer;
        ulTemp = ulTemp + TempTokensIn[j].cbBuffer;

        memcpy(pTemp, (PBYTE)TempTokensIn[2].pvBuffer, TempTokensIn[2].cbBuffer);   // signature bytes
        pTemp = pTemp + TempTokensIn[2].cbBuffer;
        ulTemp = ulTemp + TempTokensIn[2].cbBuffer;


        // You now send Output buffer to Server - in this case the buffer is szOutSecBuf
    
        printf("Now verify that the message is Authenticate\n");
        InputBuffers.ulVersion = SECBUFFER_VERSION;
        InputBuffers.cBuffers = 2;
        InputBuffers.pBuffers = TempTokensIn;
    
    
        TempTokensIn[0].BufferType = SECBUFFER_STREAM;
        TempTokensIn[0].cbBuffer = ulTemp;  
        TempTokensIn[0].pvBuffer = cTemp3;
        TempTokensIn[1].BufferType = SECBUFFER_DATA;    
        TempTokensIn[1].cbBuffer = 0;
        TempTokensIn[1].pvBuffer = NULL;
    
    
        Status = DecryptMessage(&ServerCtxtHandle,
                                 &InputBuffers,
                                 ulMessSeqNo,
                                 &ulQOP);                                   
        if (!NT_SUCCESS(Status))
        {
            printf("TestCredAPI: DecryptMessage Call  FAILED :");
            PrintStatus( Status );
            bPass = FALSE;
            goto CleanUp;
        }
        printf("Now have a authenticated message under context 0x%x\n", ServerCtxtHandle);
    
    
        printf("Processed (verify/unseal)  is %d bytes\n", TempTokensIn[1].cbBuffer);
        if (TempTokensIn[1].cbBuffer)
        {
            BinToHex((PBYTE)TempTokensIn[1].pvBuffer, TempTokensIn[1].cbBuffer, cTemp2);
            printf("Message: %s\n", cTemp2);
        }
    
    }

CleanUp:

    printf("Leaving test program\n");

    if (pPackageInfo)
    {
        FreeContextBuffer(pPackageInfo);
    }

    printf("About to call deletesecuritycontext\n");

    //
    // Free the security context handle
    //
    if (ServerCtxtHandle.dwLower || ServerCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ServerCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ServerCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }

    if (ClientCtxtHandle.dwLower || ClientCtxtHandle.dwUpper)
    {
        Status = DeleteSecurityContext(&ClientCtxtHandle);
        if (!NT_SUCCESS(Status))
        {
            printf("ERROR:  DeleteSecurityContext ClientCtxtHandle failed: ");
            PrintStatus(Status);
        }
    }
    //
    // Free the credential handles
    //

    printf("Now calling to Free the ServerCred\n");
    if (bServerCred)
    {
        Status = FreeCredentialsHandle( &ServerCred );

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ServerCred: " );
            PrintStatus(Status);
        }
    }

    printf("Now calling to Free the ServerCred\n");
    if (bClientCred)
    {
        Status = FreeCredentialsHandle(&ClientCred);

        if (!NT_SUCCESS(Status))
        {
            printf( "FreeCredentialsHandle failed for ClientCred: " );
            PrintStatus( Status );
        }
    }

    StringFree(&strChallenge);
    StringFree(&strMethod);
    StringFree(&strHEntity);
    StringFree(&strOutBuffer);


    if (bPass != TRUE)
        printf("FAILED test run with one or more tests failing.\n");
    else
        printf("All tests passed.\n");

    return 0;
}


void
PrintStatus(
    SECURITY_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = 0x%lx",NetStatus );

    switch (NetStatus) {

    case ERROR_LOGON_FAILURE:
        printf( " ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( " ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( " ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( " ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( " ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( " ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( " ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( " ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( " ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( " ERROR_FILE_NOT_FOUND" );
        break;
    case SEC_E_NO_SPM:
        printf( " SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( " SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( " SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( " SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( " SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( " SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( " SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( " SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( " SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( " SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( " SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( " SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( " SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( " SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( " SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( " SEC_E_NOT_SUPPORTED" ); break;

    case SEC_I_CONTINUE_NEEDED:
        printf( " SEC_I_CONTINUE_NEEDED" ); break;
    }

    printf( "\n" );
}



void
PrintTime(
    LPSTR Comment,
    TimeStamp ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - Local time to print

Return Value:

    None

--*/
{
    LARGE_INTEGER LocalTime;
    NTSTATUS Status;

    LocalTime.HighPart = ConvertTime.HighPart;
    LocalTime.LowPart = ConvertTime.LowPart;

    Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
    if (!NT_SUCCESS( Status )) {
        printf( "Can't convert time from GMT to Local time\n" );
        LocalTime = ConvertTime;
    }

    printf( "%s", Comment );

    //
    // If the time is infinite,
    //  just say so.
    //

    if ( LocalTime.HighPart == 0x7FFFFFFF && LocalTime.LowPart == 0xFFFFFFFF ) {
        printf( "Infinite\n" );

    //
    // Otherwise print it more clearly
    //

    } else {

        TIME_FIELDS TimeFields;

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }

}





// Support Routines


//+-------------------------------------------------------------------------
//
//  Function:   StringAllocate
//
//  Synopsis:   Allocates cb chars to STRING Buffer
//
//  Arguments:  pString - pointer to String to allocate memory to
//
//  Returns:    STATUS_SUCCESS - Normal completion
//
//  Requires:
//
//  Effects:    allocates memory and sets STRING sizes
//
//  Notes:  Must call StringFree() to release memory
//
//--------------------------------------------------------------------------
NTSTATUS
StringAllocate(
    IN PSTRING pString,
    IN USHORT cb
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringAllocate\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    cb = cb + 1;   // Add in extra room for the terminating NULL

    if (ARGUMENT_PRESENT(pString))
    {
        pString->Length = 0;

        pString->Buffer = (char *)DigestAllocateMemory((ULONG)(cb * sizeof(CHAR)));
        if (pString->Buffer)
        {
            pString->MaximumLength = cb;
        }
        else
        {
            pString->MaximumLength = 0;
            Status = STATUS_NO_MEMORY;
            goto CleanUp;
        }
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto CleanUp;
    }

CleanUp:
    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringAllocate\n"));
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   StringFree
//
//  Synopsis:   Clears a String and releases the memory
//
//  Arguments:  pString - pointer to String to clear
//
//  Returns:    SEC_E_OK - released memory succeeded
//
//  Requires:
//
//  Effects:    de-allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
StringFree(
    IN PSTRING pString
    )
{
    // DebugLog((DEB_TRACE, "NTDigest:Entering StringFree\n"));

    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pString) &&
        (pString->Buffer != NULL))
    {
        DigestFreeMemory(pString->Buffer);
        pString->Length = 0;
        pString->MaximumLength = 0;
        pString->Buffer = NULL;
    }

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringFree\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   StringCharDuplicate
//
//  Synopsis:   Duplicates a NULL terminated char. If the source string buffer is
//              NULL the destionation will be too.
//
//  Arguments:  Destination - Receives a copy of the source NULL Term char *
//              czSource - String to copy
//
//  Returns:    SEC_E_OK - the copy succeeded
//              SEC_E_INSUFFICIENT_MEMORY - the call to allocate
//                  memory failed.
//
//  Requires:
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource
    )
{
    // DebugLog((DEB_TRACE, "NTDigest: Entering StringCharDuplicate\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    USHORT cbSourceCz = 0;

    DestinationString->Buffer = NULL;
    DestinationString->Length = 0;
    DestinationString->MaximumLength = 0;

    if ((ARGUMENT_PRESENT(czSource)) &&
        ((cbSourceCz = strlen(czSource)) != 0))
    {

        DestinationString->Buffer = (LPSTR) DigestAllocateMemory(cbSourceCz + sizeof(CHAR));
        if (DestinationString->Buffer != NULL)
        {

            DestinationString->Length = cbSourceCz;
            DestinationString->MaximumLength = cbSourceCz + sizeof(CHAR);
            RtlCopyMemory(
                DestinationString->Buffer,
                czSource,
                cbSourceCz
                );

            DestinationString->Buffer[cbSourceCz/sizeof(CHAR)] = '\0';
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            // DebugLog((DEB_ERROR, "NTDigest: StringCharDuplicate, DigestAllocateMemory returns NULL\n"));
            goto CleanUp;
        }
    }

CleanUp:

    // DebugLog((DEB_TRACE, "NTDigest: Leaving StringCharDuplicate\n"));
    return(Status);

}




//+-------------------------------------------------------------------------
//
//  Function:   DigestAllocateMemory
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:    Allocated chunk is zeroed out
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
DigestAllocateMemory(
    IN ULONG BufferSize
    )
{
    PVOID Buffer = NULL;
    // DebugLog((DEB_TRACE, "Entering DigestAllocateMemory\n"));

        Buffer = LocalAlloc(LPTR, BufferSize);

    // DebugLog((DEB_TRACE, "Leaving DigestAllocateMemory\n"));
    return Buffer;
}



//+-------------------------------------------------------------------------
//
//  Function:   NtLmFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
DigestFreeMemory(
    IN PVOID Buffer
    )
{
    // DebugLog((DEB_TRACE, "Entering DigestFreeMemory\n"));

            LocalFree(Buffer);

    // DebugLog((DEB_TRACE, "Leaving DigestFreeMemory\n"));
}




VOID
BinToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )
{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}




VOID
ISCRETFlags( ULONG ulFlags)
{
    printf("ISC Ret Flag (0x%x):", ulFlags);

    if (ulFlags & ISC_RET_DELEGATE)
    {
        printf(" Delegate");
    }
    if (ulFlags & ISC_RET_MUTUAL_AUTH)
    {
        printf(" Mutual_Auth");
    }
    if (ulFlags & ISC_RET_REPLAY_DETECT)
    {
        printf(" Replay_Detect");
    }
    if (ulFlags & ISC_RET_SEQUENCE_DETECT)
    {
        printf(" Seq_Detect");
    }
    if (ulFlags & ISC_RET_CONFIDENTIALITY)
    {
        printf(" Confident");
    }
    if (ulFlags & ISC_RET_ALLOCATED_MEMORY)
    {
        printf(" Alloc_Mem");
    }
    if (ulFlags & ISC_RET_CONNECTION)
    {
        printf(" Connection");
    }
    if (ulFlags & ISC_RET_INTEGRITY)
    {
        printf(" Integrity");
    }

    printf("\n");
}

VOID
ASCRETFlags( ULONG ulFlags)
{
    printf("ASC Ret Flag (0x%x):", ulFlags);

    if (ulFlags & ASC_RET_DELEGATE)
    {
        printf(" Delegate");
    }
    if (ulFlags & ASC_RET_MUTUAL_AUTH)
    {
        printf(" Mutual_Auth");
    }
    if (ulFlags & ASC_RET_REPLAY_DETECT)
    {
        printf(" Replay_Detect");
    }
    if (ulFlags & ASC_RET_SEQUENCE_DETECT)
    {
        printf(" Seq_Detect");
    }
    if (ulFlags & ASC_RET_CONFIDENTIALITY)
    {
        printf(" Confident");
    }
    if (ulFlags & ASC_RET_ALLOCATED_MEMORY)
    {
        printf(" Alloc_Mem");
    }
    if (ulFlags & ASC_RET_CONNECTION)
    {
        printf(" Connection");
    }
    if (ulFlags & ASC_RET_INTEGRITY)
    {
        printf(" Integrity");
    }

    printf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\digest\testc\testglobal.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        global.h
//
// Contents:    global include file for NTDigest security package
//
//
// History:     KDamour 15Mar00   Stolen from msv_sspi\global.h
//
//------------------------------------------------------------------------

#ifndef NTDIGEST_GLOBAL_H
#define NTDIGEST_GLOBAL_H


#ifndef UNICODE
#define UNICODE
#endif // UNICODE


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#include <windows.h>
#ifndef RPC_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H
#include <rpc.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#define SECURITY_PACKAGE
#define SECURITY_NTLM
#include <security.h>
#include <secint.h>
// #include <dsysdbg.h>
#include <lsarpc.h>
#include <lsaitf.h>
#include <dns.h>
#include <dnsapi.h>
#include <lmcons.h>

#include <md5.h>
#include <hmac.h>

#include <pac.hxx>

// Local includes for NT Digest Access SSP
#include "wdigest.h"       /* Prototype functions for package */


//
// Macros for manipulating globals
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NTDIGEST_GLOBAL
#define EXTERN
#else
#define EXTERN extern
#endif // NTDIGEST_GLOBAL


// Copies a CzString to a String (memory alloc and copy)
NTSTATUS StringCharDuplicate(
    OUT PSTRING DestinationString,
    IN OPTIONAL char *czSource);


// Allocates cb bytes to STRING Buffer
NTSTATUS StringAllocate(IN PSTRING pString, IN USHORT cb);

// Clears a String and releases the memory
NTSTATUS StringFree(IN PSTRING pString);


// Allocate memory in LSA or user mode
PVOID DigestAllocateMemory(IN ULONG BufferSize);

// De-allocate memory from DigestAllocateMemory
VOID DigestFreeMemory(IN PVOID Buffer);



#ifdef __cplusplus
}
#endif // __cplusplus
#endif // NTDIGEST_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\sources.inc ===
MSC_WARNING_LEVEL= /W4 /WX

C_DEFINES=$(C_DEFINES) -DSECURITY_WIN32 -DUNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\bndcache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.cxx
//
// Contents:    Binding cache for Kerberos Package
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define BNDCACHE_ALLOCATE
#include <kerbp.h>

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitBindingCache
//
//  Synopsis:   Initializes the binding cache
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitBindingCache(
    VOID
    )
{
    NTSTATUS Status;

    Status = KerbInitializeList( &KerbBindingCache, BINDING_CACHE_LOCK_ENUM );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerberosBindingCacheInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbBindingCache );
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupBindingCache
//
//  Synopsis:   Frees the binding cache
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupBindingCache(
    BOOLEAN FreeList
    )
{
    PKERB_BINDING_CACHE_ENTRY CacheEntry;

    if (KerberosBindingCacheInitialized)
    {
        KerbLockList(&KerbBindingCache);

        //
        // Go through the list of bindings and dereference them all
        //

        while (!IsListEmpty(&KerbBindingCache.List))
        {
            CacheEntry = CONTAINING_RECORD(
                            KerbBindingCache.List.Flink,
                            KERB_BINDING_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry != NULL );

            KerbReferenceListEntry(
                &KerbBindingCache,
                &CacheEntry->ListEntry,
                TRUE
                );

            KerbDereferenceBindingCacheEntry(CacheEntry);
        }


        //
        // If we want to free the list, orphan the lock, and free the list
        // otherwise, proceed on w/ the "fresh" cache.
        //
        if ( FreeList )
        {
            KerbFreeList(&KerbBindingCache);
        }
        else
        {
            KerbUnlockList(&KerbBindingCache);
        }

    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceBindingCacheEntry
//
//  Synopsis:   Dereferences a binding cache entry
//
//  Effects:    Dereferences the binding cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   BindingCacheEntry - The binding cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbDereferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    if (KerbDereferenceListEntry(
            &BindingCacheEntry->ListEntry,
            &KerbBindingCache
            ) )
    {
        KerbFreeBindingCacheEntry(BindingCacheEntry);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceBindingCacheEntry
//
//  Synopsis:   References a binding cache entry
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  BindingCacheEntry - binding cache entry  to reference
//
//  Requires:   The binding cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    )
{
    KerbLockList(&KerbBindingCache);

    KerbReferenceListEntry(
        &KerbBindingCache,
        &BindingCacheEntry->ListEntry,
        RemoveFromList
        );

    KerbUnlockList(&KerbBindingCache);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateBindingCacheEntry
//
//  Synopsis:   References a binding cache entry by name
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  RealmName - Contains the name of the realm for which to
//                      obtain a binding handle.
//              DesiredFlags - Flags desired for binding, such as PDC required
//              RemoveFromList - Remove cache entry from cache when found.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------

PKERB_BINDING_CACHE_ENTRY
KerbLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG DesiredFlags,
    IN BOOLEAN RemoveFromList
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;

    if (DesiredFlags == 0)
    {
        DesiredFlags = KERB_NO_DC_FLAGS;
    }

    KerbLockList(&KerbBindingCache);

    //
    // Go through the binding cache looking for the correct entry
    //

    for (ListEntry = KerbBindingCache.List.Flink ;
         ListEntry !=  &KerbBindingCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_BINDING_CACHE_ENTRY, ListEntry.Next);

        DsysAssert( CacheEntry != NULL );

        if ( RtlEqualUnicodeString( &CacheEntry->RealmName, RealmName,TRUE ) &&
           ((DesiredFlags & CacheEntry->Flags) == DesiredFlags))
        {     
            Found = TRUE;

            //
            // Check to see if we should stop using this entry
            //
            if (!RemoveFromList)
            {
                TimeStamp CurrentTime, Timeout;
                GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );

                if ((CacheEntry->DcFlags & DS_CLOSEST_FLAG) == 0)
                {
                    Timeout = KerbGlobalFarKdcTimeout;
                }
                else
                {
                    Timeout = KerbGlobalNearKdcTimeout;
                }     
                
                if (KerbGetTime(CacheEntry->DiscoveryTime) + KerbGetTime(Timeout) < KerbGetTime(CurrentTime))
                {
                    //
                    // This entry has timed out - it is not close by and we
                    // don't want to use it for too long, or its time to check
                    // for a close DC again.
                    //
                    //  Note:  This will have the sideeffect of checking for a new PDC
                    //

                    D_DebugLog((DEB_TRACE_BND_CACHE, 
                              "Purging KDC cache entry Realm: %wZ, Addr: %wZ, DcFlags %x\n",
                              &CacheEntry->RealmName,
                              &CacheEntry->KdcAddress,
                              CacheEntry->DcFlags                     
                              ));

                    RemoveFromList = TRUE;
                    Found = FALSE;
                }
#if DBG
                else
                {

                    D_DebugLog((DEB_TRACE_BND_CACHE,
                              "**Using** KDC cache entry Realm: %wZ, Addr: %wZ, DcFlags %x\n",
                              &CacheEntry->RealmName,
                              &CacheEntry->KdcAddress,
                              CacheEntry->DcFlags                     
                              ));      
                    
                    if ((CacheEntry->DcFlags & DS_CLOSEST_FLAG) == DS_CLOSEST_FLAG)
                    {
                        D_DebugLog((DEB_TRACE_BND_CACHE, "CLOSE DC "));
                    }
                    else 
                    {
                        D_DebugLog((DEB_TRACE_BND_CACHE, "FAR DC "));                        
                    }

                    if ((CacheEntry->DcFlags & DS_PDC_FLAG) == DS_PDC_FLAG)
                    {  
                        D_DebugLog((DEB_TRACE_BND_CACHE, "-- ** PDC **\n"));      
                    }
                    else 
                    { 
                        D_DebugLog((DEB_TRACE_BND_CACHE, "-- BDC\n"));    
                    }                                                     
                }

#endif //dbg

            }

            KerbReferenceBindingCacheEntry(
                CacheEntry,
                RemoveFromList
                );

            //
            // If we aren't returning this, dereference it now
            //
            if (!Found)
            {
                KerbDereferenceBindingCacheEntry( CacheEntry );
            }

            break;
        }
    }

    if (!Found)
    {
        CacheEntry = NULL;
    }

    KerbUnlockList(&KerbBindingCache);
    return(CacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeBindingCacheEntry
//
//  Synopsis:   Frees memory associated with a binding cache entry
//
//  Effects:
//
//  Arguments:  BindingCacheEntry - The cache entry to free. It must be
//                      unlinked.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    KerbFreeString(&BindingCacheEntry->RealmName);
    KerbFreeString(&BindingCacheEntry->KdcAddress);

    KerbFree(BindingCacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertBinding
//
//  Synopsis:   Inserts a binding into the binding cache
//
//  Effects:    bumps reference count on binding
//
//  Arguments:  CacheEntry - Cache entry to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInsertBinding(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    )
{
    IF_DEBUG(DISABLE_BND_CACHE) 
    {
        DebugLog((DEB_TRACE_BND_CACHE, "KerbInsertBinding binding cache disabled\n"));
        return STATUS_SUCCESS;
    }
    
    KerbInsertListEntry(
        &CacheEntry->ListEntry,
        &KerbBindingCache
        );

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheBinding
//                                                              
//  Synopsis:   Caches a binding in the binding cache
//
//  Effects:    creates a cache entry.
//
//  Arguments:  RealmName - The realm name of the KDC the binding is to.
//              KdcAddress - address of the KDC
//              AddressType - Type of address, from DsGetDCName flags
//              Flags - These were the desired flags that we asked for
//              DcFlags - These are the flags the dc has
//              CacheFlags - Special meaning so we don't use the locator bits
//              CacheEntry - Receives the new binding cache entry, referenced
//
//  Requires:
//
//  Returns:     STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:      Locks the binding cache for write access while adding
//              the cache entry. Removes a cache entry for the same domain 
//              before adding this one.
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Flags,
    IN ULONG DcFlags,
    IN ULONG CacheFlags,
    OUT PKERB_BINDING_CACHE_ENTRY * NewCacheEntry
    )
{
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    PKERB_BINDING_CACHE_ENTRY OldCacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DesiredFlags = KERB_NO_DC_FLAGS;
    
    D_DebugLog((DEB_TRACE_BND_CACHE,
          "Adding Binding Cache Entry - %wZ : %wZ, DcFlags %x CacheFlags %x\n",
          RealmName,
          KdcAddress,
          DcFlags,
          CacheFlags
          ));

    Flags &= ~DS_FORCE_REDISCOVERY; //not a valid flag

    
    //
    // If we requested a PDC, and this is a PDC, then cache it
    // as a PDC.  Otherwise, we just got lucky, and we'll use 
    // the PDC naturally.
    //
    if ((Flags == DS_PDC_REQUIRED) && ((DcFlags & DS_PDC_FLAG) == DS_PDC_FLAG))
    {
        D_DebugLog((DEB_TRACE_BND_CACHE, "Caching as PDC\n"));      
        DesiredFlags = DS_PDC_REQUIRED;
    } 
    else 
    {
        D_DebugLog((DEB_TRACE_BND_CACHE, "Caching as BDC\n"));
        Flags &= ~DS_PDC_REQUIRED; // clear the flag.
        DcFlags &= ~DS_PDC_FLAG;

    }

    *NewCacheEntry = NULL;

    CacheEntry = (PKERB_BINDING_CACHE_ENTRY)
        KerbAllocate(sizeof(KERB_BINDING_CACHE_ENTRY));
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbInitializeListEntry(
        &CacheEntry->ListEntry
        );

    GetSystemTimeAsFileTime((PFILETIME)
        &CacheEntry->DiscoveryTime
        );

    Status = KerbDuplicateString(
                &CacheEntry->RealmName,
                RealmName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &CacheEntry->KdcAddress,
                KdcAddress
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CacheEntry->AddressType = AddressType;
    CacheEntry->Flags = ((Flags == 0) ? KERB_NO_DC_FLAGS : Flags);
    CacheEntry->DcFlags = DcFlags;
    CacheEntry->CacheFlags = CacheFlags;        


    //
    // Before we insert this binding we want to remove any
    // previous instances of bindings to the same realm.
    //

    OldCacheEntry = KerbLocateBindingCacheEntry(
                        RealmName,
                        DesiredFlags,  // only hammer on PDC entries
                        TRUE    // remove from cache
                        );

    if (OldCacheEntry != NULL)
    {
        KerbDereferenceBindingCacheEntry( OldCacheEntry );
    }

    //
    // Insert the cache entry into the cache
    //

    Status = KerbInsertBinding(
                CacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *NewCacheEntry = CacheEntry;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (NULL != CacheEntry)
        {
            KerbFreeBindingCacheEntry(CacheEntry);
        }
    }

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRemoveBindingCacheEntry
//
//  Synopsis:   removes an entry from the binding cache
//
//  Effects:
//
//  Arguments:  CacheEntry - entry to remove
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbRemoveBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    )
{
    KerbLockList(&KerbBindingCache);

    KerbReferenceBindingCacheEntry(
        CacheEntry,
        TRUE
        );

    KerbDereferenceBindingCacheEntry(
        CacheEntry
        );

    KerbUnlockList(&KerbBindingCache);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\bndcache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.h
//
// Contents:    Prototypes and types for binding handle  cache
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __BNDCACHE_H__
#define __BNDCACHE_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines TKTCACHE_ALLOCATE
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef BNDCACHE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN BOOLEAN KerberosBindingCacheInitialized;
EXTERN KERBEROS_LIST KerbBindingCache;


typedef struct _KERB_BINDING_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    TimeStamp DiscoveryTime;
    UNICODE_STRING RealmName;
    UNICODE_STRING KdcAddress;
    ULONG AddressType;
    ULONG Flags;  // These are requested flags for DsGetDcName
    ULONG DcFlags; // These are flags returned by DsGetDcName
    ULONG CacheFlags; // Valid CacheFlags are listed below
} KERB_BINDING_CACHE_ENTRY, *PKERB_BINDING_CACHE_ENTRY;

//  Valid CacheFlags
#define KERB_BINDING_LOCAL              0x80000000
#define KERB_BINDING_NO_TCP             0x40000000
#define KERB_BINDING_NEGATIVE_ENTRY     0x20000000

#define KERB_NO_DC_FLAGS        0x10000000

VOID
KerbDereferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    );

VOID
KerbReferenceBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    );

NTSTATUS
KerbInitBindingCache(
    VOID
    );

VOID
KerbCleanupBindingCache(
    BOOLEAN FreeList
    );



PKERB_BINDING_CACHE_ENTRY
KerbLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN ULONG DesiredFlags,
    IN BOOLEAN RemoveFromCache
    );


VOID
KerbFreeBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY BindingCacheEntry
    );

VOID
KerbRemoveBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    );

NTSTATUS
KerbCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PUNICODE_STRING KdcAddress,
    IN ULONG AddressType,
    IN ULONG Flags,
    IN ULONG DcFlags,
    IN ULONG CacheFlags,
    OUT PKERB_BINDING_CACHE_ENTRY * NewCacheEntry
    );

NTSTATUS
KerbRefreshBindingCacheEntry(
    IN PKERB_BINDING_CACHE_ENTRY CacheEntry
    );


#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\credmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credmgr.h
//
// Contents:    Structures and prototyps for Kerberos credential list
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __CREDMGR_H__
#define __CREDMGR_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CREDMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CREDMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN KERBEROS_LIST KerbCredentialList;
EXTERN BOOLEAN KerberosCredentialsInitialized;


#define KerbGetCredentialHandle(_Credential_) ((LSA_SEC_HANDLE)(_Credential_))


NTSTATUS
KerbInitCredentialList(
    VOID
    );

VOID
KerbFreeCredentialList(
    VOID
    );


NTSTATUS
KerbAllocateCredential(
    PKERB_CREDENTIAL * NewCredential
    );

NTSTATUS
KerbInsertCredential(
    IN PKERB_CREDENTIAL Credential
    );


NTSTATUS
KerbReferenceCredential(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG Flags,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CREDENTIAL * Credential
    );


VOID
KerbDereferenceCredential(
    IN PKERB_CREDENTIAL Credential
    );


VOID
KerbPurgeCredentials(
    IN PLIST_ENTRY CredentialList
    );

NTSTATUS
KerbCreateCredential(
    IN PLUID LogonId,
    IN PKERB_LOGON_SESSION LogonSession,
    IN ULONG CredentialUseFlags,
    IN PKERB_PRIMARY_CREDENTIAL * SuppliedCredentials,
    IN ULONG CredentialFlags,
    IN PUNICODE_STRING CredentialName,
    OUT PKERB_CREDENTIAL * NewCredential,
    OUT PTimeStamp ExpirationTime
    );

VOID
KerbFreePrimaryCredentials(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN BOOLEAN FreeBaseStructure
    );

NTSTATUS
KerbGetTicketForCredential(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm
    );
//
// Credential flags
//

#define KERB_CRED_INBOUND       SECPKG_CRED_INBOUND
#define KERB_CRED_OUTBOUND      SECPKG_CRED_OUTBOUND
#define KERB_CRED_BOTH          SECPKG_CRED_BOTH
#define KERB_CRED_TGT_AVAIL     0x80000000
#define KERB_CRED_NO_PAC        0x40000000
#define KERB_CRED_RESTRICTED    0x10000000
 

#define KERB_CRED_S4U_REQUIRED  0x01000000
#define KERB_CRED_LOCATE_ONLY   0x04000000     // Don't update the supplied credentials.  Used for S4UToSelf location only.
#define KERB_CRED_LOCAL_ACCOUNT 0x08000000     // set on local accounts so Cred Man may be used


#define KERB_CRED_NULL_SESSION  0x20000000
#define KERB_CRED_LS_DEFAULT    0x00100000



#define KERB_CRED_MATCH_FLAGS (KERB_CRED_INBOUND | KERB_CRED_OUTBOUND | KERB_CRED_NULL_SESSION | KERB_CRED_NO_PAC)
#endif // __CREDMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\credman.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        credman.cxx
//
// Contents:    Code for credentials APIs for the Kerberos package
//
//
// History:     23-Feb-2000   Created         Jeffspel
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>


#if DBG
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

extern "C"
{
#include <des.h>
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredmanCred
//
//  Synopsis:   Frees credman cred
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeCredmanCred(
    IN PKERB_CREDMAN_CRED CredToFree
    )
{
    DsysAssert(CredToFree);
    KerbFreePrimaryCredentials(CredToFree->SuppliedCredentials, TRUE);
    KerbFreeString(&CredToFree->CredmanDomainName);
    KerbFreeString(&CredToFree->CredmanUserName);
    KerbFree(CredToFree);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceCredmanCred
//
//  Synopsis:   Frees credman cred
//
//  Arguments:
//
//  Requires:
//
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbReferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN Unlink
    )
{

    KerbReferenceListEntry(
            &LogonSession->CredmanCredentials,
            &Cred->ListEntry,
            Unlink
            );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceCredmanCred
//
//  Synopsis:   Frees credman cred
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbDereferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERBEROS_LIST CredmanList
    )
{

    if (KerbDereferenceListEntry(
            &Cred->ListEntry,
            CredmanList
            ))
    {
        KerbFreeCredmanCred(Cred);
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredmanList
//
//  Synopsis:   Free a credman list from a logon session...
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreeCredmanList(
    KERBEROS_LIST CredmanList
    )
{
    PKERB_CREDMAN_CRED Cred;
    KerbLockList(&CredmanList);

    //
    // Go through the list of credman creds and dereferences them all
    //

    while (!IsListEmpty(&CredmanList.List))
    {

        Cred = CONTAINING_RECORD(
                    CredmanList.List.Flink,
                    KERB_CREDMAN_CRED,
                    ListEntry.Next
                    );


        // unlink cred from list
        KerbReferenceListEntry(
            &CredmanList,
            &Cred->ListEntry,
            TRUE
            );

        KerbDereferenceCredmanCred(
                Cred,
                &CredmanList
                );

    }

    SafeDeleteCriticalSection(&CredmanList.Lock);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbNotifyCredentialManager
//
//  Synopsis:   This function is used to notify the credential manager of a
//              password change event.   Note:  This will always be a MIT
//              session.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    NTSTATUS, typically ignored, as failure to update the credman
//              should not be fatal.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbNotifyCredentialManager(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CHANGEPASSWORD_REQUEST ChangeRequest,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING RealmName
    )
{

    UNICODE_STRING ClientNameU = {0};
    KERBERR KerbErr;

    // FESTER:
    // We should only expect to get pwd change notification on
    // an MIT Realm pwd change, in which case, there isn't a concept of a
    // Netbios name ....

    KerbErr = KerbConvertKdcNameToString(
                    &ClientNameU,
                    ClientName,
                    NULL
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        return;
    }


    LsaINotifyPasswordChanged(
        NULL,
        &ClientNameU,
        RealmName,
        NULL,
        &ChangeRequest->OldPassword,
        &ChangeRequest->NewPassword,
        ChangeRequest->Impersonating
        );

    KerbFreeString(&ClientNameU);

}





//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePasswords
//
//  Synopsis:   Verifies that two stored credentials are identical, simply
//              through comparison of KERB_ETYPE_RC4_HMAC_NT keys
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//           NULL if the user name is not a marshalled cert, a pointer
//           to the
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOL
KerbComparePasswords(
    IN PKERB_STORED_CREDENTIAL PwdList1,
    IN PKERB_STORED_CREDENTIAL PwdList2
    )
{

    PKERB_ENCRYPTION_KEY Key1 = NULL;
    PKERB_ENCRYPTION_KEY Key2 = NULL;
    ULONG Etype = KERB_ETYPE_RC4_HMAC_NT;

    Key1 = KerbGetKeyFromList(
            PwdList1,
            KERB_ETYPE_RC4_HMAC_NT
            );

    if (NULL == Key1)
    {
        Etype = KERB_ETYPE_DES_CBC_MD5;
       
        Key1 = KerbGetKeyFromList(
                    PwdList1,
                    Etype
                    );                 

        if (NULL == Key1)
        {
            D_DebugLog((DEB_ERROR, "Cred1 missing DES and RC4 key!\n"));
            DsysAssert(FALSE);
            return FALSE;
        }  
    }

    Key2 = KerbGetKeyFromList(
            PwdList2,
            Etype
            );

    if (NULL == Key2)
    {
        D_DebugLog((DEB_ERROR, "Cred2 missing %x key!\n", Etype));
        DsysAssert(FALSE);
        return FALSE;
    }

    return (RtlEqualMemory(
                Key1->keyvalue.value,
                Key2->keyvalue.value,
                Key1->keyvalue.length
                ));

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbLogCredmanError
//
//  Synopsis:   Create an event log entry to help the user fixup their
//              credman credential.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//           NULL if the user name is not a marshalled cert, a pointer
//           to the
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbLogCredmanError(
    IN PKERB_CREDMAN_CRED Cred,
    IN NTSTATUS Status
    )
{
    
    BOOLEAN CardError = FALSE;
    BOOLEAN Pkinit = (Cred->SuppliedCredentials->PublicKeyCreds != NULL);
    
    switch ( Status )
    {
    case STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED:
    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
    case STATUS_SMARTCARD_SILENT_CONTEXT:
        CardError = TRUE;
    case STATUS_NO_SUCH_USER:
    case STATUS_SMARTCARD_WRONG_PIN:
    case STATUS_WRONG_PASSWORD:
        break;
    default:
        return;
    } 
    

    //
    // If this is a *Session, e.g. RAS connection, and we have a card error, 
    // ask the user to reconnect.
    //
    if ((( Cred->CredentialFlags & RAS_CREDENTIAL ) != 0) &&
        ( CardError ))
    {
        KerbReportRasCardError(Status);
        return;
    }      

    KerbReportCredmanError(
         &Cred->SuppliedCredentials->UserName,
         &Cred->SuppliedCredentials->DomainName,
         Pkinit,
         Status
         );


}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckUserNameForCert
//
//  Synopsis:   Looks at the passed in user name and determines if that
//              user name is a marshalled cert.  If it is the function
//              opens the user cert store and then attempts to find the
//              cert in the store.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//           NULL if the user name is not a marshalled cert, a pointer
//           to the
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCheckUserNameForCert(
    IN PLUID ClientLogonId,
    IN BOOLEAN fImpersonateClient,
    IN UNICODE_STRING *pUserName,
    OUT PCERT_CONTEXT *ppCertContext
    )
{
    CRED_MARSHAL_TYPE MarshalType;
    PCERT_CREDENTIAL_INFO pCertCredInfo = NULL;
    HCERTSTORE hCertStore = NULL;
    CRYPT_HASH_BLOB HashBlob;
    LPWSTR rgwszUserName;
    WCHAR FastUserName[(UNLEN + 1) * sizeof(WCHAR)];
    LPWSTR SlowUserName = NULL;
    BOOLEAN fImpersonating = FALSE;
    HANDLE ClientTokenHandle = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    *ppCertContext = NULL;

    // Switch to stackalloc routine when available.
    if( pUserName->Length+sizeof(WCHAR) <= sizeof(FastUserName) )
    {
        rgwszUserName = FastUserName;
    }
    else
    {
        SafeAllocaAllocate(SlowUserName, pUserName->Length+sizeof(WCHAR));

        if( SlowUserName == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        rgwszUserName = SlowUserName;
    }


    RtlCopyMemory(
        rgwszUserName,
        pUserName->Buffer,
        pUserName->Length);
    rgwszUserName[pUserName->Length / sizeof(WCHAR)] = L'\0';


    //
    // unmarshall the cert cred info from the user name field
    // of the cred man cred
    //
    if (!CredUnmarshalCredentialW(
            rgwszUserName,
            &MarshalType,
            (void**)&pCertCredInfo
            ))
    {
        goto Cleanup;
    }
    if (CertCredential != MarshalType)
    {
        goto Cleanup;
    }

    // first need to impersonate the user so that we can call the
    // credential manager as that user
    // TODO: check if this fails.
    // don't do this until new ImpersonateLuid() is available.
    //
    if (NULL == ClientLogonId)
    {
        if (fImpersonateClient)
        {
            Status = LsaFunctions->ImpersonateClient();

            if (!NT_SUCCESS (Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            goto Cleanup;
        }
    }
    else
    {
        Status = LsaFunctions->OpenTokenByLogonId(
                                    ClientLogonId,
                                    &ClientTokenHandle
                                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Unable to get the client token handle.\n"));
            goto Cleanup;
        }

        if(!SetThreadToken(NULL, ClientTokenHandle))
        {
            D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
            Status = STATUS_CANNOT_IMPERSONATE;
            goto Cleanup;
        }
    }

    fImpersonating = TRUE;

    // open a cert store if necessary
    if (NULL == hCertStore)
    {
        hCertStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,
                        0,
                        0,
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        L"MY");
        if (NULL == hCertStore)
        {
            Status = SEC_E_NO_CREDENTIALS;
            D_DebugLog((DEB_ERROR,"Failed to open the user cert store even though a cert cred was found.\n"));
            goto Cleanup;
        }
    }

    // find the cert in the store which meets this hash
    HashBlob.cbData = sizeof(pCertCredInfo->rgbHashOfCert);
    HashBlob.pbData = pCertCredInfo->rgbHashOfCert;
    *ppCertContext = (PCERT_CONTEXT)CertFindCertificateInStore(
                                        hCertStore,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_HASH,
                                        &HashBlob,
                                        NULL);

    if (NULL == *ppCertContext)
    {
        Status = SEC_E_NO_CREDENTIALS;
        D_DebugLog((DEB_ERROR,"Failed to find cert in store even though a cert cred was found.\n"));
        goto Cleanup;
    }

Cleanup:
    if (NULL != hCertStore)
    {
        CertCloseStore(hCertStore, 0);
    }

    if (fImpersonating)
    {
        RevertToSelf();
    }

    if (NULL != pCertCredInfo)
    {
        CredFree (pCertCredInfo);
    }

    if(ClientTokenHandle != NULL)
    {
        CloseHandle( ClientTokenHandle );
    }

    SafeAllocaFree(SlowUserName);

    return Status;
}


// check username for domain/ or @ format
NTSTATUS
CredpParseUserName(
    IN OUT LPWSTR ParseName,
    OUT PUNICODE_STRING pUserName,
    OUT PUNICODE_STRING pDomainName
    )

/*++

Routine Description:

    This routine separates a passed in user name into domain and username.  A user name must have one
    of the following two syntaxes:

        <DomainName>\<UserName>
        <UserName>@<DnsDomainName>

    The name is considered to have the first syntax if the string contains an \.
    A string containing a @ is ambiguous since <UserName> may contain an @.

    For the second syntax, the last @ in the string is used since <UserName> may
    contain an @ but <DnsDomainName> cannot.

    NOTE - The function does not allocate the UNICODE_STRING buffers
    so these should not be freed (RtlInitUnicodeString is used)

Arguments:

    ParseName - Name of user to validate - will be modified

    pUserName - Returned pointing to canonical name inside of ParseName

    pDomainName - Returned pointing to domain name inside of ParseName


Return Values:

    The following status codes may be returned:

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{
    NTSTATUS Status;

    LPWSTR SlashPointer;
    LPWSTR AtPointer;

    LPWSTR pTmpUserName = NULL;
    LPWSTR pTmpDomainName = NULL;

    //
    // NULL is invalid
    //

    if ( ParseName == NULL ) {
        Status = STATUS_INVALID_ACCOUNT_NAME;
        goto Cleanup;
    }

    //
    // Classify the input account name.
    //
    // The name is considered to be <DomainName>\<UserName> if the string
    // contains an \.
    //

    SlashPointer = wcsrchr( ParseName, L'\\' );

    if ( SlashPointer != NULL )
    {
        //
        // point the output strings
        //

        pTmpDomainName = ParseName;

        //
        // Skip the backslash
        //

        *SlashPointer = L'\0';
        SlashPointer ++;

        pTmpUserName = SlashPointer;
    //
    // Otherwise the name must be a UPN
    //
    }
    else
    {
        //
        // A UPN has the syntax <AccountName>@<DnsDomainName>.
        // If there are multiple @ signs,
        //  use the last one since an AccountName can have an @ in it.
        //
        //

        AtPointer = wcsrchr( ParseName, L'@' );
        if ( AtPointer == NULL )
        {
            // must be just <username>
            pTmpUserName = ParseName;
        }
        else
        {
            pTmpUserName = ParseName;
            *AtPointer = L'\0';
            AtPointer ++;

            pTmpDomainName = AtPointer;
        }
    }

    RtlInitUnicodeString( pUserName, pTmpUserName );
    RtlInitUnicodeString( pDomainName, pTmpDomainName );

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:

    return Status;

}

NTSTATUS
CredpExtractMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName,
    OUT CREDENTIAL_TARGET_INFORMATIONW **pTargetInfo
    )
{
    NTSTATUS Status;

    //
    // LSA will set Length to include only the non-marshalled portion,
    // with MaximumLength trailing data to include marshalled portion.
    //

    if( (TargetServerName == NULL) ||
        (TargetServerName->Buffer == NULL) ||
        (TargetServerName->Length >= TargetServerName->MaximumLength) ||
        ((TargetServerName->MaximumLength - TargetServerName->Length) < CRED_MARSHALED_TI_SIZE_SIZE )
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // Unmarshal the target info
    //

    Status = CredUnmarshalTargetInfo (
                    TargetServerName->Buffer,
                    TargetServerName->MaximumLength,
                    pTargetInfo,
                    NULL );

    if( !NT_SUCCESS(Status) )
    {
        if( Status == STATUS_INVALID_PARAMETER )
        {
            Status = STATUS_SUCCESS;
        }
    }

    return Status ;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckForPKINITEnhKeyUsage
//
//  Synopsis:   Checks if the passed in cert context contains the
//              PKINIT enhanced key usage.
//
//  Arguments:  pCertContext - cert context to check for enh key usage
//
//  Requires:
//
//  Returns:    TRUE is success, FALSE is failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOL
KerbCheckForPKINITEnhKeyUsage(
    IN PCERT_CONTEXT pCertContext
    )
{
    LPSTR pszClientAuthUsage = KERB_PKINIT_CLIENT_CERT_TYPE;
    PCERT_ENHKEY_USAGE pEnhKeyUsage = NULL;
    ULONG cbEnhKeyUsage = 0;
    ULONG i;
    BOOLEAN fRet = FALSE;

    if ( pCertContext == NULL )
    {
        return FALSE;
    }

    if (!CertGetEnhancedKeyUsage(
            pCertContext,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,
            &cbEnhKeyUsage))
    {
        goto Cleanup;
    }

    //
    // Allocate space for the key usage structure
    //

    SafeAllocaAllocate(pEnhKeyUsage, cbEnhKeyUsage);

    if (NULL == pEnhKeyUsage)
    {
        goto Cleanup;
    }

    if (!CertGetEnhancedKeyUsage(
            pCertContext,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            pEnhKeyUsage,
            &cbEnhKeyUsage))
    {
        goto Cleanup;
    }

    //
    // Enumerate through the enh key usages looking for the PKINIT one
    //

    for (i=0;i<pEnhKeyUsage->cUsageIdentifier;i++)
    {
        if (0 == strcmp(pszClientAuthUsage, pEnhKeyUsage->rgpszUsageIdentifier[i]))
        {
            fRet = TRUE;
            goto Cleanup;
        }
    }

Cleanup:

    SafeAllocaFree(pEnhKeyUsage);

    return fRet;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddCertCredToPrimaryCredential
//
//  Synopsis:   Adds cert context and Pin info to the kerb credential
//              structure.
//
//  Arguments:  pCertContext - logon session
//              pCertCredInfo - cert cred manager info
//              pKerbCred - credential to be updated
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddCertCredToPrimaryCredential(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PUNICODE_STRING pTargetName,
    IN PCERT_CONTEXT pCertContext,
    IN PUNICODE_STRING pPin,
    IN ULONG CredFlags,
    IN OUT PKERB_PRIMARY_CREDENTIAL *ppCredMgrCred
    )

{
    UNICODE_STRING UserName = {0};
    UNICODE_STRING DomainName = {0};  // get the domain from the UPN in the cert
    PKERB_PRIMARY_CREDENTIAL pOldCred;
    PKERB_PRIMARY_CREDENTIAL pNewCred = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get the client name from the cert.
    // Place it in the return location
    //
    Status = KerbGetPrincipalNameFromCertificate(pCertContext, &UserName);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Initialize the primary credentials structure
    //

    Status = KerbInitPrimaryCreds(
                pLogonSession,
                &UserName,
                &DomainName,
                pTargetName,
                pPin,
                TRUE,
                pCertContext,
                &pNewCred
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pNewCred->PublicKeyCreds->InitializationInfo |= CredFlags;

    Status  = KerbInitializePkCreds(
                    pNewCred->PublicKeyCreds
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pOldCred = *ppCredMgrCred;
    *ppCredMgrCred = pNewCred;
    pNewCred = NULL;


    KerbFreePrimaryCredentials(pOldCred, TRUE);
Cleanup:
    KerbFreeString(&UserName);
    KerbFreePrimaryCredentials(pNewCred, TRUE);

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAddPasswordCredToPrimaryCredential
//
//  Synopsis:   Adds cert context and Pin info to the kerb credential
//              structure.
//
//  Arguments:  pCertContext - logon session
//              pCertCredInfo - cert cred manager info
//              pKerbCred - credential to be updated
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddPasswordCredToPrimaryCredential(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pTargetDomainName,
    IN PUNICODE_STRING pPassword,
    IN OUT PKERB_PRIMARY_CREDENTIAL *ppCredMgrCred
    )
{
    PKERB_PRIMARY_CREDENTIAL pOldCred;
    PKERB_PRIMARY_CREDENTIAL pNewCred = NULL;
    UNICODE_STRING RevealedPassword;
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory(&RevealedPassword, sizeof(RevealedPassword));
    Status = KerbDuplicatePassword(
                &RevealedPassword,
                pPassword
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbRevealPassword( &RevealedPassword );

    //
    // Initialize the primary credentials structure
    //

    Status = KerbInitPrimaryCreds(
                pLogonSession,
                pUserName,
                pTargetDomainName,
                NULL,
                &RevealedPassword,
                FALSE,
                NULL,
                &pNewCred
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pOldCred = *ppCredMgrCred;
    *ppCredMgrCred = pNewCred;
    pNewCred = NULL;


    KerbFreePrimaryCredentials(pOldCred, TRUE);
Cleanup:
    if ((0 != RevealedPassword.Length) && (NULL != RevealedPassword.Buffer))
    {
        RtlSecureZeroMemory(RevealedPassword.Buffer, RevealedPassword.Length);
        KerbFreeString(&RevealedPassword);
    }

    //
    // Don't leak password length
    //
    RevealedPassword.Length = RevealedPassword.MaximumLength = 0;
    KerbFreePrimaryCredentials(pNewCred, TRUE);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateCredmanCred
//
//  Synopsis:   Goes to the credential manager to try and find
//              credentials for the specific target
//
//  Arguments:
//              CredToAdd - PrimaryCredential to add to credman cred
//              ppNewCred - IN OUT built cred, free w/ KerbFreeCredmanCred
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbCreateCredmanCred(
    IN PKERB_PRIMARY_CREDENTIAL CredToAdd,
    IN ULONG AdditionalCredFlags,
    IN OUT PKERB_CREDMAN_CRED * ppNewCred
    )
{

    NTSTATUS Status = STATUS_SUCCESS;

    *ppNewCred = NULL;

    *ppNewCred = (PKERB_CREDMAN_CRED) KerbAllocate(sizeof(KERB_CREDMAN_CRED));
    if (NULL == *ppNewCred)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    Status = KerbDuplicateStringEx(
                    &(*ppNewCred)->CredmanUserName,
                    &CredToAdd->UserName,
                    FALSE
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateStringEx(
                &(*ppNewCred)->CredmanDomainName,
                &CredToAdd->DomainName,
                FALSE
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    (*ppNewCred)->SuppliedCredentials = CredToAdd;
    (*ppNewCred)->CredentialFlags |= AdditionalCredFlags;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        KerbFreeCredmanCred(*ppNewCred);
        *ppNewCred = NULL;
    }


    return (Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAddCredmanCredToLogonSession
//
//  Synopsis:   Goes to the credential manager to try and find
//              credentials for the specific target
//
//  Arguments:  pLogonSession - logon session
//              CredToMatch - PrimaryCredential to look for in logon session
//
//  Requires:   Hold logon session lock...
//
//  Returns:
//
//  Notes:  CredToMatch freed in this function...
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAddCredmanCredToLogonSession(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PKERB_PRIMARY_CREDENTIAL CredToMatch,
    IN ULONG AdditionalCredFlags,
    IN OUT PKERB_CREDMAN_CRED *NewCred
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CREDMAN_CRED CredmanCred = NULL;

    PLIST_ENTRY ListEntry;
    BOOLEAN PublicKeyCred = FALSE;
    BOOLEAN Found = FALSE;

    *NewCred = NULL;


    //
    // First, make a determination if the cred's already listed
    // Replace w/ new one if password has changed.
    //

    KerbLockList(&pLogonSession->CredmanCredentials);


    //
    // Go through the list of logon sessions looking for the correct
    // credentials, if they exist...
    //

    for (ListEntry = pLogonSession->CredmanCredentials.List.Flink ;
         (ListEntry != &pLogonSession->CredmanCredentials.List && !Found);
         ListEntry = ListEntry->Flink )
    {
        CredmanCred = CONTAINING_RECORD(ListEntry, KERB_CREDMAN_CRED, ListEntry.Next);



        // We only match on UserName / DomainName for credman creds
        if(!RtlEqualUnicodeString(
                &CredToMatch->UserName,
                &CredmanCred->CredmanUserName,
                TRUE
                ))
        {
            continue;
        }


        if(!RtlEqualUnicodeString(
                &CredToMatch->DomainName,
                &CredmanCred->CredmanDomainName,
                TRUE
                ))
        {
            continue;
        }

        //
        // Differentiate between pkiint & password based structures
        //
        if ((CredmanCred->SuppliedCredentials->PublicKeyCreds != NULL) &&
            (CredToMatch->PublicKeyCreds != NULL))

        {
            if (!KerbComparePublicKeyCreds(
                    CredToMatch->PublicKeyCreds,
                    CredmanCred->SuppliedCredentials->PublicKeyCreds
                    ))
            {
                continue;
            }

            PublicKeyCred = TRUE;
        }


        Found = TRUE;
        *NewCred = CredmanCred;


    } // FOR


    if (Found)
    {
        KerbReferenceCredmanCred(
            *NewCred,
            pLogonSession,
            FALSE
            );

        D_DebugLog((DEB_TRACE_CRED, "Found match %p\n", (*NewCred)));

        //
        // Found one.  Now we've got to compare the pwd information, and
        // change it, if needed...
        //
        if (!PublicKeyCred)
        {
            //
            // Compare the password list, as the pwd may have changed...
            // Note:  This has the by-product of tossing old tickets, but
            // that's desirable if the pwd's changed, so user knows the creds
            // are bogus.
            //
            if (!KerbComparePasswords(
                    (*NewCred)->SuppliedCredentials->Passwords,
                    CredToMatch->Passwords
                    ))
            {

                D_DebugLog((DEB_ERROR, "Changing credman cred password\n"));

                PKERB_PRIMARY_CREDENTIAL OldPwds = (*NewCred)->SuppliedCredentials;
                (*NewCred)->SuppliedCredentials = CredToMatch;
                KerbFreePrimaryCredentials(OldPwds, TRUE);

                (*NewCred)->CredentialFlags &= ~KERB_CRED_TGT_AVAIL;

            }
            else
            {
                KerbFreePrimaryCredentials(CredToMatch, TRUE);
            }

        }
        else
        {
            //
            //  Free up the cred to match, since we already have a copy stored w/ our credential
            //
            KerbFreePrimaryCredentials(CredToMatch, TRUE);
        }


    }
    else // new cred, so prepare CredmanCred to add to list...
    {

        Status = KerbCreateCredmanCred(
                    CredToMatch,
                    AdditionalCredFlags,
                    NewCred
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        KerbInsertListEntryTail(
            &((*NewCred)->ListEntry),
            &pLogonSession->CredmanCredentials
            );

        // add a ref for caller of this function.
        KerbReferenceCredmanCred(
            (*NewCred),
            pLogonSession,
            FALSE
            );
    }

    //
    // We need an initial TGT for this cred
    //
    if (((*NewCred)->CredentialFlags & KERB_CRED_TGT_AVAIL) == 0)
    {

        //
        // Get an initial TGT for this cred.
        //
        Status = KerbGetTicketGrantingTicket(
                    pLogonSession,
                    NULL,
                    (*NewCred),
                    NULL,
                    NULL,
                    NULL
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to get TGT for credman cred  - %x\n",Status));

            if( Status == STATUS_NO_LOGON_SERVERS )
            {
                //
                // negotiate treats NO_LOGON_SERVERS as a downgrade.
                // Nego allows downgrade for explicit creds, but not default creds.
                // Credman is basically explicit creds.  So over-ride the error code.
                //

                Status = SEC_E_TARGET_UNKNOWN;
            }

            goto Cleanup;
        }

        (*NewCred)->CredentialFlags |= KERB_CRED_TGT_AVAIL;
    }

Cleanup:

    KerbUnlockList(&pLogonSession->CredmanCredentials);

    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertCertCredential
//
//  Synopsis:   Converts a cert cred to a primary cred
//
//  Arguments:  pLogonSession - logon session
//              pTargetName - service name
//              pTargetDomainName - domain name
//              pTargetForestName - forest name
//              pKerbCred - credential to be allocated
//
//  Requires:   You've got to be impersonating when making this call.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbConvertCertCredential(
        IN PKERB_LOGON_SESSION LogonSession,
        IN LPCWSTR MarshalledCredential,
        IN PUNICODE_STRING TargetName,
        IN OUT PKERB_PRIMARY_CREDENTIAL * PrimaryCredential
        )

{
    NTSTATUS                    Status;
    CRED_MARSHAL_TYPE           MarshalType;
    PCERT_CREDENTIAL_INFO       pCertCredInfo = NULL;
    PKERB_PRIMARY_CREDENTIAL    LocalCredential = NULL;
    HCERTSTORE                  hCertStore = NULL;
    CRYPT_HASH_BLOB             HashBlob;
    PCERT_CONTEXT               pCertContext = NULL;
    UNICODE_STRING              Pin = {0};

    *PrimaryCredential = NULL;

    //
    // unmarshal the cert cred info from the user name field
    // of the cred man cred
    //
    if (!CredUnmarshalCredentialW(
            MarshalledCredential,
            &MarshalType,
            (void**)&pCertCredInfo
            ))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if (CertCredential != MarshalType)
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    // open a cert store if necessary
    hCertStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    0,
                    0,
                    CERT_SYSTEM_STORE_CURRENT_USER,
                    L"MY"
                    );

    if (NULL == hCertStore)
    {
        D_DebugLog((DEB_ERROR,"Failed to open the user cert store even though a cert cred was found.\n"));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    // find the cert in the store which meets this hash
    HashBlob.cbData = sizeof(pCertCredInfo->rgbHashOfCert);
    HashBlob.pbData = pCertCredInfo->rgbHashOfCert;
    pCertContext = (PCERT_CONTEXT)CertFindCertificateInStore(
                                        hCertStore,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_HASH,
                                        &HashBlob,
                                        pCertContext);

    if ( KerbCheckForPKINITEnhKeyUsage( pCertContext ) )
    {
        //
        // add the cert credential to the Kerb credential
        //
        // Cred man will no longer give us a pin, only the CSP
        // knows that information...
        //
        Status = KerbAddCertCredToPrimaryCredential(
                    LogonSession,
                    TargetName,
                    pCertContext,
                    &Pin,   // essentially, a NULL string
                    CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS,
                    &LocalCredential
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN,"Failed to add the cert cred to the credential.\n"));
            goto Cleanup;
        }


    }
    else
    {
        //
        // Can't find the certificate
        //
        DebugLog((DEB_ERROR, "Can't find cert from credman\n"));

        //
        // TBD:
        // Log Event
        /*
            KerbReportCredmanError(ID_MISSING_CERT);

          */
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }


    *PrimaryCredential = LocalCredential;
    LocalCredential = NULL;

Cleanup:

    if (NULL != pCertCredInfo)
    {
        CredFree(pCertCredInfo);
    }

    if (NULL != pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if ( LocalCredential )
    {
        KerbFree( LocalCredential );
    }

    if (NULL != hCertStore)
    {
        CertCloseStore(hCertStore, 0);
    }

    return (Status);
}







//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckCredMgrForGivenTarget
//
//  Synopsis:   Goes to the credential manager to try and find
//              credentials for the specific target
//
//  Arguments:  pLogonSession - logon session
//              pTargetName - service name
//              pTargetDomainName - domain name
//              pTargetForestName - forest name
//              pKerbCred - credential to be allocated
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCheckCredMgrForGivenTarget(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PUNICODE_STRING SuppliedTargetName,
    IN PKERB_INTERNAL_NAME pTargetName,
    IN ULONG TargetInfoFlags,
    IN PUNICODE_STRING pTargetDomainName,
    IN PUNICODE_STRING pTargetForestName,
    IN OUT PKERB_CREDMAN_CRED *CredmanCred,
    IN OUT PBYTE *pbMarshalledTargetInfo,
    IN OUT ULONG *cbMarshalledTargetInfo
    )
{
    CREDENTIAL_TARGET_INFORMATIONW CredTargetInfo;
    ULONG cCreds = 0;
    PCREDENTIALW           *rgpCreds = NULL;
    PCREDENTIALW            CertCred = NULL;
    PCREDENTIALW            PasswordCred = NULL;
    PENCRYPTED_CREDENTIALW *rgpEncryptedCreds = NULL;
    LPWSTR pwszTargetName = NULL;
    LPWSTR pwszDomainName = NULL;
    LPWSTR pwszForestName = NULL;
    BOOLEAN Impersonating = FALSE;
    ULONG i;
    UNICODE_STRING CredManUserName = {0};
    UNICODE_STRING CredManDomainName = {0};
    UNICODE_STRING CredManTargetName = {0};
    UNICODE_STRING Password = {0};
    UNICODE_STRING RevealedPassword;
    HANDLE ClientTokenHandle = NULL;
    CREDENTIAL_TARGET_INFORMATIONW *pTargetInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PRIMARY_CREDENTIAL pCredMgrCred = NULL;
    HANDLE ImpersonationToken = NULL;
    USHORT ClearBlobSize = 0;
    ULONG AdditionalCredFlags = 0;
    SECPKG_CALL_INFO CallInfo = {0};

    RtlZeroMemory(&CredTargetInfo, sizeof(CredTargetInfo));
    RtlZeroMemory(&RevealedPassword, sizeof(RevealedPassword));

    *CredmanCred = NULL;

    Status = CredpExtractMarshalledTargetInfo(
                        SuppliedTargetName,
                        &pTargetInfo
                        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Allocate space for the names
    //

    if (NULL != pTargetName)
    {
        //
        // want to use the second part of the SPN
        //
        if (pTargetName->NameCount > 1)
        {
            SafeAllocaAllocate(pwszTargetName, pTargetName->Names[1].Length + sizeof(WCHAR));

            if (NULL == pwszTargetName)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                (PUCHAR)pwszTargetName,
                pTargetName->Names[1].Buffer,
                pTargetName->Names[1].Length);

            pwszTargetName[pTargetName->Names[1].Length / sizeof(WCHAR)] = L'\0';
            CredTargetInfo.DnsServerName = pwszTargetName;
            RtlInitUnicodeString(&CredManTargetName, pwszTargetName);
        }
    }

    if ((NULL != pTargetDomainName) && (0 != pTargetDomainName->Length) &&
        (NULL != pTargetDomainName->Buffer))
    {
        SafeAllocaAllocate(pwszDomainName, pTargetDomainName->Length + sizeof(WCHAR));

        if (NULL == pwszDomainName)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            (PUCHAR)pwszDomainName,
            pTargetDomainName->Buffer,
            pTargetDomainName->Length);

        pwszDomainName[pTargetDomainName->Length / sizeof(WCHAR)] = L'\0';
        CredTargetInfo.DnsDomainName = pwszDomainName;
    }

    if ((NULL != pTargetForestName) && (0 != pTargetForestName->Length) &&
        (NULL != pTargetForestName->Buffer))
    {
        SafeAllocaAllocate(pwszForestName, pTargetForestName->Length + sizeof(WCHAR));

        if (NULL == pwszForestName)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            (PUCHAR)pwszForestName,
            pTargetForestName->Buffer,
            pTargetForestName->Length);

        pwszForestName[pTargetForestName->Length / sizeof(WCHAR)] = L'\0';
        CredTargetInfo.DnsTreeName = pwszForestName;
    }

    CredTargetInfo.PackageName = KERBEROS_PACKAGE_NAME;

    //
    // if marshalled targetinfo supplied, use it instead.
    //

    if ( pTargetInfo )
    {
        CredTargetInfo.TargetName = pTargetInfo->TargetName;
        CredTargetInfo.NetbiosServerName = pTargetInfo->NetbiosServerName;
        CredTargetInfo.DnsServerName = pTargetInfo->DnsServerName;
        CredTargetInfo.NetbiosDomainName = pTargetInfo->NetbiosDomainName;
        CredTargetInfo.DnsDomainName = pTargetInfo->DnsDomainName;
        CredTargetInfo.DnsTreeName = pTargetInfo->DnsTreeName;
        CredTargetInfo.Flags |= pTargetInfo->Flags;
    }
    else
    {
        //
        // copy the names in to the memory and set the names
        // in the PCREDENTIAL_TARGET_INFORMATIONW struct
        //

        if (pwszTargetName)
        {
            CredTargetInfo.Flags |= CRED_TI_SERVER_FORMAT_UNKNOWN;
        }
        if (pwszDomainName)
        {
            CredTargetInfo.Flags |= CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }

        CredTargetInfo.Flags |= TargetInfoFlags;
    }

    // need to specify a flag to indicate that we don't know what we are
    // doing and both types of names should be checked.

    Status = LsaFunctions->CrediReadDomainCredentials(
                            &LogonSession->LogonId,
                            CREDP_FLAGS_IN_PROCESS,     // Allow password to be returned
                            &CredTargetInfo,
                            0,
                            &cCreds,
                            &rgpEncryptedCreds );

    rgpCreds = (PCREDENTIALW *) rgpEncryptedCreds;

    //
    // return a copy of the credential target info for kernel callers (MUP/DFS/RDR).
    //

    if (NT_SUCCESS(Status) || (CallInfo.Attributes & SECPKG_CALL_KERNEL_MODE))
    {
        CredMarshalTargetInfo(
            &CredTargetInfo,
            (PUSHORT*)pbMarshalledTargetInfo,
            cbMarshalledTargetInfo
            );
    }

    if (!NT_SUCCESS(Status))
    {
        // quiet these.
        if ((Status == STATUS_NOT_FOUND) ||(Status == STATUS_NO_SUCH_LOGON_SESSION) )
        {
            D_DebugLog((DEB_TRACE, "No credentials from the cred mgr!\n", Status));
        }
        else
        {
            DebugLog((DEB_WARN, "Failed to read credentials from the cred mgr 0x%x.\n", Status));
        }

        // indicate success so we proceed with default creds
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Look for cred types we understand.
    //
    for (i = 0; i < cCreds; i++)
    {
        if ((rgpCreds[i])->Type == CRED_TYPE_DOMAIN_CERTIFICATE)
        {
            CertCred = rgpCreds[i];
            ClearBlobSize = (USHORT) (rgpEncryptedCreds[i])->ClearCredentialBlobSize;
        }
        else if ((rgpCreds[i])->Type == CRED_TYPE_DOMAIN_PASSWORD)
        {
            PasswordCred = rgpCreds[i];
            ClearBlobSize = (USHORT) (rgpEncryptedCreds[i])->ClearCredentialBlobSize;
        }
    }

    if (!(CertCred || PasswordCred))
    {
        DebugLog((DEB_ERROR, "Found no credman creds we understand\n"));
        // indicate success so we proceed with default creds
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // now evaluate the creds which were returned to determine
    // which one we should use.
    //
    // First choice is a certificate which may be
    // used for PKINIT.
    //
    if ( CertCred )
    {

        // check for the prompt now flag
        if (CertCred->Flags & CRED_FLAGS_PROMPT_NOW)
        {
            DebugLog((DEB_ERROR, "Asking for prompt on credman cred \n"));
            Status = STATUS_SMARTCARD_SILENT_CONTEXT;
            goto Cleanup;
        }


        if (!lstrcmpW(CRED_SESSION_WILDCARD_NAME_W, CertCred->TargetName))
        {
            AdditionalCredFlags |= RAS_CREDENTIAL;
        }



        if( !Impersonating )
        {

            //
            // Save off the old token, if it exists.
            //
            Status = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_QUERY | TOKEN_IMPERSONATE,
                        TRUE,
                        &ImpersonationToken
                        );

            if (!NT_SUCCESS( Status ) && Status != STATUS_NO_TOKEN )
            {
                DebugLog((DEB_ERROR, "NtOpenThreadToken failed %x\n", Status));
                goto Cleanup;
            }

            Status = LsaFunctions->OpenTokenByLogonId(
                                        &LogonSession->LogonId,
                                        &ClientTokenHandle
                                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Unable to get the client token handle.\n"));
                goto Cleanup;
            }

            if(!SetThreadToken(NULL, ClientTokenHandle))
            {
                D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
                Status = STATUS_CANNOT_IMPERSONATE;
                goto Cleanup;
            }

            Impersonating = TRUE;
        }

        Status = KerbConvertCertCredential(
                        LogonSession,
                        CertCred->UserName,
                        &CredManTargetName,
                        &pCredMgrCred
                        );

        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "KerbConvertCertCredential failed %x\n", Status));
            goto Cleanup;
        }

    }
    else if ( PasswordCred )
    {

        // check for the prompt now flag
        if ( PasswordCred->Flags & CRED_FLAGS_PROMPT_NOW)
        {
            DebugLog((DEB_ERROR, "Asking for prompt on credman cred \n"));
            Status = SEC_E_LOGON_DENIED;
            goto Cleanup;
        }

        if (!lstrcmpW(CRED_SESSION_WILDCARD_NAME_W, PasswordCred->TargetName))
        {
            AdditionalCredFlags |= RAS_CREDENTIAL;
        }

        //
        // get the user name and domain name from the credential manager info
        //
        // NOTE - CredpParseUserName does not allocate the UNICODE_STRING
        // buffers so these should not be freed (RtlInitUnicodeString is used)
        //

        Status = CredpParseUserName(
                        PasswordCred->UserName,
                        &CredManUserName,
                        &CredManDomainName);

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN,"Failed to parse the add the cert cred to the credential.\n"));
            goto Cleanup;
        }

        Password.Buffer = (LPWSTR)(PasswordCred->CredentialBlob);
        Password.MaximumLength = (USHORT)PasswordCred->CredentialBlobSize;
        Password.Length = ClearBlobSize;

        // add the cert credential to the Kerb credential
        Status = KerbAddPasswordCredToPrimaryCredential(
                        LogonSession,
                        &CredManUserName,
                        &CredManDomainName,
                        &Password,
                        &pCredMgrCred
                        );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to add the cred mgr password to the credential.\n"));
            goto Cleanup;
        }
    }
    else
    {
        //
        // NO creds found we can use.
        //
        DebugLog((DEB_ERROR, "No valid creds in credman\n"));
        Status = STATUS_NOT_FOUND;
        goto Cleanup;

    }

    //
    // We've built the credman cred, now go ahead and add it to the logon.
    //
    Status = KerbAddCredmanCredToLogonSession(
                        LogonSession,
                        pCredMgrCred, // note: freed by this fn
                        AdditionalCredFlags,
                        CredmanCred
                        );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to add credman cred to logon session\n"));
        goto Cleanup;
    }

Cleanup:

    if (Impersonating)
    {
        if (ImpersonationToken != NULL)
        {
            SetThreadToken(NULL, ImpersonationToken);

        }
        else
        {
            RevertToSelf();
        }
    }

    if ( ImpersonationToken )
    {
        CloseHandle(ImpersonationToken);
    }

    if ( ClientTokenHandle )
    {
        CloseHandle( ClientTokenHandle );
    }

    if( pTargetInfo != NULL )
    {
        LocalFree( pTargetInfo );
    }

    SafeAllocaFree(pwszTargetName);
    SafeAllocaFree(pwszDomainName);
    SafeAllocaFree(pwszForestName);

    if (NULL != rgpCreds)
    {
        //
        // Free the returned credentials
        //

        LsaFunctions->CrediFreeCredentials(
                                cCreds,
                                rgpEncryptedCreds );
    }

    return Status;
}

NTSTATUS
CopyCredManCredentials(
    IN PLUID LogonId,
    CREDENTIAL_TARGET_INFORMATIONW* pTargetInfo,
    IN OUT PUNICODE_STRING pUserName,
    IN OUT PUNICODE_STRING pDomainName,
    IN OUT PUNICODE_STRING pPassword
    )

/*++

Routine Description:

    Look for a keyring credential entry for the specified domain, and copy to Context handle if found

Arguments:

    LogonId -- LogonId of the calling process.

    pTargetInfo -- Information on target to search for creds.

    Context - Points to the ContextHandle of the Context
        to be referenced.

Return Value:

    STATUS_SUCCESS -- All OK

    STATUS_NOT_FOUND - Credential couldn't be found.

    All others are real failures and should be returned to the caller.
--*/

{
    NTSTATUS Status;
    PCREDENTIALW *Credentials = NULL;
    PENCRYPTED_CREDENTIALW *EncryptedCredentials = NULL;
    ULONG CredentialCount;
    ULONG CredIndex;

    RtlInitUnicodeString(pUserName, NULL);
    RtlInitUnicodeString(pDomainName, NULL);
    RtlInitUnicodeString(pPassword, NULL);

    Status = LsaFunctions->CrediReadDomainCredentials(
                            LogonId,
                            CREDP_FLAGS_IN_PROCESS,     // Allow password to be returned
                            pTargetInfo,
                            0,  // no flags
                            &CredentialCount,
                            &EncryptedCredentials );

    Credentials = (PCREDENTIALW *) EncryptedCredentials;

    if(!NT_SUCCESS(Status))
    {
        //
        // Ideally, only STATUS_NO_SUCH_LOGON_SESSION should be converted to
        // STATUS_NOT_FOUND.  However, swallowing all failures and asserting
        // these specific two works around a bug in CrediReadDomainCredentials
        // which returns invalid parameter if the target is a user account name.
        // Eventually, CrediReadDomainCredentials should return a more appropriate
        // error in this case.
        //

        return STATUS_NOT_FOUND;
    }


    //
    // Loop through the list of credentials
    //

    for ( CredIndex=0; CredIndex<CredentialCount; CredIndex++ ) {

        UNICODE_STRING UserName;
        UNICODE_STRING DomainName;
        UNICODE_STRING TempString;

        //
        // only supports password credentials
        //

        if ( Credentials[CredIndex]->Type != CRED_TYPE_DOMAIN_PASSWORD ) {
            continue;
        }

        if ( Credentials[CredIndex]->Flags & CRED_FLAGS_PROMPT_NOW ) {
            Status = SEC_E_LOGON_DENIED;
            goto Cleanup;
        }

        //
        // Sanity check the credential
        //

        if ( Credentials[CredIndex]->UserName == NULL ) {
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Convert the UserName to domain name and user name
        //

        Status = CredpParseUserName(
                        Credentials[CredIndex]->UserName,
                        &UserName,
                        &DomainName
                        );

        if(!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if( DomainName.Buffer )
        {
            Status = KerbDuplicateString(pDomainName, &DomainName);
            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup;
            }
        }



        if( UserName.Buffer )
        {
            Status = KerbDuplicateString(pUserName, &UserName);
            if ( !NT_SUCCESS( Status ) )
            {
                goto Cleanup;
            }
        }


        //
        // Free the existing password and add the new one
        //

        TempString.Buffer = (LPWSTR)Credentials[CredIndex]->CredentialBlob;
        TempString.MaximumLength = (USHORT) Credentials[CredIndex]->CredentialBlobSize;
        TempString.Length = (USHORT) EncryptedCredentials[CredIndex]->ClearCredentialBlobSize;

        // zero length password must be treated as blank or will assume it should use the
        // password of the currently logged in user.

        if ( TempString.Length == 0 )
        {
            TempString.Buffer = L"";
        }

        Status = KerbDuplicatePassword(pPassword, &TempString);
        if ( !NT_SUCCESS( Status ) )
        {
            goto Cleanup;
        }

        goto Cleanup;
    }

    Status = STATUS_NOT_FOUND;

Cleanup:

    if(!NT_SUCCESS(Status))
    {
        KerbFreeString( pUserName );
        KerbFreeString( pDomainName );
        KerbFreeString( pPassword );

        pUserName->Buffer = NULL;
        pDomainName->Buffer = NULL;
        pPassword->Buffer = NULL;
    }

    //
    // Free the returned credentials
    //

    LsaFunctions->CrediFreeCredentials(
                            CredentialCount,
                            EncryptedCredentials );

    return Status;
}



NTSTATUS
KerbProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    )
{

    WCHAR FastUserName[ UNLEN+1 ];
    LPWSTR SlowUserName = NULL;
    LPWSTR TempUserName;
    CRED_MARSHAL_TYPE CredMarshalType;
    PUSERNAME_TARGET_CREDENTIAL_INFO pCredentialUserName = NULL;

    CREDENTIAL_TARGET_INFORMATIONW TargetInfo;
    ULONG CredTypes;

    SECPKG_CLIENT_INFO ClientInfo;
    NTSTATUS Status = STATUS_NOT_FOUND;


    if( (MarshalledUserName->Length+sizeof(WCHAR)) <= sizeof(FastUserName) )
    {
        TempUserName = FastUserName;
    }
    else
    {
        SafeAllocaAllocate(SlowUserName, MarshalledUserName->Length + sizeof(WCHAR));

        if( SlowUserName == NULL )
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        TempUserName = SlowUserName;
    }


    //
    // copy the input to a NULL terminated string, then attempt to unmarshal it.
    //

    RtlCopyMemory(  TempUserName,
                    MarshalledUserName->Buffer,
                    MarshalledUserName->Length
                    );

    TempUserName[ MarshalledUserName->Length / sizeof(WCHAR) ] = L'\0';

    if(!CredUnmarshalCredentialW(
                        TempUserName,
                        &CredMarshalType,
                        (VOID**)&pCredentialUserName
                        ))
    {
        goto Cleanup;
    }

    if( (CredMarshalType != UsernameTargetCredential) )
    {
        goto Cleanup;
    }


    //
    // now query credential manager for a match.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ZeroMemory( &TargetInfo, sizeof(TargetInfo) );

    CredTypes = CRED_TYPE_DOMAIN_PASSWORD;

    TargetInfo.Flags = CRED_TI_USERNAME_TARGET;
    TargetInfo.TargetName = pCredentialUserName->UserName;
    TargetInfo.PackageName = KERBEROS_PACKAGE_NAME;
    TargetInfo.CredTypeCount = 1;
    TargetInfo.CredTypes = &CredTypes;


    Status = CopyCredManCredentials(
                    &ClientInfo.LogonId,
                    &TargetInfo,
                    UserName,
                    DomainName,
                    Password
                    );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbRevealPassword( Password );

Cleanup:

    if( pCredentialUserName != NULL )
    {
        CredFree( pCredentialUserName );
    }

    SafeAllocaFree( SlowUserName );

    return Status;
}






//+-------------------------------------------------------------------------
//
//  Function:   KerbMarshallMSVCredential
//
//  Synopsis:   Takes a SECPKG_SUPPLEMENTAL_CRED and bundles it up as a
//              PCREDENTIAL structure.
//
//  Arguments:  NtlmCred - Supplemental cred from PAC
//              MarshalledCred - credential being created.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbMarshallMSVCredential(
        IN PSECPKG_SUPPLEMENTAL_CRED NtlmCred,
        IN PUNICODE_STRING UserName,
        IN PUNICODE_STRING TargetName,
        IN OUT PKERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE * MarshalledCred,
        IN OUT PULONG Size
        )
{

    PKERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE  LocalCred = NULL;
    NTSTATUS                                 Status = STATUS_SUCCESS;
    PBYTE                                    Where;
    ULONG                                    LocalSize;


    LocalSize = (sizeof(KERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE) +
                    ROUND_UP_COUNT( UserName->MaximumLength, ALIGN_LPDWORD ) +
                    ROUND_UP_COUNT( TargetName->MaximumLength, ALIGN_LPDWORD ) +
                    ROUND_UP_COUNT( NtlmCred->CredentialSize, DESX_BLOCKLEN));


    LocalCred = (PKERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE) KerbAllocate(LocalSize);
    if (LocalCred == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Where = (PBYTE) LocalCred + sizeof(KERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE);

    RtlCopyMemory(
        Where,
        UserName->Buffer,
        UserName->MaximumLength
        );

    LocalCred->ReturnedCreds.Cred.UserName = (LPWSTR) Where;
    Where += ROUND_UP_COUNT(UserName->MaximumLength, ALIGN_LPDWORD);

    RtlCopyMemory(
        Where,
        TargetName->Buffer,
        TargetName->MaximumLength
        );

    LocalCred->ReturnedCreds.Cred.TargetName = (LPWSTR) Where;

    Where += ROUND_UP_COUNT(TargetName->MaximumLength, ALIGN_LPDWORD);

    RtlCopyMemory(
            Where,
            NtlmCred->Credentials,
            NtlmCred->CredentialSize
            );

    LocalCred->ReturnedCreds.ClearCredentialBlobSize = NtlmCred->CredentialSize;
    LocalCred->ReturnedCreds.Cred.CredentialBlob = Where;
    LocalCred->ReturnedCreds.Cred.CredentialBlobSize = NtlmCred->CredentialSize;

    LsaFunctions->LsaProtectMemory(
                    LocalCred->ReturnedCreds.Cred.CredentialBlob,
                    (ROUND_UP_COUNT(NtlmCred->CredentialSize, DESX_BLOCKLEN))
                    );


    LocalCred->ReturnedCreds.Cred.Flags = CRED_FLAGS_OWF_CRED_BLOB;
    LocalCred->ReturnedCreds.Cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
    LocalCred->ReturnedCreds.Cred.Persist = CRED_PERSIST_SESSION;

    *MarshalledCred = LocalCred;
    LocalCred = NULL;
    *Size = LocalSize;

Cleanup:

    if (LocalCred)
    {
        KerbFree(LocalCred);
    }


    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveOWF
//
//  Synopsis:   Converts a smartcard credential into a credential containing
//              the NT_OWF.
//
//  Arguments:  NtlmCred - Supplemental cred from PAC
//              MarshalledCred - credential being created.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbRetrieveOWF(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL    Credential,
    IN PKERB_CREDMAN_CRED  CredmanCred,
    IN PUNICODE_STRING     CredTargetName,
    IN OUT PKERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE * Response,
    IN OUT PULONG                   ResponseSize
    )
{
    NTSTATUS Status;
    ULONG    i;

    PSECPKG_SUPPLEMENTAL_CRED_ARRAY     PacCreds = NULL;
    PSECPKG_SUPPLEMENTAL_CRED           NtlmCred = NULL;
    PKERB_TICKET_CACHE_ENTRY            NewTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY            Tgt = NULL;
    UNICODE_STRING                      TempName = {0};
    UNICODE_STRING                      UserName = {0};
    UNICODE_STRING                      Package = {0};
    BOOLEAN                             CrossRealm = FALSE;
    LPWSTR                              tmp = NULL;
    KERB_TGT_REPLY                      TgtReply = {0};
    PKERB_INTERNAL_NAME                 TargetName = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3      ValidationInfo = NULL;
    ULONG Size;

    PKERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE LocalResponse = NULL;

    *Response = NULL;
    *ResponseSize = 0;

    //
    // First get a TGT for U2U
    //
    KerbReadLockLogonSessions( LogonSession );
    
    Status = KerbGetTgtForService(
                LogonSession,
                Credential,
                CredmanCred,
                NULL,
                &TempName,  // no target realm
                KERB_TICKET_CACHE_PRIMARY_TGT,
                &Tgt,
                &CrossRealm
                );

    KerbUnlockLogonSessions( LogonSession );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KerbRetrieveOWF failed to get TGT: %#x\n", Status));
        goto Cleanup;
    }

    if (CrossRealm)
    {
        DsysAssert(CrossRealm == FALSE);
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    TgtReply.version = KERBEROS_VERSION;
    TgtReply.message_type = KRB_TGT_REP;
    TgtReply.ticket = Tgt->Ticket;

    DsysAssert(CredmanCred->CredmanDomainName.Length == 0);

    if (!KERB_SUCCESS(KerbConvertStringToKdcName(
        &TargetName,
        &CredmanCred->CredmanUserName
        )))
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // HACK HACK
    // KerbConvertStringToKdcName builds a bogus name type.
    //
    TargetName->NameType = KRB_NT_ENTERPRISE_PRINCIPAL;

    Status = KerbGetServiceTicket(
                LogonSession,
                Credential,
                CredmanCred,
                TargetName, // should be a UPN
                &Tgt->ClientDomainName,
                NULL,
                0,
                0,
                0,
                NULL,
                NULL,
                &TgtReply,
                &NewTicket,
                NULL
                );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbGetServiceTicket failed - %x\n", Status ));
        goto Cleanup;
    }

    //
    // Pull the supplemental creds from the ticket.
    //
    Status = KerbGetCredsFromU2UTicket(
                NewTicket,
                Tgt,
                &PacCreds,
                &ValidationInfo
                );

    if (!NT_SUCCESS( Status))
    {
        DebugLog((DEB_ERROR, "KerbGetCredsFromTicket failed %x\n", Status));
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &Package,
        NTLMSP_NAME
        );

    for ( i = 0; i < PacCreds->CredentialCount; i++ )
    {
        if (RtlEqualUnicodeString(
                &PacCreds->Credentials[i].PackageName,
                &Package,
                TRUE
                ))
        {
            NtlmCred = &PacCreds->Credentials[i];
            break;
        }
    }


    if (NtlmCred == NULL || ValidationInfo == NULL)
    {
        DebugLog((DEB_ERROR, "No NTLM creds %p or ValidationInfo %p found in PAC\n", NtlmCred, ValidationInfo));
        Status = STATUS_NOT_FOUND;
        DsysAssert(FALSE);
        goto Cleanup;
    }

    UserName.MaximumLength = ValidationInfo->EffectiveName.Length + ValidationInfo->LogonDomainName.Length + (2 * sizeof(WCHAR));
    UserName.Length = UserName.MaximumLength - sizeof(WCHAR);

    SafeAllocaAllocate(UserName.Buffer, UserName.MaximumLength);
    if (UserName.Buffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(UserName.Buffer, UserName.MaximumLength);

    //
    // ntlm accepts empty domain name, therefore "\username" is valid
    //

    tmp = UserName.Buffer;

    RtlCopyMemory(
        tmp,
        ValidationInfo->LogonDomainName.Buffer,
        ValidationInfo->LogonDomainName.Length
        );

    tmp += (ValidationInfo->LogonDomainName.Length / sizeof(WCHAR));

    *tmp = L'\\';
    tmp++;

    RtlCopyMemory(
        tmp,
        ValidationInfo->EffectiveName.Buffer,
        ValidationInfo->EffectiveName.Length
        );

    //
    // Build the resultant CREDENTIAL for MSV.
    //

    Status = KerbMarshallMSVCredential(
                NtlmCred,
                &UserName,
                CredTargetName,
                &LocalResponse,
                &Size
                );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbMarshalMSVCredential failed %x\n", Status));
        goto Cleanup;
    }

    *Response = LocalResponse;
    LocalResponse = NULL;

    *ResponseSize = Size;

Cleanup:

    if ( PacCreds )
    {
        MIDL_user_free( PacCreds );
    }


    if ( ValidationInfo )
    {
        MIDL_user_free( ValidationInfo );
    }

    SafeAllocaFree( UserName.Buffer );
    KerbFreeString( &TempName );

    if ( TargetName )
    {
        KerbFreeKdcName( &TargetName );
    }

    if ( NewTicket )
    {
        KerbDereferenceTicketCacheEntry( NewTicket );
    }

    if ( LocalResponse )
    {
        KerbFree(LocalResponse);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbTicklePackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:   Readlock logon session
//
//  Returns:
//
//  Notes:  In order to optimize perf, we order this 1. current password,
//  2. "extra" credentials, 3. old passwords
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbTicklePackage(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PUNICODE_STRING CredentialBlob
    )
{
    NTSTATUS                    Status;
    PKERB_PRIMARY_CREDENTIAL    CertCred = NULL;
    PKERB_CREDMAN_CRED          CredmanCred = NULL;
    UNICODE_STRING              TargetName;
    LPWSTR                      CredBlob = NULL;
    HANDLE                      OldToken = NULL, ClientToken = NULL;


    //
    // Fester:
    // If we ever extend this, we may need to change the value here.
    // For now, its just the *session
    //
    RtlInitUnicodeString(
        &TargetName,
        CRED_SESSION_WILDCARD_NAME_W
        );

    //
    // Make sure we pass a NULL terminated cred
    //
    SafeAllocaAllocate( CredBlob, ( CredentialBlob->MaximumLength + sizeof(WCHAR)));
    if ( CredBlob == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( CredBlob, ( CredentialBlob->MaximumLength + sizeof(WCHAR)));
    RtlCopyMemory( CredBlob, CredentialBlob->Buffer, CredentialBlob->Length );


    //
    // Got to be impersonating to make this call...
    //
    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &OldToken
                );

    if (!NT_SUCCESS( Status ) && Status != STATUS_NO_TOKEN )
    {
        DebugLog((DEB_ERROR, "NtOpenThreadToken failed %x\n", Status));
        goto Cleanup;
    }

    Status = LsaFunctions->OpenTokenByLogonId(
                &LogonSession->LogonId,
                &ClientToken
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Unable to get the client token handle.\n"));
        goto Cleanup;
    }

    if(!SetThreadToken(NULL, ClientToken))
    {
        D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
        Status = STATUS_CANNOT_IMPERSONATE;
        goto Cleanup;
    }

    Status = KerbConvertCertCredential(
                LogonSession,
                CredBlob,
                &TargetName,
                &CertCred
                );

    if (!NT_SUCCESS( Status ))
    {
        D_DebugLog((DEB_ERROR, "Failed to convert cert cred %x\n", Status));
        goto Cleanup;
    }       
            
    KerbReadLockLogonSessions(LogonSession);

    Status = KerbAddCredmanCredToLogonSession(
                LogonSession,
                CertCred,  // note: freed by this fn, if necessary...
                RAS_CREDENTIAL,
                &CredmanCred
                );

    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS( Status ))
    {
        D_DebugLog((DEB_ERROR, "Failed to add credman cred %x\n", Status));
        goto Cleanup;
    }

Cleanup:

    if ( OldToken )
    {
        if (!SetThreadToken( NULL, OldToken ))
        {
            D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
            Status = STATUS_CANNOT_IMPERSONATE;
        }

        CloseHandle( OldToken );
    }
    else
    {
        RevertToSelf();
    }

    if ( ClientToken )
    {
        CloseHandle( ClientToken );

    }


    SafeAllocaFree( CredBlob );

    if ( CredmanCred )
    {
       KerbDereferenceCredmanCred(
            CredmanCred,
            &LogonSession->CredmanCredentials
            );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtapi.cxx
//
// Contents:    Context APIs for Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include "kerbevt.h"
#include <gssapip.h>
#include <krbaudit.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif
UNICODE_STRING KerbTargetPrefix = {sizeof(L"krb5://")-sizeof(WCHAR),sizeof(L"krb5://"),L"krb5://" };


#ifdef DBG
LONG Audits = 0;
LONG Token = 0;
#endif

#define FILENO FILENO_CTXTAPI
//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteContext
//
//  Synopsis:   Deletes a Kerberos context
//
//  Effects:
//
//  Arguments:  ContextHandle - The context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_HANDLE
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context;
    KERB_CONTEXT_STATE ContextState;
    ULONG ClientProcess = 0;

    D_DebugLog((DEB_TRACE_API,"SpDeleteContext 0x%x called\n",ContextHandle));

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        Context = NULL;
        goto Cleanup;
    }

    Status = KerbReferenceContext(
                    ContextHandle,
                    TRUE,                        // unlink handle
                    &Context
                    );

    if (Context == NULL)
    {
        D_DebugLog((DEB_ERROR,"SpDeleteContext: Context 0x%x not located. %ws, line %d\n",ContextHandle, THIS_FILE, __LINE__));
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    KerbReadLockContexts();

    // Need to copy out the context data else we'll end up holding the lock
    // for too long a time.
    //
    ContextState = Context->ContextState;

    ClientProcess = Context->ClientProcess;
    KerbUnlockContexts();

    // If this was a context that was dropped in the middle,
    // audit it as a logon failure.
    //

    if (ContextState == ApReplySentState)
    {
        LsaFunctions->AuditLogon(
            STATUS_UNFINISHED_CONTEXT_DELETED,
            STATUS_SUCCESS,
            &Context->ClientName,
            &Context->ClientRealm,
            NULL,                       // no workstation
            Context->UserSid,
            Network,
            &KerberosSource,
            &Context->LogonId
            );
    }
#endif // WIN32_CHICAGO

    //
    // Now dereference the Context. If nobody else is using this Context
    // currently it will be freed.
    //

    KerbDereferenceContext(Context);
    Status = STATUS_SUCCESS;

Cleanup:

    D_DebugLog((DEB_TRACE_LEAKS,"SpDeleteContext returned 0x%x, Context 0x%x, Pid 0x%x\n",KerbMapKerbNtStatusToNtStatus(Status), Context, ClientProcess));
    D_DebugLog((DEB_TRACE_API, "SpDeleteContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbProcessTargetNames
//
//  Synopsis:   Takes the target names from both the negotiate hint and
//              supplied by the caller and creates the real Kerberos target
//              name.
//
//  Effects:
//
//  Arguments:  TargetName - supplies the name passed in the TargetName
//                      parameter of InitializeSecurityContext.
//              SuppTargetName - If present, an alternate name passed in
//                      a security token.
//              Flags - flags to use when cracking a name. May be:
//                  KERB_CRACK_NAME_USE_WKSTA_REALM - if no realm can be
//                          determined, use the realm of the wksta
//                  KERB_CRACK_NAME_REALM_SUPPLIED - the caller has the
//                      realm name, so treat "@" in the name as a normal
//                      character, not a spacer.
//              UseSpnRealmSupplied - If the target name was an spn and it
//                      contained a realm, it's set to TRUE
//              FinalTarget - The processed name.  Must be freed with KerbFreeKdcName.
//              TargetRealm - If the name contains a realm portions, this is
//                      the realm. Should be freed using KerbFreeString.
//
//
//  Requires:
//
//  Returns:
//
//  Notes:      If the name has an "@" in it, it is converted into a standard
//              Kerberos V5 name - everything after the "@" is put in the
//              realm field, and everything before the @ is separted at the
//              "/" characters into different pieces of the name. Depending
//              on the number of pieces, it is passed as a KRB_NT_PRINCIPAL (1)
//              or KRB_NT_SRV_INSTANCE (2), or KRB_NT_SRV_XHST (3+)
//
//              If the name has an "\" in it, it is assumed to be an NT4
//              name & put as is into a KRB_NT_MS_PRINCIPAL_NAME name
//
//              If the name has neither a "\" or a "@" or a "/", it is
//              assumed to be a simple name & passed as KRB_NT_PRINCIPAL
//              in the caller's domain.
//
//
//
//--------------------------------------------------------------------------

#ifdef later
#define KERB_LOCALHOST_NAME L"localhost"
#endif

NTSTATUS
KerbProcessTargetNames(
    IN PUNICODE_STRING TargetName,
    IN OPTIONAL PUNICODE_STRING SuppTargetName,
    IN ULONG Flags,
    IN OUT PULONG ProcessFlags,
    OUT PKERB_INTERNAL_NAME * FinalTarget,
    OUT PUNICODE_STRING TargetRealm,
    OUT OPTIONAL PKERB_SPN_CACHE_ENTRY * SpnCacheEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SHORT NameType = 0;
    PKERB_INTERNAL_NAME OutputName = NULL;
    USHORT NameParts = 0, ExtraNameParts = 0;
    ULONG NameLength = 0;
    USHORT Index, NameIndex;
    PUNICODE_STRING RealTargetName;
    UNICODE_STRING CacheTargetRealm = {0};
    UNICODE_STRING SuppliedRealm = {0};
    UNICODE_STRING FirstNamePart = {0};
    PKERB_SPN_CACHE_ENTRY LocalCacheEntry = NULL;
#ifdef later
    UNICODE_STRING LocalhostName = {0};
    BOOLEAN ReplaceLocalhost = FALSE;
#endif
    BOOLEAN DoneParsing = FALSE;
    PKERB_MIT_REALM MitRealm;
    BOOLEAN UsedAlternateName;
    PUCHAR Where;

    *ProcessFlags = 0;

    //
    // If a supplemental target name was supplied, use it as it is more likely
    // to be correct.
    //

    if (ARGUMENT_PRESENT(SuppTargetName) && (SuppTargetName->Length > 0))
    {
        RealTargetName = SuppTargetName;
    }
    else
    {
        RealTargetName = TargetName;
    }

    //
    // If this is an IP address, we don't handle it so bail now.
    //

    if (KerbIsIpAddress(RealTargetName))
    {
        D_DebugLog((DEB_ERROR,"Ip address passed as target name: %wZ. Failing InitSecCtxt\n",
            RealTargetName ));
        Status = SEC_E_TARGET_UNKNOWN;
        goto Cleanup;
    }

#ifdef later
    RtlInitUnicodeString(
        &LocalhostName,
        KERB_LOCALHOST_NAME
        );
#endif


    //
    // Initialize the first part of the name to the whole string
    //

    FirstNamePart.Buffer = RealTargetName->Buffer;
    FirstNamePart.Length = RealTargetName->Length;
    FirstNamePart.MaximumLength = FirstNamePart.Length;

    //
    // Check the characters in the name. Search backwards to front because
    // username may have "@" signs in them.
    //

    for ( Index = (RealTargetName->Length / sizeof(WCHAR)); Index-- > 0; )
    {
        switch(RealTargetName->Buffer[Index])
        {
        case L'@':

            //
            // If we have a realm name already, ignore this character.
            //

            if ((Flags & KERB_CRACK_NAME_REALM_SUPPLIED) != 0)
            {
                break;
            }

            //
            // If we haven't hit any other separators, this is user@domain kind
            // of name
            //


            if (NameType == 0)
            {
                NameType = KRB_NT_PRINCIPAL;
                NameParts++;

                SuppliedRealm.Buffer = &RealTargetName->Buffer[Index] + 1;
                SuppliedRealm.Length = RealTargetName->Length - (Index + 1) * sizeof(WCHAR);
                SuppliedRealm.MaximumLength = SuppliedRealm.Length;

                if (SuppliedRealm.Length == 0)
                {
                    Status = SEC_E_TARGET_UNKNOWN;
                    goto Cleanup;
                }

                FirstNamePart.Buffer = RealTargetName->Buffer;
                FirstNamePart.Length = Index * sizeof(WCHAR);
                FirstNamePart.MaximumLength = FirstNamePart.Length;
            }
//            else
//            {
//                Status = SEC_E_TARGET_UNKNOWN;
//                goto Cleanup;
//            }

            break;

        case L'/':

            //
            // All names that have a '/' separator are KRB_NT_SRV_INST
            // If we saw an @before this, we need to do something special.
            //

            NameType = KRB_NT_SRV_INST;
            NameParts ++;
            break;


        case L'\\':

            //
            // If we have a realm name already, ignore this character.
            //

            if ((Flags & KERB_CRACK_NAME_REALM_SUPPLIED) != 0)
            {
                break;
            }

            //
            // If we hit a backslash, this is an NT4 style name, so treat it
            // as such.
            // Just for error checking purposes, make sure that the current
            // name type was 0
            //

            if (NameType != 0)
            {
                Status = SEC_E_TARGET_UNKNOWN;
                goto Cleanup;
            }
            NameType = KRB_NT_MS_PRINCIPAL;
            NameParts = 1;
            SuppliedRealm.Buffer = RealTargetName->Buffer;
            SuppliedRealm.Length = Index * sizeof(WCHAR);
            SuppliedRealm.MaximumLength = SuppliedRealm.Length;

            FirstNamePart.Buffer = &RealTargetName->Buffer[Index] + 1;
            FirstNamePart.Length = RealTargetName->Length - (Index + 1) * sizeof(WCHAR);
            FirstNamePart.MaximumLength = FirstNamePart.Length;

            if (SuppliedRealm.Length == 0 || FirstNamePart.Length == 0)
            {
                Status = SEC_E_TARGET_UNKNOWN;
                goto Cleanup;
            }

            DoneParsing = TRUE;

            break;

        default:
            break;

        }
        if (DoneParsing)
        {
            break;
        }
    }

    //
    // If we didn't exit early, then we were sent a name with no "@" sign.
    // If there were no separators, then it is a flat principal name
    //

    if (!DoneParsing && (NameType == 0))
    {
        if (NameParts == 0)
        {
            //
            // The name has no separators, so it is a flat principal name
            //

            NameType = KRB_NT_PRINCIPAL;
            NameParts = 1;
        }
    }

    //
    // For KRB_NT_SRV_INST, get the name parts correct and tell the caller
    // that a realm was supplied in the spn
    //

    if (NameType == KRB_NT_SRV_INST)
    {
        if (SuppliedRealm.Length == 0)
        {
            // We have an spn of the form a/b..../n and the name parts needs
            // to be upped by one
            // If we had an spn of the form a/b@c, then the name
            // parts would be right.

            NameParts++;
        }
        else
        {
            // We need to filter this back to the caller so that the
            // name canonicalization bit is not set.

            *ProcessFlags |= KERB_GET_TICKET_NO_CANONICALIZE;
        }
    }

    //
    // Check for an MIT realm with the supplied realm - if the name type is
    // KRB_NT_PRINCIPAL, send it as a UPN unless we can find an MIT realm.
    // If we are not a member of a domain, then we can't default so use
    // the domain name supplied. Also, if we are using supplied credentials
    // we don't want to use the wksta realm.

    if ( (NameType == KRB_NT_PRINCIPAL) 
         && (KerbGetGlobalRole() != KerbRoleRealmlessWksta) // not realmless
         && ((Flags & KERB_CRACK_NAME_USE_WKSTA_REALM) != 0) )
    {
        BOOLEAN Result;
        Result = KerbLookupMitRealm(
                    &SuppliedRealm,
                    &MitRealm,
                    &UsedAlternateName
                    );
        //
        // If we didn't find a realm, use this as a UPN
        //

        if (!Result)
        {
            //
            // If the caller supplied the realm separately, then don't
            // send it as a UPN.
            //

            if ((Flags & KERB_CRACK_NAME_REALM_SUPPLIED) == 0)
            {
                //
                // send it as UPN

                NameType = KRB_NT_ENTERPRISE_PRINCIPAL;
                NameParts = 1;
                FirstNamePart = *RealTargetName; 
                RtlInitUnicodeString(
                    &SuppliedRealm,
                    NULL
                    );
            }
        }
        //
        // For logon, its interesting to know if we're doing an MIT realm lookup
        //
        else
        {
            D_DebugLog((DEB_TRACE, "Using MIT realm in Process TargetName\n"));
            *ProcessFlags |= KERB_MIT_REALM_USED;
        }
    }

    NameLength = FirstNamePart.Length + NameParts * sizeof(WCHAR);


    D_DebugLog((DEB_TRACE_CTXT,
                "Parsed name %wZ (%wZ) into:\n\t name type 0x%x, name count %d, \n\t realm %wZ, \n\t first part %wZ\n",
                TargetName,
                SuppTargetName,
                NameType,
                NameParts,
                &SuppliedRealm,
                &FirstNamePart
                ));

#ifdef later
    //
    // If the name end in "localhost", replace it with our dns machine
    // name.
    //

    if ((NameType == KRB_NT_SRV_INST) &&
        (NameParts == 2) &&
        (RealTargetName->Length > LocalhostName.Length) &&
        RtlEqualMemory(
            RealTargetName->Buffer + (RealTargetName->Length - LocalhostName.Length ) / sizeof(WCHAR),
            LocalhostName.Buffer,
            LocalhostName.Length
            ))

    {
        NameLength -= LocalhostName.Length;
        KerbGlobalReadLock();
        NameLength += KerbGlobalMitMachineServiceName->Names[1].Length;

        //
        // Set the flag to indicate we need to replace the name, and that
        // the global lock is held.
        //

        ReplaceLocalhost = TRUE;
    }
#endif

    //
    // Create the output names
    //

    OutputName = (PKERB_INTERNAL_NAME) KerbAllocate(KERB_INTERNAL_NAME_SIZE(NameParts + ExtraNameParts) + NameLength);
    if (OutputName == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    OutputName->NameCount = NameParts + ExtraNameParts;
    OutputName->NameType = NameType;

    Where = (PUCHAR) OutputName + KERB_INTERNAL_NAME_SIZE(NameParts+ExtraNameParts);
    NameIndex = 0;

    //
    // If there is only one part of the name, handle that first
    //

    if (NameParts == 1)
    {
        OutputName->Names[0].Length = FirstNamePart.Length;
        OutputName->Names[0].MaximumLength = FirstNamePart.Length + sizeof(WCHAR);
        OutputName->Names[0].Buffer = (LPWSTR) Where;
        RtlCopyMemory(
            Where,
            FirstNamePart.Buffer,
            FirstNamePart.Length
            );
        OutputName->Names[0].Buffer[FirstNamePart.Length / sizeof(WCHAR)] = L'\0';
        Where += FirstNamePart.Length + sizeof(WCHAR);
        NameIndex = 1;

    }
    else
    {
        UNICODE_STRING TempName;

        //
        // Build up the name, piece by piece
        //

        DoneParsing = FALSE;
        NameIndex = 0;
        TempName.Buffer = FirstNamePart.Buffer;

        for ( Index = 0; Index <= FirstNamePart.Length / sizeof(WCHAR) ; Index++ )
        {
            //
            // If we hit the end or a separator, build a name part
            //

            if ((Index == FirstNamePart.Length / sizeof(WCHAR)) ||
                (FirstNamePart.Buffer[Index] == L'/') )
            {
#ifdef later
                if ((NameIndex == 1) && (ReplaceLocalhost))
                {
                    OutputName->Names[NameIndex].Length = KerbGlobalMitMachineServiceName->Names[1].Length;
                    OutputName->Names[NameIndex].MaximumLength = OutputName->Names[NameIndex].Length + sizeof(WCHAR);
                    OutputName->Names[NameIndex].Buffer = (LPWSTR) Where;

                    RtlCopyMemory(
                        Where,
                        KerbGlobalMitMachineServiceName->Names[1].Buffer,
                        OutputName->Names[NameIndex].Length
                        );
                    //
                    // Release the lock now
                    //

                    KerbGlobalReleaseLock();
                    ReplaceLocalhost = FALSE;
                }
                else
#endif
                {
                    OutputName->Names[NameIndex].Length = (USHORT) (&FirstNamePart.Buffer[Index] - TempName.Buffer) * sizeof(WCHAR);
                    OutputName->Names[NameIndex].MaximumLength = OutputName->Names[NameIndex].Length + sizeof(WCHAR);
                    OutputName->Names[NameIndex].Buffer = (LPWSTR) Where;

                    RtlCopyMemory(
                        Where,
                        TempName.Buffer,
                        OutputName->Names[NameIndex].Length
                        );
                }
                Where += OutputName->Names[NameIndex].Length;
                *(LPWSTR)Where = L'\0';
                Where += sizeof(WCHAR);


                NameIndex++;
                TempName.Buffer = &FirstNamePart.Buffer[Index+1];
            }
        }

        DsysAssert(NameParts == NameIndex);
    }

    //
    // Now that we've built the output name, check SPN Cache.
    //

    if ( ARGUMENT_PRESENT(SpnCacheEntry) &&
         NameType == KRB_NT_SRV_INST     &&
         SuppliedRealm.Length == 0 )

    {

        LocalCacheEntry = KerbLocateSpnCacheEntry(OutputName);

        if (NULL != LocalCacheEntry)
        {   
            DebugLog((DEB_TRACE_SPN_CACHE, "Found in SPN Cache %p ", LocalCacheEntry));
            D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, LocalCacheEntry->Spn));  
            
            *SpnCacheEntry = LocalCacheEntry;
            LocalCacheEntry = NULL;

            *ProcessFlags |= KERB_TARGET_USED_SPN_CACHE;

        }
        else
        {
            //
            // This is used for HostToRealm mappings.
            //
            KerbSpnSubstringMatch(
                            OutputName,
                            &CacheTargetRealm
                            );
        }

    }

    D_DebugLog((DEB_TRACE_CTXT,"Cracked name %wZ into: ", RealTargetName));
    D_KerbPrintKdcName((DEB_TRACE_CTXT,OutputName));

    //
    // Only use SPN cache w/o supplied credentials - we don't even talk
    // to the cache if the SuppliedRealm is present.
    //
    if (CacheTargetRealm.Buffer != NULL)
    {
        Status = KerbDuplicateString(
                    TargetRealm,
                    &CacheTargetRealm
                    );

    }
    else if (((Flags & KERB_CRACK_NAME_USE_WKSTA_REALM) == 0) || SuppliedRealm.Length > 0)
    {
        Status = KerbDuplicateString(
                        TargetRealm,
                        &SuppliedRealm
                        );
    }
    else
    {
        if ((Flags & KERB_CRACK_NAME_USE_WKSTA_REALM) == 0)
        {
            DsysAssert(FALSE); // hey, this shouldn't ever be hit...
            RtlInitUnicodeString(
                TargetRealm,
                NULL
                );
        }
        else
        {
            //
            // There was no realm name provided, so use the wksta domain
            //
            Status = KerbGetOurDomainName(
                            TargetRealm
                            );
        }

    }
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *FinalTarget = OutputName;
    OutputName = NULL;

Cleanup:

#ifdef later
    if (ReplaceLocalhost)
    {
        KerbGlobalReleaseLock();
    }
#endif

    if ( LocalCacheEntry ) 
    {
        KerbDereferenceSpnCacheEntry( LocalCacheEntry );
    }

    KerbFreeString( &CacheTargetRealm );

    if (OutputName != NULL)
    {
        KerbFree(OutputName);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbValidateChannelBindings
//
//  Synopsis:   Validates the channel bindings copied from the client.
//
//  Effects:
//
//  Arguments:  pBuffer -- Input buffer that contains channel bindings
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
KerbValidateChannelBindings(
    IN  PVOID pBuffer,
    IN  ULONG ulBufferLength
    )
{
    PSEC_CHANNEL_BINDINGS pClientBindings = (PSEC_CHANNEL_BINDINGS) pBuffer;
    DWORD                 dwBindingLength;
    DWORD                 dwInitiatorEnd;
    DWORD                 dwAcceptorEnd;
    DWORD                 dwApplicationEnd;

    //
    // If channel bindings were specified, they had better be there
    //

    if (pBuffer == NULL || ulBufferLength < sizeof(SEC_CHANNEL_BINDINGS))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure we got one contiguous buffer
    //

    dwBindingLength = sizeof(SEC_CHANNEL_BINDINGS)
                            + pClientBindings->cbInitiatorLength
                            + pClientBindings->cbAcceptorLength
                            + pClientBindings->cbApplicationDataLength;

    //
    // Make sure the lengths are valid and check for overflow
    //

    if (dwBindingLength > ulBufferLength)
    {
        return STATUS_INVALID_PARAMETER;
    }

    dwInitiatorEnd   = pClientBindings->dwInitiatorOffset + pClientBindings->cbInitiatorLength;
    dwAcceptorEnd    = pClientBindings->dwAcceptorOffset + pClientBindings->cbAcceptorLength;
    dwApplicationEnd = pClientBindings->dwApplicationDataOffset + pClientBindings->cbApplicationDataLength;

    if ((dwInitiatorEnd > dwBindingLength || dwInitiatorEnd < pClientBindings->dwInitiatorOffset)
         ||
        (dwAcceptorEnd > dwBindingLength || dwAcceptorEnd < pClientBindings->dwAcceptorOffset)
         ||
        (dwApplicationEnd > dwBindingLength || dwApplicationEnd < pClientBindings->dwApplicationDataOffset))
    {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitLsaModeContext
//
//  Synopsis:   Kerberos implementation of InitializeSecurityContext. This
//              routine handles the client side of authentication by
//              acquiring a ticket to the specified target. If a context
//              handle is passed in, then the input buffer is used to
//              verify the authenticity of the server.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpInitLsaModeContext(
    IN OPTIONAL LSA_SEC_HANDLE CredentialHandle,
    IN OPTIONAL LSA_SEC_HANDLE ContextHandle,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG ContextRequirements,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputBuffers,
    OUT PLSA_SEC_HANDLE NewContextHandle,
    IN OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_LOGON_SESSION CallerLogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry = NULL;
    ULONG TicketOptions = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    LUID LogonId;
    PUCHAR Request = NULL;
    ULONG RequestSize = 0;
    PUCHAR Reply = NULL;
    ULONG ReplySize;
    PSecBuffer OutputToken = NULL;
    PSecBuffer InputToken = NULL;
    UNICODE_STRING LocalTargetName;
    UNICODE_STRING TargetDomainName;
    PKERB_INTERNAL_NAME TargetInternalName = NULL;
    ULONG Index;
    PKERB_CONTEXT Context = NULL;
    ULONG Nonce = 0;
    ULONG ProcessFlags = 0;
    ULONG ReceiveNonce = 0;
    ULONG ContextFlags = 0;
    ULONG ContextAttribs = 0;
    ULONG LogonSessionFlags = 0;
    TimeStamp ContextLifetime;
    TimeStamp AuthenticatorTime = {0};
    BOOLEAN DoThirdLeg = FALSE;
    BOOLEAN GetAuthTicket = FALSE;
    BOOLEAN UseNullSession = FALSE;
    BOOLEAN GetServerTgt = FALSE;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_ERROR_METHOD_DATA ErrorData = NULL;
    PKERB_EXT_ERROR pExtendedError = NULL;
    PKERB_TGT_REPLY TgtReply = NULL;
    PKERB_SPN_CACHE_ENTRY SpnCacheEntry = NULL;
    ULONG ContextRetries = 0;
    KERB_CONTEXT_STATE ContextState = InvalidState;
    KERB_ENCRYPTION_KEY SubSessionKey = {0};
    BOOLEAN ClientAskedForDelegate = FALSE, ClientAskedForDelegateIfSafe = FALSE;
    ULONG ClientProcess = 0;
    PKERB_CREDMAN_CRED CredManCredentials = NULL;
    NTSTATUS InitialStatus = STATUS_SUCCESS;
    PSEC_CHANNEL_BINDINGS pChannelBindings = NULL;
    PKERB_TICKET_CACHE_ENTRY EvidenceTicket = NULL;
    PBYTE pbMarshalledTargetInfo = NULL;
    ULONG cbMarshalledTargetInfo = 0;

    KERB_INITSC_INFO InitSCTraceInfo;
    InitSCTraceInfo.EventTrace.Size = 0;
    LUID LocalSystemLuid = SYSTEM_LUID;

    D_DebugLog((DEB_TRACE_API, "SpInitLsaModeContext 0x%x called\n", ContextHandle));

    if( KerbEventTraceFlag ) // Event Trace: KerbInitSecurityContextStart {No Data}
    {
        InitSCTraceInfo.EventTrace.Guid       = KerbInitSCGuid;
        InitSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        InitSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
            InitSCTraceInfo.EventTrace.Size       = sizeof (EVENT_TRACE_HEADER);

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&InitSCTraceInfo
        );
    }

    //
    // Initialize the outputs.
    //

    *ContextAttributes = 0;
    *NewContextHandle = 0;
    *ExpirationTime = KerbGlobalHasNeverTime;
    *MappedContext = FALSE;
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;
    LocalTargetName.Buffer = NULL;
    LocalTargetName.Length = 0;
    TargetDomainName.Buffer = NULL;
    TargetDomainName.Length = 0;

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // Make sure we have at least one ip address
    //

    KerbGlobalReadLock();
    if (KerbGlobalNoTcpUdp)
    {
        Status = STATUS_NETWORK_UNREACHABLE;
    }
    KerbGlobalReleaseLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Delegate will mean delegate_if_safe for this
    // release (NT5)
    //

    if ( ContextRequirements & ISC_REQ_DELEGATE )
    {
        ClientAskedForDelegate = TRUE;
        ContextRequirements |= ISC_REQ_DELEGATE_IF_SAFE ;
        ContextRequirements &= ~(ISC_REQ_DELEGATE) ;
    }
    else if ( ContextRequirements & ISC_REQ_DELEGATE_IF_SAFE )
    {
        ClientAskedForDelegateIfSafe = TRUE;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Process the input tokens
    //
    /////////////////////////////////////////////////////////////////////

    //
    // First locate the output token.
    //

    for (Index = 0; Index < OutputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(OutputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            OutputToken = &OutputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(OutputToken,OutputToken);
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to map output token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now locate the Input token.
    //

    for (Index = 0; Index < InputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            InputToken = &InputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(InputToken,InputToken);
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to map Input token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check to see if we were passed an additional name
    //

    for (Index = 0; Index < InputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_NEGOTIATION_INFO)
        {
            Status = LsaFunctions->MapBuffer(
                        &InputBuffers->pBuffers[Index],
                        &InputBuffers->pBuffers[Index]
                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog( (DEB_ERROR, "Failed to map incoming SECBUFFER_NEGOTIATION_INFO. %x, %ws, %d", Status, THIS_FILE, __LINE__) );
                goto Cleanup;
            }
            LocalTargetName.Buffer = (LPWSTR) InputBuffers->pBuffers[Index].pvBuffer;

            //
            // We can only stick 64k in a the length field, so make sure the
            // buffer is not too big.
            //

            if (InputBuffers->pBuffers[Index].cbBuffer > 0xffff)
            {
                Status = SEC_E_INVALID_TOKEN;
                goto Cleanup;
            }

            LocalTargetName.Length =
                LocalTargetName.MaximumLength = (USHORT) InputBuffers->pBuffers[Index].cbBuffer;

            break;
        }
    }

    //
    // Process the target names
    //

    Status = KerbProcessTargetNames(
                TargetName,
                &LocalTargetName,
                0,                              // No flags
                &ProcessFlags,
                &TargetInternalName,
                &TargetDomainName,
                &SpnCacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Check to see if we were passed channel bindings
    //

    for( Index = 0; Index < InputBuffers->cBuffers; Index++ )
    {
        if( BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_CHANNEL_BINDINGS )
        {
            Status = LsaFunctions->MapBuffer(
                        &InputBuffers->pBuffers[Index],
                        &InputBuffers->pBuffers[Index]
                        );

            if( !NT_SUCCESS(Status) )
            {
                D_DebugLog( (DEB_ERROR,
                           "Failed to map incoming SECBUFFER_CHANNEL_BINDINGS. %x, %ws, %d\n",
                           Status,
                           THIS_FILE,
                           __LINE__) );

                goto Cleanup;
            }

            pChannelBindings = (PSEC_CHANNEL_BINDINGS) InputBuffers->pBuffers[Index].pvBuffer;

            Status = KerbValidateChannelBindings(pChannelBindings,
                                                 InputBuffers->pBuffers[Index].cbBuffer);

            if (!NT_SUCCESS(Status))
            {
                pChannelBindings = NULL;
                goto Cleanup;
            }

            break;
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // If the caller passed in a context handle, deal with updating an
    // existing context.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // If the input context handle is no NULL then we are actually
    // finalizing an already-existing context. So be it.
    //

    //
    // Use "while" so we can break out.
    //

    while (ContextHandle != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "SpInitLsaModeContext: Second call to Initialize\n"));
        if (InputToken == NULL)
        {
            D_DebugLog((DEB_ERROR, "SpInitLsaModeContext trying to complete a context with no input token! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // First reference the context.
        //

        Status = KerbReferenceContext(
                    ContextHandle,
                    FALSE,       // don't unlink
                    &Context
                    );
        if (Context == NULL)
        {
            D_DebugLog((DEB_ERROR,"Failed to reference context 0x%x. %ws, line %d\n",ContextHandle, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Check the mode of the context to make sure we can finalize it.
        //

        KerbReadLockContexts();

        ContextState = Context->ContextState;
        if ((ContextState != ApRequestSentState) &&
            (ContextState != TgtRequestSentState))
        {
            D_DebugLog((DEB_ERROR, "Invalid context state: %d. %ws, line %d\n",
                Context->ContextState, THIS_FILE, __LINE__));
            Status = STATUS_INVALID_HANDLE;
            KerbUnlockContexts();
            goto Cleanup;
        }
        ContextRetries = Context->Retries;
        ContextFlags = Context->ContextFlags;
        ContextAttribs = Context->ContextAttributes;
        Nonce = Context->Nonce;
        CredentialHandle = Context->CredentialHandle;
        ClientProcess = Context->ClientProcess;
        KerbUnlockContexts();

        //
        // If we are not doing datagram, unpack the AP or TGT reply.
        //

        if ((ContextFlags & ISC_RET_DATAGRAM) == 0)
        {
            ////////////////////////////////////////////////////
            //
            // Handle a TGT reply - get out the TGT & the name of
            // the server
            //
            ////////////////////////////////////////////////////

            if (ContextState == TgtRequestSentState)
            {
                D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext calling KerbUnpackTgtReply\n"));

                KerbWriteLockContexts();
                if (!(Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER))
                {
                    Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
                    DebugLog((DEB_WARN, "SpInitLsaModeContext * use_sesion_key but USER2USER-OUTBOUND not set, added it now\n"));
                }
                KerbUnlockContexts();

                Status = KerbUnpackTgtReply(
                            Context,
                            (PUCHAR) InputToken->pvBuffer,
                            InputToken->cbBuffer,
                            &TargetInternalName,
                            &TargetDomainName,
                            &TgtReply
                            );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR, "SpInitLsaModeContext failed to unpack TGT reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));

                    //
                    // Check for an error message
                    //

                    Status = KerbReceiveErrorMessage(
                                (PUCHAR) InputToken->pvBuffer,
                                InputToken->cbBuffer,
                                Context,
                                &ErrorMessage,
                                &ErrorData
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }

                    KerbReportKerbError(
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        KLIN(FILENO,__LINE__),
                        ErrorMessage,
                        ((NULL != ErrorMessage) ? ErrorMessage->error_code : KRB_ERR_GENERIC),
                        pExtendedError,
                        FALSE
                        );

                    //
                    // Ahh. We have an error message. See if it is an
                    // error we can handle, and if so, Now we need to
                    // try to build a better AP request. Or, if we have
                    // already retried once, fail.
                    //

                    DebugLog((DEB_WARN, "SpInitLsaModeContext received KERB_ERROR message with error 0x%x, can't handle\n",
                            ErrorMessage->error_code ));

                    if ((ErrorMessage->error_code == KRB_ERR_GENERIC)
                        && (ErrorData != NULL)
                        && (ErrorData->bit_mask & data_value_present)
                        && (ErrorData->data_type == KERB_AP_ERR_TYPE_NTSTATUS)
                        && (ErrorData->data_value.length == sizeof(ULONG)))
                    {
                        Status = *((PULONG)ErrorData->data_value.value);
                    }
                    else
                    {
                        Status = KerbMapKerbError((KERBERR) ErrorMessage->error_code);
                        if (NT_SUCCESS(Status))
                        {
                            Status = STATUS_INTERNAL_ERROR;
                        }
                    }

                    goto Cleanup;
                }

                //
                // Break out so we generate a normal request now
                //

                break;
            }
            else // not user-to-user
            {

            ////////////////////////////////////////////////////
            //
            // This is the response to an AP request. It could be
            // an AP reply or an error. Handle both cases
            //
            ////////////////////////////////////////////////////

                //
                // Now unpack the AP reply
                //

                Status = KerbVerifyApReply(
                            Context,
                            (PUCHAR) InputToken->pvBuffer,
                            InputToken->cbBuffer,
                            &ReceiveNonce
                            );

                if (!NT_SUCCESS(Status))
                {
                    //
                    // Check for an error message
                    //

                    Status = KerbReceiveErrorMessage(
                                (PUCHAR) InputToken->pvBuffer,
                                InputToken->cbBuffer,
                                Context,
                                &ErrorMessage,
                                &ErrorData
                                );
                    DebugLog((DEB_TRACE, "SpInitLsaModeContext non datagram called KerbReceiveErrorMessage %#x\n", Status));

                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }

                    KerbReportKerbError(
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        KLIN(FILENO, __LINE__),
                        ErrorMessage,
                        ((NULL != ErrorMessage) ? ErrorMessage->error_code : KRB_ERR_GENERIC),
                        pExtendedError,
                        FALSE
                        );

                    DebugLog((DEB_WARN, "SpInitLsaModeContext failed to verify AP reply: 0x%x\n", ErrorMessage->error_code));

                    //
                    // Ahh. We have an error message. See if it is an
                    // error we can handle, and if so, Now we need to
                    // try to build a better AP request. Or, if we have
                    // already retried once, fail. We can't get a new ticket
                    // with user-to-user.
                    //
                    if ((ContextRetries != 0) ||
                        (((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_SKEW) &&
                         ((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_TKT_NYV) &&
                         ((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_USER_TO_USER_REQUIRED) &&
                         ((KERBERR) ErrorMessage->error_code != KRB_AP_ERR_MODIFIED)) ||
                        (((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_MODIFIED) &&
                         ((ContextAttribs & KERB_CONTEXT_USER_TO_USER) != 0)))
                    {
                        if ((ErrorMessage->error_code == KRB_ERR_GENERIC) &&
                            (ErrorData != NULL) && (ErrorData->data_type == KERB_AP_ERR_TYPE_NTSTATUS) &&
                            ((ErrorData->bit_mask & data_value_present) != 0) &&
                             (ErrorData->data_value.value != NULL) &&
                             (ErrorData->data_value.length == sizeof(ULONG)))
                        {
                            Status = *((PULONG)ErrorMessage->error_data.value);

                            if (NT_SUCCESS(Status)) // must fail here
                            {
                                Status = STATUS_INTERNAL_ERROR;
                            }

                            DebugLog((DEB_ERROR, "InitSecContext Received KERB_ERROR message with Status %#x, %ws, line %d\n",
                                Status, THIS_FILE, __LINE__));
                        }

                        if (ErrorMessage->error_code == KRB_AP_ERR_MODIFIED)
                        {
                            //
                            // If the server couldn't decrypt the ticket,
                            // then the target name is wrong for the server.
                            //
                            DebugLog((DEB_ERROR, "App modified error (NO CONTINUE, bail)\n"));
                            KerbReportApError(ErrorMessage, TargetName);
                            Status = SEC_E_WRONG_PRINCIPAL;
                        }
                        else if (ErrorMessage->error_code == KRB_AP_ERR_TKT_NYV)
                        {
                           DebugLog((DEB_ERROR, "Not yet valid error - Check Time Skew\n"));
                           KerbReportApError(ErrorMessage, NULL);
                           Status = STATUS_TIME_DIFFERENCE_AT_DC;
                        }
                        else
                        {
                            DebugLog((DEB_ERROR, "InitSecContext Received KERB_ERROR message with error 0x%x, can't handle. %ws, line %d\n",
                                ErrorMessage->error_code, THIS_FILE, __LINE__));

                            Status = KerbMapKerbError((KERBERR) ErrorMessage->error_code);
                            if (NT_SUCCESS(Status)) // must fail here
                            {
                                Status = STATUS_INTERNAL_ERROR;
                            }
                        }
                        goto Cleanup;
                    }
                    else
                    {
                       //
                       // Check to see if the server supports skew
                       //

                        if ((ErrorMessage->error_code == KRB_AP_ERR_SKEW) &&
                            (ErrorData == NULL) || ((ErrorData != NULL) && (ErrorData->data_type != KERB_AP_ERR_TYPE_SKEW_RECOVERY)))
                        {
                            //
                            // The server doesn't support skew recovery.
                            //

                            D_DebugLog((DEB_WARN, "SpInitLsaModeContext skew error but server doesn't handle skew recovery.\n"));
                            Status = KerbMapKerbError((KERBERR) ErrorMessage->error_code);
                            goto Cleanup;
                        }

                        //
                        // Here's where we'll punt "not yet valid tickets" and friends...
                        //
                        if (ErrorMessage->error_code == KRB_AP_ERR_TKT_NYV)
                        {
                            KerbPurgeServiceTicketAndTgt(
                                 Context,
                                 CredentialHandle,
                                 CredManCredentials
                                 );

                            DebugLog((DEB_ERROR, "Purged all tickets due to NYV error!\n"));
                        }

                        KerbWriteLockContexts();
                        Context->Retries++;
                        KerbUnlockContexts();
                    }

                    ////////////////////////////////////////////////////
                    //
                    // We got an error we can handle. For user-to-user
                    // required, we received the TGT so we can get
                    // the appropriate ticket. For modified, we want
                    // to toss the old ticket & get a new one, hopefully
                    // with a better key.
                    //
                    ////////////////////////////////////////////////////
                    if ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_USER_TO_USER_REQUIRED)
                    {
                        D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext received KRB_AP_ERR_USER_TO_USER_REQUIRED\n"));

                        if ((ErrorMessage->bit_mask & error_data_present) == 0)
                        {
                            DebugLog((DEB_ERROR, "Server requires user-to-user but didn't send TGT reply. %ws, line %d\n", THIS_FILE, __LINE__));
                            Status = STATUS_NO_TGT_REPLY;
                            goto Cleanup;
                        }

                        //
                        // Check for TGT reply
                        //

                        Status = KerbUnpackTgtReply(
                                    Context,
                                    ErrorMessage->error_data.value,
                                    ErrorMessage->error_data.length,
                                    &TargetInternalName,
                                    &TargetDomainName,
                                    &TgtReply
                                    );
                        if (!NT_SUCCESS(Status))
                        {
                            DebugLog((DEB_ERROR, "SpInitLsaModeContext failed to unpack tgt reply %#x\n", Status));

                            Status = STATUS_INVALID_PARAMETER;
                            goto Cleanup;
                        }

                        //
                        // Fall through into normal ticket handling
                        //

                        ContextFlags |= ISC_RET_USE_SESSION_KEY;

                        //
                        // Remove the old ticket cache entry
                        //

                        KerbWriteLockContexts();
                        TicketCacheEntry = Context->TicketCacheEntry;
                        Context->TicketCacheEntry = NULL;
                        KerbUnlockContexts();

                        if (TicketCacheEntry != NULL)
                        {
                            KerbFreeString(
                                &TargetDomainName
                                );
                            KerbFreeKdcName(
                                &TargetInternalName
                                );

                            //
                            // Get the target name from the old ticket
                            //
                            KerbReadLockTicketCache();
                            Status = KerbDuplicateString(
                                        &TargetDomainName,
                                        &TicketCacheEntry->DomainName
                                        );
                            if (NT_SUCCESS(Status))
                            {
                                Status = KerbDuplicateKdcName(
                                            &TargetInternalName,
                                            TicketCacheEntry->ServiceName
                                            );
                            }

                            KerbUnlockTicketCache();
                            if (!NT_SUCCESS(Status))
                            {
                                goto Cleanup;
                            }

                            //
                            // Free this ticket cache entry
                            //

                            KerbRemoveTicketCacheEntry(TicketCacheEntry);

                            //
                            // Remove the reference holding it to the context
                            //

                            KerbDereferenceTicketCacheEntry(TicketCacheEntry);

                            TicketCacheEntry = NULL;
                        }

                        break;
                    }
                    else if ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_MODIFIED)
                    {
                        DebugLog((DEB_WARN, "App modified error (purge ticket!)\n"));

                        KerbWriteLockContexts();
                        TicketCacheEntry = Context->TicketCacheEntry;
                        Context->TicketCacheEntry = NULL;
                        KerbUnlockContexts();

                        if (TicketCacheEntry != NULL)
                        {
                            //
                            // Get rid of the old ticket in the context

                            KerbFreeString(
                                &TargetDomainName
                                );
                            KerbFreeKdcName(
                                &TargetInternalName
                                );

                            //
                            // Get the target name from the old ticket
                            //
                            KerbReadLockTicketCache();
                            Status = KerbDuplicateString(
                                        &TargetDomainName,
                                        &TicketCacheEntry->DomainName
                                        );
                            if (NT_SUCCESS(Status))
                            {

                                Status = KerbDuplicateKdcName(
                                            &TargetInternalName,
                                            TicketCacheEntry->ServiceName
                                            );
                            }
                            KerbUnlockTicketCache();
                            if (!NT_SUCCESS(Status))
                            {
                                goto Cleanup;
                            }
                            //
                            // Free this ticket cache entry
                            //

                            KerbRemoveTicketCacheEntry(TicketCacheEntry);

                            //
                            // Remove the reference holding it to the context
                            //

                            KerbDereferenceTicketCacheEntry(TicketCacheEntry);

                            TicketCacheEntry = NULL;
                        }
                    }

                    break;
                }
            }

            ////////////////////////////////////////////////////
            //
            // We successfully decrypted the AP reply. At this point
            // we want to finalize the context. For DCE style we send
            // a useless AP reply to the server.
            //
            ////////////////////////////////////////////////////

            //
            // If the caller wanted DCE style authentication, build another
            // AP reply
            //

            KerbWriteLockContexts();

            if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
            {
                DoThirdLeg = TRUE;
            }
            else
            {
                DoThirdLeg = FALSE;
            }

            Context->ReceiveNonce = ReceiveNonce;

            KerbUnlockContexts();

            if (DoThirdLeg)
            {
                //
                // Build an AP reply to send back to the server.
                //

                Status = KerbBuildThirdLegApReply(
                            Context,
                            ReceiveNonce,
                            &Reply,
                            &ReplySize
                            );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR,"Failed to build AP reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                if (OutputToken == NULL)
                {
                    D_DebugLog((DEB_ERROR,"Output token missing. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status  = SEC_E_INVALID_TOKEN;
                    goto Cleanup;
                }

                //
                // Return the AP reply in the output buffer.
                //

                if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
                {
                    if (OutputToken->cbBuffer < ReplySize)
                    {
                        ULONG ErrorData[3];

                        ErrorData[0] = ReplySize;
                        ErrorData[1] = OutputToken->cbBuffer;
                        ErrorData[2] = ClientProcess;

                        DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                            OutputToken->cbBuffer,ReplySize, THIS_FILE, __LINE__ ));
                        OutputToken->cbBuffer = ReplySize;
                        Status = STATUS_BUFFER_TOO_SMALL;

                        KerbReportNtstatus(
                            KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                            Status,
                            NULL,
                            0,
                            ErrorData,
                            3
                            );

                        goto Cleanup;
                    }

                    RtlCopyMemory(
                        OutputToken->pvBuffer,
                        Reply,
                        ReplySize
                        );
                }
                else
                {
                    OutputToken->pvBuffer = Reply;
                    Reply = NULL;
                    *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
                }
                OutputToken->cbBuffer = ReplySize;
            }
            else
            {
                //
                // No return message, so set the return length to zero.
                //

                if (OutputToken != NULL)
                {
                    OutputToken->cbBuffer = 0;
                }
            }
        }
        else
        {
            //////////////////////////////////////////////////////////////////////
            //
            // We are doing datagram, so we don't expect anything from the
            // server but perhaps an error. If we get an error, handle it.
            // Otherwise, build an AP request to send to the server
            //
            /////////////////////////////////////////////////////////////////////

            //
            // We are doing datagram. Build the AP request for the
            // server side.
            //

            //
            // Check for an error message
            //

            if ((InputToken != NULL) && (InputToken->cbBuffer != 0))
            {
                Status = KerbReceiveErrorMessage(
                            (PUCHAR) InputToken->pvBuffer,
                            InputToken->cbBuffer,
                            Context,
                            &ErrorMessage,
                            &ErrorData
                            );
                DebugLog((DEB_TRACE, "SpInitLsaModeContext datagram called KerbReceiveErrorMessage %#x\n", Status));

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                KerbReportKerbError(
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    KLIN(FILENO, __LINE__),
                    ErrorMessage,
                    ((NULL != ErrorMessage) ? ErrorMessage->error_code : KRB_ERR_GENERIC),
                    pExtendedError,
                    FALSE
                    );

                //
                // Check for a real error
                //

                if ((ErrorData != NULL) && (ErrorData->data_type == KERB_AP_ERR_TYPE_NTSTATUS) &&
                    ((ErrorData->bit_mask & data_value_present) != 0) &&
                     (ErrorData->data_value.value != NULL) &&
                    (ErrorData->data_value.length == sizeof(ULONG)))
                {
                    Status = *((PULONG)ErrorMessage->error_data.value);
                    if (NT_SUCCESS(Status))
                    {
                        Status = STATUS_INTERNAL_ERROR;
                    }
                    goto Cleanup;
                }
            }

            //
            // Get the associated credential
            //

            Status = KerbReferenceCredential(
                            CredentialHandle,
                            KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                            FALSE,
                            &Credential);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN,"Failed to locate credential: 0x%x\n",Status));
                goto Cleanup;
            }

            //
            // Get the logon id from the credentials so we can locate the
            // logon session.
            //

            LogonId = Credential->LogonId;

            //
            // Get the logon session
            //

            LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
            if (LogonSession == NULL)
            {
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto Cleanup;
            }

            KerbReadLockLogonSessions(LogonSession);


            if (Credential->SuppliedCredentials != NULL)
            {
                GetAuthTicket = TRUE;
            } else if (((Credential->CredentialFlags & KERB_CRED_NULL_SESSION) != 0) ||
                       ((ContextRequirements & ISC_REQ_NULL_SESSION) != 0))
            {
                UseNullSession = TRUE;
                ContextFlags |= ISC_RET_NULL_SESSION;
            }
            KerbUnlockLogonSessions(LogonSession);

            KerbReadLockContexts();

            TicketCacheEntry = Context->TicketCacheEntry;

            //
            // Get the session key to use from the context
            //

            if (Context->SessionKey.keyvalue.value != 0)
            {
                if (!KERB_SUCCESS(KerbDuplicateKey(
                        &SubSessionKey,
                        &Context->SessionKey
                        )))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            Context->TicketCacheEntry = NULL;

            KerbUnlockContexts();


            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            D_DebugLog((DEB_TRACE_CTXT2,"Building AP request for datagram oriented context\n"));

            //
            // If we are building a null session, build the special null
            // session AP request
            //

            if (UseNullSession)
            {
                Status = KerbBuildNullSessionApRequest(
                            &Request,
                            &RequestSize
                            );
                //
                // Turn off all unsupported flags
                //

                ContextFlags &= (   ISC_RET_ALLOCATED_MEMORY |
                                    ISC_RET_CONNECTION |
                                    ISC_RET_DATAGRAM |
                                    ISC_RET_NULL_SESSION );
            }
            else
            {
                if (TicketCacheEntry == NULL)
                {
                    DebugLog((DEB_ERROR, "SpInitLsaModeContext does have service ticket\n"));

                    Status = STATUS_INTERNAL_ERROR;
                    goto Cleanup;
                }

                Status = KerbBuildApRequest(
                            LogonSession,
                            Credential,
                            CredManCredentials,
                            TicketCacheEntry,
                            ErrorMessage,
                            ContextAttribs,
                            &ContextFlags,
                            &Request,
                            &RequestSize,
                            &Nonce,
                            &AuthenticatorTime,
                            &SubSessionKey,
                            pChannelBindings
                            );
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to build AP request: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // Return the AP request in the output buffer.
            //

            if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
            {
                if (OutputToken->cbBuffer < RequestSize)
                {
                    ULONG ErrorData[3];

                    ErrorData[0] = RequestSize;
                    ErrorData[1] = OutputToken->cbBuffer;
                    ErrorData[2] = ClientProcess;

                    D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                              OutputToken->cbBuffer,RequestSize, THIS_FILE, __LINE__ ));
                    OutputToken->cbBuffer = RequestSize;
                    Status = STATUS_BUFFER_TOO_SMALL;

                    KerbReportNtstatus(
                        KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                        Status,
                        NULL,
                        0,
                        ErrorData,
                        3
                        );

                    goto Cleanup;
                }

                RtlCopyMemory(
                    OutputToken->pvBuffer,
                    Request,
                    RequestSize
                    );
            }
            else
            {
                OutputToken->pvBuffer = Request;
                *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
                Request = NULL;
            }

            OutputToken->cbBuffer = RequestSize;
        }

        //
        //
        // We're done - we finalized.
        //

        Status = STATUS_SUCCESS;

        KerbReadLockContexts();
        Context->ContextFlags = ContextFlags;
        *ContextAttributes |= Context->ContextFlags;

        KerbUtcTimeToLocalTime(
            ExpirationTime,
            &Context->Lifetime
            );
        *NewContextHandle = ContextHandle;
        KerbUnlockContexts();

        goto Cleanup;
    }

    //////////////////////////////////////////////////////////////////////
    //
    // We need to create a request to the server, possibly a TGT request
    // or an AP request depending on what phase of the protocol we're in.
    //
    /////////////////////////////////////////////////////////////////////

    DsysAssert(!((Context != NULL) ^ ((ErrorMessage != NULL) || (TgtReply != NULL))));

    D_DebugLog((DEB_TRACE_CTXT,"SpInitLsaModeContext: First call to Initialize\n"));

    //
    // This is the case where we are constructing a new context.
    //

    //
    // Get the associated credential and its TGT, if needed
    //

    Status = KerbReferenceCredential(
                    CredentialHandle,
                    KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                    FALSE,
                    &Credential
                    );
    if (!NT_SUCCESS(Status))
    {
        InitialStatus = Status;

        Status = KerbReferenceCredential(
                        CredentialHandle,
                        KERB_CRED_OUTBOUND,
                        FALSE,
                        &Credential
                        );
        if( !NT_SUCCESS( Status ) || Credential->SuppliedCredentials != NULL)
        {
            Status = InitialStatus;
            D_DebugLog((DEB_WARN,"Failed to locate credential 0x%x\n",Status));
            goto Cleanup;
        }

        //
        // if we got here, only explicit or credman creds are allowed.
        // If the explicit creds failed to get a TGT from above, its also
        // time to bail, as explicit creds never should fall back to credman.
        //
        // We may also try to use S4U
        //
    }

    //
    // Get the logon id from the credentials so we can locate the
    // logon session.
    //

    LogonId = Credential->LogonId;

    //
    // Get the logon session
    //

    LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);
    LogonSessionFlags = LogonSession->LogonSessionFlags;
    KerbUnlockLogonSessions(LogonSession);

    //
    // Make some decisions based on the state of the credential.  If using
    // supplied credentials, make decisions based on the logon session.
    // or presense of credman credentials.
    //

    if (Credential->SuppliedCredentials != NULL)
    {
        GetAuthTicket = TRUE;
    }
    else if (((Credential->CredentialFlags & KERB_CRED_NULL_SESSION) != 0) ||
                ((ContextRequirements & ISC_REQ_NULL_SESSION) != 0))
    {
        UseNullSession = TRUE;
        ContextFlags |= ISC_RET_NULL_SESSION;
    }
    else if ((LogonSessionFlags & KERB_LOGON_S4U_REQUIRED) != 0)
    {
        //
        // Evaluate the current state of the logon session.  If its an S4U one,
        // but isn't marked for delegate, then this will be a NULL session.
        //

        if ((LogonSessionFlags & KERB_LOGON_DELEGATE_OK) == 0)
        {
            DebugLog((DEB_ERROR, "Calling ISC from a nondelegatable S4U ls (%p)\n", LogonSession));
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }
        else
        {
            DebugLog((DEB_TRACE_S4U, "Trying S4UProxy for ls %p\n", LogonSession));

            //
            // The other 2 forms of S4U possibilities (dummy & delegate OK) will
            // either have a ticket, or require an S4U ticket.  Handle this by
            // prefetching the S4U ticket as evidence for S4U request.
            //
            Status = KerbGetS4UProxyEvidence(
                                LogonSession,
                                TargetInternalName,
                                Credential->ClientProcess,
                                &CallerLogonSession,
                                &EvidenceTicket
                                );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "Failed to get S4UProxy Evidence ticket %x \n", Status));
                Status = SEC_E_NO_CREDENTIALS;  // fall back to anony / NTLM...
                goto Cleanup;
            }
        }
    }
    else
    {
        //
        // go to the credential manager to try and find
        // credentials for this specific target
        //

        ULONG ExtraTargetFlags = 0;


        if ((ContextRequirements & ISC_REQ_USE_SUPPLIED_CREDS) != 0)
        {
            ExtraTargetFlags = CRED_TI_ONLY_PASSWORD_REQUIRED;
        }

        KerbWriteLockLogonSessions(LogonSession);
        Status = KerbCheckCredMgrForGivenTarget(
                    LogonSession,
                    Credential,
                    TargetName, // original targetname, may contain marshalled targetinfo
                    TargetInternalName,
                    ExtraTargetFlags,
                    &TargetDomainName,
                    NULL,
                    &CredManCredentials,
                    &pbMarshalledTargetInfo,
                    &cbMarshalledTargetInfo
                    );

        KerbUnlockLogonSessions(LogonSession);

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "SpInitLsaModeContext failed to get outbound ticket, KerbCheckCredMgrForGivenTarget failed with 0x%x\n", Status));
            goto Cleanup;
        }

        if (CredManCredentials != NULL)
        {
            GetAuthTicket = TRUE;
            ProcessFlags &=  ~KERB_TARGET_UNKNOWN_SPN;
        }
        else
        {
            //
            // if this is a local account logon then we have to have a cred man
            // credential
            //
            if ((Credential->CredentialFlags & KERB_CRED_LOCAL_ACCOUNT) != 0)
            {
                D_DebugLog((DEB_WARN, "Trying to use a local logon session with Kerberos\n"));
                Status = SEC_E_NO_CREDENTIALS;
                goto Cleanup;
            }

            //
            // if no credman cred was found, we didn't use explicit creds,
            // and the initial credential reference for TGT_AVAIL failed, bail now.
            //
            if( !NT_SUCCESS( InitialStatus ) )
            {
                Status = InitialStatus;
                D_DebugLog((DEB_WARN,"Failed to locate credential 0x%x\n",Status));
                goto Cleanup;
            }
        }
    }

#if DBG
    KerbReadLockLogonSessions(LogonSession);
    D_DebugLog((DEB_TRACE_CTXT, "SpInitLsaModeContext: Initailizing context for %wZ\\%wZ\n",
        &LogonSession->PrimaryCredentials.DomainName,
        &LogonSession->PrimaryCredentials.UserName ));
    KerbUnlockLogonSessions(LogonSession);
#endif

    //////////////////////////////////////////////////////////////////////
    //
    // Process all the context requirements. We don't support all of them
    // and some of them are mutually exclusive. In general, we don't fail
    // if we're asked to do something we can't do, unless it seems mandatory,
    // like allocating memory.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // Figure out the context flags
    //

    if ((ContextRequirements & ISC_REQ_MUTUAL_AUTH) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT,"Client wants mutual auth.\n"));
        ContextFlags |= ISC_RET_MUTUAL_AUTH;
    }


    if ((ContextRequirements & ISC_REQ_SEQUENCE_DETECT) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants sequence detect\n"));
        ContextFlags |= ISC_RET_SEQUENCE_DETECT | ISC_RET_INTEGRITY;
    }

    if ((ContextRequirements & ISC_REQ_REPLAY_DETECT) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants replay detect\n"));
        ContextFlags |= ISC_RET_REPLAY_DETECT | ISC_RET_INTEGRITY;
    }

    if ((ContextRequirements & ISC_REQ_INTEGRITY) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants integrity\n"));
        ContextFlags |= ISC_RET_INTEGRITY;
    }

    if ((ContextRequirements & ISC_REQ_CONFIDENTIALITY) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants privacy\n"));
        ContextFlags |= (ISC_RET_CONFIDENTIALITY |
                         ISC_RET_INTEGRITY |
                         ISC_RET_SEQUENCE_DETECT |
                         ISC_RET_REPLAY_DETECT );
    }

    if ((ContextRequirements & ISC_REQ_USE_DCE_STYLE) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants DCE style\n"));
        ContextFlags |= ISC_RET_USED_DCE_STYLE;
    }

    if ((ContextRequirements & ISC_REQ_EXTENDED_ERROR) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants extended error\n"));
        ContextFlags |= ISC_RET_EXTENDED_ERROR;
    }

    if ((ContextRequirements & ISC_REQ_DATAGRAM) != 0)
    {
        if ((ContextRequirements & ISC_REQ_CONNECTION) != 0)
        {
            D_DebugLog((DEB_ERROR,"Client wanted both data gram and connection. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_UNSUPPORTED_FUNCTION;
            goto Cleanup;
        }
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Datagram style\n"));
        ContextFlags |= ISC_RET_DATAGRAM;
    }

    if ((ContextRequirements & ISC_REQ_USE_SESSION_KEY) != 0)
    {
        D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext Client wants sub-session key\n"));

        //
        // Can't do this with datagram because we need to be able to
        // start sealing messages after the first call to Initialize.
        //
        // With a null session there is no real ticket so we don't ever
        // need the server TGT either.
        //
        // Can't do DCE style because they don't have this.
        //

        if (!UseNullSession && (ContextRequirements & (ISC_REQ_DATAGRAM | ISC_REQ_USE_DCE_STYLE)) == 0)
        {
            //
            // If we are in the first call, get a server TGT
            //

            if (ContextState == InvalidState)
            {
                GetServerTgt = TRUE;
            }
            ContextFlags |= ISC_RET_USE_SESSION_KEY;
        }
        else
        {
            DebugLog((DEB_WARN, "SpInitLsaModeContext Client wanted both datagram and session key, dropping session key\n"));
        }
    }

    if ((ContextRequirements & ISC_REQ_DELEGATE) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Delegation\n"));
        if ((ContextFlags & ISC_RET_MUTUAL_AUTH) == 0)
        {
            D_DebugLog((DEB_WARN,"Can't do delegate without mutual\n"));
        }
        else
        {
            ContextFlags |= ISC_RET_DELEGATE;
        }
    }
    else if ((ContextRequirements & ISC_REQ_DELEGATE_IF_SAFE) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Delegation, if safe\n"));
        if ((ContextFlags & ISC_RET_MUTUAL_AUTH) == 0)
        {
            D_DebugLog((DEB_WARN,"Can't do delegate without mutual\n"));
        }
        else
        {
            ContextFlags |= ISC_RET_DELEGATE_IF_SAFE;
        }
    }

    if ((ContextRequirements & ISC_REQ_CONNECTION) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Connection style\n"));
        ContextFlags |= ISC_RET_CONNECTION;
    }

    if ((ContextRequirements & ISC_REQ_IDENTIFY) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT, "Client wants Identify level\n"));
        ContextFlags |= ISC_RET_IDENTIFY;
        if (((ContextRequirements & ISC_REQ_DELEGATE) != 0) ||
             ((ContextRequirements & ISC_REQ_DELEGATE_IF_SAFE) != 0))
        {
            D_DebugLog((DEB_WARN, "Client wants Delegation and Indentify, turning off delegation\n"));
            ContextFlags &= ~ISC_RET_DELEGATE;
            ContextFlags &= ~ISC_RET_DELEGATE_IF_SAFE;
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Get the ticket necessary to process the request. At this point:
    //  - TicketCacheEntry should contain the ticket to re-use
    //  - ErrorMessage should contain the error message, if there was one
    //
    /////////////////////////////////////////////////////////////////////

    //
    // Get the outbound ticket. If the credential has attached supplied
    // credentials, get an AS ticket instead.
    //

    if (GetServerTgt)
    {
        //
        // Nothing to do
        //

    }
    else if (!UseNullSession)
    {
        D_DebugLog((DEB_TRACE_CTXT,"SpInitLsaModeContext: Getting outbound ticket for %wZ (%wZ) or ",
            TargetName, &LocalTargetName));
        D_KerbPrintKdcName((DEB_TRACE_CTXT, TargetInternalName));

        //
        // If we got a skew error and we already have a cached ticket, don't
        // bother getting a new ticket.
        //

        KerbReadLockContexts();

        if (ErrorMessage != NULL)
        {
            if (((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_SKEW) &&
                (Context->TicketCacheEntry != NULL))
            {
                 TicketCacheEntry = Context->TicketCacheEntry;
                 KerbReferenceTicketCacheEntry(Context->TicketCacheEntry);
            }
        }
        KerbUnlockContexts();

        //
        // If we don't have a ticket in the context, go ahead and get
        // a new ticket
        //

        if ( EvidenceTicket != NULL )
        {
            Status = KerbGetServiceTicketByS4UProxy(
                            LogonSession,
                            CallerLogonSession,
                            Credential,
                            EvidenceTicket,
                            TargetInternalName,
                            &TargetDomainName,
                            SpnCacheEntry,
                            ProcessFlags,
                            TicketOptions,
                            0,                          // no enc type
                            ErrorMessage,
                            NULL,                       // no authorization data
                            TgtReply,
                            &TicketCacheEntry,
                            NULL                        // don't return logon guid
                            );
            if (Status == STATUS_USER2USER_REQUIRED)
            {
                D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext failed to get serviceticket ByS4UProxy: STATUS_USER2USER_REQUIRED\n"));

                Status = STATUS_SUCCESS;

                ContextFlags |= ISC_RET_USE_SESSION_KEY;
                GetServerTgt = TRUE;
            }
            else if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "SpInitLsaModeContext failed to get outbound ticket, KerbGetServiceTicketByS4UProxy failed 0x%x\n",Status));
                goto Cleanup;
            }
        }
        else if (TicketCacheEntry == NULL)
        {
            D_DebugLog((DEB_TRACE, "SpInitLsaModeContext getting service ticket\n"));
            Status = KerbGetServiceTicket(
                        LogonSession,
                        Credential,
                        CredManCredentials,
                        TargetInternalName,
                        &TargetDomainName,
                        SpnCacheEntry,
                        ProcessFlags,
                        TicketOptions,
                        0,                          // no enc type
                        ErrorMessage,
                        NULL,                       // no authorization data
                        TgtReply,
                        &TicketCacheEntry,
                        NULL                        // don't return logon guid
                        );
            if (Status == STATUS_USER2USER_REQUIRED)
            {
                D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext failed to get serviceticket: STATUS_USER2USER_REQUIRED\n"));

                Status = STATUS_SUCCESS;

                ContextFlags |= ISC_RET_USE_SESSION_KEY;
                GetServerTgt = TRUE;
            }
            else if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "SpInitLsaModeContext failed to get outbound ticket, KerbGetServiceTicket failed  with 0x%x\n",Status));
                goto Cleanup;
            }
        }

        //
        // fail user2user in data gram: not enough round trips to complete the protocol
        //

        if ((ContextFlags & ISC_RET_USE_SESSION_KEY) && (ContextFlags & ISC_RET_DATAGRAM))
        {
            DebugLog((DEB_ERROR, "SpInitLsaModeContext Client needed session key in datagram, dropping session key\n"));

            ContextFlags |= ~ISC_RET_USE_SESSION_KEY;

            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }
    else
    {
        //
        // Turn off all unsupported flags
        //

        ContextFlags &= (   ISC_RET_ALLOCATED_MEMORY |
                            ISC_RET_CONNECTION |
                            ISC_RET_DATAGRAM |
                            ISC_RET_NULL_SESSION );

    }

    //////////////////////////////////////////////////////////////////////
    //
    // Build the request - an AP request for standard Kerberos, or a TGT
    // request.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // For datagram requests, there is no output.
    //

    if ((ContextFlags & ISC_RET_DATAGRAM) == 0)
    {
        //
        // This is the case