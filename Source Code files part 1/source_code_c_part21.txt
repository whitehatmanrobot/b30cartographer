Taskpad: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsTaskpad(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionTaskpad(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pTaskpads = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionTaskpad: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_TASKPAD, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pTaskpads = New CSelectionHolder(SEL_EEXTENSIONS_TASKPAD, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pTaskpads)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pTaskpads);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionToolbar: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsToolbar(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoExtensionToolbar(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pToolbar = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionToolbar: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_TOOLBAR, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pToolbar = New CSelectionHolder(SEL_EEXTENSIONS_TOOLBAR, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pToolbar)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pToolbar);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



HRESULT CSnapInDesigner::DoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "DoExtensionNameSpace: pExtendedSnapIn is NULL");

    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    // If we haven't yet set this value to True then do it now

    if (VARIANT_FALSE == bValue)
    {
        hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->put_ExtendsNameSpace(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CSnapInDesigner::OnDoExtensionNameSpace(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pNameSpace = NULL;

    ASSERT(SEL_EEXTENSIONS_NAME == pExtendedSnapIn->m_st, "OnDoExtensionNameSpace: pExtendedSnapIn is NULL");

    hr = GetResourceString(IDS_EXT_PROP_NAMESPACE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pNameSpace = New CSelectionHolder(SEL_EEXTENSIONS_NAMESPACE, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pNameSpace)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pNameSpace);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindExtension(SelectionType stExtensionType, CSelectionHolder **ppExtension)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//

HRESULT CSnapInDesigner::FindExtension
(
    CSelectionHolder  *pRoot,
    SelectionType      stExtensionType,
    CSelectionHolder **ppExtension
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pChild = NULL;

    hr = m_pTreeView->GetFirstChildNode(pRoot, &pChild);
    IfFailGo(hr);

    while (S_OK == hr)
    {
        if (stExtensionType == pChild->m_st)
        {
            *ppExtension = pChild;
            hr = S_OK;
            goto Error;
        }

        hr = m_pTreeView->GetNextChildNode(pChild, &pChild);
        IfFailGo(hr);
    }

    hr = S_FALSE;

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Extending this Snap-In
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


HRESULT CSnapInDesigner::DoMyExtendsNewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsNewMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsNewMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsNewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsNewMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_NEW_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_NEW_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsTaskMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsTaskMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsTaskMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsTaskMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsTaskMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_TASK_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_TASK_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsTopMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsTopMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsTopMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsTopMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsTopMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_TOP_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_TOP_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsViewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsViewMenu: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsViewMenu(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsViewMenu(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsViewMenu: wrong argument");

    hr = GetResourceString(IDS_MYEXT_VIEW_MENU, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_VIEW_MENU, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsPPages(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsPPages: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsPropertyPages(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsPPages(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsPPages: wrong argument");

    hr = GetResourceString(IDS_MYEXT_PPAGES, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_PPAGES, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsToolbar(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsToolbar: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsToolbar(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsToolbar(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsToolbar: wrong argument");

    hr = GetResourceString(IDS_MYEXT_TOOLBAR, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_TOOLBAR, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DoMyExtendsNameSpace(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    VARIANT_BOOL         bValue = VARIANT_FALSE;

    ASSERT(SEL_EXTENSIONS_MYNAME == pMyExtensions->m_st, "DoMyExtendsNameSpace: wrong argument");

    hr = pMyExtensions->m_piObject.m_piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = pMyExtensions->m_piObject.m_piExtensionDefs->put_ExtendsNameSpace(VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CSnapInDesigner::OnDoMyExtendsNameSpace(CSelectionHolder *pMyExtensions)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pSelection = NULL;

    ASSERT(SEL_EXTENSIONS_ROOT == pMyExtensions->m_st, "OnDoMyExtendsNameSpace: wrong argument");

    hr = GetResourceString(IDS_MYEXT_NAMESPACE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    pSelection = New CSelectionHolder(SEL_EXTENSIONS_NAMESPACE, pMyExtensions->m_piObject.m_piExtendedSnapIn);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->AddNode(szBuffer, m_pRootMyExtensions, kClosedFolderIcon, pSelection);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\help.h ===
//---------------------------------------------------------------------------
// help.h
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
//
// Contains help info needed by the .ODL file and the DECLARE_CONTROLOBJECT
// structure.  Define everything here once so we keep both items in sync. 
//

#ifndef _HELP_H
#define _HELP_H

#define HELP_FILENAME "VBSnapInsGuide.chm"
#define HELP_DLLFILENAME "MSSNAPD.OCX"
#define HELP_PPFILENAME HELP_FILENAME // Property page filename

#define merge(a,b) a ## b
#define WIDESTRINGCONSTANT(x) merge(L,x)
#define HELP_FILENAME_WIDE WIDESTRINGCONSTANT(HELP_FILENAME)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\mssnapr_i_wrap.c ===
#include "mssnapr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\menuedit.h ===
//=--------------------------------------------------------------------------------------
// MenuEdit.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// CMenuEditor declaration
//=-------------------------------------------------------------------------------------=

#ifndef _MENUEDITOR_H_
#define _MENUEDITOR_H_




class CMenuEditor : public CError, public CtlNewDelete
{
public:
    CMenuEditor(IMMCMenu *piMMCMenu);
    ~CMenuEditor();

    HRESULT DoModal(HWND hwndParent);

    static BOOL CALLBACK MenuEditorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    IMMCMenu    *m_piMMCMenu;
};


#endif  // _MENUEDITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\localobj.h ===
//=--------------------------------------------------------------------------=
// localobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// This file is used by automation servers to delcare things that their objects
// need other parts of the server to see.
//
#ifndef _LOCALOBJECTS_H_

//=--------------------------------------------------------------------------=
// these constants are used in conjunction with the g_ObjectInfo table that
// each inproc server defines.  they are used to identify a given  object
// within the server.
//
// **** ADD ALL NEW OBJECTS TO THIS LIST ****
//

#define _LOCALOBJECTS_H_

#define OBJECT_TYPE_SNAPINDESIGNER          0   // SnapIn Designer

#define OBJECT_TYPE_PPGSNAPINGENERAL        1   // SnapIn <General> PP
#define OBJECT_TYPE_PPGSNAPINIL             2   // SnapIn <Image Lists> PP
#define OBJECT_TYPE_PPGSNAPINAVAILNO        3   // SnapIn <Available Nodes> PP

#define OBJECT_TYPE_PPGNODEGENERAL	        4   // ScopeItem <General> PP
#define OBJECT_TYPE_PPGNODECOLHDRS	        5   // ScopeItem <Column Headers> PP

#define OBJECT_TYPE_PPGLSTVIEWGENERAL	    6   // ListView <General> PP
#define OBJECT_TYPE_PPGLSTVIEWIMGLSTS	    7   // ListView <Image Lists> PP
#define OBJECT_TYPE_PPGLSTVIEWSORTING	    8   // ListView <Sorting> PP
#define OBJECT_TYPE_PPGLSTVIEWCOLHDRS	    9   // ListView <Column Headers> PP

#define OBJECT_TYPE_PPGURLVIEWGENERAL	   10   // URLView <General> PP

#define OBJECT_TYPE_PPGOCXVIEWGENERAL      11   // OCXView <General> PP

#define OBJECT_TYPE_PPGIMGLISTSIMAGES      12   // ImageList <Images> PP

#define OBJECT_TYPE_PPGTOOLBRGENERAL       13   // Toolbar <General> PP
#define OBJECT_TYPE_PPGTOOLBRBUTTONS       14   // Toolbar <Buttons> PP

#define OBJECT_TYPE_PPGTASKGENERAL         15   // TaskpadView <General> PP
#define OBJECT_TYPE_PPGTASKBACKGR          16   // TaskpadView <Background> PP
#define OBJECT_TYPE_PPGTASKTASKS           17   // TaskpadView <Tasks> PP

#endif // _LOCALOBJECTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\imglist.cpp ===
//=--------------------------------------------------------------------------------------
// imglist.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- ImageList-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddImageList()
{
    HRESULT                hr = S_OK;
    IMMCImageLists        *piMMCImageLists = NULL;
    VARIANT                vtEmpty;
    IMMCImageList         *piMMCImageList = NULL;

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    if (piMMCImageLists != NULL)
    {
        ::VariantInit(&vtEmpty);
        vtEmpty.vt = VT_ERROR;
        vtEmpty.scode = DISP_E_PARAMNOTFOUND;

        hr = piMMCImageLists->Add(vtEmpty, vtEmpty, &piMMCImageList);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddMMCImageList(CSelectionHolder *pParent, IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnAddMMCImageList(CSelectionHolder *pParent, IMMCImageList *piMMCImageList)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pImageList = NULL;

    ASSERT(NULL != pParent, "OnAddMMCImageList: pParent is NULL");
    ASSERT(SEL_TOOLS_IMAGE_LISTS == pParent->m_st, "OnAddMMCImageList: type is not SEL_TOOLS_IMAGE_LISTS");
    ASSERT(NULL != piMMCImageList, "OnAddMMCImageList: piMMCImageList is NULL");

    hr = MakeNewImageList(pParent->m_piObject.m_piMMCImageLists, piMMCImageList, &pImageList);
    IfFailGo(hr);

    hr = pImageList->RegisterHolder();
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->AddImageList(piMMCImageList);
    IfFailGo(hr);

    hr = InsertImageListInTree(pImageList, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pImageList);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pImageList);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pImageList);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameImageList(CSelectionHolder *pImageList, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameImageList(CSelectionHolder *pImageList, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrOldName = NULL;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_TOOLS_IMAGE_LISTS_NAME == pImageList->m_st, "RenameImageList: wrong argument");

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = m_pTreeView->GetLabel(pImageList, &bstrOldName);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->RenameImageList(pImageList->m_piObject.m_piMMCImageList, bstrOldName);
    IfFailGo(hr);

    hr = pImageList->m_piObject.m_piMMCImageList->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pImageList, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteImageList(CSelectionHolder *pImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteImageList(CSelectionHolder *pImageList)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    BSTR                 bstrName = NULL;
    IMMCImageLists      *piMMCImageLists = NULL;
    VARIANT              vtKey;

    ::VariantInit(&vtKey);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pImageList, &pParent);
    IfFailGo(hr);

    // Remove the ImageList from the appropriate collection
    ASSERT(SEL_TOOLS_IMAGE_LISTS == pParent->m_st, "DeleteImageList: expected another kind of parent");

    hr = pImageList->m_piObject.m_piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    if (piMMCImageLists != NULL)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piMMCImageLists->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtKey);
    FREESTRING(bstrName);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteImageList(CSelectionHolder *pImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteImageList(CSelectionHolder *pImageList)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IMMCImageLists      *piMMCImageLists = NULL;
    long                 lCount = 0;

    // Delete the TypeInfo related property
    hr = m_pSnapInTypeInfo->DeleteImageList(pImageList->m_piObject.m_piMMCImageList);
    IfFailGo(hr);

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pImageList, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pImageList);
    IfFailGo(hr);

    delete pImageList;

    // Select the next selection
    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    if (NULL != piMMCImageLists)
    {
        hr = piMMCImageLists->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowImageListProperties(IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowImageListProperties
(
    IMMCImageList *piMMCImageList
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[2];

    hr = GetResourceString(IDS_IL_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piMMCImageList->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_MMCImageListImagesPP;
    pageClsID[1] = CLSID_StockColorPage;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList, CSelectionHolder **ppImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewImageList
(
    IMMCImageLists    *piMMCImageLists,
    IMMCImageList     *piMMCImageList,
    CSelectionHolder **ppImageList
)
{
    HRESULT                hr = S_OK;

    *ppImageList = New CSelectionHolder(piMMCImageList);
    if (*ppImageList == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewImageList(piMMCImageLists, piMMCImageList);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewImageList(IMMCImageLists *piMMCImageLists, IMMCImageList *piMMCImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewImageList
(
    IMMCImageLists *piMMCImageLists,
    IMMCImageList  *piMMCImageList
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pMMCImageListClone = NULL;

    hr = GetResourceString(IDS_IMGLIST, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pMMCImageListClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piMMCImageList->put_Name(bstrName);
    IfFailGo(hr);

    hr = piMMCImageList->put_Key(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertImageListInTree(CSelectionHolder *pImageList, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertImageListInTree
(
    CSelectionHolder *pImageList,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pImageList->m_piObject.m_piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kImageListIcon, pImageList);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\listvw.cpp ===
//=--------------------------------------------------------------------------------------
// listvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- ListView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddListView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddListView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    IListViewDefs         *piListViewDefs = NULL;
    VARIANT                vtEmpty;
    IListViewDef          *piListViewDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        if (piListViewDefs != NULL)
        {
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piListViewDefs->Add(vtEmpty, vtEmpty, &piListViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piListViewDef);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingListView(IViewDefs *piViewDefs, IListViewDef *piListViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingListView(IViewDefs *piViewDefs, IListViewDef *piListViewDef)
{
    HRESULT           hr = S_OK;
    IListViewDefs    *piListViewDefs = NULL;

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->AddFromMaster(piListViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piListViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddListViewDef(CSelectionHolder *pParent, IListViewDef *piListViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddListViewDef(CSelectionHolder *pParent, IListViewDef *piListViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pListView = NULL;
    IViewDefs           *piViewDefs = NULL;
    IListViewDefs       *piListViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddListViewDef: pParent is NULL");
    ASSERT(NULL != pParent->m_piObject.m_piListViewDefs, "OnAddListViewDef: pParent->m_piObject.m_piListViewDefs is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS:
        piListViewDefs = pParent->m_piObject.m_piListViewDefs;
        piListViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddListViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewListView(piListViewDefs, piListViewDef, &pListView);
    IfFailGo(hr);

    hr = InsertListViewInTree(pListView, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pListView);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pListView);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pListView);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piListViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameListView(CSelectionHolder *pListView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameListView(CSelectionHolder *pListView, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_VIEWS_LIST_VIEWS_NAME == pListView->m_st, "RenameListView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pListView->m_piObject.m_piListViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pListView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pListView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteListView(CSelectionHolder *pListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteListView
(
    CSelectionHolder *pListView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    VARIANT           vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pListView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pListView->m_piObject.m_piListViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pListView->m_piObject.m_piListViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pListView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piListViewDefs->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteListView(CSelectionHolder *pListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  This view will be contained either in the main collection (SnapIn/Views/ListViews/<name>) or
//  or in one of the satellite collections. The former is pointed to by the argument <pListView>,
//  the latter should be <m_pCurrentSelection>,
//  
HRESULT CSnapInDesigner::OnDeleteListView
(
    CSelectionHolder *pListView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    IListViewDefs     *piListViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pListView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pListView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pListView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pListView);
    IfFailGo(hr);

    delete pListView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        hr = piListViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowListViewProperties(IListViewDef *piListViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowListViewProperties
(
    IListViewDef *piListViewDef
)
{
    HRESULT         hr = S_OK;
    int             iResult = 0;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[4];

    hr = GetResourceString(IDS_LISTVIEW_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piListViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_ListViewDefGeneralPP;
    pageClsID[1] = CLSID_ListViewDefImgLstsPP;
    pageClsID[2] = CLSID_ListViewDefSortingPP;
    pageClsID[3] = CLSID_ListViewDefColHdrsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 4;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewListView(IListViewDefs *piListViewDefs, IListViewDef *piListViewDef, CSelectionHolder **ppListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewListView
(
    IListViewDefs     *piListViewDefs,
    IListViewDef      *piListViewDef,
    CSelectionHolder **ppListView
)
{
    HRESULT                hr = S_OK;

    *ppListView = New CSelectionHolder(piListViewDef);
    if (*ppListView == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewListView(piListViewDefs, *ppListView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewListView(IListViewDefs *piListViewDefs, CSelectionHolder *pListView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewListView
(
    IListViewDefs     *piListViewDefs,
    CSelectionHolder  *pListView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pListViewDefClone = NULL;

    ASSERT(NULL != piListViewDefs, "InitializeNewListView: piListViewDefs is NULL");
    ASSERT(NULL != pListView, "InitializeNewListView: pListView is NULL");

    hr = piListViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewListView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_LIST_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++iItemNumber);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pListViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pListView->m_piObject.m_piListViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pListView->m_piObject.m_piListViewDef->put_Key(bstrName);
        IfFailGo(hr);
    }

    hr = pListView->RegisterHolder();
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertListViewInTree(CSelectionHolder *pListView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertListViewInTree
(
    CSelectionHolder *pListView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pListView->m_piObject.m_piListViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kListViewIcon, pListView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pch.h ===
//=--------------------------------------------------------------------------------------
// pch.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Precompiled header files for mssnapd
//=-------------------------------------------------------------------------------------=

#include <ipserver.h>
#include <localsrv.h>
#include <comcat.h>
#include <commctrl.h>
#include <windowsx.h>
#include <macros.h>
#include <util.h>
#include <tchar.h>
#include <stdio.h>
#include <prsht.h>
#include <MSStkPPg.h>
#include <commdlg.h>

#include "..\..\mssnapr\mssnapr\dispid.h"
#include "mssnapr.h"

#include "resource.h"
#include "help.h"
#include "mssnapd_helpids.h"
#include "localobj.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ocxvw.cpp ===
//=--------------------------------------------------------------------------------------
// ocxvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- OCXView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "snaputil.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddOCXView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddOCXView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    IOCXViewDefs          *piOCXViewDefs = NULL;
    VARIANT                vtEmpty;
    IOCXViewDef           *piOCXViewDef = NULL;

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        if (piOCXViewDefs != NULL)
        {
            ::VariantInit(&vtEmpty);
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piOCXViewDefs->Add(vtEmpty, vtEmpty, &piOCXViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piOCXViewDef);
    RELEASE(piOCXViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingOCXView(IViewDefs *piViewDefs, IOCXViewDef *piOCXViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingOCXView(IViewDefs *piViewDefs, IOCXViewDef *piOCXViewDef)
{
    HRESULT           hr = S_OK;
    IOCXViewDefs     *piOCXViewDefs = NULL;

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    hr = piOCXViewDefs->AddFromMaster(piOCXViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piOCXViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddOCXViewDef(CSelectionHolder *pParent, IOCXViewDef *piOCXViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddOCXViewDef(CSelectionHolder *pParent, IOCXViewDef *piOCXViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pOCXViewDef = NULL;
    IViewDefs           *piViewDefs = NULL;
    IOCXViewDefs        *piOCXViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddOCXViewDef: pParent is NULL");
    ASSERT(NULL != piOCXViewDef, "OnAddOCXViewDef: piOCXViewDef is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX:
        piOCXViewDefs = pParent->m_piObject.m_piOCXViewDefs;
        piOCXViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddOCXViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewOCXView(piOCXViewDefs, piOCXViewDef, &pOCXViewDef);
    IfFailGo(hr);

    hr = InsertOCXViewInTree(pOCXViewDef, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pOCXViewDef);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pOCXViewDef);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pOCXViewDef);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piOCXViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameOCXView(CSelectionHolder *pOCXView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameOCXView(CSelectionHolder *pOCXView, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_VIEWS_OCX_NAME == pOCXView->m_st, "RenameOCXView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pOCXView->m_piObject.m_piOCXViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pOCXView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pOCXView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteOCXView(CSelectionHolder *pOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteOCXView
(
    CSelectionHolder *pOCXView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    VARIANT           vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pOCXView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pOCXView->m_piObject.m_piOCXViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pOCXView->m_piObject.m_piOCXViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pOCXView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        if (piOCXViewDefs != NULL)
        {
            vtKey.vt = VT_BSTR;
            vtKey.bstrVal = ::SysAllocString(bstrName);
            if (NULL == vtKey.bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK(hr);
            }

            hr = piOCXViewDefs->Remove(vtKey);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piOCXViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    FREESTRING(bstrName);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteOCXView(CSelectionHolder *pOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteOCXView
(
    CSelectionHolder *pOCXView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    IOCXViewDefs      *piOCXViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pOCXView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pOCXView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pOCXView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pOCXView);
    IfFailGo(hr);

    delete pOCXView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        hr = piOCXViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piOCXViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowOCXViewProperties(IOCXViewDef *piOCXViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowOCXViewProperties
(
    IOCXViewDef *piOCXViewDef
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[1];

    hr = GetResourceString(IDS_OCX_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piOCXViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_OCXViewDefGeneralPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 1;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewOCXView(IOCXViewDefs *piOCXViewDefs, IOCXViewDef *piOCXViewDef, CSelectionHolder **ppOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewOCXView
(
    IOCXViewDefs      *piOCXViewDefs,
    IOCXViewDef       *piOCXViewDef,
    CSelectionHolder **ppOCXView
)
{
    HRESULT                hr = S_OK;

    *ppOCXView = New CSelectionHolder(piOCXViewDef);
    if (*ppOCXView == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewOCXView(piOCXViewDefs, *ppOCXView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewOCXView(IOCXViewDefs *piOCXViewDefs, CSelectionHolder *pOCXView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewOCXView
(
    IOCXViewDefs     *piOCXViewDefs,
    CSelectionHolder *pOCXView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pOCXViewDefClone = NULL;

    hr = piOCXViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewOCXView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_OCX_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pOCXViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pOCXView->m_piObject.m_piOCXViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pOCXView->m_piObject.m_piOCXViewDef->put_Key(bstrName);
        IfFailGo(hr);
    }

    hr = pOCXView->RegisterHolder();
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertOCXViewInTree(CSelectionHolder *pOCXView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertOCXViewInTree
(
    CSelectionHolder *pOCXView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pOCXView->m_piObject.m_piOCXViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kOCXViewIcon, pOCXView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ppage.cpp ===
//=--------------------------------------------------------------------------------------
// ppage.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Designer Property Page implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "ppage.h"

// for ASSERT and FAIL
//
SZTHISFILE


OLECHAR g_wstrEmptyy[] = L"";


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::CSIPropertyPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSIPropertyPage::CSIPropertyPage
(
    IUnknown *pUnkOuter,
    int       iObjectType
)
: CPropertyPage(pUnkOuter, iObjectType), m_bInitialized(false), m_bSilentUpdate(false)
{
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::~CSIPropertyPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSIPropertyPage::~CSIPropertyPage()
{
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::DialogProc()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
BOOL CSIPropertyPage::DialogProc
(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    HRESULT     hr = S_OK;
    BOOL        bResult = FALSE;
    HRESULT    *pHr = NULL;
    LPNMHDR     pnmh = NULL;

    switch (uMsg)
    {
    case PPM_NEWOBJECTS:
        // The control has been given some new objects.
        // The control is expected to go and populate its page's controls with information from this object.
        // Using the FirstControl() and NextControl() methods from the CPropertyPage class, the control can
        // get the relevant information.
        hr = OnNewObjects();
        bResult = TRUE;
        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }

        break;

    case PPM_APPLY:
        // The control has to apply any changes that have occurred now.
        // Again, you can use the FirstControl() and NextControl() routines to loop through all the objects
        // for which the property pages were visible and apply the values (note that it's possible for there
        // to be more than one object for which a property page is being displayed).
        // The framework send an PPM_APPLY every time a page is deactivated. We only care for this event
        // if the page is dirty.
        if (IsPageDirty() == S_OK)
        {
            hr = OnApply();
        }
        else
            hr = S_OK;

        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }
        bResult = TRUE;
        break;

    case PPM_EDITPROPERTY:
        // When the control is sent this message, the control is expected to set the focus to the control
        // instance which represents the property of the given dispid.  You will typically only see this
        // message called if you implement IPerPropertyBrowsing and return a value in MapPropertyToPage.
        hr = OnEditProperty(static_cast<int>(wParam));
        bResult = TRUE;
        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }

        break;

    case PPM_FREEOBJECTS:
        // Various people will find it interesting to stash, in some way, the pointers they receive in
        // PPM_NEWOBJECTS.  This message tells them that it is time to free them, as the objects are no 
        // longer valid.  This can be called from the property page's destructor, so people should be careful
        // not to make too many assumptions about the property page.
        hr = OnFreeObjects();
        bResult = TRUE;
        if (lParam != NULL)
        {
            pHr = reinterpret_cast<HRESULT *>(lParam);
            *pHr = hr;
        }

        break;

    case WM_MEASUREITEM:
        hr = OnMeasureItem(reinterpret_cast<LPMEASUREITEMSTRUCT>(lParam));
        IfFailGo(hr);
        bResult = TRUE;
        break;

    case WM_ERASEBKGND:
        if (NULL != m_hwndTT)
        {
            ::SetWindowPos(m_hwndTT,
                           HWND_TOPMOST,
                           0, 0, 0, 0,
                           SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }
        bResult = FALSE;
        break;

    case WM_DRAWITEM:
        hr = OnDrawItem(reinterpret_cast<LPDRAWITEMSTRUCT>(lParam));
        IfFailGo(hr);
        bResult = TRUE;
        break;

    case WM_INITDIALOG:
        hr = InternalOnInitializeDialog(hwnd);
        IfFailGo(hr);
        bResult = TRUE;
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case EN_CHANGE:
            hr = InternalOnTextChanged(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case EN_KILLFOCUS:
            hr = InternalOnKillFocus(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case CBN_SELCHANGE:
        // also handles LBN_SELCHANGE which has the same value as CBN_SELCHANGE
            hr = OnCtlSelChange(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case CBN_DROPDOWN:
            hr = OnCBDropDown(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case LBN_SETFOCUS:
            hr = OnCtlSetFocus(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;

        case BN_CLICKED:
            hr = OnButtonClicked(LOWORD(wParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;
        }
        break;

    case WM_NOTIFY:
        pnmh = reinterpret_cast<LPNMHDR>(lParam);
        switch (pnmh->code)
        {
        case UDN_DELTAPOS:
            hr = OnDeltaPos(reinterpret_cast<NMUPDOWN *>(lParam));
            IfFailGo(hr);
            bResult = TRUE;
            break;
        }
        break;

    case WM_DESTROY:
        hr = InternalOnDestroy();
        IfFailGo(hr);
        bResult = TRUE;
        break;

    default:
        hr = OnDefault(uMsg, wParam, lParam);
        IfFailGo(hr);
        bResult = (hr == S_OK) ? TRUE : FALSE;
        break;
    }

Error:
    return bResult;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnInitializeDialog(HWND hwndDlg)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnInitializeDialog
(
    HWND hwndDlg
)
{
    HRESULT                 hr = S_OK;

    ASSERT(hwndDlg != NULL, "InternalOnInitializeDialog: hwndDlg is NULL");

    // Create the tooltip control
    m_hwndTT = ::CreateWindowEx(0,
                                TOOLTIPS_CLASS,
                                reinterpret_cast<LPSTR>(NULL),
                                TTS_ALWAYSTIP,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                hwndDlg,
                                reinterpret_cast<HMENU>(NULL),
                                GetResourceHandle(),
                                NULL);
    if (m_hwndTT == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndTT, TTM_ACTIVATE, static_cast<WPARAM>(TRUE), 0);

    hr = OnInitializeDialog();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnTextChanged
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    if (m_bInitialized == true)
    {
        hr = OnTextChanged(dlgItemID);
        IfFailGo(hr);
        if (hr == S_OK && true == m_bInitialized && false == m_bSilentUpdate)
            MakeDirty();
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnKillFocus
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    if (m_bInitialized == true)
    {
        hr = OnKillFocus(dlgItemID);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InternalOnDestroy()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InternalOnDestroy()
{
    HRESULT hr = S_OK;

    hr = OnDestroy();
    IfFailGo(hr);

    if (m_hwndTT == NULL)
    {
        ::DestroyWindow(m_hwndTT);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::HandleError(TCHAR *pszTitle, TCHAR *pszMessage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::HandleError(TCHAR *pszTitle, TCHAR *pszMessage)
{
    HRESULT     hr = S_OK;

    ::MessageBox(m_hwnd, pszMessage, pszTitle, MB_OK | MB_ICONHAND);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::HandleCantCommit(int iCtrlID, int iStringRsrcID, int *pDisposition)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::HandleCantCommit(TCHAR *pszTitle, TCHAR *pszMessage, int *pDisposition)
{
    HRESULT     hr = S_OK;
    int         iDlgResult = 0;

    *pDisposition = 0;
    iDlgResult = ::MessageBox(m_hwnd, pszMessage, pszTitle, MB_YESNO | MB_ICONHAND);
    if (IDYES == iDlgResult)
        *pDisposition = kSIDiscardChanges;
    else
        *pDisposition = kSICancelOperation;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::RegisterTooltip(int iCtrlID, int iStringRsrcID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::RegisterTooltip
(
    int iCtrlID,
    int iStringRsrcID
)
{
    HRESULT     hr = S_OK;
    HWND        hwndCtrl = NULL;
    TOOLINFO    ti;
    RECT        rc;
    BOOL        bReturn = FALSE;

    hwndCtrl = ::GetDlgItem(m_hwnd, iCtrlID);
    if (hwndCtrl == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    bReturn = ::GetWindowRect(hwndCtrl, &rc);
    if (bReturn == FALSE)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memset(&ti, 0, sizeof(TOOLINFO));

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND  | TTF_SUBCLASS;
    ti.hwnd = m_hwnd;
    ti.uId = reinterpret_cast<unsigned int>(hwndCtrl);
    ti.rect = rc;
    ti.hinst = GetResourceHandle();
    ti.lpszText = reinterpret_cast<LPTSTR>(iStringRsrcID);
    ti.lParam = reinterpret_cast<LPARAM>(this);

    bReturn = ::SendMessage(m_hwndTT, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(reinterpret_cast<LPTOOLINFO>(&ti)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeEditCtl(BSTR bstr, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeEditCtl
(
    BSTR bstr,
    int  iCtrlID,
    int  iStrRscrID
)
{
    HRESULT hr = S_OK;
    char   *pstr = NULL;
    BOOL    bResult = FALSE;

    if (bstr != NULL && ::SysStringLen(bstr) > 0)
    {
        hr = ANSIFromBSTR(bstr, &pstr);
        IfFailGo(hr);

        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pstr);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, _T(""));
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    if (pstr != NULL)
        CtlFree(pstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeEditCtl(long lValue, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeEditCtl
(
    long lValue,
    int  iCtrlID,
    int  iStrRscrID
)
{
    HRESULT hr = S_OK;
    char    pszBuffer[kSIMaxBuffer];
    BOOL    bResult = FALSE;

    ::sprintf(pszBuffer, "%d", lValue);

    bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
    if (bResult == FALSE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeEditCtl(VARIANT vt, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeEditCtl
(
    VARIANT vt,
    int     iCtrlID,
    int     iStrRscrID
)
{
    HRESULT hr = S_OK;
    char    pszBuffer[kSIMaxBuffer];
    BOOL    bResult = FALSE;
    char   *pszAnsi = NULL;

    switch (vt.vt)
    {
    case VT_I2:
        ::sprintf(pszBuffer, "%d", vt.iVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_I4:
        ::sprintf(pszBuffer, "%d", vt.lVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_BSTR:
        hr = ANSIFromBSTR(vt.bstrVal, &pszAnsi);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszAnsi);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::InitializeCheckboxCtl(VARIANT_BOOL bValue, int iCtrlID, int iStrRscrID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::InitializeCheckboxCtl
(
    VARIANT_BOOL bValue,
    int          iCtrlID,
    int          iStrRscrID
)
{
    HRESULT hr = S_OK;
    BOOL    bResult = FALSE;

    if (bValue == VARIANT_TRUE)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID), BM_SETCHECK, static_cast<WPARAM>(TRUE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID), BM_SETCHECK, static_cast<WPARAM>(FALSE), 0);
    }

    if (iStrRscrID != 0)
    {
        hr = RegisterTooltip(iCtrlID, iStrRscrID);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetDlgText(int iDlgItem, BSTR *pBstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetDlgText
(
    int      iDlgItem,
    BSTR    *pBstr
)
{
    HRESULT hr = S_OK;
    char    szBuffer[kSIMaxBuffer + 1];
    UINT    uChars = 0;

    szBuffer[0] = 0;
    uChars = ::GetDlgItemText(m_hwnd, iDlgItem, szBuffer, kSIMaxBuffer);
    if (uChars == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);

        *pBstr = ::SysAllocString(g_wstrEmptyy);
        if (*pBstr == NULL)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        goto Error;
    }

    hr = BSTRFromANSI(szBuffer, pBstr);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetDlgInt(int iDlgItem, int *piInt)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Attempts to exract an integer from a control's text. If the text cannot
// be converted to an int then returns E_INVALIDARG.
//
HRESULT CSIPropertyPage::GetDlgInt
(
    int      iDlgItem,
    int     *piInt
)
{
    HRESULT hr = S_OK;
    char    szBuffer[kSIMaxBuffer + 1];
    UINT    uChars = 0;

    uChars = ::GetDlgItemText(m_hwnd, iDlgItem, szBuffer, kSIMaxBuffer);
    if (uChars == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *piInt = 0;
    if (0 == ::sscanf(szBuffer, "%d", piInt))
    {
        hr = E_INVALIDARG;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetDlgVariant(int iDlgItem, VARIANT *pvt)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetDlgVariant
(
    int      iDlgItem,
    VARIANT *pvt
)
{
    HRESULT hr = S_OK;
    char    szBuffer[kSIMaxBuffer + 1];
    UINT    uChars = 0;
    bool    isNumeric = true;
    int     iMax = 0;
    int     iIndex = 0;

    ::VariantInit(pvt);

    szBuffer[0] = 0;
    uChars = ::GetDlgItemText(m_hwnd, iDlgItem, szBuffer, kSIMaxBuffer);
    if (uChars == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);

        goto Error;
    }

    iMax = ::strlen(szBuffer);
    for (iIndex = 0; iIndex < iMax; ++iIndex)
    {
        if (0 == ::isdigit(szBuffer[iIndex]))
        {
            isNumeric = false;
            break;
        }
    }

    if (true == isNumeric)
    {
        pvt->vt = VT_I4;
        pvt->lVal = ::atol(szBuffer);
    }
    else
    {
        pvt->vt = VT_BSTR;
        hr = BSTRFromANSI(szBuffer, &pvt->bstrVal);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetCheckbox(int iCtrlID, VARIANT_BOOL *pbValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetCheckbox
(
    int           iDlgItem,
    VARIANT_BOOL *pbValue
)
{
    HRESULT hr = S_OK;
    int     iValue = 0;

    iValue = ::SendMessage(::GetDlgItem(m_hwnd, iDlgItem), BM_GETCHECK, 0, 0);
    if (iValue == BST_CHECKED)
    {
        *pbValue = VARIANT_TRUE;
    }
    else
    {
        *pbValue = VARIANT_FALSE;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetCBSelection(int iDlgItem, BSTR *bstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetCBSelection
(
    int   iDlgItem,
    BSTR *pBstr
)
{
    HRESULT     hr = S_OK;
    HWND        hcb = NULL;
    int         iIndex = 0;
    char        szBuffer[kSIMaxBuffer + 1];
    int         cch = 0;

    hcb = ::GetDlgItem(m_hwnd, iDlgItem);
    if (hcb == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iIndex = ::SendMessage(hcb, CB_GETCURSEL, 0, 0);
    if (iIndex == CB_ERR)
    {
        // No selection available
        hr = S_FALSE;
        goto Error;
    }

    cch = ::SendMessage(hcb, CB_GETLBTEXT, static_cast<WPARAM>(iIndex), reinterpret_cast<LPARAM>(reinterpret_cast<LPCSTR>(szBuffer)));
    if (cch == CB_ERR)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = BSTRFromANSI(szBuffer, pBstr);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::GetCBSelectedItemData(int iDlgItem, void **pvData)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::GetCBSelectedItemData
(
    int   iDlgItem,
    long *plData
)
{
    HRESULT     hr = S_OK;
    HWND        hcb = NULL;
    int         iIndex = 0;

    *plData = -1;

    hcb = ::GetDlgItem(m_hwnd, iDlgItem);
    if (hcb == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iIndex = ::SendMessage(hcb, CB_GETCURSEL, 0, 0);
    if (iIndex == CB_ERR)
    {
        // Nothing is selected
        hr = S_FALSE;
        goto Error;
    }

    *plData = ::SendMessage(hcb, CB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0);
    if (*plData == CB_ERR)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetDlgText(int iDlgItem, BSTR bstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetDlgText
(
    int  iDlgItem,
    BSTR bstr
)
{
    HRESULT hr = S_OK;
    char   *pstr = NULL;
    BOOL    bResult = FALSE;

    if ( (bstr != NULL) && (::SysStringLen(bstr) > 0) )
    {
        hr = ANSIFromBSTR(bstr, &pstr);
        IfFailGo(hr);

        bResult = ::SetDlgItemText(m_hwnd, iDlgItem, pstr);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        bResult = ::SetDlgItemText(m_hwnd, iDlgItem, _T(""));
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (pstr != NULL)
        CtlFree(pstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetDlgText(int iDlgItem, long lValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetDlgText
(
    int  iDlgItem, 
    long lValue
)
{
    HRESULT hr = S_OK;
    char    strBuffer[kSIMaxBuffer + 1];
    BOOL    bResult = FALSE;

    ::sprintf(strBuffer, _T("%d"), lValue);

    bResult = ::SetDlgItemText(m_hwnd, iDlgItem, strBuffer);
    if (bResult == FALSE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetDlgText(VARIANT vt, int iCtrlID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetDlgText
(
    VARIANT vt,
    int     iCtrlID
)
{
    HRESULT hr = S_OK;
    char    pszBuffer[kSIMaxBuffer];
    BOOL    bResult = FALSE;
    char   *pszAnsi = NULL;

    switch (vt.vt)
    {
    case VT_I2:
        ::sprintf(pszBuffer, "%d", vt.iVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_I4:
        ::sprintf(pszBuffer, "%d", vt.lVal);
        bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszBuffer);
        if (bResult == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case VT_BSTR:
        if (::SysStringLen(vt.bstrVal) > 0)
        {
            hr = ANSIFromBSTR(vt.bstrVal, &pszAnsi);
            bResult = ::SetDlgItemText(m_hwnd, iCtrlID, pszAnsi);
            if (bResult == FALSE)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else
        {
            ::SetDlgItemText(m_hwnd, iCtrlID, _T(""));
        }
        break;
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetCheckbox(int iDlgItem, VARIANT_BOOL bValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetCheckbox
(
    int          iDlgItem, 
    VARIANT_BOOL bValue
)
{
    HRESULT hr = S_OK;

    if (bValue == VARIANT_TRUE)
        ::SendMessage(::GetDlgItem(m_hwnd, iDlgItem), BM_SETCHECK, static_cast<WPARAM>(TRUE), 0);
    else
        ::SendMessage(::GetDlgItem(m_hwnd, iDlgItem), BM_SETCHECK, static_cast<WPARAM>(FALSE), 0);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SetCBItemSelection(int iCtrlID, long lValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SetCBItemSelection
(
    int  iCtrlID, 
    long lValue
)
{
    HRESULT     hr = S_OK;
    HWND        hCombo = NULL;
    int         iCount = 0;
    int         iIndex = 0;
    long        lTestValue = 0;

    hCombo = ::GetDlgItem(m_hwnd, iCtrlID);
    if (hCombo == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iCount = ::SendMessage(hCombo, CB_GETCOUNT, 0, 0);
    if (iCount == CB_ERR)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = S_FALSE;
    for (iIndex = 0; iIndex < iCount; ++iIndex)
    {
        lTestValue = ::SendMessage(hCombo, CB_GETITEMDATA, static_cast<WPARAM>(iIndex), 0);
        if (lTestValue == CB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (lTestValue == lValue)
        {
            ::SendMessage(hCombo, CB_SETCURSEL, static_cast<WPARAM>(iIndex), 0);

            hr = S_OK;
            break;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::AddCBBstr(int iCtrlID, BSTR bstr, long lValue)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::AddCBBstr
(
    int  iCtrlID, 
    BSTR bstr, 
    long lValue
)
{
    HRESULT     hr = S_OK;
    HWND        hCombo = NULL;
    int         iIndex = 0;
    int         iResult = 0;
    char       *psz = NULL;

    hCombo = ::GetDlgItem(m_hwnd, iCtrlID);
    if (hCombo == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ANSIFromBSTR(bstr, &psz);
    IfFailGo(hr);

    iIndex = ::SendMessage(hCombo,
                           CB_ADDSTRING,
                           0,
                           reinterpret_cast<LPARAM>(psz));
    if (iIndex == CB_ERR || iIndex == CB_ERRSPACE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (lValue != -1)
    {
        iResult = ::SendMessage(hCombo,
                                CB_SETITEMDATA,
                                iIndex,
                                static_cast<LPARAM>(lValue));
        if (iResult == CB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        iResult = ::SendMessage(hCombo,
                                CB_SETITEMDATA,
                                iResult,
                                static_cast<LPARAM>(iIndex));
        if (iResult == CB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (psz != NULL)
        CtlFree(psz);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::SelectCBBstr(int iCtrlID, BSTR bstr)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::SelectCBBstr
(
    int  iCtrlID,
    BSTR bstr
)
{
    HRESULT     hr = S_OK;
    char       *psz = NULL;
    int         iIndex = 0;

    if (NULL != bstr && ::SysStringLen(bstr) > 0)
    {
        hr = ANSIFromBSTR(bstr, &psz);
        IfFailGo(hr);

        iIndex = ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID),
                               CB_FINDSTRINGEXACT,
                               static_cast<WPARAM>(-1),
                               reinterpret_cast<LPARAM>(psz));
        if (iIndex != CB_ERR)
        {
            ::SendMessage(::GetDlgItem(m_hwnd, iCtrlID), CB_SETCURSEL, static_cast<WPARAM>(iIndex), 0);
        }
    }

Error:
    if (psz != NULL)
        CtlFree(psz);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnNewObjects()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnApply()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnEditProperty(int iDispID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnEditProperty
(
    int iDispID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnFreeObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnFreeObjects()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnInitializeDialog()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDeltaPos
(
    NMUPDOWN *pNMUpDown
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnTextChanged
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnKillFocus
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnCtlSelChange
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnCtlSetFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnCtlSetFocus
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnButtonClicked
(
    int dlgItemID
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnMeasureItem
(
    MEASUREITEMSTRUCT *pMeasureItemStruct
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDrawItem
(
    DRAWITEMSTRUCT *pDrawItemStruct
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return S_FALSE;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnDestroy
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnDestroy()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSIPropertyPage::OnCBDropDown
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSIPropertyPage::OnCBDropDown(int dlgItemID)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\ppage.h ===
//=--------------------------------------------------------------------------------------
// ppage.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Designer Property Page class. All of our property pages subclass this class,
// which is based on the framework's CPropertyPage.
//=-------------------------------------------------------------------------------------=

#ifndef _SIPROPERTYPAGE_H_
#define _SIPROPERTYPAGE_H_

// Size of internal buffer we use for string handling: resource loading and
// string conversion.
const int           kSIMaxBuffer = 512;

// We implement a minimum error handler that returns the following values
// after being invoked:
const int           kSICancelOperation = 1;
const int           kSIDiscardChanges  = 2;

class CSIPropertyPage : public CPropertyPage, public CError
{
public:
    CSIPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CSIPropertyPage();

// Overridable member functions
protected:
    // Delegation from CPropertyPage
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnEditProperty(int iDispID);
    virtual HRESULT OnFreeObjects();

    // Delegation from our WinProc
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnTextChanged(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnCtlSetFocus(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct);
    virtual HRESULT OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct);
    virtual HRESULT OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT OnDestroy();
    virtual HRESULT OnCBDropDown(int dlgItemID);

protected:
    // Error handling. May be invoked by subclasses.
    HRESULT HandleCantCommit(TCHAR *pszTitle, TCHAR *pszMessage, int *pDisposition);
    HRESULT HandleError(TCHAR *pszTitle, TCHAR *pszMessage);

    // Allows a derived class to determine if the page is dirty
    BOOL IsDirty() {return S_OK == IsPageDirty();}

// Services provided to subclasses
protected:
    HRESULT RegisterTooltip(int iCtrlID, int iStringRsrcID);

    HRESULT InitializeEditCtl(BSTR bstr, int iCtrlID, int iStrRscrID = 0);
    HRESULT InitializeEditCtl(long lValue, int iCtrlID, int iStrRscrID);
    HRESULT InitializeEditCtl(VARIANT vt, int iCtrlID, int iStrRscrID);
    HRESULT InitializeCheckboxCtl(VARIANT_BOOL bValue, int iCtrlID, int iStrRscrID);

    HRESULT GetDlgText(int iDlgItem, BSTR *pBstr);
    HRESULT GetDlgInt(int iDlgItem, int *piInt);
    HRESULT GetDlgVariant(int iDlgItem, VARIANT *pvt);
    HRESULT GetCheckbox(int iDlgItem, VARIANT_BOOL *pbValue);
    HRESULT GetCBSelection(int iDlgItem, BSTR *pBstr);
    HRESULT GetCBSelectedItemData(int iDlgItem, long *plData);

    HRESULT SetDlgText(int iDlgItem, BSTR bstr);
    HRESULT SetDlgText(int iDlgItem, long lValue);
    HRESULT SetDlgText(VARIANT vt, int iCtrlID);
    HRESULT SetCheckbox(int iDlgItem, VARIANT_BOOL bValue);
    HRESULT SetCBItemSelection(int iCtrlID, long lValue);
    HRESULT AddCBBstr(int iCtrlID, BSTR bstr, long lValue = -1);
    HRESULT SelectCBBstr(int iCtrlID, BSTR bstr);

private:
    // Implementation details
    HRESULT InternalOnInitializeDialog(HWND hwndDlg);
    HRESULT InternalOnTextChanged(int dlgItemID);
    HRESULT InternalOnKillFocus(int dlgItemID);
    HRESULT InternalOnDestroy();

    virtual BOOL DialogProc(HWND, UINT, WPARAM, LPARAM);

protected:
    HWND    m_hwndTT;
    bool    m_bInitialized;
    bool    m_bSilentUpdate;
};


#endif  // _SIPROPERTYPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psextend.h ===
//=--------------------------------------------------------------------------------------
// psextend.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSEXTEND_H_
#define _PSEXTEND_H_

#include "ppage.h"
#include "chklst.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Holder for available MMC Node Types
//
////////////////////////////////////////////////////////////////////////////////////
class CMMCNodeType : public CCheckedListItem
{
public:
    CMMCNodeType(const char *pszName, const char *pszGuid);
    virtual ~CMMCNodeType();

public:
    char    *m_pszName;
    char    *m_pszGuid;
};


////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Available Nodes"
//
////////////////////////////////////////////////////////////////////////////////////


class CSnapInAvailNodesPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CSnapInAvailNodesPage(IUnknown *pUnkOuter);
    virtual ~CSnapInAvailNodesPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnCtlSetFocus(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct);
    virtual HRESULT OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct);
    virtual HRESULT OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT OnDestroy();

// Helpers to get attributes from component
protected:

// Helpers for Apply event
protected:

// Other helpers
protected:
    HRESULT PopulateAvailNodesDialog();
    HRESULT AddSnapInToList(HKEY hkeyNodeTypes, const TCHAR *pszKeyName);

    HRESULT OnNewAvailNode();
    HRESULT OnProperties(CMMCNodeType *pMMCNodeType);
    static BOOL CALLBACK NodeTypeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT FindSnapIn(BSTR bstrNodeTypeGUID, IExtendedSnapIn **ppiExtendedSnapIn);
    HRESULT AddSnapIn(CMMCNodeType *pCMMCNodeType);
    HRESULT RemoveSnapIn(CMMCNodeType *pCMMCNodeType);

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    ISnapInDef          *m_piSnapInDef;
    CCheckList          *m_pCheckList;
    CMMCNodeType        *m_pMMCNodeType;
    bool                 m_bEnabled;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	SnapInAvailNodes,                   // Name
	&CLSID_SnapInDefExtensionsPP,       // Class ID
	"Snap-In Available Nodes Page",     // Registry display name
	CSnapInAvailNodesPage::Create,      // Create function
	IDD_DIALOG_AVAILABLE_NODES,         // Dialog resource ID
	IDS_SNAPINPPG_AVAIL,                // Tab caption
	IDS_SNAPINPPG_AVAIL,                // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Extensions,             // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSEXTEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psextend.cpp ===
//=--------------------------------------------------------------------------------------
// psextend.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psextend.h"

// for ASSERT and FAIL
//
SZTHISFILE

const int   kMaxBuffer                  = 1024;

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Holder for available MMC Node Types
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

//=--------------------------------------------------------------------------------------
// CMMCNodeType::CMMCNodeType(const char *pszName, const char *pszGuid)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CMMCNodeType::CMMCNodeType
(
    const char *pszName,
    const char *pszGuid
)
: CCheckedListItem(false), m_pszName(0), m_pszGuid(0)
{
    m_pszName = reinterpret_cast<char *>(CtlAlloc(::strlen(pszName) + 1));
    if (NULL != m_pszName)
    {
        ::strcpy(m_pszName, pszName);
    }

    m_pszGuid = reinterpret_cast<char *>(CtlAlloc(::strlen(pszGuid) + 1));
    if (NULL != m_pszGuid)
    {
        ::strcpy(m_pszGuid, pszGuid);
    }
}


//=--------------------------------------------------------------------------------------
// CMMCNodeType::~CMMCNodeType()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CMMCNodeType::~CMMCNodeType()
{
    if (NULL != m_pszName)
        CtlFree(m_pszName);

    if (NULL != m_pszGuid)
        CtlFree(m_pszGuid);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Available Nodes"
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CSnapInAvailNodesPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CSnapInAvailNodesPage::Create(IUnknown *pUnkOuter)
{
        CSnapInAvailNodesPage *pNew = New CSnapInAvailNodesPage(pUnkOuter);
        return pNew->PrivateUnknown();
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::CSnapInAvailNodesPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CSnapInAvailNodesPage::CSnapInAvailNodesPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGSNAPINAVAILNO),
  m_piSnapInDesignerDef(0), m_piSnapInDef(0), m_pCheckList(0), m_pMMCNodeType(0), m_bEnabled(false)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::~CSnapInAvailNodesPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CSnapInAvailNodesPage::~CSnapInAvailNodesPage()
{
    RELEASE(m_piSnapInDef);
    RELEASE(m_piSnapInDesignerDef);

    if (NULL != m_pCheckList)
    {
        m_pCheckList->Detach();
        delete m_pCheckList;
    }
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnInitializeDialog()
{
    HRESULT  hr = S_OK;

    m_pCheckList = New CCheckList(IDC_LIST_AVAILABLE_NODES);
    if (NULL == m_pCheckList)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pCheckList->Attach(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnNewObjects()
{
    HRESULT             hr = S_OK;
    IUnknown           *pUnk = NULL;
    DWORD               dwDummy = 0;
    IObjectModel       *piObjectModel = NULL;
    ISnapInDef         *piSnapInDef = NULL;
    SnapInTypeConstants sitc = siStandAlone;
    TCHAR               szBuffer[kMaxBuffer + 1];

    if (NULL != m_piSnapInDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ISnapInDef, reinterpret_cast<void **>(&m_piSnapInDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Type(&sitc);
    IfFailGo(hr);

    if (siStandAlone != sitc)
    {
        hr = PopulateAvailNodesDialog();
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), FALSE);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES), LB_SETCURSEL, 0, 0);

        m_bEnabled = true;
    }
    else
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_ADD), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), FALSE);

        hr = GetResourceString(IDS_TT_EXTEND_INSTRUCTIONS, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        ::SetWindowText(::GetDlgItem(m_hwnd, IDC_STATIC_EXTEND_INSTRUCTIONS), szBuffer);
    }

Error:
    RELEASE(piSnapInDef);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnApply()
{
    HRESULT          hr = S_OK;
    int              iCount = 0;
    int              iIndex = 0;
    CMMCNodeType    *pNodeType = NULL;
    VARIANT_BOOL     bCheck = VARIANT_FALSE;
    BSTR             bstrNodeTypeGUID = NULL;
    IExtendedSnapIn *piExtendedSnapIn = NULL;

    ASSERT(NULL != m_piSnapInDef, "OnApply: m_piSnapInDef is NULL");

    m_pCheckList->GetNumberOfItems(&iCount);
    IfFailGo(hr);

    for (iIndex = 0; iIndex < iCount; ++iIndex)
    {
        hr = m_pCheckList->GetItemData(iIndex, reinterpret_cast<void **>(&pNodeType));
        IfFailGo(hr);

        if (NULL == pNodeType)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hr = m_pCheckList->GetItemCheck(iIndex, &bCheck);
        IfFailGo(hr);

        hr = BSTRFromANSI(pNodeType->m_pszGuid, &bstrNodeTypeGUID);
        IfFailGo(hr);

        if (VARIANT_TRUE == bCheck)
        {
            hr = FindSnapIn(bstrNodeTypeGUID, &piExtendedSnapIn);
            IfFailGo(hr);

            if (S_FALSE == hr)
            {
                hr = AddSnapIn(pNodeType);
                IfFailGo(hr);
            }
        }
        else
        {
            hr = FindSnapIn(bstrNodeTypeGUID, &piExtendedSnapIn);
            IfFailGo(hr);

            if (S_OK == hr)
            {
                hr = RemoveSnapIn(pNodeType);
                IfFailGo(hr);
            }
        }

        FREESTRING(bstrNodeTypeGUID);
        RELEASE(piExtendedSnapIn);
    }

Error:
    FREESTRING(bstrNodeTypeGUID);
    RELEASE(piExtendedSnapIn);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnCtlSelChange
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;
    long    lIndex = 0;

    DebugPrintf("OnCtlSelChange() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        lIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES), LB_GETCURSEL, 0, 0);
        if (LB_ERR == lIndex)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (LB_ERR != lIndex)
        {
            hr = m_pCheckList->GetItemData(lIndex, reinterpret_cast<void **>(&m_pMMCNodeType));
            IfFailGo(hr);

            if (NULL == m_pMMCNodeType)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), TRUE);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnCtlSetFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnCtlSetFocus
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;
    long    lIndex = 0;

    DebugPrintf("OnCtlSetFocus() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        lIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES), LB_GETCURSEL, 0, 0);
        if (lIndex == LB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (LB_ERR != lIndex)
        {
            hr = m_pCheckList->GetItemData(lIndex, reinterpret_cast<void **>(&m_pMMCNodeType));
            IfFailGo(hr);

            if (NULL == m_pMMCNodeType)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_PROPERTIES), TRUE);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_ADD:
        hr = OnNewAvailNode();
        IfFailGo(hr);
        break;

    case IDC_BUTTON_PROPERTIES:
        if (NULL != m_pMMCNodeType)
        {
            hr = OnProperties(m_pMMCNodeType);
            IfFailGo(hr);
        }
        break;
    }

    ::SetFocus(::GetDlgItem(m_hwnd, IDC_LIST_AVAILABLE_NODES));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnMeasureItem
(
    MEASUREITEMSTRUCT *pMeasureItemStruct
)
{
    HRESULT     hr = S_OK;
    HDC         hdc = NULL;
    BOOL        bResult = FALSE;
    TEXTMETRIC  tm;

    DebugPrintf("OnMeasureItem() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        hdc = ::GetDC(m_hwnd);
        if (NULL == hdc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        bResult = ::GetTextMetrics(hdc, &tm);
        if (FALSE == bResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        pMeasureItemStruct->itemWidth = 0;
        pMeasureItemStruct->itemHeight = tm.tmHeight;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnDrawItem
(
    DRAWITEMSTRUCT *pDrawItemStruct
)
{
    HRESULT            hr = S_OK;
    CCheckedListItem  *pCheckedListItem = NULL;

    ASSERT(NULL != m_pCheckList, "OnDrawItem: m_pCheckList is NULL");

    DebugPrintf("OnDrawItem() m_bEnabled=%d\r\n", m_bEnabled);

    if (true == m_bEnabled)
    {
        hr = m_pCheckList->GetItemData(pDrawItemStruct->itemID, reinterpret_cast<void **>(&pCheckedListItem));
        IfFailGo(hr);

        hr = m_pCheckList->DrawItem(pDrawItemStruct, pCheckedListItem->m_bSelected);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnDestroy()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnDestroy()
{
    HRESULT            hr = S_OK;
    long               lCount = 0;
    long               lIndex = 0;
    CCheckedListItem  *pCheckedListItem = NULL;

    if (NULL != m_pCheckList)
    {
        lCount = ::SendMessage(m_pCheckList->Window(), LB_GETCOUNT, 0, 0);
        if (LB_ERR != lCount)
        {
            for (lIndex = 0; lIndex < lCount; ++lIndex)
            {
                hr = m_pCheckList->GetItemData(lIndex, reinterpret_cast<void **>(&pCheckedListItem));
                if (NULL != pCheckedListItem)
                    delete pCheckedListItem;
            }
        }

        m_pCheckList->Detach();
        delete m_pCheckList;
        m_pCheckList = NULL;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::AddSnapInToList(HKEY hkeyNodeTypes, const TCHAR *pszKeyName)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::AddSnapInToList
(
    HKEY         hkeyNodeTypes,
    const TCHAR *pszKeyName
)
{
    HRESULT            hr = S_OK;
    long               lResult = 0;
    HKEY               hkeyRegisteredSnapIn = NULL;
    unsigned long      lBufSize = kSIMaxBuffer;
    TCHAR              pszName[kSIMaxBuffer + 1];
    CMMCNodeType      *pMMCNodeType = NULL;
    int                iIndex = 0;
    BSTR               bstrNodeTypeGUID = NULL;
    IExtendedSnapIn   *piExtendedSnapIn = NULL;

    lResult = RegOpenKeyEx(hkeyNodeTypes, pszKeyName, 0, KEY_READ, &hkeyRegisteredSnapIn);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    lResult = RegQueryValue(hkeyRegisteredSnapIn, NULL, pszName, reinterpret_cast<long *>(&lBufSize));
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    pMMCNodeType = New CMMCNodeType(pszName, pszKeyName);
    if (NULL == pMMCNodeType)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    if (0 == _tcslen(pszName))
    {
        hr = m_pCheckList->AddString(pszKeyName, &iIndex);
        IfFailGo(hr);
    }
    else
    {
        hr = m_pCheckList->AddString(pszName, &iIndex);
        IfFailGo(hr);
    }

    hr = m_pCheckList->SetItemData(iIndex, pMMCNodeType);
    IfFailGo(hr);

    hr = BSTRFromANSI(pszKeyName, &bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = FindSnapIn(bstrNodeTypeGUID, &piExtendedSnapIn);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_pCheckList->SetItemCheck(iIndex, VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RELEASE(piExtendedSnapIn);
    FREESTRING(bstrNodeTypeGUID);
    if (NULL != hkeyRegisteredSnapIn)
        RegCloseKey(hkeyRegisteredSnapIn);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::PopulateAvailNodesDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::PopulateAvailNodesDialog()
{
    HRESULT            hr = S_OK;
    long               lResult = 0;
    HKEY               hkeyNodeTypes = 0;
    DWORD              dwIndex = 0;
    TCHAR              pszKeyName[kSIMaxBuffer + 1];
    TCHAR              pszClass[kSIMaxBuffer + 1];
    unsigned long      lBufSize = kSIMaxBuffer;
    FILETIME           fileTime;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes"), 0, KEY_READ, &hkeyNodeTypes);
    if (ERROR_SUCCESS != lResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    while (1)
    {
        lResult = RegEnumKeyEx(hkeyNodeTypes,
                               dwIndex,
                               pszKeyName,
                               &lBufSize,
                               0,
                               pszClass,
                               &lBufSize,
                               &fileTime);
        if (ERROR_NO_MORE_ITEMS == lResult)
            break;
        if (ERROR_SUCCESS != lResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        hr = AddSnapInToList(hkeyNodeTypes, pszKeyName);
        IfFailGo(hr);

        pszKeyName[0] = '\0';
        pszClass[0] = '\0';
        lBufSize = kSIMaxBuffer;
        ++dwIndex;
    }

Error:
    if (NULL != hkeyNodeTypes)
        RegCloseKey(hkeyNodeTypes);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnNewAvailNode()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnNewAvailNode()
{
    HRESULT       hr = S_OK;
    CMMCNodeType *pMMCNodeType = NULL;
    int           iResult = 0;
    int           iIndex = 0;

    pMMCNodeType = New CMMCNodeType("", "");
    if (NULL == pMMCNodeType)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    iResult = ::DialogBoxParam(GetResourceHandle(),
                               MAKEINTRESOURCE(IDD_DIALOG_ADD_TO_AVAILABLE),
                               m_hwnd,
                               NodeTypeDialogProc,
                               reinterpret_cast<LPARAM>(pMMCNodeType));
    if (-1 == iResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (1 == iResult)
    {
        if (0 != ::strlen(pMMCNodeType->m_pszName))
        {
            hr = m_pCheckList->AddString(pMMCNodeType->m_pszName, &iIndex);
            IfFailGo(hr);
        }
        else
        {
            hr = m_pCheckList->AddString(pMMCNodeType->m_pszGuid, &iIndex);
            IfFailGo(hr);
        }

        hr = m_pCheckList->SetItemData(iIndex, pMMCNodeType);
        IfFailGo(hr);

        // Select this node-type.
        hr = m_pCheckList->SetItemCheck(iIndex, VARIANT_TRUE);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnProperties(CMMCNodeType *pMMCNodeType)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnProperties
(
    CMMCNodeType *pMMCNodeType
)
{
    HRESULT          hr = S_OK;
    int              iResult = 0;

    iResult = ::DialogBoxParam(GetResourceHandle(),
                               MAKEINTRESOURCE(IDD_DIALOG_ADD_TO_AVAILABLE),
                               m_hwnd,
                               NodeTypeDialogProc,
                               reinterpret_cast<LPARAM>(pMMCNodeType));
    if (-1 == iResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::NodeTypeDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
INT_PTR CALLBACK CSnapInAvailNodesPage::NodeTypeDialogProc
(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    CMMCNodeType *pMMCNodeType = NULL;
    TCHAR         pszBuffer[kSIMaxBuffer + 1];
    HRESULT       hr = S_OK;
    WCHAR        *pwszGUID = NULL;
    int           nRet = 0;

    if (WM_INITDIALOG == uMsg)
    {
        pMMCNodeType = reinterpret_cast<CMMCNodeType *>(lParam);
        ::SetWindowLong(hwndDlg, DWL_USER, reinterpret_cast<LONG>(pMMCNodeType));

        if (NULL != pMMCNodeType)
        {
            ::SetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID, pMMCNodeType->m_pszGuid);
            ::SetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_NAME, pMMCNodeType->m_pszName);

            // If we are showing properties for an existing node type then disable
            // the edit controls and hide the Cancel button

            if (::strlen(pMMCNodeType->m_pszGuid) > 0)
            {
                ::EnableWindow(::GetDlgItem(hwndDlg, IDC_EDIT_AVAIL_NODE_NAME), FALSE);
                ::EnableWindow(::GetDlgItem(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID), FALSE);
                ::ShowWindow(::GetDlgItem(hwndDlg, IDCANCEL), SW_HIDE);
            }
            else
            {
                // The user has asked to add a new node type. Disable the OK
                // button until something has been typed in.
                ::EnableWindow(::GetDlgItem(hwndDlg, IDOK), FALSE);
            }
        }

        return TRUE;
    }

    pMMCNodeType = reinterpret_cast<CMMCNodeType *>(::GetWindowLong(hwndDlg, DWL_USER));

    switch (uMsg)
    {
    case WM_HELP:
        g_GlobalHelp.ShowHelp(HID_mssnapd_AddToAvailableNodes);
        return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
		case IDOK:
		{
            // Get the node type string entered by the user

            ::GetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID, reinterpret_cast<LPTSTR>(pszBuffer), kSIMaxBuffer);

            // Convert to wide char

            hr = ::WideStrFromANSI(pszBuffer, &pwszGUID);
            if (FAILED(hr))
            {
                //UNDONE: generate error message here
                GLOBAL_EXCEPTION_CHECK(hr);
                ::EndDialog(hwndDlg, 0);
            }

            // Check that the GUID string entered is indeed a GUID

            CLSID clsid = CLSID_NULL;
            hr = ::CLSIDFromString(pwszGUID, &clsid);
            CtlFree(pwszGUID);
            if (CO_E_CLASSSTRING == hr)
            {
                hr = ::SDU_DisplayMessage(IDS_INVALID_GUID,
                                          MB_OK | MB_ICONHAND,
                                          HID_mssnapd_InvalidGuid, 0,
                                          DontAppendErrorInfo, &nRet);
                if (FAILED(hr))
                {
                    GLOBAL_EXCEPTION_CHECK(hr);
                }
                if ( FAILED(hr) || (IDCANCEL == nRet) )
                {
                    ::EndDialog(hwndDlg, 0);
                }
                else
                {
                    return TRUE;
                }
            }

            if (NULL != pMMCNodeType->m_pszGuid)
                CtlFree(pMMCNodeType->m_pszGuid);
            pMMCNodeType->m_pszGuid = reinterpret_cast<char *>(CtlAlloc(::strlen(pszBuffer) + 1));
            if (NULL == pMMCNodeType->m_pszGuid)
            {
                //UNDONE: generate error message here
                GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
                ::EndDialog(hwndDlg, 0);
                return TRUE;
            }
            ::strcpy(pMMCNodeType->m_pszGuid, pszBuffer);

            ::GetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_NAME, reinterpret_cast<LPTSTR>(pszBuffer), kSIMaxBuffer);
            if (NULL != pMMCNodeType->m_pszName)
                CtlFree(pMMCNodeType->m_pszName);
            pMMCNodeType->m_pszName = reinterpret_cast<char *>(CtlAlloc(::strlen(pszBuffer) + 1));
            if (NULL == pMMCNodeType->m_pszName)
            {
                //UNDONE: generate error message here
                GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
                ::EndDialog(hwndDlg, 0);
            }
            ::strcpy(pMMCNodeType->m_pszName, pszBuffer);

             // return 1 to indicate user entered valid data
            ::EndDialog(hwndDlg, 1);
            return TRUE;
            break;
		}

        case IDCANCEL:
            ::EndDialog(hwndDlg, 0);
            return TRUE;
            break;

        case IDHELP:
            g_GlobalHelp.ShowHelp(HID_mssnapd_AddToAvailableNodes);
            return TRUE;
            break;

        case IDC_EDIT_AVAIL_NODE_GUID:
            if (EN_CHANGE == HIWORD(wParam))
            {
                // If the GUID edit field is empty then disable the OK button
                if (0 == ::GetDlgItemText(hwndDlg, IDC_EDIT_AVAIL_NODE_GUID,
                                          pszBuffer, kSIMaxBuffer))
                {
                    ::EnableWindow(::GetDlgItem(hwndDlg, IDOK), FALSE);
                }
                else
                {
                    ::EnableWindow(::GetDlgItem(hwndDlg, IDOK), TRUE);
                }
            }
            break;
        }
        break;
    }

    return FALSE;
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::OnDefault(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uiMsg)
    {
    case kCheckBoxChanged:
        hr = S_OK; // message was handled
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::FindSnapIn(BSTR bstrNodeTypeGUID, IExtendedSnapIn **ppiExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::FindSnapIn(BSTR bstrNodeTypeGUID, IExtendedSnapIn **ppiExtendedSnapIn)
{
    HRESULT              hr = S_FALSE;
    IExtensionDefs      *piExtensionDefs = NULL;
    IExtendedSnapIns    *piExtendedSnapIns = NULL;
    long                 lCount = 0;
    long                 lIndex = 0;
    VARIANT              vtIndex;
    IExtendedSnapIn     *piExtendedSnapIn = NULL;
    BSTR                 bstrThisNodeGUID = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
    IfFailGo(hr);

    hr = piExtendedSnapIns->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piExtendedSnapIns->get_Item(vtIndex, &piExtendedSnapIn);
        IfFailGo(hr);

        hr = piExtendedSnapIn->get_NodeTypeGUID(&bstrThisNodeGUID);
        IfFailGo(hr);

        if (0 == ::wcscmp(bstrNodeTypeGUID, bstrThisNodeGUID))
        {
            *ppiExtendedSnapIn = piExtendedSnapIn;
            piExtendedSnapIn->AddRef();
            hr = S_OK;
            goto Error;
        }

        FREESTRING(bstrThisNodeGUID);
        RELEASE(piExtendedSnapIn);
    }

    hr = S_FALSE;

Error:
    FREESTRING(bstrThisNodeGUID);
    ::VariantClear(&vtIndex);
    RELEASE(piExtendedSnapIn);
    RELEASE(piExtendedSnapIns);
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::AddSnapIn(CMMCNodeType *pCMMCNodeType)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::AddSnapIn(CMMCNodeType *pCMMCNodeType)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrNodeTypeGUID = NULL;
    IExtendedSnapIn     *piExtendedSnapIn = NULL;
    IExtensionDefs      *piExtensionDefs = NULL;
    IExtendedSnapIns    *piExtendedSnapIns = NULL;
    VARIANT              vtIndex;
    VARIANT              vtKey;
    BSTR                 bstrNodeTypeName = NULL;

    ASSERT(NULL != pCMMCNodeType, "AddSnapIn: pCMMCNodeType is NULL");

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtKey);

    hr = ::BSTRFromANSI(pCMMCNodeType->m_pszGuid, &bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
    IfFailGo(hr);

    vtIndex.vt = VT_ERROR;
    vtIndex.scode = DISP_E_PARAMNOTFOUND;
    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrNodeTypeGUID);
    if (NULL == vtKey.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piExtendedSnapIns->Add(vtIndex, vtKey, &piExtendedSnapIn);
    IfFailGo(hr);

    hr = piExtendedSnapIn->put_NodeTypeGUID(bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = BSTRFromANSI(pCMMCNodeType->m_pszName, &bstrNodeTypeName);
    IfFailGo(hr);

    hr = piExtendedSnapIn->put_NodeTypeName(bstrNodeTypeName);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtKey);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrNodeTypeGUID);
    RELEASE(piExtendedSnapIn);
    RELEASE(piExtendedSnapIns);
    RELEASE(piExtensionDefs);
    FREESTRING(bstrNodeTypeGUID);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInAvailNodesPage::RemoveSnapIn(CMMCNodeType *pCMMCNodeType)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInAvailNodesPage::RemoveSnapIn(CMMCNodeType *pCMMCNodeType)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrNodeTypeGUID = NULL;
    IExtensionDefs      *piExtensionDefs = NULL;
    IExtendedSnapIns    *piExtendedSnapIns = NULL;
    VARIANT              vtKey;

    ASSERT(NULL != pCMMCNodeType, "RemoveSnapIn: pCMMCNodeType is NULL");

    ::VariantInit(&vtKey);

    hr = BSTRFromANSI(pCMMCNodeType->m_pszGuid, &bstrNodeTypeGUID);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
    IfFailGo(hr);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrNodeTypeGUID);
    if (NULL == vtKey.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piExtendedSnapIns->Remove(vtKey);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtKey);
    RELEASE(piExtendedSnapIns);
    RELEASE(piExtensionDefs);
    FREESTRING(bstrNodeTypeGUID);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psimglst.cpp ===
//=--------------------------------------------------------------------------------------
// psimglst.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// ImageList Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psimglst.h"

// for ASSERT and FAIL
//
SZTHISFILE


const int   CX_IMAGE_HILIGHT    = 2;
const int   CY_IMAGE_HILIGHT    = 2;

const int   CX_IMAGE_BORDER     = CX_IMAGE_HILIGHT * 3;
const int   CY_IMAGE_BORDER     = CY_IMAGE_HILIGHT * 3;

const int   OX_IMAGE_FOCUS      = CX_IMAGE_HILIGHT * 2;
const int   OY_IMAGE_FOCUS      = CY_IMAGE_HILIGHT * 2;


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// ImageLists Property Page Images
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CImageListImagesPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CImageListImagesPage::Create(IUnknown *pUnkOuter)
{
	CImageListImagesPage *pNew = New CImageListImagesPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::CImageListImagesPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CImageListImagesPage::CImageListImagesPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGIMGLISTSIMAGES), m_piMMCImageList(0), m_iCurrentImage(0)
{
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::~CImageListImagesPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CImageListImagesPage::~CImageListImagesPage()
{
    RELEASE(m_piMMCImageList);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnInitializeDialog()
{
    HRESULT      hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_IL_INDEX, IDS_TT_IL_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_IL_KEY, IDS_TT_IL_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_IL_TAG, IDS_TT_IL_TAG);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_IL_IMAGE_COUNT, IDS_TT_IL_COUNT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IMMCImages     *piMMCImages = NULL;
    long            lCount = 0;
    VARIANT         vtIndex;
    IMMCImage      *piMMCImage = NULL;
    BSTR            bstrKey = NULL;
    VARIANT         vtTag;
    VARIANT         vtTagBstr;

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtTag);
    ::VariantInit(&vtTagBstr);

    if (m_piMMCImageList != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IMMCImageList, reinterpret_cast<void **>(&m_piMMCImageList));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    hr = piMMCImages->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_iCurrentImage = 1;

        hr = SetDlgText(IDC_EDIT_IL_INDEX, m_iCurrentImage);
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        hr = piMMCImage->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_KEY, bstrKey);
        IfFailGo(hr);

        hr = piMMCImage->get_Tag(&vtTag);
        IfFailGo(hr);

        hr = ::VariantChangeType(&vtTagBstr, &vtTag, 0, VT_BSTR);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_TAG, vtTagBstr.bstrVal);
        IfFailGo(hr);

        hr = UpdateImages();
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_SETCURSEL, 0 ,0);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_IL_INDEX, m_iCurrentImage);
        IfFailGo(hr);

        hr = EnableInput(false);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_IL_REMOVE_PICTURE), FALSE);
    }

    hr = SetDlgText(IDC_EDIT_IL_IMAGE_COUNT, lCount);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    ::VariantClear(&vtTagBstr);
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnApply()
{
    HRESULT      hr = S_OK;
    IMMCImages  *piMMCImages = NULL;
    VARIANT      vtIndex;
    IMMCImage   *piMMCImage = NULL;
    BSTR         bstrKey = NULL;
    VARIANT      vtTag;

    ASSERT(m_piMMCImageList != NULL, "OnApply: m_piMMCImageList is NULL");

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtTag);

    if (m_iCurrentImage > 0)
    {
        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));

        hr = GetDlgText(IDC_EDIT_IL_KEY, &bstrKey);
        IfFailGo(hr);

        hr = piMMCImage->put_Key(bstrKey);
        IfFailGo(hr);

        vtTag.vt = VT_BSTR;
        hr = GetDlgText(IDC_EDIT_IL_TAG, &vtTag.bstrVal);
        IfFailGo(hr);

        hr = piMMCImage->put_Tag(vtTag);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// If the index field lost focus and the index has changed then do an Apply if dirty and
// move to the requested index if valid.
//
HRESULT CImageListImagesPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    IMMCImages      *piMMCImages = NULL;
    int              lIndex = 0;
    long             lCount = 0;
    VARIANT          vtIndex;
    IMMCImage       *piMMCImage = NULL;

    ::VariantInit(&vtIndex);

    switch (dlgItemID)
    {
    case IDC_EDIT_IL_INDEX:

        // Get the contents of the index field. If the user entered something
        // other than a number then set the index to 1.
        
        hr = GetDlgInt(IDC_EDIT_IL_INDEX, &lIndex);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_iCurrentImage = 0;
        }
        IfFailGo(hr);

        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        hr = piMMCImages->get_Count(&lCount);
        IfFailGo(hr);

        // If there was no change to the index then ignore it

        IfFalseGo(lIndex != m_iCurrentImage, S_OK);

        // If the user entered an index of zero then switch it to 1 because the
        // collection is one-based

        if (0 == lIndex)
        {
            lIndex = 1L;
        }

        // If the user entered an index that is beyond the end of the list then
        // switch to the last valid index

        if (lIndex > lCount)
        {
            lIndex = lCount;
        }

        // If the old image is dirty then save the changes

        if (IsDirty())
        {
            IfFailGo(Apply());
        }

        // Record the new current index
        
        m_iCurrentImage = lIndex;

        // Get the image at the new index

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        // Select and display the new image

        hr = ShowImage(piMMCImage);
        IfFailGo(hr);
        break;
    }

Error:
    RELEASE(piMMCImage);
    RELEASE(piMMCImages);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnButtonClicked(int dlgItemID)
{
    HRESULT     hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_IL_INSERT_PICTURE:
        hr = OnInsertPicture();
        IfFailGo(hr);
        break;

    case IDC_BUTTON_IL_REMOVE_PICTURE:
        hr = OnRemovePicture();
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnInsertPicture
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnInsertPicture()
{
    HRESULT       hr = S_OK;
    TCHAR        *pszFileName = NULL;
    IStream      *piStream = NULL;
    IDispatch    *piPictureDisp = NULL;
    IPicture     *piPicture = NULL;
    IMMCImages   *piMMCImages = NULL;
    long          lCount = 0;
    long          cbPicture = 0;
    VARIANT       vtIndex;
    VARIANT       vtKey;
    VARIANT       vtPicture;
    IMMCImage    *piMMCImage = NULL;
    short         PictureType = PICTYPE_UNINITIALIZED;

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtPicture);

	// If the current picture is unsaved then save it
	if (IsDirty())
	{
		hr = Apply();
		IfFailGo(hr);
	}

    hr = GetFileName(&pszFileName);
    IfFailGo(hr);

    if (hr == S_OK)
    {
        hr = CreateStreamOnFile(pszFileName, &piStream, &cbPicture);
        IfFailGo(hr);

        hr = ::OleLoadPicture(piStream,
                              0,             // Read entire stream
                              FALSE,         // Keep original format
                              IID_IDispatch, // Interface requested
                              reinterpret_cast<void **>(&piPictureDisp));
        EXCEPTION_CHECK_GO(hr);

        // NTBUGS 349270
        // Despite the fact that we only offer *.bmp extensions in the
        // file open dialog, the user can still type in something else like
        // .ico. Ask the picture for its type and display an error for anything
        // but a bitmap.

        IfFailGo(piPictureDisp->QueryInterface(IID_IPicture,
                                   reinterpret_cast<void **>(&piPicture)));

        IfFailGo(piPicture->get_Type(&PictureType));
        if (PICTYPE_BITMAP != PictureType)
        {
            (void)::SDU_DisplayMessage(IDS_INVALID_PICTURE, MB_OK | MB_ICONHAND, HID_mssnapd_InvalidPicture, 0, DontAppendErrorInfo, NULL);
            hr = SID_E_INVALID_IMAGE_TYPE;
            EXCEPTION_CHECK_GO(hr);
        }

        // END NTBUGS 349270

        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        hr = piMMCImages->get_Count(&lCount);
        IfFailGo(hr);

        ++m_iCurrentImage;
        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;

        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;

        vtPicture.vt = VT_DISPATCH;
        vtPicture.pdispVal = piPictureDisp;

        hr = piMMCImages->Add(vtIndex, vtKey, vtPicture, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        hr = UpdateImages();
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_IMAGE_COUNT, lCount + 1);
        IfFailGo(hr);

        hr = EnableInput(true);
        IfFailGo(hr);

        hr = ShowImage(piMMCImage);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_IL_REMOVE_PICTURE), TRUE);
    }

	MakeDirty();

Error:
    QUICK_RELEASE(piMMCImage);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piPictureDisp);
    QUICK_RELEASE(piPicture);
    QUICK_RELEASE(piStream);
    if (pszFileName != NULL)
        CtlFree(pszFileName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::GetFileName(char **ppszFileName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::GetFileName(TCHAR **ppszFileName)
{
    HRESULT         hr = S_OK;
    BOOL            bResult = FALSE;
    OPENFILENAME    of;
    TCHAR           pszFilter[] = _T("Bitmaps (*.bmp;*.dib)\0*.bmp;*.dib\0\0");
    TCHAR           pszPath[kSIMaxBuffer + 1];
    TCHAR           pszFileName[kSIMaxBuffer + 1];
    TCHAR           pszTitle[] = _T("Choose an image");
    DWORD           dwReturn = 0;

    pszPath[0] = 0;
    pszFileName[0] = 0;

    ::memset(&of, 0, sizeof(OPENFILENAME));
    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = m_hwnd;
    of.hInstance = GetResourceHandle();
    of.lpstrFilter = pszFilter;
    of.lpstrFile = pszPath;
    of.nMaxFile = kSIMaxBuffer;
    of.lpstrFileTitle = pszFileName;
    of.nMaxFileTitle = kSIMaxBuffer;
    of.lpstrTitle = pszTitle;
    of.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

    bResult = ::GetOpenFileName(&of);
    if (bResult == FALSE)
    {
        dwReturn = CommDlgExtendedError();
        hr = HRESULT_FROM_WIN32(dwReturn);
        EXCEPTION_CHECK_GO(hr);
        hr = S_FALSE;
    }
    else
    {
        *ppszFileName = reinterpret_cast<TCHAR *>(CtlAlloc(_tcslen(pszPath) + 1));
        if (*ppszFileName == NULL)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        _tcscpy(*ppszFileName, pszPath);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::CreateStreamOnFile(const TCHAR *lpctFilename, IStream **ppStream, long *pcbPicture)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::CreateStreamOnFile(const TCHAR *lpctFilename, IStream **ppStream, long *pcbPicture)
{
    HRESULT     hr = S_OK;
    HANDLE      hFile = NULL;
    DWORD       dwSize = 0;
    HANDLE      hMem = NULL;
    LPVOID      pMem = NULL;
    DWORD       dwRead = 0;

    *ppStream = NULL;


    hFile = ::CreateFile(lpctFilename,                // filename
                         GENERIC_READ,                // Access mode
                         FILE_SHARE_READ,             // Share mode
                         NULL,                        // Security
                         OPEN_EXISTING,
                         FILE_FLAG_SEQUENTIAL_SCAN,   // flags and attributes
                         NULL);                       // template file handle

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    dwSize = ::GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hMem = ::GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if (hMem == NULL) 
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    pMem = ::GlobalLock(hMem);

    if (!::ReadFile(hFile, pMem, dwSize, &dwRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (dwRead != dwSize)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (::GlobalUnlock(hMem) == 0)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (NOERROR != ::GetLastError())
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }
    pMem = NULL;

    hr = ::CreateStreamOnHGlobal(hMem, TRUE, ppStream);
    IfFailGo(hr);
    hMem = NULL;

    // Use static cast to ensure that DWORD fits into a long.
    // Convert to unsigned long first to avoid sign extension.
    *pcbPicture = (long)(static_cast<unsigned long>(dwSize));

Error:
    if (hFile != NULL)
        ::CloseHandle(hFile);	
    if (FAILED(hr))
    {
        if (pMem != NULL)
            ::GlobalUnlock(hMem);
        if (hMem != NULL)
            ::GlobalFree(hMem);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnRemovePicture
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnRemovePicture()
{
    HRESULT     hr = S_OK;
    IMMCImages *piMMCImages = NULL;
    long        lCount = 0;
    VARIANT     vtIndex;
    IMMCImage  *piMMCImage = NULL;
    BSTR        bstrNull = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    hr = piMMCImages->get_Count(&lCount);
    IfFailGo(hr);

    if (m_iCurrentImage > 0 && m_iCurrentImage <= lCount)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        --m_iCurrentImage;

        hr = piMMCImages->Remove(vtIndex);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_DELETESTRING, static_cast<WPARAM>(m_iCurrentImage), 0);

        hr = UpdateImages();
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_IL_IMAGE_COUNT, lCount - 1);
        IfFailGo(hr);

        if (lCount - 1 > 0)
        {
            if (m_iCurrentImage == 0)
                m_iCurrentImage = 1;
            else if (m_iCurrentImage > lCount - 1)
                m_iCurrentImage = lCount - 1;
        }

        if (m_iCurrentImage > 0)
        {
            ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_SETCURSEL, static_cast<WPARAM>(m_iCurrentImage - 1), 0);

            vtIndex.vt = VT_I4;
            vtIndex.lVal = m_iCurrentImage;

            hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
            IfFailGo(hr);

            hr = ShowImage(piMMCImage);
            IfFailGo(hr);
        }
        else
        {
            hr = SetDlgText(IDC_EDIT_IL_INDEX, bstrNull);
            IfFailGo(hr);

            hr = SetDlgText(IDC_EDIT_IL_KEY, bstrNull);
            IfFailGo(hr);

            hr = SetDlgText(IDC_EDIT_IL_TAG, bstrNull);
            IfFailGo(hr);

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_IL_REMOVE_PICTURE), FALSE);

            hr = EnableInput(false);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct)
{
    HRESULT     hr = S_OK;
    RECT        rect;

    ::GetClientRect(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), &rect);
    pMeasureItemStruct->itemHeight = rect.bottom;
    pMeasureItemStruct->itemWidth = rect.bottom;	

    // VBE#20445: a-cmai 8/1/96 -- Used for the work around
//    m_nVisibleItems = rect.right / rect.bottom;

    return hr;
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct)
{
    HRESULT     hr = S_OK;
	UINT        uAction = pDrawItemStruct->itemAction;
    HBRUSH      hbr = NULL;
    RECT        rc;

    if (pDrawItemStruct->itemID == -1)
        RRETURN(hr);

    if (uAction == ODA_DRAWENTIRE)
    {
        // Fill background with button face color
        hbr = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
        if (hbr == NULL)
            ::FillRect(pDrawItemStruct->hDC, &pDrawItemStruct->rcItem, static_cast<HBRUSH>(::GetStockObject(LTGRAY_BRUSH)));
        else
        {
            ::FillRect(pDrawItemStruct->hDC, &pDrawItemStruct->rcItem, hbr);
        }

        // Set up color box rectangle
        ::SetRect(&rc,
                 pDrawItemStruct->rcItem.left + CX_IMAGE_BORDER,
                 pDrawItemStruct->rcItem.top + CY_IMAGE_BORDER, 
                 pDrawItemStruct->rcItem.right - CX_IMAGE_BORDER,
                 pDrawItemStruct->rcItem.bottom - CY_IMAGE_BORDER);

        DrawImage(pDrawItemStruct->hDC, pDrawItemStruct->itemID, rc);

        // Next step is to draw the text with correct selection state
        uAction = ODA_SELECT;
    }

    if (uAction == ODA_SELECT)
    {
        // Set up text rectangle
        ::SetRect(&rc,
                  pDrawItemStruct->rcItem.left,
                  pDrawItemStruct->rcItem.top,
                  pDrawItemStruct->rcItem.right,
                  pDrawItemStruct->rcItem.bottom);

        // Draw selection state
        DrawRectEffect(pDrawItemStruct->hDC, rc, (ODS_SELECTED & pDrawItemStruct->itemState) ? EDGE_RAISED : NULL);

        // If we are to draw the entire item and its has focus then
        // set uAction for drawing the focus 
        //
        if (pDrawItemStruct->itemAction == ODA_DRAWENTIRE && (ODS_FOCUS & pDrawItemStruct->itemState))
            uAction = ODA_FOCUS;
    }    

    if (uAction == ODA_FOCUS)
    {
        // Set up focus rect
        ::SetRect(&rc,
                  pDrawItemStruct->rcItem.left + OX_IMAGE_FOCUS,
                  pDrawItemStruct->rcItem.top + OY_IMAGE_FOCUS,
                  pDrawItemStruct->rcItem.right - OX_IMAGE_FOCUS,
                  pDrawItemStruct->rcItem.bottom - OY_IMAGE_FOCUS);

        DrawRectEffect(pDrawItemStruct->hDC, rc, (ODS_FOCUS & pDrawItemStruct->itemState) ? EDGE_ETCHED : NULL);
    }

    if (hbr != NULL)
        ::DeleteObject(static_cast<HGDIOBJ>(hbr));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::DrawImage(HDC hdc, int nIndex, const RECT& rcImage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::DrawImage(HDC hdc, int nIndex, const RECT& rcImage)
{
    HRESULT          hr = S_OK;
    VARIANT          vIndex;
    IMMCImages      *piMMCImages = NULL;
    IMMCImage       *piMMCImage = NULL;
    IPictureDisp    *pPictureDisp = NULL;
    IPicture        *pPicture = NULL;

    ::VariantInit(&vIndex);	

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    vIndex.vt = VT_I4;
    vIndex.lVal = nIndex + 1;
    hr = piMMCImages->get_Item(vIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
    IfFailGo(hr);

    if (piMMCImage != NULL)
    {
        // Get Images(iIndex).Picture
        hr = piMMCImage->get_Picture(&pPictureDisp);
        IfFailGo(hr);

        hr = pPictureDisp->QueryInterface(IID_IPicture, (void **) &pPicture);
        IfFailGo(hr);

        // Draw Images(iIndex).Picture
        if (pPicture != NULL)
            hr = RenderPicture(pPicture, hdc, &rcImage, &rcImage);
    }

Error:
    RELEASE(pPicture);
    RELEASE(pPictureDisp);
    ::VariantClear(&vIndex);
    RELEASE(piMMCImage);
    RELEASE(piMMCImages);

    return TRUE;
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::RenderPicture(IPicture *pPicture, HDC hdc, const RECT *prcRender, const RECT *prcWBounds)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::RenderPicture
(
    IPicture   *pPicture, 
    HDC         hdc, 
    const RECT *prcRender, 
    const RECT *prcWBounds
)
{
    HRESULT     hr = S_OK;
    long        hmWidth = 0;
    long        hmHeight = 0;
    long        lWidth = 0;
    long        lHeight = 0;

    if (pPicture != NULL)
    {
        hr = pPicture->get_Width(&hmWidth);
        hr = pPicture->get_Height(&hmHeight);

        lWidth = prcRender->right - prcRender->left;
        lHeight = prcRender->bottom - prcRender->top;

        if (lWidth < 0)
            lWidth = -lWidth;
        if (lHeight < 0)
            lHeight = -lHeight;

        ASSERT(lWidth >= 0, "Width is negative");
        ASSERT(lHeight >=0, "Height is negative");

        hr = pPicture->Render(hdc,
                              prcRender->left,
                              prcRender->top,
                              lWidth,
                              lHeight,
                              0,
                              hmHeight - 1,
                              hmWidth,
                              -hmHeight,
                              prcWBounds);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::DrawRectEffect(HDC hdc, const RECT& rc, WORD dwStyle)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::DrawRectEffect(HDC hdc, const RECT& rc, WORD dwStyle)
{
    HRESULT hr = S_OK;
    BOOL    fRet = FALSE;
    HBRUSH  hbr = NULL;
    HBRUSH  hbrOld = NULL;

    if (dwStyle == NULL)
    {
        hbr = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
        fRet = NULL != hbr;

        if (hbr == NULL)
            hbr = static_cast<HBRUSH>(::GetStockObject(LTGRAY_BRUSH));

        hbrOld = static_cast<HBRUSH>(::SelectObject(hdc, static_cast<HGDIOBJ>(hbr)));

        ::PatBlt(hdc, rc.left, rc.top,     rc.right - rc.left,    CY_IMAGE_HILIGHT,      PATCOPY);
        ::PatBlt(hdc, rc.left, rc.top,     CX_IMAGE_HILIGHT,      rc.bottom - rc.top,    PATCOPY);
        ::PatBlt(hdc, rc.right, rc.bottom, -(rc.right - rc.left), -CY_IMAGE_HILIGHT,     PATCOPY);
        ::PatBlt(hdc, rc.right, rc.bottom, -CX_IMAGE_HILIGHT,     -(rc.bottom - rc.top), PATCOPY);

        ::SelectObject(hdc, static_cast<HGDIOBJ>(hbrOld));

        if (hbr != NULL)
            ::DeleteObject(static_cast<HGDIOBJ>(hbr));
    }	
    else
        fRet = ::DrawEdge(hdc, const_cast<LPRECT>(&rc), dwStyle, BF_RECT);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Called when the user selects a different picture in the listbox
//
HRESULT CImageListImagesPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT      hr = S_OK;
    int          iIndex = 0;
    IMMCImages  *piMMCImages = NULL;
    VARIANT      vtIndex;
    IMMCImage   *piMMCImage = NULL;

    ::VariantInit(&vtIndex);

    // If the current picture is unsaved then save it
    if (IsDirty())
    {
        hr = Apply();
        IfFailGo(hr);
    }

    if (dlgItemID == IDC_LIST_IL_IMAGES)
    {
        iIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES), LB_GETCURSEL, 0, 0);
        if (iIndex == LB_ERR)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        m_iCurrentImage = iIndex + 1;

        hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = m_iCurrentImage;
        hr = piMMCImages->get_Item(vtIndex, reinterpret_cast<MMCImage **>(&piMMCImage));
        IfFailGo(hr);

        hr = ShowImage(piMMCImage);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCImage);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::UpdateImages()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::UpdateImages()
{
    HRESULT     hr = S_OK;
    HWND        hwndList = NULL;
    IMMCImages *piMMCImages = NULL;
    long        lCount = 0;
    long        lIndex = 0;

    hwndList = ::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES);
    if (hwndList == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
    ::SendMessage(hwndList, LB_RESETCONTENT, 0, 0L);

    hr = m_piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages));
    IfFailGo(hr);

    hr = piMMCImages->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 0; lIndex < lCount; ++lIndex)
    {
        // For each image, we add a place holder to the list
        // OnDrawItem will look up the corresponding IPicture
        ::SendMessage(hwndList, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(_T("")));
    }

    ::SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
    ::InvalidateRect(hwndList, NULL, TRUE);

Error:
    RELEASE(piMMCImages);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::EnableInput(bool bEnable)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::EnableInput(bool bEnable)
{
    BOOL    fReadOnly = (bEnable == false) ? TRUE : FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_IL_INDEX), EM_SETREADONLY, static_cast<WPARAM>(fReadOnly), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_IL_KEY), EM_SETREADONLY, static_cast<WPARAM>(fReadOnly), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_IL_TAG), EM_SETREADONLY, static_cast<WPARAM>(fReadOnly), 0);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::ShowImage(IMMCImage *piMMCImage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::ShowImage(IMMCImage *piMMCImage)
{
    HRESULT     hr = S_OK;
    long        lIndex = 0;
    BSTR        bstrKey = NULL;
    VARIANT     vtTag;
    VARIANT     vtTagBstr;

    ASSERT(piMMCImage != NULL, "ShowImage: piMMCImage is NULL");

    ::VariantInit(&vtTag);
    ::VariantInit(&vtTagBstr);

    m_bSilentUpdate = true;
    hr = piMMCImage->get_Index(&lIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_IL_INDEX, lIndex);
    IfFailGo(hr);

    hr = piMMCImage->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_IL_KEY, bstrKey);
    IfFailGo(hr);

    hr = piMMCImage->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = ::VariantChangeType(&vtTagBstr, &vtTag, 0, VT_BSTR);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_IL_TAG, vtTagBstr.bstrVal);
    IfFailGo(hr);

    // Select the image in the listbox

    if (LB_ERR == ::SendMessage(::GetDlgItem(m_hwnd, IDC_LIST_IL_IMAGES),
                                             LB_SETCURSEL, lIndex - 1L, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    ::VariantClear(&vtTagBstr);
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    m_bSilentUpdate = false;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CImageListImagesPage::OnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CImageListImagesPage::OnTextChanged(int dlgItemID)
{
    if ( (IDC_EDIT_IL_KEY == dlgItemID) || (IDC_EDIT_IL_TAG == dlgItemID) )
    {
        MakeDirty();
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psimglst.h ===
//=--------------------------------------------------------------------------------------
// psimglst.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// ImageList Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSIMGLST_H_
#define _PSIMGLST_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Image List Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CImageListImagesPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CImageListImagesPage(IUnknown *pUnkOuter);
    virtual ~CImageListImagesPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnMeasureItem(MEASUREITEMSTRUCT *pMeasureItemStruct);
    virtual HRESULT OnDrawItem(DRAWITEMSTRUCT *pDrawItemStruct);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);
    virtual HRESULT OnTextChanged(int dlgItemID);


// Helpers for Apply event
protected:

// Other helpers
protected:
    HRESULT ShowImage(IMMCImage *piMMCImage);
    HRESULT EnableInput(bool bEnable);

    HRESULT OnInsertPicture();
    HRESULT GetFileName(TCHAR **ppszFileName);
    HRESULT CreateStreamOnFile(const TCHAR *lpctFilename, IStream **ppStream, long *pcbPicture);

    HRESULT OnRemovePicture();

// Custom drawing
protected:
    HRESULT DrawImage(HDC hdc, int nIndex, const RECT& rcImage);
    HRESULT RenderPicture(IPicture *pPicture, HDC hdc, const RECT *prcRender, const RECT *prcWBounds);
    HRESULT DrawRectEffect(HDC hdc, const RECT& rc, WORD dwStyle);
    HRESULT UpdateImages();

// Instance data
protected:
    IMMCImageList   *m_piMMCImageList;
    int              m_iCurrentImage;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ImageListImages,                    // Name
	&CLSID_MMCImageListImagesPP,        // Class ID
	"ImageList Images Property Page",   // Registry display name
	CImageListImagesPage::Create,       // Create function
	IDD_PROPPAGE_IL_IMAGES,             // Dialog resource ID
	IDS_IMGLSTPPG_IMG,                  // Tab caption
	IDS_IMGLSTPPG_IMG,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_ImageLists,             // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSIMGLST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pslistvw.cpp ===
//=--------------------------------------------------------------------------------------
// pslistvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "pslistvw.h"

// for ASSERT and FAIL
//
SZTHISFILE


struct ViewModes
{
    TCHAR                   m_pszModeName[kSIMaxBuffer + 1];
    SnapInViewModeConstants m_iIdentifier;
    int                     m_iIndex;
};

struct ViewModes g_viewModes[5] =
{
    { _T(""),  siIcon,        -1, },
    { _T(""),  siSmallIcon,   -1, },
    { _T(""),  siList,        -1, },
    { _T(""),  siReport,      -1, },
    { _T(""),  siFiltered,    -1  }
};

static size_t g_cViewModes = sizeof(g_viewModes) / sizeof(g_viewModes[0]);


struct SortOrder
{
    TCHAR                    m_pszSortOrderName[kSIMaxBuffer + 1];
    SnapInSortOrderConstants m_iIdentifier;
    int                      m_iIndex;
};

struct SortOrder g_sortOrder[2] =
{
    { _T(""),  siAscending,   -1, },
    { _T(""),  siDescending,  -1  }
};



////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewGeneralPage::Create(IUnknown *pUnkOuter)
{
        CListViewGeneralPage *pNew = New CListViewGeneralPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::CListViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewGeneralPage::CListViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWGENERAL), m_piListViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::~CListViewGeneralPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewGeneralPage::~CListViewGeneralPage()
{
    RELEASE(m_piListViewDef);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_LV_NAME, IDS_TT_LV1_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_VIEWS, IDS_TT_LV1_DFLTVIEW);
    IfFailGo(hr);

    hr = PopulateViewModes();
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_VIRTUAL_LIST, IDS_TT_LV1_VIRTLIST);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_ADDTOVIEWMENU, IDS_TT_LV1_ADDTOVIEWM);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_ADDTOVIEWMENU, IDS_TT_LV1_ADDTOVIEWM);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_STATUSBARTEXT, IDS_TT_LV1_STATUSTXT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::InitializeViewModes()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::InitializeViewModes()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_viewModes[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_LARGE,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[0].m_pszModeName, szBuffer);
        g_viewModes[0].m_iIdentifier = siIcon;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_SMALL,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[1].m_pszModeName, szBuffer);
        g_viewModes[1].m_iIdentifier = siSmallIcon;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_LIST,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[2].m_pszModeName, szBuffer);
        g_viewModes[2].m_iIdentifier = siList;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_REPORT,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[3].m_pszModeName, szBuffer);
        g_viewModes[3].m_iIdentifier = siReport;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_VM_FILTERED,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_viewModes[4].m_pszModeName, szBuffer);
        g_viewModes[4].m_iIdentifier = siFiltered;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::PopulateViewModes()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::PopulateViewModes()
{
    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;
    size_t      i = 0;

    hr = InitializeViewModes();
    IfFailGo(hr);

    for (i = 0; i < g_cViewModes; i++)
    {
        hr = BSTRFromANSI(g_viewModes[i].m_pszModeName, &bstr);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_VIEWS, bstr, g_viewModes[i].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstr);
    }

Error:
    FREESTRING(bstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrMenuText = NULL;
    BSTR            bstrStatusBarText = NULL;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_NAME, bstrName);
    IfFailGo(hr);

    hr = InitializeDefaultViewMode();
    IfFailGo(hr);

    hr = m_piListViewDef->get_Virtual(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_LV_VIRTUAL_LIST, vtBool);
    IfFailGo(hr);

    hr = m_piListViewDef->get_AddToViewMenu(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_LV_ADDTOVIEWMENU, vtBool);
    IfFailGo(hr);

    if (VARIANT_FALSE == vtBool)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_VIEWMENUTEXT), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_STATUSBARTEXT), FALSE);
    }

    hr = m_piListViewDef->get_ViewMenuText(&bstrMenuText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_VIEWMENUTEXT, bstrMenuText);
    IfFailGo(hr);

    hr = m_piListViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_STATUSBARTEXT, bstrStatusBarText);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrMenuText);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::InitializeDefaultViewMode()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::InitializeDefaultViewMode()
{
    HRESULT                 hr = S_OK;
    HWND                    hCombo = NULL;
    SnapInViewModeConstants svmc = siIcon;

    ASSERT(NULL != m_piListViewDef, "InitializeDefaultViewMode: m_piListViewDef is NULL");

    hCombo = ::GetDlgItem(m_hwnd, IDC_COMBO_LV_VIEWS);
    if (NULL == hCombo)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_View(&svmc);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_LV_VIEWS, static_cast<long>(svmc));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;

    switch (dlgItemID)
    {
    case IDC_CHECK_LV_ADDTOVIEWMENU:
        hr = GetCheckbox(IDC_CHECK_LV_ADDTOVIEWMENU, &vtAddToViewMenu);
        IfFailGo(hr);
        if (VARIANT_TRUE == vtAddToViewMenu)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_VIEWMENUTEXT), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_STATUSBARTEXT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_VIEWMENUTEXT), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_STATUSBARTEXT), FALSE);
        }

        break;

    case IDC_CHECK_LV_VIRTUAL_LIST:
        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_LV_VIEWS:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    hr = ApplyListViewName();
    IfFailGo(hr);

    hr = ApplyDefualtViewMode();
    IfFailGo(hr);

    hr = ApplyVirtualList();
    IfFailGo(hr);

    hr = ApplyAddToViewMenu();
    IfFailGo(hr);

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyListViewName()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyListViewName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrListViewName = NULL;
    BSTR     bstrSavedListViewName = NULL;

    ASSERT(NULL != m_piListViewDef, "ApplyListViewName: m_piListViewDef is NULL");

    hr = GetDlgText(IDC_EDIT_LV_NAME, &bstrListViewName);
    IfFailGo(hr);

    hr = m_piListViewDef->get_Name(&bstrSavedListViewName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrListViewName, bstrSavedListViewName))
    {
        hr = m_piListViewDef->put_Name(bstrListViewName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedListViewName);
    FREESTRING(bstrListViewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyDefualtViewMode()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyDefualtViewMode()
{
    HRESULT                 hr = S_OK;
    long                    lData = 0;
    SnapInViewModeConstants svmc = siIcon;
    SnapInViewModeConstants savedSvmc = siIcon;

    ASSERT(NULL != m_piListViewDef, "ApplyDefualtViewMode: m_piListViewDef is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_LV_VIEWS, &lData);
    IfFailGo(hr);

    svmc = static_cast<SnapInViewModeConstants>(lData);

    hr = m_piListViewDef->get_View(&savedSvmc);
    IfFailGo(hr);

    if (svmc != savedSvmc)
    {
        hr = m_piListViewDef->put_View(svmc);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyVirtualList()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyVirtualList()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtVirtualList = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedVirtualList = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "ApplyVirtualList: m_piListViewDef is NULL");

    hr = GetCheckbox(IDC_CHECK_LV_VIRTUAL_LIST, &vtVirtualList);
    IfFailGo(hr);

    hr = m_piListViewDef->get_Virtual(&vtSavedVirtualList);
    IfFailGo(hr);

    if (vtVirtualList != vtSavedVirtualList)
    {
        hr = m_piListViewDef->put_Virtual(vtVirtualList);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyAddToViewMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyAddToViewMenu()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedAddToViewMenu = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "ApplyAddToViewMenu: m_piListViewDef is NULL");

    hr = GetCheckbox(IDC_CHECK_LV_ADDTOVIEWMENU, &vtAddToViewMenu);
    IfFailGo(hr);

    hr = m_piListViewDef->get_AddToViewMenu(&vtSavedAddToViewMenu);
    IfFailGo(hr);

    if (vtAddToViewMenu != vtSavedAddToViewMenu)
    {
        hr = m_piListViewDef->put_AddToViewMenu(vtAddToViewMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyViewMenuText()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyViewMenuText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewMenuText = NULL;
    BSTR     bstrSavedViewMenuText = NULL;

    ASSERT(NULL != m_piListViewDef, "ApplyViewMenuText: m_piListViewDef is NULL");

    hr = GetDlgText(IDC_EDIT_LV_VIEWMENUTEXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piListViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrViewMenuText, bstrSavedViewMenuText))
    {
        hr = m_piListViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewGeneralPage::ApplyStatusBarText()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewGeneralPage::ApplyStatusBarText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrStatusBarText = NULL;
    BSTR     bstrSavedStatusBarText = NULL;

    ASSERT(NULL != m_piListViewDef, "ApplyStatusBarText: m_piListViewDef is NULL");

    hr = GetDlgText(IDC_EDIT_LV_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piListViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrStatusBarText, bstrSavedStatusBarText))
    {
        hr = m_piListViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Image Lists
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewImgListsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewImgListsPage::Create(IUnknown *pUnkOuter)
{
        CListViewImgListsPage *pNew = New CListViewImgListsPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::CListViewImgListsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewImgListsPage::CListViewImgListsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWIMGLSTS),
  m_piSnapInDesignerDef(0), m_piListViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::~CListViewImgListsPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewImgListsPage::~CListViewImgListsPage()
{
    RELEASE(m_piListViewDef);
    RELEASE(m_piSnapInDesignerDef);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_COMBO_LV_LARGE_ICONS, IDS_TT_LV2_LARGE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_SMALL_ICONS, IDS_TT_LV2_SMALL);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnNewObjects()
{
    HRESULT          hr = S_OK;
    IUnknown        *pUnk = NULL;
    DWORD            dwDummy = 0;
    IObjectModel    *piObjectModel = NULL;
    IMMCListView    *piMMCListView = NULL;
    IMMCImageList   *piMMCLrgImageList = NULL;
    BSTR             bstrLargeIcon = NULL;
    IMMCImageList   *piMMCSmlImageList = NULL;
    BSTR             bstrSmallIcon = NULL;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeComboBoxes();
    IfFailGo(hr);

    hr = m_piListViewDef->get_ListView(&piMMCListView);
    IfFailGo(hr);

    hr = piMMCListView->get_Icons(reinterpret_cast<MMCImageList **>(&piMMCLrgImageList));
    IfFailGo(hr);

    if (NULL != piMMCLrgImageList)
    {
        hr = piMMCLrgImageList->get_Name(&bstrLargeIcon);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_LV_LARGE_ICONS, bstrLargeIcon);
        IfFailGo(hr);
    }

    hr = piMMCListView->get_SmallIcons(reinterpret_cast<MMCImageList **>(&piMMCSmlImageList));
    IfFailGo(hr);

    if (NULL != piMMCSmlImageList)
    {
        hr = piMMCSmlImageList->get_Name(&bstrSmallIcon);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_LV_SMALL_ICONS, bstrSmallIcon);
        IfFailGo(hr);
    }

    m_bInitialized = true;

Error:
    FREESTRING(bstrSmallIcon);
    RELEASE(piMMCSmlImageList);
    FREESTRING(bstrLargeIcon);
    RELEASE(piMMCLrgImageList);
    RELEASE(piMMCListView);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::InitializeComboBoxes()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::InitializeComboBoxes()
{
    HRESULT          hr = S_OK;
    IMMCImageLists  *piMMCImageLists = NULL;
    long             lCount = 0;
    int              lIndex = 0;
    VARIANT          vtIndex;
    IMMCImageList   *piMMCImageList = NULL;
    BSTR             bstrILName = NULL;
    int              iResult = 0;

    ASSERT(NULL != m_piSnapInDesignerDef, "InitializeComboBoxes: m_piSnapInDesignerDef is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrILName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_LARGE_ICONS, bstrILName, 0);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_SMALL_ICONS, bstrILName, 0);
        IfFailGo(hr);

        FREESTRING(bstrILName);
        RELEASE(piMMCImageList);
    }

Error:
    FREESTRING(bstrILName);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    hr = ApplyLargeIcon();
    IfFailGo(hr);

    hr = ApplySmallIcon();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::ApplyLargeIcon()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::ApplyLargeIcon()
{
    HRESULT          hr = S_OK;
    BSTR             bstrLargeIcons = NULL;
    IMMCListView    *piMMCListView = NULL;
    IMMCImageLists  *piMMCImageLists = NULL;
    IMMCImageList   *piMMCImageList = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    ASSERT(NULL != m_piListViewDef, "ApplyLargeIcon: m_piListViewDef is NULL");

    IfFailGo(GetCBSelection(IDC_COMBO_LV_LARGE_ICONS, &bstrLargeIcons));

    if (NULL != bstrLargeIcons)
    {
        IfFailGo(m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));

        varKey.vt = VT_BSTR;
        varKey.bstrVal = bstrLargeIcons;
        IfFailGo(piMMCImageLists->get_Item(varKey, &piMMCImageList));
    }

    IfFailGo(m_piListViewDef->get_ListView(&piMMCListView));
    IfFailGo(piMMCListView->putref_Icons(reinterpret_cast<MMCImageList *>(piMMCImageList)));

Error:
    FREESTRING(bstrLargeIcons);
    RELEASE(piMMCListView);
    RELEASE(piMMCImageLists);
    RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::ApplySmallIcon()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::ApplySmallIcon()
{
    HRESULT          hr = S_OK;
    BSTR             bstrSmallIcons = NULL;
    IMMCListView    *piMMCListView = NULL;
    IMMCImageLists  *piMMCImageLists = NULL;
    IMMCImageList   *piMMCImageList = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    ASSERT(NULL != m_piListViewDef, "ApplySmallIcon: m_piListViewDef is NULL");

    IfFailGo(GetCBSelection(IDC_COMBO_LV_SMALL_ICONS, &bstrSmallIcons));

    if (NULL != bstrSmallIcons)
    {
        IfFailGo(m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));

        varKey.vt = VT_BSTR;
        varKey.bstrVal = bstrSmallIcons;
        IfFailGo(piMMCImageLists->get_Item(varKey, &piMMCImageList));
    }

    IfFailGo(m_piListViewDef->get_ListView(&piMMCListView));
    IfFailGo(piMMCListView->putref_SmallIcons(reinterpret_cast<MMCImageList *>(piMMCImageList)));

Error:
    FREESTRING(bstrSmallIcons);
    RELEASE(piMMCListView);
    RELEASE(piMMCImageLists);
    RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewImgListsPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewImgListsPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    MakeDirty();

    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Sorting
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewSortingPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewSortingPage::Create(IUnknown *pUnkOuter)
{
        CListViewSortingPage *pNew = New CListViewSortingPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::CListViewSortingPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewSortingPage::CListViewSortingPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWSORTING), m_piListViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::~CListViewSortingPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewSortingPage::~CListViewSortingPage()
{
    RELEASE(m_piListViewDef);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_CHECK_LV_SORTED, IDS_TT_LV3_SORTED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_KEY, IDS_TT_LV3_KEY);
    IfFailGo(hr);

    hr = InitializeSortOrder();
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LV_SORT, IDS_TT_LV3_SORTORDER);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::InitializeSortOrderArray()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::InitializeSortOrderArray()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_sortOrder[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_SORT_ASC,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_sortOrder[0].m_pszSortOrderName, szBuffer);
        g_sortOrder[0].m_iIdentifier = siAscending;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_LV_SORT_DESC,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_sortOrder[1].m_pszSortOrderName, szBuffer);
        g_sortOrder[1].m_iIdentifier = siDescending;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::InitializeSortOrder()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::InitializeSortOrder()
{
    HRESULT     hr = S_OK;
    BSTR        bstrSortOrder = NULL;
    int         iIndex = 0;

    hr = InitializeSortOrderArray();
    IfFailGo(hr);

    for (iIndex = 0; iIndex < 2; ++iIndex)
    {
        hr = BSTRFromANSI(g_sortOrder[iIndex].m_pszSortOrderName, &bstrSortOrder);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_SORT, bstrSortOrder, g_sortOrder[iIndex].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstrSortOrder);
    }

Error:
    FREESTRING(bstrSortOrder);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnNewObjects()
{
    HRESULT                   hr = S_OK;
    IUnknown                 *pUnk = NULL;
    DWORD                     dwDummy = 0;
    VARIANT_BOOL              vtBool = VARIANT_FALSE;
    SnapInSortOrderConstants  ssoc = siAscending;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_Sorted(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_LV_SORTED, vtBool);
    IfFailGo(hr);

    if (VARIANT_FALSE == vtBool)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_KEY), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), FALSE);
    }

    hr = InitializeKey();
    IfFailGo(hr);

    hr = m_piListViewDef->get_SortOrder(&ssoc);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_LV_SORT, static_cast<long>(ssoc));
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::InitializeKey
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::InitializeKey()
{
    HRESULT             hr = S_OK;
    IMMCListView       *piMMCListView = NULL;
    IMMCColumnHeaders  *piMMCColumnHeaders = NULL;
    short               sKey = 0;
    long                lIndex = 0;

    ASSERT(NULL != m_piListViewDef, "InitializeKey: m_piListViewDef is NULL");

    hr = m_piListViewDef->get_ListView(&piMMCListView);
    IfFailGo(hr);

    hr = piMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piMMCColumnHeaders));
    IfFailGo(hr);

    hr = PopulateKeys(piMMCColumnHeaders);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piListViewDef->get_SortKey(&sKey);
        IfFailGo(hr);

        lIndex = static_cast<long>(sKey);
        hr = SetCBItemSelection(IDC_COMBO_LV_KEY, lIndex);
    }
    else
        hr = S_OK;

Error:
    RELEASE(piMMCColumnHeaders);
    RELEASE(piMMCListView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::PopulateKeys(IMMCColumnHeaders *piMMCColumnHeaders)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::PopulateKeys(IMMCColumnHeaders *piMMCColumnHeaders)
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    long                lCount = 0;
    long                lIndex = 0;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    int                 iResult = 0;
    BSTR                bstrKey = NULL;

    ASSERT(NULL != m_piListViewDef, "PopulateKeys: m_piListViewDef is NULL");

    ::VariantInit(&vtIndex);

    hr = piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
        IfFailGo(hr);

        hr = piMMCColumnHeader->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LV_KEY, bstrKey, lIndex);
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piMMCColumnHeader);
    }

    hr = (0 == lCount) ? S_FALSE : S_OK;

Error:
    FREESTRING(bstrKey);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnCBDropDown()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
// When user drops down combox box for sort key we need to repopulate the
// list because they may have made changes in the column headers page that we
// have not seen yet. Unfortunately, when the user goes back and forth between
// pages, OnNewObjects() is not called. This is because the OlePropertyFrame
// implementation only forwards the first PSN_SETACTIVE to OLE property pages.
// In order to make sure that we have latest list of column headers, we handle
// this message.

HRESULT CListViewSortingPage::OnCBDropDown(int dlgItemID)
{
    HRESULT hr = S_OK;

    IfFalseGo(IDC_COMBO_LV_KEY == dlgItemID, S_OK);

    // Clear out the combox box

    (void)::SendDlgItemMessage(m_hwnd, IDC_COMBO_LV_KEY, CB_RESETCONTENT, 0, 0);

    // Repopulate it

    IfFailGo(InitializeKey());

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    hr = ApplySorted();
    IfFailGo(hr);

    hr = ApplyKey();
    IfFailGo(hr);

    hr = ApplySortOrder();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::ApplySorted()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::ApplySorted()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtSorted = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedSorted = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "ApplySorted: m_piListViewDef is NULL");

    hr = GetCheckbox(IDC_CHECK_LV_SORTED, &vtSorted);
    IfFailGo(hr);

    hr = m_piListViewDef->get_Sorted(&vtSavedSorted);
    IfFailGo(hr);

    if (vtSorted != vtSavedSorted)
    {
        hr = m_piListViewDef->put_Sorted(vtSorted);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::ApplyKey()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::ApplyKey()
{
    HRESULT     hr = S_OK;
    long        lKey = 0;
    short       sKey = 0;
    short       sSavedKey = 0;

    ASSERT(NULL != m_piListViewDef, "ApplyKey: m_piListViewDef is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_LV_KEY, &lKey);
    IfFailGo(hr);

    // Do nothing if there's no selection
    if (S_OK == hr)
    {
        sKey = static_cast<short>(lKey);

        hr = m_piListViewDef->get_SortKey(&sSavedKey);
        IfFailGo(hr);

        if (sKey != sSavedKey)
        {
            hr = m_piListViewDef->put_SortKey(sKey);
            IfFailGo(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::ApplySortOrder()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::ApplySortOrder()
{
    HRESULT     hr = S_OK;
    int         iIndex = 0;

    ASSERT(NULL != m_piListViewDef, "ApplySortOrder: m_piListViewDef is NULL");

    iIndex = ::SendMessage(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), CB_GETCURSEL, 0, 0);
    if (CB_ERR == iIndex)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->put_SortOrder(g_sortOrder[iIndex].m_iIdentifier);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;

    ASSERT(NULL != m_piListViewDef, "OnButtonClicked: m_piListViewDef is NULL");

    switch (dlgItemID)
    {
    case IDC_CHECK_LV_SORTED:
        hr = GetCheckbox(IDC_CHECK_LV_SORTED, &vtBool);
        IfFailGo(hr);

        if (VARIANT_TRUE == vtBool)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_KEY), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_KEY), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LV_SORT), FALSE);
        }

        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewSortingPage::OnCtlSelChange()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewSortingPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT     hr = S_OK;

    MakeDirty();

    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CListViewColHdrsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CListViewColHdrsPage::Create(IUnknown *pUnkOuter)
{
        CListViewColHdrsPage *pNew = New CListViewColHdrsPage(pUnkOuter);
        return pNew->PrivateUnknown();          
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CListViewColHdrsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewColHdrsPage::CListViewColHdrsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGLSTVIEWCOLHDRS),
  m_piListViewDef(0), m_piMMCColumnHeaders(0), m_lCurrentIndex(0), m_bSavedLastHeader(true)
{
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::~CListViewColHdrsPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CListViewColHdrsPage::~CListViewColHdrsPage()
{
    RELEASE(m_piListViewDef);
    RELEASE(m_piMMCColumnHeaders);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnInitializeDialog()
{
    HRESULT           hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_LV_INDEX, IDS_TT_LV4_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_COLUMNTEXT, IDS_TT_LV4_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_COLUMNWIDTH, IDS_TT_LV4_WIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_LV_AUTOWIDTH, IDS_TT_LV4_AUTOWIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_LV_COLUMNKEY, IDS_TT_LV4_KEY);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnNewObjects()
{
    HRESULT           hr = S_OK;
    IUnknown         *pUnk = NULL;
    DWORD             dwDummy = 0;
    IMMCListView     *piMMCListView = NULL;
    long              lCount = 0;

    if (NULL != m_piListViewDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IListViewDef, reinterpret_cast<void **>(&m_piListViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piListViewDef->get_ListView(&piMMCListView);
    IfFailGo(hr);

    hr = piMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&m_piMMCColumnHeaders));
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentIndex = 1;
        hr = ShowColumnHeader();
        IfFailGo(hr);

        EnableEdits(true);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);
        EnableEdits(false);
    }

    m_bInitialized = true;

Error:
    RELEASE(piMMCListView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnApply()
{
    HRESULT              hr = S_OK;
    long                 lCount = 0;
    int                  disposition = 0;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;

    ASSERT(NULL != m_piListViewDef, "OnApply: m_piListViewDef is NULL");

    if (0 == m_lCurrentIndex)
        goto Error;

    if (false == m_bSavedLastHeader)
    {
        hr = CanCreateNewHeader();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new ColumnHeader"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewHeaderState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewHeader(&piMMCColumnHeader);
        IfFailGo(hr);

        hr = ExitDoingNewHeaderState(piMMCColumnHeader);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentHeader(&piMMCColumnHeader);
        IfFailGo(hr);
    }

    hr = ApplyCurrentHeader();
    IfFailGo(hr);

    // Adjust the remove button as necessary
    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (0 == lCount)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), TRUE);

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_COLHDR_APPLY_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_ColhdrApplyFailed, 0, DontAppendErrorInfo, NULL);
    }

    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ApplyCurrentHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ApplyCurrentHeader()
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    BSTR                bstrText = NULL;
    VARIANT_BOOL        bAutoWidth = VARIANT_FALSE;
    int                 iWidth = 0;
    BSTR                bstrKey = NULL;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    // The Text property
    hr = GetDlgText(IDC_EDIT_LV_COLUMNTEXT, &bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->put_Text(bstrText);
    IfFailGo(hr);

    // The Column Width property
    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_TRUE == bAutoWidth)
    {
        hr = piMMCColumnHeader->put_Width(siColumnAutoWidth);
        IfFailGo(hr);
    }
    else
    {
        hr = GetDlgInt(IDC_EDIT_LV_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);

        hr = piMMCColumnHeader->put_Width(static_cast<short>(iWidth));
        IfFailGo(hr);
    }

    // The Key property
    hr = GetDlgText(IDC_EDIT_LV_COLUMNKEY, &bstrKey);
    IfFailGo(hr);

    if (0 == ::SysStringLen(bstrKey))
    {
        FREESTRING(bstrKey);
    }

    hr = piMMCColumnHeader->put_Key(bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrKey);
    FREESTRING(bstrText);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT     hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_LV_INSERT_COLUMN:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewHeaderState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewHeaderState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_LV_REMOVE_COLUMN:
        hr = OnRemoveColumn();
        IfFailGo(hr);
        break;

    case IDC_CHECK_LV_AUTOWIDTH:
        hr = OnAutoWidth();
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnRemoveColumn()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnRemoveColumn()
{
    HRESULT             hr = S_OK;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    VARIANT             vtKey;
    long                lCount = 0;

    ::VariantInit(&vtKey);

    hr = GetCurrentHeader(&piMMCColumnHeader);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Index(&vtKey.lVal);
    IfFailGo(hr);

    vtKey.vt = VT_I4;

    hr = m_piMMCColumnHeaders->Remove(vtKey);
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentIndex > lCount)
            m_lCurrentIndex = lCount;

        hr = ShowColumnHeader();
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentIndex = 0;

        hr = ClearHeader();
        IfFailGo(hr);

        hr = EnableEdits(false);
        IfFailGo(hr);

                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);
    }


Error:
    ::VariantClear(&vtKey);
    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnAutoWidth()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnAutoWidth()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), TRUE);

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    int              lIndex = 0;
    long             lCount = 0;

    if (false == m_bSavedLastHeader)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_LV_INDEX:
        hr = GetDlgInt(IDC_EDIT_LV_INDEX, &lIndex);
        IfFailGo(hr);

        hr = m_piMMCColumnHeaders->get_Count(&lCount);
        IfFailGo(hr);

        if (lIndex != m_lCurrentIndex)
        {
            if (lIndex >= 1)
            {
                if (lIndex > lCount)
                    m_lCurrentIndex = lCount;
                else
                    m_lCurrentIndex = lIndex;

                hr = ShowColumnHeader();
                IfFailGo(hr);
            }
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ClearHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ClearHeader()
{
    HRESULT hr = S_OK;

    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNTEXT, static_cast<BSTR>(NULL));
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNWIDTH, static_cast<BSTR>(NULL));
    IfFailGo(hr);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), TRUE);

    hr = SetCheckbox(IDC_CHECK_LV_AUTOWIDTH, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNKEY, static_cast<BSTR>(NULL));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::EnableEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::EnableEdits
(
    bool bEnable
)
{
    BOOL    fEnable = false == bEnable ? TRUE : FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNTEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNKEY), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_LV_AUTOWIDTH), (TRUE == fEnable) ? FALSE : TRUE);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ShowColumnHeader(IMMCColumnHeader *piMMCColumnHeader)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ShowColumnHeader
(
    IMMCColumnHeader *piMMCColumnHeader
)
{
    HRESULT     hr = S_OK;
    BSTR        bstrText = NULL;
    short       iWidth = 0;
    BSTR        bstrKey = NULL;

    ASSERT(NULL != piMMCColumnHeader, "InitializeIndex: piMMCColumnHeader is NULL");

    m_bSilentUpdate = true;
    hr = piMMCColumnHeader->get_Index(&m_lCurrentIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNTEXT, bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Width(static_cast<short *>(&iWidth));
    IfFailGo(hr);

    if (siColumnAutoWidth == iWidth)
    {
        hr = SetCheckbox(IDC_CHECK_LV_AUTOWIDTH, VARIANT_TRUE);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), FALSE);
    }
    else
    {
        hr = SetCheckbox(IDC_CHECK_LV_AUTOWIDTH, VARIANT_FALSE);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_COLUMNWIDTH), TRUE);

        hr = SetDlgText(IDC_EDIT_LV_COLUMNWIDTH, iWidth);
        IfFailGo(hr);
    }

    hr = piMMCColumnHeader->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_LV_COLUMNKEY, bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrText);
    FREESTRING(bstrKey);
    m_bSilentUpdate = false;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ShowColumnHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ShowColumnHeader()
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;

    ::VariantInit(&vtIndex);

    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    hr = ShowColumnHeader(piMMCColumnHeader);
    IfFailGo(hr);
Error:
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::OnDeltaPos
(
    NMUPDOWN *pNMUpDown
)
{
    HRESULT             hr = S_OK;
    long                lCount = 0;

    if (false == m_bSavedLastHeader || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentIndex < lCount)
        {
            ++m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentIndex > 1 && m_lCurrentIndex <= lCount)
        {
            --m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CanEnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::CanEnterDoingNewHeaderState()
{
    HRESULT     hr = S_FALSE;

    if (true == m_bSavedLastHeader)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::EnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::EnterDoingNewHeaderState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piMMCColumnHeaders, "EnterDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentIndex;
    hr = SetDlgText(IDC_EDIT_LV_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    // We disable the RemoveButton.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableEdits(true);
    IfFailGo(hr);

    hr = ClearHeader();
    IfFailGo(hr);

    m_bSavedLastHeader = false;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CanCreateNewHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::CanCreateNewHeader()
{
    HRESULT      hr = S_OK;
    BSTR         bstrWidth = NULL;
    VARIANT_BOOL bAutoWidth = VARIANT_FALSE;
    VARIANT      vtWidth;

    ::VariantInit(&vtWidth);

    // ColumnWidth must be a short if it is not auto-width.
    // First see if auto-width is checked.

    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    IfFalseGo(VARIANT_TRUE != bAutoWidth, S_OK);

    // Not using auto-width. Make sure that the text box contains a short.

    hr = GetDlgText(IDC_EDIT_LV_COLUMNWIDTH, &bstrWidth);
    IfFailGo(hr);

    vtWidth.vt = VT_BSTR;
    vtWidth.bstrVal = ::SysAllocString(bstrWidth);
    if (NULL == vtWidth.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = ::VariantChangeType(&vtWidth, &vtWidth, 0, VT_I2);
    if (FAILED(hr))
    {
        hr = HandleError(_T("ColumnHeaders"), _T("Column width must be an integer between 1 and 32767."));
        hr = S_FALSE;
    }

Error:
    ::VariantClear(&vtWidth);
    FREESTRING(bstrWidth);


    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::CreateNewHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{
    HRESULT              hr = S_OK;
    VARIANT              vtEmpty;
    VARIANT              vtIndex;
    VARIANT              vtKey;
    VARIANT              vtText;
    VARIANT_BOOL         bAutoWidth = VARIANT_FALSE;
    int                  iWidth = 0;
    VARIANT              vtWidth;

    ::VariantInit(&vtEmpty);
    ::VariantInit(&vtIndex);
    ::VariantInit(&vtText);
    ::VariantInit(&vtWidth);
    ::VariantInit(&vtKey);

    vtEmpty.vt = VT_ERROR;
    vtEmpty.scode = DISP_E_PARAMNOTFOUND;

    vtIndex.vt = VT_I4;
    vtIndex.scode = m_lCurrentIndex;

    vtKey.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_LV_COLUMNKEY, &vtKey.bstrVal);
    IfFailGo(hr);

    if (NULL == vtKey.bstrVal)
    {
        vtKey = vtEmpty;
    }
    else if (0 == ::SysStringLen(vtKey.bstrVal))
    {
        hr = ::VariantClear(&vtKey);
        EXCEPTION_CHECK_GO(hr);
        vtKey = vtEmpty;
    }

    vtText.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_LV_COLUMNTEXT, &vtText.bstrVal);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_CHECK_LV_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_FALSE == bAutoWidth)
    {
        hr = GetDlgInt(IDC_EDIT_LV_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);
    }
    else
    {
        iWidth = siColumnAutoWidth;
    }

    vtWidth.vt = VT_I2;
    vtWidth.iVal = static_cast<short>(iWidth);

    hr = m_piMMCColumnHeaders->Add(vtIndex, vtKey, vtText, vtWidth, vtEmpty, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtEmpty);
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtText);
    ::VariantClear(&vtWidth);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
{
    HRESULT                     hr = S_OK;

    ASSERT(m_piMMCColumnHeaders != NULL, "ExitDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    if (NULL != piMMCColumnHeader)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_LV_INDEX), TRUE);
    }
    else    // Operation was cancelled
    {
        --m_lCurrentIndex;
        if (m_lCurrentIndex > 0)
        {
            hr = ShowColumnHeader();
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_LV_REMOVE_COLUMN), TRUE);
            IfFailGo(hr);
        }
        else
        {
            hr = EnableEdits(false);
            IfFailGo(hr);

            hr = ClearHeader();
            IfFailGo(hr);
        }
    }

    m_bSavedLastHeader = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CListViewColHdrsPage::GetCurrentHeader()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CListViewColHdrsPage::GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{

    HRESULT              hr = S_OK;
    VARIANT              vtIndex;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;
    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pslistvw.h ===
//=--------------------------------------------------------------------------------------
// pslistvw.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// List View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSLISTVIEW_H_
#define _PSLISTVIEW_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~CListViewGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyListViewName();
    HRESULT ApplyDefualtViewMode();
    HRESULT ApplyVirtualList();
    HRESULT ApplyAddToViewMenu();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Other helpers
protected:
    HRESULT InitializeViewModes();
    HRESULT PopulateViewModes();
    HRESULT InitializeDefaultViewMode();

// Instance data
protected:
    IListViewDef  *m_piListViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewGeneral,                    // Name
	&CLSID_ListViewDefGeneralPP,        // Class ID
	"List View General Property Page",  // Registry display name
	CListViewGeneralPage::Create,       // Create function
	IDD_PROPPAGE_LV_GENERAL,            // Dialog resource ID
	IDS_LISTVPPG_GEN,                   // Tab caption
	IDS_LISTVPPG_GEN,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_ListViews,              // Help context ID
	FALSE                               // Thread safe
);

////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Image Lists
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewImgListsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewImgListsPage(IUnknown *pUnkOuter);
    virtual ~CListViewImgListsPage();


// Inherited from COldPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers to get attributes from component
protected:

// Helpers for Apply event
protected:
    HRESULT ApplyLargeIcon();
    HRESULT ApplySmallIcon();

// Other helpers
protected:
    HRESULT InitializeComboBoxes();

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    IListViewDef        *m_piListViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewImgLists,                       // Name
	&CLSID_ListViewDefImgLstsPP,            // Class ID
	"List View Image Lists Property Page",  // Registry display name
	CListViewImgListsPage::Create,          // Create function
	IDD_PROPPAGE_LV_IMAGELISTS,             // Dialog resource ID
	IDS_LISTVPPG_IL,                        // Tab caption
	IDS_LISTVPPG_IL,                        // Doc string
	HELP_FILENAME,                          // Help file
	HID_mssnapd_ListViews,                  // Help context ID
	FALSE                                   // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Sorting
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewSortingPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewSortingPage(IUnknown *pUnkOuter);
    virtual ~CListViewSortingPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnCBDropDown(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplySorted();
    HRESULT ApplyKey();
    HRESULT ApplySortOrder();

// Other helpers
protected:
    HRESULT PopulateKeys(IMMCColumnHeaders *piIMMCColumnHeaders);
    HRESULT InitializeKey();
    HRESULT InitializeSortOrder();
    HRESULT InitializeSortOrderArray();

// Instance data
protected:
    IListViewDef  *m_piListViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewSorting,                    // Name
	&CLSID_ListViewDefSortingPP,        // Class ID
	"List View Sorting Property Page",  // Registry display name
	CListViewSortingPage::Create,       // Create function
	IDD_PROPPAGE_LV_SORTING,            // Dialog resource ID
	IDS_LISTVPPG_SORT,                  // Tab caption
	IDS_LISTVPPG_SORT,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_ListViews,             // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// List View Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
class CListViewColHdrsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CListViewColHdrsPage(IUnknown *pUnkOuter);
    virtual ~CListViewColHdrsPage();


// Inherited from COldPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);

    HRESULT OnInsertColumn();
    HRESULT OnRemoveColumn();
    HRESULT OnAutoWidth();

// Helpers for Apply event
protected:
    HRESULT ShowColumnHeader(IMMCColumnHeader *piMMCColumnHeader);
    HRESULT ShowColumnHeader();
    HRESULT AddNewColumnHeader();
    HRESULT ApplyCurrentHeader();
    HRESULT ClearHeader();
    HRESULT GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader);

// Other helpers
protected:
    HRESULT EnableEdits(bool bEnable);

// State transitions
protected:
    HRESULT CanEnterDoingNewHeaderState();
    HRESULT EnterDoingNewHeaderState();
    HRESULT CanCreateNewHeader();
    HRESULT CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader);
    HRESULT ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader);

// Instance data
protected:
    IListViewDef        *m_piListViewDef;
    IMMCColumnHeaders   *m_piMMCColumnHeaders;
    long                 m_lCurrentIndex;
	bool			     m_bSavedLastHeader;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ListViewColHdrs,                            // Name
	&CLSID_ListViewDefColHdrsPP,                // Class ID
	"List View Column Headers Property Page",   // Registry display name
	CListViewColHdrsPage::Create,               // Create function
	IDD_PROPPAGE_LV_COLUMNS,                    // Dialog resource ID
	IDS_LISTVPPG_CH,                            // Tab caption
	IDS_LISTVPPG_CH,                            // Doc string
	HELP_FILENAME,                              // Help file
	HID_mssnapd_ListViews,                      // Help context ID
	FALSE                                       // Thread safe
);


#endif  // _PSLISTVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psmain.cpp ===
//=--------------------------------------------------------------------------------------
// psmain.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psmain.h"

#undef IMAGELIST_FIX

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Snap-In Properties"
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CSnapInGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CSnapInGeneralPage::Create(IUnknown *pUnkOuter)
{
	CSnapInGeneralPage *pNew = New CSnapInGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::CSnapInGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInGeneralPage::CSnapInGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGSNAPINGENERAL), m_piSnapInDesignerDef(0), m_piSnapInDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::~CSnapInGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInGeneralPage::~CSnapInGeneralPage()
{
    RELEASE(m_piSnapInDesignerDef);
    RELEASE(m_piSnapInDef);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_RADIO_STAND_ALONE, IDS_TT_SN_STANDALONE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_EXTENSION, IDS_TT_SN_EXTENSION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_DUAL, IDS_TT_SN_DUAL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_EXTENSIBLE, IDS_TT_SN_EXTENSIBLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_NAME, IDS_TT_SN_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_NODE_TYPE, IDS_TT_SN_TYPENAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_DISPLAY, IDS_TT_SN_DISPLAY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_PROVIDER, IDS_TT_SN_PROVIDER);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_VERSION, IDS_TT_SN_VERSION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_DESCRIPTION, IDS_TT_SN_DESCRIPTION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_VIEWS, IDS_TT_SN_DEFAULTVIEW);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IObjectModel   *piObjectModel = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrName = NULL;
    BSTR            bstrNodeTypeName = NULL;
    BSTR            bstrDisplayName = NULL;
    BSTR            bstrProvider = NULL;
    BSTR            bstrVersion = NULL;
    BSTR            bstrDescription = NULL;

    SnapInTypeConstants sitc = siStandAlone;

    if (NULL != m_piSnapInDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ISnapInDef, reinterpret_cast<void **>(&m_piSnapInDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    IfFailGo(hr);

    hr = InitializeNodeType();
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Extensible(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_EXTENSIBLE, vtBool);
    IfFailGo(hr);

    // If snap-in is extension then disable Extensible check box as there is
    // no static node that can be extensible. Also disable Static Node Type
    // Name edit box as there is no static node.

    IfFailGo(m_piSnapInDef->get_Type(&sitc));
    if (siExtension == sitc)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), FALSE);
    }

    hr = m_piSnapInDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_NodeTypeName(&bstrNodeTypeName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NODE_TYPE, bstrNodeTypeName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_DisplayName(&bstrDisplayName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_DISPLAY, bstrDisplayName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Provider(&bstrProvider);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_PROVIDER, bstrProvider);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Version(&bstrVersion);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_VERSION, bstrVersion);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Description(&bstrDescription);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_DESCRIPTION, bstrDescription);
    IfFailGo(hr);

    hr = InitializeViews();
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrDescription);
    FREESTRING(bstrVersion);
    FREESTRING(bstrProvider);
    FREESTRING(bstrDisplayName);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::InitializeNodeType()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::InitializeNodeType()
{
    HRESULT             hr = S_OK;
    SnapInTypeConstants sitc = siStandAlone;

    ASSERT(NULL != m_piSnapInDef, "InitializeNodeType: m_piSnapInDef is NULL");

    hr = m_piSnapInDef->get_Type(&sitc);
    IfFailGo(hr);

    switch (sitc)
    {
    case siStandAlone:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_RADIO_STAND_ALONE), BM_SETCHECK, 1, 0);
        break;

    case siExtension:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_RADIO_EXTENSION), BM_SETCHECK, 1, 0);
        break;

    case siDualMode:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_RADIO_DUAL), BM_SETCHECK, 1, 0);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::InitializeViews()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::InitializeViews()
{
    HRESULT     hr = S_OK;
    BSTR        bstrDefaultView = NULL;

    ASSERT(NULL != m_piSnapInDef, "InitializeViews: m_piSnapInDef is NULL");

    // First populate the combo box
    hr = PopulateViews();
    IfFailGo(hr);

    hr = m_piSnapInDef->get_DefaultView(&bstrDefaultView);
    IfFailGo(hr);

    if (::SysStringLen(bstrDefaultView) > 0)
    {
        hr = SelectCBBstr(IDC_COMBO_VIEWS, bstrDefaultView);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrDefaultView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateViews()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateViews()
{
    HRESULT           hr = S_OK;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    long              lCount = 0;

    ASSERT(NULL != m_piSnapInDef, "PopulateViews: m_piSnapInDef is NULL");

    hr = m_piSnapInDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        hr = PopulateListViews(piListViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        hr = PopulateOCXViews(piOCXViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        hr = PopulateURLViews(piURLViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        hr = PopulateTaskpadViews(piTaskpadViewDefs);
        IfFailGo(hr);
    }

    lCount = ::SendMessage(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS), CB_GETCOUNT, 0, 0);
    if (CB_ERR == lCount)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (0 == lCount)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS), FALSE);
    }

Error:
    RELEASE(piListViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateListViews(IListViewDefs *piListViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateListViews
(
    IListViewDefs *piListViewDefs
)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    VARIANT         vtIndex;
    long            lIndex = 0;
    IListViewDef   *piListViewDef = NULL;
    BSTR            bstrName = NULL;

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
        IfFailGo(hr);

        hr = piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piListViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piListViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateOCXViews(IOCXViewDefs *piOCXViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateOCXViews
(
    IOCXViewDefs *piOCXViewDefs
)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    VARIANT         vtIndex;
    long            lIndex = 0;
    IOCXViewDef    *piOCXViewDef = NULL;
    BSTR            bstrName = NULL;

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
        IfFailGo(hr);

        hr = piOCXViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piOCXViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piOCXViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateURLViews(IURLViewDefs *piURLViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateURLViews
(
    IURLViewDefs *piURLViewDefs
)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    VARIANT         vtIndex;
    long            lIndex = 0;
    IURLViewDef    *piURLViewDef = NULL;
    BSTR            bstrName = NULL;

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
        IfFailGo(hr);

        hr = piURLViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piURLViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piURLViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::PopulateTaskpadViews(ITaskpadViewDefs *piTaskpadViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::PopulateTaskpadViews
(
    ITaskpadViewDefs *piTaskpadViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    ITaskpadViewDef *piTaskpadViewDef = NULL;
    BSTR             bstrName = NULL;

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
        IfFailGo(hr);

        hr = piTaskpadViewDef->get_Key(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrName);
        IfFailGo(hr);

        RELEASE(piTaskpadViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piSnapInDef, "OnApply: m_piSnapInDef is NULL");

    hr = ApplyNodeType();
    IfFailGo(hr);

    hr = ApplyExtensible();
    IfFailGo(hr);

    hr = ApplyName();
    IfFailGo(hr);

    hr = ApplyNodeTypeName();
    IfFailGo(hr);

    hr = ApplyDisplayName();
    IfFailGo(hr);

    hr = ApplyProvider();
    IfFailGo(hr);

    hr = ApplyVersion();
    IfFailGo(hr);

    hr = ApplyDescription();
    IfFailGo(hr);

    hr = ApplyDefaultView();
    IfFailGo(hr);
/*
    hr = ApplyImageList();
    IfFailGo(hr);
*/
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyExtensible()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyExtensible()
{
    HRESULT             hr = S_OK;
    VARIANT_BOOL        vtExtensible = VARIANT_FALSE;
    VARIANT_BOOL        vtSavedExtensible = VARIANT_FALSE;
    SnapInTypeConstants Type = siStandAlone;

    ASSERT(NULL != m_piSnapInDef, "ApplyExtensible: m_piSnapInDef is NULL");

    // If the snap-in is an extension then set SnapInDef.Extensible=False
    // so that a static node type will not be registered in MMC\NodeTypes
    // in the reg db.

    hr = m_piSnapInDef->get_Type(&Type);
    IfFailGo(hr);

    if (Type == siExtension)
    {
        vtExtensible = VARIANT_FALSE;
    }
    else
    {
        hr = GetCheckbox(IDC_CHECK_EXTENSIBLE, &vtExtensible);
        IfFailGo(hr);
    }

    hr = m_piSnapInDef->get_Extensible(&vtSavedExtensible);
    IfFailGo(hr);

    if (vtSavedExtensible != vtExtensible)
    {
        hr = m_piSnapInDef->put_Extensible(vtExtensible);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyNodeType()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyNodeType()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vbChecked = VARIANT_FALSE;

    ASSERT(NULL != m_piSnapInDef, "ApplyNodeType: m_piSnapInDef is NULL");

    hr = GetCheckbox(IDC_RADIO_STAND_ALONE, &vbChecked);
    IfFailGo(hr);

    if (VARIANT_TRUE == vbChecked)
    {
        hr = m_piSnapInDef->put_Type(siStandAlone);
        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_EXTENSION, &vbChecked);
    IfFailGo(hr);

    if (VARIANT_TRUE == vbChecked)
    {
        hr = m_piSnapInDef->put_Type(siExtension);
        goto Error;
    }

    hr = m_piSnapInDef->put_Type(siDualMode);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrNodeName = NULL;
    BSTR     bstrSavedNodeName = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyName: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_NAME, &bstrNodeName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Name(&bstrSavedNodeName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrNodeName, bstrSavedNodeName))
    {
        hr = m_piSnapInDef->put_Name(bstrNodeName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedNodeName);
    FREESTRING(bstrNodeName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyNodeTypeName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyNodeTypeName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrNodeTypeName = NULL;
    SnapInTypeConstants Type = siStandAlone;

    ASSERT(NULL != m_piSnapInDef, "ApplyNodeTypeName: m_piSnapInDef is NULL");

    // If the snap-in is an extension then set SnapInDef.NodeTypeName=NULL
    // as there is no static node

    hr = m_piSnapInDef->get_Type(&Type);
    IfFailGo(hr);

    if (Type == siExtension)
    {
        IfFailGo(m_piSnapInDef->put_NodeTypeName(NULL));
    }
    else
    {        
        hr = GetDlgText(IDC_EDIT_NODE_TYPE, &bstrNodeTypeName);
        IfFailGo(hr);

        IfFailGo(m_piSnapInDef->put_NodeTypeName(bstrNodeTypeName));
    }

Error:
     FREESTRING(bstrNodeTypeName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyDisplayName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyDisplayName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrDisplayName = NULL;
    BSTR     bstrSavedDisplayName = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyDisplayName: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_DISPLAY, &bstrDisplayName);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_DisplayName(&bstrSavedDisplayName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDisplayName, bstrSavedDisplayName))
    {
        hr = m_piSnapInDef->put_DisplayName(bstrDisplayName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDisplayName);
    FREESTRING(bstrDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyProvider()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyProvider()
{
    HRESULT  hr = S_OK;
    BSTR     bstrProvider = NULL;
    BSTR     bstrSavedProvider = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyProvider: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_PROVIDER, &bstrProvider);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Provider(&bstrSavedProvider);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrProvider, bstrSavedProvider))
    {
        hr = m_piSnapInDef->put_Provider(bstrProvider);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedProvider);
    FREESTRING(bstrProvider);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyVersion()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyVersion()
{
    HRESULT  hr = S_OK;
    BSTR     bstrVersion = NULL;
    BSTR     bstrSavedVersion = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyVersion: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_VERSION, &bstrVersion);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Version(&bstrSavedVersion);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrVersion, bstrSavedVersion))
    {
        hr = m_piSnapInDef->put_Version(bstrVersion);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedVersion);
    FREESTRING(bstrVersion);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyDescription()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyDescription()
{
    HRESULT hr = S_OK;
    BSTR    bstrDescription = NULL;
    BSTR    bstrSavedDescription = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyDescription: m_piSnapInDef is NULL");

    hr = GetDlgText(IDC_EDIT_DESCRIPTION, &bstrDescription);
    IfFailGo(hr);

    hr = m_piSnapInDef->get_Description(&bstrSavedDescription);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDescription, bstrSavedDescription))
    {
        hr = m_piSnapInDef->put_Description(bstrDescription);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDescription);
    FREESTRING(bstrDescription);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyDefaultView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyDefaultView()
{
    HRESULT hr = S_OK;
    BSTR    bstrDefaultView = NULL;
    BSTR    bstrSavedDefaultView = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyDefaultView: m_piSnapInDef is NULL");

    hr = GetCBSelection(IDC_COMBO_VIEWS, &bstrDefaultView);
    IfFailGo(hr);

    if (NULL != bstrDefaultView)
    {
        hr = m_piSnapInDef->get_DefaultView(&bstrSavedDefaultView);
        IfFailGo(hr);

        if (0 != ::wcscmp(bstrDefaultView, bstrSavedDefaultView))
        {
            hr = m_piSnapInDef->put_DefaultView(bstrDefaultView);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedDefaultView);
    FREESTRING(bstrDefaultView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::ApplyImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::ApplyImageList()
{
    HRESULT             hr = S_OK;
/*
    BSTR                bstrImageList = NULL;
    IMMCImageList      *piMMCImageList = NULL;
    BSTR                bstrSavedImageList = NULL;
    IObjectModel       *piObjectModel = NULL;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;
    IMMCImageLists     *piMMCImageLists = NULL;
    long                lIndex = 0;
    VARIANT             vtIndex;

    ASSERT(NULL != m_piSnapInDef, "ApplyImageList: m_piSnapInDef is NULL");

    ::VariantInit(&vtIndex);

    hr = GetCBSelection(IDC_COMBO_IMAGELISTS, &bstrImageList);
    IfFailGo(hr);

    if (NULL != bstrImageList)
    {
#if defined(IMAGELIST_FIX)
        hr = m_piSnapInDef->get_Images(&piMMCImageList);
        IfFailGo(hr);
#endif
        if (NULL != piMMCImageList)
        {
            hr = piMMCImageList->get_Name(&bstrSavedImageList);
            IfFailGo(hr);
        }

        if (NULL == piMMCImageList || 0 != ::wcscmp(bstrImageList, bstrSavedImageList))
        {
            hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
            if (FAILED(hr))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }

            hr = piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef);
            if (FAILED(hr))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }

            hr = piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
            IfFailGo(hr);

            hr = GetCBSelectedItemData(IDC_COMBO_IMAGELISTS, &lIndex);
            IfFailGo(hr);

            RELEASE(piMMCImageList);
            vtIndex.vt = VT_I4;
            vtIndex.lVal = lIndex;
            hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
            IfFailGo(hr);

#if defined(IMAGELIST_FIX)
            hr = m_piSnapInDef->putref_Images(piMMCImageList);
            IfFailGo(hr);
#endif
        }
    }

Error:
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImageLists);
    RELEASE(piSnapInDesignerDef);
    RELEASE(piObjectModel);
    FREESTRING(bstrSavedImageList);
    RELEASE(piMMCImageList);
    FREESTRING(bstrImageList);
*/
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnEditProperty(int iDispID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnEditProperty(int iDispID)
{
    HRESULT hr = S_OK;
    SnapInTypeConstants sitc = siStandAlone;

    switch (iDispID)
    {
    case DISPID_SNAPIN_TYPE:
        hr = m_piSnapInDef->get_Type(&sitc);
        IfFailGo(hr);

        switch (sitc)
        {
        case siStandAlone:
            ::SetFocus(::GetDlgItem(m_hwnd, IDC_RADIO_STAND_ALONE));
            break;

        case siExtension:
            ::SetFocus(::GetDlgItem(m_hwnd, IDC_RADIO_EXTENSION));
            break;

        case siDualMode:
            ::SetFocus(::GetDlgItem(m_hwnd, IDC_RADIO_DUAL));
            break;
        }
        break;

    case DISPID_SNAPIN_EXTENSION_SNAPIN:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE));
        break;

    case DISPID_SNAPIN_NAME:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_NAME));
        break;

    case DISPID_SNAPIN_NODE_TYPE_NAME:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE));
        break;

    case DISPID_SNAPIN_DISPLAY_NAME:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_DISPLAY));
        break;

    case DISPID_SNAPIN_PROVIDER:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_PROVIDER));
        break;

    case DISPID_SNAPIN_VERSION:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_VERSION));
        break;

    case DISPID_SNAPIN_DESCRIPTION:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_EDIT_DESCRIPTION));
        break;

    case DISPID_SNAPIN_VIEWS:
        ::SetFocus(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS));
        break;

    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_VIEWS:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInGeneralPage::OnButtonClicked(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_RADIO_STAND_ALONE:
    case IDC_RADIO_EXTENSION:
    case IDC_RADIO_DUAL:
    case IDC_CHECK_EXTENSIBLE:
        MakeDirty();
        break;
    }

    // Enable/disable the Extensible check box if the snap-in type has changed
    // Enable/disable the Static Node Type name edit box if type has changed
    
    switch (dlgItemID)
    {
        case IDC_RADIO_STAND_ALONE:
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), TRUE);
            break;

        case IDC_RADIO_EXTENSION:
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), FALSE);
            IfFailGo(SetCheckbox(IDC_CHECK_EXTENSIBLE, VARIANT_FALSE));
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), FALSE);
            IfFailGo(SetDlgText(IDC_EDIT_NODE_TYPE, (BSTR)NULL));
            break;

        case IDC_RADIO_DUAL:
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_EXTENSIBLE), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_NODE_TYPE), TRUE);
            break;
    }    

Error:
    RRETURN(hr);
}



////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Image Lists"
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CSnapInImageListPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CSnapInImageListPage::Create(IUnknown *pUnkOuter)
{
	CSnapInImageListPage *pNew = New CSnapInImageListPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::CSnapInImageListPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInImageListPage::CSnapInImageListPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGSNAPINIL), m_piSnapInDesignerDef(0), m_piSnapInDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::~CSnapInImageListPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CSnapInImageListPage::~CSnapInImageListPage()
{
    RELEASE(m_piSnapInDesignerDef);
    RELEASE(m_piSnapInDef);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_COMBO_SMALL_FOLDERS, IDS_TT_SN_SMALL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_SMALL_OPEN_FOLDERS, IDS_TT_SN_SMALL_OPEN);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_LARGE_FOLDERS, IDS_TT_SN_LARGE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IObjectModel   *piObjectModel = NULL;

    if (NULL != m_piSnapInDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ISnapInDef, reinterpret_cast<void **>(&m_piSnapInDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    IfFailGo(hr);

    hr = InitializeImageLists();
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::InitImageComboBoxSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//

HRESULT CSnapInImageListPage::InitImageComboBoxSelection
(
    UINT           idComboBox,
    IMMCImageList *piMMCImageList
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;

    hr = piMMCImageList->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SelectCBBstr(idComboBox, bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::InitializeImageLists()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::InitializeImageLists()
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "InitializeImageLists: m_piSnapInDef is NULL");

    // First populate the combo boxes
    hr = PopulateImageLists();
    IfFailGo(hr);

    hr = m_piSnapInDef->get_SmallFolders(&piMMCImageList);
    IfFailGo(hr);

    if (NULL != piMMCImageList)
    {
        hr = InitImageComboBoxSelection(IDC_COMBO_SMALL_FOLDERS, piMMCImageList);
        IfFailGo(hr);
        RELEASE(piMMCImageList);
    }

    hr = m_piSnapInDef->get_SmallFoldersOpen(&piMMCImageList);
    IfFailGo(hr);
    if (NULL != piMMCImageList)
    {
        hr = InitImageComboBoxSelection(IDC_COMBO_SMALL_OPEN_FOLDERS, piMMCImageList);
        IfFailGo(hr);
        RELEASE(piMMCImageList);
    }

    hr = m_piSnapInDef->get_LargeFolders(&piMMCImageList);
    IfFailGo(hr);
    if (NULL != piMMCImageList)
    {
        hr = InitImageComboBoxSelection(IDC_COMBO_LARGE_FOLDERS, piMMCImageList);
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::PopulateImageLists()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::PopulateImageLists()
{
    HRESULT               hr = S_OK;
    IObjectModel         *piObjectModel = NULL;
    ISnapInDesignerDef   *piSnapInDesignerDef = NULL;
    IMMCImageLists       *piMMCImageLists = NULL;
    long                  lCount = 0;
    long                  lIndex = 1;
    VARIANT               vtIndex;
    IMMCImageList        *piMMCImageList = NULL;
    BSTR                  bstrName = NULL;

    ASSERT(NULL != m_piSnapInDef, "InitializeImageLists: m_piSnapInDef is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_SMALL_FOLDERS, bstrName, lIndex);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_SMALL_OPEN_FOLDERS, bstrName, lIndex);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_LARGE_FOLDERS, bstrName, lIndex);
        IfFailGo(hr);

        FREESTRING(bstrName);
        RELEASE(piMMCImageList);
    }

    lCount = ::SendMessage(::GetDlgItem(m_hwnd, IDC_COMBO_SMALL_FOLDERS), CB_GETCOUNT, 0, 0);
    if (CB_ERR == lCount)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    if (0 == lCount)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_SMALL_FOLDERS), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_SMALL_OPEN_FOLDERS), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_LARGE_FOLDERS), FALSE);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piMMCImageList);
    ::VariantClear(&vtIndex);
    RELEASE(piMMCImageLists);
    RELEASE(piSnapInDesignerDef);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnApply()
{
    HRESULT hr = S_OK;
    IObjectModel         *piObjectModel = NULL;
    ISnapInDesignerDef   *piSnapInDesignerDef = NULL;
    IMMCImageLists       *piMMCImageLists = NULL;

    hr = m_piSnapInDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = ApplySmallImageList(piMMCImageLists);
    IfFailGo(hr);

    hr = ApplySmallOpenImageList(piMMCImageLists);
    IfFailGo(hr);

    hr = ApplyLargeImageList(piMMCImageLists);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageLists);
    QUICK_RELEASE(piSnapInDesignerDef);
    QUICK_RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::GetImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::GetImageList
(
    UINT             idComboBox,
    IMMCImageLists  *piMMCImageLists,
    IMMCImageList  **ppiMMCImageList
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    VARIANT varIndex;

	ASSERT(NULL != piMMCImageLists, "GetImageList: piMMCImageLists is NULL");

    ::VariantInit(&varIndex);

    hr = GetCBSelection(idComboBox, &bstrName);
    IfFailGo(hr);

    if (NULL != bstrName)
    {
        varIndex.vt = VT_BSTR;
        varIndex.bstrVal = bstrName;

        hr = piMMCImageLists->get_Item(varIndex, ppiMMCImageList);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::ApplySmallImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::ApplySmallImageList
(
    IMMCImageLists *piMMCImageLists
)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplySmallImageList: m_piSnapInDef is NULL");

    hr = GetImageList(IDC_COMBO_SMALL_FOLDERS, piMMCImageLists, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piSnapInDef->putref_SmallFolders(piMMCImageList);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::ApplySmallOpenImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::ApplySmallOpenImageList
(
    IMMCImageLists *piMMCImageLists
)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplySmallOpenImageList: m_piSnapInDef is NULL");

    hr = GetImageList(IDC_COMBO_SMALL_OPEN_FOLDERS, piMMCImageLists, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piSnapInDef->putref_SmallFoldersOpen(piMMCImageList);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::ApplyLargeImageList()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::ApplyLargeImageList
(
    IMMCImageLists *piMMCImageLists
)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;

    ASSERT(NULL != m_piSnapInDef, "ApplyLargeImageList: m_piSnapInDef is NULL");

    hr = GetImageList(IDC_COMBO_LARGE_FOLDERS, piMMCImageLists, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piSnapInDef->putref_LargeFolders(piMMCImageList);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInImageListPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInImageListPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_SMALL_FOLDERS:
        MakeDirty();
        break;
    case IDC_COMBO_SMALL_OPEN_FOLDERS:
        MakeDirty();
        break;
    case IDC_COMBO_LARGE_FOLDERS:
        MakeDirty();
        break;

    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psnode.h ===
//=--------------------------------------------------------------------------------------
// psnode.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Node Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSNODE_H_
#define _PSNODE_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItemDef Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CNodeGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CNodeGeneralPage(IUnknown *pUnkOuter);
    virtual ~CNodeGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnTextChanged(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyName();
    HRESULT ApplyDisplayName();
    HRESULT ApplyFolder();
    HRESULT ApplyDefaultView();
    HRESULT ApplyAutoCreate();

// Other helpers
protected:
    HRESULT PopulateViews();

    HRESULT OnClosedChangeSelection();
    HRESULT OnOpenChangeSelection();
    HRESULT OnViewsChangeSelection();

// Instance data
protected:
    IScopeItemDef  *m_piScopeItemDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	NodeGeneral,                        // Name
	&CLSID_ScopeItemDefGeneralPP,       // Class ID
	"Scope Item General Property Page", // Registry display name
	CNodeGeneralPage::Create,           // Create function
	IDD_DIALOG_NEW_NODE,                // Dialog resource ID
	IDS_URLPPG_GEN,                     // Tab caption
	IDS_URLPPG_GEN,                     // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Node,                   // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItemDef Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
class CScopeItemDefColHdrsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CScopeItemDefColHdrsPage(IUnknown *pUnkOuter);
    virtual ~CScopeItemDefColHdrsPage();


// Inherited from COldPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnKillFocus(int dlgItemID);

    HRESULT OnRemoveColumn();
    HRESULT OnAutoWidth();

// Helpers for Apply event
protected:
    HRESULT ApplyCurrentHeader();

// Other helpers
protected:
    HRESULT ShowColumnHeader();
    HRESULT EnableEdits(bool bEnable);
    HRESULT ClearHeader();
    HRESULT GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader);

// State transitions
protected:
    HRESULT CanEnterDoingNewHeaderState();
    HRESULT EnterDoingNewHeaderState();
    HRESULT CanCreateNewHeader();
    HRESULT CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader);
    HRESULT ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader);

// Instance data
protected:
    IScopeItemDef       *m_piScopeItemDef;
    IMMCColumnHeaders   *m_piMMCColumnHeaders;
    long                 m_lCurrentIndex;
	bool			     m_bSavedLastHeader;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ScopeItemDefColHdrs,                        // Name
	&CLSID_ScopeItemDefColHdrsPP,               // Class ID
	"Scope Item Column Headers Property Page",  // Registry display name
	CScopeItemDefColHdrsPage::Create,           // Create function
	IDD_PROPPAGE_SI_COLUMNS,                    // Dialog resource ID
	IDS_NODEPPG_CH,                             // Tab caption
	IDS_NODEPPG_CH,                             // Doc string
	HELP_FILENAME,                              // Help file
	HID_mssnapd_Node,                           // Help context ID
	FALSE                                       // Thread safe
);


#endif  // _PSNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psocx.h ===
//=--------------------------------------------------------------------------------------
// psocx.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// OCX View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSOCX_H_
#define _PSOCX_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// OCX View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class COCXViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    COCXViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~COCXViewGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyOCXName();
    HRESULT ApplyProgID();
    HRESULT ApplyAddToView();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Instance data
protected:
    IOCXViewDef  *m_piOCXViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	OCXViewGeneral,                     // Name
	&CLSID_OCXViewDefGeneralPP,         // Class ID
	"OCX View General Property Page",   // Registry display name
	COCXViewGeneralPage::Create,        // Create function
	IDD_PROPPAGE_OCX_VIEW,              // Dialog resource ID
	IDS_OCXPPG_GEN,                     // Tab caption
	IDS_OCXPPG_GEN,                     // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_OCXViews,               // Help context ID
	FALSE                               // Thread safe
);

#endif  // _PSOCX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psmain.h ===
//=--------------------------------------------------------------------------------------
// psmain.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSMAIN_H_
#define _PSMAIN_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Snap-In Properties"
//
////////////////////////////////////////////////////////////////////////////////////


class CSnapInGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CSnapInGeneralPage(IUnknown *pUnkOuter);
    virtual ~CSnapInGeneralPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnEditProperty(int iDispID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyExtensible();
    HRESULT ApplyNodeType();
    HRESULT ApplyName();
    HRESULT ApplyNodeTypeName();
    HRESULT ApplyDisplayName();
    HRESULT ApplyProvider();
    HRESULT ApplyVersion();
    HRESULT ApplyDescription();
    HRESULT ApplyDefaultView();
    HRESULT ApplyImageList();

// Other helpers
protected:
    HRESULT InitializeNodeType();
    HRESULT InitializeDescription();

    HRESULT InitializeViews();
    HRESULT PopulateViews();
    HRESULT PopulateListViews(IListViewDefs *piListViewDefs);
    HRESULT PopulateOCXViews(IOCXViewDefs *piOCXViewDefs);
    HRESULT PopulateURLViews(IURLViewDefs *piURLViewDefs);
    HRESULT PopulateTaskpadViews(ITaskpadViewDefs *piTaskpadViewDefs);

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    ISnapInDef          *m_piSnapInDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	SnapInGeneral,                      // Name
	&CLSID_SnapInDefGeneralPP,          // Class ID
	"Snap-In General Property Page",    // Registry display name
	CSnapInGeneralPage::Create,         // Create function
	IDD_DIALOG_SNAPIN,                  // Dialog resource ID
	IDS_SNAPINPPG_GEN,                  // Tab caption
	IDS_SNAPINPPG_GEN,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_StaticNode,             // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// SnapIn Property Page "Image Lists"
//
////////////////////////////////////////////////////////////////////////////////////


class CSnapInImageListPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CSnapInImageListPage(IUnknown *pUnkOuter);
    virtual ~CSnapInImageListPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplySmallImageList(IMMCImageLists *piMMCImageLists);
    HRESULT ApplySmallOpenImageList(IMMCImageLists *piMMCImageLists);
    HRESULT ApplyLargeImageList(IMMCImageLists *piMMCImageLists);

// Other helpers
protected:
    HRESULT InitializeImageLists();
    HRESULT PopulateImageLists();
    HRESULT InitImageComboBoxSelection(UINT idComboBox,
                                       IMMCImageList *piMMCImageList);
    HRESULT GetImageList(UINT idComboBox, IMMCImageLists *piMMCImageLists,
                         IMMCImageList **ppiMMCImageList);

// Instance data
protected:
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
    ISnapInDef          *m_piSnapInDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	SnapInImageList,                    // Name
	&CLSID_SnapInDefImageListPP,        // Class ID
	"Snap-In Image List Property Page", // Registry display name
	CSnapInImageListPage::Create,       // Create function
	IDD_PROPPAGE_SNAPIN_IL,             // Dialog resource ID
	IDS_SNAPINPPG_IL,                   // Tab caption
	IDS_SNAPINPPG_IL,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_StaticNode,             // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psnode.cpp ===
//=--------------------------------------------------------------------------------------
// psnode.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Snap-In Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psnode.h"

// for ASSERT and FAIL
//
SZTHISFILE


const kListVw   = 0;
const kURLVw    = 1;
const kOCXVw    = 2;
const kTaskVw   = 3;


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItemDef Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CNodeGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CNodeGeneralPage::Create(IUnknown *pUnkOuter)
{
	CNodeGeneralPage *pNew = New CNodeGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::CNodeGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CNodeGeneralPage::CNodeGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGNODEGENERAL), m_piScopeItemDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::~CNodeGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CNodeGeneralPage::~CNodeGeneralPage()
{
    RELEASE(m_piScopeItemDef);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnInitializeDialog()
{
    HRESULT             hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_NODE_NAME, IDS_TT_NODE_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_NODE_DISPLAY_NAME, IDS_TT_NODE_DISPLAY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_FOLDER, IDS_TT_NODE_FOLDER);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_VIEWS, IDS_TT_NODE_DEFAULT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_AUTO_CREATE, IDS_TT_NODE_AUTOCR);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    BSTR            bstrDisplayName = NULL;
    IMMCImageList  *piMMCImageList = NULL;
    BSTR            bstrImageList = NULL;
    VARIANT         vtClosedFolder;
    VARIANT         vtOpenFolder;
    BSTR            bstrDefaultView = NULL;
	VARIANT_BOOL	vtbAutoCreate = VARIANT_FALSE;

    ::VariantInit(&vtClosedFolder);
    ::VariantInit(&vtOpenFolder);

    if (NULL != m_piScopeItemDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IScopeItemDef, reinterpret_cast<void **>(&m_piScopeItemDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Initialize the ScopeItemDef's name
    hr = m_piScopeItemDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NODE_NAME, bstrName);
    IfFailGo(hr);

    // Initialize the ScopeItemDef's display name
    hr = m_piScopeItemDef->get_DisplayName(&bstrDisplayName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_NODE_DISPLAY_NAME, bstrDisplayName);
    IfFailGo(hr);

    // Initialize the ScopeItemDef's folder
    hr = m_piScopeItemDef->get_Folder(&vtClosedFolder);
    IfFailGo(hr);

    hr = SetDlgText(vtClosedFolder, IDC_EDIT_FOLDER);
    IfFailGo(hr);

    // Initialize the ScopeItemDef's default view
    hr = PopulateViews();
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piScopeItemDef->get_DefaultView(&bstrDefaultView);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_VIEWS, bstrDefaultView);
        IfFailGo(hr);
    }
    else
    {
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_VIEWS), FALSE);
    }

	// Initialize Auto-Create
	hr = m_piScopeItemDef->get_AutoCreate(&vtbAutoCreate);
	IfFailGo(hr);

	hr = SetCheckbox(IDC_CHECK_AUTO_CREATE, vtbAutoCreate);
	IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrDefaultView);
    ::VariantClear(&vtOpenFolder);
    ::VariantClear(&vtClosedFolder);
    FREESTRING(bstrImageList);
    RELEASE(piMMCImageList);
    FREESTRING(bstrDisplayName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::PopulateViews()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::PopulateViews()
{
    HRESULT            hr = S_OK;
    bool               bGotOneIn = false;
    IViewDefs         *piViewDefs = NULL;
    IListViewDefs     *piListViewDefs = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IListViewDef      *piListViewDef = NULL;
    BSTR               bstrKey = NULL;
    IOCXViewDefs      *piOCXViewDefs = NULL;
    IOCXViewDef       *piOCXViewDef = NULL;
    IURLViewDefs      *piURLViewDefs = NULL;
    IURLViewDef       *piURLViewDef = NULL;
    ITaskpadViewDefs  *piTaskpadViewDefs = NULL;
    ITaskpadViewDef   *piTaskpadViewDef = NULL;

    ASSERT(NULL != m_piScopeItemDef, "PopulateViews: m_piScopeItemDef is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
        IfFailGo(hr);

        hr = piListViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kListVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piListViewDef);
    }

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
        IfFailGo(hr);

        hr = piOCXViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kOCXVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piOCXViewDef);
    }

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
        IfFailGo(hr);

        hr = piURLViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kURLVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piURLViewDef);
    }

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (false == bGotOneIn && lCount > 0)
        bGotOneIn = true;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
        IfFailGo(hr);

        hr = piTaskpadViewDef->get_Key(&bstrKey);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_VIEWS, bstrKey, MAKELONG(kTaskVw, static_cast<short>(lIndex)));
        IfFailGo(hr);

        FREESTRING(bstrKey);
        RELEASE(piTaskpadViewDef);
    }

    hr = (true == bGotOneIn) ? S_OK : S_FALSE;

Error:
    RELEASE(piTaskpadViewDef);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDef);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDef);
    RELEASE(piOCXViewDefs);
    FREESTRING(bstrKey);
    RELEASE(piListViewDef);
    ::VariantClear(&vtIndex);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(NULL != m_piScopeItemDef, "OnApply: m_piScopeItemDef is NULL");

    hr = ApplyName();
    IfFailGo(hr);

    hr = ApplyDisplayName();
    IfFailGo(hr);

    hr = ApplyFolder();
    IfFailGo(hr);

    hr = ApplyDefaultView();
    IfFailGo(hr);

	hr = ApplyAutoCreate();
	IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyName()
{
    HRESULT hr = S_OK;
    BSTR    bstrNodeName = NULL;
    BSTR    bstrSavedNodeName = NULL;

    ASSERT(NULL != m_piScopeItemDef, "ApplyName: m_piScopeItemDef is NULL");

    hr = GetDlgText(IDC_EDIT_NODE_NAME, &bstrNodeName);
    IfFailGo(hr);

    hr = m_piScopeItemDef->get_Name(&bstrSavedNodeName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrNodeName, bstrSavedNodeName))
    {
        hr = m_piScopeItemDef->put_Name(bstrNodeName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedNodeName);
    FREESTRING(bstrNodeName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyDisplayName
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyDisplayName()
{
    HRESULT hr = S_OK;
    BSTR    bstrDisplayName = NULL;
    BSTR    bstrSavedDisplayName = NULL;

    ASSERT(NULL != m_piScopeItemDef, "ApplyDisplayName: m_piScopeItemDef is NULL");

    hr = GetDlgText(IDC_EDIT_NODE_DISPLAY_NAME, &bstrDisplayName);
    IfFailGo(hr);

    hr = m_piScopeItemDef->get_DisplayName(&bstrSavedDisplayName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDisplayName, bstrSavedDisplayName))
    {
        hr = m_piScopeItemDef->put_DisplayName(bstrDisplayName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDisplayName);
    FREESTRING(bstrDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyFolder
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyFolder()
{
    HRESULT     hr = S_OK;
    BSTR        bstrFolder = NULL;
    VARIANT     vtFolder;

    ASSERT(NULL != m_piScopeItemDef, "ApplyFolder: m_piScopeItemDef is NULL");

    ::VariantInit(&vtFolder);

    hr = GetDlgText(IDC_EDIT_FOLDER, &bstrFolder);
    IfFailGo(hr);

    hr = m_piScopeItemDef->get_Folder(&vtFolder);
    IfFailGo(hr);

    if (VT_BSTR != vtFolder.vt || 0 != ::wcscmp(bstrFolder, vtFolder.bstrVal))
    {
        ::VariantClear(&vtFolder);
        vtFolder.vt = VT_BSTR;
        vtFolder.bstrVal = ::SysAllocString(bstrFolder);
        if (NULL == vtFolder.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = m_piScopeItemDef->put_Folder(vtFolder);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtFolder);
    FREESTRING(bstrFolder);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyDefaultView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyDefaultView()
{
    HRESULT hr = S_OK;
    BSTR    bstrDefaultView = NULL;
    BSTR    bstrSavedDefaultView = NULL;

    ASSERT(NULL != m_piScopeItemDef, "ApplyDisplayName: m_piScopeItemDef is NULL");

    hr = GetCBSelection(IDC_COMBO_VIEWS, &bstrDefaultView);
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = m_piScopeItemDef->get_DefaultView(&bstrSavedDefaultView);
        IfFailGo(hr);

        if (0 != ::wcscmp(bstrDefaultView, bstrSavedDefaultView))
        {
            hr = m_piScopeItemDef->put_DefaultView(bstrDefaultView);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedDefaultView);
    FREESTRING(bstrDefaultView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::ApplyAutoCreate()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::ApplyAutoCreate()
{
    HRESULT			hr = S_OK;
	VARIANT_BOOL	vtbAutoCreate = VARIANT_FALSE;
	VARIANT_BOOL	vtbSavedAutoCreate = VARIANT_FALSE;

    ASSERT(NULL != m_piScopeItemDef, "ApplyAutoCreate: m_piScopeItemDef is NULL");

	hr = GetCheckbox(IDC_CHECK_AUTO_CREATE, &vtbAutoCreate);
	IfFailGo(hr);

	hr = m_piScopeItemDef->get_AutoCreate(&vtbSavedAutoCreate);
	IfFailGo(hr);

	if (vtbSavedAutoCreate != vtbAutoCreate)
	{
		hr = m_piScopeItemDef->put_AutoCreate(vtbAutoCreate);
		IfFailGo(hr);
	}

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnTextChanged(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnTextChanged
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_EDIT_NODE_NAME:
    case IDC_EDIT_NODE_DISPLAY_NAME:
    case IDC_EDIT_FOLDER:
        break; 
    }

//Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_CHECK_AUTO_CREATE:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_COMBO_VIEWS:
        hr = OnViewsChangeSelection();
        IfFailGo(hr);
        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnClosedChangeSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnClosedChangeSelection()
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnOpenChangeSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnOpenChangeSelection()
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CNodeGeneralPage::OnViewsChangeSelection()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CNodeGeneralPage::OnViewsChangeSelection()
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}



////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// ScopeItem Property Page Column Headers
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CScopeItemDefColHdrsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CScopeItemDefColHdrsPage::Create(IUnknown *pUnkOuter)
{
	CScopeItemDefColHdrsPage *pNew = New CScopeItemDefColHdrsPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CScopeItemDefColHdrsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CScopeItemDefColHdrsPage::CScopeItemDefColHdrsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGNODECOLHDRS),
  m_piScopeItemDef(0), m_piMMCColumnHeaders(0), m_lCurrentIndex(0), m_bSavedLastHeader(true)
{
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::~CScopeItemDefColHdrsPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CScopeItemDefColHdrsPage::~CScopeItemDefColHdrsPage()
{
    RELEASE(m_piScopeItemDef);
    RELEASE(m_piMMCColumnHeaders);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnInitializeDialog()
{
    HRESULT           hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_SI_INDEX, IDS_TT_LV4_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_SI_COLUMNTEXT, IDS_TT_LV4_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_SI_COLUMNWIDTH, IDS_TT_LV4_WIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_SI_AUTOWIDTH, IDS_TT_LV4_AUTOWIDTH);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_SI_COLUMNKEY, IDS_TT_LV4_KEY);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnNewObjects()
{
    HRESULT           hr = S_OK;
    IUnknown         *pUnk = NULL;
    DWORD             dwDummy = 0;
    long              lCount = 0;

    if (NULL != m_piScopeItemDef)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (NULL == pUnk)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IScopeItemDef, reinterpret_cast<void **>(&m_piScopeItemDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piScopeItemDef->get_ColumnHeaders(&m_piMMCColumnHeaders);
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentIndex = 1;
        hr = ShowColumnHeader();
        IfFailGo(hr);

        EnableEdits(true);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
        EnableEdits(false);
    }

    m_bInitialized = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnApply()
{
    HRESULT              hr = S_OK;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;
    int                  disposition = 0;
    long                 lCount = 0;

    ASSERT(NULL != m_piScopeItemDef, "OnApply: m_piScopeItemDef is NULL");
    ASSERT(NULL != m_piMMCColumnHeaders, "OnApply: m_piMMCColumnHeaders is NULL");

    if (0 == m_lCurrentIndex)
        goto Error;

    if (false == m_bSavedLastHeader)
    {
        hr = CanCreateNewHeader();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new ColumnHeader"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewHeaderState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewHeader(&piMMCColumnHeader);
        IfFailGo(hr);

        hr = ExitDoingNewHeaderState(piMMCColumnHeader);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentHeader(&piMMCColumnHeader);
        IfFailGo(hr);
    }

    hr = ApplyCurrentHeader();
    IfFailGo(hr);

    // Adjust the remove button as necessary
    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (0 == lCount)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);

    m_bSavedLastHeader = true;

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_COLHDR_APPLY_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_ColhdrApplyFailed, 0, DontAppendErrorInfo, NULL);
    }

    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ApplyCurrentHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ApplyCurrentHeader()
{
    HRESULT             hr = S_OK;
    VARIANT             vtIndex;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    BSTR                bstrText = NULL;
    VARIANT_BOOL        bAutoWidth = VARIANT_FALSE;
    int                 iWidth = 0;
    BSTR                bstrKey = NULL;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    // The Text property
    hr = GetDlgText(IDC_EDIT_SI_COLUMNTEXT, &bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->put_Text(bstrText);
    IfFailGo(hr);

    // The Column Width property
    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_TRUE == bAutoWidth)
    {
        hr = piMMCColumnHeader->put_Width(siColumnAutoWidth);
        IfFailGo(hr);
    }
    else
    {
        hr = GetDlgInt(IDC_EDIT_SI_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);

        hr = piMMCColumnHeader->put_Width(static_cast<short>(iWidth));
        IfFailGo(hr);
    }

    // The Key property
    hr = GetDlgText(IDC_EDIT_SI_COLUMNKEY, &bstrKey);
    IfFailGo(hr);

    if (0 == ::SysStringLen(bstrKey))
    {
        FREESTRING(bstrKey);
    }

    hr = piMMCColumnHeader->put_Key(bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrKey);
    FREESTRING(bstrText);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT     hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_BUTTON_SI_INSERT_COLUMN:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewHeaderState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewHeaderState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_SI_REMOVE_COLUMN:
        hr = OnRemoveColumn();
        IfFailGo(hr);
        break;

    case IDC_CHECK_SI_AUTOWIDTH:
        hr = OnAutoWidth();
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnRemoveColumn()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnRemoveColumn()
{
    HRESULT             hr = S_OK;
    IMMCColumnHeader   *piMMCColumnHeader = NULL;
    VARIANT             vtKey;
    long                lCount = 0;

    ::VariantInit(&vtKey);

    hr = GetCurrentHeader(&piMMCColumnHeader);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Index(&vtKey.lVal);
    IfFailGo(hr);

    vtKey.vt = VT_I4;

    hr = m_piMMCColumnHeaders->Remove(vtKey);
    IfFailGo(hr);

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentIndex > lCount)
            m_lCurrentIndex = lCount;

        hr = ShowColumnHeader();
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentIndex = 0;

        hr = ClearHeader();
        IfFailGo(hr);

        hr = EnableEdits(false);
        IfFailGo(hr);

		::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
    }


Error:
    RELEASE(piMMCColumnHeader);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnAutoWidth()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnAutoWidth()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), TRUE);

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    int              lIndex = 0;
    long             lCount = 0;

    if (false == m_bSavedLastHeader)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_SI_INDEX:
        hr = GetDlgInt(IDC_EDIT_SI_INDEX, &lIndex);
        IfFailGo(hr);

        hr = m_piMMCColumnHeaders->get_Count(&lCount);
        IfFailGo(hr);

        if (lIndex != m_lCurrentIndex)
        {
            if (lIndex >= 1)
            {
                if (lIndex > lCount)
                    m_lCurrentIndex = lCount;
                else
                    m_lCurrentIndex = lIndex;

                hr = ShowColumnHeader();
                IfFailGo(hr);
            }
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ClearHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ClearHeader()
{
    HRESULT hr = S_OK;

    hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNTEXT, static_cast<BSTR>(NULL));
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNWIDTH, static_cast<BSTR>(NULL));
    IfFailGo(hr);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), TRUE);

    hr = SetCheckbox(IDC_CHECK_SI_AUTOWIDTH, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNKEY, static_cast<BSTR>(NULL));
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::EnableEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::EnableEdits
(
    bool bEnable
)
{
    BOOL    fEnable = false == bEnable ? TRUE : FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNTEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNKEY), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_SI_AUTOWIDTH), (TRUE == fEnable) ? FALSE : TRUE);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ShowColumnHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ShowColumnHeader()
{

    HRESULT              hr = S_OK;
    VARIANT              vtIndex;
    IMMCColumnHeader    *piMMCColumnHeader = NULL;
    BSTR                 bstrText = NULL;
    short                iWidth = 0;
    BSTR                 bstrKey = NULL;

    ASSERT(NULL != m_piMMCColumnHeaders, "ShowColumnHeader: m_piMMCColumnHeaders is NULL");

    ::VariantInit(&vtIndex);

    hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;
    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader));
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNTEXT, bstrText);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Width(&iWidth);
    IfFailGo(hr);

    if (siColumnAutoWidth == static_cast<SnapInColumnWidthConstants>(iWidth))
    {
        EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), FALSE);
        iWidth = 0;

        hr = SetCheckbox(IDC_CHECK_SI_AUTOWIDTH, VARIANT_TRUE);
        IfFailGo(hr);
    }
    else
    {
        EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_SI_COLUMNWIDTH), TRUE);

        hr = SetCheckbox(IDC_CHECK_SI_AUTOWIDTH, VARIANT_FALSE);
        IfFailGo(hr);
    }

    hr = SetDlgText(IDC_EDIT_SI_COLUMNWIDTH, iWidth);
    IfFailGo(hr);

    hr = piMMCColumnHeader->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_SI_COLUMNKEY, bstrKey);
    IfFailGo(hr);

Error:
    FREESTRING(bstrKey);
    FREESTRING(bstrText);
    RELEASE(piMMCColumnHeader);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::OnDeltaPos
(
    NMUPDOWN *pNMUpDown
)
{
    HRESULT             hr = S_OK;
    long                lCount = 0;

    if (false == m_bSavedLastHeader || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piMMCColumnHeaders->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentIndex < lCount)
        {
            ++m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentIndex > 1 && m_lCurrentIndex <= lCount)
        {
            --m_lCurrentIndex;
            hr = ShowColumnHeader();
            IfFailGo(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CanEnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::CanEnterDoingNewHeaderState()
{
    HRESULT     hr = S_FALSE;

    if (true == m_bSavedLastHeader)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::EnterDoingNewHeaderState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::EnterDoingNewHeaderState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piScopeItemDef, "EnterDoingNewHeaderState: m_piScopeItemDef is NULL");
    ASSERT(NULL != m_piMMCColumnHeaders, "EnterDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentIndex;
    hr = SetDlgText(IDC_EDIT_SI_INDEX, m_lCurrentIndex);
    IfFailGo(hr);

    // We disable the RemoveButton.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableEdits(true);
    IfFailGo(hr);

    hr = ClearHeader();
    IfFailGo(hr);

    m_bSavedLastHeader = false;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CanCreateNewHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::CanCreateNewHeader()
{
    HRESULT      hr = S_OK;
    BSTR         bstrWidth = NULL;
    VARIANT_BOOL bAutoWidth = VARIANT_FALSE;
    VARIANT      vtWidth;

    ::VariantInit(&vtWidth);

    // ColumnWidth must be a short if it is not auto-width.
    // First see if auto-width is checked.

    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    IfFalseGo(VARIANT_TRUE != bAutoWidth, S_OK);

    // Not using auto-width. Make sure that the text box contains a short.

    hr = GetDlgText(IDC_EDIT_SI_COLUMNWIDTH, &bstrWidth);
    IfFailGo(hr);

    vtWidth.vt = VT_BSTR;
    vtWidth.bstrVal = ::SysAllocString(bstrWidth);
    if (NULL == vtWidth.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = ::VariantChangeType(&vtWidth, &vtWidth, 0, VT_I2);
    if (FAILED(hr))
    {
        hr = HandleError(_T("ColumnHeaders"), _T("Column width must be an integer between 1 and 32767."));
        hr = S_FALSE;
    }

Error:
    ::VariantClear(&vtWidth);
    FREESTRING(bstrWidth);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::CreateNewHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::CreateNewHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{
    HRESULT              hr = S_OK;
    VARIANT              vtIndex;
    VARIANT              vtEmpty;
    VARIANT              vtKey;
    VARIANT              vtText;
    VARIANT_BOOL         bAutoWidth = VARIANT_FALSE;
    int                  iWidth = 0;
    VARIANT              vtWidth;

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtEmpty);
    ::VariantInit(&vtText);
    ::VariantInit(&vtWidth);
    ::VariantInit(&vtKey);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;

    vtEmpty.vt = VT_ERROR;
    vtEmpty.scode = DISP_E_PARAMNOTFOUND;

    vtKey.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_SI_COLUMNKEY, &vtKey.bstrVal);
    IfFailGo(hr);

    if (NULL == vtKey.bstrVal)
    {
        vtKey = vtEmpty;
    }
    else if (0 == ::SysStringLen(vtKey.bstrVal))
    {
        IfFailGo(::VariantClear(&vtKey));
        vtKey = vtEmpty;
    }

    vtText.vt = VT_BSTR;
    hr = GetDlgText(IDC_EDIT_SI_COLUMNTEXT, &vtText.bstrVal);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_CHECK_SI_AUTOWIDTH, &bAutoWidth);
    IfFailGo(hr);

    if (VARIANT_FALSE == bAutoWidth)
    {
        hr = GetDlgInt(IDC_EDIT_SI_COLUMNWIDTH, &iWidth);
        IfFailGo(hr);
    }
    else
    {
        iWidth = siColumnAutoWidth;
    }

    vtWidth.vt = VT_I2;
    vtWidth.iVal = static_cast<short>(iWidth);

    hr = m_piMMCColumnHeaders->Add(vtIndex, vtKey, vtText, vtWidth, vtEmpty, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtEmpty);
    ::VariantClear(&vtText);
    ::VariantClear(&vtWidth);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::ExitDoingNewHeaderState(IMMCColumnHeader *piMMCColumnHeader)
{
    HRESULT                     hr = S_OK;

    ASSERT(m_piScopeItemDef != NULL, "ExitDoingNewHeaderState: m_piScopeItemDef is NULL");
    ASSERT(m_piMMCColumnHeaders != NULL, "ExitDoingNewHeaderState: m_piMMCColumnHeaders is NULL");

    if (NULL != piMMCColumnHeader)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);
    }
    else    // Operation was cancelled
    {
        --m_lCurrentIndex;
        if (m_lCurrentIndex > 0)
        {
            hr = ShowColumnHeader();
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);
            IfFailGo(hr);
        }
        else
        {
            hr = EnableEdits(false);
            IfFailGo(hr);

            hr = ClearHeader();
            IfFailGo(hr);
        }
    }

    m_bSavedLastHeader = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CScopeItemDefColHdrsPage::GetCurrentHeader()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CScopeItemDefColHdrsPage::GetCurrentHeader(IMMCColumnHeader **ppiMMCColumnHeader)
{

    HRESULT              hr = S_OK;
    VARIANT              vtIndex;

    ::VariantInit(&vtIndex);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentIndex;
    hr = m_piMMCColumnHeaders->get_Item(vtIndex, reinterpret_cast<MMCColumnHeader **>(ppiMMCColumnHeader));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psocx.cpp ===
//=--------------------------------------------------------------------------------------
// psocx.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// OCX View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psocx.h"

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// OCX View Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *COCXViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *COCXViewGeneralPage::Create(IUnknown *pUnkOuter)
{
	COCXViewGeneralPage *pNew = New COCXViewGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::COCXViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
COCXViewGeneralPage::COCXViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGOCXVIEWGENERAL), m_piOCXViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::~COCXViewGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
COCXViewGeneralPage::~COCXViewGeneralPage()
{
    RELEASE(m_piOCXViewDef);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_OCX_NAME, IDS_TT_OCX_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_OCX_PROGID, IDS_TT_OCX_PROGID);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_OCX_ADDTOVIEWMENU, IDS_TT_OCX_ATVMENU);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_OCX_VIEWMENUTEXT, IDS_TT_OCX_VMTEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_OCX_STATUSBARTEXT, IDS_TT_OCX_SBTEXT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    BSTR            bstrProgID = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrViewMenuText = NULL;
    BSTR            bstrStatusBarText = NULL;

    if (m_piOCXViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IOCXViewDef, reinterpret_cast<void **>(&m_piOCXViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piOCXViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ProgID(&bstrProgID);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_PROGID, bstrProgID);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_AddToViewMenu(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_OCX_ADDTOVIEWMENU, vtBool);
    IfFailGo(hr);

    // Initialize the state of View Menu Text
    if (vtBool == VARIANT_FALSE)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_VIEWMENUTEXT), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_STATUSBARTEXT), FALSE);
    }

    hr = m_piOCXViewDef->get_ViewMenuText(&bstrViewMenuText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_VIEWMENUTEXT, bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_OCX_STATUSBARTEXT, bstrStatusBarText);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrViewMenuText);
    FREESTRING(bstrProgID);
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piOCXViewDef != NULL, "OnApply: m_piOCXViewDef is NULL");

    hr = ApplyOCXName();
    IfFailGo(hr);

    hr = ApplyProgID();
    IfFailGo(hr);

    hr = ApplyAddToView();
    IfFailGo(hr);

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyOCXName
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyOCXName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrOCXName = NULL;
    BSTR     bstrSavedOCXName = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_NAME, &bstrOCXName);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_Name(&bstrSavedOCXName);
    IfFailGo(hr);

    if (::wcscmp(bstrOCXName, bstrSavedOCXName) != 0)
    {
        hr = m_piOCXViewDef->put_Name(bstrOCXName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedOCXName);
    FREESTRING(bstrOCXName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyProgID
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyProgID()
{
    HRESULT  hr = S_OK;
    BSTR     bstrProgID = NULL;
    BSTR     bstrSavedProgID = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_PROGID, &bstrProgID);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ProgID(&bstrSavedProgID);
    IfFailGo(hr);

    if (::wcscmp(bstrProgID, bstrSavedProgID) != 0)
    {
        hr = m_piOCXViewDef->put_ProgID(bstrProgID);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedProgID);
    FREESTRING(bstrProgID);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyAddToView
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyAddToView()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToView = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedAddToView = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_OCX_ADDTOVIEWMENU, &vtAddToView);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_AddToViewMenu(&vtSavedAddToView);
    IfFailGo(hr);

    if (vtAddToView != vtSavedAddToView)
    {
        hr = m_piOCXViewDef->put_AddToViewMenu(vtAddToView);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyViewMenuText
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyViewMenuText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewMenuText = NULL;
    BSTR     bstrSavedViewMenuText = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_VIEWMENUTEXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (::wcscmp(bstrViewMenuText, bstrSavedViewMenuText) != 0)
    {
        hr = m_piOCXViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::ApplyStatusBarText
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::ApplyStatusBarText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrStatusBarText = NULL;
    BSTR     bstrSavedStatusBarText = NULL;

    hr = GetDlgText(IDC_EDIT_OCX_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piOCXViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (::wcscmp(bstrStatusBarText, bstrSavedStatusBarText) != 0)
    {
        hr = m_piOCXViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// COCXViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT COCXViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;

    switch (dlgItemID)
    {
    case IDC_CHECK_OCX_ADDTOVIEWMENU:
        hr = GetCheckbox(IDC_CHECK_OCX_ADDTOVIEWMENU, &vtAddToViewMenu);
        IfFailGo(hr);

        if (vtAddToViewMenu == VARIANT_TRUE)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_VIEWMENUTEXT), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_STATUSBARTEXT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_VIEWMENUTEXT), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_OCX_STATUSBARTEXT), FALSE);
        }

    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstaskp.cpp ===
//=--------------------------------------------------------------------------------------
// pstaskp.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// OCX View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "pstaskp.h"

// for ASSERT and FAIL
//
SZTHISFILE


BOOL IsValidURL(const TCHAR *pszString)
{
    if (NULL != pszString)
    {
        if (0 != ::_tcslen(pszString))
        {
            return TRUE;
        }
    }
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View General Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CTaskpadViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CTaskpadViewGeneralPage::Create(IUnknown *pUnkOuter)
{
	CTaskpadViewGeneralPage *pNew = New CTaskpadViewGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::CTaskpadViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewGeneralPage::CTaskpadViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTASKGENERAL),
m_piTaskpadViewDef(NULL),
m_piTaskpad(NULL),
m_piSnapInDesignerDef(NULL)
{
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::~CTaskpadViewGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewGeneralPage::~CTaskpadViewGeneralPage()
{
    RELEASE(m_piTaskpad);
    RELEASE(m_piTaskpadViewDef);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_TP_NAME, IDS_TT_TP_GEN_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TITLE, IDS_TT_TP_GEN_TITLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_DESCRIPTIVE_TEXT, IDS_TT_TP_GEN_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_DEFAULT, IDS_TT_TP_GEN_DEFAULT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_LISTPAD, IDS_TT_TP_GEN_LISTPAD);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_LP_TITLE, IDS_TT_TP_GEN_LIST_TI);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TP_USE_BUTTON, IDS_TT_TP_GEN_USE_BTN);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_LP_BUTTON_TEXT, IDS_TT_TP_GEN_BTN_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_CUSTOM, IDS_TT_TP_GEN_CUSTOM);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_URL, IDS_TT_TP_GEN_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TP_USER_PREFERRED, IDS_TT_TP_GEN_PREFERRED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TP_ADD_TO_VIEW, IDS_TT_TP_GEN_ADDTOVW);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_VIEW_MENUTXT, IDS_TT_TP_GEN_VWMNTEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_TP_LISTVIEW, IDS_TT_TP_GEN_LISTVIEW);
    IfFailGo(hr);

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), FALSE);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnNewObjects()
{
    HRESULT                    hr = S_OK;
    IUnknown                  *pUnk = NULL;
    IObjectModel              *piObjectModel = NULL;
    DWORD                      dwDummy = 0;
    BSTR                       bstrName = NULL;
    BSTR                       bstrTitle = NULL;
    BSTR                       bstrText = NULL;
    SnapInTaskpadTypeConstants sittc = Default;
    BSTR                       bstrListpadTitle = NULL;
    VARIANT_BOOL               bHasButton = VARIANT_FALSE;
    BSTR                       bstrButtonText = NULL;
    BSTR                       bstrURL = NULL;
    VARIANT_BOOL               bUsePreferred = VARIANT_FALSE;
    VARIANT_BOOL               bAddToView = VARIANT_FALSE;
    BSTR                       bstrViewMenuText = NULL;
    BSTR                       bstrStatusBarText = NULL;

    if (m_piTaskpadViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&m_piTaskpadViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpadViewDef->get_Taskpad(&m_piTaskpad);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Title(&bstrTitle);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TITLE, bstrTitle);
    IfFailGo(hr);

    hr = m_piTaskpad->get_DescriptiveText(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_DESCRIPTIVE_TEXT, bstrText);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Type(&sittc);
    IfFailGo(hr);

    switch (sittc)
    {
    case Default:
        hr = SetCheckbox(IDC_RADIO_TP_DEFAULT, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case Listpad:
        hr = SetCheckbox(IDC_RADIO_TP_LISTPAD, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_ListpadTitle(&bstrListpadTitle);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_LP_TITLE, bstrListpadTitle);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), TRUE);
        hr = m_piTaskpad->get_ListpadHasButton(&bHasButton);
        IfFailGo(hr);

        hr = SetCheckbox(IDC_CHECK_TP_USE_BUTTON, bHasButton);
        IfFailGo(hr);

        if (VARIANT_TRUE == bHasButton)
        {
            ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
            hr = m_piTaskpad->get_ListpadButtonText(&bstrButtonText);
            IfFailGo(hr);

            hr = SetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, bstrButtonText);
            IfFailGo(hr);
        }

        IfFailGo(PopulateListViewCombo());

        break;

    case Custom:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        hr = SetCheckbox(IDC_RADIO_TP_CUSTOM, VARIANT_TRUE);
        IfFailGo(hr);

        hr = m_piTaskpad->get_URL(&bstrURL);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_URL, bstrURL);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_URL), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        break;
    }

    hr = m_piTaskpadViewDef->get_UseWhenTaskpadViewPreferred(&bUsePreferred);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TP_USER_PREFERRED, bUsePreferred);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_AddToViewMenu(&bAddToView);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TP_ADD_TO_VIEW, bAddToView);
    IfFailGo(hr);

    if (VARIANT_TRUE == bAddToView)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        hr = m_piTaskpadViewDef->get_ViewMenuText(&bstrViewMenuText);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_VIEW_MENUTXT, bstrViewMenuText);
        IfFailGo(hr);

        hr = m_piTaskpadViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_STATUSBARTEXT, bstrStatusBarText);
        IfFailGo(hr);
    }

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrViewMenuText);
    FREESTRING(bstrURL);
    FREESTRING(bstrButtonText);
    FREESTRING(bstrListpadTitle);
    FREESTRING(bstrText);
    FREESTRING(bstrTitle);
    FREESTRING(bstrName);
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::PopulateListViewCombo()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::PopulateListViewCombo()
{
    HRESULT        hr = S_OK;
    BSTR           bstrListView = NULL;
    IViewDefs     *piViewDefs = NULL;
    IListViewDefs *piListViewDefs = NULL;
    IListViewDef  *piListViewDef = NULL;
    long           cListViewDefs = 0;
    long           i = 0;
    long           iListView = 0;
    BSTR           bstrNextListView = NULL;
    BOOL           fFoundListView = FALSE;

    VARIANT varKey;
    ::VariantInit(&varKey);

    IfFailGo(m_piTaskpad->get_ListView(&bstrListView));
    if (NULL != bstrListView)
    {
        if (0 == ::wcslen(bstrListView))
        {
            // Zero length string is the same as none at all
            FREESTRING(bstrListView);
        }
    }

    // Get the ListViewDefs collection

    IfFailGo(m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(piListViewDefs->get_Count(&cListViewDefs));

        // If there is anything in it then enable the combobox and populate it

    if (cListViewDefs > 0)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), TRUE);
    }

    varKey.vt = VT_I4;;

    for (i = 1L; i <= cListViewDefs; i++)
    {
        varKey.lVal = i;
        IfFailGo(piListViewDefs->get_Item(varKey, &piListViewDef));
        IfFailGo(piListViewDef->get_Name(&bstrNextListView));
        if (NULL != bstrListView)
        {
            if (0 == ::wcscmp(bstrListView, bstrNextListView))
            {
                iListView = i - 1L;
                fFoundListView = TRUE;
            }
        }
        IfFailGo(AddCBBstr(IDC_COMBO_TP_LISTVIEW, bstrNextListView, 0));
        RELEASE(piListViewDef);
    }

    // If there is a Taskpad.ListView and we didn't find it then reset
    // the property to NULL

    if ( (NULL != bstrListView) && (!fFoundListView) )
    {
        IfFailGo(m_piTaskpad->put_ListView(NULL));
    }

    // If Taskpad.ListView was found then select it

    if (fFoundListView)
    {
        if (CB_ERR == ::SendDlgItemMessage(m_hwnd,
                                           IDC_COMBO_TP_LISTVIEW,
                                           CB_SETCURSEL,
                                           static_cast<WPARAM>(iListView), 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else if (cListViewDefs > 0)
    {
        // Make sure that the first item is visible

        if (CB_ERR == ::SendDlgItemMessage(m_hwnd,
                                           IDC_COMBO_TP_LISTVIEW,
                                           CB_SETTOPINDEX,
                                           static_cast<WPARAM>(iListView), 0))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }


Error:
    FREESTRING(bstrListView);
    FREESTRING(bstrNextListView);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    RRETURN(hr);
}



HRESULT CTaskpadViewGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch (dlgItemID)
    {
        case IDC_COMBO_TP_LISTVIEW:
            MakeDirty();
            break;
    }

    RRETURN(hr);
}



//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piTaskpadViewDef != NULL, "OnApply: m_piTaskpadViewDef is NULL");

	hr = CanApply();
	IfFailGo(hr);

	if (S_OK == hr)
	{
		hr = ApplyName();
		IfFailGo(hr);

		hr = ApplyTitle();
		IfFailGo(hr);

		hr = ApplyDescription();
		IfFailGo(hr);

		hr = ApplyType();
		IfFailGo(hr);

		hr = ApplyViewMenu();
		IfFailGo(hr);
	}

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::CanApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::CanApply()
{
    HRESULT         hr = S_OK;
	BSTR            bstrViewName = NULL;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    BSTR            bstrButtonText = NULL;
    BSTR            bstrURL = NULL;
    TCHAR          *pszURL = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "CanApply: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "CanApply: m_piTaskpad is NULL");

	// Name must not be empty
    hr = GetDlgText(IDC_EDIT_TP_NAME, &bstrViewName);
    IfFailGo(hr);

	if (NULL == bstrViewName || 0 == ::SysStringLen(bstrViewName))
	{
        HandleError(_T("Apply Taskpad"), _T("Taskpad must have a name"));
        hr = E_INVALIDARG;
        goto Error;
	}

    // Check type consistency
    hr = GetCheckbox(IDC_RADIO_TP_LISTPAD, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetCheckbox(IDC_CHECK_TP_USE_BUTTON, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = GetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, &bstrButtonText);
            IfFailGo(hr);

	        if (NULL == bstrButtonText || 0 == ::SysStringLen(bstrButtonText))
	        {
                HandleError(_T("Apply Taskpad"), _T("Button text cannot be empty"));
                hr = E_INVALIDARG;
                goto Error;
            }
        }
    }

    hr = GetCheckbox(IDC_RADIO_TP_CUSTOM, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TP_URL, &bstrURL);
        IfFailGo(hr);

	    if (NULL == bstrURL || 0 == ::SysStringLen(bstrURL))
	    {
            HandleError(_T("Apply Taskpad"), _T("URL cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
        }

        hr = ANSIFromBSTR(bstrURL, &pszURL);
        IfFailGo(hr);

        if (false == IsValidURL(pszURL))
        {
            HandleError(_T("Apply Taskpad"), _T("URL must have \'res://\' format"));
            hr = E_INVALIDARG;
            goto Error;
        }
    }

Error:
    if (NULL != pszURL)
        CtlFree(pszURL);
    FREESTRING(bstrURL);
    FREESTRING(bstrButtonText);
	FREESTRING(bstrViewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewName = NULL;
    BSTR     bstrSavedViewName = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyName: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyName: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_NAME, &bstrViewName);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Name(&bstrSavedViewName);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrViewName, bstrSavedViewName))
    {
        hr = m_piTaskpadViewDef->put_Key(bstrViewName);
        IfFailGo(hr);

        hr = m_piTaskpadViewDef->put_Name(bstrViewName);
        IfFailGo(hr);

        hr = m_piTaskpad->put_Name(bstrViewName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewName);
    FREESTRING(bstrViewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyTitle()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyTitle()
{
    HRESULT  hr = S_OK;
    BSTR     bstrTitle = NULL;
    BSTR     bstrSavedTitle = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyTitle: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyTitle: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TITLE, &bstrTitle);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Title(&bstrSavedTitle);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrTitle, bstrSavedTitle))
    {
        hr = m_piTaskpad->put_Title(bstrTitle);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedTitle);
    FREESTRING(bstrTitle);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyDescription()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyDescription()
{
    HRESULT  hr = S_OK;
    BSTR     bstrDescription = NULL;
    BSTR     bstrSavedDescription = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyDescription: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyDescription: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_DESCRIPTIVE_TEXT, &bstrDescription);
    IfFailGo(hr);

    hr = m_piTaskpad->get_DescriptiveText(&bstrSavedDescription);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrDescription, bstrSavedDescription))
    {
        hr = m_piTaskpad->put_DescriptiveText(bstrDescription);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedDescription);
    FREESTRING(bstrDescription);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyType()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyType()
{
    HRESULT  hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    SnapInTaskpadTypeConstants  sittc = Default;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyType: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyType: m_piTaskpad is NULL");

    hr = GetCheckbox(IDC_RADIO_TP_DEFAULT, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = m_piTaskpad->put_Type(Default);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_LISTPAD, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = m_piTaskpad->put_Type(Listpad);
        IfFailGo(hr);

        hr = ApplyListpad();
        IfFailGo(hr);
        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_CUSTOM, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = m_piTaskpad->put_Type(Custom);
        IfFailGo(hr);

        hr = ApplyCustom();
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyListpad()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyListpad()
{
    HRESULT         hr = S_OK;
    BSTR            bstrListpadTitle = NULL;
    BSTR            bstrSavedListpadTitle = NULL;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    VARIANT_BOOL    bSavedValue = VARIANT_FALSE;
    BSTR            bstrButtonText = NULL;
    BSTR            bstrSavedButtonText = NULL;
    BSTR            bstrSavedListView = NULL;
    BSTR            bstrListView = NULL;
    long            iSelectedListView = 0;
    BOOL            fUpdateListView = FALSE;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyListpad: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyListpad: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_LP_TITLE, &bstrListpadTitle);
    IfFailGo(hr);

    hr = m_piTaskpad->get_ListpadTitle(&bstrSavedListpadTitle);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrListpadTitle, bstrSavedListpadTitle))
    {
        hr = m_piTaskpad->put_ListpadTitle(bstrListpadTitle);
        IfFailGo(hr);
    }

    hr = GetCheckbox(IDC_CHECK_TP_USE_BUTTON, &bValue);
    IfFailGo(hr);

    hr = m_piTaskpad->get_ListpadHasButton(&bSavedValue);
    IfFailGo(hr);

    if (bValue != bSavedValue)
    {
        hr = m_piTaskpad->put_ListpadHasButton(bValue);
        IfFailGo(hr);
    }

    hr = GetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, &bstrButtonText);
    IfFailGo(hr);

    hr = m_piTaskpad->get_ListpadButtonText(&bstrSavedButtonText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrButtonText, bstrSavedButtonText))
    {
        hr = m_piTaskpad->put_ListpadButtonText(bstrButtonText);
        IfFailGo(hr);
    }

    // Get the current value of Taskpad.ListView

    IfFailGo(m_piTaskpad->get_ListView(&bstrSavedListView));

    // Check if something is selected in the combobox
    
    iSelectedListView = ::SendDlgItemMessage(m_hwnd,
                                             IDC_COMBO_TP_LISTVIEW,
                                             CB_GETCURSEL, 0, 0);
    if (CB_ERR != iSelectedListView)
    {
        // Something is selected. Get its text.
        
        IfFailGo(GetDlgText(IDC_COMBO_TP_LISTVIEW, &bstrListView));
    }

    // If the selection changed then update Taskpad.ListView
    // If nothing is selected then bstrListView will be NULL and the property
    // will be set to NULL.

    // If there is a current Taskpad.ListView and the user selected something
    // then compare them. If different then update Taskpad.ListView.

    if ( (NULL != bstrListView) && (NULL != bstrSavedListView) )
    {
        if (0 != ::wcscmp(bstrListView, bstrSavedListView))
        {
            fUpdateListView = TRUE;
        }
    }
    else if ( (NULL == bstrListView) && (NULL != bstrSavedListView) )
    {
        // The user did not select anything but there is a current
        // Taskpad.ListView. Need to set Taskpad.ListView to NULL.

        fUpdateListView = TRUE;
    }
    else if (NULL != bstrListView)
    {
        // The is no current Taskpad.ListView and the user has now selected one.

        fUpdateListView = TRUE;
    }

    if (fUpdateListView)
    {
        IfFailGo(m_piTaskpad->put_ListView(bstrListView));
    }

Error:
    FREESTRING(bstrSavedListView);
    FREESTRING(bstrListView);
    FREESTRING(bstrSavedButtonText);
    FREESTRING(bstrButtonText);
    FREESTRING(bstrSavedListpadTitle);
    FREESTRING(bstrListpadTitle);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyCustom()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyCustom()
{
    HRESULT         hr = S_OK;
    BSTR            bstrURL = NULL;
    BSTR            bstrSavedURL = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyCustom: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyCustom: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_URL, &bstrURL);
    IfFailGo(hr);

    hr = m_piTaskpad->get_URL(&bstrSavedURL);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrURL, bstrSavedURL))
    {
        hr = m_piTaskpad->put_URL(bstrURL);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURL);
    FREESTRING(bstrURL);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyViewMenu()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyViewMenu()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    VARIANT_BOOL    bSavedValue = VARIANT_FALSE;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyViewMenu: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyViewMenu: m_piTaskpad is NULL");

    hr = GetCheckbox(IDC_CHECK_TP_USER_PREFERRED, &bValue);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_UseWhenTaskpadViewPreferred(&bSavedValue);
    IfFailGo(hr);

    if (bValue != bSavedValue)
    {
        hr = m_piTaskpadViewDef->put_UseWhenTaskpadViewPreferred(bValue);
        IfFailGo(hr);
    }

    hr = GetCheckbox(IDC_CHECK_TP_ADD_TO_VIEW, &bValue);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_AddToViewMenu(&bSavedValue);
    IfFailGo(hr);

    if (bValue != bSavedValue)
    {
        hr = m_piTaskpadViewDef->put_AddToViewMenu(bValue);
        IfFailGo(hr);
    }

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyViewMenuText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyViewMenuText()
{
    HRESULT         hr = S_OK;
    BSTR            bstrViewMenuText = NULL;
    BSTR            bstrSavedViewMenuText = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyListpad: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyListpad: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_VIEW_MENUTXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrViewMenuText, bstrSavedViewMenuText))
    {
        hr = m_piTaskpadViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::ApplyStatusBarText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::ApplyStatusBarText()
{
    HRESULT         hr = S_OK;
    BSTR            bstrStatusBarText = NULL;
    BSTR            bstrSavedStatusBarText = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyStatusBarText: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyStatusBarText: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piTaskpadViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrStatusBarText, bstrSavedStatusBarText))
    {
        hr = m_piTaskpadViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_RADIO_TP_DEFAULT:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_TITLE, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_TITLE, (BSTR)NULL));

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), FALSE);
        IfFailGo(SetCheckbox(IDC_CHECK_TP_USE_BUTTON, VARIANT_FALSE));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_URL, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_URL, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_COMBO_TP_LISTVIEW, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), FALSE);
        break;

    case IDC_RADIO_TP_LISTPAD:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_TITLE, EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), TRUE);

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_URL, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_URL, (BSTR)NULL));
        
        IfFailGo(PopulateListViewCombo());
        hr = OnUseButton();
        IfFailGo(hr);
        break;

    case IDC_RADIO_TP_CUSTOM:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TITLE), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_TITLE, (BSTR)NULL));

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_DESCRIPTIVE_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_DESCRIPTIVE_TEXT, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_TITLE, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_TITLE, (BSTR)NULL));

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TP_USE_BUTTON), FALSE);
        IfFailGo(SetCheckbox(IDC_CHECK_TP_USE_BUTTON, VARIANT_FALSE));
        
        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT, EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_LP_BUTTON_TEXT, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_EDIT_TP_URL, EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        IfFailGo(SetDlgText(IDC_EDIT_TP_URL, (BSTR)NULL));

        ::SendDlgItemMessage(m_hwnd, IDC_COMBO_TP_LISTVIEW, CB_RESETCONTENT, 0, 0);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TP_LISTVIEW), FALSE);
        break;

    case IDC_CHECK_TP_USE_BUTTON:
        hr = OnUseButton();
        IfFailGo(hr);
        break;

    case IDC_CHECK_TP_ADD_TO_VIEW:
        hr = OnAddToView();
        IfFailGo(hr);
        break;
    }

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnUseButton()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnUseButton()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bSet = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_TP_USE_BUTTON, &bSet);
    IfFailGo(hr);

    if (VARIANT_TRUE == bSet)
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    else
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_LP_BUTTON_TEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewGeneralPage::OnAddToView(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewGeneralPage::OnAddToView()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bSet = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_TP_ADD_TO_VIEW, &bSet);
    IfFailGo(hr);

    if (VARIANT_TRUE == bSet)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_VIEW_MENUTXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_STATUSBARTEXT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    }

Error:
    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Background Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CTaskpadViewBackgroundPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CTaskpadViewBackgroundPage::Create(IUnknown *pUnkOuter)
{
	CTaskpadViewBackgroundPage *pNew = New CTaskpadViewBackgroundPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::CTaskpadViewBackgroundPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewBackgroundPage::CTaskpadViewBackgroundPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTASKBACKGR), m_piTaskpadViewDef(0), m_piTaskpad(0)
{
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::~CTaskpadViewBackgroundPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewBackgroundPage::~CTaskpadViewBackgroundPage()
{
    RELEASE(m_piTaskpad);
    RELEASE(m_piTaskpadViewDef);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_RADIO_TP_NONE, IDS_TT_TP_BK_NONE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_BITMAP, IDS_TT_TP_BK_BITMAP);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_MOUSE_OVER, IDS_TT_TP_BK_MOUSE_OVR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_VANILLA, IDS_TT_TP_BK_VANILLA);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_CHOCOLATE, IDS_TT_TP_BK_CHOCOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_SYMBOL, IDS_TT_TP_BK_SYMBOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_FONT_FAMILY, IDS_TT_TP_BK_FFNAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_EOT, IDS_TT_TP_BK_EOT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_SYMBOL_STRING, IDS_TT_TP_BK_SYM_STR);
    IfFailGo(hr);

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnNewObjects()
{
    HRESULT                         hr = S_OK;
    IUnknown                       *pUnk = NULL;
    DWORD                           dwDummy = 0;
    SnapInTaskpadImageTypeConstants sititc = siNoImage;
    BSTR                            bstrMouseOverImage = NULL;
    BSTR                            bstrFontFamily = NULL;
    BSTR                            bstrEOTFile = NULL;
    BSTR                            bstrSymbolString = NULL;

    if (m_piTaskpadViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&m_piTaskpadViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpadViewDef->get_Taskpad(&m_piTaskpad);
    IfFailGo(hr);

    hr = m_piTaskpad->get_BackgroundType(&sititc);
    IfFailGo(hr);

    switch (sititc)
    {
    case siNoImage:
        hr = SetCheckbox(IDC_RADIO_TP_NONE, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siSymbol:
        hr = SetCheckbox(IDC_RADIO_TP_SYMBOL, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        hr = m_piTaskpad->get_FontFamily(&bstrFontFamily);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_FONT_FAMILY, bstrFontFamily);
        IfFailGo(hr);

        hr = m_piTaskpad->get_EOTFile(&bstrEOTFile);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_EOT, bstrEOTFile);
        IfFailGo(hr);

        hr = m_piTaskpad->get_SymbolString(&bstrSymbolString);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_SYMBOL_STRING, bstrSymbolString);
        IfFailGo(hr);
        break;

    case siVanillaGIF:
        hr = SetCheckbox(IDC_RADIO_TP_VANILLA, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_MouseOverImage(&bstrMouseOverImage);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_MOUSE_OVER, bstrMouseOverImage);
        IfFailGo(hr);
        break;

    case siChocolateGIF:
        hr = SetCheckbox(IDC_RADIO_TP_CHOCOLATE, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_MouseOverImage(&bstrMouseOverImage);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_MOUSE_OVER, bstrMouseOverImage);
        IfFailGo(hr);
        break;

    case siBitmap:
        hr = SetCheckbox(IDC_RADIO_TP_BITMAP, VARIANT_TRUE);
        IfFailGo(hr);

        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        hr = m_piTaskpad->get_MouseOverImage(&bstrMouseOverImage);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_MOUSE_OVER, bstrMouseOverImage);
        IfFailGo(hr);
        break;
    }

    m_bInitialized = true;

Error:
    FREESTRING(bstrSymbolString);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    FREESTRING(bstrMouseOverImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnApply()
{
    HRESULT             hr = S_OK;
    VARIANT_BOOL        bValue = VARIANT_FALSE;

    ASSERT(NULL != m_piTaskpadViewDef, "OnApply: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "OnApply: m_piTaskpad is NULL");

    hr = CanApply();
    IfFailGo(hr);

    if (S_OK == hr)
    {
        hr = GetCheckbox(IDC_RADIO_TP_NONE, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siNoImage);
            IfFailGo(hr);

            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_BITMAP, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siBitmap);
            IfFailGo(hr);

            hr = ApplyMouseOverImage();
            IfFailGo(hr);
            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_VANILLA, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siVanillaGIF);
            IfFailGo(hr);

            hr = ApplyMouseOverImage();
            IfFailGo(hr);
            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_CHOCOLATE, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siChocolateGIF);
            IfFailGo(hr);

            hr = ApplyMouseOverImage();
            IfFailGo(hr);
            goto Error;
        }

        hr = GetCheckbox(IDC_RADIO_TP_SYMBOL, &bValue);
        IfFailGo(hr);

        if (VARIANT_TRUE == bValue)
        {
            hr = m_piTaskpad->put_BackgroundType(siSymbol);
            IfFailGo(hr);

            hr = ApplyFontFamily();
            IfFailGo(hr);

            hr = ApplyEOTFile();
            IfFailGo(hr);

            hr = ApplySymbolString();
            IfFailGo(hr);
            goto Error;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::CanApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::CanApply()
{
    HRESULT             hr = S_OK;
    VARIANT_BOOL        bBitmap = VARIANT_FALSE;
    VARIANT_BOOL        bVanilla = VARIANT_FALSE;
    VARIANT_BOOL        bChocolate = VARIANT_FALSE;
    BSTR                bstrMouseOverImage = NULL;
    TCHAR              *pszMouseOver = NULL;
    VARIANT_BOOL        bSymbol = VARIANT_FALSE;
    BSTR                bstrFontFamily = NULL;
    BSTR                bstrEOTFile = NULL;
    TCHAR              *pszEOTFile = NULL;
    BSTR                bstrSymbolString = NULL;

    // Check type consistency
    hr = GetCheckbox(IDC_RADIO_TP_BITMAP, &bBitmap);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_RADIO_TP_VANILLA, &bVanilla);
    IfFailGo(hr);

    hr = GetCheckbox(IDC_RADIO_TP_CHOCOLATE, &bChocolate);
    IfFailGo(hr);

    if (VARIANT_TRUE == bBitmap || VARIANT_TRUE == bVanilla || VARIANT_TRUE == bChocolate)
    {
        hr = GetDlgText(IDC_EDIT_TP_MOUSE_OVER, &bstrMouseOverImage);
        IfFailGo(hr);

	    if (NULL == bstrMouseOverImage || 0 == ::SysStringLen(bstrMouseOverImage))
	    {
            HandleError(_T("Apply Taskpad"), _T("Mouse over image cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }

        hr = ANSIFromBSTR(bstrMouseOverImage, &pszMouseOver);
        IfFailGo(hr);

        if (false == IsValidURL(pszMouseOver))
        {
            HandleError(_T("Apply Taskpad"), _T("Mouse over image must have \'res://\' format"));
            hr = E_INVALIDARG;
            goto Error;
        }
    }

    // Check if symbol
    hr = GetCheckbox(IDC_RADIO_TP_SYMBOL, &bSymbol);
    IfFailGo(hr);

    if (VARIANT_TRUE == bSymbol)
    {
        hr = GetDlgText(IDC_EDIT_TP_FONT_FAMILY, &bstrFontFamily);
        IfFailGo(hr);

	    if (NULL == bstrFontFamily || 0 == ::SysStringLen(bstrFontFamily))
	    {
            HandleError(_T("Apply Taskpad"), _T("Font family cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }

        hr = GetDlgText(IDC_EDIT_TP_EOT, &bstrEOTFile);
        IfFailGo(hr);

	    if (NULL == bstrEOTFile || 0 == ::SysStringLen(bstrEOTFile))
	    {
            HandleError(_T("Apply Taskpad"), _T("EOT file cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }

        hr = ANSIFromBSTR(bstrEOTFile, &pszEOTFile);
        IfFailGo(hr);

        if (false == IsValidURL(pszEOTFile))
        {
            HandleError(_T("Apply Taskpad"), _T("EOT file must have \'res://\' format"));
            hr = E_INVALIDARG;
            goto Error;
        }

        hr = GetDlgText(IDC_EDIT_TP_SYMBOL_STRING, &bstrSymbolString);
        IfFailGo(hr);

	    if (NULL == bstrSymbolString || 0 == ::SysStringLen(bstrSymbolString))
	    {
            HandleError(_T("Apply Taskpad"), _T("Symbol string cannot be empty"));
            hr = E_INVALIDARG;
            goto Error;
	    }
    }

Error:
    FREESTRING(bstrSymbolString);
    if (NULL != pszEOTFile)
        CtlFree(pszEOTFile);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    if (NULL != pszMouseOver)
        CtlFree(pszMouseOver);
    FREESTRING(bstrMouseOverImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplyMouseOverImage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplyMouseOverImage()
{
    HRESULT     hr = S_OK;
    BSTR        bstrMouseOverImage = NULL;
    BSTR        bstrSavedMouseOverImage = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyMouseOverImage: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyMouseOverImage: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_MOUSE_OVER, &bstrMouseOverImage);
    IfFailGo(hr);

    hr = m_piTaskpad->get_MouseOverImage(&bstrSavedMouseOverImage);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrMouseOverImage, bstrSavedMouseOverImage))
    {
        hr = m_piTaskpad->put_MouseOverImage(bstrMouseOverImage);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedMouseOverImage);
    FREESTRING(bstrMouseOverImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplyFontFamily()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplyFontFamily()
{
    HRESULT     hr = S_OK;
    BSTR        bstrFontFamily = NULL;
    BSTR        bstrSavedFontFamily = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyFontFamily: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyFontFamily: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_FONT_FAMILY, &bstrFontFamily);
    IfFailGo(hr);

    hr = m_piTaskpad->get_FontFamily(&bstrSavedFontFamily);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrFontFamily, bstrSavedFontFamily))
    {
        hr = m_piTaskpad->put_FontFamily(bstrFontFamily);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedFontFamily);
    FREESTRING(bstrFontFamily);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplyEOTFile()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplyEOTFile()
{
    HRESULT     hr = S_OK;
    BSTR        bstrEOTFile = NULL;
    BSTR        bstrSavedEOTFile = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplyEOTFile: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplyEOTFile: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_EOT, &bstrEOTFile);
    IfFailGo(hr);

    hr = m_piTaskpad->get_EOTFile(&bstrSavedEOTFile);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrEOTFile, bstrSavedEOTFile))
    {
        hr = m_piTaskpad->put_EOTFile(bstrEOTFile);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedEOTFile);
    FREESTRING(bstrEOTFile);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::ApplySymbolString()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::ApplySymbolString()
{
    HRESULT     hr = S_OK;
    BSTR        bstrSymbolString = NULL;
    BSTR        bstrSavedSymbolString = NULL;

    ASSERT(NULL != m_piTaskpadViewDef, "ApplySymbolString: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "ApplySymbolString: m_piTaskpad is NULL");

    hr = GetDlgText(IDC_EDIT_TP_SYMBOL_STRING, &bstrSymbolString);
    IfFailGo(hr);

    hr = m_piTaskpad->get_SymbolString(&bstrSavedSymbolString);
    IfFailGo(hr);

    if (0 != ::wcscmp(bstrSymbolString, bstrSavedSymbolString))
    {
        hr = m_piTaskpad->put_SymbolString(bstrSymbolString);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedSymbolString);
    FREESTRING(bstrSymbolString);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewBackgroundPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewBackgroundPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;

    switch (dlgItemID)
    {
    case IDC_RADIO_TP_NONE:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_BITMAP:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_VANILLA:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_CHOCOLATE:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_SYMBOL:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        break;
    }

    MakeDirty();

//Error:
    RRETURN(hr);
}




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Tasks Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CTaskpadViewTasksPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CTaskpadViewTasksPage::Create(IUnknown *pUnkOuter)
{
	CTaskpadViewTasksPage *pNew = New CTaskpadViewTasksPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CTaskpadViewTasksPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewTasksPage::CTaskpadViewTasksPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTASKTASKS), m_piTaskpadViewDef(0), m_piTaskpad(0), m_lCurrentTask(0), m_bSavedLastTask(true)
{
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::~CTaskpadViewTasksPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CTaskpadViewTasksPage::~CTaskpadViewTasksPage()
{
    RELEASE(m_piTaskpad);
    RELEASE(m_piTaskpadViewDef);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_INDEX, IDS_TT_TP_TSK_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_KEY, IDS_TT_TP_TSK_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_TEXT, IDS_TT_TP_TSK_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_HELP_STRING, IDS_TT_TP_TSK_HELP);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_TASK_NOTIFY, IDS_TT_TP_TSK_NOTIFY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_TASK_URL, IDS_TT_TP_TSK_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TP_TASK_SCRIPT, IDS_TT_TP_TSK_SCRIPT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_URL, IDS_TT_TP_TSK_U_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TP_TASK_SCRIPT, IDS_TT_TP_TSK_S_SCRIPT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_VANILLA, IDS_TT_TP_TSK_VANILLA);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_CHOCOLATE, IDS_TT_TP_TSK_CHOCOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_BITMAP, IDS_TT_TP_TSK_BITMAP);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_RADIO_TPT_SYMBOL, IDS_TT_TP_TSK_SYMBOL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_MOUSE_OVER, IDS_TT_TP_TSK_MOUSE_OVR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_MOUSE_OFF, IDS_TT_TP_TSK_MOUSE_OFF);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_FONT_FAMILY, IDS_TT_TP_TSK_FFNAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_EOT, IDS_TT_TP_TSK_EOT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TPT_SYMBOL_STRING, IDS_TT_TP_TSK_SYM_STR);
    IfFailGo(hr);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), FALSE);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    ITasks         *piTasks = NULL;
    long            lCount = 0;
    VARIANT         vtVariant;
    ITask          *piTask = NULL;

    ::VariantInit(&vtVariant);

    if (m_piTaskpadViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_ITaskpadViewDef, reinterpret_cast<void **>(&m_piTaskpadViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpadViewDef->get_Taskpad(&m_piTaskpad);
    IfFailGo(hr);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentTask = 1;
        vtVariant.vt = VT_I4;
        vtVariant.lVal = m_lCurrentTask;

        hr = piTasks->get_Item(vtVariant, reinterpret_cast<Task **>(&piTask));
        IfFailGo(hr);

        hr = ShowTask(piTask);
        IfFailGo(hr);

        hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
        IfFailGo(hr);

        hr = EnableEdits(true);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), TRUE);
    }
    else
    {
        hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
        IfFailGo(hr);

        hr = EnableEdits(false);
        IfFailGo(hr);
    }

    m_bInitialized = true;

Error:
    RELEASE(piTask);
    ::VariantClear(&vtVariant);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnApply()
{
    HRESULT      hr = S_OK;
    int          disposition = 0;
    ITasks      *piTasks = NULL;
    long         lCount = 0;
    ITask       *piTask = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "OnApply: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "OnApply: m_piTaskpad is NULL");

    if (0 == m_lCurrentTask)
        goto Error;

    if (false == m_bSavedLastTask)
    {
        hr = CanCreateNewTask();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new Task"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewTaskState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewTask(&piTask);
        IfFailGo(hr);

        hr = ExitDoingNewTaskState(piTask);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentTask(&piTask);
        IfFailGo(hr);
    }

    hr = ApplyCurrentTask();
    IfFailGo(hr);

    // Adjust the remove button as necessary
    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

    if (0 == lCount)
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), FALSE);
    else
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_SI_REMOVE_COLUMN), TRUE);

    m_bSavedLastTask = true;

Error:
    RELEASE(piTask);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyCurrentTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyCurrentTask()
{
    HRESULT                         hr = S_OK;
    ITasks                         *piTasks = NULL;
    VARIANT                         vtIndex;
    ITask                          *piTask = NULL;
    SnapInActionTypeConstants       sictc = siNotify;
    SnapInTaskpadImageTypeConstants sititc = siNoImage;

    ASSERT(m_piTaskpadViewDef != NULL, "ApplyCurrentTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ApplyCurrentTask: m_piTaskpad is NULL");

    ::VariantInit(&vtIndex);

    hr = CanApply();
    IfFailGo(hr);

    if (S_FALSE == hr) {
        hr = E_INVALIDARG;
        goto Error;
    }

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentTask;
    hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(&piTask));
    IfFailGo(hr);

    hr = ApplyKey(piTask);
    IfFailGo(hr);

    hr = ApplyText(piTask);
    IfFailGo(hr);

    hr = ApplyHelpString(piTask);
    IfFailGo(hr);

	hr = ApplyTag(piTask);
	IfFailGo(hr);

    hr = ApplyActionType(piTask);
    IfFailGo(hr);

    hr = piTask->get_ActionType(&sictc);
    IfFailGo(hr);

    switch (sictc)
    {
    case siNotify:
        hr = piTask->put_URL(NULL);
        IfFailGo(hr);

        hr = piTask->put_Script(NULL);
        IfFailGo(hr);
        break;

    case siURL:
        hr = ApplyURL(piTask);
        IfFailGo(hr);

        hr = piTask->put_Script(NULL);
        IfFailGo(hr);
        break;

    case siScript:
        hr = ApplyScript(piTask);
        IfFailGo(hr);

        hr = piTask->put_URL(NULL);
        IfFailGo(hr);
        break;
    }

    hr = ApplyImageType(piTask);
    IfFailGo(hr);

    hr = piTask->get_ImageType(&sititc);
    IfFailGo(hr);

    switch (sititc)
    {
    case siSymbol:
        hr = ApplyFontFamilyName(piTask);
        IfFailGo(hr);

        hr = ApplyEOTFile(piTask);
        IfFailGo(hr);

        hr = ApplySymbolString(piTask);
        IfFailGo(hr);

        hr = piTask->put_MouseOverImage(NULL);
        hr = piTask->put_MouseOffImage(NULL);
        break;

    case siVanillaGIF:
    case siChocolateGIF:
    case siBitmap:
        hr = ApplyMouseOverImage(piTask);
        IfFailGo(hr);

        hr = ApplyMouseOffImage(piTask);
        IfFailGo(hr);

        hr = piTask->put_FontFamily(NULL);
        hr = piTask->put_EOTFile(NULL);
        hr = piTask->put_SymbolString(NULL);
        break;
    }


Error:
    RELEASE(piTask);
    ::VariantClear(&vtIndex);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyKey(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyKey(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrKey = NULL;
    BSTR         bstrSavedKey = NULL;

    ASSERT(piTask != NULL, "ApplyKey: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL == bstrKey || 0 == ::SysStringLen(bstrKey))
    {
        hr = piTask->put_Key(NULL);
        IfFailGo(hr);
    }
    else
    {
        hr = piTask->get_Key(&bstrSavedKey);
        IfFailGo(hr);

        if (NULL == bstrSavedKey || 0 != ::wcscmp(bstrSavedKey, bstrKey))
        {
            hr = piTask->put_Key(bstrKey);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedKey);
    FREESTRING(bstrKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyText(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyText(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrText = NULL;
    BSTR         bstrSavedText = NULL;

    ASSERT(piTask != NULL, "ApplyText: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    hr = piTask->get_Text(&bstrSavedText);
    IfFailGo(hr);

    if (NULL == bstrSavedText || 0 != ::wcscmp(bstrSavedText, bstrText))
    {
        hr = piTask->put_Text(bstrText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedText);
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyHelpString(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyHelpString(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrHelpString = NULL;
    BSTR         bstrSavedHelpString = NULL;

    ASSERT(piTask != NULL, "ApplyHelpString: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, &bstrHelpString);
    IfFailGo(hr);

    hr = piTask->get_HelpString(&bstrSavedHelpString);
    IfFailGo(hr);

    if (NULL == bstrSavedHelpString || 0 != ::wcscmp(bstrSavedHelpString, bstrHelpString))
    {
        hr = piTask->put_HelpString(bstrHelpString);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedHelpString);
    FREESTRING(bstrHelpString);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyTag(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyTag(ITask *piTask)
{
    HRESULT      hr = S_OK;
    VARIANT      vtTag;

    ASSERT(piTask != NULL, "ApplyTag: piTask is NULL");

	::VariantInit(&vtTag);

    hr = GetDlgVariant(IDC_EDIT_TP_TASK_TAG, &vtTag);
    IfFailGo(hr);

	if (VT_EMPTY != vtTag.vt)
	{
		hr = piTask->put_Tag(vtTag);
		IfFailGo(hr);
	}

Error:
	::VariantClear(&vtTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyActionType(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyActionType(ITask *piTask)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bVal = VARIANT_FALSE;

    ASSERT(piTask != NULL, "ApplyActionType: piTask is NULL");

    hr = GetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ActionType(siNotify);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_TASK_URL, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ActionType(siURL);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ActionType(siScript);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyURL(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyURL(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrURL = NULL;
    BSTR         bstrSavedURL = NULL;

    ASSERT(piTask != NULL, "ApplyURL: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_URL, &bstrURL);
    IfFailGo(hr);

    hr = piTask->get_URL(&bstrSavedURL);
    IfFailGo(hr);

    if (NULL == bstrSavedURL || 0 != ::wcscmp(bstrURL, bstrSavedURL))
    {
        hr = piTask->put_URL(bstrURL);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURL);
    FREESTRING(bstrURL);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyScript(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyScript(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrScript = NULL;
    BSTR         bstrSavedScript = NULL;

    ASSERT(piTask != NULL, "ApplyScript: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TP_TASK_SCRIPT, &bstrScript);
    IfFailGo(hr);

    hr = piTask->get_Script(&bstrSavedScript);
    IfFailGo(hr);

    if (NULL == bstrSavedScript || 0 != ::wcscmp(bstrScript, bstrSavedScript))
    {
        hr = piTask->put_Script(bstrScript);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedScript);
    FREESTRING(bstrScript);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyImageType(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyImageType(ITask *piTask)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bVal = VARIANT_FALSE;

    ASSERT(piTask != NULL, "ApplyImageType: piTask is NULL");

    hr = GetCheckbox(IDC_RADIO_TPT_VANILLA, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siVanillaGIF);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TPT_CHOCOLATE, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siChocolateGIF);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TPT_BITMAP, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siBitmap);
        IfFailGo(hr);

        goto Error;
    }

    hr = GetCheckbox(IDC_RADIO_TPT_SYMBOL, &bVal);
    IfFailGo(hr);

    if (VARIANT_TRUE == bVal)
    {
        hr = piTask->put_ImageType(siSymbol);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyMouseOverImage(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyMouseOverImage(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrMouseOver = NULL;
    BSTR         bstrSavedMouseOver = NULL;

    ASSERT(piTask != NULL, "ApplyMouseOverImage: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OVER, &bstrMouseOver);
    IfFailGo(hr);

    hr = piTask->get_MouseOverImage(&bstrSavedMouseOver);
    IfFailGo(hr);

    if (NULL == bstrSavedMouseOver || 0 != ::wcscmp(bstrMouseOver, bstrSavedMouseOver))
    {
        hr = piTask->put_MouseOverImage(bstrMouseOver);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedMouseOver);
    FREESTRING(bstrMouseOver);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyMouseOffImage(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyMouseOffImage(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrMouseOff = NULL;
    BSTR         bstrSavedMouseOff = NULL;

    ASSERT(piTask != NULL, "ApplyMouseOffImage: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OFF, &bstrMouseOff);
    IfFailGo(hr);

    hr = piTask->get_MouseOffImage(&bstrSavedMouseOff);
    IfFailGo(hr);

    if (NULL == bstrSavedMouseOff || 0 != ::wcscmp(bstrMouseOff, bstrSavedMouseOff))
    {
        hr = piTask->put_MouseOffImage(bstrMouseOff);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedMouseOff);
    FREESTRING(bstrMouseOff);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyFontFamilyName(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyFontFamilyName(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrFontFamily = NULL;
    BSTR         bstrSavedFontFamily = NULL;

    ASSERT(piTask != NULL, "ApplyFontFamilyName: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_FONT_FAMILY, &bstrFontFamily);
    IfFailGo(hr);

    hr = piTask->get_FontFamily(&bstrSavedFontFamily);
    IfFailGo(hr);

    if (NULL == bstrSavedFontFamily || 0 != ::wcscmp(bstrFontFamily, bstrSavedFontFamily))
    {
        hr = piTask->put_FontFamily(bstrFontFamily);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedFontFamily);
    FREESTRING(bstrFontFamily);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplyEOTFile(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplyEOTFile(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrEOTFile = NULL;
    BSTR         bstrSavedEOTFile = NULL;

    ASSERT(piTask != NULL, "ApplyEOTFile: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_EOT, &bstrEOTFile);
    IfFailGo(hr);

    hr = piTask->get_EOTFile(&bstrSavedEOTFile);
    IfFailGo(hr);

    if (NULL == bstrSavedEOTFile || 0 != ::wcscmp(bstrEOTFile, bstrSavedEOTFile))
    {
        hr = piTask->put_EOTFile(bstrEOTFile);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedEOTFile);
    FREESTRING(bstrEOTFile);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ApplySymbolString(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ApplySymbolString(ITask *piTask)
{
    HRESULT      hr = S_OK;
    BSTR         bstrSymbolString = NULL;
    BSTR         bstrSavedSymbolString = NULL;

    ASSERT(piTask != NULL, "ApplySymbolString: piTask is NULL");

    hr = GetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, &bstrSymbolString);
    IfFailGo(hr);

    hr = piTask->get_SymbolString(&bstrSavedSymbolString);
    IfFailGo(hr);

    if (NULL == bstrSavedSymbolString || 0 != ::wcscmp(bstrSymbolString, bstrSavedSymbolString))
    {
        hr = piTask->put_SymbolString(bstrSymbolString);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedSymbolString);
    FREESTRING(bstrSymbolString);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrNull = NULL;

    switch (dlgItemID)
    {
    case IDC_BUTTON_TP_INSERT_TASK:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewTaskState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewTaskState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_TP_REMOVE_TASK:
		hr = OnRemoveTask();
		IfFailGo(hr);
        break;

    case IDC_RADIO_TP_TASK_NOTIFY:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_TASK_URL:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        break;

    case IDC_RADIO_TP_TASK_SCRIPT:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        break;

    case IDC_RADIO_TPT_VANILLA:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        if (siSymbol == m_lastImageType)
        {
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
        }
        m_lastImageType = siVanillaGIF;
        break;

    case IDC_RADIO_TPT_CHOCOLATE:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        if (siSymbol == m_lastImageType)
        {
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
        }
        m_lastImageType = siChocolateGIF;
        break;

    case IDC_RADIO_TPT_BITMAP:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

        if (siSymbol == m_lastImageType)
        {
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
            hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
        }
        m_lastImageType = siBitmap;
        break;

    case IDC_RADIO_TPT_SYMBOL:
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

        hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
        hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);

        m_lastImageType = siSymbol;
        break;
    }

    MakeDirty();

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnRemoveTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnRemoveTask()
{
    HRESULT         hr = S_OK;
    ITasks         *piTasks = NULL;
	VARIANT			vtIndex;
	ITask		   *piTask = NULL;
    long            lCount = 0;

    ASSERT(NULL != m_piTaskpadViewDef, "OnRemoveTask: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "OnRemoveTask: m_piTaskpad is NULL");

	::VariantInit(&vtIndex);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

	vtIndex.vt = VT_I4;
	vtIndex.lVal = m_lCurrentTask;
	hr = piTasks->Remove(vtIndex);
	IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

	if (lCount > 0)
	{
        if (m_lCurrentTask > lCount)
            m_lCurrentTask = lCount;

		hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
		IfFailGo(hr);

		vtIndex.vt = VT_I4;
		vtIndex.lVal = m_lCurrentTask;
		hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(&piTask));
		IfFailGo(hr);

		hr = ShowTask(piTask);
		IfFailGo(hr);
	}
	else
	{
		m_lCurrentTask = 0;
		hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
		IfFailGo(hr);

		hr = ClearTask();
		IfFailGo(hr);

		hr = EnableEdits(false);
		IfFailGo(hr);
	}

Error:
	RELEASE(piTask);
	::VariantClear(&vtIndex);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    ITasks          *piTasks = NULL;
    int              lIndex = 0;
    long             lCount = 0;

    if (false == m_bSavedLastTask)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_TP_TASK_INDEX:
        hr = GetDlgInt(IDC_EDIT_TP_TASK_INDEX, &lIndex);
        IfFailGo(hr);

        hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
        IfFailGo(hr);

        hr = piTasks->get_Count(&lCount);
        IfFailGo(hr);

        if (lIndex != m_lCurrentTask)
        {
            if (lIndex >= 1)
            {
                if (lIndex > lCount)
                    m_lCurrentTask = lCount;
                else
                    m_lCurrentTask = lIndex;

                hr = ShowTask();
                IfFailGo(hr);
            }
        }
        break;
    }

Error:
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ClearTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ClearTask()
{
    HRESULT                         hr = S_OK;
    BSTR                            bstrNull = NULL;

    hr = SetDlgText(IDC_EDIT_TP_TASK_KEY, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_TEXT, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_TAG, bstrNull);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_URL, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_SCRIPT, bstrNull);
    IfFailGo(hr);

    //
    hr = SetCheckbox(IDC_RADIO_TPT_VANILLA, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TPT_CHOCOLATE, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TPT_BITMAP, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_RADIO_TPT_SYMBOL, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

    hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrNull);
    IfFailGo(hr);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::EnableEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::EnableEdits
(
    bool bEnable
)
{
    HRESULT         hr = S_OK;
    BOOL            fEnable = (true == bEnable) ? FALSE : TRUE;
    VARIANT_BOOL    bValue = VARIANT_FALSE;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_KEY), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_TEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_HELP_STRING), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_TAG), EM_SETREADONLY, static_cast<WPARAM>(fEnable), 0);

    GetCheckbox(IDC_RADIO_TP_TASK_URL, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_URL), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    }

    GetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
    }
    else
    {
        ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TP_TASK_SCRIPT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
    }

    if (true == bEnable)
    {
		GetCheckbox(IDC_RADIO_TPT_SYMBOL, &bValue);
		IfFailGo(hr);

		if (VARIANT_TRUE == bValue)
		{
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
		}
		else
		{
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(FALSE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
			::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		}
	}
	else
	{
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OVER), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_MOUSE_OFF), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_FONT_FAMILY), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_EOT), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
		::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TPT_SYMBOL_STRING), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);
	}

    if (false == bEnable)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_NOTIFY), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_URL), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_SCRIPT), FALSE);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_VANILLA), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_CHOCOLATE), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_BITMAP), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_SYMBOL), FALSE);
    }
    else
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_NOTIFY), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_URL), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TP_TASK_SCRIPT), TRUE);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_VANILLA), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_CHOCOLATE), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_BITMAP), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_RADIO_TPT_SYMBOL), TRUE);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ShowTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ShowTask()
{
    HRESULT     hr = S_OK;
    ITasks     *piTasks = NULL;
    VARIANT     vtIndex;
    ITask      *piTask = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "ShowTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ShowTask: m_piTaskpad is NULL");

    ::VariantInit(&vtIndex);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentTask;

    hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(&piTask));
    IfFailGo(hr);

    hr = ShowTask(piTask);
    IfFailGo(hr);

Error:
    RELEASE(piTask);
    RELEASE(piTasks);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ShowTask(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ShowTask
(
    ITask *piTask
)
{
    HRESULT                         hr = S_OK;
    BSTR                            bstrKey = NULL;
    BSTR                            bstrText = NULL;
    BSTR                            bstrHelpString = NULL;
	VARIANT							vtTag;
    SnapInActionTypeConstants       siatc = siNotify;
    SnapInTaskpadImageTypeConstants sititc = siNoImage;
    BSTR                            bstrURL = NULL;
    BSTR                            bstrScript = NULL;
    BSTR                            bstrMouseOver = NULL;
    BSTR                            bstrMouseOff = NULL;
    BSTR                            bstrFontFamily = NULL;
    BSTR                            bstrEOTFile = NULL;
    BSTR                            bstrSymbolString = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "ShowTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ShowTask: m_piTaskpad is NULL");

	::VariantInit(&vtTag);

    hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
    IfFailGo(hr);

    hr = piTask->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_KEY, bstrKey);
    IfFailGo(hr);

    hr = piTask->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_TEXT, bstrText);
    IfFailGo(hr);

    hr = piTask->get_HelpString(&bstrHelpString);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, bstrHelpString);
    IfFailGo(hr);

    hr = piTask->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TP_TASK_TAG);
    IfFailGo(hr);

    hr = piTask->get_ActionType(&siatc);
    IfFailGo(hr);

    switch (siatc)
    {
    case siNotify:
        hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_TRUE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_FALSE);
        IfFailGo(hr);
        break;

    case siURL:
        hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_TRUE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_FALSE);
        IfFailGo(hr);
        break;

    case siScript:
        hr = SetCheckbox(IDC_RADIO_TP_TASK_NOTIFY, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_URL, VARIANT_FALSE);
        hr = SetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, VARIANT_TRUE);
        IfFailGo(hr);
        break;
    }

    hr = piTask->get_URL(&bstrURL);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_URL, bstrURL);
    IfFailGo(hr);

    hr = piTask->get_Script(&bstrScript);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TP_TASK_SCRIPT, bstrScript);
    IfFailGo(hr);

    hr = piTask->get_ImageType(&sititc);
    IfFailGo(hr);

    m_lastImageType = sititc;

    hr = SetCheckbox(IDC_RADIO_TPT_VANILLA, VARIANT_FALSE);
    hr = SetCheckbox(IDC_RADIO_TPT_CHOCOLATE, VARIANT_FALSE);
    hr = SetCheckbox(IDC_RADIO_TPT_BITMAP, VARIANT_FALSE);
    hr = SetCheckbox(IDC_RADIO_TPT_SYMBOL, VARIANT_FALSE);

    switch (sititc)
    {
    case siVanillaGIF:
        hr = SetCheckbox(IDC_RADIO_TPT_VANILLA, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siChocolateGIF:
        hr = SetCheckbox(IDC_RADIO_TPT_CHOCOLATE, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siBitmap:
        hr = SetCheckbox(IDC_RADIO_TPT_BITMAP, VARIANT_TRUE);
        IfFailGo(hr);
        break;

    case siSymbol:
        hr = SetCheckbox(IDC_RADIO_TPT_SYMBOL, VARIANT_TRUE);
        IfFailGo(hr);
        break;
    }

    hr = piTask->get_MouseOverImage(&bstrMouseOver);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OVER, bstrMouseOver);
    IfFailGo(hr);

    hr = piTask->get_MouseOffImage(&bstrMouseOff);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_MOUSE_OFF, bstrMouseOff);
    IfFailGo(hr);

    hr = piTask->get_FontFamily(&bstrFontFamily);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_FONT_FAMILY, bstrFontFamily);
    IfFailGo(hr);

    hr = piTask->get_EOTFile(&bstrEOTFile);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_EOT, bstrEOTFile);
    IfFailGo(hr);

    hr = piTask->get_SymbolString(&bstrSymbolString);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, bstrSymbolString);
    IfFailGo(hr);

    hr = EnableEdits(true);
    IfFailGo(hr);

Error:
    FREESTRING(bstrSymbolString);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    FREESTRING(bstrMouseOff);
    FREESTRING(bstrMouseOver);
    FREESTRING(bstrScript);
    FREESTRING(bstrURL);
	::VariantClear(&vtTag);
    FREESTRING(bstrHelpString);
    FREESTRING(bstrText);
    FREESTRING(bstrKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT       hr = S_OK;
    ITasks       *piTasks = NULL;
    long          lCount = 0;

    ASSERT(NULL != m_piTaskpadViewDef, "OnButtonDeltaPos: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "OnButtonDeltaPos: m_piTaskpad is NULL");

    if (false == m_bSavedLastTask || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentTask < lCount)
        {
            ++m_lCurrentTask;
            hr = ShowTask();
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentTask > 1 && m_lCurrentTask <= lCount)
        {
            --m_lCurrentTask;
            hr = ShowTask();
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CanEnterDoingNewTaskState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CanEnterDoingNewTaskState()
{
    HRESULT     hr = S_FALSE;

    if (true == m_bSavedLastTask)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::EnterDoingNewTaskState()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::EnterDoingNewTaskState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piTaskpadViewDef, "EnterDoingNewTaskState: m_piTaskpadViewDef is NULL");
    ASSERT(NULL != m_piTaskpad, "EnterDoingNewTaskState: m_piTaskpad is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentTask;
    hr = SetDlgText(IDC_EDIT_TP_TASK_INDEX, m_lCurrentTask);
    IfFailGo(hr);

    // We disable the RemoveButton.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableEdits(true);
    IfFailGo(hr);

    hr = ClearTask();
    IfFailGo(hr);

    m_lastImageType = siBitmap;
    m_bSavedLastTask = false;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CanCreateNewTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CanCreateNewTask()
{
    HRESULT      hr = S_OK;
    BSTR         bstrText = NULL;

    // Got to have some text
    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    if (NULL == bstrText || 0 == ::SysStringLen(bstrText))
    {
        HandleError(_T("Cannot Create New Task"), _T("Task must have some text"));
        hr = S_FALSE;
        goto Error;
    }

Error:
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CanApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CanApply()
{
    HRESULT         hr = S_OK;
    BSTR            bstrText = NULL;
    BSTR            bstrHelpString = NULL;
    VARIANT_BOOL    bValue = VARIANT_FALSE;
    BSTR            bstrURL  = NULL;
    BSTR            bstrScript = NULL;
    BSTR            bstrMouseOver = NULL;
    bool            bMouseOverEmpty = false;
    BSTR            bstrMouseOff = NULL;
    bool            bMouseOffEmpty = false;
    TCHAR          *pszMouseOver = NULL;
    TCHAR          *pszMouseOff = NULL;
    BSTR            bstrFontFamily = NULL;
    BSTR            bstrEOTFile = NULL;
    TCHAR          *pszEOTFile = NULL;
    BSTR            bstrSymbolString = NULL;

    // Got to have some text
    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    if (NULL == bstrText || 0 == ::SysStringLen(bstrText))
    {
        HandleError(_T("Apply Taskpad"), _T("Task must have some text"));
        hr = S_FALSE;
        goto Error;
    }

    // Got to have a help string
    hr = GetDlgText(IDC_EDIT_TP_TASK_HELP_STRING, &bstrHelpString);
    IfFailGo(hr);

    if (NULL == bstrHelpString || 0 == ::SysStringLen(bstrHelpString))
    {
        HandleError(_T("Apply Taskpad"), _T("Task must have a help string"));
        hr = S_FALSE;
        goto Error;
    }

    // Check URL consistency
    hr = GetCheckbox(IDC_RADIO_TP_TASK_URL, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TP_TASK_URL, &bstrURL);
        IfFailGo(hr);

        if (NULL == bstrURL || 0 == ::SysStringLen(bstrURL))
        {
            HandleError(_T("Apply Taskpad"), _T("URL cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }
    }

    // Check Script consistency
    hr = GetCheckbox(IDC_RADIO_TP_TASK_SCRIPT, &bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TP_TASK_SCRIPT, &bstrScript);
        IfFailGo(hr);

        if (NULL == bstrScript || 0 == ::SysStringLen(bstrScript))
        {
            HandleError(_T("Apply Taskpad"), _T("Script name cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }
    }

    // If we're not a symbol, certain restrictions apply
    hr = GetCheckbox(IDC_RADIO_TPT_SYMBOL, &bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
    {
        hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OVER, &bstrMouseOver);
        IfFailGo(hr);

        if (NULL == bstrMouseOver || 0 == ::SysStringLen(bstrMouseOver))
            bMouseOverEmpty = true;

        hr = GetDlgText(IDC_EDIT_TPT_MOUSE_OFF, &bstrMouseOff);
        IfFailGo(hr);

        if (NULL == bstrMouseOff || 0 == ::SysStringLen(bstrMouseOff))
            bMouseOffEmpty = true;

        if (true == bMouseOverEmpty && true == bMouseOffEmpty)
        {
            HandleError(_T("Apply Taskpad"), _T("Mouse over and mouse off cannot both be empty"));
            hr = S_FALSE;
            goto Error;
        }

        if (false == bMouseOverEmpty)
        {
            hr = ANSIFromBSTR(bstrMouseOver, &pszMouseOver);
            IfFailGo(hr);

            if (false == IsValidURL(pszMouseOver))
            {
                HandleError(_T("Apply Taskpad"), _T("Mouse over must have \'res://\' format"));
                hr = S_FALSE;
                goto Error;
            }
        }

        if (false == bMouseOffEmpty)
        {
            hr = ANSIFromBSTR(bstrMouseOff, &pszMouseOff);
            IfFailGo(hr);

            if (false == IsValidURL(pszMouseOff))
            {
                HandleError(_T("Apply Taskpad"), _T("Mouse off must have \'res://\' format"));
                hr = S_FALSE;
                goto Error;
            }
        }

    }
    // And if we ARE a symbol, then other restrictions apply
    else
    {
        hr = GetDlgText(IDC_EDIT_TPT_FONT_FAMILY, &bstrFontFamily);
        IfFailGo(hr);

        if (NULL == bstrFontFamily || 0 == ::SysStringLen(bstrFontFamily))
        {
            HandleError(_T("Apply Taskpad"), _T("Font family cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }

        hr = GetDlgText(IDC_EDIT_TPT_EOT, &bstrEOTFile);
        IfFailGo(hr);

        if (NULL == bstrEOTFile || 0 == ::SysStringLen(bstrEOTFile))
        {
            HandleError(_T("Apply Taskpad"), _T("EOT file cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }

        hr = ANSIFromBSTR(bstrEOTFile, &pszEOTFile);
        IfFailGo(hr);

        if (false == IsValidURL(pszEOTFile))
        {
            HandleError(_T("Apply Taskpad"), _T("EOT file must have \'res://\' format"));
            hr = S_FALSE;
            goto Error;
        }

        hr = GetDlgText(IDC_EDIT_TPT_SYMBOL_STRING, &bstrSymbolString);
        IfFailGo(hr);

        if (NULL == bstrSymbolString || 0 == ::SysStringLen(bstrSymbolString))
        {
            HandleError(_T("Apply Taskpad"), _T("Symbol string cannot be empty"));
            hr = S_FALSE;
            goto Error;
        }
    }

Error:
    FREESTRING(bstrSymbolString);
    if (NULL != pszEOTFile)
        CtlFree(pszEOTFile);
    FREESTRING(bstrEOTFile);
    FREESTRING(bstrFontFamily);
    if (NULL != pszMouseOff)
        CtlFree(pszMouseOff);
    if (NULL != pszMouseOver)
        CtlFree(pszMouseOver);
    FREESTRING(bstrMouseOff);
    FREESTRING(bstrMouseOver);
    FREESTRING(bstrScript);
    FREESTRING(bstrURL);
    FREESTRING(bstrHelpString);
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::CreateNewTask(ITask **ppiTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::CreateNewTask(ITask **ppiTask)
{
    HRESULT      hr = S_OK;
    ITasks      *piTasks = NULL;
    VARIANT      vtIndex;
    VARIANT      vtKey;
    VARIANT      vtText;
    BSTR         bstrKey = NULL;
    BSTR         bstrText = NULL;

    ASSERT(m_piTaskpadViewDef != NULL, "CreateNewTask: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "CreateNewTask: m_piTaskpad is NULL");

    ::VariantInit(&vtIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtText);

    vtIndex.vt = VT_ERROR;
    vtIndex.scode = DISP_E_PARAMNOTFOUND;

    hr = GetDlgText(IDC_EDIT_TP_TASK_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL == bstrKey || 0 == ::SysStringLen(bstrKey))
    {
        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;
    }
    else
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    hr = GetDlgText(IDC_EDIT_TP_TASK_TEXT, &bstrText);
    IfFailGo(hr);

    vtText.vt = VT_BSTR;
    vtText.bstrVal = ::SysAllocString(bstrText);
    if (NULL == vtText.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    hr = piTasks->Add(vtIndex, vtKey, vtText, reinterpret_cast<Task **>(ppiTask));
    IfFailGo(hr);

Error:
    FREESTRING(bstrText);
    FREESTRING(bstrKey);
    ::VariantClear(&vtIndex);
    ::VariantClear(&vtKey);
    ::VariantClear(&vtText);
    RELEASE(piTasks);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::ExitDoingNewTaskState(ITask *piTask)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::ExitDoingNewTaskState(ITask *piTask)
{
    HRESULT                     hr = S_OK;

    ASSERT(m_piTaskpadViewDef != NULL, "ExitDoingNewTaskState: m_piTaskpadViewDef is NULL");
    ASSERT(m_piTaskpad != NULL, "ExitDoingNewTaskState: m_piTaskpad is NULL");

    if (NULL != piTask)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_TP_REMOVE_TASK), TRUE);
    }
    else    // Operation was cancelled
    {
        --m_lCurrentTask;
        if (m_lCurrentTask > 0)
        {
            hr = ShowTask();
            IfFailGo(hr);
        }
        else
        {
            hr = EnableEdits(false);
            IfFailGo(hr);

            hr = ClearTask();
            IfFailGo(hr);
        }
    }

    m_bSavedLastTask = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTaskpadViewTasksPage::GetCurrentTask()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTaskpadViewTasksPage::GetCurrentTask(ITask **ppiTask)
{

    HRESULT      hr = S_OK;
    ITasks      *piTasks = NULL;
    VARIANT      vtIndex;

    ::VariantInit(&vtIndex);

    hr = m_piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks));
    IfFailGo(hr);

    vtIndex.vt = VT_I4;
    vtIndex.lVal = m_lCurrentTask;
    hr = piTasks->get_Item(vtIndex, reinterpret_cast<Task **>(ppiTask));
    IfFailGo(hr);

Error:
    RELEASE(piTasks);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstaskp.h ===
//=--------------------------------------------------------------------------------------
// pstaskp.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Taskpad View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSTASKPAD_H_
#define _PSTASKPAD_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CTaskpadViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CTaskpadViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~CTaskpadViewGeneralPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
	HRESULT CanApply();
    HRESULT ApplyName();
    HRESULT ApplyTitle();
    HRESULT ApplyDescription();
    HRESULT ApplyType();
    HRESULT ApplyListpad();
    HRESULT ApplyCustom();
    HRESULT ApplyViewMenu();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Other helpers
    HRESULT OnUseButton();
    HRESULT OnAddToView();
    HRESULT PopulateListViewCombo();

// Instance data
protected:
    ISnapInDesignerDef *m_piSnapInDesignerDef;
    ITaskpadViewDef    *m_piTaskpadViewDef;
    ITaskpad           *m_piTaskpad;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	TaskpadViewGeneral,                 // Name
	&CLSID_TaskpadViewDefGeneralPP,     // Class ID
	"Taskpad General Property Page",    // Registry display name
	CTaskpadViewGeneralPage::Create,    // Create function
	IDD_PROPPAGE_TP_VIEW_GENERAL,       // Dialog resource ID
	IDS_TASKPAD_GEN,                    // Tab caption
	IDS_TASKPAD_GEN,                    // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Taskpads,               // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Property Page Background
//
////////////////////////////////////////////////////////////////////////////////////


class CTaskpadViewBackgroundPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CTaskpadViewBackgroundPage(IUnknown *pUnkOuter);
    virtual ~CTaskpadViewBackgroundPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT CanApply();
    HRESULT ApplyMouseOverImage();
    HRESULT ApplyFontFamily();
    HRESULT ApplyEOTFile();
    HRESULT ApplySymbolString();

// Instance data
protected:
    ITaskpadViewDef  *m_piTaskpadViewDef;
    ITaskpad         *m_piTaskpad;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	TaskpadViewBackground,              // Name
	&CLSID_TaskpadViewDefBackgroundPP,  // Class ID
	"Taskpad Background Property Page", // Registry display name
	CTaskpadViewBackgroundPage::Create, // Create function
	IDD_PROPPAGE_TP_VIEW_BACKGROUND,    // Dialog resource ID
	IDS_TASKPAD_BACK,                   // Tab caption
	IDS_TASKPAD_BACK,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Taskpads,               // Help context ID
	FALSE                               // Thread safe
);

////////////////////////////////////////////////////////////////////////////////////
//
// Taskpad View Property Page Tasks
//
////////////////////////////////////////////////////////////////////////////////////


class CTaskpadViewTasksPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CTaskpadViewTasksPage(IUnknown *pUnkOuter);
    virtual ~CTaskpadViewTasksPage();


// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnKillFocus(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyCurrentTask();
    HRESULT CanApply();

    HRESULT ApplyKey(ITask *piTask);
    HRESULT ApplyText(ITask *piTask);
    HRESULT ApplyHelpString(ITask *piTask);
	HRESULT ApplyTag(ITask *piTask);
    HRESULT ApplyActionType(ITask *piTask);
    HRESULT ApplyURL(ITask *piTask);
    HRESULT ApplyScript(ITask *piTask);
    HRESULT ApplyImageType(ITask *piTask);
    HRESULT ApplyMouseOverImage(ITask *piTask);
    HRESULT ApplyMouseOffImage(ITask *piTask);
    HRESULT ApplyFontFamilyName(ITask *piTask);
    HRESULT ApplyEOTFile(ITask *piTask);
    HRESULT ApplySymbolString(ITask *piTask);

// Other helpers
	HRESULT OnRemoveTask();

    HRESULT ShowTask();
    HRESULT ShowTask(ITask *piTask);
    HRESULT GetCurrentTask(ITask **ppiTask);
	HRESULT ClearTask();
    HRESULT EnableEdits(bool bEnable);

// State transitions
protected:
    HRESULT CanEnterDoingNewTaskState();
    HRESULT EnterDoingNewTaskState();
    HRESULT CanCreateNewTask();
    HRESULT CreateNewTask(ITask **ppiTask);
    HRESULT ExitDoingNewTaskState(ITask *piTask);

// Instance data
protected:
    ITaskpadViewDef  *m_piTaskpadViewDef;
    ITaskpad         *m_piTaskpad;
    long              m_lCurrentTask;
    bool              m_bSavedLastTask;

    SnapInTaskpadImageTypeConstants m_lastImageType;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	TaskpadViewTasks,                   // Name
	&CLSID_TaskpadViewDefTasksPP,       // Class ID
	"Taskpad Tasks Property Page",      // Registry display name
	CTaskpadViewTasksPage::Create,      // Create function
	IDD_PROPPAGE_TP_VIEW_TASKS,         // Dialog resource ID
	IDS_TASKPAD_TASKS,                  // Tab caption
	IDS_TASKPAD_TASKS,                  // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Taskpads,               // Help context ID
	FALSE                               // Thread safe
);

#endif  // _PSTASKPAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstoolbr.cpp ===
//=--------------------------------------------------------------------------------------
// pstoolbr.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "pstoolbr.h"

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page General
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CToolbarGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CToolbarGeneralPage::Create(IUnknown *pUnkOuter)
{
        CToolbarGeneralPage *pNew = New CToolbarGeneralPage(pUnkOuter);
        return pNew->PrivateUnknown();
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::CToolbarGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarGeneralPage::CToolbarGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTOOLBRGENERAL), m_piMMCToolbar(0), m_piSnapInDesignerDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::~CToolbarGeneralPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarGeneralPage::~CToolbarGeneralPage()
{
    RELEASE(m_piMMCToolbar);
    RELEASE(m_piSnapInDesignerDef);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_COMBO_TB_ILS, IDS_TT_TB_IMAGE_LIST);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_TAG, IDS_TT_TB_TAG);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IObjectModel   *piObjectModel = NULL;
    VARIANT         vtTag;

    ::VariantInit(&vtTag);

    if (NULL != m_piMMCToolbar)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IMMCToolbar, reinterpret_cast<void **>(&m_piMMCToolbar));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piObjectModel->GetSnapInDesignerDef(&m_piSnapInDesignerDef);
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeImageListCombo();
    IfFailGo(hr);

    hr = InitializeImageListValue();
    IfFailGo(hr);

    hr = m_piMMCToolbar->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TB_TAG);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    ::VariantClear(&vtTag);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::InitializeImageListCombo()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::InitializeImageListCombo()
{
    HRESULT          hr = S_OK;
    IMMCImageLists  *piMMCImageLists = NULL;
    long             lCount = 0;
    int              lIndex = 0;
    VARIANT          varIndex;
    IMMCImageList   *piMMCImageList = NULL;
    BSTR             bstrILName = NULL;
    int              iResult = 0;

    ASSERT(NULL != m_piSnapInDesignerDef, "InitializeImageListCombo: m_piSnapInDesignerDef is NULL");

    ::VariantInit(&varIndex);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        varIndex.vt = VT_I4;
        varIndex.lVal = lIndex;
        hr = piMMCImageLists->get_Item(varIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrILName);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_TB_ILS, bstrILName, 0);
        IfFailGo(hr);

        FREESTRING(bstrILName);
        RELEASE(piMMCImageList);
    }

Error:
    FREESTRING(bstrILName);
    ::VariantClear(&varIndex);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::InitializeImageListValue()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::InitializeImageListValue()
{
    HRESULT          hr = S_OK;
    IMMCImageList   *piMMCImageList = NULL;
    BSTR             bstrName = NULL;

    ASSERT(m_piMMCToolbar != NULL, "InitializeImageListValue: m_piMMCToolbar is NULL");

    hr = m_piMMCToolbar->get_ImageList(reinterpret_cast<MMCImageList **>(&piMMCImageList));
    IfFailGo(hr);

    if (NULL != piMMCImageList)
    {
        hr = piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        hr = SelectCBBstr(IDC_COMBO_TB_ILS, bstrName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piMMCImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piMMCToolbar != NULL, "OnApply: m_piMMCToolbar is NULL");

    hr = ApplyImageList();
    IfFailGo(hr);

    hr = ApplyTag();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::ApplyImageList()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::ApplyImageList()
{
    HRESULT          hr = S_OK;
    BSTR             bstrImageList = NULL;
    IMMCImageLists  *piMMCImageLists = NULL;
    IMMCImageList   *piMMCImageList = NULL;
    VARIANT          varIndex;

    ASSERT(m_piMMCToolbar != NULL, "ApplyImageList: m_piMMCToolbar is NULL");

    ::VariantInit(&varIndex);

    hr = GetCBSelection(IDC_COMBO_TB_ILS, &bstrImageList);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = ::SysAllocString(bstrImageList);

    hr = piMMCImageLists->get_Item(varIndex, &piMMCImageList);
    IfFailGo(hr);

    hr = m_piMMCToolbar->putref_ImageList(reinterpret_cast<MMCImageList *>(piMMCImageList));
    IfFailGo(hr);

Error:
    ::VariantClear(&varIndex);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);
    FREESTRING(bstrImageList);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::ApplyTag()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::ApplyTag()
{
    HRESULT hr = S_OK;
    BSTR    bstrTag = NULL;
    VARIANT vtTag;

    ASSERT(m_piMMCToolbar != NULL, "ApplyTag: m_piMMCToolbar is NULL");

    ::VariantInit(&vtTag);

    hr = GetDlgText(IDC_EDIT_TB_TAG, &bstrTag);
    IfFailGo(hr);

    vtTag.vt = VT_BSTR;
    vtTag.bstrVal = ::SysAllocString(bstrTag);

    hr = m_piMMCToolbar->put_Tag(vtTag);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtTag);
    FREESTRING(bstrTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarGeneralPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarGeneralPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch(dlgItemID)
    {
    case IDC_COMBO_TB_ILS:
        MakeDirty();
        break;
    }

    RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page Buttons
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


struct ButtonStyles
{
    TCHAR                      m_pszStyleName[kSIMaxBuffer + 1];
    SnapInButtonStyleConstants m_iIdentifier;
    int                        m_iIndex;
};

ButtonStyles    g_buttonStyles[5] = {
    _T(""),  siDefault,        -1,
    _T(""),  siCheck,          -1,
    _T(""),  siButtonGroup,    -1,
    _T(""),  siSeparator,      -1,
    _T(""),  siDropDown,       -1
};


struct ButtonValues
{
    TCHAR                      m_pszValueName[kSIMaxBuffer + 1];
    SnapInButtonValueConstants m_iIdentifier;
    int                        m_iIndex;
};

ButtonValues    g_buttonValues[2] = {
    _T(""),  siUnpressed,      -1,
    _T(""),  siPressed,        -1,
};


//=--------------------------------------------------------------------------------------
// IUnknown *CToolbarButtonsPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
IUnknown *CToolbarButtonsPage::Create(IUnknown *pUnkOuter)
{
        CToolbarButtonsPage *pNew = New CToolbarButtonsPage(pUnkOuter);
        return pNew->PrivateUnknown();
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CToolbarButtonsPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarButtonsPage::CToolbarButtonsPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGTOOLBRBUTTONS), m_piMMCToolbar(0), m_lCurrentButtonIndex(0),
  m_lCurrentButtonMenuIndex(0), m_bSavedLastButton(true), m_bSavedLastButtonMenu(true)
{
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::~CToolbarButtonsPage()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
CToolbarButtonsPage::~CToolbarButtonsPage()
{
    RELEASE(m_piMMCToolbar);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_TB_INDEX, IDS_TT_TB_BTN_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_CAPTION, IDS_TT_TB_BTN_CAPTION);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_KEY, IDS_TT_TB_BTN_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_TB_BUTTON_VALUE, IDS_TT_TB_BTN_VALUE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_COMBO_TB_BUTTON_STYLE, IDS_TT_TB_BTN_STYLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_TOOLTIP_TEXT, IDS_TT_TB_BTN_TT_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_IMAGE, IDS_TT_TB_BTN_IMAGE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_BUTTON_TAG, IDS_TT_TB_BTN_TAG);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_VISIBLE, IDS_TT_TB_BTN_VISIBLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_ENABLED, IDS_TT_TB_BTN_ENABLED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MIXED_STATE, IDS_TT_TB_BTN_MIXED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_INDEX, IDS_TT_TB_BTNM_INDEX);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_TEXT, IDS_TT_TB_BTNM_TEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_KEY, IDS_TT_TB_BTNM_KEY);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_TB_MENU_TAG, IDS_TT_TB_BTNM_TAG);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_ENABLED, IDS_TT_TB_BTNM_ENABLED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_VISIBLE, IDS_TT_TB_BTNM_VISIBLE);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_CHECKED, IDS_TT_TB_BTN_CHECKED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_GRAYED, IDS_TT_TB_BTN_GRAYED);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_SEPARATOR, IDS_TT_TB_BTN_SEPRTR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_BREAK, IDS_TT_TB_BTN_MENUBR);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_TB_MENU_BAR_BREAK, IDS_TT_TB_BTN_MENUBARB);
    IfFailGo(hr);

    hr = PopulateButtonStyles();
    IfFailGo(hr);

    hr = PopulateButtonValues();
    IfFailGo(hr);

    hr = EnableButtonEdits(false);
    IfFailGo(hr);

    hr = EnableButtonMenuEdits(false);
    IfFailGo(hr);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::InitializeButtonValues()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::InitializeButtonValues()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_buttonValues[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BV_UNPRESSED,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonValues[0].m_pszValueName, szBuffer);
        g_buttonValues[0].m_iIdentifier = siUnpressed;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BV_PRESSED,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonValues[1].m_pszValueName, szBuffer);
        g_buttonValues[1].m_iIdentifier = siPressed;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::PopulateButtonValues()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::PopulateButtonValues()
{
    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;
    int         iIndex = 0;

    hr = InitializeButtonValues();
    IfFailGo(hr);

    for (iIndex = 0; iIndex < 2; ++iIndex)
    {
        hr = BSTRFromANSI(g_buttonValues[iIndex].m_pszValueName, &bstr);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_TB_BUTTON_VALUE, bstr, g_buttonValues[iIndex].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstr);
    }

Error:
    FREESTRING(bstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::InitializeButtonStyles()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::InitializeButtonStyles()
{
    HRESULT     hr = S_OK;
    int         iResult = 0;
    char        szBuffer[kSIMaxBuffer + 1];

    if (-1 == g_buttonStyles[0].m_iIndex)
    {
        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_DEFAULT,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[0].m_pszStyleName, szBuffer);
        g_buttonStyles[0].m_iIdentifier = siDefault;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_CHECK,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[1].m_pszStyleName, szBuffer);
        g_buttonStyles[1].m_iIdentifier = siCheck;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_GROUP,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[2].m_pszStyleName, szBuffer);
        g_buttonStyles[2].m_iIdentifier = siButtonGroup;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_SEPARATOR,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[3].m_pszStyleName, szBuffer);
        g_buttonStyles[3].m_iIdentifier = siSeparator;

        iResult = ::LoadString(GetResourceHandle(),
                               IDS_TB_BS_DROPDOWN,
                               szBuffer,
                               kSIMaxBuffer);
        if (0 == iResult)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        _tcscpy(g_buttonStyles[4].m_pszStyleName, szBuffer);
        g_buttonStyles[4].m_iIdentifier = siDropDown;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::PopulateButtonStyles()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::PopulateButtonStyles()
{
    HRESULT     hr = S_OK;
    BSTR        bstr = NULL;
    int         iIndex = 0;

    hr = InitializeButtonStyles();
    IfFailGo(hr);

    for (iIndex = 0; iIndex < 5; ++iIndex)
    {
        hr = BSTRFromANSI(g_buttonStyles[iIndex].m_pszStyleName, &bstr);
        IfFailGo(hr);

        hr = AddCBBstr(IDC_COMBO_TB_BUTTON_STYLE, bstr, g_buttonStyles[iIndex].m_iIdentifier);
        IfFailGo(hr);

        FREESTRING(bstr);
    }

Error:
    FREESTRING(bstr);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    IMMCButtons    *piMMCButtons = NULL;
    long            lCount = 0;
    IMMCButton     *piMMCButton = NULL;

    if (NULL != m_piMMCToolbar)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IMMCToolbar, reinterpret_cast<void **>(&m_piMMCToolbar));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    hr = piMMCButtons->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        m_lCurrentButtonIndex = 1;

        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);

        hr = ShowButton(piMMCButton);
        IfFailGo(hr);

        hr = EnableButtonEdits(true);
        IfFailGo(hr);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), TRUE);
    }
    else
    {
        // There are no buttons so disable the button and button menu index
        // edit controls
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_INDEX), FALSE);
    }

    m_bInitialized = true;

Error:
    RELEASE(piMMCButton);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnApply()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
//  Scenarios:
//  1. The user is in the middle of creating a new Button
//  2. The user is modifying an exising button
HRESULT CToolbarButtonsPage::OnApply()
{
    HRESULT                     hr = S_OK;
    IMMCButton                 *piMMCButton = NULL;
    long                        lCount = 0;
    int                         disposition = 0;
    IMMCButtonMenu             *piMMCButtonMenu = NULL;
    SnapInButtonStyleConstants  Style = siDefault;

    ASSERT(m_piMMCToolbar != NULL, "OnApply: m_piMMCToolbar is NULL");

    if (0 == m_lCurrentButtonIndex)
        goto Error;

    if (!m_bSavedLastButton)
    {
        hr = CanCreateNewButton();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new Button"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewButtonState(NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewButton(&piMMCButton);
        IfFailGo(hr);

        hr = ExitDoingNewButtonState(piMMCButton);
        IfFailGo(hr);
    }
    else
    {
        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);
    }


    // Check the style. If it is dropdown and we haven't yet created a
    // button menu for it then do so now

    IfFailGo(piMMCButton->get_Style(&Style));

    if ( (siDropDown == Style) && (!m_bSavedLastButtonMenu) )
    {
        hr = CanCreateNewButtonMenu();
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = HandleCantCommit(_T("Can\'t create new ButtonMenu"), _T("Would you like to discard your changes?"), &disposition);
            if (kSICancelOperation == disposition)
            {
                hr = E_INVALIDARG;
                goto Error;
            }
            else
            {
                // Discard changes
                hr = ExitDoingNewButtonMenuState(NULL, NULL);
                IfFailGo(hr);

                hr = S_OK;
                goto Error;
            }
        }

        hr = CreateNewButtonMenu(piMMCButton, &piMMCButtonMenu);
        IfFailGo(hr);

        hr = ExitDoingNewButtonMenuState(piMMCButton, piMMCButtonMenu);
        IfFailGo(hr);
    }

    hr = ApplyCurrentButton();
    IfFailGo(hr);

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyCurrentButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyCurrentButton()
{
    HRESULT                     hr = S_OK;
    IMMCButton                 *piMMCButton = NULL;

    ASSERT(m_piMMCToolbar != NULL, "ApplyCurrentButton: m_piMMCToolbar is NULL");

    hr = CanCreateNewButton();
    IfFailGo(hr);

    if (S_FALSE == hr) {
        hr = E_INVALIDARG;
        goto Error;
    }

    hr = GetCurrentButton(&piMMCButton);
    IfFailGo(hr);

    hr = ApplyCaption(piMMCButton);
    IfFailGo(hr);

    hr = ApplyKey(piMMCButton);
    IfFailGo(hr);

    hr = ApplyStyle(piMMCButton);
    IfFailGo(hr);

    hr = ApplyImage(piMMCButton);
    IfFailGo(hr);

    hr = ApplyValue(piMMCButton);
    IfFailGo(hr);

    hr = ApplyTooltipText(piMMCButton);
    IfFailGo(hr);

    hr = ApplyTag(piMMCButton);
    IfFailGo(hr);

    hr = ApplyVisible(piMMCButton);
    IfFailGo(hr);

    hr = ApplyEnabled(piMMCButton);
    IfFailGo(hr);

    hr = ApplyMixedState(piMMCButton);
    IfFailGo(hr);

    hr = ApplyCurrentButtonMenu(piMMCButton);
    IfFailGo(hr);

Error:
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyCurrentButtonMenu(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyCurrentButtonMenu(IMMCButton *piMMCButton)
{
    HRESULT                     hr = S_OK;
    SnapInButtonStyleConstants  bscStyle = siDefault;
    IMMCButtonMenu             *piMMCButtonMenu = NULL;

    ASSERT(m_piMMCToolbar != NULL, "ApplyCurrentButtonMenu: m_piMMCToolbar is NULL");
    ASSERT(piMMCButton != NULL, "ApplyCurrentButtonMenu: piMMCButton is NULL");

    hr = piMMCButton->get_Style(&bscStyle);
    IfFailGo(hr);

    if (siDropDown == bscStyle)
    {
        hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
        IfFailGo(hr);

        if (NULL != piMMCButtonMenu)
        {
            hr = ApplyButtonMenuText(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuKey(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuTag(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuEnabled(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuVisible(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuChecked(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuGrayed(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuSeparator(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuBreak(piMMCButtonMenu);
            IfFailGo(hr);

            hr = ApplyButtonMenuBarBreak(piMMCButtonMenu);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCButtonMenu);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyCaption(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyCaption(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrCaption = NULL;
    BSTR            bstrSavedCaption = NULL;

    ASSERT(NULL != piMMCButton, "ApplyCaption: piMMCButton is NULL");

    hr = GetDlgText(IDC_EDIT_TB_CAPTION, &bstrCaption);
    IfFailGo(hr);

    hr = piMMCButton->get_Caption(&bstrSavedCaption);
    IfFailGo(hr);

    if (NULL == bstrSavedCaption || 0 != ::wcscmp(bstrCaption, bstrSavedCaption))
    {
        hr = piMMCButton->put_Caption(bstrCaption);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedCaption);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyKey(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyKey(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrKey = NULL;
    BSTR            bstrSavedKey = NULL;

    ASSERT(NULL != piMMCButton, "ApplyKey: piMMCButton is NULL");

    hr = GetDlgText(IDC_EDIT_TB_KEY, &bstrKey);
    IfFailGo(hr);

    if ( (NULL == bstrKey) || (0 == ::SysStringLen(bstrKey)) )
    {
        hr = piMMCButton->put_Key(NULL);
        IfFailGo(hr);
    }
    else
    {
        hr = piMMCButton->get_Key(&bstrSavedKey);
        IfFailGo(hr);

        if ( (NULL == bstrSavedKey) || (0 != ::wcscmp(bstrKey, bstrSavedKey)) )
        {
            hr = piMMCButton->put_Key(bstrKey);
            IfFailGo(hr);
        }
    }

Error:
    FREESTRING(bstrSavedKey);
    FREESTRING(bstrKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyValue(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyValue(IMMCButton *piMMCButton)
{
    HRESULT                                             hr = S_OK;
    long                                                lValue = 0;
    SnapInButtonValueConstants  bvcValue = siUnpressed;
    SnapInButtonValueConstants  bvcSavedValue = siUnpressed;

    ASSERT(NULL != m_piMMCToolbar, "ApplyValue: m_piMMCToolbar is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_VALUE, &lValue);
    IfFailGo(hr);

    bvcValue = static_cast<SnapInButtonValueConstants>(lValue);

    hr = piMMCButton->get_Value(&bvcSavedValue);
    IfFailGo(hr);

    if (bvcValue != bvcSavedValue)
    {
        hr = piMMCButton->put_Value(bvcValue);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyStyle(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyStyle(IMMCButton *piMMCButton)
{
    HRESULT                     hr = S_OK;
    long                        lValue = 0;
    long                        cButtons = 0;
    SnapInButtonStyleConstants  NewStyle = siDefault;
    SnapInButtonStyleConstants  SavedStyle = siDefault;

    ASSERT(NULL != piMMCButton, "ApplyStyle: piMMCButton is NULL");

    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lValue);
    IfFailGo(hr);

    NewStyle = static_cast<SnapInButtonStyleConstants>(lValue);

    hr = piMMCButton->get_Style(&SavedStyle);
    IfFailGo(hr);

    if (NewStyle != SavedStyle)
    {
        hr = piMMCButton->put_Style(NewStyle);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyTooltipText(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyTooltipText(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrTooltipText = NULL;
    BSTR            bstrSavedTooltipText = NULL;

    ASSERT(NULL != m_piMMCToolbar, "ApplyTooltipText: m_piMMCToolbar is NULL");

    hr = GetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, &bstrTooltipText);
    IfFailGo(hr);

    hr = piMMCButton->get_ToolTipText(&bstrSavedTooltipText);
    IfFailGo(hr);

    if (NULL == bstrSavedTooltipText || 0 != ::wcscmp(bstrTooltipText, bstrSavedTooltipText))
    {
        hr = piMMCButton->put_ToolTipText(bstrTooltipText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedTooltipText);
    FREESTRING(bstrTooltipText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyImage(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyImage(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT         vtNewImage;

    ASSERT(NULL != piMMCButton, "ApplyImage: piMMCButton is NULL");

    ::VariantInit(&vtNewImage);

    hr = GetDlgVariant(IDC_EDIT_TB_IMAGE, &vtNewImage);
    IfFailGo(hr);

    if (VT_EMPTY != vtNewImage.vt)
    {
        hr = piMMCButton->put_Image(vtNewImage);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtNewImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyTag(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyTag(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    BSTR            bstrTag = NULL;
    VARIANT         vtNewTag;

    ASSERT(NULL != m_piMMCToolbar, "ApplyTag: m_piMMCToolbar is NULL");

    ::VariantInit(&vtNewTag);

    hr = GetDlgText(IDC_EDIT_TB_BUTTON_TAG, &bstrTag);
    IfFailGo(hr);

    vtNewTag.vt = VT_BSTR;
    vtNewTag.bstrVal = ::SysAllocString(bstrTag);
    if (NULL == vtNewTag.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piMMCButton->put_Tag(vtNewTag);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtNewTag);
    FREESTRING(bstrTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyVisible(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyVisible(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbVisible = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedVisible = VARIANT_FALSE;

    ASSERT(NULL != m_piMMCToolbar, "ApplyVisible: m_piMMCToolbar is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_VISIBLE, &vtbVisible);
    IfFailGo(hr);

    hr = piMMCButton->get_Visible(&vtbSavedVisible);
    IfFailGo(hr);

    if (vtbVisible != vtbSavedVisible)
    {
        hr = piMMCButton->put_Visible(vtbVisible);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyEnabled(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyEnabled(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedEnabled = VARIANT_FALSE;

    ASSERT(NULL != m_piMMCToolbar, "ApplyEnabled: m_piMMCToolbar is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_ENABLED, &vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButton->get_Enabled(&vtbSavedEnabled);
    IfFailGo(hr);

    if (vtbEnabled != vtbSavedEnabled)
    {
        hr = piMMCButton->put_Enabled(vtbEnabled);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyMixedState(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyMixedState(IMMCButton *piMMCButton)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbMixedState = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedMixedState = VARIANT_FALSE;

    ASSERT(NULL != m_piMMCToolbar, "ApplyMixedState: m_piMMCToolbar is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MIXED_STATE, &vtbMixedState);
    IfFailGo(hr);

    hr = piMMCButton->get_MixedState(&vtbSavedMixedState);
    IfFailGo(hr);

    if (vtbMixedState != vtbSavedMixedState)
    {
        hr = piMMCButton->put_MixedState(vtbMixedState);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuText(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuText(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    BSTR            bstrButtonMenuText = NULL;
    BSTR            bstrSavedButtonMenuText = NULL;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuText: piMMCButtonMenu is NULL");

    hr = GetDlgText(IDC_EDIT_TB_MENU_TEXT, &bstrButtonMenuText);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Text(&bstrSavedButtonMenuText);
    IfFailGo(hr);

    if (NULL == bstrSavedButtonMenuText || 0 != ::wcscmp(bstrButtonMenuText, bstrSavedButtonMenuText))
    {
        hr = piMMCButtonMenu->put_Text(bstrButtonMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedButtonMenuText);
    FREESTRING(bstrButtonMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuKey(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuKey(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    BSTR            bstrButtonMenuKey = NULL;
    BSTR            bstrSavedButtonMenuKey = NULL;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuKey: piMMCButtonMenu is NULL");

    hr = GetDlgText(IDC_EDIT_TB_MENU_KEY, &bstrButtonMenuKey);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Key(&bstrSavedButtonMenuKey);
    IfFailGo(hr);

    if (NULL == bstrSavedButtonMenuKey || 0 != ::wcscmp(bstrButtonMenuKey, bstrSavedButtonMenuKey))
    {
        hr = piMMCButtonMenu->put_Key(bstrButtonMenuKey);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedButtonMenuKey);
    FREESTRING(bstrButtonMenuKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuTag(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuTag(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    BSTR            bstrTag = NULL;
    VARIANT         vtNewTag;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuTag: piMMCButtonMenu is NULL");

    ::VariantInit(&vtNewTag);

    hr = GetDlgText(IDC_EDIT_TB_MENU_TAG, &bstrTag);
    IfFailGo(hr);

    vtNewTag.vt = VT_BSTR;
    vtNewTag.bstrVal = ::SysAllocString(bstrTag);
    if (NULL == vtNewTag.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piMMCButtonMenu->put_Tag(vtNewTag);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtNewTag);
    FREESTRING(bstrTag);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuEnabled(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuEnabled(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedEnabled = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuEnabled: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_ENABLED, &vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Enabled(&vtbSavedEnabled);
    IfFailGo(hr);

    if (vtbEnabled != vtbSavedEnabled)
    {
        hr = piMMCButtonMenu->put_Enabled(vtbEnabled);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuVisible(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuVisible(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbVisible = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedVisible = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuVisible: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_VISIBLE, &vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Visible(&vtbSavedVisible);
    IfFailGo(hr);

    if (vtbVisible != vtbSavedVisible)
    {
        hr = piMMCButtonMenu->put_Visible(vtbVisible);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuChecked(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuChecked(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbChecked = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedChecked = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuChecked: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_CHECKED, &vtbChecked);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Checked(&vtbSavedChecked);
    IfFailGo(hr);

    if (vtbChecked != vtbSavedChecked)
    {
        hr = piMMCButtonMenu->put_Checked(vtbChecked);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuGrayed(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuGrayed(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbGrayed = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedGrayed = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuGrayed: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_GRAYED, &vtbGrayed);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Grayed(&vtbSavedGrayed);
    IfFailGo(hr);

    if (vtbGrayed != vtbSavedGrayed)
    {
        hr = piMMCButtonMenu->put_Grayed(vtbGrayed);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuSeparator(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuSeparator(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbSeparator = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedSeparator = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuSeparator: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_SEPARATOR, &vtbSeparator);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Separator(&vtbSavedSeparator);
    IfFailGo(hr);

    if (vtbSeparator != vtbSavedSeparator)
    {
        hr = piMMCButtonMenu->put_Separator(vtbSeparator);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuBreak(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuBreak(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbMenuBreak = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedMenuBreak = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuBreak: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_BREAK, &vtbMenuBreak);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBreak(&vtbSavedMenuBreak);
    IfFailGo(hr);

    if (vtbMenuBreak != vtbSavedMenuBreak)
    {
        hr = piMMCButtonMenu->put_MenuBreak(vtbMenuBreak);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ApplyButtonMenuBarBreak(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ApplyButtonMenuBarBreak(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtbMenuBarBreak = VARIANT_FALSE;
    VARIANT_BOOL    vtbSavedMenuBarBreak = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ApplyButtonMenuBarBreak: piMMCButtonMenu is NULL");

    hr = GetCheckbox(IDC_CHECK_TB_MENU_BAR_BREAK, &vtbMenuBarBreak);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBarBreak(&vtbSavedMenuBarBreak);
    IfFailGo(hr);

    if (vtbMenuBarBreak != vtbSavedMenuBarBreak)
    {
        hr = piMMCButtonMenu->put_MenuBarBreak(vtbMenuBarBreak);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    IMMCButton     *piMMCButton = NULL;

    switch(dlgItemID)
    {
    case IDC_BUTTON_INSERT_BUTTON:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewButtonState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = EnterDoingNewButtonState();
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_REMOVE_BUTTON:
        hr = OnRemoveButton();
        IfFailGo(hr);
        break;

    case IDC_BUTTON_INSERT_BUTTON_MENU:
        if (S_OK == IsPageDirty())
        {
            hr = OnApply();
            IfFailGo(hr);
        }

        hr = CanEnterDoingNewButtonMenuState();
        IfFailGo(hr);

        if (S_OK == hr)
        {
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = EnterDoingNewButtonMenuState(piMMCButton);
            IfFailGo(hr);
        }
        break;

    case IDC_BUTTON_REMOVE_BUTTON_MENU:
        hr = OnRemoveButtonMenu();
        IfFailGo(hr);
        break;

    case IDC_CHECK_TB_VISIBLE:
    case IDC_CHECK_TB_ENABLED:
    case IDC_CHECK_TB_MIXED_STATE:
    case IDC_CHECK_TB_MENU_ENABLED:
    case IDC_CHECK_TB_MENU_VISIBLE:
    case IDC_CHECK_TB_MENU_CHECKED:
    case IDC_CHECK_TB_MENU_GRAYED:
    case IDC_CHECK_TB_MENU_SEPARATOR:
    case IDC_CHECK_TB_MENU_BREAK:
    case IDC_CHECK_TB_MENU_BAR_BREAK:
        MakeDirty();
        break;
    }

Error:
    RELEASE(piMMCButton);
    if (FAILED(hr))
        HandleError(_T("Apply Error"), _T("There was an error applying values for this Toolbar."));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnRemoveButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnRemoveButton()
{
    HRESULT         hr = S_OK;
    IMMCButtons    *piMMCButtons = NULL;
    IMMCButton     *piMMCButton = NULL;
    VARIANT         varIndex;
    long            lCount = 0;

    ASSERT(NULL != m_piMMCToolbar, "OnRemoveButton: m_piMMCToolbar is NULL");

    ::VariantInit(&varIndex);

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonIndex;
    hr = piMMCButtons->Remove(varIndex);
    IfFailGo(hr);

    hr = piMMCButtons->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentButtonIndex > lCount)
            m_lCurrentButtonIndex = lCount;

        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);

        hr = ShowButton(piMMCButton);
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentButtonIndex = 0;

        hr = ClearButton();
        IfFailGo(hr);

        hr = EnableButtonEdits(false);
        IfFailGo(hr);

        hr = EnableButtonMenuEdits(false);
        IfFailGo(hr);

                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);
    }

    m_bSavedLastButton = TRUE;
    m_bSavedLastButtonMenu = TRUE;

Error:
    ::VariantClear(&varIndex);
    RELEASE(piMMCButton);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnRemoveButtonMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnRemoveButtonMenu()
{
    HRESULT          hr = S_OK;
    IMMCButton      *piMMCButton = NULL;
    IMMCButtonMenu  *piMMCButtonMenu = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    VARIANT          varIndex;
    long             lCount = 0;

    ASSERT(NULL != m_piMMCToolbar, "OnRemoveButtonMenu: m_piMMCToolbar is NULL");

    ::VariantInit(&varIndex);

    hr = GetCurrentButton(&piMMCButton);
    IfFailGo(hr);

    hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
    IfFailGo(hr);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonMenuIndex;
    hr = piMMCButtonMenus->Remove(varIndex);
    IfFailGo(hr);

    hr = piMMCButtonMenus->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        if (m_lCurrentButtonMenuIndex > lCount)
            m_lCurrentButtonMenuIndex = lCount;

        hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
        IfFailGo(hr);

        hr = ShowButtonMenu(piMMCButtonMenu);
        IfFailGo(hr);
    }
    else
    {
        m_lCurrentButtonMenuIndex = 0;

        hr = ClearButtonMenu();
        IfFailGo(hr);

        hr = EnableButtonMenuEdits(false);
        IfFailGo(hr);

                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);
    }

Error:
    ::VariantClear(&varIndex);
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ClearButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ClearButton()
{
    HRESULT     hr = S_OK;
    BSTR        bstrNull = NULL;
    long        lData = 0;

    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_CAPTION, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_KEY, bstrNull);
    IfFailGo(hr);

    lData = 0;  // siUnpressed;
    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_VALUE, lData);
    IfFailGo(hr);

    lData = 0;  // siDefault;
    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_STYLE, lData);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, bstrNull);
    IfFailGo(hr);

    // Initialize the image index to the button index.
    hr = SetDlgText(IDC_EDIT_TB_IMAGE, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_BUTTON_TAG, bstrNull);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_VISIBLE, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_ENABLED, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MIXED_STATE, VARIANT_FALSE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ClearButtonMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ClearButtonMenu()
{
    HRESULT     hr = S_OK;
    BSTR        bstrNull = NULL;

    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_TEXT, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_KEY, bstrNull);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_TAG, bstrNull);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_ENABLED, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_VISIBLE, VARIANT_TRUE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_CHECKED, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_GRAYED, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_SEPARATOR, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BREAK, VARIANT_FALSE);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BAR_BREAK, VARIANT_FALSE);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnCtlSelChange(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnCtlSelChange(int dlgItemID)
{
    HRESULT hr = S_OK;

    switch(dlgItemID)
    {
    case IDC_COMBO_TB_BUTTON_VALUE:
        MakeDirty();
        break;

    case IDC_COMBO_TB_BUTTON_STYLE:
        hr = OnButtonStyle();
        IfFailGo(hr);

        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonStyle()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonStyle()
{
    HRESULT                     hr = S_OK;
    long                        lData = 0;
    SnapInButtonStyleConstants  bscStyle = siDefault;
    IMMCButton                 *piMMCButton = NULL;
    IMMCButtonMenus            *piMMCButtonMenus = NULL;
    long                        lCount = 0;

    ASSERT(NULL != m_piMMCToolbar, "ApplyEnabled: OnButtonStyle is NULL");

    IfFailGo(GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lData));

    bscStyle = static_cast<SnapInButtonStyleConstants>(lData);

    IfFailGo(GetCurrentButton(&piMMCButton));

    if (NULL != piMMCButton)
    {
        IfFailGo(piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus)));
    }

    switch (bscStyle)
    {
    case siDropDown:
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE), FALSE);
        IfFailGo(SetDlgText(IDC_EDIT_TB_IMAGE, (BSTR)NULL));
        break;

    default:
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), FALSE);
        IfFailGo(SetDlgText(IDC_EDIT_TB_CAPTION, (BSTR)NULL));
        IfFailGo(EnableButtonMenuEdits(FALSE));

        // Revert the button to a state where it has no button menus

        m_lCurrentButtonMenuIndex = 0;
        IfFailGo(ClearButtonMenu());
        if (NULL != piMMCButton)
        {
            IfFailGo(piMMCButton->put_Caption(NULL));
        }
        if (NULL != piMMCButtonMenus)
        {
            IfFailGo(piMMCButtonMenus->Clear());
        }
        m_bSavedLastButtonMenu = TRUE;
        break;
    }

Error:
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT       hr = S_OK;

    switch (pNMUpDown->hdr.idFrom)
    {
    case IDC_SPIN_TB_INDEX:
        hr = OnButtonDeltaPos(pNMUpDown);
        IfFailGo(hr);
        break;

    case IDC_SPIN_TB_MENU_INDEX:
        hr = OnButtonMenuDeltaPos(pNMUpDown);
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT       hr = S_OK;
    IMMCButtons  *piMMCButtons = NULL;
    long          lCount = 0;
    IMMCButton   *piMMCButton = NULL;

    ASSERT(NULL != m_piMMCToolbar, "OnButtonDeltaPos: m_piMMCToolbar is NULL");

    if (false == m_bSavedLastButton || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    hr = piMMCButtons->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentButtonIndex < lCount)
        {
            ++m_lCurrentButtonIndex;
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentButtonIndex > 1 && m_lCurrentButtonIndex <= lCount)
        {
            --m_lCurrentButtonIndex;
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCButton);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnButtonMenuDeltaPos(NMUPDOWN *pNMUpDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnButtonMenuDeltaPos(NMUPDOWN *pNMUpDown)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    IMMCButton      *piMMCButton = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    IMMCButtonMenu  *piMMCButtonMenu = NULL;

    ASSERT(NULL != m_piMMCToolbar, "OnButtonMenuDeltaPos: m_piMMCToolbar is NULL");

    if (false == m_bSavedLastButtonMenu || S_OK == IsPageDirty())
    {
        hr = OnApply();
        IfFailGo(hr);
    }

    hr = GetCurrentButton(&piMMCButton);
    IfFailGo(hr);

    hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
    IfFailGo(hr);

    hr = piMMCButtonMenus->get_Count(&lCount);
    IfFailGo(hr);

    if (pNMUpDown->iDelta < 0)
    {
        if (m_lCurrentButtonMenuIndex < lCount)
        {
            ++m_lCurrentButtonMenuIndex;
            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);
        }
    }
    else
    {
        if (m_lCurrentButtonMenuIndex > 1 && m_lCurrentButtonMenuIndex <= lCount)
        {
            --m_lCurrentButtonMenuIndex;
            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnKillFocus(int dlgItemID)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnKillFocus(int dlgItemID)
{
    HRESULT          hr = S_OK;
    int              lIndex = 0;
    IMMCButtons     *piMMCButtons = NULL;
    long             lCount = 0;
    IMMCButton      *piMMCButton = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    IMMCButtonMenu  *piMMCButtonMenu = NULL;

    if (false == m_bSavedLastButton)
    {
        goto Error;
    }

    switch (dlgItemID)
    {
    case IDC_EDIT_TB_INDEX:

        // Get the contents of the index field. If the user entered something
        // other than a number then set the index to 1.

        hr = GetDlgInt(IDC_EDIT_TB_INDEX, &lIndex);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonIndex = 0;
        }
        IfFailGo(hr);

        hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
        IfFailGo(hr);

        hr = piMMCButtons->get_Count(&lCount);
        IfFailGo(hr);

        // If the user entered an index of zero then switch it to 1 because the
        // collection is one-based

        if (0 == lIndex)
        {
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonIndex = 0;
        }

        // If the user entered an index that is beyond the end of the list then
        // switch to the last valid index

        if (lIndex > lCount)
        {
            lIndex = lCount;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonIndex = 0;
        }

        if (lIndex != m_lCurrentButtonIndex)
        {
            m_lCurrentButtonIndex = lIndex;

            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);
        }
        break;

    case IDC_EDIT_TB_MENU_INDEX:
        // Get the contents of the index field. If the user entered something
        // other than a number then set the index to 1.

        hr = GetDlgInt(IDC_EDIT_TB_MENU_INDEX, &lIndex);
        if (E_INVALIDARG == hr)
        {
            hr = S_OK;
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonMenuIndex = 0;
        }
        IfFailGo(hr);

        hr = GetCurrentButton(&piMMCButton);
        IfFailGo(hr);

        hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
        IfFailGo(hr);

        hr = piMMCButtonMenus->get_Count(&lCount);
        IfFailGo(hr);

        // If the user entered an index of zero then switch it to 1 because the
        // collection is one-based

        if (0 == lIndex)
        {
            lIndex = 1L;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonMenuIndex = 0;
        }

        // If the user entered an index that is beyond the end of the list then
        // switch to the last valid index

        if (lIndex > lCount)
        {
            lIndex = lCount;
            // Set this to zero so code below will detect a change and
            // refresh dialog which will replace junk in index field with "1"
            m_lCurrentButtonMenuIndex = 0;
        }

        if (lIndex != m_lCurrentButtonMenuIndex)
        {
            m_lCurrentButtonMenuIndex = lIndex;

            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);
        }
        break;
    }

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButtonMenus);
    RELEASE(piMMCButtons);
    RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ShowButton(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ShowButton
(
    IMMCButton *piMMCButton
)
{
    HRESULT                     hr = S_OK;
    BSTR                        bstrCaption = NULL;
    BSTR                        bstrKey = NULL;
    SnapInButtonValueConstants  bvcValue = siUnpressed;
    SnapInButtonStyleConstants  bscStyle = siDefault;
    BSTR                        bstrTooltipText = NULL;
    VARIANT                     vtImage;
    VARIANT                     vtTag;
    VARIANT_BOOL                vtbVisible = VARIANT_FALSE;
    VARIANT_BOOL                vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL                vtbMixedState = VARIANT_FALSE;
    IMMCButtonMenus            *piMMCButtonMenus = NULL;
    long                        lCount = 0;
    IMMCButtonMenu             *piMMCButtonMenu = NULL;

    ASSERT(NULL != piMMCButton, "ShowButton: piMMCButton is NULL");

    ::VariantInit(&vtImage);
    ::VariantInit(&vtTag);

    m_lCurrentButtonMenuIndex = 0;
    m_bSilentUpdate = true;

    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    hr = piMMCButton->get_Caption(&bstrCaption);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_CAPTION, bstrCaption);
    IfFailGo(hr);

    hr = piMMCButton->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_KEY, bstrKey);
    IfFailGo(hr);

    hr = piMMCButton->get_Value(&bvcValue);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_VALUE, static_cast<long>(bvcValue));
    IfFailGo(hr);

    hr = piMMCButton->get_Style(&bscStyle);
    IfFailGo(hr);

    hr = SetCBItemSelection(IDC_COMBO_TB_BUTTON_STYLE, static_cast<long>(bscStyle));
    IfFailGo(hr);

    hr = piMMCButton->get_ToolTipText(&bstrTooltipText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, bstrTooltipText);
    IfFailGo(hr);

    hr = piMMCButton->get_Image(&vtImage);
    IfFailGo(hr);

    hr = SetDlgText(vtImage, IDC_EDIT_TB_IMAGE);
    IfFailGo(hr);

    hr = piMMCButton->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TB_BUTTON_TAG);
    IfFailGo(hr);

    hr = piMMCButton->get_Visible(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_VISIBLE, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButton->get_Enabled(&vtbEnabled);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_ENABLED, vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButton->get_MixedState(&vtbMixedState);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MIXED_STATE, vtbMixedState);
    IfFailGo(hr);

    hr = EnableButtonEdits(TRUE);
    IfFailGo(hr);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), TRUE);

    if (siDropDown == bscStyle)
    {
                ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), TRUE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE), FALSE);

        hr = SetDlgText(IDC_EDIT_TB_IMAGE, (BSTR)NULL);
        IfFailGo(hr);

        hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
        IfFailGo(hr);

        hr = piMMCButtonMenus->get_Count(&lCount);
        IfFailGo(hr);

        if (lCount > 0)
        {
            m_lCurrentButtonMenuIndex = 1;
            hr = GetCurrentButtonMenu(piMMCButton, &piMMCButtonMenu);
            IfFailGo(hr);

            hr = ShowButtonMenu(piMMCButtonMenu);
            IfFailGo(hr);

            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), TRUE);

            hr = EnableButtonMenuEdits(true);
            IfFailGo(hr);
        }
    }
    else
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), FALSE);
        hr = SetDlgText(IDC_EDIT_TB_CAPTION, (BSTR)NULL);
        IfFailGo(hr);

                m_lCurrentButtonMenuIndex = 0;
                hr = ClearButtonMenu();
                IfFailGo(hr);

        hr = EnableButtonMenuEdits(false);
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCButtonMenu);
    RELEASE(piMMCButtonMenus);
    ::VariantClear(&vtTag);
    ::VariantClear(&vtImage);
    FREESTRING(bstrTooltipText);
    FREESTRING(bstrKey);
    FREESTRING(bstrCaption);
    m_bSilentUpdate = false;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ShowButtonMenu(IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ShowButtonMenu(IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT      hr = S_OK;
    BSTR         bstrText = NULL;
    BSTR         bstrKey = NULL;
    VARIANT      vtTag;
    VARIANT_BOOL vtbEnabled = VARIANT_FALSE;
    VARIANT_BOOL vtbVisible = VARIANT_FALSE;

    ASSERT(NULL != piMMCButtonMenu, "ShowButtonMenu: piMMCButtonMenu is NULL");

    ::VariantInit(&vtTag);

    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Text(&bstrText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_TEXT, bstrText);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Key(&bstrKey);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_TB_MENU_KEY, bstrKey);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Tag(&vtTag);
    IfFailGo(hr);

    hr = SetDlgText(vtTag, IDC_EDIT_TB_MENU_TAG);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Enabled(&vtbEnabled);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_ENABLED, vtbEnabled);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Visible(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_VISIBLE, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Checked(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_CHECKED, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Grayed(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_GRAYED, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_Separator(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_SEPARATOR, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBreak(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BREAK, vtbVisible);
    IfFailGo(hr);

    hr = piMMCButtonMenu->get_MenuBarBreak(&vtbVisible);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_TB_MENU_BAR_BREAK, vtbVisible);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtTag);
    FREESTRING(bstrKey);
    FREESTRING(bstrText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnableButtonEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnableButtonEdits
(
    bool bEnable
)
{
    BOOL    fEnableEdit = ((false == bEnable) ? TRUE : FALSE);
    BOOL    fEnableWindow = ((true == bEnable) ? TRUE : FALSE);

//    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), EM_SETREADONLY, static_cast<WPARAM>(TRUE), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_SPIN_TB_INDEX),        fEnableWindow);

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_KEY),     EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TB_BUTTON_VALUE), fEnableWindow);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_COMBO_TB_BUTTON_STYLE), fEnableWindow);

    ::SendMessage(::GetDlgItem(m_hwnd,  IDC_EDIT_TB_TOOLTIP_TEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    ::SendMessage(::GetDlgItem(m_hwnd,  IDC_EDIT_TB_IMAGE),        EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_IMAGE),        fEnableWindow);
    ::SendMessage(::GetDlgItem(m_hwnd,  IDC_EDIT_TB_BUTTON_TAG),   EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_VISIBLE),        fEnableWindow);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_ENABLED),        fEnableWindow);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MIXED_STATE),    fEnableWindow);

    return S_OK;
}

//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnableButtonMenuEdits(bool bEnable)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnableButtonMenuEdits
(
    bool bEnable
)
{
    BOOL    fEnableEdit = ((false == bEnable) ? TRUE : FALSE);
    BOOL    fEnableWindow = ((true == bEnable) ? TRUE : FALSE);
    int     iRetValue = 0;

    ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_INDEX), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_SPIN_TB_MENU_INDEX),        fEnableWindow);

    iRetValue = ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_TEXT), EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    iRetValue = ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_KEY),  EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);
    iRetValue = ::SendMessage(::GetDlgItem(m_hwnd, IDC_EDIT_TB_MENU_TAG),  EM_SETREADONLY, static_cast<WPARAM>(fEnableEdit), 0);

    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_ENABLED),   fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_VISIBLE),   fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_CHECKED),   fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_GRAYED),    fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_SEPARATOR), fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_BREAK),     fEnableWindow);
    iRetValue = ::EnableWindow(::GetDlgItem(m_hwnd, IDC_CHECK_TB_MENU_BAR_BREAK), fEnableWindow);

    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanEnterDoingNewButtonState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanEnterDoingNewButtonState()
{
    HRESULT     hr = S_FALSE;

    if (m_bSavedLastButton && m_bSavedLastButtonMenu)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnterDoingNewButtonState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnterDoingNewButtonState()
{
    HRESULT      hr = S_OK;

    ASSERT(NULL != m_piMMCToolbar, "EnterDoingNewButtonState: m_piMMCToolbar is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentButtonIndex;
    hr = SetDlgText(IDC_EDIT_TB_INDEX, m_lCurrentButtonIndex);
    IfFailGo(hr);

    // Don't let the user change index on a new button

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_INDEX), FALSE);

    // We disable the RemoveButton, InsertButtonMenu and RemoveButtonMenu buttons.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

    // Enable edits in this area of the dialog and clear all the entries
    hr = EnableButtonEdits(TRUE);
    IfFailGo(hr);

    // Disable and clear the Caption field as the default style is siDefault and
    // Caption is only used for a menu button (siDropDown)

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_TB_CAPTION), FALSE);

    hr = ClearButton();
    IfFailGo(hr);

    // Reinitialize button menu stuff for this button
        m_lCurrentButtonMenuIndex = 0;
        hr = ClearButtonMenu();
        IfFailGo(hr);

        hr = EnableButtonMenuEdits(FALSE);
        IfFailGo(hr);

    // Visible and Enabled should be on by default
    m_bSavedLastButton = FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanCreateNewButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanCreateNewButton()
{
    HRESULT     hr = S_OK;
    long        lData = 0;
    VARIANT     vtImageIndex;

    ::VariantInit(&vtImageIndex);

    // Got to have an image which is a string or an index > 0, unless it's a drop-down,
    // in which case we ignore this value.
    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lData);
    IfFailGo(hr);

    if (siDropDown != static_cast<SnapInButtonStyleConstants>(lData))
    {
        hr = GetDlgVariant(IDC_EDIT_TB_IMAGE, &vtImageIndex);
        IfFailGo(hr);

        if (VT_I4 == vtImageIndex.vt)
        {
            if (vtImageIndex.lVal <= 0)
            {
                HandleError(_T("Cannot Create New Button"), _T("ImageIndex has to be greater than zero"));
                hr = S_FALSE;
                goto Error;
            }
        }
        else if (VT_BSTR == vtImageIndex.vt)
        {
            if (0 == ::SysStringLen(vtImageIndex.bstrVal))
            {
                HandleError(_T("Cannot Create New Button"), _T("ImageIndex cannot be an empty string"));
                hr = S_FALSE;
                goto Error;
            }
        }
        else
        {
            HandleError(_T("Cannot Create New Button"), _T("Cannot determine type of ImageIndex"));
            hr = S_FALSE;
            goto Error;
        }

    }

Error:
    ::VariantClear(&vtImageIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CreateNewButton()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CreateNewButton(IMMCButton **ppiMMCButton)
{
    HRESULT         hr = S_OK;
    IMMCButtons    *piMMCButtons = NULL;
    VARIANT         varIndex;
    BSTR            bstrKey = NULL;
    VARIANT         vtKey;
    BSTR            bstrCaption = NULL;
    VARIANT         vtCaption;
    BSTR            bstrTooltipText = NULL;
    VARIANT         vtTooltipText;
    VARIANT         vtStyle;
    long            lData = 0;
    BSTR            bstrImage = NULL;
    VARIANT         vtImage;

    ::VariantInit(&varIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtCaption);
    ::VariantInit(&vtTooltipText);
    ::VariantInit(&vtStyle);
    ::VariantInit(&vtImage);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonIndex;

    hr = GetDlgText(IDC_EDIT_TB_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL == bstrKey || 0 == ::SysStringLen(bstrKey))
    {
        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;
    }
    else
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    hr = GetDlgText(IDC_EDIT_TB_CAPTION, &bstrCaption);
    IfFailGo(hr);

    vtCaption.vt = VT_BSTR;
    vtCaption.bstrVal = ::SysAllocString(bstrCaption);
    if (NULL == vtCaption.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetDlgText(IDC_EDIT_TB_TOOLTIP_TEXT, &bstrTooltipText);
    IfFailGo(hr);

    vtTooltipText.vt = VT_BSTR;
    vtTooltipText.bstrVal = ::SysAllocString(bstrTooltipText);
    if (NULL == vtTooltipText.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetCBSelectedItemData(IDC_COMBO_TB_BUTTON_STYLE, &lData);
    IfFailGo(hr);

    vtStyle.vt = VT_I4;
    vtStyle.lVal = lData;

    hr = GetDlgText(IDC_EDIT_TB_IMAGE, &bstrImage);
    IfFailGo(hr);

    vtImage.vt = VT_BSTR;
    vtImage.bstrVal = ::SysAllocString(bstrImage);
    if (NULL == vtImage.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
    IfFailGo(hr);

    hr = piMMCButtons->Add(varIndex, vtKey, vtCaption, vtStyle, vtImage,
                           vtTooltipText,
                           reinterpret_cast<MMCButton **>(ppiMMCButton));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtImage);
    FREESTRING(bstrImage);
    ::VariantClear(&vtStyle);
    ::VariantClear(&vtCaption);
    FREESTRING(bstrCaption);
    ::VariantClear(&vtTooltipText);
    FREESTRING(bstrTooltipText);
    ::VariantClear(&vtKey);
    FREESTRING(bstrKey);
    ::VariantClear(&varIndex);
    RELEASE(piMMCButtons);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ExitDoingNewButtonState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ExitDoingNewButtonState(IMMCButton *piMMCButton)
{
    HRESULT                     hr = S_OK;
    SnapInButtonStyleConstants  sibsc = siDefault;

    ASSERT(m_piMMCToolbar != NULL, "ExitDoingNewButtonState: m_piMMCToolbar is NULL");

    if (NULL != piMMCButton)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), TRUE);

        hr = piMMCButton->get_Style(&sibsc);
        IfFailGo(hr);

        if (siDropDown == sibsc)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON_MENU), TRUE);
        }
    }
    else    // Operation was cancelled
    {
        --m_lCurrentButtonIndex;
        if (m_lCurrentButtonIndex > 0)
        {
            hr = GetCurrentButton(&piMMCButton);
            IfFailGo(hr);

            hr = ShowButton(piMMCButton);
            IfFailGo(hr);

            RELEASE(piMMCButton);
        }
        else
        {
            hr = EnableButtonEdits(false);
            IfFailGo(hr);

            hr = ClearButton();
            IfFailGo(hr);
        }
    }

    m_bSavedLastButton = true;
    m_bSavedLastButtonMenu = true;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanEnterDoingNewButtonMenuState()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanEnterDoingNewButtonMenuState()
{
    HRESULT     hr = S_FALSE;

    if (m_bSavedLastButton && m_bSavedLastButtonMenu)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::EnterDoingNewButtonMenuState(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::EnterDoingNewButtonMenuState(IMMCButton *piMMCButton)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;

    ASSERT(NULL != piMMCButton, "EnterDoingNewButtonMenuState: piMMCButton is NULL");

    // Bump up the current button index to keep matters in sync.
    ++m_lCurrentButtonMenuIndex;
    hr = SetDlgText(IDC_EDIT_TB_MENU_INDEX, m_lCurrentButtonMenuIndex);
    IfFailGo(hr);

    // We disable the InsertButton, RemoveButton, and RemoveButtonMenu buttons.
    // The InsertButton button remains enabled and acts like an "Apply and New" button
    //::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON), FALSE);
    //::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), FALSE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), FALSE);

    hr = EnableButtonMenuEdits(true);
    IfFailGo(hr);

        hr = ClearButtonMenu();
    IfFailGo(hr);

    m_bSavedLastButtonMenu = FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CanCreateNewButtonMenu()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CanCreateNewButtonMenu()
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CreateNewButtonMenu(IMMCButton *piMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::CreateNewButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu)
{
    HRESULT           hr = S_OK;
    IMMCButtonMenus  *piMMCButtonMenus = NULL;
    VARIANT           varIndex;
    BSTR              bstrKey = NULL;
    VARIANT           vtKey;
    BSTR              bstrText = NULL;
    VARIANT           vtText;

    ::VariantInit(&varIndex);
    ::VariantInit(&vtKey);
    ::VariantInit(&vtText);

    hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
    IfFailGo(hr);

    varIndex.vt = VT_I4;
    varIndex.lVal = m_lCurrentButtonMenuIndex;

    hr = GetDlgText(IDC_EDIT_TB_MENU_KEY, &bstrKey);
    IfFailGo(hr);

    if (NULL != bstrKey && ::SysStringLen(bstrKey) > 0)
    {
        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrKey);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        vtKey.vt = VT_ERROR;
        vtKey.scode = DISP_E_PARAMNOTFOUND;
    }

    hr = GetDlgText(IDC_EDIT_TB_MENU_TEXT, &bstrText);
    IfFailGo(hr);

    vtText.vt = VT_BSTR;
    vtText.bstrVal = ::SysAllocString(bstrText);
    if (NULL == vtText.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piMMCButtonMenus->Add(varIndex, vtKey, vtText, reinterpret_cast<MMCButtonMenu **>(ppiMMCButtonMenu));
    IfFailGo(hr);

Error:
    ::VariantClear(&vtText);
    FREESTRING(bstrText);
    ::VariantClear(&vtKey);
    FREESTRING(bstrKey);
    ::VariantClear(&varIndex);
    RELEASE(piMMCButtonMenus);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::ExitDoingNewButtonMenuState(IMMCButton *piMMCButton, IMMCButtonMenu *piMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::ExitDoingNewButtonMenuState(IMMCButton *piMMCButton, IMMCButtonMenu *piMMCButtonMenu)
{
    HRESULT     hr = S_OK;

    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_INSERT_BUTTON), TRUE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON), TRUE);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDC_BUTTON_REMOVE_BUTTON_MENU), TRUE);

    m_bSavedLastButtonMenu = true;

//Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::GetCurrentButton(IMMCButton **ppiMMCButton)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
// Returns: S_OK - button found and returned in *ppiMMCButton
//          S_FALSE - button not found, *ppiMMCButton=NULL
//
HRESULT CToolbarButtonsPage::GetCurrentButton(IMMCButton **ppiMMCButton)
{
    HRESULT      hr = S_OK;
    IMMCButtons *piMMCButtons = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    *ppiMMCButton = NULL;

    ASSERT(NULL != m_piMMCToolbar, "GetCurrentButton: m_piMMCToolbar is NULL");

    if (m_lCurrentButtonIndex > 0)
    {
        hr = m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons));
        IfFailGo(hr);

        varIndex.vt = VT_I4;
        varIndex.lVal = m_lCurrentButtonIndex;
        hr = piMMCButtons->get_Item(varIndex, reinterpret_cast<MMCButton **>(ppiMMCButton));
        if (SID_E_INDEX_OUT_OF_RANGE == hr)
        {
            // User did Insert Button but has not yet applied so it it not
            // in the collection.
            hr = S_FALSE;
        }
        IfFailGo(hr);
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    RELEASE(piMMCButtons);
    ::VariantClear(&varIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::GetCurrentButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::GetCurrentButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu)
{
    HRESULT          hr = S_OK;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    VARIANT          varIndex;

    ASSERT(NULL != piMMCButton, "GetCurrentButton: piMMCButton is NULL");

    ::VariantInit(&varIndex);

    if (m_lCurrentButtonMenuIndex > 0)
    {
        hr = piMMCButton->get_ButtonMenus(reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus));
        IfFailGo(hr);

        varIndex.vt = VT_I4;
        varIndex.lVal = m_lCurrentButtonMenuIndex;
        hr = piMMCButtonMenus->get_Item(varIndex, reinterpret_cast<MMCButtonMenu **>(ppiMMCButtonMenu));
        IfFailGo(hr);
    }

Error:
    RELEASE(piMMCButtonMenus);
    ::VariantClear(&varIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::OnDestroy()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CToolbarButtonsPage::OnDestroy()
{
    HRESULT          hr = S_OK;

    IfFailGo(CheckButtonStyles());

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CToolbarButtonsPage::CheckButtonStyles()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
// Checks that all buttons are either dropdown or something else as MMC does not
// allow mixing toolbar buttons and menu buttons. If styles are not consistent
// displays message telling user to fix it up before running the snap-in or a
// runtime error will occur.
//
HRESULT CToolbarButtonsPage::CheckButtonStyles()
{
    HRESULT                     hr = S_OK;
    long                        cButtons = 0;
    SnapInButtonStyleConstants  Style = siDefault;
    SnapInButtonStyleConstants  LastStyle = siDefault;
    IMMCButtons                *piMMCButtons = NULL;
    IMMCButton                 *piMMCButton = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons)));
    IfFailGo(piMMCButtons->get_Count(&cButtons));

    varIndex.vt = VT_I4;

    for (varIndex.lVal = 1L; varIndex.lVal <= cButtons; varIndex.lVal++)
    {
        IfFailGo(piMMCButtons->get_Item(varIndex, reinterpret_cast<MMCButton **>(&piMMCButton)));
        IfFailGo(piMMCButton->get_Style(&Style));

        if (varIndex.lVal != 1L)
        {
            if (siDropDown == Style)
            {
                if (siDropDown != LastStyle)
                {
                    hr = SID_E_TOOLBAR_INCONSISTENT;
                    goto Error;
                }
            }
            else // This button is not drop-down
            {
                if (siDropDown == LastStyle)
                {
                    hr = SID_E_TOOLBAR_INCONSISTENT;
                    goto Error;
                }
            }
        }
        LastStyle = Style;
        RELEASE(piMMCButton);
    }

Error:
    if (SID_E_TOOLBAR_INCONSISTENT == hr)
    {
        HandleError("Toolbar Definition Inconsistent", "A toolbar's buttons must all be drop-down style or all must be something else. MMC does not allow mixing toolbar buttons and menu buttons within a toolbar. If you do not make the styles consistent before running your snap-in the toolbar will not appear.");
    }
    QUICK_RELEASE(piMMCButtons);
    QUICK_RELEASE(piMMCButton);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\pstoolbr.h ===
//=--------------------------------------------------------------------------------------
// pstoolbr.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// Toolbar Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSTOOLBAR_H_
#define _PSTOOLBAR_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CToolbarGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CToolbarGeneralPage(IUnknown *pUnkOuter);
    virtual ~CToolbarGeneralPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnCtlSelChange(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyImageList();
    HRESULT ApplyTag();

// Initialization
    HRESULT InitializeImageListCombo();
    HRESULT InitializeImageListValue();

// Instance data
protected:
    IMMCToolbar         *m_piMMCToolbar;
    ISnapInDesignerDef  *m_piSnapInDesignerDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ToolbarGeneral,                     // Name
	&CLSID_MMCToolbarGeneralPP,         // Class ID
	"Toolbar General Property Page",    // Registry display name
	CToolbarGeneralPage::Create,        // Create function
	IDD_PROPPAGE_TOOLBAR_GENERAL,       // Dialog resource ID
	IDS_TOOLBPPG_GEN,                   // Tab caption
	IDS_TOOLBPPG_GEN,                   // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Toolbars,               // Help context ID
	FALSE                               // Thread safe
);


////////////////////////////////////////////////////////////////////////////////////
//
// Toolbar Property Page Buttons
//
// We handle insertion, deletion, modification and navigation of IMMCButton's and
// the IMMCButtonMenu's owned by them. This is one of the most involved property
// pages in the whole designer.
//
////////////////////////////////////////////////////////////////////////////////////


class CToolbarButtonsPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CToolbarButtonsPage(IUnknown *pUnkOuter);
    virtual ~CToolbarButtonsPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);
    virtual HRESULT OnCtlSelChange(int dlgItemID);
    virtual HRESULT OnDeltaPos(NMUPDOWN *pNMUpDown);
    virtual HRESULT OnKillFocus(int dlgItemID);
    virtual HRESULT OnDestroy();

// Helpers for Apply event
protected:
    // IMMCButton's
    HRESULT CreateNewButton(IMMCButton **ppiMMCButton);
    HRESULT GetCurrentButton(IMMCButton **ppiMMCButton);
    HRESULT ShowButton(IMMCButton *piMMCButton);
    HRESULT EnableButtonEdits(bool bEnable);
    HRESULT ClearButton();
    HRESULT ApplyCurrentButton();

    HRESULT ApplyCaption(IMMCButton *piMMCButton);
    HRESULT ApplyKey(IMMCButton *piMMCButton);
    HRESULT ApplyValue(IMMCButton *piMMCButton);
    HRESULT ApplyStyle(IMMCButton *piMMCButton);
    HRESULT ApplyTooltipText(IMMCButton *piMMCButton);
    HRESULT ApplyImage(IMMCButton *piMMCButton);
    HRESULT ApplyTag(IMMCButton *piMMCButton);
    HRESULT ApplyVisible(IMMCButton *piMMCButton);
    HRESULT ApplyEnabled(IMMCButton *piMMCButton);
    HRESULT ApplyMixedState(IMMCButton *piMMCButton);
    HRESULT CheckButtonStyles();

    // IMMCButtonMenu's
    HRESULT CreateNewButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu);
    HRESULT GetCurrentButtonMenu(IMMCButton *piMMCButton, IMMCButtonMenu **ppiMMCButtonMenu);
    HRESULT ShowButtonMenu(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT EnableButtonMenuEdits(bool bEnable);
	HRESULT ClearButtonMenu();
    HRESULT ApplyCurrentButtonMenu(IMMCButton *piMMCButton);

    HRESULT ApplyButtonMenuText(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuKey(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuTag(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuEnabled(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuVisible(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuChecked(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuGrayed(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuSeparator(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuBreak(IMMCButtonMenu *piMMCButtonMenu);
    HRESULT ApplyButtonMenuBarBreak(IMMCButtonMenu *piMMCButtonMenu);

// Other helpers
protected:
    // Helpers called at initialization time
    HRESULT InitializeButtonValues();
    HRESULT PopulateButtonValues();
    HRESULT PopulateButtonStyles();
    HRESULT InitializeButtonStyles();

    // Combo box notifications
    HRESULT OnButtonStyle();

    // Button Handlers
    HRESULT OnRemoveButton();
    HRESULT OnRemoveButtonMenu();

    // Spin Button Handlers
    HRESULT OnButtonDeltaPos(NMUPDOWN *pNMUpDown);
    HRESULT OnButtonMenuDeltaPos(NMUPDOWN *pNMUpDown);

// State transitions
protected:
    HRESULT CanEnterDoingNewButtonState();
    HRESULT EnterDoingNewButtonState();
    HRESULT CanCreateNewButton();
    HRESULT ExitDoingNewButtonState(IMMCButton *piMMCButton);

    HRESULT CanEnterDoingNewButtonMenuState();
    HRESULT EnterDoingNewButtonMenuState(IMMCButton *piMMCButton);
    HRESULT CanCreateNewButtonMenu();
    HRESULT ExitDoingNewButtonMenuState(IMMCButton *piMMCButton, IMMCButtonMenu *piMMCButtonMenu);

// Instance data
protected:
    IMMCToolbar  *m_piMMCToolbar;
    long          m_lCurrentButtonIndex;
    long          m_lCurrentButtonMenuIndex;
    bool          m_bSavedLastButton;
    bool          m_bSavedLastButtonMenu;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	ToolbarButtons,                     // Name
	&CLSID_MMCToolbarButtonsPP,         // Class ID
	"Toolbar Buttons Property Page",    // Registry display name
	CToolbarButtonsPage::Create,        // Create function
	IDD_PROPPAGE_TOOLBAR_BUTTONS,       // Dialog resource ID
	IDS_TOOLBPPG_BUTTONS,               // Tab caption
	IDS_TOOLBPPG_BUTTONS,               // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_Toolbars,               // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSTOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psurl.h ===
//=--------------------------------------------------------------------------------------
// psurl.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet
//=-------------------------------------------------------------------------------------=

#ifndef _PSURL_H_
#define _PSURL_H_

#include "ppage.h"


////////////////////////////////////////////////////////////////////////////////////
//
// URL View Property Page General
//
////////////////////////////////////////////////////////////////////////////////////


class CURLViewGeneralPage : public CSIPropertyPage
{
public:
	static IUnknown *Create(IUnknown *pUnkOuter);

    CURLViewGeneralPage(IUnknown *pUnkOuter);
    virtual ~CURLViewGeneralPage();

// Inherited from CSIPropertyPage
protected:
    virtual HRESULT OnInitializeDialog();
    virtual HRESULT OnNewObjects();
    virtual HRESULT OnApply();
    virtual HRESULT OnButtonClicked(int dlgItemID);

// Helpers for Apply event
protected:
    HRESULT ApplyURLName();
    HRESULT ApplyURLUrl();
    HRESULT ApplyAddToView();
    HRESULT ApplyViewMenuText();
    HRESULT ApplyStatusBarText();

// Instance data
protected:
    IURLViewDef  *m_piURLViewDef;
};


DEFINE_PROPERTYPAGEOBJECT2
(
	URLViewGeneral,                     // Name
	&CLSID_URLViewDefGeneralPP,         // Class ID
	"URL View General Property Page",   // Registry display name
	CURLViewGeneralPage::Create,        // Create function
	IDD_PROPPAGE_URL_VIEW,              // Dialog resource ID
	IDS_URLPPG_GEN,                     // Tab caption
	IDS_URLPPG_GEN,                     // Doc string
	HELP_FILENAME,                      // Help file
	HID_mssnapd_URLViews,               // Help context ID
	FALSE                               // Thread safe
);


#endif  // _PSURL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\psurl.cpp ===
//=--------------------------------------------------------------------------------------
// psurl.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// URL View Property Sheet implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "psurl.h"

// for ASSERT and FAIL
//
SZTHISFILE


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
// URL View Property Page
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


//=--------------------------------------------------------------------------------------
// IUnknown *CURLViewGeneralPage::Create(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
IUnknown *CURLViewGeneralPage::Create(IUnknown *pUnkOuter)
{
	CURLViewGeneralPage *pNew = New CURLViewGeneralPage(pUnkOuter);
	return pNew->PrivateUnknown();		
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::CURLViewGeneralPage(IUnknown *pUnkOuter)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CURLViewGeneralPage::CURLViewGeneralPage
(
    IUnknown *pUnkOuter
)
: CSIPropertyPage(pUnkOuter, OBJECT_TYPE_PPGURLVIEWGENERAL), m_piURLViewDef(0)
{
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::~CURLViewGeneralPage()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
CURLViewGeneralPage::~CURLViewGeneralPage()
{
    RELEASE(m_piURLViewDef);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnInitializeDialog()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnInitializeDialog()
{
    HRESULT     hr = S_OK;

    hr = RegisterTooltip(IDC_EDIT_URL_NAME, IDS_TT_URL_NAME);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_URL_URL, IDS_TT_URL_URL);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_CHECK_URL_ADDTOVIEWMENU, IDS_TT_URL_ATVMENU);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_URL_VIEWMENUTEXT, IDS_TT_URL_VMTEXT);
    IfFailGo(hr);

    hr = RegisterTooltip(IDC_EDIT_URL_STATUSBARTEXT, IDS_TT_URL_SBTEXT);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnNewObjects()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnNewObjects()
{
    HRESULT         hr = S_OK;
    IUnknown       *pUnk = NULL;
    DWORD           dwDummy = 0;
    BSTR            bstrName = NULL;
    BSTR            bstrURL = NULL;
    VARIANT_BOOL    vtBool = VARIANT_FALSE;
    BSTR            bstrViewMenuText = NULL;
    BSTR            bstrStatusBarText = NULL;

    if (m_piURLViewDef != NULL)
        goto Error;     // Handle only one object

    pUnk = FirstControl(&dwDummy);
    if (pUnk == NULL)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pUnk->QueryInterface(IID_IURLViewDef, reinterpret_cast<void **>(&m_piURLViewDef));
    if (FAILED(hr))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piURLViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_NAME, bstrName);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_URL(&bstrURL);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_URL, bstrURL);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_AddToViewMenu(&vtBool);
    IfFailGo(hr);

    hr = SetCheckbox(IDC_CHECK_URL_ADDTOVIEWMENU, vtBool);
    IfFailGo(hr);

    // Initialize the state of View Menu Text
    if (vtBool == VARIANT_FALSE)
    {
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_VIEWMENUTEXT), FALSE);
        ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_STATUSBARTEXT), FALSE);
    }

    hr = m_piURLViewDef->get_ViewMenuText(&bstrViewMenuText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_VIEWMENUTEXT, bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_ViewMenuStatusBarText(&bstrStatusBarText);
    IfFailGo(hr);

    hr = SetDlgText(IDC_EDIT_URL_STATUSBARTEXT, bstrStatusBarText);
    IfFailGo(hr);

    m_bInitialized = true;

Error:
    FREESTRING(bstrStatusBarText);
    FREESTRING(bstrViewMenuText);
    FREESTRING(bstrURL);
    FREESTRING(bstrName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnApply()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnApply()
{
    HRESULT hr = S_OK;

    ASSERT(m_piURLViewDef != NULL, "OnApply: m_piURLViewDef is NULL");

    hr = ApplyURLName();
    IfFailGo(hr);

    hr = ApplyURLUrl();
    IfFailGo(hr);

    hr = ApplyAddToView();
    IfFailGo(hr);

    hr = ApplyViewMenuText();
    IfFailGo(hr);

    hr = ApplyStatusBarText();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyURLName()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyURLName()
{
    HRESULT  hr = S_OK;
    BSTR     bstrURLName = NULL;
    BSTR     bstrSavedURLName = NULL;

    hr = GetDlgText(IDC_EDIT_URL_NAME, &bstrURLName);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_Name(&bstrSavedURLName);
    IfFailGo(hr);

    if (::wcscmp(bstrURLName, bstrSavedURLName) != 0)
    {
        hr = m_piURLViewDef->put_Name(bstrURLName);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURLName);
    FREESTRING(bstrURLName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyURLUrl()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyURLUrl()
{
    HRESULT  hr = S_OK;
    BSTR     bstrURLUrl = NULL;
    BSTR     bstrSavedURLUrl = NULL;

    hr = GetDlgText(IDC_EDIT_URL_URL, &bstrURLUrl);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_URL(&bstrSavedURLUrl);
    IfFailGo(hr);

    if (::wcscmp(bstrURLUrl, bstrSavedURLUrl) != 0)
    {
        hr = m_piURLViewDef->put_URL(bstrURLUrl);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedURLUrl);
    FREESTRING(bstrURLUrl);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyAddToView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyAddToView()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;
    VARIANT_BOOL    vtSavedAddToViewMenu = VARIANT_FALSE;

    hr = GetCheckbox(IDC_CHECK_URL_ADDTOVIEWMENU, &vtAddToViewMenu);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_AddToViewMenu(&vtSavedAddToViewMenu);
    IfFailGo(hr);

    if (vtAddToViewMenu != vtSavedAddToViewMenu)
    {
        hr = m_piURLViewDef->put_AddToViewMenu(vtAddToViewMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyViewMenuText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyViewMenuText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrViewMenuText = NULL;
    BSTR     bstrSavedViewMenuText = NULL;

    hr = GetDlgText(IDC_EDIT_URL_VIEWMENUTEXT, &bstrViewMenuText);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_ViewMenuText(&bstrSavedViewMenuText);
    IfFailGo(hr);

    if (::wcscmp(bstrViewMenuText, bstrSavedViewMenuText) != 0)
    {
        hr = m_piURLViewDef->put_ViewMenuText(bstrViewMenuText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedViewMenuText);
    FREESTRING(bstrViewMenuText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::ApplyStatusBarText()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::ApplyStatusBarText()
{
    HRESULT  hr = S_OK;
    BSTR     bstrStatusBarText = NULL;
    BSTR     bstrSavedStatusBarText = NULL;

    hr = GetDlgText(IDC_EDIT_URL_STATUSBARTEXT, &bstrStatusBarText);
    IfFailGo(hr);

    hr = m_piURLViewDef->get_ViewMenuStatusBarText(&bstrSavedStatusBarText);
    IfFailGo(hr);

    if (::wcscmp(bstrStatusBarText, bstrSavedStatusBarText) != 0)
    {
        hr = m_piURLViewDef->put_ViewMenuStatusBarText(bstrStatusBarText);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrSavedStatusBarText);
    FREESTRING(bstrStatusBarText);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CURLViewGeneralPage::OnButtonClicked(int dlgItemID)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CURLViewGeneralPage::OnButtonClicked
(
    int dlgItemID
)
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    vtAddToViewMenu = VARIANT_FALSE;

    switch (dlgItemID)
    {
    case IDC_CHECK_URL_ADDTOVIEWMENU:
        hr = GetCheckbox(IDC_CHECK_URL_ADDTOVIEWMENU, &vtAddToViewMenu);
        IfFailGo(hr);

        if (vtAddToViewMenu == VARIANT_TRUE)
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_VIEWMENUTEXT), TRUE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_STATUSBARTEXT), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_VIEWMENUTEXT), FALSE);
            ::EnableWindow(::GetDlgItem(m_hwnd, IDC_EDIT_URL_STATUSBARTEXT), FALSE);
        }

        MakeDirty();
        break;
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\scpitm.cpp ===
//=--------------------------------------------------------------------------------------
// scpitm.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"
#include "psnode.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;



//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddNewNode()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  This function is invoked in response to a user clicking on the toolbar or selecting
//  a menu item. IObjectModelHost will have triggered an Add() notification, and the
//  notification will be serviced before this function returns.
//
HRESULT CSnapInDesigner::AddNewNode()
{
    HRESULT              hr = S_OK;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    VARIANT              vtEmpty;
    IScopeItemDef       *piScopeItemDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetScopeItemCollection(m_pCurrentSelection, &piScopeItemDefs);
    IfFailGo(hr);

    vtEmpty.vt = VT_ERROR;
    vtEmpty.scode = DISP_E_PARAMNOTFOUND;

    hr = piScopeItemDefs->Add(vtEmpty, vtEmpty, &piScopeItemDef);
    IfFailGo(hr);

Error:
    ::VariantClear(&vtEmpty);
    RELEASE(piScopeItemDef);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddScopeItemDef(pSelection, piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddScopeItemDef(CSelectionHolder *pParent, IScopeItemDef *piScopeItemDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pScopeItem = NULL;

    hr = MakeNewNode(pParent, piScopeItemDef, &pScopeItem);
    IfFailGo(hr);

    hr = pScopeItem->RegisterHolder();
    IfFailGo(hr);

    hr = InsertNodeInTree(pScopeItem, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pScopeItem);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pScopeItem);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pScopeItem);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameScopeItem(CSelectionHolder *pScopeItem, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost::Update() notification.
//
HRESULT CSnapInDesigner::RenameScopeItem(CSelectionHolder *pScopeItem, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_NODES_ANY_NAME == pScopeItem->m_st, "RenameScopeItem: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pScopeItem->m_piObject.m_piScopeItemDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = pScopeItem->m_piObject.m_piScopeItemDef->put_NodeTypeName(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pScopeItem, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteScopeItem(CSelectionHolder *pScopeItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteScopeItem(CSelectionHolder *pScopeItem)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    long                 lIndex = 0;
    VARIANT              vtIndex;

    ::VariantInit(&vtIndex);

    hr = CanDeleteScopeItem(pScopeItem);
    IfFailGo(hr);

    if (S_FALSE == hr)
        goto Error;

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pScopeItem, &pParent);
    IfFailGo(hr);

    // Delete from the appropriate object model collection
    hr = GetScopeItemCollection(pParent, &piScopeItemDefs);
    IfFailGo(hr);

    if (NULL != piScopeItemDefs)
    {
        hr = pScopeItem->m_piObject.m_piScopeItemDef->get_Index(&lIndex);
        IfFailGo(hr);

        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->Remove(vtIndex);
        IfFailGo(hr);
    }

Error:
    ::VariantClear(&vtIndex);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CanDeleteScopeItem(CSelectionHolder *pScopeItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::CanDeleteScopeItem(CSelectionHolder *pScopeItem)
{
    HRESULT           hr = S_OK;
    IScopeItemDefs   *piScopeItemDefs = NULL;
    long              lCount = 0;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;

    hr = pScopeItem->m_piObject.m_piScopeItemDef->get_Children(&piScopeItemDefs);
    IfFailGo(hr);

    piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = pScopeItem->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    if (lCount > 0)
    {
        hr = S_FALSE;
        goto Error;
    }

Error:
    if (S_FALSE == hr)
    {
        (void)::SDU_DisplayMessage(IDS_NODE_HAS_CHILDREN, MB_OK | MB_ICONHAND, HID_mssnapd_NodeHasChildren, 0, DontAppendErrorInfo, NULL);
    }

    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteScopeItem(CSelectionHolder *pScopeItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteScopeItem(CSelectionHolder *pScopeItem)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    CSelectionHolder    *pChildren = NULL;
    CSelectionHolder    *pViews = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    long                 lCount = 0;

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pScopeItem, &pParent);
    IfFailGo(hr);

    // Need to delete the children and views folders
    hr = m_pTreeView->GetFirstChildNode(pScopeItem, &pViews);
    IfFailGo(hr);

    ASSERT(SEL_NODES_ANY_VIEWS == pViews->m_st, "OnDeleteScopeItem: Expected a different child");

    hr = m_pTreeView->GetNextChildNode(pViews, &pChildren);
    IfFailGo(hr);

    ASSERT(SEL_NODES_ANY_CHILDREN == pChildren->m_st, "OnDeleteScopeItem: Expected a different child");

    delete pChildren;
    delete pViews;

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pScopeItem);
    IfFailGo(hr);

    delete pScopeItem;

    // Select the next selection
    hr = GetScopeItemCollection(pParent, &piScopeItemDefs);
    IfFailGo(hr);

    if (NULL != piScopeItemDefs)
    {
        hr = piScopeItemDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowNodeProperties(IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowNodeProperties
(
    IScopeItemDef *piScopeItemDef
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[2];

    hr = GetResourceString(IDS_NODE_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piScopeItemDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_ScopeItemDefGeneralPP;
    pageClsID[1] = CLSID_ScopeItemDefColHdrsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewNode(CSelectionHolder  *pParent, IScopeItemDef *piScopeItemDef, CSelectionHolder **ppNode)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewNode
(
    CSelectionHolder  *pParent,
    IScopeItemDef     *piScopeItemDef,
    CSelectionHolder **ppNode
)
{
    HRESULT              hr = S_OK;

    *ppNode = New CSelectionHolder(SEL_NODES_ANY_NAME, piScopeItemDef);
    if (*ppNode == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTCH:
        hr = InitializeNewAutoCreateNode(piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_NODES_OTHER:
        hr = InitializeNewOtherNode(piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_CHILDREN:
        hr = InitializeNewChildNode(piScopeItemDef, pParent->m_piObject.m_piScopeItemDefs);
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewAutoCreateNode(IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewAutoCreateNode
(
    IScopeItemDef *piScopeItemDef
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    bool              bGood = false;
    IScopeItemDefs   *piAutoScopeItemDefs = NULL;
    CSelectionHolder *pScopeItemDefClone = NULL;
    BSTR              bstrName = NULL;

    hr = GetResourceString(IDS_NODE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_AutoCreateNodes(&piAutoScopeItemDefs);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++m_iNextNodeNumber);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pScopeItemDefClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piScopeItemDef->put_Name(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_Key(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_NodeTypeName(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_DisplayName(bstrName);
    IfFailGo(hr);

	hr = piScopeItemDef->put_AutoCreate(VARIANT_TRUE);
	IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piAutoScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewOtherNode(IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewOtherNode
(
    IScopeItemDef *piScopeItemDef
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    bool              bGood = false;
    IScopeItemDefs   *piOtherScopeItemDefs = NULL;
    CSelectionHolder *pScopeItemDefClone = NULL;
    BSTR              bstrName = NULL;

    hr = GetResourceString(IDS_NODE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_OtherNodes(&piOtherScopeItemDefs);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++m_iNextNodeNumber);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pScopeItemDefClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piScopeItemDef->put_Name(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_Key(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_NodeTypeName(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_DisplayName(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piOtherScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsAutoCreateChild(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::IsAutoCreateChild(CSelectionHolder *pSelection)
{
	HRESULT				 hr = S_FALSE;
	CSelectionHolder	*pParent = NULL;

	while (SEL_SNAPIN_ROOT != pSelection->m_st && pParent != m_pRootNode)
	{
		hr = m_pTreeView->GetParent(pSelection, &pParent);
		IfFailGo(hr);

		if (pParent == m_pAutoCreateRoot)
		{
			hr = S_OK;
			goto Error;
		}

		pSelection = pParent;
		pParent = NULL;
	}

	hr = S_FALSE;

Error:
	RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewChildNode(IScopeItemDef *piScopeItemDef, IScopeItemDefs *piScopeItemDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewChildNode
(
    IScopeItemDef   *piScopeItemDef,
    IScopeItemDefs  *piScopeItemDefs
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    bool              bGood = false;
    CSelectionHolder *pScopeItemDefClone = NULL;
    BSTR              bstrName = NULL;

    hr = GetResourceString(IDS_NODE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++m_iNextNodeNumber);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pScopeItemDefClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piScopeItemDef->put_Name(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_Key(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_NodeTypeName(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_DisplayName(bstrName);
    IfFailGo(hr);

	hr = IsAutoCreateChild(m_pCurrentSelection);
	IfFailGo(hr);

	if (S_OK == hr)
	{
		hr = piScopeItemDef->put_AutoCreate(VARIANT_TRUE);
		IfFailGo(hr);
	}

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertNodeInTree(CSelectionHolder *pNode, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertNodeInTree
(
    CSelectionHolder *pNode,
    CSelectionHolder *pParent
)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrName = NULL;
    TCHAR               *pszName = NULL;
    CSelectionHolder    *pChildren = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pViews = NULL;
    IViewDefs           *piViewDefs = NULL;

    hr = pNode->m_piObject.m_piScopeItemDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kScopeItemIcon, pNode);
    IfFailGo(hr);

    pViews = New CSelectionHolder(SEL_NODES_ANY_VIEWS, pNode->m_piObject.m_piScopeItemDef);
    if (NULL == pViews)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pNode->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = RegisterViewCollections(pViews, piViewDefs);
    IfFailGo(hr);

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pNode, kClosedFolderIcon, pViews);
    IfFailGo(hr);

    hr = pNode->m_piObject.m_piScopeItemDef->get_Children(&piScopeItemDefs);
    IfFailGo(hr);

    pChildren = New CSelectionHolder(SEL_NODES_ANY_CHILDREN, piScopeItemDefs);
    if (NULL == pChildren)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pChildren->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_CHILDREN, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pNode, kClosedFolderIcon, pChildren);
    IfFailGo(hr);

Error:
    RELEASE(piViewDefs);
    RELEASE(piScopeItemDefs);
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetScopeItemCollection(CSelectionHolder *pScopeItem, IScopeItemDefs **ppiScopeItemDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetScopeItemCollection
(
    CSelectionHolder *pScopeItem,
    IScopeItemDefs  **ppiScopeItemDefs
)
{
    HRESULT              hr = S_OK;
    IScopeItemDefs      *piScopeItemDefs = NULL;

    switch (pScopeItem->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_AUTO_CREATE_ROOT:
        hr = m_piSnapInDesignerDef->get_AutoCreateNodes(ppiScopeItemDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_OTHER:
        hr = m_piSnapInDesignerDef->get_OtherNodes(ppiScopeItemDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = pScopeItem->m_piObject.m_piScopeItemDef->get_Children(ppiScopeItemDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_CHILDREN:
        *ppiScopeItemDefs = pScopeItem->m_piObject.m_piScopeItemDefs;
        (*ppiScopeItemDefs)->AddRef();
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "DeleteScopeItem: Cannot determine appropriate parent");
        hr = S_FALSE;
        break;
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\resource.h ===
//=--------------------------------------------------------------------------=
// resource.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//      Snap-in designer runtime resource IDs
//

#ifndef _RESOURCE_H_


//=--------------------------------------------------------------------------=
//                              Bitmaps
//=--------------------------------------------------------------------------=

#define IDB_TOOLBAR                     1
#define IDB_BITMAP_CLOSED_FOLDER        2
#define IDB_BITMAP_OPEN_FOLDER          3
#define IDB_BITMAP_SCOPE_ITEM           4
#define IDB_BITMAP_IMAGE_LIST           5
#define IDB_BITMAP_MENU                 6
#define IDB_BITMAP_TOOLBAR              7
#define IDB_BITMAP_LIST_VIEW            8
#define IDB_BITMAP_OCX_VIEW             9
#define IDB_BITMAP_URL_VIEW            10
#define IDB_BITMAP_TASKPAD             11
#define IDB_BITMAP_DATAFMT             12
#define IDB_BITMAP_CHECKBOX            13

//=--------------------------------------------------------------------------=
//                              Strings
//=--------------------------------------------------------------------------=

#define IDS_DESIGNER_NAME               0

// This is defined for all inproc servers that use satellite localization. It
// must be 1001
//
#define IDS_SERVERBASENAME              1001
#define IDS_SNAPIN_PROPS                1002
#define IDS_NODE_PROPS                  1003
#define IDS_LISTVIEW_PROPS              1004
#define IDS_OCX_PROPS                   1005
#define IDS_URL_PROPS                   1006
#define IDS_TASK_PROPS                  1007
#define IDS_IL_PROPS                    1008
#define IDS_MENU_PROPS                  1009
#define IDS_TOOLB_PROPS                 1010

#define IDS_DFLT_PROVIDER               1020
#define IDS_DFLT_VERSION                1021
#define IDS_DFLT_DESCRIPT               1022

#define IDS_SNAPINPPG_GEN               1030
#define IDS_SNAPINPPG_IL				1031
#define IDS_SNAPINPPG_AVAIL             1032
#define IDS_NODEPPG_GEN                 1033
#define IDS_NODEPPG_CH                  1034
#define IDS_URLPPG_GEN                  1035
#define IDS_OCXPPG_GEN                  1036
#define IDS_LISTVPPG_GEN                1037
#define IDS_LISTVPPG_IL                 1038
#define IDS_LISTVPPG_SORT               1039
#define IDS_LISTVPPG_CH                 1040
#define IDS_IMGLSTPPG_IMG               1041
#define IDS_TOOLBPPG_GEN                1042
#define IDS_TOOLBPPG_BUTTONS            1043
#define IDS_TASKPAD_GEN                 1044
#define IDS_TASKPAD_BACK                1045
#define IDS_TASKPAD_TASKS               1046

#define IDS_NODE                        1100
#define IDS_LIST_VIEW                   1101
#define IDS_URL_VIEW                    1102
#define IDS_OCX_VIEW                    1103
#define IDS_TASK_VIEW                   1104
#define IDS_IMGLIST                     1105
#define IDS_MENU                        1106
#define IDS_TOOLBAR                     1107
#define IDS_DATAFORMAT                  1108

#define IDS_EXTENSIONS_ROOT             1201
#define IDS_NODES_ROOT                  1202
#define IDS_NODES_AUTO_CREATE           1203
#define IDS_NODES_OTHER                 1204
#define IDS_NODES_STATIC                1205
#define IDS_CHILDREN                    1206
#define IDS_VIEWS                       1207
#define IDS_TOOLS                       1208
#define IDS_IMAGE_LISTS                 1209
#define IDS_MENUS                       1210
#define IDS_TOOLBARS                    1211
#define IDS_LISTVIEWS                   1212
#define IDS_OCXVIEWS                    1213
#define IDS_URLVIEWS                    1214
#define IDS_TASKPADS                    1215
#define IDS_DATAFORMATS                 1216

#define IDS_LV_VM_LARGE                 1300
#define IDS_LV_VM_SMALL                 1301
#define IDS_LV_VM_LIST                  1302
#define IDS_LV_VM_REPORT                1303
#define IDS_LV_VM_FILTERED              1304
#define IDS_LV_SORT_ASC                 1305
#define IDS_LV_SORT_DESC                1306

#define IDS_TB_BS_DEFAULT               1310
#define IDS_TB_BS_CHECK                 1311
#define IDS_TB_BS_GROUP                 1312
#define IDS_TB_BS_SEPARATOR             1313
#define IDS_TB_BS_DROPDOWN              1314

#define IDS_TB_BV_UNPRESSED             1320
#define IDS_TB_BV_PRESSED               1321

#define IDS_EXT_CONTEXT_MENUS           1400
#define IDS_EXT_CTX_MENU_NEW            1401
#define IDS_EXT_CTX_MENU_TASK           1402
#define IDS_EXT_PROP_PAGES              1403
#define IDS_EXT_PROP_TASKPAD            1404
#define IDS_EXT_PROP_TOOLBAR            1405
#define IDS_EXT_PROP_NAMESPACE          1406

#define IDS_MYEXT_NEW_MENU              1410
#define IDS_MYEXT_TASK_MENU             1411
#define IDS_MYEXT_TOP_MENU              1412
#define IDS_MYEXT_VIEW_MENU             1413
#define IDS_MYEXT_PPAGES                1414
#define IDS_MYEXT_TOOLBAR               1415
#define IDS_MYEXT_NAMESPACE             1416

#define IDS_TT_ADD_NODE                  200
#define IDS_TT_ADD_LISTVIEW              201
#define IDS_TT_ADD_TASKPAD               202
#define IDS_TT_ADD_OCX_VIEW              203
#define IDS_TT_ADD_WEB_VIEW              204
#define IDS_TT_ADD_IMAGE_LIST            205
#define IDS_TT_ADD_TOOLBAR               206
#define IDS_TT_ADD_MENU                  207
#define IDS_TT_PROMOTE                   208
#define IDS_TT_DEMOTE                    209
#define IDS_TT_MOVE_UP                   210
#define IDS_TT_MOVE_DOWN                 211
#define IDS_TT_VIEW_PROPERTIES           212
#define IDS_TT_DELETE                    213

#define IDS_TT_SN_STANDALONE             220
#define IDS_TT_SN_EXTENSION              221
#define IDS_TT_SN_DUAL                   222
#define IDS_TT_SN_EXTENSIBLE             223
#define IDS_TT_SN_NAME                   224
#define IDS_TT_SN_TYPENAME               225
#define IDS_TT_SN_DISPLAY                226
#define IDS_TT_SN_PROVIDER               227
#define IDS_TT_SN_VERSION                228
#define IDS_TT_SN_DESCRIPTION            229
#define IDS_TT_SN_DEFAULTVIEW            230
#define IDS_TT_SN_SMALL                  231
#define IDS_TT_SN_SMALL_OPEN             232
#define IDS_TT_SN_LARGE                  233

#define IDS_TT_LV1_NAME                  401
#define IDS_TT_LV1_DFLTVIEW              402
#define IDS_TT_LV1_VIRTLIST              403
#define IDS_TT_LV1_ADDTOVIEWM            404
#define IDS_TT_LV1_VIEWMENUTXT           405
#define IDS_TT_LV1_STATUSTXT             406

#define IDS_TT_LV2_LARGE                 410
#define IDS_TT_LV2_SMALL                 411

#define IDS_TT_LV3_SORTED                415
#define IDS_TT_LV3_KEY                   416
#define IDS_TT_LV3_SORTORDER             417

#define IDS_TT_LV4_INDEX                 420
#define IDS_TT_LV4_TEXT                  421
#define IDS_TT_LV4_WIDTH                 422
#define IDS_TT_LV4_AUTOWIDTH             423
#define IDS_TT_LV4_KEY                   424

#define IDS_TT_OCX_NAME                  430
#define IDS_TT_OCX_PROGID                431
#define IDS_TT_OCX_ATVMENU               432
#define IDS_TT_OCX_VMTEXT                433
#define IDS_TT_OCX_SBTEXT                434

#define IDS_TT_URL_NAME                  440
#define IDS_TT_URL_URL                   441
#define IDS_TT_URL_ATVMENU               442
#define IDS_TT_URL_VMTEXT                443
#define IDS_TT_URL_SBTEXT                444

#define IDS_TT_NODE_NAME                 450
#define IDS_TT_NODE_DISPLAY              451
#define IDS_TT_NODE_IMAGEL               452
#define IDS_TT_NODE_FOLDER               453
#define IDS_TT_NODE_DEFAULT              455
#define IDS_TT_NODE_AUTOCR               456

#define IDS_TT_IL_INDEX                  460
#define IDS_TT_IL_KEY                    461
#define IDS_TT_IL_TAG                    462
#define IDS_TT_IL_COUNT                  463

#define IDS_TT_TB_IMAGE_LIST             480
#define IDS_TT_TB_TAG                    481

#define IDS_TT_TB_BTN_INDEX              485
#define IDS_TT_TB_BTN_CAPTION            486
#define IDS_TT_TB_BTN_KEY                487
#define IDS_TT_TB_BTN_VALUE              488
#define IDS_TT_TB_BTN_STYLE              489
#define IDS_TT_TB_BTN_TT_TEXT            490
#define IDS_TT_TB_BTN_IMAGE              491
#define IDS_TT_TB_BTN_TAG                492
#define IDS_TT_TB_BTN_VISIBLE            493
#define IDS_TT_TB_BTN_ENABLED            494
#define IDS_TT_TB_BTN_MIXED              495
#define IDS_TT_TB_BTN_CHECKED            496
#define IDS_TT_TB_BTN_GRAYED             497
#define IDS_TT_TB_BTN_SEPRTR             498
#define IDS_TT_TB_BTN_MENUBR             499
#define IDS_TT_TB_BTN_MENUBARB           500
#define IDS_TT_TB_BTNM_INDEX             501
#define IDS_TT_TB_BTNM_TEXT              502
#define IDS_TT_TB_BTNM_KEY               503
#define IDS_TT_TB_BTNM_TAG               504
#define IDS_TT_TB_BTNM_ENABLED           505
#define IDS_TT_TB_BTNM_VISIBLE           506

#define IDS_TT_TP_GEN_NAME               600
#define IDS_TT_TP_GEN_TITLE              601
#define IDS_TT_TP_GEN_TEXT               602
#define IDS_TT_TP_GEN_DEFAULT            603
#define IDS_TT_TP_GEN_LISTPAD            604
#define IDS_TT_TP_GEN_CUSTOM             605
#define IDS_TT_TP_GEN_LIST_TI            606
#define IDS_TT_TP_GEN_USE_BTN            607
#define IDS_TT_TP_GEN_BTN_TEXT           608
#define IDS_TT_TP_GEN_URL                609
#define IDS_TT_TP_GEN_ADDTOVW            610
#define IDS_TT_TP_GEN_VWMNTEXT           611
#define IDS_TT_TP_GEN_LISTVIEW           612
#define IDS_TT_TP_GEN_PREFERRED          613

#define IDS_TT_TP_BK_NONE                620
#define IDS_TT_TP_BK_SYMBOL              621
#define IDS_TT_TP_BK_VANILLA             622
#define IDS_TT_TP_BK_CHOCOL              623
#define IDS_TT_TP_BK_BITMAP              624
#define IDS_TT_TP_BK_MOUSE_OVR           625
#define IDS_TT_TP_BK_FFNAME              626
#define IDS_TT_TP_BK_EOT                 627
#define IDS_TT_TP_BK_SYM_STR             628

#define IDS_TT_TP_TSK_INDEX              630
#define IDS_TT_TP_TSK_KEY                631
#define IDS_TT_TP_TSK_TEXT               632
#define IDS_TT_TP_TSK_HELP               633
#define IDS_TT_TP_TSK_NOTIFY             634
#define IDS_TT_TP_TSK_URL                635
#define IDS_TT_TP_TSK_SCRIPT             636
#define IDS_TT_TP_TSK_U_URL              637
#define IDS_TT_TP_TSK_S_SCRIPT           638
#define IDS_TT_TP_TSK_SYMBOL             639
#define IDS_TT_TP_TSK_VANILLA            640
#define IDS_TT_TP_TSK_CHOCOL             641
#define IDS_TT_TP_TSK_BITMAP             642
#define IDS_TT_TP_TSK_MOUSE_OVR          643
#define IDS_TT_TP_TSK_MOUSE_OFF          644
#define IDS_TT_TP_TSK_FFNAME             645
#define IDS_TT_TP_TSK_EOT                646
#define IDS_TT_TP_TSK_SYM_STR            647

#define IDS_TT_EXTEND_INSTRUCTIONS       700


// Error messages

#define IDS_RENAME_FAILED                800
#define IDS_DELETE_FAILED                801
#define IDS_INVALID_IDENTIFIER           802
#define IDS_IDENTIFIER_IN_USE            803
#define IDS_ADD_FAILED                   804
#define IDS_DEMOTE_FAILED                805
#define IDS_PROMOTE_FAILED               806
#define IDS_VIEW_IN_USE                  807
#define IDS_INVALID_GUID                 808
#define IDS_INVALID_PICTURE              809
#define IDS_COLHDR_APPLY_FAILED          810
#define IDS_NODE_HAS_CHILDREN            811





//=--------------------------------------------------------------------------=
//                          Property Sheets
//=--------------------------------------------------------------------------=
#define IDC_STATIC                        -1

// Snap-In Properties Page 1
#define IDD_DIALOG_SNAPIN               1000
#define IDC_RADIO_STAND_ALONE           1001
#define IDC_RADIO_EXTENSION             1002
#define IDC_RADIO_DUAL                  1003
#define IDC_EDIT_NAME                   1004
#define IDC_EDIT_NODE_TYPE              1005
#define IDC_EDIT_DISPLAY                1006
#define IDC_EDIT_PROVIDER               1007
#define IDC_EDIT_VERSION                1008
#define IDC_EDIT_DESCRIPTION            1009
#define IDC_COMBO_VIEWS                 1010
#define IDC_CHECK_EXTENSIBLE            1011

// Snap-In Properties Page 2
#define IDD_PROPPAGE_SNAPIN_IL			1015
#define IDC_COMBO_SMALL_FOLDERS			1016
#define IDC_COMBO_SMALL_OPEN_FOLDERS	1017
#define IDC_COMBO_LARGE_FOLDERS			1018

// Snap-In Properties Page 3
#define IDD_DIALOG_AVAILABLE_NODES      1020
#define IDC_LIST_AVAILABLE_NODES        1021
#define IDC_BUTTON_ADD                  1022
#define IDC_BUTTON_PROPERTIES           1023
#define IDC_STATIC_EXTEND_INSTRUCTIONS  1024

#define IDD_DIALOG_ADD_TO_AVAILABLE     1025
#define IDAPPLY                         1026
#define IDC_EDIT_AVAIL_NODE_GUID        1027
#define IDC_EDIT_AVAIL_NODE_NAME        1028

// ScopeItemDef's Properties Page 1
#define IDD_DIALOG_NEW_NODE             1030
#define IDC_EDIT_NODE_NAME              1031
#define IDC_EDIT_NODE_DISPLAY_NAME      1032
#define IDC_EDIT_FOLDER		            1033
#define IDC_COMBO_IMAGE_LISTS           1034
#define IDC_CHECK_AUTO_CREATE           1035

// ScopeItemDef's Properties Page 2
#define IDD_PROPPAGE_SI_COLUMNS         1040
#define IDC_EDIT_SI_INDEX               1041
#define IDC_EDIT_SI_COLUMNTEXT          1042
#define IDC_EDIT_SI_COLUMNWIDTH         1043
#define IDC_CHECK_SI_AUTOWIDTH          1044
#define IDC_EDIT_SI_COLUMNKEY           1045
#define IDC_SPIN_SI_INDEX               1046
#define IDC_BUTTON_SI_INSERT_COLUMN     1047
#define IDC_BUTTON_SI_REMOVE_COLUMN     1048

// ListView Property Page 1
#define IDD_PROPPAGE_LV_GENERAL         1050
#define IDC_EDIT_LV_NAME                1051
#define IDC_EDIT_LV_VIEWMENUTEXT        1052
#define IDC_COMBO_LV_VIEWS              1053
#define IDC_CHECK_LV_VIRTUAL_LIST       1054
#define IDC_CHECK_LV_ADDTOVIEWMENU      1055
#define IDC_EDIT_LV_STATUSBARTEXT       1056

// ListView Property Page 2
#define IDD_PROPPAGE_LV_IMAGELISTS      1057
#define IDC_COMBO_LV_LARGE_ICONS        1058
#define IDC_COMBO_LV_SMALL_ICONS        1059

// ListView Property Page 3
#define IDD_PROPPAGE_LV_SORTING         1060
#define IDC_CHECK_LV_SORTED             1061
#define IDC_COMBO_LV_KEY                1062
#define IDC_COMBO_LV_SORT               1063

// ListView Property Page 4
#define IDD_PROPPAGE_LV_COLUMNS         1065
#define IDC_EDIT_LV_COLUMNTEXT          1066
#define IDC_EDIT_LV_INDEX               1067
#define IDC_SPIN_LV_INDEX               1068
#define IDC_BUTTON_LV_INSERT_COLUMN     1069
#define IDC_BUTTON_LV_REMOVE_COLUMN     1070
#define IDC_EDIT_LV_COLUMNWIDTH         1071
#define IDC_EDIT_LV_COLUMNKEY           1072
#define IDC_CHECK_LV_AUTOWIDTH          1073

// URL View Property Page 1
#define IDD_PROPPAGE_URL_VIEW           1080
#define IDC_EDIT_URL_NAME               1081
#define IDC_EDIT_URL_URL                1082
#define IDC_CHECK_URL_ADDTOVIEWMENU     1083
#define IDC_EDIT_URL_VIEWMENUTEXT       1084
#define IDC_EDIT_URL_STATUSBARTEXT      1085

// OCX View Property Page 1
#define IDD_PROPPAGE_OCX_VIEW           1090
#define IDC_EDIT_OCX_NAME               1091
#define IDC_EDIT_OCX_PROGID             1092
#define IDC_CHECK_OCX_ADDTOVIEWMENU     1093
#define IDC_EDIT_OCX_VIEWMENUTEXT       1094
#define IDC_EDIT_OCX_STATUSBARTEXT      1095

// Image List Property Page 1
#define IDD_PROPPAGE_IL_IMAGES          1110
#define IDC_EDIT_IL_INDEX               1111
#define IDC_EDIT_IL_KEY                 1112
#define IDC_EDIT_IL_TAG                 1113
#define IDC_LIST_IL_IMAGES              1114
#define IDC_BUTTON_IL_INSERT_PICTURE    1115
#define IDC_BUTTON_IL_REMOVE_PICTURE    1116
#define IDC_EDIT_IL_IMAGE_COUNT         1117

// Taskpad View Property Page 1
#define IDD_PROPPAGE_TP_VIEW_GENERAL    1200
#define IDC_EDIT_TP_NAME                1201
#define IDC_EDIT_TP_TITLE               1202
#define IDC_EDIT_TP_DESCRIPTIVE_TEXT    1203
#define IDC_RADIO_TP_DEFAULT            1204
#define IDC_RADIO_TP_LISTPAD            1205
#define IDC_EDIT_TP_LP_TITLE            1206
#define IDC_CHECK_TP_USE_BUTTON         1207
#define IDC_EDIT_TP_LP_BUTTON_TEXT      1208
#define IDC_RADIO_TP_CUSTOM             1209
#define IDC_EDIT_TP_URL                 1210
#define IDC_CHECK_TP_USER_PREFERRED     1211
#define IDC_CHECK_TP_ADD_TO_VIEW        1212
#define IDC_EDIT_TP_VIEW_MENUTXT        1213
#define IDC_EDIT_TP_STATUSBARTEXT       1214

// Taskpad View Property Page 2
#define IDD_PROPPAGE_TP_VIEW_BACKGROUND 1220
#define IDC_RADIO_TP_NONE               1221
#define IDC_RADIO_TP_VANILLA            1222
#define IDC_RADIO_TP_CHOCOLATE          1223
#define IDC_RADIO_TP_BITMAP             1224
#define IDC_RADIO_TP_SYMBOL             1225
#define IDC_EDIT_TP_MOUSE_OVER          1226
#define IDC_EDIT_TP_FONT_FAMILY         1227
#define IDC_EDIT_TP_EOT                 1228
#define IDC_EDIT_TP_SYMBOL_STRING       1229

// Taskpad View Property Page 2
#define IDD_PROPPAGE_TP_VIEW_TASKS      1230
#define IDC_EDIT_TP_TASK_INDEX          1231
#define IDC_SPIN_TP_INDEX               1232
#define IDC_BUTTON_TP_INSERT_TASK       1233
#define IDC_BUTTON_TP_REMOVE_TASK       1234
#define IDC_EDIT_TP_TASK_KEY            1235
#define IDC_EDIT_TP_TASK_TEXT           1236
#define IDC_EDIT_TP_TASK_HELP_STRING    1237
#define IDC_EDIT_TP_TASK_TAG			1238
#define IDC_RADIO_TP_TASK_NOTIFY        1239
#define IDC_RADIO_TP_TASK_URL           1240
#define IDC_RADIO_TP_TASK_SCRIPT        1241
#define IDC_EDIT_TP_TASK_URL            1242
#define IDC_EDIT_TP_TASK_SCRIPT         1243
#define IDC_RADIO_TPT_VANILLA           1244
#define IDC_RADIO_TPT_CHOCOLATE         1245
#define IDC_RADIO_TPT_BITMAP            1246
#define IDC_RADIO_TPT_SYMBOL            1247
#define IDC_EDIT_TPT_MOUSE_OVER         1248
#define IDC_EDIT_TPT_MOUSE_OFF          1249
#define IDC_EDIT_TPT_FONT_FAMILY        1250
#define IDC_EDIT_TPT_EOT                1251
#define IDC_EDIT_TPT_SYMBOL_STRING      1252
#define IDC_COMBO_TP_LISTVIEW           1253

// Toolbar Property Page 1
#define IDD_PROPPAGE_TOOLBAR_GENERAL    1300
#define IDC_COMBO_TB_ILS                1301
#define IDC_EDIT_TB_TAG                 1302

// Toolbar Property Page 2
#define IDD_PROPPAGE_TOOLBAR_BUTTONS    1310
#define IDC_EDIT_TB_INDEX               1311
#define IDC_SPIN_TB_INDEX               1312
#define IDC_BUTTON_INSERT_BUTTON        1313
#define IDC_BUTTON_REMOVE_BUTTON        1314
#define IDC_EDIT_TB_CAPTION             1315
#define IDC_EDIT_TB_KEY                 1316
#define IDC_COMBO_TB_BUTTON_VALUE       1317
#define IDC_COMBO_TB_BUTTON_STYLE       1318
#define IDC_EDIT_TB_TOOLTIP_TEXT        1319
#define IDC_EDIT_TB_IMAGE               1320
#define IDC_EDIT_TB_BUTTON_TAG          1321
#define IDC_CHECK_TB_VISIBLE            1322
#define IDC_CHECK_TB_ENABLED            1323
#define IDC_CHECK_TB_MIXED_STATE        1324
#define IDC_EDIT_TB_MENU_INDEX          1325
#define IDC_SPIN_TB_MENU_INDEX          1326
#define IDC_BUTTON_INSERT_BUTTON_MENU   1327
#define IDC_BUTTON_REMOVE_BUTTON_MENU   1328
#define IDC_EDIT_TB_MENU_TEXT           1329
#define IDC_EDIT_TB_MENU_KEY            1330
#define IDC_EDIT_TB_MENU_TAG            1331
#define IDC_CHECK_TB_MENU_ENABLED       1332
#define IDC_CHECK_TB_MENU_VISIBLE       1333
#define IDC_CHECK_TB_MENU_CHECKED       1334
#define IDC_CHECK_TB_MENU_GRAYED        1335
#define IDC_CHECK_TB_MENU_SEPARATOR     1336
#define IDC_CHECK_TB_MENU_BREAK         1337
#define IDC_CHECK_TB_MENU_BAR_BREAK     1338


// Dialog Unit Converter
#define IDD_DIALOG_DLGUNITS             1400
#define IDC_EDIT_HEIGHT                 1401
#define IDC_EDIT_WIDTH                  1402
#define ID_BUTTON_CALC                  1403
#define IDC_STATIC_TWIPS_HEIGHT         1404
#define IDC_STATIC_POINTS_HEIGHT        1405
#define IDC_STATIC_PIXELS_HEIGHT        1406
#define IDC_STATIC_TWIPS_WIDTH          1407
#define IDC_STATIC_POINTS_WIDTH         1408
#define IDC_STATIC_PIXELS_WIDTH         1409




//=--------------------------------------------------------------------------=
//                                Menus
//=--------------------------------------------------------------------------=
#define IDR_MENU_ROOT                   2000
#define IDR_MENU_NODE                   2001
#define IDR_MENU_VIEW                   2002
#define IDR_NODE_CHILDREN               2003
#define IDR_NODE_VIEWS                  2004
#define IDR_NODE_OTHER                  2005
#define IDR_MENU_IMAGE_LIST             2006
#define IDR_MENU_MENU                   2007
#define IDR_MENU_TOOLBAR                2008
#define IDR_MENU_TOOLS                  2009
#define IDR_MENU_IMAGE_LISTS            2010
#define IDR_MENU_MENUS                  2011
#define IDR_MENU_TOOLBARS               2012
#define IDR_MENU_VIEWS                  2013
#define IDR_MENU_LIST_VIEWS             2014
#define IDR_MENU_TASKPAD_VIEWS          2015
#define IDR_MENU_OCX_VIEWS              2016
#define IDR_MENU_URL_VIEWS              2017
#define IDR_MENU_STATIC_NODE            2018
#define IDR_MENU_EXTENSIONS_ROOT        2019
#define IDR_MENU_EXTENSIONS             2020
#define IDR_MENU_THIS_EXTENSIONS        2021
#define IDR_MENU_RESOURCES              2022
#define IDR_MENU_RESOURCE               2023

//=--------------------------------------------------------------------------=
//                              Commands
//=--------------------------------------------------------------------------=
#define CMD_ADD_NODE                    3000
#define CMD_ADD_LISTVIEW                3001
#define CMD_ADD_TASKPAD                 3002
#define CMD_ADD_OCX_VIEW                3003
#define CMD_ADD_WEB_VIEW                3004

#define CMD_ADD_IMAGE_LIST              3010
#define CMD_ADD_TOOLBAR                 3011
#define CMD_ADD_MENU                    3012

#define CMD_VIEW_PROPERTIES             3020
#define CMD_DELETE                      3021
#define CMD_RENAME                      3022
#define CMD_ADD_CHILD_MENU              3023
#define CMD_PROMOTE                     3024
#define CMD_DEMOTE                      3025
#define CMD_MOVE_UP                     3026
#define CMD_MOVE_DOWN                   3027
#define CMD_VIEW_DLGUNITS               3028

#define CMD_EXT_CM_NEW                  3050
#define CMD_EXT_CM_TASK                 3051
#define CMD_EXT_PPAGES                  3052
#define CMD_EXT_TASKPAD                 3053
#define CMD_EXT_TOOLBAR                 3054
#define CMD_EXT_NAMESPACE               3055

#define CMD_EXTE_NEW_MENU               3060
#define CMD_EXTE_TASK_MENU              3061
#define CMD_EXTE_TOP_MENU               3062
#define CMD_EXTE_VIEW_MENU              3063
#define CMD_EXTE_PPAGES                 3064
#define CMD_EXTE_TOOLBAR                3065
#define CMD_EXTE_NAMESPACE              3066

#define CMD_ADD_RESOURCE                3070
#define CMD_VIEW_RESOURCE_REFRESH       3071

#endif // _RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\selhold.cpp ===
//=--------------------------------------------------------------------------------------
// SelHold.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSelectionHolder implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "SelHold.h"

// for ASSERT and FAIL
//
SZTHISFILE


CSelectionHolder::CSelectionHolder() : m_st(SEL_NONE), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    m_piObject.m_lDummy = 0;
}


CSelectionHolder::CSelectionHolder(SelectionType st) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
}


CSelectionHolder::CSelectionHolder(SelectionType st, ISnapInDef *piSnapInDef) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piSnapInDef != NULL, "piSnapInDef is NULL");

    m_piObject.m_piSnapInDef = piSnapInDef;
    m_piObject.m_piSnapInDef->AddRef();

}


CSelectionHolder::CSelectionHolder(SelectionType st, IExtensionDefs *piExtensionDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piExtensionDefs != NULL, "piExtensionDefs is NULL");

    m_piObject.m_piExtensionDefs = piExtensionDefs;
    if (m_piObject.m_piExtensionDefs != NULL)
        m_piObject.m_piExtensionDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IExtendedSnapIn *piExtendedSnapIn) : m_st(SEL_EEXTENSIONS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piExtendedSnapIn != NULL, "piExtendedSnapIn is NULL");

    m_piObject.m_piExtendedSnapIn = piExtendedSnapIn;
    if (m_piObject.m_piExtendedSnapIn != NULL)
        m_piObject.m_piExtendedSnapIn->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IExtendedSnapIn *piExtendedSnapIn) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piExtendedSnapIn != NULL, "piExtendedSnapIn is NULL");

    m_piObject.m_piExtendedSnapIn = piExtendedSnapIn;
    if (m_piObject.m_piExtendedSnapIn != NULL)
        m_piObject.m_piExtendedSnapIn->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IScopeItemDefs *pScopeItemDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pScopeItemDefs != NULL, "pScopeItemDefs is NULL");

    m_piObject.m_piScopeItemDefs = pScopeItemDefs;
    if (m_piObject.m_piScopeItemDefs != NULL)
        m_piObject.m_piScopeItemDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IScopeItemDef *pScopeItemDef) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pScopeItemDef != NULL, "pScopeItemDef is NULL");

    m_piObject.m_piScopeItemDef = pScopeItemDef;
    if (m_piObject.m_piScopeItemDef != NULL)
        m_piObject.m_piScopeItemDef->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IListViewDefs *pListViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pListViewDefs != NULL, "pListViewDefs is NULL");

    m_piObject.m_piListViewDefs = pListViewDefs;
    if (m_piObject.m_piListViewDefs != NULL)
        m_piObject.m_piListViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IListViewDef *pListViewDef) : m_st(SEL_VIEWS_LIST_VIEWS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pListViewDef != NULL, "pListViewDef is NULL");

    m_piObject.m_piListViewDef = pListViewDef;
    if (m_piObject.m_piListViewDef != NULL)
        m_piObject.m_piListViewDef->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IURLViewDefs *pURLViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pURLViewDefs != NULL, "pURLViewDefs is NULL");

    m_piObject.m_piURLViewDefs = pURLViewDefs;
    if (m_piObject.m_piURLViewDefs != NULL)
        m_piObject.m_piURLViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IURLViewDef *pURLViewDef) : m_st(SEL_VIEWS_URL_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pURLViewDef != NULL, "pURLViewDef is NULL");

    m_piObject.m_piURLViewDef = pURLViewDef;
    if (m_piObject.m_piURLViewDef != NULL)
        m_piObject.m_piURLViewDef->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IOCXViewDefs *pOCXViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pOCXViewDefs != NULL, "pOCXViewDefs is NULL");

    m_piObject.m_piOCXViewDefs = pOCXViewDefs;
    if (m_piObject.m_piOCXViewDefs != NULL)
        m_piObject.m_piOCXViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IOCXViewDef *pOCXViewDef) : m_st(SEL_VIEWS_OCX_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pOCXViewDef != NULL, "pOCXViewDef is NULL");

    m_piObject.m_piOCXViewDef = pOCXViewDef;
    if (m_piObject.m_piOCXViewDef != NULL)
        m_piObject.m_piOCXViewDef->AddRef();
}

CSelectionHolder::CSelectionHolder(SelectionType st, ITaskpadViewDefs *pTaskpadViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pTaskpadViewDefs != NULL, "pTaskpadViewDefs is NULL");

    m_piObject.m_piTaskpadViewDefs = pTaskpadViewDefs;
    if (m_piObject.m_piTaskpadViewDefs != NULL)
        m_piObject.m_piTaskpadViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(ITaskpadViewDef *pTaskpadViewDef) : m_st(SEL_VIEWS_TASK_PAD_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pTaskpadViewDef != NULL, "pTaskpadViewDef is NULL");

    m_piObject.m_piTaskpadViewDef = pTaskpadViewDef;
    if (m_piObject.m_piTaskpadViewDef != NULL)
        m_piObject.m_piTaskpadViewDef->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCImageLists *pMMCImageLists) : m_st(SEL_TOOLS_IMAGE_LISTS), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCImageLists != NULL, "pMMCImageLists is NULL");

    m_piObject.m_piMMCImageLists = pMMCImageLists;
    if (m_piObject.m_piMMCImageLists != NULL)
        m_piObject.m_piMMCImageLists->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCImageList *pMMCImageList) : m_st(SEL_TOOLS_IMAGE_LISTS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCImageList != NULL, "pMMCImageList is NULL");

    m_piObject.m_piMMCImageList = pMMCImageList;
    if (m_piObject.m_piMMCImageList != NULL)
        m_piObject.m_piMMCImageList->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCMenus *pMMCMenus) : m_st(SEL_TOOLS_MENUS), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCMenus != NULL, "pMMCMenus is NULL");

    m_piObject.m_piMMCMenus = pMMCMenus;
    if (m_piObject.m_piMMCMenus != NULL)
        m_piObject.m_piMMCMenus->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCMenu *pMMCMenu, IMMCMenus *piChildrenMenus) : m_st(SEL_TOOLS_MENUS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCMenu != NULL, "pMMCMenu is NULL");
    ASSERT(piChildrenMenus != NULL, "piChildrenMenus is NULL");

    m_piObject.m_piMMCMenu = pMMCMenu;
    if (m_piObject.m_piMMCMenu != NULL)
    {
        m_piObject.m_piMMCMenu->AddRef();

        m_piChildrenMenus = piChildrenMenus;
        m_piChildrenMenus->AddRef();
    }
}


CSelectionHolder::CSelectionHolder(IMMCToolbars *pMMCToolbars) : m_st(SEL_TOOLS_TOOLBARS), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCToolbars != NULL, "pMMCToolbars is NULL");

    m_piObject.m_piMMCToolbars = pMMCToolbars;
    if (m_piObject.m_piMMCToolbars != NULL)
        m_piObject.m_piMMCToolbars->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCToolbar *pMMCToolbar) : m_st(SEL_TOOLS_TOOLBARS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCToolbar != NULL, "pMMCToolbar is NULL");

    m_piObject.m_piMMCToolbar = pMMCToolbar;
    if (m_piObject.m_piMMCToolbar != NULL)
        m_piObject.m_piMMCToolbar->AddRef();
}


CSelectionHolder::CSelectionHolder(IDataFormats *pDataFormats) : m_st(SEL_XML_RESOURCES), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pDataFormats != NULL, "pDataFormats is NULL");

    m_piObject.m_piDataFormats = pDataFormats;
    if (m_piObject.m_piDataFormats != NULL)
        m_piObject.m_piDataFormats->AddRef();
}


CSelectionHolder::CSelectionHolder(IDataFormat *pDataFormat) : m_st(SEL_XML_RESOURCE_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pDataFormat != NULL, "pDataFormat is NULL");

    m_piObject.m_piDataFormat = pDataFormat;
    if (m_piObject.m_piDataFormat != NULL)
        m_piObject.m_piDataFormat->AddRef();
}


CSelectionHolder::~CSelectionHolder()
{
    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        RELEASE(m_piObject.m_piSnapInDef);
        break;

    case SEL_EXTENSIONS_ROOT:
    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:
        RELEASE(m_piObject.m_piExtensionDefs);
        break;

    case SEL_EEXTENSIONS_NAME:
    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:
        RELEASE(m_piObject.m_piExtendedSnapIn);
        break;

    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_OTHER:
	case SEL_NODES_ANY_CHILDREN:
        RELEASE(m_piObject.m_piScopeItemDefs);
        break;

    case SEL_NODES_ANY_NAME:
	case SEL_NODES_ANY_VIEWS:
        RELEASE(m_piObject.m_piScopeItemDef);
        break;

    case SEL_VIEWS_LIST_VIEWS:
        RELEASE(m_piObject.m_piListViewDefs);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        RELEASE(m_piObject.m_piListViewDef);
        break;

    case SEL_VIEWS_OCX:
        RELEASE(m_piObject.m_piOCXViewDefs);
        break;

    case SEL_VIEWS_OCX_NAME:
        RELEASE(m_piObject.m_piOCXViewDef);
        break;

    case SEL_VIEWS_URL:
        RELEASE(m_piObject.m_piURLViewDefs);
        break;

    case SEL_VIEWS_URL_NAME:
        RELEASE(m_piObject.m_piURLViewDef);
        break;

    case SEL_VIEWS_TASK_PAD:
        RELEASE(m_piObject.m_piTaskpadViewDefs);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        RELEASE(m_piObject.m_piTaskpadViewDef);
        break;

    case SEL_TOOLS_IMAGE_LISTS:
        RELEASE(m_piObject.m_piMMCImageLists);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        RELEASE(m_piObject.m_piMMCImageList);
        break;

    case SEL_TOOLS_MENUS:
        RELEASE(m_piObject.m_piMMCMenus);
        break;

    case SEL_TOOLS_MENUS_NAME:
        RELEASE(m_piObject.m_piMMCMenu);
        RELEASE(m_piChildrenMenus);
        break;

    case SEL_TOOLS_TOOLBARS:
        RELEASE(m_piObject.m_piMMCToolbars);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        RELEASE(m_piObject.m_piMMCToolbar);
        break;

    case SEL_XML_RESOURCES:
        RELEASE(m_piObject.m_piDataFormats);
        break;

    case SEL_XML_RESOURCE_NAME:
        RELEASE(m_piObject.m_piDataFormat);
        break;
    }
}



void CSelectionHolder::SetInUpdate(BOOL fInUpdate)
{
    m_fInUpdate = fInUpdate;
}



BOOL CSelectionHolder::InUpdate()
{
    return m_fInUpdate;
}


HRESULT CSelectionHolder::RegisterHolder()
{
    HRESULT              hr = S_OK;
    IUnknown            *piUnknown = NULL;
    IMMCMenu            *piMMCMenu = NULL;
    ITaskpad            *piTaskpad = NULL;
    IExtendedSnapIns    *piIExtendedSnapIns = NULL;

    hr = GetIUnknown(&piUnknown);
    IfFailGo(hr);

    hr = InternalRegisterHolder(piUnknown);
    IfFailGo(hr);

    if (SEL_EXTENSIONS_ROOT == m_st)
    {
        hr = m_piObject.m_piExtensionDefs->get_ExtendedSnapIns(&piIExtendedSnapIns);
        IfFailGo(hr);

        RELEASE(piUnknown);
        hr = piIExtendedSnapIns->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        hr = InternalRegisterHolder(piUnknown);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == m_st)
    {
        RELEASE(piUnknown);
        hr = m_piChildrenMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        hr = InternalRegisterHolder(piUnknown);
        IfFailGo(hr);
    }
    else if (SEL_VIEWS_TASK_PAD_NAME == m_st)
    {
        hr = m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        RELEASE(piUnknown);
        hr = piTaskpad->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        hr = InternalRegisterHolder(piUnknown);
        IfFailGo(hr);
    }

Error:
    RELEASE(piIExtendedSnapIns);
    RELEASE(piTaskpad);
    RELEASE(piMMCMenu);
    RELEASE(piUnknown);

    RRETURN(hr);
}

HRESULT CSelectionHolder::InternalRegisterHolder(IUnknown *piUnknown)
{
    HRESULT        hr = S_OK;
    IObjectModel  *piObjectModel = NULL;
    long           lCookie = 0;

    hr = piUnknown->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    lCookie = 0;
    hr = piObjectModel->GetCookie(&lCookie);
    IfFailGo(hr);

    if (0 == lCookie)
    {
        hr = piObjectModel->SetCookie(reinterpret_cast<long>(this));
        IfFailGo(hr);
    }

Error:
    RELEASE(piObjectModel);

    RRETURN(hr);
}

HRESULT CSelectionHolder::UnregisterHolder()
{
    HRESULT        hr = S_OK;
    IUnknown      *piUnknown = NULL;
    IObjectModel  *piObjectModel = NULL;
    long           lCookie = 0;

    hr = GetIUnknown(&piUnknown);
    IfFailGo(hr);

    hr = piUnknown->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(0);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS_NAME == m_st)
    {
        RELEASE(piUnknown);
        hr = m_piChildrenMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        RELEASE(piObjectModel);
        hr = m_piChildrenMenus->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        lCookie = 0;
        hr = piObjectModel->SetCookie(0);
        IfFailGo(hr);
    }

Error:
    RELEASE(piObjectModel);
    RELEASE(piUnknown);

    RRETURN(hr);
}


HRESULT CSelectionHolder::GetIUnknown(IUnknown **ppiUnknown)
{
    HRESULT     hr = S_FALSE;

    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        hr = m_piObject.m_piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EXTENSIONS_ROOT:
    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtensionDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EEXTENSIONS_NAME:
    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtendedSnapIn->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_ANY_NAME:
	case SEL_NODES_ANY_VIEWS:
        hr = m_piObject.m_piScopeItemDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_OTHER:
	case SEL_NODES_ANY_CHILDREN:
        hr = m_piObject.m_piScopeItemDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS:
        hr = m_piObject.m_piListViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = m_piObject.m_piListViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX:
        hr = m_piObject.m_piOCXViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = m_piObject.m_piOCXViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL:
        hr = m_piObject.m_piURLViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL_NAME:
        hr = m_piObject.m_piURLViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD:
        hr = m_piObject.m_piTaskpadViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_piObject.m_piTaskpadViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS:
        hr = m_piObject.m_piMMCImageLists->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = m_piObject.m_piMMCImageList->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS:
        hr = m_piObject.m_piMMCMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = m_piObject.m_piMMCMenu->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS:
        hr = m_piObject.m_piMMCToolbars->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = m_piObject.m_piMMCToolbar->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCES:
        hr = m_piObject.m_piDataFormats->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = m_piObject.m_piDataFormat->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;
    }

    RRETURN(hr);
}


HRESULT CSelectionHolder::GetSelectableObject(IUnknown **ppiUnknown)
{
    HRESULT     hr = S_FALSE;
    ITaskpad   *piTaskpad = NULL;
    IMMCMenu   *piMMCMenu = NULL;

    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        hr = m_piObject.m_piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EXTENSIONS_ROOT:
    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtensionDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EEXTENSIONS_NAME:
    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtendedSnapIn->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_ANY_NAME:
	case SEL_NODES_ANY_VIEWS:
        hr = m_piObject.m_piScopeItemDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_OTHER:
	case SEL_NODES_ANY_CHILDREN:
        hr = m_piObject.m_piScopeItemDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS:
        hr = m_piObject.m_piListViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = m_piObject.m_piListViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX:
        hr = m_piObject.m_piOCXViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = m_piObject.m_piOCXViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL:
        hr = m_piObject.m_piURLViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL_NAME:
        hr = m_piObject.m_piURLViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD:
        hr = m_piObject.m_piTaskpadViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        hr = piTaskpad->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS:
        hr = m_piObject.m_piMMCImageLists->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = m_piObject.m_piMMCImageList->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS:
        hr = m_piObject.m_piMMCMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = m_piObject.m_piMMCMenu->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS:
        hr = m_piObject.m_piMMCToolbars->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = m_piObject.m_piMMCToolbar->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCES:
        hr = m_piObject.m_piDataFormats->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = m_piObject.m_piDataFormat->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;
    }

Error:
    RELEASE(piMMCMenu);
    RELEASE(piTaskpad);

    RRETURN(hr);
}


HRESULT CSelectionHolder::GetName(BSTR *pbstrName)
{
    HRESULT     hr = S_FALSE;
    IMMCMenu   *piMMCMenu = NULL;

    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        hr = m_piObject.m_piSnapInDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = m_piObject.m_piScopeItemDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = m_piObject.m_piListViewDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = m_piObject.m_piOCXViewDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = m_piObject.m_piURLViewDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_piObject.m_piTaskpadViewDef->get_Key(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = m_piObject.m_piMMCImageList->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = m_piObject.m_piMMCMenu->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = m_piObject.m_piMMCToolbar->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = m_piObject.m_piDataFormat->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "GetName: Object does not support this function");
    }

Error:
    RELEASE(piMMCMenu);

    RRETURN(hr);
}


bool CSelectionHolder::IsEqual(const CSelectionHolder *pHolder) const
{
    if (m_st != pHolder->m_st)
        return false;

    if (m_piObject.m_lDummy != pHolder->m_piObject.m_lDummy)
        return false;

    return true;
}


bool CSelectionHolder::IsNotEqual(const CSelectionHolder *pHolder) const
{
    if (m_st != pHolder->m_st)
        return true;

    if (m_piObject.m_lDummy != pHolder->m_piObject.m_lDummy)
        return true;

    return false;
}


bool CSelectionHolder::IsVirtual() const
{
    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:

    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:

    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:

    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_NODES_OTHER:
    case SEL_NODES_ANY_CHILDREN:
    case SEL_NODES_ANY_VIEWS:

    case SEL_TOOLS_ROOT:
    case SEL_TOOLS_IMAGE_LISTS:
    case SEL_TOOLS_MENUS:
    case SEL_TOOLS_TOOLBARS:

    case SEL_VIEWS_ROOT:
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:

    case SEL_XML_RESOURCES:
        return true;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\selhold.h ===
//=--------------------------------------------------------------------------------------
// SelHold.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSelectionHolder declaration
//=-------------------------------------------------------------------------------------=

#ifndef _SELECTIONHOLDER_H_
#define _SELECTIONHOLDER_H_


////////////////////////////////////////////////////////////////////////////////////
// SelectionHolder
//
// There is one SelectionType for each kind of node in the Snap-In Designer tree
//
typedef enum tagSELECTION_TYPE
{
	SEL_NONE                    =  0,

	SEL_SNAPIN_ROOT             =  1,

    SEL_EXTENSIONS_ROOT         = 10,    // Extensions

    SEL_EEXTENSIONS_NAME        = 11,    // Extensions/<Extended snap-in>
    SEL_EEXTENSIONS_CC_ROOT     = 12,    // Extensions/<Extended snap-in>/Context Menus
    SEL_EEXTENSIONS_CC_NEW      = 13,    // Extensions/<Extended snap-in>/Context Menus/New
    SEL_EEXTENSIONS_CC_TASK     = 14,    // Extensions/<Extended snap-in>/Context Menus/Task
    SEL_EEXTENSIONS_PP_ROOT     = 15,    // Extensions/<Extended snap-in>/Property Pages
    SEL_EEXTENSIONS_TASKPAD     = 16,    // Extensions/<Extended snap-in>/Taskpad
    SEL_EEXTENSIONS_TOOLBAR     = 17,    // Extensions/<Extended snap-in>/Toolbar
    SEL_EEXTENSIONS_NAMESPACE   = 18,    // Extensions/<Extended snap-in>/NameSpace

    SEL_EXTENSIONS_MYNAME       = 20,    // Extensions/<Snap-in Name>
    SEL_EXTENSIONS_NEW_MENU     = 21,    // Extensions/<Snap-in Name>/ExtendsNewMenu
    SEL_EXTENSIONS_TASK_MENU    = 22,    // Extensions/<Snap-in Name>/ExtendsTaskMenu
    SEL_EXTENSIONS_TOP_MENU     = 23,    // Extensions/<Snap-in Name>/ExtendsTopMenu
    SEL_EXTENSIONS_VIEW_MENU    = 24,    // Extensions/<Snap-in Name>/ExtendsViewMenu
    SEL_EXTENSIONS_PPAGES       = 25,    // Extensions/<Snap-in Name>/ExtendsPropertyPages
    SEL_EXTENSIONS_TOOLBAR      = 26,    // Extensions/<Snap-in Name>/ExtendsToolbar
    SEL_EXTENSIONS_NAMESPACE    = 27,    // Extensions/<Snap-in Name>/ExtendsNameSpace

    SEL_NODES_ROOT              = 40,    // Nodes
    SEL_NODES_AUTO_CREATE       = 41,    // Nodes/AutoCreate
    SEL_NODES_AUTO_CREATE_ROOT  = 42,    // Nodes/AutoCreate/Root
    SEL_NODES_AUTO_CREATE_RTCH  = 43,    // Nodes/AutoCreate/Root/Children
    SEL_NODES_AUTO_CREATE_RTVW  = 44,    // Nodes/AutoCreate/Root/Views
    SEL_NODES_OTHER             = 45,    // Nodes/Other
    SEL_NODES_ANY_NAME          = 46,    // Nodes/<any>/<node name>
    SEL_NODES_ANY_CHILDREN      = 47,    // Nodes/<any>/<any>/Children
    SEL_NODES_ANY_VIEWS         = 48,    // Nodes/<any>/<any>/Views

    SEL_TOOLS_ROOT              = 50,    // Tools
    SEL_TOOLS_IMAGE_LISTS       = 51,    // Tools/Image Lists
    SEL_TOOLS_IMAGE_LISTS_NAME  = 52,    // Tools/Image Lists/<image list name>
    SEL_TOOLS_MENUS             = 53,    // Tools/Menus
    SEL_TOOLS_MENUS_NAME        = 54,    // Tools/Menus/<menu name>
    SEL_TOOLS_TOOLBARS          = 55,    // Tools/Toolbars
    SEL_TOOLS_TOOLBARS_NAME     = 56,    // Tools/Toolbars/<toolbar name>

    SEL_VIEWS_ROOT              = 60,    // Views
    SEL_VIEWS_LIST_VIEWS        = 61,    // Views/List Views
    SEL_VIEWS_LIST_VIEWS_NAME   = 62,    // Views/List Views/<view name>
    SEL_VIEWS_OCX               = 63,    // Views/OCX Views
    SEL_VIEWS_OCX_NAME          = 64,    // Views/OCX Views/<view name>
    SEL_VIEWS_URL               = 65,    // Views/URL Views
    SEL_VIEWS_URL_NAME          = 66,    // Views/URL Views/<view name>
    SEL_VIEWS_TASK_PAD          = 67,    // Views/Taskpad Views
    SEL_VIEWS_TASK_PAD_NAME     = 68,    // Views/Taskpad Views/<view name>

    SEL_XML_RESOURCES           = 70,    // Resources
    SEL_XML_RESOURCE_NAME       = 71     // Resource/<resource name>
} SelectionType;


class CSelectionHolder : public CtlNewDelete
{
public:
    CSelectionHolder();
    CSelectionHolder(SelectionType st);
    CSelectionHolder(SelectionType st, ISnapInDef *piSnapInDef);

    CSelectionHolder(SelectionType st, IExtensionDefs *piExtensionDefs);
    CSelectionHolder(IExtendedSnapIn *piExtendedSnapIn);
    CSelectionHolder(SelectionType st, IExtendedSnapIn *piExtendedSnapIn);

    CSelectionHolder(SelectionType st, IScopeItemDefs *pScopeItemDefs);
    CSelectionHolder(SelectionType st, IScopeItemDef *pScopeItemDef);

    CSelectionHolder(SelectionType st, IListViewDefs *pListViewDefs);
    CSelectionHolder(IListViewDef *pListViewDef);
    CSelectionHolder(SelectionType st, IURLViewDefs *pURLViewDefs);
    CSelectionHolder(IURLViewDef *pURLViewDef);
    CSelectionHolder(SelectionType st, IOCXViewDefs *pOCXViewDefs);
    CSelectionHolder(IOCXViewDef *pOCXViewDef);
    CSelectionHolder(SelectionType st, ITaskpadViewDefs *pTaskpadViewDefs);
    CSelectionHolder(ITaskpadViewDef *pTaskpadViewDef);

    CSelectionHolder(IMMCImageLists *pMMCImageLists);
    CSelectionHolder(IMMCImageList *pMMCImageList);
    CSelectionHolder(IMMCMenus *pMMCMenus);
    CSelectionHolder(IMMCMenu *pMMCMenu, IMMCMenus *piChildrenMenus);
    CSelectionHolder(IMMCToolbars *pMMCToolbars);
    CSelectionHolder(IMMCToolbar *pMMCToolbar);

    CSelectionHolder(IDataFormats *pDataFormats);
    CSelectionHolder(IDataFormat *pDataFormat);

    ~CSelectionHolder();

public:
    bool IsEqual(const CSelectionHolder *pHolder) const;
    bool IsNotEqual(const CSelectionHolder *pHolder) const;

    bool IsVirtual() const;

    HRESULT RegisterHolder();
    HRESULT InternalRegisterHolder(IUnknown *piUnknown);
	HRESULT UnregisterHolder();
    HRESULT GetIUnknown(IUnknown **ppiUnknown);
    HRESULT GetSelectableObject(IUnknown **ppiUnknown);
    HRESULT GetName(BSTR *pbstrName);
    void SetInUpdate(BOOL fInUpdate);
    BOOL InUpdate();

public:
    SelectionType   m_st;
    BOOL            m_fInUpdate;
    void           *m_pvData;
    union
    {
        ISnapInDef            *m_piSnapInDef;
        IExtensionDefs        *m_piExtensionDefs;
        IExtendedSnapIn       *m_piExtendedSnapIn;
        IScopeItemDefs        *m_piScopeItemDefs;
        IScopeItemDef         *m_piScopeItemDef;
        IListViewDefs         *m_piListViewDefs;
        IListViewDef          *m_piListViewDef;
        IURLViewDefs          *m_piURLViewDefs;
        IURLViewDef           *m_piURLViewDef;
        IOCXViewDefs          *m_piOCXViewDefs;
        IOCXViewDef           *m_piOCXViewDef;
        ITaskpadViewDefs      *m_piTaskpadViewDefs;
        ITaskpadViewDef       *m_piTaskpadViewDef;
        IMMCImageLists        *m_piMMCImageLists;
        IMMCImageList         *m_piMMCImageList;
        IMMCMenus             *m_piMMCMenus;
        IMMCMenu              *m_piMMCMenu;
		IMMCToolbars          *m_piMMCToolbars;
		IMMCToolbar           *m_piMMCToolbar;
		IDataFormats          *m_piDataFormats;
		IDataFormat           *m_piDataFormat;
        long                   m_lDummy;
    } m_piObject;
    IMMCMenus   *m_piChildrenMenus;
};

#endif // _SELECTIONHOLDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\stub_mssnapr_i.c ===
#include <mssnapr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\snaputil.cpp ===
//=--------------------------------------------------------------------------=
// snaputil.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Utitlity Routines for the SnapIn Designer
//

#include "pch.h"
#include "common.h"
#include "desmain.h"

// for ASSERT and FAIL
//
SZTHISFILE


CGlobalHelp g_GlobalHelp;

IHelp *CGlobalHelp::m_pIHelp = NULL;
DWORD  CGlobalHelp::m_cSnapInDesigners = 0;
char   CGlobalHelp::m_szDesignerName[256] = "Snap-in Designer";
BOOL   CGlobalHelp::m_fHaveDesignerName = FALSE;

CGlobalHelp::CGlobalHelp()
{
    m_pIHelp = NULL;
}

CGlobalHelp::~CGlobalHelp()
{
    RELEASE(m_pIHelp);
}

VOID CALLBACK CGlobalHelp::MsgBoxCallback(LPHELPINFO lpHelpInfo)
{
    ShowHelp(lpHelpInfo->dwContextId);
}

HRESULT CGlobalHelp::ShowHelp(DWORD dwHelpContextId)
{
    HRESULT hr = S_OK;

    if (NULL != m_pIHelp)
    {
        hr = m_pIHelp->ShowHelp(HELP_FILENAME_WIDE, 
                                HELP_CONTEXT, 
                                dwHelpContextId);
    }

    return hr;
}

void CGlobalHelp::Attach(IHelp* pIHelp)
{
    if(m_pIHelp == NULL)
    {
        pIHelp->AddRef();

        m_pIHelp = pIHelp;
    }
    else
    {
        m_pIHelp->AddRef();
    }

    m_cSnapInDesigners++;
}

void CGlobalHelp::Detach()
{
    QUICK_RELEASE(m_pIHelp);
    m_cSnapInDesigners--;
    if (0 == m_cSnapInDesigners)
    {
        m_pIHelp = NULL;
    }
}

//=--------------------------------------------------------------------------=
// CGlobalHelp::GetDesignerName
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      Pointer to null terminates string containing designer name. This
//      pointer is guaranteed to be valid.
//
// Notes:
//
// If designer name has not yet been loaded from the resource DLL then loads it.
// If load fails then designer name will be default English string set in its
// initialization at the top of this file.
//

char *CGlobalHelp::GetDesignerName()
{
    if (!m_fHaveDesignerName)
    {
        (void)::LoadString(::GetResourceHandle(), 
                           IDS_DESIGNER_NAME,
                           m_szDesignerName,
                           sizeof(m_szDesignerName) / sizeof(m_szDesignerName[0]));
        m_fHaveDesignerName = TRUE;
    }
    return m_szDesignerName;
}


//=--------------------------------------------------------------------------=
// SDU_DisplayMessage
//=--------------------------------------------------------------------------=
//
// Parameters:
//      UINT   idMessage        [in]  resource ID of message format string
//      UINT   uMsgBoxOpts      [in]  MB_OK etc.
//      DWORD  dwHelpContextID  [in]  Help Context ID
//      int   *pMsgBoxRet       [out] IDOK, IDCANCEL etc, returned here
//      ...                     [in]  arguments for % replacements in string
//
// Output:
//      HRESULT
//
// Notes:
//
// Formats message from string table using Win32 FormatMessage API and displays
// it in a message box with a help button (automatically adds MB_HELP). If the
// string has replacements then they must use FormatMessage style e.g.
//
// "The file %1!s! for %2!s! is missing from the project directory."
//
// All messages displayed by the designer must use this function. Doing so
// guarantees that localization and help support have been handled correctly.
//
// How to Create a New Message
// ===========================
// 1. Add a string to a STRINGTABLE in the mssnapd.rc
// 2. Add an ID string that matches the name in mssnapd.id
// 3. Call this function passing the string's resource ID and HID_Xxxx where
// Xxxx is the ID string added mssnapd.id.
//

HRESULT cdecl SDU_DisplayMessage
(
    UINT            idMessage,
    UINT            uMsgBoxOpts,
    DWORD           dwHelpContextID,
    HRESULT         hrDisplay,
    MessageOptions  Option,
    int            *pMsgBoxRet,
    ...
)
{
    HRESULT      hr = S_OK;
    int          MsgBoxRet = 0;
    DWORD        cchMsg = 0;
    char         szMessage[2048];
    char        *pszFormattedMessage = NULL;
    char        *pszDisplayMessage = "An error occurred in the Snap-in Designer but the error message could not be loaded.";
    int          nRet = 0;
    IErrorInfo  *piErrorInfo = NULL;
    BSTR         bstrSource = NULL;
    BSTR         bstrDescription = NULL;

    MSGBOXPARAMS mbp;
    ::ZeroMemory(&mbp, sizeof(mbp));

    va_list pArgList;
    va_start(pArgList, pMsgBoxRet);

    mbp.dwContextHelpId = dwHelpContextID;

    cchMsg = (DWORD)::LoadString(::GetResourceHandle(), 
                                 idMessage,
                                 szMessage,
                                 sizeof(szMessage) / sizeof(szMessage[0]));
    IfFalseGoto(0 < cchMsg, S_OK, Display);

    cchMsg = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_STRING,
                             szMessage,
                             0, // no message ID, passing string
                             0, // no language ID, passing string
                             (LPTSTR)&pszFormattedMessage,
                             0, // minimum buffer size
                             &pArgList);

    IfFalseGoto(0 < cchMsg, S_OK, Display);
    pszFormattedMessage = pszDisplayMessage;

    if ( (AppendErrorInfo == Option) & (cchMsg < sizeof(szMessage) - 1) )
    {
        ::strcpy(szMessage, pszFormattedMessage);
        IfFailGoto(::GetErrorInfo(0, &piErrorInfo), Display);
        IfFalseGoto(NULL != piErrorInfo, S_OK, Display);
        IfFailGoto(piErrorInfo->GetHelpContext(&mbp.dwContextHelpId), Display);
        IfFailGoto(piErrorInfo->GetSource(&bstrSource), Display);
        IfFailGoto(piErrorInfo->GetDescription(&bstrDescription), Display);
        IfFalseGoto(NULL != bstrSource, S_OK, Display);
        IfFalseGoto(NULL != bstrDescription, S_OK, Display);
        _snprintf(&szMessage[cchMsg], sizeof(szMessage) - cchMsg - 1,
                  "\r\nError &H%08.8X (%u) %S: %S", hrDisplay, HRESULT_CODE(hrDisplay), bstrSource, bstrDescription);
        pszDisplayMessage = szMessage;
    }

Display:
    
    mbp.cbSize = sizeof(mbp);
    mbp.hwndOwner = ::GetActiveWindow();
    mbp.hInstance = ::GetResourceHandle();
    mbp.lpszText = pszDisplayMessage;
    mbp.lpszCaption = CGlobalHelp::GetDesignerName();
    mbp.dwStyle = uMsgBoxOpts | MB_HELP;
    mbp.lpfnMsgBoxCallback = CGlobalHelp::MsgBoxCallback;
    mbp.dwLanguageId = LANGIDFROMLCID(g_lcidLocale);

    MsgBoxRet = ::MessageBoxIndirect(&mbp);
    IfFalseGo(0 != MsgBoxRet, HRESULT_FROM_WIN32(GetLastError()));

    if(pMsgBoxRet != NULL)
    {
        *pMsgBoxRet = MsgBoxRet;
    }

Error:

    va_end(pArgList);

    if (NULL != pszFormattedMessage)
    {
        ::LocalFree(pszFormattedMessage);
    }
    QUICK_RELEASE(piErrorInfo);
    return hr;
}


//=--------------------------------------------------------------------------=
// SDU_GetLastError()
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      Return value from Win32 API function GetLastError()
//
// Notes:
//
// This function is available only in debug builds. It is for use in the
// debugger when a Win32 API call fails and you need to examine the return from
// GetLastError(). Open the quick watch window (Shift+F9) and type in
//
// SDU_GetLastError()
//
// The debugger will call the function and show its return value.
//

#if defined(DEBUG)

DWORD SDU_GetLastError()
{
    return ::GetLastError();
}

#endif


//=--------------------------------------------------------------------------=
// ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts null terminated WCHAR string to null terminated ANSI string. 
// Allocates ANSI string using CtlAlloc() function. If successful, caller
// must free ANSI string with CtlFree() function.
//
HRESULT ANSIFromWideStr
(
    WCHAR   *pwszWideStr,
    char   **ppszAnsi
)
{
    HRESULT hr = S_OK;
    int     cchAnsi = 0;
    int     cchWideStr = (int)::wcslen(pwszWideStr);
    int     cchConverted = 0;

    *ppszAnsi = NULL;

    if (0 != cchWideStr)
    {
        // get required buffer length

        cchAnsi = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                        0,           // performance and mapping flags 
                                        pwszWideStr, // address of wide-character string 
                                        cchWideStr,  // number of characters in string 
                                        NULL,        // address of buffer for new string 
                                        0,           // size of buffer 
                                        NULL,        // address of default for unmappable characters 
                                        NULL         // address of flag set when default char. used 
                                       );
        if (0 == cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<char *>(::CtlAlloc(cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        IfFailGo(hr);
    }

    if (0 != cchWideStr)
    {
        // now convert the string and copy it to the buffer
        cchConverted = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                             0,           // performance and mapping flags 
                                             pwszWideStr, // address of wide-character string 
                                             cchWideStr,  // number of characters in string 
                                            *ppszAnsi,    // address of buffer for new string 
                                             cchAnsi,     // size of buffer 
                                             NULL,        // address of default for unmappable characters 
                                             NULL         // address of flag set when default char. used 
                                            );
        if (cchConverted != cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null byte

    *((*ppszAnsi) + cchAnsi) = '\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            ::CtlFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// WideStrFromANSI(const char *pszAnsi, WCHAR **ppwszWideStr)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts null terminated ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the CtlAlloc() function. If successful,
// caller must free WCHAR string using the CtlFree() function.
//
HRESULT WideStrFromANSI
(
    const char    *pszAnsi,
    WCHAR        **ppwszWideStr
)
{
    HRESULT    hr = S_OK;
    int        cchANSI = ::strlen(pszAnsi);
    int        cchWideStr = 0;
    int        cchConverted = 0;

    *ppwszWideStr = NULL;

    if (0 != cchANSI)
    {
        // get required buffer length
        cchWideStr = ::MultiByteToWideChar(CP_ACP,  // code page - ANSI code page
                                           0,       // performance and mapping flags 
                                           pszAnsi, // address of multibyte string 
                                           cchANSI, // number of characters in string 
                                           NULL,    // address of buffer for new string 
                                           0        // size of buffer 
                                          );
        if (0 == cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the WCHAR *
    *ppwszWideStr = static_cast<WCHAR *>(::CtlAlloc(sizeof(WCHAR) * (cchWideStr + 1)));
    if (*ppwszWideStr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 != cchANSI)
    {
        // now convert the string and copy it to the buffer
        cchConverted = ::MultiByteToWideChar(CP_ACP,       // code page - ANSI code page
                                             0,            // performance and mapping flags 
                                             pszAnsi,      // address of multibyte string 
                                             cchANSI,      // number of characters in string 
                                            *ppwszWideStr, // address of buffer for new string 
                                             cchWideStr    // size of buffer 
                                            );
        if (cchConverted != cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null character
    *((*ppwszWideStr) + cchWideStr) = L'\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            ::CtlFree(*ppwszWideStr);
            *ppwszWideStr = NULL;
        }
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// ANSIFromBSTR(BSTR bstr, TCHAR **ppszAnsi)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts BSTR to null terminated ANSI string. Allocates ANSI string using
// CtlAlloc() function. If successful, caller must free ANSI string with CtlFree()
// function.
//
HRESULT ANSIFromBSTR(BSTR bstr, TCHAR **ppszAnsi)
{
    HRESULT     hr = S_OK;
    int         cchBstr = (int) ::SysStringLen(bstr);
    int         cchConverted = 0;
    int         cchAnsi = 0;

    *ppszAnsi = NULL;

    if (0 != cchBstr)
    {
        // get required buffer length
        cchAnsi = ::WideCharToMultiByte(CP_ACP,  // code page - ANSI code page
                                        0,       // performance and mapping flags 
                                        bstr,    // address of wide-character string 
                                        cchBstr, // number of characters in string 
                                        NULL,    // address of buffer for new string 
                                        0,       // size of buffer 
                                        NULL,    // address of default for unmappable characters 
                                        NULL     // address of flag set when default char. used 
                                       );
        if (cchAnsi == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<TCHAR *>(::CtlAlloc(cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 != cchBstr)
    {
        // now convert the string and copy it to the buffer
        cchConverted = ::WideCharToMultiByte(CP_ACP,    // code page - ANSI code page
                                             0,         // performance and mapping flags 
                                             bstr,      // address of wide-character string 
                                             cchBstr,   // number of characters in string 
                                             *ppszAnsi, // address of buffer for new string 
                                             cchAnsi,   // size of buffer 
                                             NULL,      // address of default for unmappable characters 
                                             NULL       // address of flag set when default char. used 
                                            );
        if (cchConverted != cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null byte
    *((*ppszAnsi) + cchAnsi) = '\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            ::CtlFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// BSTRFromANSI(TCHAR *pszAnsi, BSTR *pbstr)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts null terminated ANSI string to a null terminated BSTR. Allocates
// BSTR. If successful, caller must free BSTR using ::SysFreeString().
//
HRESULT BSTRFromANSI(const TCHAR *pszAnsi, BSTR *pbstr)
{
    HRESULT  hr = S_OK;
    WCHAR   *pwszWideStr = NULL;

    // convert to a wide string first
    hr = ::WideStrFromANSI(pszAnsi, &pwszWideStr);
    IfFailGo(hr);

    // allocate a BSTR and copy it
    *pbstr = ::SysAllocStringLen(pwszWideStr, ::wcslen(pwszWideStr));
    if (*pbstr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pwszWideStr)
    {
        ::CtlFree(pwszWideStr);
    }

    RRETURN(hr);
}


HRESULT GetResourceString(int iStringID, char *pszBuffer, int iBufferLen)
{
    HRESULT     hr = S_OK;
    int         iResult = 0;

    iResult = ::LoadString(GetResourceHandle(),
                           iStringID,
                           pszBuffer,
                           iBufferLen);
    if (0 == iResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        CError::GenerateInternalExceptionInfo(hr);
    }

    RRETURN(hr);
}


HRESULT GetExtendedSnapInDisplayName
(
    IExtendedSnapIn  *piExtendedSnapIn,
    char            **ppszDisplayName
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrName = NULL;
    BSTR     bstrGUID = NULL;
    char    *pszName = NULL;
    size_t   cbName = 0;
    char    *pszGUID = NULL;
    size_t   cbGUID = 0;
    char    *pszDisplayName = NULL;

    hr = piExtendedSnapIn->get_NodeTypeName(&bstrName);
    IfFailGo(hr);

    hr = piExtendedSnapIn->get_NodeTypeGUID(&bstrGUID);
    IfFailGo(hr);

    if (NULL != bstrName)
    {
        hr = ::ANSIFromBSTR(bstrName, &pszName);
        IfFailGo(hr);
        cbName = ::strlen(pszName);
    }

    if (NULL != bstrGUID)
    {
        hr = ::ANSIFromBSTR(bstrGUID, &pszGUID);
        IfFailGo(hr);
        cbGUID = ::strlen(pszGUID);
    }

    // Allocate enough room for two names separated by a space plus a null byte

    pszDisplayName = (char *)::CtlAlloc(cbName + cbGUID + 2);
    if (NULL == pszDisplayName)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 != cbGUID)
    {
        ::memcpy(pszDisplayName, pszGUID, cbGUID + 1);
    }

    if (0 != cbName)
    {
        pszDisplayName[cbGUID] = ' ';
        ::memcpy(&pszDisplayName[cbGUID + 1], pszName, cbName + 1);
    }

    *ppszDisplayName = pszDisplayName;

Error:
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);

    if (NULL != pszName)
        CtlFree(pszName);

    if (NULL != pszGUID)
        CtlFree(pszGUID);

   RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\snaputil.h ===
//=--------------------------------------------------------------------------=
// snaputil.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Utitlity Routines for the SnapIn Designer
//

#ifndef _SNAPUTIL_H_
#define _SNAPUTIL_H_



class CGlobalHelp;

extern CGlobalHelp g_GlobalHelp;

class CGlobalHelp
{
public:
    CGlobalHelp();
    ~CGlobalHelp();

public:
    static VOID CALLBACK MsgBoxCallback(LPHELPINFO lpHelpInfo);
    static HRESULT ShowHelp(DWORD dwHelpContextId);
    static void Attach(IHelp* pIHelp);
    static void Detach();
    static char *GetDesignerName();

private:
    static IHelp *m_pIHelp;
    static DWORD  m_cSnapInDesigners;
    static char   m_szDesignerName[256];
    static BOOL   m_fHaveDesignerName;
};


enum MessageOptions { AppendErrorInfo, DontAppendErrorInfo };

HRESULT cdecl SDU_DisplayMessage // Displays a formatted message from STRINGTABLE
(
    UINT            idMessage,
    UINT            uMsgBoxOpts,
    DWORD           dwHelpContextID,
    HRESULT         hrDisplay,
    MessageOptions  Options,
    int            *pMsgBoxRet,
    ...
);


////////////////////////////////////////////////////////////////////
// String conversion functions

HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi);
HRESULT WideStrFromANSI(const char *pszAnsi, WCHAR **ppwszWideStr);

HRESULT ANSIFromBSTR(BSTR bstr, TCHAR **ppszAnsi);
HRESULT BSTRFromANSI(const TCHAR *pszAnsi, BSTR *pbstr);

HRESULT GetResourceString(int iStringID, char *pszBuffer, int iBufferLen);



////////////////////////////////////////////////////////////////////
// Misc. Utility Functions

// Synthesize a display name for an extended snap-in from its node type name
// and node type GUID

HRESULT GetExtendedSnapInDisplayName(IExtendedSnapIn  *piExtendedSnapIn,
                                     char            **ppszDisplayName);

#endif  // _SNAPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\taskpvw.cpp ===
//=--------------------------------------------------------------------------------------
// taskpvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- TaskpadView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddTaskpadView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddTaskpadView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    ITaskpadViewDefs      *piTaskpadViewDefs = NULL;
    VARIANT                vtEmpty;
    ITaskpadViewDef       *piTaskpadViewDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        if (piTaskpadViewDefs != NULL)
        {
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piTaskpadViewDefs->Add(vtEmpty, vtEmpty, &piTaskpadViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piTaskpadViewDef);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddTaskpadViewDef(CSelectionHolder *pParent, ITaskpadViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddTaskpadViewDef(CSelectionHolder *pParent, ITaskpadViewDef *piTaskpadViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pTaskpadView = NULL;
    IViewDefs           *piViewDefs = NULL;
    ITaskpadViewDefs    *piTaskpadViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddTaskpadViewDef: pParent is NULL");
    ASSERT(NULL != pParent->m_piObject.m_piTaskpadViewDefs, "OnAddTaskpadViewDef: pParent->m_piObject.m_piTaskpadViewDefs is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD:
        piTaskpadViewDefs = pParent->m_piObject.m_piTaskpadViewDefs;
        piTaskpadViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddTaskpadViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewTaskpadView(piTaskpadViewDefs, piTaskpadViewDef, &pTaskpadView);
    IfFailGo(hr);

    hr = InsertTaskpadViewInTree(pTaskpadView, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pTaskpadView);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pTaskpadView);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pTaskpadView);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piTaskpadViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingTaskpadView(IViewDefs *piViewDefs, ITaskpadViewDef *piTaskpadViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingTaskpadView(IViewDefs *piViewDefs, ITaskpadViewDef *piTaskpadViewDef)
{
    HRESULT           hr = S_OK;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->AddFromMaster(piTaskpadViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameTaskpadView(CSelectionHolder *pTaskpadView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameTaskpadView(CSelectionHolder *pTaskpadView, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_VIEWS_TASK_PAD_NAME == pTaskpadView->m_st, "RenameTaskpadView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Name(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pTaskpadView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pTaskpadView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteTaskpadView(CSelectionHolder *pTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteTaskpadView
(
    CSelectionHolder *pTaskpadView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    VARIANT           vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pTaskpadView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->get_Key(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pTaskpadView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piTaskpadViewDefs->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteTaskpadView(CSelectionHolder *pTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteTaskpadView
(
    CSelectionHolder *pTaskpadView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    ITaskpadViewDefs  *piTaskpadViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pTaskpadView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pTaskpadView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pTaskpadView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pTaskpadView);
    IfFailGo(hr);

    delete pTaskpadView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        hr = piTaskpadViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowTaskpadViewProperties(ITaskpadViewDef *piTaskpadViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowTaskpadViewProperties
(
    ITaskpadViewDef *piTaskpadViewDef
)
{
    HRESULT         hr = S_OK;
    int             iResult = 0;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[3];

    hr = GetResourceString(IDS_TASK_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piTaskpadViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_TaskpadViewDefGeneralPP;
    pageClsID[1] = CLSID_TaskpadViewDefBackgroundPP;
    pageClsID[2] = CLSID_TaskpadViewDefTasksPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 3;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDef *piTaskpadViewDef, CSelectionHolder **ppTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewTaskpadView
(
    ITaskpadViewDefs  *piTaskpadViewDefs,
    ITaskpadViewDef   *piTaskpadViewDef,
    CSelectionHolder **ppTaskpadView
)
{
    HRESULT                hr = S_OK;

    *ppTaskpadView = New CSelectionHolder(piTaskpadViewDef);
    if (NULL == *ppTaskpadView)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewTaskpadView(piTaskpadViewDefs, *ppTaskpadView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, CSelectionHolder *pTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewTaskpadView
(
    ITaskpadViewDefs  *piTaskpadViewDefs,
    CSelectionHolder  *pTaskpadView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pTaskpadViewDefClone = NULL;
    ITaskpad         *piTaskpad = NULL;

    ASSERT(NULL != piTaskpadViewDefs, "InitializeNewTaskpadView: piTaskpadViewDefs is NULL");
    ASSERT(NULL != pTaskpadView, "InitializeNewTaskpadView: pTaskpadView is NULL");

    hr = piTaskpadViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewTaskpadView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_TASK_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++iItemNumber);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pTaskpadViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Key(bstrName);
        IfFailGo(hr);

        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        hr = piTaskpad->put_Name(bstrName);
        IfFailGo(hr);
    }

    hr = pTaskpadView->RegisterHolder();
    IfFailGo(hr);

Error:
    RELEASE(piTaskpad);
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertTaskpadViewInTree(CSelectionHolder *pTaskpadView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertTaskpadViewInTree
(
    CSelectionHolder *pTaskpadView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->get_Key(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kTaskpadIcon, pTaskpadView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Support functions to manipulate IViewDef's
// Searching
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetOwningViewCollection(IViewDefs **ppiViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetOwningViewCollection
(
    IViewDefs **ppiViewDefs
)
{
    HRESULT              hr = S_OK;

    hr = GetOwningViewCollection(m_pCurrentSelection, ppiViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetOwningViewCollection(CSelectionHolder *pView, IViewDefs **ppiViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetOwningViewCollection
(
    CSelectionHolder *pView,
    IViewDefs       **ppiViewDefs
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    ISnapInDef          *piSnapInDef = NULL;

    switch (pView->m_st)
    {
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
        IfFailGo(hr);

        hr = piSnapInDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_VIEWS:
    case SEL_VIEWS_LIST_VIEWS_NAME:
    case SEL_VIEWS_OCX_NAME:
    case SEL_VIEWS_URL_NAME:
    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_pTreeView->GetParent(pView, &pParent);
        IfFailGo(hr);

        switch (pParent->m_st)
        {
        case SEL_NODES_ANY_NAME:
        case SEL_NODES_ANY_VIEWS:
            hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(ppiViewDefs);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
            hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
            IfFailGo(hr);

            hr = piSnapInDef->get_ViewDefs(ppiViewDefs);
            IfFailGo(hr);
            break;

        default:
            ASSERT(0, "Unexpected parent");
        }
        break;

    case SEL_NODES_ANY_NAME:
        hr = pView->m_piObject.m_piScopeItemDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_ROOT:
        hr = m_piSnapInDesignerDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:
        hr = m_piSnapInDesignerDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;
    }

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsSatelliteView(CSelectionHolder *pView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return S_OK if this view is part of a satellite collection, S_FALSE otherwise.
//
HRESULT CSnapInDesigner::IsSatelliteView(CSelectionHolder *pView)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    hr = m_pTreeView->GetParent(pView, &pParent);
    IfFailGo(hr);

    switch (pParent->m_st)
    {
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:
        hr = S_FALSE;
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsSatelliteCollection(CSelectionHolder *pViewCollection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return S_OK if collection is a satellite collection, S_FALSE otherwise.
//
HRESULT CSnapInDesigner::IsSatelliteCollection(CSelectionHolder *pViewCollection)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    switch (pViewCollection->m_st)
    {
        // Possible parent nodes of a view:
    case SEL_NODES_AUTO_CREATE_RTVW:
        // Anything off of SnapIn/Auto-Create/Static Node/Views is a satellite collection
        break;

    case SEL_NODES_ANY_VIEWS:
        // Anything off of SnapIn/Auto-Create/Static Node/<name>/Views, recursively, and
        // anything off of SnapIn/Other/<name>/Views is a satellite collection
        break;

    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:
        // If these depend off of SnapIn/Views then they are NOT a satellite collection
        hr = m_pTreeView->GetParent(pViewCollection, &pParent);
        IfFailGo(hr);

        switch (pParent->m_st)
        {
        case SEL_VIEWS_ROOT:
            hr = S_FALSE;
            break;
        }
        break;

    default:
        ASSERT(0, "IsSatelliteCollection: wrong argument");
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\treeview.cpp ===
//=--------------------------------------------------------------------------------------
// TreeView.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CTreeView implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// These are the bitmap resource IDs that match the icon list.

static const UINT rgImageListBitmaps[] =
{
    /* kOpenFolderIcon      */  IDB_BITMAP_OPEN_FOLDER,
    /* kClosedFolderIcon    */  IDB_BITMAP_CLOSED_FOLDER,
    /* kScopeItemIcon       */  IDB_BITMAP_SCOPE_ITEM,
    /* kImageListIcon       */  IDB_BITMAP_IMAGE_LIST,
    /* kMenuIcon            */  IDB_BITMAP_MENU,
    /* kToolbarIcon         */  IDB_BITMAP_TOOLBAR,
    /* kListViewIcon        */  IDB_BITMAP_LIST_VIEW,
    /* kOCXViewIcon         */  IDB_BITMAP_OCX_VIEW,
    /* kURLViewIcon         */  IDB_BITMAP_URL_VIEW,
    /* kTaskpadIcon         */  IDB_BITMAP_TASKPAD,
    /* kDataFmtIcon         */  IDB_BITMAP_DATAFMT
};

const int   gcImages = 11;


//=--------------------------------------------------------------------------------------
// CTreeView::CTreeView
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Intialize member variables
//
CTreeView::CTreeView() : m_hTreeView(0), m_fnTreeProc(0)
{
}


//=--------------------------------------------------------------------------------------
// CTreeView::~CTreeView
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Ensure all dynamically allocated objects are freed
//
CTreeView::~CTreeView()
{
    Clear();

    if (NULL != m_hTreeView) {
        ImageList_Destroy(TreeView_GetImageList(m_hTreeView, TVSIL_NORMAL));
        ::DestroyWindow(m_hTreeView);
    }
}


//=--------------------------------------------------------------------------------------
// CTreeView::Initialize
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Build the initial view
//
HRESULT CTreeView::Initialize
(
    HWND  hwndParent,
    RECT& rc
)
{
    HRESULT     hr = S_OK;
    HIMAGELIST  hImageList = NULL;
    char        szzWindowName[1];
    DWORD       dwStyle = WS_CHILD | WS_VISIBLE | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_EDITLABELS | TVS_SHOWSELALWAYS;
    size_t      i = 0;

    if (NULL != m_hTreeView)
        return S_OK;

    szzWindowName[0] = 0;

    hr = CreateImageList(&hImageList);
    IfFailGo(hr);

    m_hTreeView = ::CreateWindowEx(0,
                                   WC_TREEVIEW,
                                   szzWindowName,
                                   dwStyle,
                                   0,
                                   rc.top,
                                   rc.right - rc.left,
                                   rc.bottom - rc.top,
                                   hwndParent,
                                   reinterpret_cast<HMENU>(1),
                                   GetResourceHandle(),
                                   NULL);
    if (NULL == m_hTreeView)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    TreeView_SetImageList(m_hTreeView, hImageList, TVSIL_NORMAL);

    ::SetWindowLong(m_hTreeView, GWL_USERDATA, reinterpret_cast<LONG>(this));

    m_fnTreeProc = reinterpret_cast<WNDPROC>(::SetWindowLong(m_hTreeView, GWL_WNDPROC, reinterpret_cast<LONG>(CTreeView::DesignerTreeWindowProc)));
    if (NULL == m_fnTreeProc)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::CreateImageList(HIMAGELIST *phImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//
HRESULT CTreeView::CreateImageList
(
    HIMAGELIST *phImageList
)
{
    HRESULT     hr = S_OK;
    HBITMAP     hBitmap = NULL;
    int         i = 0;
    int         iResult = 0;
    HIMAGELIST  hImageList = NULL;

    hImageList = ImageList_Create(16,
                                  16,
                                  0,
                                  1,
                                  0);
    if (hImageList == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    for (i = 0; i < gcImages; i++)
    {
        hBitmap = ::LoadBitmap(GetResourceHandle(), MAKEINTRESOURCE(rgImageListBitmaps[i]));
        if (hBitmap == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }


        iResult = ImageList_Add(hImageList, hBitmap, NULL);
        if (iResult == -1)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        DeleteObject(hBitmap);
        hBitmap = NULL;
    }

    *phImageList = hImageList;

Error:
    if (NULL != hBitmap)
        DeleteObject(hBitmap);

    if (FAILED(hr))
    {
        if (hImageList != NULL)
            ImageList_Destroy(hImageList);

        *phImageList = NULL;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::DesignerTreeWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//
LRESULT CALLBACK CTreeView::DesignerTreeWindowProc
(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT    hr = S_OK;
    CTreeView *pView = NULL;
    LRESULT    lResult = TRUE;

    pView = reinterpret_cast<CTreeView *>(::GetWindowLong(hwnd, GWL_USERDATA));
    if (pView == NULL)
        return DefWindowProc(hwnd, msg, wParam, lParam);
    else if (hwnd == pView->m_hTreeView)
    {
        switch (msg)
        {
        case WM_SETFOCUS:
//            hr = pView->OnGotFocus(msg, wParam, lParam, &lResult);
//            CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);
            break;
        }
    }

    return ::CallWindowProc(pView->m_fnTreeProc, hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Clear()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Called upon termination to clear the tree and all selection holders.
//
HRESULT CTreeView::Clear()
{
    HRESULT  hr = S_OK;
    BOOL     fRet = FALSE;

    hr = ClearTree(TVI_ROOT);
    IfFailGo(hr);

    fRet = TreeView_DeleteAllItems(m_hTreeView);
    if (fRet != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::ClearTree(HTREEITEM hItemParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::ClearTree
(
    HTREEITEM hItemParent
)
{
    HRESULT            hr = S_OK;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = ClearTree(hItemChild);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
            delete pSelection;

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::RenameAllSatelliteViews(CSelectionHolder *pView, TCHAR *pszNewViewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::RenameAllSatelliteViews
(
    CSelectionHolder *pView,
    TCHAR            *pszNewViewName
)
{
    HRESULT            hr = S_FALSE;

    hr = RenameAllSatelliteViews(TVI_ROOT, pView, pszNewViewName);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::RenameAllSatelliteViews(HTREEITEM hItemParent, CSelectionHolder *pView, TCHAR *pszNewViewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::RenameAllSatelliteViews
(
    HTREEITEM          hItemParent,
    CSelectionHolder  *pView,
    TCHAR             *pszNewViewName
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    IUnknown          *piunkView = NULL;
    IUnknown          *piunkTargetView = NULL;

    hr = pView->GetIUnknown(&piunkView);
    IfFailGo(hr);

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = RenameAllSatelliteViews(hItemChild, pView, pszNewViewName);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection != pView && pSelection->m_st == pView->m_st)
        {
            hr = pSelection->GetIUnknown(&piunkTargetView);
            IfFailGo(hr);

            if (piunkTargetView == piunkView)
            {
                hr = ChangeText(pSelection, pszNewViewName);
                IfFailGo(hr);
            }

            RELEASE(piunkTargetView);
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RELEASE(piunkTargetView);
    RELEASE(piunkView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindInTree(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Attempts to find a CSelectionHolder in the tree that resolves to the argument piUnknown.
// If found, returns it in the [out] parameter ppSelectionHolder and the return value
// of the function is S_OK, otherwise the return value is S_FALSE.
// Search is depth-first.
//
HRESULT CTreeView::FindInTree
(
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;

    hr = FindInTree(TVI_ROOT, piUnknown, ppSelectionHolder);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindInTree(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindInTree
(
    HTREEITEM          hItemParent,
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    IUnknown          *piUnknownTarget = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        hr = pSelection->GetIUnknown(&piUnknownTarget);
        IfFailGo(hr);

        if (piUnknownTarget == piUnknown)
        {
            *ppSelectionHolder = pSelection;
            hr = S_OK;
            goto Error;
        }

        hr = FindInTree(hItemChild, piUnknown, ppSelectionHolder);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            goto Error;
        }

        RELEASE(piUnknownTarget);
        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RELEASE(piUnknownTarget);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindSelectableObject(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindSelectableObject
(
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;

    hr = FindSelectableObject(TVI_ROOT, piUnknown, ppSelectionHolder);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindSelectableObject(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindSelectableObject
(
    HTREEITEM          hItemParent,
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    IUnknown          *piUnknownTarget = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        hr = pSelection->GetSelectableObject(&piUnknownTarget);
        IfFailGo(hr);

        if (piUnknownTarget == piUnknown)
        {
            *ppSelectionHolder = pSelection;
            hr = S_OK;
            goto Error;
        }

        hr = FindSelectableObject(hItemChild, piUnknown, ppSelectionHolder);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            goto Error;
        }

        RELEASE(piUnknownTarget);
        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RELEASE(piUnknownTarget);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindLabelInTree(TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindLabelInTree
(
    TCHAR             *pszLabel,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_OK;

    hr = FindLabelInTree(TVI_ROOT, pszLabel, ppSelectionHolder);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindLabelInTree(HTREEITEM hItemParent, TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindLabelInTree
(
    HTREEITEM          hItemParent,
    TCHAR             *pszLabel,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_OK;
    HTREEITEM          hItemChild = NULL;
    TVITEM             tv;
    TCHAR              pszBuffer[1024];
    BOOL               bReturn = FALSE;
    CSelectionHolder  *pSelection = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        pszBuffer[0] = 0;
        ::memset(&tv, 0, sizeof(TVITEM));
        tv.mask = TVIF_TEXT;
        tv.hItem = hItemChild;
        tv.pszText = pszBuffer;
        tv.cchTextMax = 1023;
        bReturn = TreeView_GetItem(m_hTreeView, &tv);

        if (TRUE == bReturn)
        {
            if (0 == _tcscmp(pszBuffer, pszLabel))
            {
                *ppSelectionHolder = pSelection;
                hr = S_OK;
                goto Error;
            }
        }

        hr = FindLabelInTree(hItemChild, pszLabel, ppSelectionHolder);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            goto Error;
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

    hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::CountSelectableObjects(long *plCount)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the number of non-virtual selection holders in the tree.
//
HRESULT CTreeView::CountSelectableObjects
(
    long        *plCount
)
{
    HRESULT            hr = S_FALSE;

    hr = Count(TVI_ROOT, plCount);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Count(HTREEITEM hItemParent, long *plCount)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::Count
(
    HTREEITEM    hItemParent,
    long        *plCount
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    CSelectionHolder  *pParentSelection = NULL;

    // If this item is 
    // Nodes\Auto-Create\Static Node\ResultViews or
    // <any node>\ResultViews then don't count its children as they
    // will be counted under SnapIn1\ResultViews\ListViews etc.

    if (TVI_ROOT != hItemParent)
    {
        hr = GetItemParam(hItemParent, &pParentSelection);
        IfFailGo(hr);

        if ( (SEL_NODES_AUTO_CREATE_RTVW == pParentSelection->m_st) ||
             (SEL_NODES_ANY_VIEWS == pParentSelection->m_st) )
        {
            goto Error; // nothing to do
        }
    }

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = Count(hItemChild, plCount);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection->IsVirtual() == false)
        {
            ++(*plCount);
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::CollectSelectableObjects(IUnknown *piUnknown[], long *plOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Collect all non-virtual selection holders in piUnknown array.
//
HRESULT CTreeView::CollectSelectableObjects
(
    IUnknown    *ppiUnknown[],
    long        *plOffset
)
{
    HRESULT            hr = S_FALSE;

    hr = Collect(TVI_ROOT, ppiUnknown, plOffset);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Collect(HTREEITEM hItemParent, IUnknown *ppiUnknown[], long *plOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::Collect
(
    HTREEITEM    hItemParent,
    IUnknown    *ppiUnknown[],
    long        *plOffset
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    CSelectionHolder  *pParentSelection = NULL;

    // If this item is 
    // Nodes\Auto-Create\Static Node\ResultViews or
    // <any node>\ResultViews then don't collect its children as they
    // will be collected under SnapIn1\ResultViews\ListViews etc.

    if (TVI_ROOT != hItemParent)
    {
        hr = GetItemParam(hItemParent, &pParentSelection);
        IfFailGo(hr);

        if ( (SEL_NODES_AUTO_CREATE_RTVW == pParentSelection->m_st) ||
             (SEL_NODES_ANY_VIEWS == pParentSelection->m_st) )
        {
            goto Error; // nothing to do
        }
    }

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = Collect(hItemChild, ppiUnknown, plOffset);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection->IsVirtual() == false)
        {
            hr = pSelection->GetSelectableObject(&(ppiUnknown[*plOffset]));
            IfFailGo(hr);

            ++(*plOffset);
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::AddNode(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add a node to the tree.
//
HRESULT CTreeView::AddNode
(
    const char        *pszNodeName,
    CSelectionHolder  *pParent,
    int                iImage,
    CSelectionHolder  *pItem
)
{
    HRESULT         hr = S_OK;
    HTREEITEM       hParent = NULL;
    BOOL            fRet = FALSE;
    TV_INSERTSTRUCT is;
    HTREEITEM       hItem = NULL;

    ASSERT(pszNodeName != NULL, "Parameter pszNodeName is NULL");
    ASSERT(pItem != NULL, "Parameter pItem is NULL");

    if (pParent == NULL)
        hParent = TVI_ROOT;
    else
        hParent = reinterpret_cast<HTREEITEM>(pParent->m_pvData);

    is.hParent = hParent;
    is.hInsertAfter = TVI_LAST;
    is.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    is.item.hItem = 0;
    is.item.state = 0;
    is.item.stateMask = 0;
    is.item.pszText = const_cast<char *>(pszNodeName);
    is.item.cchTextMax = ::strlen(pszNodeName);
    is.item.iImage = iImage;
    is.item.iSelectedImage = iImage;
    is.item.cChildren = 0;
    is.item.lParam = reinterpret_cast<LPARAM>(pItem);

    hItem = TreeView_InsertItem(m_hTreeView, &is);
    if (hItem == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Is it a big deal if fRet is false?
    fRet = TreeView_EnsureVisible(m_hTreeView, hItem);

    pItem->m_pvData = hItem;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::AddNodeAfter(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pPrevious, CSelectionHolder *pItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add a node to the tree.
//
// If pParent is NULL then insert at root of tree
// If pPrevious is NULL then inserts at top of subtree owned by parent
//
HRESULT CTreeView::AddNodeAfter
(
    const char        *pszNodeName,
    CSelectionHolder  *pParent,
    int                iImage,
    CSelectionHolder  *pPrevious,
    CSelectionHolder  *pItem
)
{
    HRESULT         hr = S_OK;
    HTREEITEM       hParent = NULL;
    HTREEITEM       hPrevious = NULL;
    BOOL            fRet = FALSE;
    TV_INSERTSTRUCT is;
    HTREEITEM       hItem = NULL;

    ASSERT(pszNodeName != NULL, "Parameter pszNodeName is NULL");
    ASSERT(pItem != NULL, "Parameter pItem is NULL");

    // If there is no parent then insert at root of tree

    if (pParent == NULL)
        hParent = TVI_ROOT;
    else
        hParent = reinterpret_cast<HTREEITEM>(pParent->m_pvData);

    // If there is no previous then insert at top of subtree owned by parent

    if (NULL == pPrevious)
    {
        hPrevious = TVI_FIRST;
    }
    else
    {
        hPrevious = reinterpret_cast<HTREEITEM>(pPrevious->m_pvData);;
    }

    is.hParent = hParent;
    is.hInsertAfter = hPrevious;
    is.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    is.item.hItem = 0;
    is.item.state = 0;
    is.item.stateMask = 0;
    is.item.pszText = const_cast<char *>(pszNodeName);
    is.item.cchTextMax = ::strlen(pszNodeName);
    is.item.iImage = iImage;
    is.item.iSelectedImage = iImage;
    is.item.cChildren = 0;
    is.item.lParam = reinterpret_cast<LPARAM>(pItem);

    hItem = TreeView_InsertItem(m_hTreeView, &is);
    if (hItem == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Is it a big deal if fRet is false?
    fRet = TreeView_EnsureVisible(m_hTreeView, hItem);

    pItem->m_pvData = hItem;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::DeleteNode(CSelectionHolder *pItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::DeleteNode(CSelectionHolder *pItem)
{
    HRESULT     hr = S_OK;
    BOOL        bResult = FALSE;

    bResult = TreeView_DeleteItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pItem->m_pvData));

//Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetItemParam(CSelectionHolder *pItem, CSelectionHolder **ppObject)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the selection holder located in pItem->pvData in the tree.
//
HRESULT CTreeView::GetItemParam
(
    CSelectionHolder  *pItem,
    CSelectionHolder **ppObject
)
{
    HRESULT     hr = S_OK;
    TV_ITEM     tvItem;

    ASSERT(m_hTreeView != NULL, "m_hTreeView is NULL");
    ASSERT(pItem != NULL, "pItem is NULL");
    ASSERT(ppObject != NULL, "ppObject is NULL");

    memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.hItem = reinterpret_cast<HTREEITEM>(pItem->m_pvData);
    tvItem.mask = TVIF_PARAM;

    TreeView_GetItem(m_hTreeView, &tvItem);
    if (tvItem.lParam == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *ppObject = reinterpret_cast<CSelectionHolder *>(tvItem.lParam);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetItemParam(HTREEITEM hItem, CSelectionHolder **ppObject)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the selection holder located in hItem in the tree.
//
HRESULT CTreeView::GetItemParam
(
    HTREEITEM          hItem,
    CSelectionHolder **ppObject
)
{
    HRESULT     hr = S_OK;
    TV_ITEM     tvItem;

    ASSERT(m_hTreeView != NULL, "m_hTreeView is NULL");
    ASSERT(hItem != NULL, "hItem is NULL");
    ASSERT(ppObject != NULL, "ppObject is NULL");

    memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.hItem = hItem;
    tvItem.mask = TVIF_PARAM;

    TreeView_GetItem(m_hTreeView, &tvItem);
    if (tvItem.lParam == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *ppObject = reinterpret_cast<CSelectionHolder *>(tvItem.lParam);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::ChangeText(CSelectionHolder *pItem, char *pszNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Change the text of the node pointed by pItem to be pszNewName.
//
HRESULT CTreeView::ChangeText
(
    CSelectionHolder *pItem,
    char             *pszNewName
)
{
    HRESULT		hr = S_OK;
    TV_ITEM		tvItem;
    BOOL		fResult = FALSE;

    ::memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.mask = TVIF_TEXT;
    tvItem.hItem = (HTREEITEM) pItem->m_pvData;
    tvItem.pszText = pszNewName;
    tvItem.cchTextMax = ::strlen(pszNewName);

    fResult = TreeView_SetItem(m_hTreeView, &tvItem);
    if (fResult != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::ChangeNodeIcon(CSelectionHolder *pItem, int iImage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Change the the icon of the node pointed by pItem to be iImage
//
HRESULT CTreeView::ChangeNodeIcon
(
    CSelectionHolder *pItem,
    int               iImage
)
{
    HRESULT     hr = S_OK;
    TV_ITEM     tvItem;
    BOOL        fResult = FALSE;

    ::memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvItem.hItem = reinterpret_cast<HTREEITEM>(pItem->m_pvData);
    tvItem.iImage = iImage;
    tvItem.iSelectedImage = iImage;

    fResult = TreeView_SetItem(m_hTreeView, &tvItem);
    if (fResult != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::HitTest(POINT pHit, CSelectionHolder **ppSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the selection holder located at the coordinates pHit.
//
HRESULT CTreeView::HitTest
(
    POINT              pHit,
    CSelectionHolder **ppSelection
)
{
    HRESULT          hr = S_OK;
    TV_HITTESTINFO   hti;
    HTREEITEM        hItem = NULL;
    CSelectionHolder item;

    ASSERT(NULL != ppSelection, "HitTest: ppSelection is NULL");
    ASSERT(NULL != m_hTreeView, "HitTest: m_hTreeView is NULL");

    *ppSelection = NULL;

    hti.pt.x = pHit.x;
    hti.pt.y = pHit.y;

    hItem = TreeView_HitTest(m_hTreeView, &hti);

    if (NULL != hItem)
    {
        item.m_pvData = hItem;

        hr = GetItemParam(&item, ppSelection);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetRectangle(CSelectionHolder *pSelection, RECT *prc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetRectangle
(
    CSelectionHolder *pSelection,
    RECT             *prc
)
{
    HRESULT         hr = S_OK;
    BOOL            bResult = FALSE;

    bResult = TreeView_GetItemRect(m_hTreeView,
                                   reinterpret_cast<HTREEITEM>(pSelection->m_pvData),
                                   prc,
                                   TRUE);
    if (bResult != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::SelectItem(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Select the tree node pointed by pSelection.
//
HRESULT CTreeView::SelectItem
(
    CSelectionHolder *pSelection
)
{
    HRESULT		hr = S_OK;
    BOOL		fReturn = FALSE;

    ASSERT(m_hTreeView != NULL, "SelectItem: m_hTreeView is NULL");
    ASSERT(pSelection != NULL, "SelectItem: pSelection i NULL");

    fReturn = TreeView_SelectItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData));
    if (fReturn != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Edit(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Select the tree node pointed by pSelection.
//
HRESULT CTreeView::Edit(CSelectionHolder *pSelection)
{
    HRESULT		hr = S_OK;

    TreeView_EditLabel(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetParent(CSelectionHolder *pSelection, CSelectionHolder **ppParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Select the tree node pointed by pSelection.
//
HRESULT CTreeView::GetParent
(
    CSelectionHolder  *pSelection,
    CSelectionHolder **ppParent
)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hParent = NULL;

    ASSERT(m_hTreeView != NULL, "GetParent: m_hTreeView is NULL");
    ASSERT(pSelection != NULL, "GetParent: pSelection i NULL");

    hParent = TreeView_GetParent(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData));
    if (hParent == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetItemParam(hParent, ppParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetFirstChildNode(CSelectionHolder *pSelection, CSelectionHolder **ppChild)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetFirstChildNode(CSelectionHolder *pSelection, CSelectionHolder **ppChild)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hChild = NULL;

    *ppChild = NULL;

    hChild = TreeView_GetNextItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData), TVGN_CHILD);
    if (NULL == hChild)
    {
        // Maybe an error or no children
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (FAILED(hr))
        {
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            hr = S_FALSE;
            goto Error;
        }
    }

    hr = GetItemParam(hChild, ppChild);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetNextChildNode(CSelectionHolder *pChild, CSelectionHolder **ppNextChild)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetNextChildNode(CSelectionHolder *pChild, CSelectionHolder **ppNextChild)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hNextChild = NULL;

    *ppNextChild = NULL;

    hNextChild = TreeView_GetNextItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pChild->m_pvData), TVGN_NEXT);
    if (NULL == hNextChild)
    {
        // Maybe an error or no more children
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (FAILED(hr))
        {
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            hr = S_FALSE;
            goto Error;
        }
    }

    hr = GetItemParam(hNextChild, ppNextChild);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetPreviousNode(CSelectionHolder *pNode, CSelectionHolder **ppPreviousNode)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetPreviousNode(CSelectionHolder *pNode, CSelectionHolder **ppPreviousNode)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hPreviousNode = NULL;

    hPreviousNode = TreeView_GetNextItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pNode->m_pvData), TVGN_PREVIOUS);
    if (NULL == hPreviousNode)
    {
        // Maybe an error or no more children
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (FAILED(hr))
        {
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            hr = S_FALSE;
            goto Error;
        }
    }

    hr = GetItemParam(hPreviousNode, ppPreviousNode);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel)
{
    HRESULT     hr = S_OK;
    BOOL        bResult = FALSE;
    TVITEM      tv;
    char        buffer[1024];

    ::memset(&tv, 0, sizeof(TVITEM));
    tv.mask = TVIF_TEXT;
    tv.hItem = reinterpret_cast<HTREEITEM>(pSelection->m_pvData);
    tv.pszText = buffer;
    tv.cchTextMax = 1023;

    bResult = TreeView_GetItem(m_hTreeView, &tv);
    if (TRUE == bResult)
    {
        hr = BSTRFromANSI(buffer, pbstrLabel);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetLabelA(CSelectionHolder *pSelection, char *pszBuffer, int cbBuffer)
{
    HRESULT     hr = S_OK;
    TVITEM      tv;

    ::memset(&tv, 0, sizeof(TVITEM));
    tv.mask = TVIF_TEXT;
    tv.hItem = reinterpret_cast<HTREEITEM>(pSelection->m_pvData);
    tv.pszText = pszBuffer;
    tv.cchTextMax = cbBuffer;

    IfFalseGo(TreeView_GetItem(m_hTreeView, &tv), E_FAIL);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::PruneAndGraft()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Grafts the specified node and any subtree to the new parent node. Removes
// the node and any subtree from its old parent.
//
HRESULT CTreeView::PruneAndGraft
(
    CSelectionHolder *pNode,
    CSelectionHolder *pNewParentNode,
    int               iImage
)
{
    HRESULT hr = S_OK;

    CSelectionHolder OldNode;
    ::ZeroMemory(&OldNode, sizeof(OldNode));

    // Create a shallow copy of the node so we can use it later to delete it
    // from the treeview. The only significant piece of information in the
    // clone is the HTREEITEM in CSelectionHolder.m_pvData as that is used
    // by CTreeView::GetFirstChildNode. This allows us to make a simple copy
    // rather than AddRef()ing the contained object.

    OldNode = *pNode;

    // Replicate the old node and any potential sub-tree onto the new parent

    IfFailGo(Graft(pNode, pNewParentNode, iImage));

    // Delete the old node and any potential sub-tree from the treeview. Use
    // the clone we created above as it contains the old HTREEITEM.

    IfFailGo(DeleteNode(&OldNode));

Error:

    // Clean out the clone so that the CSelectionHolder destructor doesn't
    // release the object as it is still owned by the original CSelectionHolder.

    ::ZeroMemory(&OldNode, sizeof(OldNode));

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::Graft()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Grafts the specified node and any subtree to the new parent node.
//
HRESULT CTreeView::Graft
(
    CSelectionHolder *pNode,
    CSelectionHolder *pNewParentNode,
    int               iImage
)
{
    HRESULT           hr = S_OK;
    char              szNodeLabel[512] = "";
    CSelectionHolder *pNextChild = NULL;

    CSelectionHolder OldNode;
    ::ZeroMemory(&OldNode, sizeof(OldNode));

    CSelectionHolder OldChild;
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    // Create a shallow copy of the node so we can use it later to get its 1st
    // child from the treeview. The only significant piece of information in the
    // clone is the HTREEITEM in CSelectionHolder.m_pvData as that is used
    // by CTreeView::GetFirstChildNode. This allows us to make a simple copy
    // rather than AddRef()ing the contained object.

    OldNode = *pNode;

    // Get the node's label

    IfFailGo(GetLabelA(pNode, szNodeLabel, sizeof(szNodeLabel)));

    // Create a new node in the treeview under the new parent and give it
    // ownership of the existing CSelectionHolder. This will replace the
    // HTREEITEM in CSelectionHolder.m_pvData.

    IfFailGo(AddNode(szNodeLabel, pNewParentNode, iImage, pNode));

    // If the old node has children then add them to the new node

    IfFailGo(GetFirstChildNode(&OldNode, &pNextChild));

    while (S_OK == hr)
    {
        // Clone the child because the recursive call to this function will
        // change its HTREEITEM.
        OldChild = *pNextChild;

        IfFailGo(Graft(pNextChild, pNode, iImage));
        IfFailGo(GetNextChildNode(&OldChild, &pNextChild));
    }

Error:

    // Clean out the clones so that the CSelectionHolder destructor doesn't
    // release the object as it is still owned by the original CSelectionHolder.

    ::ZeroMemory(&OldNode, sizeof(OldNode));
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::MoveNodeAfter()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Moves pNode to the position immediately after pPreviousNode as a peer of
// pPreviousNode. Moves all children of pNode to the new position. Deletes the
// old pNode and all of its children.
//
HRESULT CTreeView::MoveNodeAfter
(
    CSelectionHolder *pNode,
    CSelectionHolder *pNewParentNode,
    CSelectionHolder *pPreviousNode,
    int               iImage
)
{
    HRESULT           hr = S_OK;
    char              szNodeLabel[512] = "";
    CSelectionHolder *pNextChild = NULL;

    CSelectionHolder OldNode;
    ::ZeroMemory(&OldNode, sizeof(OldNode));

    CSelectionHolder OldChild;
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    // Create a shallow copy of the node so we can use it later to delete it
    // from the treeview. The only significant piece of information in the
    // clone is the HTREEITEM in CSelectionHolder.m_pvData as that is used
    // by CTreeView::GetFirstChildNode. This allows us to make a simple copy
    // rather than AddRef()ing the contained object.

    OldNode = *pNode;

    // Get the node's label

    IfFailGo(GetLabelA(pNode, szNodeLabel, sizeof(szNodeLabel)));

    // Create a new node in the treeview after pPrevious and give it
    // ownership of the existing CSelectionHolder. This will replace the
    // HTREEITEM in CSelectionHolder.m_pvData.

    IfFailGo(AddNodeAfter(szNodeLabel, pNewParentNode, iImage,
                          pPreviousNode, pNode));

    // If the old node has children then add them to the new node

    IfFailGo(GetFirstChildNode(&OldNode, &pNextChild));

    while (S_OK == hr)
    {
        // Clone the child because the recursive call to this function will
        // change its HTREEITEM.
        OldChild = *pNextChild;

        IfFailGo(Graft(pNextChild, pNode, iImage));
        IfFailGo(GetNextChildNode(&OldChild, &pNextChild));
    }

    // Delete the old node and any potential sub-tree from the treeview. Use
    // the clone we created above as it contains the old HTREEITEM.

    IfFailGo(DeleteNode(&OldNode));

Error:

    // Clean out the clone so that the CSelectionHolder destructor doesn't
    // release the object as it is still owned by the original CSelectionHolder.

    ::ZeroMemory(&OldNode, sizeof(OldNode));
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\treeview.h ===
//=--------------------------------------------------------------------------------------
// TreeView.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// CTreeView declaration
//=-------------------------------------------------------------------------------------=

#ifndef _TREEVIEW_H_
#define _TREEVIEW_H_

#include "SelHold.h"


// Icon identifiers for the tree view
const int   kOpenFolderIcon    = 0;
const int   kClosedFolderIcon  = 1;
const int   kScopeItemIcon     = 2;
const int   kImageListIcon     = 3;
const int   kMenuIcon          = 4;
const int   kToolbarIcon       = 5;
const int   kListViewIcon      = 6;
const int   kOCXViewIcon       = 7;
const int   kURLViewIcon       = 8;
const int   kTaskpadIcon       = 9;
const int   kDataFmtIcon       = 10;

typedef int (_stdcall *FnPtr)(void);

////////////////////////////////////////////////////////////////////////////////////
//
// Class CTreeView
//
////////////////////////////////////////////////////////////////////////////////////

class CTreeView : public CError, public CtlNewDelete
{
public:
    CTreeView();
    ~CTreeView();

    HRESULT Initialize(HWND hwndParent, RECT& rc);
    HRESULT CreateTreeView(HWND hwndParent);


////////////////////////////////////////////////////////////////////////////////////
// WinProc and friends
public:
    static LRESULT CALLBACK DesignerTreeWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HWND TreeViewWindow()                       { return m_hTreeView; }

    HRESULT CreateImageList(HIMAGELIST *phImageList);


////////////////////////////////////////////////////////////////////////////////////
// Basic operations on the TreeView
protected:
    HRESULT ClearTree(HTREEITEM hItemParent);
    HRESULT Clear();

public:
    HRESULT RenameAllSatelliteViews(CSelectionHolder *pView, TCHAR *pszNewViewName);
    HRESULT RenameAllSatelliteViews(HTREEITEM          hItemParent,
                                    CSelectionHolder  *pView,
                                    TCHAR             *pszNewViewName);

    HRESULT FindInTree(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);
    HRESULT FindInTree(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);

    HRESULT FindSelectableObject(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);
    HRESULT FindSelectableObject(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);

    HRESULT FindLabelInTree(TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder);
    HRESULT FindLabelInTree(HTREEITEM hItemParent, TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder);

    HRESULT Count(HTREEITEM hItemParent, long *plCount);
    HRESULT CountSelectableObjects(long *plCount);

    HRESULT Collect(HTREEITEM hItemParent, IUnknown *ppiUnknown[], long *plOffset);
    HRESULT CollectSelectableObjects(IUnknown *ppiUnknown[], long *plOffset);

    HRESULT AddNode(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pItem);
    HRESULT AddNodeAfter(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pPrevious, CSelectionHolder *pItem);

    HRESULT DeleteNode(CSelectionHolder *pItem);
    HRESULT GetItemParam(CSelectionHolder *pItem, CSelectionHolder **ppObject);
    HRESULT GetItemParam(HTREEITEM hItem, CSelectionHolder **ppObject);
    HRESULT ChangeText(CSelectionHolder *pItem, char *pszNewName);
    HRESULT ChangeNodeIcon(CSelectionHolder *pItem, int iImage);
    HRESULT HitTest(POINT pHit, CSelectionHolder **ppSelection);
    HRESULT GetRectangle(CSelectionHolder *pSelection, RECT *prc);
    HRESULT SelectItem(CSelectionHolder *pSelection);
    HRESULT Edit(CSelectionHolder *pSelection);

    HRESULT GetParent(CSelectionHolder *pSelection, CSelectionHolder **ppParent);
    HRESULT GetFirstChildNode(CSelectionHolder *pSelection, CSelectionHolder **ppChild);
    HRESULT GetNextChildNode(CSelectionHolder *pChild, CSelectionHolder **ppNextChild);
    HRESULT GetPreviousNode(CSelectionHolder *pNode, CSelectionHolder **ppPreviousNode);

    HRESULT GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel);
    HRESULT GetLabelA(CSelectionHolder *pSelection, char *pszBuffer, int cbBuffer);

    HRESULT MoveNodeAfter(CSelectionHolder *pNode,
                          CSelectionHolder *pParent,
                          CSelectionHolder *pPrevious,
                          int               iImage);

    HRESULT PruneAndGraft(CSelectionHolder *pNode, CSelectionHolder *pNewParentNode, int iImage);
    HRESULT Graft(CSelectionHolder *pNode, CSelectionHolder *pNewParentNode, int iImage);

////////////////////////////////////////////////////////////////////////////////////
// Member variables
protected:
    HWND                 m_hTreeView;
    WNDPROC              m_fnTreeProc;
};


#endif // _TREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\tvcmd.cpp ===
//=--------------------------------------------------------------------------------------
// tvcmd.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Command multiplexers
// Deleting, properties
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingView(MMCViewMenuInfo *pMMCViewMenuInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingView(MMCViewMenuInfo *pMMCViewMenuInfo)
{
    HRESULT           hr = S_OK;
    IViewDefs        *piViewDefs = NULL;
    CSelectionHolder *pParent = NULL;
    ISnapInDef       *piSnapInDef = NULL;

    if (m_pCurrentSelection != NULL)
    {
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_AUTO_CREATE_ROOT:
            hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
            IfFailGo(hr);

            hr = piSnapInDef->get_ViewDefs(&piViewDefs);
            IfFailGo(hr);
            break;

        case SEL_NODES_ANY_VIEWS:
            hr = m_pTreeView->GetParent(m_pCurrentSelection, &pParent);
            IfFailGo(hr);

            hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
            IfFailGo(hr);
            break;

        case SEL_NODES_ANY_NAME:
            hr = m_pCurrentSelection->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
            IfFailGo(hr);
            break;
        }
    }

    if (piViewDefs != NULL)
    {
        switch (pMMCViewMenuInfo->m_vmit)
        {
        case MMCViewMenuInfo::vmitListView:
            hr = AddExistingListView(piViewDefs, pMMCViewMenuInfo->m_view.m_piListViewDef);
            IfFailGo(hr);
            break;

        case MMCViewMenuInfo::vmitOCXView:
            hr = AddExistingOCXView(piViewDefs, pMMCViewMenuInfo->m_view.m_piOCXViewDef);
            IfFailGo(hr);
            break;

        case MMCViewMenuInfo::vmitURLView:
            hr = AddExistingURLView(piViewDefs, pMMCViewMenuInfo->m_view.m_piURLViewDef);
            IfFailGo(hr);
            break;

        case MMCViewMenuInfo::vmitTaskpad:
            hr = AddExistingTaskpadView(piViewDefs, pMMCViewMenuInfo->m_view.m_piTaskpadViewDef);
            IfFailGo(hr);
            break;
        }
    }

Error:
    RELEASE(piSnapInDef);
    RELEASE(piViewDefs);
    if (pMMCViewMenuInfo != NULL)
        delete pMMCViewMenuInfo;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DoRename(CSelectionHolder *pSelection, TCHAR *pszNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// The point here is to trigger an ObjectModel notification.
//
HRESULT CSnapInDesigner::DoRename(CSelectionHolder *pSelection, TCHAR *pszNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrNewName = NULL;
    ISnapInDef *piSnapInDef = NULL;
    ITaskpad   *piTaskpad = NULL;

    hr = BSTRFromANSI(pszNewName, &bstrNewName);
    IfFailGo(hr);

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:
        hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
        IfFailGo(hr);

        hr = piSnapInDef->put_Name(bstrNewName);
        IfFailGo(hr);

    case SEL_NODES_ANY_NAME:
        hr = pSelection->m_piObject.m_piScopeItemDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = pSelection->m_piObject.m_piListViewDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = pSelection->m_piObject.m_piURLViewDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = pSelection->m_piObject.m_piOCXViewDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = pSelection->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        hr = piTaskpad->put_Name(bstrNewName);
        IfFailGo(hr);

        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = pSelection->m_piObject.m_piMMCImageList->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = pSelection->m_piObject.m_piMMCToolbar->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = pSelection->m_piObject.m_piMMCMenu->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = pSelection->m_piObject.m_piDataFormat->put_Name(bstrNewName);
        IfFailGo(hr);
        break;
    }

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_RENAME_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_RenameFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piSnapInDef);
    RELEASE(piTaskpad);
    FREESTRING(bstrNewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DoDelete(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DoDelete(CSelectionHolder *pSelection)
{
    HRESULT     hr = S_OK;

    switch (pSelection->m_st)
    {
    case SEL_EEXTENSIONS_NAME:
        hr = DeleteExtendedSnapIn(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_CC_NEW:
        hr = DeleteExtensionNewMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_CC_TASK:
        hr = DeleteExtensionTaskMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_PP_ROOT:
        hr = DeleteExtensionPropertyPages(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_TASKPAD:
        hr = DeleteExtensionTaskpad(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_TOOLBAR:
        hr = DeleteExtensionToolbar(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_NAMESPACE:
        hr = DeleteExtensionNameSpace(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_NEW_MENU:
        hr = DeleteMyExtendsNewMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_TASK_MENU:
        hr = DeleteMyExtendsTaskMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_TOP_MENU:
        hr = DeleteMyExtendsTopMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_VIEW_MENU:
        hr = DeleteMyExtendsViewMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_PPAGES:
        hr = DeleteMyExtendsPPages(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_TOOLBAR:
        hr = DeleteMyExtendsToolbar(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_NAMESPACE:
        hr = DeleteMyExtendsNameSpace(pSelection);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = DeleteScopeItem(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = DeleteListView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = DeleteOCXView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = DeleteURLView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = DeleteTaskpadView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = DeleteImageList(pSelection);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = DeleteMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = DeleteToolbar(pSelection);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = DeleteDataFormat(pSelection);
        IfFailGo(hr);
    }

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_DELETE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_DeleteFailed, hr, AppendErrorInfo, NULL);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowProperties(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowProperties
(
    CSelectionHolder *pSelection
)
{
    HRESULT                hr = S_OK;
    CSelectionHolder      *pParent = NULL;

    ASSERT(pSelection != NULL, "ShowProperties: pSelection is NULL");

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:

    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_NODES_OTHER:

    case SEL_TOOLS_ROOT:
    case SEL_TOOLS_IMAGE_LISTS:
    case SEL_TOOLS_MENUS:
    case SEL_TOOLS_TOOLBARS:
    case SEL_VIEWS_ROOT:
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:

    case SEL_XML_RESOURCES:
        hr = ShowSnapInProperties();
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_ROOT:
        hr = ShowSnapInExtensions();
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = ShowNodeProperties(pSelection->m_piObject.m_piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_CHILDREN:
    case SEL_NODES_ANY_VIEWS:
        hr = m_pTreeView->GetParent(pSelection, &pParent);
        IfFailGo(hr);

        ASSERT(SEL_NODES_ANY_NAME == pParent->m_st, "ShowProperties: Expected ScopeItem");

        hr = ShowNodeProperties(pParent->m_piObject.m_piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = ShowListViewProperties(pSelection->m_piObject.m_piListViewDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = ShowOCXViewProperties(pSelection->m_piObject.m_piOCXViewDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = ShowURLViewProperties(pSelection->m_piObject.m_piURLViewDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = ShowTaskpadViewProperties(pSelection->m_piObject.m_piTaskpadViewDef);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = ShowImageListProperties(pSelection->m_piObject.m_piMMCImageList);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = ShowToolbarProperties(pSelection->m_piObject.m_piMMCToolbar);
        IfFailGo(hr);
    default:
        hr = S_FALSE;
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Manipulating the ISnapInDef
// renaming and properties
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameSnapIn(CSelectionHolder *pSnapIn, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameSnapIn(CSelectionHolder *pSnapIn, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    ISnapInDef          *piSnapInDef = NULL;
    BSTR                 bstrOldName = NULL;
    TCHAR               *pszName = NULL;
    CSelectionHolder    *pExtension = NULL;

    ASSERT(SEL_SNAPIN_ROOT == pSnapIn->m_st, "RenameSnapIn: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->GetLabel(pSnapIn, &bstrOldName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Name(&bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pSnapIn, pszName);
    IfFailGo(hr);

    hr = m_pTreeView->GetFirstChildNode(m_pRootExtensions, &pExtension);
    IfFailGo(hr);

    while (SEL_EXTENSIONS_MYNAME != pExtension->m_st)
    {
        hr = m_pTreeView->GetNextChildNode(pExtension, &pExtension);
        IfFailGo(hr);
    }

    if (NULL != pExtension)
    {
        hr = m_pTreeView->ChangeText(pExtension, pszName);
        IfFailGo(hr);
    }

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    RELEASE(piSnapInDef);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowSnapInProperties()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowSnapInProperties()
{
    HRESULT              hr = S_OK;
    OCPFIPARAMS          ocpfiParams;
    TCHAR                szBuffer[kMaxBuffer + 1];
    BSTR                 bstrCaption = NULL;
    IUnknown            *pUnk[1];
    CLSID                pageClsID[2];
    ISnapInDef          *piSnapInDef = NULL;
    SnapInTypeConstants  OldSnapInType = siStandAlone;
    SnapInTypeConstants  NewSnapInType = siStandAlone;

    hr = GetResourceString(IDS_SNAPIN_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Store the snap-in type. If it changes in the property sheet then we
    // may need to adjust the tree by adding or removing the auto-creates
    // subtree.
    
    IfFailGo(piSnapInDef->get_Type(&OldSnapInType));

    hr = piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_SnapInDefGeneralPP;
    pageClsID[1] = CLSID_SnapInDefImageListPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = DISPID_SNAPIN_TYPE;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

    // Check if the snap-in type changed
    
    IfFailGo(piSnapInDef->get_Type(&NewSnapInType));
    IfFalseGo(NewSnapInType != OldSnapInType, S_OK);

    // If the old type was not an extension and now it is an extension then
    // we need to remove the auto-creates subtree

    if ( (siExtension != OldSnapInType) && (siExtension == NewSnapInType) )
    {
        IfFailGo(RemoveAutoCreateSubTree());
    }

    // If the old type was an extension and now it not an extension then
    // we need to add the auto-creates subtree

    else if ( (siExtension == OldSnapInType) && (siExtension != NewSnapInType) )
    {
        IfFailGo(CreateAutoCreateSubTree(m_pRootNodes));
    }


Error:
    RELEASE(piSnapInDef);
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowSnapInExtensions()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowSnapInExtensions()
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[1];
    ISnapInDef     *piSnapInDef = NULL;

    hr = GetResourceString(IDS_SNAPIN_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_SnapInDefExtensionsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 1;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = DISPID_SNAPIN_TYPE;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\tvpopul.cpp ===
//=--------------------------------------------------------------------------------------
// tvpopul.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Initializing and populating the tree view
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "desmain.h"
#include "TreeView.h"

// for ASSERT and FAIL
//
SZTHISFILE


const int   kMaxBuffer = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializePresentation()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the tree. This top level function populates the root and
//      four children, and calls helper functions tha build the sub-trees off them.
// 
HRESULT CSnapInDesigner::InitializePresentation()
{
    HRESULT              hr = S_OK;
    ISnapInDef          *piSnapInDef = NULL;
    TCHAR               *pszSnapInName = NULL;

    // Create the tree root node
    hr = GetSnapInName(&pszSnapInName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    m_pRootNode = New CSelectionHolder(SEL_SNAPIN_ROOT, piSnapInDef);
    if (NULL == m_pRootNode)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pRootNode->RegisterHolder();
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszSnapInName, NULL, kClosedFolderIcon, m_pRootNode);
    IfFailGo(hr);

    hr = CreateExtensionsTree(m_pRootNode);
    IfFailGo(hr);

    hr = CreateNodesTree(m_pRootNode);
    IfFailGo(hr);

    hr = CreateToolsTree(m_pRootNode);
    IfFailGo(hr);

    hr = CreateViewsTree(m_pRootNode);
    IfFailGo(hr);

    // UNDONE: we are leaving the data formats section out of the tree until
    // we make a final decision regarding XML
    
    // hr = CreateDataFormatsTree(m_pRootNode);
    IfFailGo(hr);

    hr = OnSelectionChanged(m_pRootNode);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(m_pRootNode);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);
    if (NULL != pszSnapInName)
        CtlFree(pszSnapInName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateExtensionsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the Extensions subtree
//
HRESULT CSnapInDesigner::CreateExtensionsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT              hr = S_OK;
    IExtensionDefs      *piExtensionDefs = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    m_pRootExtensions = New CSelectionHolder(SEL_EXTENSIONS_ROOT, piExtensionDefs);
    if (NULL == m_pRootExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // We want to receive notifications of changes to basic properties and additions to the collection
    // of extended snap-ins.
    hr = m_pRootExtensions->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_EXTENSIONS_ROOT, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, m_pRootExtensions);
    IfFailGo(hr);

    hr = PopulateExtensions(m_pRootExtensions);
    IfFailGo(hr);

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateExtensions(CSelectionHolder *pExtensionsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Extensions subtree. We cycle through IExtensionDefs collection
//      of the snap-in and populate tree nodes accordingly.
//
HRESULT CSnapInDesigner::PopulateExtensions
(
    CSelectionHolder *pExtensionsParent
)
{
    HRESULT             hr = S_OK;
    IExtensionDefs     *piExtensionDefs = NULL;
    ISnapInDef         *piSnapInDef = NULL;
    SnapInTypeConstants sitc = siStandAlone;
    IExtendedSnapIns   *piExtendedSnapIns = NULL;
    long                lCount = 0;
    long                lIndex = 1;
    IExtendedSnapIn    *piExtendedSnapIn = NULL;
    VARIANT             vtIndex;
    TCHAR              *pszSnapInName = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    // Add the snap-ins we're extending
    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Type(&sitc);
    IfFailGo(hr);

    if (siStandAlone != sitc)
    {
        hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
        IfFailGo(hr);

        hr = piExtendedSnapIns->get_Count(&lCount);
        IfFailGo(hr);

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.vt = VT_I4;
            vtIndex.lVal = lIndex;
            hr = piExtendedSnapIns->get_Item(vtIndex, &piExtendedSnapIn);
            IfFailGo(hr);

            hr = CreateExtendedSnapIn(pExtensionsParent, piExtendedSnapIn);
            IfFailGo(hr);

            RELEASE(piExtendedSnapIn);
        }
    }

    // Always extend myself
    m_pRootMyExtensions = New CSelectionHolder(SEL_EXTENSIONS_MYNAME, piExtensionDefs);
    if (NULL == m_pRootMyExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetSnapInName(&pszSnapInName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszSnapInName, pExtensionsParent, kClosedFolderIcon, m_pRootMyExtensions);
    IfFailGo(hr);

    hr = PopulateSnapInExtensions(m_pRootMyExtensions, piExtensionDefs);
    IfFailGo(hr);

Error:
    if (NULL != pszSnapInName)
        CtlFree(pszSnapInName);
    ::VariantClear(&vtIndex);
    RELEASE(piExtendedSnapIn);
    RELEASE(piExtendedSnapIns);
    RELEASE(piSnapInDef);
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateExtendedSnapIn(CSelectionHolder *pRoot, IExtendedSnapIn *piExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Extensions/<Extended snap-in> node.
//
HRESULT CSnapInDesigner::CreateExtendedSnapIn(CSelectionHolder *pRoot, IExtendedSnapIn *piExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    char             *pszDisplayName = NULL;
    CSelectionHolder *pExtendedSnapIn = NULL;

    IfFailGo(::GetExtendedSnapInDisplayName(piExtendedSnapIn, &pszDisplayName));

    pExtendedSnapIn = New CSelectionHolder(piExtendedSnapIn);
    IfFailGo(hr);

    pExtendedSnapIn->RegisterHolder();
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszDisplayName, pRoot, kClosedFolderIcon,
                              pExtendedSnapIn);
    IfFailGo(hr);

    hr = PopulateExtendedSnapIn(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    if (NULL != pszDisplayName)
        CtlFree(pszDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Extensions/<Extended snap-in> node.
//
HRESULT CSnapInDesigner::PopulateExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pContextMenus = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    VARIANT_BOOL         bValue = VARIANT_FALSE;
    CSelectionHolder    *pSelection = NULL;

    // Create the Context Menus folder
    pContextMenus = New CSelectionHolder(SEL_EEXTENSIONS_CC_ROOT, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pContextMenus)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_EXT_CONTEXT_MENUS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pContextMenus);
    IfFailGo(hr);

    // Check to see if it extends New menu
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_CC_NEW, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_CTX_MENU_NEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pContextMenus, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Task menu
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_CC_TASK, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_CTX_MENU_TASK, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pContextMenus, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Property Pages
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_PP_ROOT, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_PAGES, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Taskpad
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_TASKPAD, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_TASKPAD, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Toolbar
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_TOOLBAR, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_TOOLBAR, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Namespace
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_NAMESPACE, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_NAMESPACE, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateSnapInExtensions(CSelectionHolder *pRoot, IExtensionDefs *piExtensionDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Extensions/<Snap-in Name> node.
//
// <Root>/Extensions/<Snap-in Name>/ExtendsNewMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsTaskMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsTopMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsViewMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsPropertyPages
// <Root>/Extensions/<Snap-in Name>/ExtendsToolbar
// <Root>/Extensions/<Snap-in Name>/ExtendsNameSpace

HRESULT CSnapInDesigner::PopulateSnapInExtensions(CSelectionHolder *pRoot, IExtensionDefs *piExtensionDefs)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    VARIANT_BOOL         bValue = VARIANT_FALSE;
    CSelectionHolder    *pNode = NULL;

    // <Root>/Extensions/<Snap-in Name>/ExtendsNewMenu
    hr = piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_NEW_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_NEW_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsTaskMenu
    hr = piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_TASK_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_TASK_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsTopMenu
    hr = piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_TOP_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_TOP_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsViewMenu
    hr = piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_VIEW_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_VIEW_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsPropertyPages
    hr = piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_PPAGES, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_PPAGES, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsToolbar
    hr = piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_TOOLBAR, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_TOOLBAR, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsNamespace
    hr = piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_NAMESPACE, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_NAMESPACE, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateNodesTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Nodes node.
//
HRESULT CSnapInDesigner::CreateNodesTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Create the parent node, <Root>/Nodes.
    m_pRootNodes = New CSelectionHolder(SEL_NODES_ROOT, piSnapInDef);
    if (NULL == m_pRootNodes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_NODES_ROOT, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, m_pRootNodes);
    IfFailGo(hr);

    // Populate the subtree
    hr = PopulateNodes(m_pRootNodes);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateNodes(CSelectionHolder *pNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Nodes subtree.
//
HRESULT CSnapInDesigner::PopulateNodes
(
    CSelectionHolder *pNodesParent
)
{
    HRESULT              hr = S_OK;
    ISnapInDef          *piSnapInDef = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    IScopeItemDefs      *piScopeItemDefs = NULL;
    SnapInTypeConstants  SnapInType = siStandAlone;

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    IfFailGo(piSnapInDef->get_Type(&SnapInType));

    if (siExtension != SnapInType)
    {
        IfFailGo(CreateAutoCreateSubTree(pNodesParent));
    }

    // Build the <Root>/Nodes/Other tree
    hr = m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs);
    IfFailGo(hr);

    m_pOtherRoot = New CSelectionHolder(SEL_NODES_OTHER, piScopeItemDefs);
    if (NULL == m_pOtherRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pOtherRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_NODES_OTHER, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pNodesParent, kClosedFolderIcon, m_pOtherRoot);
    IfFailGo(hr);

    hr = PopulateOtherNodes(m_pOtherRoot);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateAutoCreateSubTree(CSelectionHolder *pNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Nodes/Auto-Create subtree.
//
HRESULT CSnapInDesigner::CreateAutoCreateSubTree
(
    CSelectionHolder *pNodesParent
)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    SnapInTypeConstants  SnapInType = siStandAlone;
    ISnapInDef          *piSnapInDef = NULL;

    IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));

    // Create the <Root>/Nodes/Auto-Create tree
    m_pAutoCreateRoot = New CSelectionHolder(SEL_NODES_AUTO_CREATE, piSnapInDef);
    if (NULL == m_pAutoCreateRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        IfFailGo(hr);
    }

    hr = GetResourceString(IDS_NODES_AUTO_CREATE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    // Insert node at the top of <Root>/Nodes

    hr = m_pTreeView->AddNodeAfter(szBuffer, pNodesParent, kClosedFolderIcon,
                                   NULL, m_pAutoCreateRoot);
    IfFailGo(hr);

    hr = PopulateAutoCreateNodes(m_pAutoCreateRoot);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateAutoCreateNodes(CSelectionHolder *pAutoCreateNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the Nodes/Auto-Create subtree. Cycle through the IScopeItemDef's for
//      auto-create nodes and populate this subtree.
//
HRESULT CSnapInDesigner::PopulateAutoCreateNodes
(
    CSelectionHolder *pAutoCreateNodesParent
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pRootNode = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Always have a root: <Root>/Nodes/Auto-Create/Static Node
    pRootNode = New CSelectionHolder(SEL_NODES_AUTO_CREATE_ROOT, piSnapInDef);
    if (NULL == pRootNode)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_NODES_STATIC, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pAutoCreateNodesParent,
                              kClosedFolderIcon, pRootNode);
    IfFailGo(hr);

    hr = PopulateStaticNodeTree(pRootNode);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}


HRESULT CSnapInDesigner::RemoveAutoCreateSubTree()
{
    HRESULT           hr = S_OK;
    IScopeItemDefs   *piAutoCreates = NULL;
    IScopeItemDefs   *piScopeItemDefs = NULL;
    ISnapInDef       *piSnapInDef = NULL;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;

    IfFalseGo(NULL != m_pAutoCreateRoot, S_OK);

    // Get <Root>/Nodes/Auto-Create/Static Node/Children
    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piAutoCreates));

    // Remove everything from the collection
    IfFailGo(piAutoCreates->Clear());

    // Get <Root>/Nodes/Auto-Create/Static Node/ResultViews
    IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));
    IfFailGo(piSnapInDef->get_ViewDefs(&piViewDefs));

    // Remove everything from each of the result view collections
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(piListViewDefs->Clear());
    
    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));
    IfFailGo(piOCXViewDefs->Clear());

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));
    IfFailGo(piURLViewDefs->Clear());

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(piTaskpadViewDefs->Clear());

    IfFailGo(DeleteSubTree(m_pAutoCreateRoot));
    IfFailGo(m_pTreeView->DeleteNode(m_pAutoCreateRoot));

    // Need to unregister here in order to set
    // SnapInDesignerDef.AutoCreateNodes cookie to zero. If the user
    // decides to switch back to standalone or dual mode, the code in
    // CSnapInDesigner::PopulateStaticNodeTree() will detect a zero cookie
    // and register a new one.
    
    IfFailGo(m_pAutoCreateRoot->UnregisterHolder());
    m_pAutoCreateRoot = NULL;

    IfFailGo(OnSelectionChanged(m_pRootNode));
    IfFailGo(m_pTreeView->SelectItem(m_pRootNode));

Error:
    QUICK_RELEASE(piAutoCreates);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DeleteSubTree(CSelectionHolder *pNode)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pNextChild = NULL;
    CSelectionHolder *pThisChild = NULL;

    IfFailGo(m_pTreeView->GetFirstChildNode(pNode, &pNextChild));

    while (NULL != pNextChild)
    {
        pThisChild = pNextChild;
        IfFailGo(m_pTreeView->GetNextChildNode(pThisChild, &pNextChild));

        IfFailGo(DeleteSubTree(pThisChild));
        IfFailGo(m_pTreeView->DeleteNode(pThisChild));
        IfFailGo(pThisChild->UnregisterHolder());
        delete pThisChild;
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateOtherNodes(CSelectionHolder *pOtherNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the Nodes/Other subtree.
//
HRESULT CSnapInDesigner::PopulateOtherNodes
(
    CSelectionHolder *pOtherNodesParent
)
{
    HRESULT            hr = S_OK;
    IScopeItemDefs    *piScopeItemDefs = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IScopeItemDef     *piScopeItemDef = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs);
    IfFailGo(hr);

    hr = piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->get_Item(vtIndex, &piScopeItemDef);
        IfFailGo(hr);

        hr = PopulateNodeTree(pOtherNodesParent, piScopeItemDef);
        IfFailGo(hr);

        RELEASE(piScopeItemDef);
    }

Error:
    RELEASE(piScopeItemDef);
    ::VariantClear(&vtIndex);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateStaticNodeTree(CSelectionHolder *pStaticNode)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Nodes/Auto-Create/Static Node/ subtree.
//
HRESULT CSnapInDesigner::PopulateStaticNodeTree
(
    CSelectionHolder  *pStaticNode
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pChildrenRoot = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];
    IScopeItemDefs    *piScopeItemDefs = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IScopeItemDef     *piScopeItemDef = NULL;
    CSelectionHolder  *pViewsRoot = NULL;
    IViewDefs         *piViewDefs = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // <Root>/Nodes/Auto-Create/Static Node/Views
    pViewsRoot = New CSelectionHolder(SEL_NODES_AUTO_CREATE_RTVW, piSnapInDef);
    if (NULL == pViewsRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piSnapInDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = RegisterViewCollections(pViewsRoot, piViewDefs);
    IfFailGo(hr);

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pStaticNode, kClosedFolderIcon, pViewsRoot);
    IfFailGo(hr);

    // Cycle through the views defined for this node
    hr = PopulateListViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    hr = PopulateOCXViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    hr = PopulateURLViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    hr = PopulateTaskpadViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    // <Root>/Nodes/Auto-Create/Static Node/Children
    hr = m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs);
    IfFailGo(hr);

    pChildrenRoot = New CSelectionHolder(SEL_NODES_AUTO_CREATE_RTCH, piScopeItemDefs);
    if (NULL == pChildrenRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pChildrenRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_CHILDREN, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pStaticNode, kClosedFolderIcon, pChildrenRoot);
    IfFailGo(hr);

    hr = piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->get_Item(vtIndex, &piScopeItemDef);
        IfFailGo(hr);

        hr = PopulateNodeTree(pChildrenRoot, piScopeItemDef);
        IfFailGo(hr);

        RELEASE(piScopeItemDef);
    }

Error:
    RELEASE(piViewDefs);
    RELEASE(piScopeItemDef);
    ::VariantClear(&vtIndex);
    RELEASE(piScopeItemDefs);
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateToolsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the <Root>/Tools subtree
//
HRESULT CSnapInDesigner::CreateToolsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pRootTools = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    pRootTools = New CSelectionHolder(SEL_TOOLS_ROOT, piSnapInDef);
    if (NULL == pRootTools)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_TOOLS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pRootTools);
    IfFailGo(hr);

    hr = InitializeToolsTree(pRootTools);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeToolsTree(CSelectionHolder *pToolsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the 3 basic nodes of the <Root>/Tools subtree
//
HRESULT CSnapInDesigner::InitializeToolsTree
(
    CSelectionHolder *pToolsParent
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    IMMCImageLists    *piMMCImageLists = NULL;
    IMMCMenus         *piMMCMenus = NULL;
    IMMCToolbars      *piMMCToolbars = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // ImageLists
    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    m_pToolImgLstRoot = New CSelectionHolder(piMMCImageLists);
    if (NULL == m_pToolImgLstRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pToolImgLstRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_IMAGE_LISTS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pToolsParent, kClosedFolderIcon, m_pToolImgLstRoot);
    IfFailGo(hr);

    hr = PopulateImageLists(m_pToolImgLstRoot);
    IfFailGo(hr);

    // Menus
    hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
    IfFailGo(hr);

    m_pToolMenuRoot = New CSelectionHolder(piMMCMenus);
    if (NULL == m_pToolMenuRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pToolMenuRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_MENUS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pToolsParent, kClosedFolderIcon, m_pToolMenuRoot);
    IfFailGo(hr);

    hr = PopulateMenus(m_pToolMenuRoot, piMMCMenus);
    IfFailGo(hr);

    // Toolbars
    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    m_pToolToolbarRoot = New CSelectionHolder(piMMCToolbars);
    if (NULL == m_pToolToolbarRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pToolToolbarRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_TOOLBARS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pToolsParent, kClosedFolderIcon, m_pToolToolbarRoot);
    IfFailGo(hr);

    hr = PopulateToolbars(m_pToolToolbarRoot);
    IfFailGo(hr);

Error:
    RELEASE(piMMCToolbars);
    RELEASE(piMMCMenus);
    RELEASE(piMMCImageLists);
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateImageLists(CSelectionHolder *pImageListsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Tools/ImageLists subtree
//
HRESULT CSnapInDesigner::PopulateImageLists
(
    CSelectionHolder *pImageListsParent
)
{
    HRESULT            hr = S_OK;
    IMMCImageLists    *piMMCImageLists = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IMMCImageList     *piMMCImageList = NULL;
    CSelectionHolder  *pImageList = NULL;
    BSTR               bstrName = NULL;
    TCHAR             *pszAnsi = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = m_pSnapInTypeInfo->AddImageList(piMMCImageList);
        IfFailGo(hr);

        pImageList = New CSelectionHolder(piMMCImageList);
        if (NULL == pImageList)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pImageList->RegisterHolder();
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pImageListsParent, kImageListIcon, pImageList);
        IfFailGo(hr);

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piMMCImageList);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateMenus(CSelectionHolder *pMenusParent, IMMCMenus *piMMCMenus)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Tools/Menus subtree
//
HRESULT CSnapInDesigner::PopulateMenus
(
    CSelectionHolder *pMenusParent,
    IMMCMenus        *piMMCMenus
)
{
    HRESULT            hr = S_OK;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    CSelectionHolder  *pMenu = NULL;
    IMMCMenu          *piMMCMenu = NULL;
    BSTR               bstrName = NULL;
    TCHAR             *pszAnsi = NULL;
    IMMCMenus         *piChildren = NULL;
    long               lChildrenCount = 0;

    ::VariantInit(&vtIndex);

    hr = piMMCMenus->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCMenus->get_Item(vtIndex, reinterpret_cast<MMCMenu **>(&piMMCMenu));
        IfFailGo(hr);

        hr = piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piChildren));
        IfFailGo(hr);

        pMenu = New CSelectionHolder(piMMCMenu, piChildren);
        if (NULL == pMenu)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pMenu->RegisterHolder();
        IfFailGo(hr);

        hr = piMMCMenu->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pMenusParent, kMenuIcon, pMenu);
        IfFailGo(hr);

        hr = m_pSnapInTypeInfo->IsNameDefined(bstrName);
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = m_pSnapInTypeInfo->AddMenu(pMenu->m_piObject.m_piMMCMenu);
            IfFailGo(hr);
        }

		hr = piChildren->get_Count(&lChildrenCount);
		IfFailGo(hr);

        if (lChildrenCount > 0)
        {
            hr = PopulateMenus(pMenu, piChildren);
            IfFailGo(hr);
        }

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piMMCMenu);
        RELEASE(piChildren);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    RELEASE(piMMCMenu);
    RELEASE(piChildren);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateToolbars(CSelectionHolder *pToolbarsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Tools/Toolbars subtree
//
HRESULT CSnapInDesigner::PopulateToolbars
(
    CSelectionHolder *pToolbarsParent
)
{
    HRESULT            hr = S_OK;
    IMMCToolbars      *piMMCToolbars = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IMMCToolbar       *piMMCToolbar = NULL;
    CSelectionHolder  *pToolbar = NULL;
    BSTR               bstrName = NULL;
    TCHAR             *pszAnsi = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    hr = piMMCToolbars->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCToolbars->get_Item(vtIndex, &piMMCToolbar);
        IfFailGo(hr);

        hr = m_pSnapInTypeInfo->AddToolbar(piMMCToolbar);
        IfFailGo(hr);

        pToolbar = New CSelectionHolder(piMMCToolbar);
        if (NULL == pToolbar)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pToolbar->RegisterHolder();
        IfFailGo(hr);

        hr = piMMCToolbar->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pToolbarsParent, kToolbarIcon, pToolbar);
        IfFailGo(hr);

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piMMCToolbar);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    RELEASE(piMMCToolbar);
    RELEASE(piMMCToolbars);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateViewsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the  <Root>/Views subtree
//
HRESULT CSnapInDesigner::CreateViewsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pRootViews = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Create the views subtree
    pRootViews = New CSelectionHolder(SEL_VIEWS_ROOT, piSnapInDef);
    if (NULL == pRootViews)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pRootViews);
    IfFailGo(hr);

    hr = InitializeViews(pRootViews);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeViews(CSelectionHolder *pViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Views/* tree.
//
HRESULT CSnapInDesigner::InitializeViews
(
    CSelectionHolder *pViewsParent
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    IViewDefs         *piViewDefs = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];
    CSelectionHolder  *pViewTaskRoot = NULL;
    IListViewDefs     *piListViewDefs = NULL;
    IOCXViewDefs      *piOCXViewDefs = NULL;
    IURLViewDefs      *piURLViewDefs = NULL;
    ITaskpadViewDefs  *piTaskpadViewDefs = NULL;

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Get the master collections of views
    hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    // Create the ListView node and populate the subtree
    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    m_pViewListRoot = New CSelectionHolder(SEL_VIEWS_LIST_VIEWS, piListViewDefs);
    if (NULL == m_pViewListRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pViewListRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_LISTVIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, m_pViewListRoot);
    IfFailGo(hr);

    hr = PopulateListViews(piViewDefs, m_pViewListRoot);
    IfFailGo(hr);

    // Create the OCXView node and populate the subtree
    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    m_pViewOCXRoot = New CSelectionHolder(SEL_VIEWS_OCX, piOCXViewDefs);
    if (NULL == m_pViewOCXRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pViewOCXRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_OCXVIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, m_pViewOCXRoot);
    IfFailGo(hr);

    hr = PopulateOCXViews(piViewDefs, m_pViewOCXRoot);
    IfFailGo(hr);

    // Create the URLView node and populate the subtree
    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    m_pViewURLRoot = New CSelectionHolder(SEL_VIEWS_URL, piURLViewDefs);
    if (NULL == m_pViewURLRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pViewURLRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_URLVIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, m_pViewURLRoot);
    IfFailGo(hr);

    hr = PopulateURLViews(piViewDefs, m_pViewURLRoot);
    IfFailGo(hr);

    // Create the TaskpadView node and populate the subtree
    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    pViewTaskRoot = New CSelectionHolder(SEL_VIEWS_TASK_PAD, piTaskpadViewDefs);
    if (NULL == pViewTaskRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pViewTaskRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_TASKPADS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, pViewTaskRoot);
    IfFailGo(hr);

    hr = PopulateTaskpadViews(piViewDefs, pViewTaskRoot);
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateListViews(IViewDefs *piViewDefs, CSelectionHolder *pListViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateListViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pListViewsParent
)
{
    HRESULT           hr = S_OK;
    IListViewDefs    *piListViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    IListViewDef     *piListViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (piViewDefs == NULL)
    {
        goto Error;
    }

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    if (NULL != piListViewDefs)
    {
        hr = piListViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
            IfFailGo(hr);

            hr = piListViewDef->get_Name(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piListViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pListViewsParent, kListViewIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piListViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piListViewDefs);
    RELEASE(piListViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateOCXViews(IViewDefs *piViewDefs, CSelectionHolder *pOCXViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateOCXViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pOCXViewsParent
)
{
    HRESULT           hr = S_OK;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    IOCXViewDef      *piOCXViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (NULL == piViewDefs)
    {
        goto Error;
    }

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    if (NULL != piOCXViewDefs)
    {
        hr = piOCXViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
            IfFailGo(hr);

            hr = piOCXViewDef->get_Name(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piOCXViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pOCXViewsParent, kOCXViewIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piOCXViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piOCXViewDefs);
    RELEASE(piOCXViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateURLViews(IViewDefs *piViewDefs, CSelectionHolder *pURLViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateURLViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pURLViewsParent
)
{
    HRESULT           hr = S_OK;
    IURLViewDefs     *piURLViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    IURLViewDef      *piURLViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (NULL == piViewDefs)
    {
        goto Error;
    }

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    if (NULL != piURLViewDefs)
    {
        hr = piURLViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
            IfFailGo(hr);

            hr = piURLViewDef->get_Name(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piURLViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pURLViewsParent, kURLViewIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piURLViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piURLViewDefs);
    RELEASE(piURLViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateTaskpadViews(IViewDefs *piViewDefs, CSelectionHolder *pTaskpadViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateTaskpadViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pTaskpadViewsParent
)
{
    HRESULT           hr = S_OK;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (NULL == piViewDefs)
    {
        goto Error;
    }

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    if (NULL != piTaskpadViewDefs)
    {
        hr = piTaskpadViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
            IfFailGo(hr);

            hr = piTaskpadViewDef->get_Key(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piTaskpadViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pTaskpadViewsParent, kTaskpadIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piTaskpadViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RegisterViewCollections(CSelectionHolder *pSelection, IViewDefs *piViewDefs)
//=--------------------------------------------------------------------------------------
//  
HRESULT CSnapInDesigner::RegisterViewCollections(CSelectionHolder *pSelection, IViewDefs *piViewDefs)
{
    HRESULT              hr = S_OK;
    IObjectModel        *piObjectModel = NULL;
    IListViewDefs       *piListViewDefs = NULL;
    IOCXViewDefs        *piOCXViewDefs = NULL;
    IURLViewDefs        *piURLViewDefs = NULL;
    ITaskpadViewDefs    *piTaskpadViewDefs = NULL;

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    RELEASE(piObjectModel);
    hr = piOCXViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    RELEASE(piObjectModel);
    hr = piURLViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

    RELEASE(piObjectModel);
    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateNodeTree(CSelectionHolder *pNodeParent, IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Recursive function used to populate a node tree. For a piScopeItemDef, create the
//  piScopeItemDef/Children/* and piScopeItemDef/Views/* subtrees.
//
HRESULT CSnapInDesigner::PopulateNodeTree
(
    CSelectionHolder *pNodeParent,
    IScopeItemDef    *piScopeItemDef
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;
    BSTR                 bstrName = NULL;
    TCHAR               *pszAnsi = NULL;
    CSelectionHolder    *pChildren = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pViews = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    long                 lCount = 0;
    long                 lIndex = 0;
    VARIANT              vtIndex;
    IScopeItemDef       *piChildScopeItemDef = NULL;
    IViewDefs           *piViewDefs = NULL;

    ::VariantInit(&vtIndex);

    pSelection = New CSelectionHolder(SEL_NODES_ANY_NAME, piScopeItemDef);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pSelection->RegisterHolder();
    IfFailGo(hr);

    hr = piScopeItemDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszAnsi);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszAnsi, pNodeParent, kScopeItemIcon, pSelection);
    IfFailGo(hr);

    // Populate the views for this node
    pViews = New CSelectionHolder(SEL_NODES_ANY_VIEWS, piScopeItemDef);
    if (NULL == pViews)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = RegisterViewCollections(pViews, piViewDefs);
    IfFailGo(hr);

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pSelection, kClosedFolderIcon, pViews);
    IfFailGo(hr);

    hr = PopulateListViews(piViewDefs, pViews);
    IfFailGo(hr);

    hr = PopulateOCXViews(piViewDefs, pViews);
    IfFailGo(hr);

    hr = PopulateURLViews(piViewDefs, pViews);
    IfFailGo(hr);

    hr = PopulateTaskpadViews(piViewDefs, pViews);
    IfFailGo(hr);

    // Populate the children for this node
    hr = piScopeItemDef->get_Children(&piScopeItemDefs);
    IfFailGo(hr);

    pChildren = New CSelectionHolder(SEL_NODES_ANY_CHILDREN, piScopeItemDefs);
    if (NULL == pChildren)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pChildren->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_CHILDREN, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pSelection, kClosedFolderIcon, pChildren);
    IfFailGo(hr);

    hr = piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->get_Item(vtIndex, &piChildScopeItemDef);
        IfFailGo(hr);

        hr = PopulateNodeTree(pChildren, piChildScopeItemDef);
        IfFailGo(hr);

        RELEASE(piChildScopeItemDef);
    }

Error:
    RELEASE(piViewDefs);
    RELEASE(piChildScopeItemDef);
    RELEASE(piScopeItemDefs);
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateDataFormatsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the  <Root>/Data Formats subtree
//
HRESULT CSnapInDesigner::CreateDataFormatsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    IDataFormats      *piDataFormats = NULL;
    CSelectionHolder  *pRootDataFormats = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_DataFormats(&piDataFormats);
    IfFailGo(hr);

    // Create the Data Formats subtree
    pRootDataFormats = New CSelectionHolder(piDataFormats);
    if (NULL == piDataFormats)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_DATAFORMATS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pRootDataFormats);
    IfFailGo(hr);

    hr = pRootDataFormats->RegisterHolder();
    IfFailGo(hr);

    hr = PopulateDataFormats(pRootDataFormats, piDataFormats);
    IfFailGo(hr);

Error:
    RELEASE(piDataFormats);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateDataFormats(CSelectionHolder *pRoot, IDataFormats *piDataFormats)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::PopulateDataFormats
(
    CSelectionHolder *pRoot,
    IDataFormats     *piDataFormats
)
{
    HRESULT              hr = S_OK;
    long                 lCount = 0;
    long                 lIndex = 0;
    VARIANT              vtIndex;
    IDataFormat         *piDataFormat = NULL;
    CSelectionHolder    *pDataFormat = NULL;
    BSTR                 bstrName = NULL;
    TCHAR               *pszAnsi = NULL;

    ::VariantInit(&vtIndex);

    hr = piDataFormats->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piDataFormats->get_Item(vtIndex, &piDataFormat);
        IfFailGo(hr);

        pDataFormat = New CSelectionHolder(piDataFormat);
        if (NULL == pDataFormat)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pDataFormat->RegisterHolder();
        IfFailGo(hr);

        hr = piDataFormat->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pRoot, kDataFmtIcon, pDataFormat);
        IfFailGo(hr);

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piDataFormat);
    }

Error:
    FREESTRING(bstrName);
    ::VariantClear(&vtIndex);
    RELEASE(piDataFormat);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetSnapInName
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//
HRESULT CSnapInDesigner::GetSnapInName
(
    TCHAR **ppszNodeName
)
{
    HRESULT         hr = S_OK;
    ISnapInDef     *piSnapInDef = NULL;
    BSTR            bstrName = NULL;

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Name(&bstrName);
    if (bstrName != NULL)
    {
        hr = ANSIFromBSTR(bstrName, ppszNodeName);
        IfFailGo(hr);
    }

Error:
    RELEASE(piSnapInDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\wndproc.cpp ===
//=--------------------------------------------------------------------------------------
// wndproc.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// Designer WinProc and friends
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "desmain.h"
#include "TreeView.h"

// for ASSERT and FAIL
//
SZTHISFILE

#define CheckHMenuResult(hMenu) \
                if (NULL == (hMenu))                                \
                {                                                   \
                    hr = HRESULT_FROM_WIN32(::GetLastError());      \
                    EXCEPTION_CHECK_GO(hr);                         \
                }

//=--------------------------------------------------------------------------------------
// Toolbar stuff
//
const int kToolbarIdentifier    =   9;
const int kMainBitmapCount              =  14;
const int kMainBitmapSize               =  16;       // square


// static array describing our main toolbar.
//
static TBBUTTON g_MainButtons[] = {
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  0, CMD_ADD_NODE,         TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  1, CMD_ADD_LISTVIEW,     TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  2, CMD_ADD_TASKPAD,      TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  3, CMD_ADD_OCX_VIEW,     TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  4, CMD_ADD_WEB_VIEW,     TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  5, CMD_ADD_IMAGE_LIST,   TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  6, CMD_ADD_TOOLBAR,      TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  7, CMD_ADD_MENU,         TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  8, CMD_PROMOTE,          TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  9, CMD_DEMOTE,           TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { 10, CMD_MOVE_UP,          TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { 11, CMD_MOVE_DOWN,        TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
    { 12, CMD_VIEW_PROPERTIES,  TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
    { 13, CMD_DELETE,           TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1}
};


//=--------------------------------------------------------------------------------------
// array that contains mappings between ids and resource ids for tooltip strings.
//
struct IdToResId {
    UINT    id;
    WORD    resid;
} static g_tooltipMappings [] = {
    { CMD_ADD_NODE,             IDS_TT_ADD_NODE},
    { CMD_ADD_LISTVIEW,         IDS_TT_ADD_LISTVIEW},
    { CMD_ADD_TASKPAD,          IDS_TT_ADD_TASKPAD},
    { CMD_ADD_OCX_VIEW,         IDS_TT_ADD_OCX_VIEW},
    { CMD_ADD_WEB_VIEW,         IDS_TT_ADD_WEB_VIEW},
    { CMD_ADD_IMAGE_LIST,       IDS_TT_ADD_IMAGE_LIST},
    { CMD_ADD_TOOLBAR,          IDS_TT_ADD_TOOLBAR},
    { CMD_ADD_MENU,             IDS_TT_ADD_MENU},
    { CMD_PROMOTE,              IDS_TT_PROMOTE},
    { CMD_DEMOTE,               IDS_TT_DEMOTE},
    { CMD_MOVE_UP,              IDS_TT_MOVE_UP},
    { CMD_MOVE_DOWN,            IDS_TT_MOVE_DOWN},
    { CMD_VIEW_PROPERTIES,      IDS_TT_VIEW_PROPERTIES},
    { CMD_DELETE,               IDS_TT_DELETE},
    { 0xffff, 0xffff}
};


//=--------------------------------------------------------------------------=
// CSnapInDesigner::BeforeCreateWindow(DWORD *pdwWindowStyle, DWORD *pdwExWindowStyle, LPSTR pszWindowTitle)
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::RegisterClassData()
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::RegisterClassData()
{
    HRESULT     hr = S_OK;
    ATOM        atom = 0;
    WNDCLASSEX  wndClass;

        if (0 == ::GetClassInfoEx(GetResourceHandle(), WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_SNAPINDESIGNER), &wndClass))
        {
        ::memset(&wndClass, 0, sizeof(WNDCLASSEX));

                wndClass.cbSize                 = sizeof(WNDCLASSEX);
        wndClass.style          = NULL; // CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        wndClass.lpfnWndProc    = COleControl::ControlWindowProc;
        wndClass.hInstance      = GetResourceHandle();
        wndClass.hCursor        = ::LoadCursor(NULL, IDC_ARROW);
        wndClass.hbrBackground  = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
        wndClass.lpszClassName  = WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_SNAPINDESIGNER);

        atom = ::RegisterClassEx(&wndClass);
        if (0 == atom)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }
    }

    return SUCCEEDED(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::AfterCreateWindow()
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::AfterCreateWindow()
{
    HRESULT       hr = S_OK;
    int           iToolbarHeight = 0;
    RECT          rc;
    RECT          rcTreeView;
    ISnapInDef   *piSnapInDef = NULL;
    BOOL          fInteractive = VARIANT_FALSE;

    IfFailGo(AttachAmbients());
    IfFailGo(m_Ambients.GetInteractive(&fInteractive));

    IfFailGo(GetHostServices(fInteractive));

    g_GlobalHelp.Attach(m_piHelp);

    // Initialize the Views: toolbar and treeview
    hr = InitializeToolbar();
    IfFailGo(hr);

    iToolbarHeight = m_rcToolbar.bottom - m_rcToolbar.top;
    ::GetWindowRect(m_hwnd, &rc);

    ::SetRect(&rcTreeView,
              0,
              iToolbarHeight,
              rc.right,
              rc.bottom - rc.top);

    m_pTreeView = New CTreeView();
    if (NULL == m_pTreeView)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = m_pTreeView->Initialize(m_hwnd, rcTreeView);
    IfFailGo(hr);

    ::MoveWindow(m_pTreeView->TreeViewWindow(),
                 0,
                 iToolbarHeight,
                 rc.right - rc.left,
                 rc.bottom - rc.top - iToolbarHeight,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    if (NULL == m_bstrName)
    {
        hr = UpdateDesignerName();
        IfFailGo(hr);
    }

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->InitializeTypeInfo(piSnapInDef, m_bstrName);
    IfFailGo(hr);

    // Populate the tree
    hr = InitializePresentation();
    IfFailGo(hr);

    hr = OnPrepareToolbar();
    IfFailGo(hr);

    ::SetFocus(m_pTreeView->TreeViewWindow());

    if (FALSE == m_bDidLoad)
    {
        ::PostMessage(m_hwnd, CMD_SHOW_MAIN_PROPERTIES, 0, 0);
    }

Error:
    RELEASE(piSnapInDef);

    return SUCCEEDED(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeToolbar()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
//
HRESULT CSnapInDesigner::InitializeToolbar()
{
    HRESULT     hr = S_OK;
    RECT        rc;

    m_hwdToolbar = ::CreateToolbarEx(m_hwnd,
                                     TBSTYLE_TOOLTIPS | WS_CHILD,
                                     kToolbarIdentifier,
                                     kMainBitmapCount,
                                     GetResourceHandle(),
                                     IDB_TOOLBAR,
                                     g_MainButtons,
                                     sizeof(g_MainButtons) / sizeof(TBBUTTON),
                                     kMainBitmapSize,
                                     kMainBitmapSize,
                                     kMainBitmapSize,
                                     kMainBitmapSize,
                                     sizeof(TBBUTTON));
    if (m_hwdToolbar == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    ::GetWindowRect(m_hwnd, &rc);
    ::GetWindowRect(m_hwdToolbar, &m_rcToolbar);

    ::MoveWindow(m_hwdToolbar,
                 0,
                 0,
                 rc.right - rc.left,
                 m_rcToolbar.bottom - m_rcToolbar.top,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    ::ShowWindow(m_hwdToolbar, SW_SHOW);

Error:
    RRETURN(hr);
}


void CSnapInDesigner::OnHelp()
{
    DWORD dwHelpContextID = HID_mssnapd_DesignerWindow;

    if (NULL == m_pCurrentSelection)
    {
        goto DisplayHelp;
    }

    switch (m_pCurrentSelection->m_st)
    {
        case SEL_SNAPIN_ROOT:
            dwHelpContextID = HID_mssnapd_DesignerWindow;
            break;

        case SEL_EXTENSIONS_ROOT:
            dwHelpContextID = HID_mssnapd_Extensions;
            break;

        case SEL_EXTENSIONS_NEW_MENU:
        case SEL_EXTENSIONS_TASK_MENU:
        case SEL_EXTENSIONS_TOP_MENU:
        case SEL_EXTENSIONS_VIEW_MENU:
        case SEL_EXTENSIONS_PPAGES:
        case SEL_EXTENSIONS_TOOLBAR:
        case SEL_EXTENSIONS_NAMESPACE:
            dwHelpContextID = HID_mssnapd_MyExtensions;
            break;

        case SEL_EEXTENSIONS_CC_ROOT:
        case SEL_EEXTENSIONS_CC_NEW:
        case SEL_EEXTENSIONS_CC_TASK:
        case SEL_EEXTENSIONS_PP_ROOT:
        case SEL_EEXTENSIONS_TASKPAD:
        case SEL_EEXTENSIONS_TOOLBAR:
        case SEL_EEXTENSIONS_NAMESPACE:
            dwHelpContextID = HID_mssnapd_Extensions;
            break;

        case SEL_NODES_ROOT:
        case SEL_NODES_AUTO_CREATE:
        case SEL_NODES_AUTO_CREATE_ROOT:
        case SEL_NODES_ANY_NAME:
        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
        case SEL_NODES_OTHER:
            dwHelpContextID = HID_mssnapd_Nodes;
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
        case SEL_VIEWS_ROOT:
            dwHelpContextID = HID_mssnapd_ResultViews;
            break;

        case SEL_TOOLS_ROOT:
            dwHelpContextID = HID_mssnapd_Tools;
            break;

        case SEL_TOOLS_IMAGE_LISTS:
        case SEL_TOOLS_IMAGE_LISTS_NAME:
            dwHelpContextID = HID_mssnapd_ImageLists;
            break;

        case SEL_VIEWS_LIST_VIEWS:
        case SEL_VIEWS_LIST_VIEWS_NAME:
            dwHelpContextID = HID_mssnapd_ListViews;
            break;

        case SEL_VIEWS_OCX:
        case SEL_VIEWS_OCX_NAME:
            dwHelpContextID = HID_mssnapd_OCXViews;
            break;

        case SEL_VIEWS_URL:
        case SEL_VIEWS_URL_NAME:
            dwHelpContextID = HID_mssnapd_URLViews;
            break;

        case SEL_VIEWS_TASK_PAD:
        case SEL_VIEWS_TASK_PAD_NAME:
            dwHelpContextID = HID_mssnapd_Taskpads;
            break;

        case SEL_TOOLS_TOOLBARS:
        case SEL_TOOLS_TOOLBARS_NAME:
            dwHelpContextID = HID_mssnapd_Toolbars;
            break;

        case SEL_TOOLS_MENUS:
        case SEL_TOOLS_MENUS_NAME:
            dwHelpContextID = HID_mssnapd_Menus;
            break;

        default:
            dwHelpContextID = HID_mssnapd_DesignerWindow;
            break;
    }

    
DisplayHelp:
    g_GlobalHelp.ShowHelp(dwHelpContextID);
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------=
//
// Notes:
//
LRESULT CSnapInDesigner::WindowProc
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT     hr = S_FALSE;
    long        lResult = 0;
    HMENU       hmenuPopup = NULL;
    BOOL        fSystemMenu = FALSE;
    TCHAR      *pszNewName = NULL;

    switch (uMsg)
    {
    case WM_SIZE:
        hr = OnResize(uMsg, wParam, lParam);
        IfFailGo(hr);
        return TRUE;

    case WM_SETFOCUS:
        uMsg = uMsg;
//        hr = theView->OnGotFocus(uMsg, wParam, lParam, &lResult);
//        CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);
        return TRUE;

    case WM_ACTIVATE:
        uMsg = uMsg;
        return TRUE;

    case WM_NOTIFY:
        hr = OnNotify(uMsg, wParam, lParam, &lResult);
        IfFailGo(hr);
        return (0 == lResult) ? FALSE : TRUE;

    case WM_COMMAND:
        hr = OnCommand(uMsg, wParam, lParam);
        IfFailGo(hr);
        return TRUE;

    case WM_INITMENUPOPUP:
        hmenuPopup = reinterpret_cast<HMENU>(wParam);
        fSystemMenu = static_cast<BOOL>(HIWORD(lParam));
        if (fSystemMenu == FALSE)
        {
            hr = OnInitMenuPopup(hmenuPopup);
            IfFailGo(hr);
        }
        return TRUE;

    case WM_CONTEXTMENU:
        hr = OnContextMenu(m_hwnd, uMsg, wParam, lParam);
        IfFailGo(hr);
        return TRUE;

    case WM_HELP:
        OnHelp();
        return TRUE;

    case CMD_SHOW_MAIN_PROPERTIES:
        hr = ShowProperties(m_pRootNode);
        IfFailGo(hr);
        return TRUE;

    case CMD_ADD_EXISTING_VIEW:
        hr = AddExistingView(reinterpret_cast<MMCViewMenuInfo *>(lParam));
        IfFailGo(hr);
        return TRUE;

    case CMD_RENAME_NODE:
        pszNewName = reinterpret_cast<TCHAR *>(lParam);
        ASSERT(NULL != pszNewName, "WindowProc: pszNewName is NULL");

        hr = DoRename(m_pCurrentSelection, pszNewName);
        IfFailGo(hr);

        ::CtlFree(pszNewName);
        return TRUE;

    default:
        return OcxDefWindowProc(uMsg, wParam, lParam);
    }

Error:
    return FALSE;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnDraw(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::OnDraw
(
    DWORD    dvAspect,
    HDC      hdcDraw,
    LPCRECTL prcBounds,
    LPCRECTL prcWBounds,
    HDC      hicTargetDev,
    BOOL     fOptimize
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnResize(UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnResize
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT     hr = S_FALSE;
    HWND        hwdParent = NULL;
    RECT        rcClient;
    int         iWidth = 0;
    int         iToolbarHeight = 0;

    if (m_hwnd)
    {
        hwdParent = ::GetParent(m_hwnd);
        ::GetClientRect(hwdParent, &rcClient);

        iWidth = rcClient.right - rcClient.left;

        // Resize ourselves
        ::MoveWindow(m_hwnd,
                     0,
                     0,
                     iWidth,
                     rcClient.bottom - rcClient.top,
                     SWP_NOZORDER | SWP_NOACTIVATE);

        // Resize the toolbar
        iToolbarHeight = m_rcToolbar.bottom - m_rcToolbar.top;

        ::MoveWindow(m_hwdToolbar,
                     0,
                     0,
                     iWidth,
                     iToolbarHeight,
                     SWP_NOZORDER | SWP_NOACTIVATE);

        // Resize the tree view
        if (NULL != m_pTreeView)
        {
            ::MoveWindow(m_pTreeView->TreeViewWindow(),
                         0,
                         iToolbarHeight,
                         iWidth,
                         rcClient.bottom - rcClient.top - iToolbarHeight,
                         SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnCommand(UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnCommand
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT   hr = S_OK;
    WORD      wNotifyCode = HIWORD(wParam);             // Should be zero if from a menu
    WORD      wID = LOWORD(wParam);                             // Menu item

    m_bDoingPromoteOrDemote = false;

    switch (wID)
    {
    case CMD_ADD_NODE:
        hr = AddNewNode();
        IfFailGo(hr);
        break;

    case CMD_ADD_LISTVIEW:
        hr = AddListView();
        IfFailGo(hr);
        break;

    case CMD_ADD_TASKPAD:
        hr = AddTaskpadView();
        IfFailGo(hr);
        break;

    case CMD_ADD_OCX_VIEW:
        hr = AddOCXView();
        IfFailGo(hr);
        break;

    case CMD_ADD_WEB_VIEW:
        hr = AddURLView();
        IfFailGo(hr);
        break;

    case CMD_ADD_IMAGE_LIST:
        hr = AddImageList();
        IfFailGo(hr);
        break;

    case CMD_ADD_TOOLBAR:
        hr = AddToolbar();
        IfFailGo(hr);
        break;

    case CMD_ADD_MENU:
        hr = AddMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_DEMOTE:
        hr = DemoteMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_PROMOTE:
        hr = PromoteMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_MOVE_UP:
        hr = MoveMenuUp(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_MOVE_DOWN:
        hr = MoveMenuDown(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_VIEW_PROPERTIES:
        hr = ShowProperties(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_RENAME:
        hr = m_pTreeView->Edit(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_VIEW_DLGUNITS:
        IfFailGo(ShowDlgUnitConverter());
        break;

    case CMD_DELETE:
        hr = DoDelete(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_CM_NEW:
        hr = DoExtensionNewMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_CM_TASK:
        hr = DoExtensionTaskMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;
    case CMD_EXT_PPAGES:
        hr = DoExtensionPropertyPages(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_TASKPAD:
        hr = DoExtensionTaskpad(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_TOOLBAR:
        hr = DoExtensionToolbar(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_NAMESPACE:
        hr = DoExtensionNameSpace(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_NEW_MENU:
        hr = DoMyExtendsNewMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_TASK_MENU:
        hr = DoMyExtendsTaskMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_TOP_MENU:
        hr = DoMyExtendsTopMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_VIEW_MENU:
        hr = DoMyExtendsViewMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_PPAGES:
        hr = DoMyExtendsPPages(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_TOOLBAR:
        hr = DoMyExtendsToolbar(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_NAMESPACE:
        hr = DoMyExtendsNameSpace(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_ADD_RESOURCE:
        hr = AddResource();
        IfFailGo(hr);
        break;

    case CMD_VIEW_RESOURCE_REFRESH:
        hr = RefreshResource(m_pCurrentSelection);
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnNotify(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lResult)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnNotify
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *lResult
)
{
        HRESULT           hr = S_FALSE;
        int               idCtrl;
        LPNMHDR           pnmh = NULL;
        NM_TREEVIEW          *pnmtv = NULL;
        HTREEITEM         htiCurrent = NULL;
    CSelectionHolder  selection;
    CSelectionHolder *pSelection = NULL;
    DWORD             dwPos = 0;
    POINT             pHit;
    NMTVDISPINFO     *pnmTVDispInfo = NULL;
    TCHAR            *pszNewName = NULL;

    idCtrl = static_cast<int>(wParam);
        pnmh = reinterpret_cast<LPNMHDR>(lParam);

        switch (pnmh->code)
        {
    case TTN_NEEDTEXT:
        hr = OnNeedText(lParam);
        IfFailGo(hr);
        break;

        case NM_DBLCLK:
        dwPos = ::GetMessagePos();

        pHit.x = static_cast<LONG>(static_cast<short>(LOWORD(dwPos)));
        pHit.y = static_cast<LONG>(static_cast<short>(HIWORD(dwPos)));

        ::ScreenToClient(m_pTreeView->TreeViewWindow(), &pHit);

        hr = m_pTreeView->HitTest(pHit, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
        {
            hr = OnDoubleClick(pSelection);
            IfFailGo(hr);

            if (hr == S_FALSE)
            {
                WinProcHandled(FALSE);
            }
            else
            {
                WinProcHandled(TRUE);
            }
            hr = S_OK;
        }
        else
        {
            WinProcHandled(FALSE);
        }
        break;

    case TVN_SELCHANGED:
                pnmtv = reinterpret_cast<NM_TREEVIEW *>(lParam);
        htiCurrent = pnmtv->itemNew.hItem;

        selection.m_pvData = htiCurrent;
        hr = m_pTreeView->GetItemParam(htiCurrent, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
        {
            hr = OnSelectionChanged(pSelection);
            IfFailGo(hr);
        }
        WinProcHandled(FALSE);
        break;

    case TVN_ITEMEXPANDED:
                pnmtv = reinterpret_cast<NM_TREEVIEW *>(lParam);
        if (pnmtv->action == TVE_COLLAPSE)
        {
            htiCurrent = pnmtv->itemNew.hItem;

            selection.m_pvData = htiCurrent;
            hr = m_pTreeView->GetItemParam(htiCurrent, &pSelection);
            IfFailGo(hr);

            if (SEL_NODES_ANY_NAME != pSelection->m_st && SEL_TOOLS_MENUS_NAME != pSelection->m_st)
            {
                hr = m_pTreeView->ChangeNodeIcon(pSelection, kClosedFolderIcon);
                IfFailGo(hr);
            }
        }
        else if (pnmtv->action == TVE_EXPAND)
        {
            htiCurrent = pnmtv->itemNew.hItem;

            selection.m_pvData = htiCurrent;
            hr = m_pTreeView->GetItemParam(htiCurrent, &pSelection);
            IfFailGo(hr);

            if (SEL_NODES_ANY_NAME != pSelection->m_st && SEL_TOOLS_MENUS_NAME != pSelection->m_st)
            {
                hr = m_pTreeView->ChangeNodeIcon(pSelection, kOpenFolderIcon);
                IfFailGo(hr);
            }
        }
        WinProcHandled(FALSE);
        break;

    case TVN_KEYDOWN:
        hr = OnKeyDown(reinterpret_cast<NMTVKEYDOWN *>(lParam));
        IfFailGo(hr);

        WinProcHandled(FALSE);
        break;

    case TVN_BEGINLABELEDIT:
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
        case SEL_NODES_ANY_NAME:
        case SEL_TOOLS_IMAGE_LISTS_NAME:
        case SEL_TOOLS_MENUS_NAME:
        case SEL_TOOLS_TOOLBARS_NAME:
        case SEL_VIEWS_LIST_VIEWS_NAME:
        case SEL_VIEWS_OCX_NAME:
        case SEL_VIEWS_URL_NAME:
        case SEL_VIEWS_TASK_PAD_NAME:
        case SEL_XML_RESOURCE_NAME:
            WinProcHandled(FALSE);  // Enable label editing
            break;
        default:
            WinProcHandled(TRUE);   // Disable label editing
            break;
        }
        break;

    case TVN_ENDLABELEDIT:
        // This message needs to complete before we attempt any further operations,
        // so at this point the only thing we do is post another message.
        pnmTVDispInfo = reinterpret_cast<NMTVDISPINFO *>(lParam);
        ASSERT(NULL != pnmTVDispInfo, "OnNotify: pnmTVDispInfo is NULL");

        if ( (NULL != pnmTVDispInfo->item.pszText) &&
             (pnmTVDispInfo->item.cchTextMax < 1024) )
        {
            pszNewName = reinterpret_cast<TCHAR *>(::CtlAlloc(sizeof(TCHAR) * (pnmTVDispInfo->item.cchTextMax + 1)));
            if (NULL == pszNewName)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            _tcscpy(pszNewName, pnmTVDispInfo->item.pszText);

            ::PostMessage(m_hwnd, CMD_RENAME_NODE, 0, reinterpret_cast<LPARAM>(pszNewName));
            WinProcHandled(FALSE);
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnNeedText(LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnNeedText
(
    LPARAM lParam
)
{
    HRESULT         hr = S_OK;
        LPTOOLTIPTEXT   pttt = NULL;
        int             x = 0;

    pttt = reinterpret_cast<LPTOOLTIPTEXT>(lParam);
    pttt->hinst = GetResourceHandle();

    // get the resource id associated with this ID
    while (0xffff != g_tooltipMappings[x].id)
    {
        if (g_tooltipMappings[x].id == pttt->hdr.idFrom)
            break;
        x++;
    }

    if (0xffff != g_tooltipMappings[x].id)
        pttt->lpszText = MAKEINTRESOURCE(g_tooltipMappings[x].resid);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDoubleClick(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnDoubleClick
(
    CSelectionHolder *pSelection
)
{
    HRESULT          hr = S_OK;
    BSTR             bstrObject = NULL;
    BSTR             bstrEventHandler = NULL;
    ICodeNavigate   *piCodeNavigate = NULL;
    IMMCButtons     *piMMCButtons = NULL;
    IMMCButton      *piMMCButton = NULL;
    long             cButtons = 0;
    ITaskpad        *piTaskpad = NULL;

    SnapInTaskpadTypeConstants TaskpadType = Default;

    SnapInButtonStyleConstants ButtonStyle = siDefault;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    ASSERT(pSelection != NULL, "OnDoubleClick: pSelection is NULL");

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:
        bstrObject = ::SysAllocString(L"SnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Load");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_ROOT:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_NEW_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddNewMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_TASK_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTaskMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_TOP_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTopMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_VIEW_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddViewMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_PPAGES:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"CreatePropertyPages");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_TOOLBAR:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"SetControlBar");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_NAMESPACE:
        bstrObject = ::SysAllocString(L"ScopeItems");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddNewMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_CC_TASK:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTaskMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_PP_ROOT:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"CreatePropertyPages");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_TASKPAD:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTasks");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_TOOLBAR:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        bstrEventHandler = ::SysAllocString(L"SetControlBar");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_NAMESPACE:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;


    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_ANY_NAME:
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_ANY_CHILDREN:
        bstrObject = ::SysAllocString(L"ScopeItems");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Initialize");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_NODES_OTHER:
        bstrObject = ::SysAllocString(L"ScopeItems");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_NODES_ANY_VIEWS:
    case SEL_TOOLS_ROOT:
    case SEL_TOOLS_IMAGE_LISTS:
    case SEL_TOOLS_IMAGE_LISTS_NAME:
    case SEL_VIEWS_ROOT:
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_URL_NAME:
    case SEL_VIEWS_TASK_PAD:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Initialize");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_VIEWS_OCX_NAME:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"InitializeControl");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(pSelection->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad));
        IfFailGo(piTaskpad->get_Type(&TaskpadType));

        if (Listpad == TaskpadType)
        {
            bstrEventHandler = ::SysAllocString(L"ListpadButtonClick");
        }
        else if (Custom == TaskpadType)
        {
            bstrEventHandler = ::SysAllocString(L"TaskNotify");
        }
        else // default taskpad
        {
            bstrEventHandler = ::SysAllocString(L"TaskClick");
        }
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_TOOLBARS:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"SetControlBar");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_MENUS:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTopMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = pSelection->m_piObject.m_piMMCMenu->get_Name(&bstrObject);
        IfFailGo(hr);

        bstrEventHandler = ::SysAllocString(L"Click");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_TOOLBARS_NAME:

        hr = pSelection->m_piObject.m_piMMCToolbar->get_Name(&bstrObject);
        IfFailGo(hr);

        // Determine whether this toolbar represents a toolbar or a menu
        // button by examining the button styles. A menu button is defined by
        // a toolbar in which all buttons have the dropdown style.

        IfFailGo(pSelection->m_piObject.m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons)));
        IfFailGo(piMMCButtons->get_Count(&cButtons));

        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;

        while ( (varIndex.lVal <= cButtons) && (NULL == bstrEventHandler) )
        {
            IfFailGo(piMMCButtons->get_Item(varIndex, reinterpret_cast<MMCButton **>(&piMMCButton)));
            IfFailGo(piMMCButton->get_Style(&ButtonStyle));
            if (siDropDown != ButtonStyle)
            {
                // Found a button that is not dropdown style. Assume this is
                // a toolbar.

                bstrEventHandler = ::SysAllocString(L"ButtonClick");
                if (NULL == bstrEventHandler)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }
            }
            varIndex.lVal++;
        }

        // If we are here and the loop didn't set the event handler name then
        // either the toolbar has no buttons defined or all of the buttons have
        // the dropdown style which means that the toolbar represents a menu
        // button.

        if (NULL == bstrEventHandler)
        {
            if (0 == cButtons)
            {
                // No buttons defined. Default to a toolbar.
                bstrEventHandler = ::SysAllocString(L"ButtonClick");
            }
            else
            {
                bstrEventHandler = ::SysAllocString(L"ButtonMenuClick");
            }
            if (NULL == bstrEventHandler)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
        }

        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Initialize");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    default:
        hr = S_FALSE;
        break;
    }

    if (NULL != m_piCodeNavigate2)
    {
        if (NULL != bstrEventHandler)
        {
            hr = m_piCodeNavigate2->DisplayEventHandler(bstrObject, bstrEventHandler);
            IfFailGo(hr);
        }
        else if (NULL != bstrObject)
        {
            hr = m_piCodeNavigate2->QueryInterface(IID_ICodeNavigate, reinterpret_cast<void **>(&piCodeNavigate));
            IfFailGo(hr);

            hr = piCodeNavigate->DisplayDefaultEventHandler(bstrObject);
            IfFailGo(hr);
        }
    }

Error:
    QUICK_RELEASE(piCodeNavigate);
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrEventHandler);
    FREESTRING(bstrObject);
    QUICK_RELEASE(piMMCButtons);
    QUICK_RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnPrepareToolbar()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnPrepareToolbar()
{
    HRESULT     hr = S_OK;
    LRESULT             lResult = 0;

    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_PROMOTE, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_DEMOTE, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_UP, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_DOWN, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(FALSE, 0));

    if (m_pCurrentSelection != NULL)
    {
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        // Extensions subtree
        case SEL_EXTENSIONS_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_EEXTENSIONS_NAME:
        case SEL_EEXTENSIONS_CC_NEW:
        case SEL_EEXTENSIONS_CC_TASK:
        case SEL_EEXTENSIONS_PP_ROOT:
        case SEL_EEXTENSIONS_TASKPAD:
        case SEL_EEXTENSIONS_TOOLBAR:
        case SEL_EEXTENSIONS_NAMESPACE:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        // We turn bits off in the extensibility model by deleting a node from the tree.
        case SEL_EXTENSIONS_NEW_MENU:
        case SEL_EXTENSIONS_TASK_MENU:
        case SEL_EXTENSIONS_TOP_MENU:
        case SEL_EXTENSIONS_VIEW_MENU:
        case SEL_EXTENSIONS_PPAGES:
        case SEL_EXTENSIONS_TOOLBAR:
        case SEL_EXTENSIONS_NAMESPACE:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_AUTO_CREATE_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_OTHER:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_ANY_NAME:
            // Enable new node, net view buttons.
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_ANY_CHILDREN:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_ANY_VIEWS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        // Tools subtree
        case SEL_TOOLS_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_MENUS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_MENUS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_PROMOTE, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_DEMOTE, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_UP, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_DOWN, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));

            hr = CanPromoteMenu(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_PROMOTE, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_PROMOTE, MAKELONG(FALSE, 0));

            hr = CanDemoteMenu(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DEMOTE, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DEMOTE, MAKELONG(FALSE, 0));

            hr = CanMoveMenuUp(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_UP, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_UP, MAKELONG(FALSE, 0));

            hr = CanMoveMenuDown(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_DOWN, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_DOWN, MAKELONG(FALSE, 0));

            break;

        case SEL_TOOLS_TOOLBARS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        // View subtree
        case SEL_VIEWS_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_LIST_VIEWS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_OCX:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_OCX_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_URL:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_URL_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_TASK_PAD:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_TASK_PAD_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_XML_RESOURCES:
//            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_XML_RESOURCE_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnKeyDown(NMTVKEYDOWN *pNMTVKeyDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnKeyDown(NMTVKEYDOWN *pNMTVKeyDown)
{
    HRESULT     hr = S_OK;

    switch (pNMTVKeyDown->wVKey)
    {
    case VK_DELETE:
        hr = DoDelete(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    default:
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnContextMenu(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnContextMenu
(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT           hr = S_OK;
    DWORD             dwPos = 0;
    POINT             pHit;
    CSelectionHolder *pSelection = NULL;
    RECT              rc;

    // lParam is valid if this is a right mouse click
    if (-1 != lParam)
    {
        // Make sure we select the tree item under the mouse
        dwPos = ::GetMessagePos();

        // Vegas #46772: Multi-monitor support
        pHit.x = (LONG)(short)LOWORD(dwPos);
        pHit.y = (LONG)(short)HIWORD(dwPos);
        ::ScreenToClient(m_pTreeView->TreeViewWindow(), &pHit);

        hr = m_pTreeView->HitTest(pHit, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
        {
            // First make sure that the item we're clicking on is selected
            if (m_pCurrentSelection == NULL || m_pCurrentSelection->IsEqual(pSelection) != true)
            {
                hr = OnSelectionChanged(pSelection);
                IfFailGo(hr);

                hr = m_pTreeView->SelectItem(pSelection);
                IfFailGo(hr);
            }
        }
    }

    if (NULL != m_pCurrentSelection)
    {
        hr = m_pTreeView->GetRectangle(m_pCurrentSelection, &rc);
        IfFailGo(hr);

        pHit.x = rc.right;
        pHit.y = rc.top;
        ::ClientToScreen(m_pTreeView->TreeViewWindow(), &pHit);
        IfFailGo(hr);

        hr = DoOnContextMenu(pHit.x, pHit.y);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DoOnContextMenu(int x, int y)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::DoOnContextMenu(int x, int y)
{
    HRESULT           hr = S_OK;
    HMENU             hMenu = NULL;
    HMENU             hSubMenu = NULL;
    int               iCmd = 0;

    if (m_pCurrentSelection != NULL)
    {
        // Select the appropriate MENU resouce
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_ROOT));
            CheckHMenuResult(hMenu);
            break;

        case SEL_EXTENSIONS_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_EXTENSIONS_ROOT));
            CheckHMenuResult(hMenu);
            break;

        case SEL_EEXTENSIONS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_EXTENSIONS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_EXTENSIONS_MYNAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_THIS_EXTENSIONS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_AUTO_CREATE_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_STATIC_NODE));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_NODE_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_ANY_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_NODE));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_NODE_CHILDREN));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_OTHER:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_NODE_OTHER));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TOOLS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_IMAGE_LISTS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_IMAGE_LIST));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_MENUS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_MENUS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_MENUS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_MENU));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_TOOLBARS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TOOLBARS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TOOLBAR));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_LIST_VIEWS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_LIST_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_OCX:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_OCX_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_URL:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_URL_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_TASK_PAD:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TASKPAD_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
        case SEL_VIEWS_OCX_NAME:
        case SEL_VIEWS_URL_NAME:
        case SEL_VIEWS_TASK_PAD_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_VIEW));
            CheckHMenuResult(hMenu);
            break;

        case SEL_XML_RESOURCES:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_RESOURCES));
            CheckHMenuResult(hMenu);
            break;

        case SEL_XML_RESOURCE_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_RESOURCE));
            CheckHMenuResult(hMenu);
            break;
        }

        // If we've got a resource, invoke the menu
        if (hMenu != NULL)
        {
            hSubMenu = ::GetSubMenu(hMenu, 0);
            if (hSubMenu == NULL)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }

            iCmd = ::TrackPopupMenu(hSubMenu,
                                    TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                    x,
                                    y,
                                    0,
                                    m_hwnd,
                                    NULL);

            if (SEL_NODES_AUTO_CREATE_ROOT == m_pCurrentSelection->m_st
             || SEL_NODES_AUTO_CREATE_RTVW == m_pCurrentSelection->m_st
             || SEL_NODES_ANY_VIEWS == m_pCurrentSelection->m_st
             || SEL_NODES_ANY_NAME == m_pCurrentSelection->m_st)
            {
                hr = CleanPopupNodeViews(hSubMenu, iCmd);
                IfFailGo(hr);
            }

            ::PostMessage(m_hwnd, WM_COMMAND, iCmd, 0);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopup(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopup
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    if (m_pCurrentSelection != NULL)
    {
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
            hr = OnInitMenuPopupRoot(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_EXTENSIONS_ROOT:
            hr = OnInitMenuPopupExtensionRoot(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_EEXTENSIONS_NAME:
            hr = OnInitMenuPopupExtension(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_EXTENSIONS_MYNAME:
            hr = OnInitMenuPopupMyExtensions(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_ROOT:
            hr = OnInitMenuPopupStaticNode(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_ANY_NAME:
            hr = OnInitMenuPopupNode(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
            hr = OnInitMenuPopupNodeChildren(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
            hr = OnInitMenuPopupNodeViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_OTHER:
            hr = OnInitMenuPopupNodeOther(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_ROOT:
            hr = OnInitMenuPopupToolsRoot(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            hr = OnInitMenuPopupImageLists(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            hr = OnInitMenuPopupImageList(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS:
            hr = OnInitMenuPopupMenus(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS_NAME:
            hr = OnInitMenuPopupMenu(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS:
            hr = OnInitMenuPopupToolbars(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            hr = OnInitMenuPopupToolbar(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_ROOT:
            hr = OnInitMenuPopupViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_LIST_VIEWS:
            hr = OnInitMenuPopupListViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_OCX:
            hr = OnInitMenuPopupOCXViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_URL:
            hr = OnInitMenuPopupURLViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_TASK_PAD:
            hr = OnInitMenuPopupTaskpadViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
        case SEL_VIEWS_OCX_NAME:
        case SEL_VIEWS_URL_NAME:
        case SEL_VIEWS_TASK_PAD_NAME:
            hr = OnInitMenuPopupView(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCES:
            hr = OnInitMenuPopupResources(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCE_NAME:
            hr = OnInitMenuPopupResourceName(hmenuPopup);
            IfFailGo(hr);
            break;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupRoot(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupRoot
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupExtensionRoot(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupExtensionRoot
(
    HMENU hmenuPopup
)
{
    HRESULT                     hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupExtension(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupExtension
(
    HMENU hmenuPopup
)
{
    HRESULT                     hr = S_OK;
    VARIANT_BOOL        bValue = VARIANT_FALSE;

    ASSERT(NULL != m_pCurrentSelection, "OnInitMenuPopupExtension: Current selection is NULL");
    ASSERT(SEL_EEXTENSIONS_NAME == m_pCurrentSelection->m_st, "OnInitMenuPopupExtension: Unexpected current selection is NULL");

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_NEW, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_NEW, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_TASK, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_TASK, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_PPAGES, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_PPAGES, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TASKPAD, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TOOLBAR, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_NAMESPACE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_NAMESPACE, MF_BYCOMMAND | MF_GRAYED);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupMyExtensions(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupMyExtensions
(
    HMENU hmenuPopup
)
{
    HRESULT                     hr = S_OK;
    IExtensionDefs     *piExtensionDefs = NULL;
    VARIANT_BOOL        bValue = VARIANT_FALSE;

    m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NEW_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NEW_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TASK_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TASK_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOP_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOP_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_PPAGES, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_PPAGES, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_VIEW_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_VIEW_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOOLBAR, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NAMESPACE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NAMESPACE, MF_BYCOMMAND | MF_GRAYED);

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupStaticNode(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupStaticNode
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;
    HMENU       hAddViewMenu = NULL;
    HMENU       hExistingViewsMenu = NULL;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    hAddViewMenu = ::GetSubMenu(hmenuPopup, 1);
    if (hAddViewMenu != NULL)
    {
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);
    }

    hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 2);
    if (hExistingViewsMenu != NULL)
    {
        hr = PopulateNodeViewsMenu(hExistingViewsMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNode(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNode
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;
    HMENU       hAddViewMenu = NULL;
    HMENU       hExistingViewsMenu = NULL;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    hAddViewMenu = ::GetSubMenu(hmenuPopup, 2);
    if (hAddViewMenu != NULL)
    {
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);
    }

    hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 3);
    if (hExistingViewsMenu != NULL)
    {
        hr = PopulateNodeViewsMenu(hExistingViewsMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNodeChildren(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNodeChildren
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNodeChildren(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNodeOther
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNodeViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNodeViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;
    HMENU       hAddViewMenu = NULL;
    HMENU       hExistingViewsMenu = NULL;

    hAddViewMenu = ::GetSubMenu(hmenuPopup, 0);
    if (hAddViewMenu != NULL)
    {
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);
    }

    hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 1);
    if (hExistingViewsMenu != NULL)
    {
        hr = PopulateNodeViewsMenu(hExistingViewsMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupToolsRoot(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupToolsRoot
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_IMAGE_LIST, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_MENU, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupImageLists(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupImageLists
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_IMAGE_LIST, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupImageList(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupImageList
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupMenus(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupMenus
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_MENU, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupMenu(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupMenu
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_MENU, MF_BYCOMMAND | MF_ENABLED);

    hr = CanDemoteMenu(m_pCurrentSelection);
    IfFailGo(hr);

    if (S_OK == hr)
        ::EnableMenuItem(hmenuPopup, CMD_DEMOTE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_DEMOTE, MF_BYCOMMAND | MF_GRAYED);

    hr = CanPromoteMenu(m_pCurrentSelection);
    IfFailGo(hr);

    if (S_OK == hr)
        ::EnableMenuItem(hmenuPopup, CMD_PROMOTE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_PROMOTE, MF_BYCOMMAND | MF_GRAYED);

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupToolbars(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupToolbars
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupToolbar(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupToolbar
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupListViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupListViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupOCXViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupOCXViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupURLViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupURLViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupTaskpadViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupTaskpadViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupView(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupView
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupResources(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupResources
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_RESOURCE, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupResourceName(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupResourceName
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_RESOURCE_REFRESH, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddViewToViewMenu(HMENU hMenu, int iMenuItem, char *pszMenuItemText)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::AddViewToViewMenu(HMENU hMenu, int iMenuItem, char *pszMenuItemText, MMCViewMenuInfo *pMMCViewMenuInfo)
{
    HRESULT       hr = S_OK;
    MENUITEMINFO  minfo;
    BOOL          bReturn = FALSE;

    ::memset(&minfo, 0, sizeof(MENUITEMINFO));

    minfo.cbSize = sizeof(MENUITEMINFO);
    minfo.fMask = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
    minfo.fType = MFT_STRING;
    minfo.fState = MFS_ENABLED;
    minfo.wID = CMD_ADD_EXISTING_VIEW + iMenuItem;
    minfo.dwItemData = reinterpret_cast<DWORD>(pMMCViewMenuInfo);
    minfo.dwTypeData = pszMenuItemText;
    minfo.cch = ::strlen(pszMenuItemText);

    bReturn = ::InsertMenuItem(hMenu, iMenuItem, TRUE, &minfo);
    if (bReturn == FALSE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindListViewInCollection(BSTR bstrName, IListViewDefs *piListViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindListViewInCollection
(
    BSTR           bstrName,
    IListViewDefs *piListViewDefs
)
{
    HRESULT        hr = S_OK;
    VARIANT        vtKey;
    IListViewDef  *piListViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piListViewDefs->get_Item(vtKey, &piListViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

    IfFailGo(hr);

Error:
    RELEASE(piListViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateListViews(HMENU hMenu, int *piCurrentMenuItem, IListViewDefs *piListViewDefs, IListViewDefs *piTargetListViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateListViews
(
    HMENU          hMenu,
    int           *piCurrentMenuItem,
    IListViewDefs *piListViewDefs,
    IListViewDefs *piTargetListViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    IListViewDef    *piListViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
        IfFailGo(hr);

        hr = piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = FindListViewInCollection(bstrName, piTargetListViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piListViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piListViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piListViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindOCXViewInCollection(BSTR bstrName, IOCXViewDefs *piOCXViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindOCXViewInCollection
(
    BSTR           bstrName,
    IOCXViewDefs  *piOCXViewDefs
)
{
    HRESULT        hr = S_OK;
    VARIANT        vtKey;
    IOCXViewDef   *piOCXViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piOCXViewDefs->get_Item(vtKey, &piOCXViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

    IfFailGo(hr);

Error:
    RELEASE(piOCXViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateOCXViews(HMENU hMenu, int *piCurrentMenuItem, IOCXViewDefs *piOCXViewDefs, IOCXViewDefs *piTargetOCXViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateOCXViews
(
    HMENU          hMenu,
    int           *piCurrentMenuItem,
    IOCXViewDefs  *piOCXViewDefs,
    IOCXViewDefs  *piTargetOCXViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    IOCXViewDef     *piOCXViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
        IfFailGo(hr);

        hr = piOCXViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = FindOCXViewInCollection(bstrName, piTargetOCXViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piOCXViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piOCXViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piOCXViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindURLViewInCollection(BSTR bstrName, IURLViewDefs *piURLViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindURLViewInCollection
(
    BSTR           bstrName,
    IURLViewDefs  *piURLViewDefs
)
{
    HRESULT        hr = S_OK;
    VARIANT        vtKey;
    IURLViewDef   *piURLViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piURLViewDefs->get_Item(vtKey, &piURLViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

        goto Error;

Error:
    RELEASE(piURLViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateURLViews(HMENU hMenu, int *piCurrentMenuItem, IURLViewDefs *piURLViewDefs, IURLViewDefs *piTargetURLViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateURLViews
(
    HMENU          hMenu,
    int           *piCurrentMenuItem,
    IURLViewDefs  *piURLViewDefs,
    IURLViewDefs  *piTargetURLViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    IURLViewDef     *piURLViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
        IfFailGo(hr);

        hr = piURLViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = FindURLViewInCollection(bstrName, piTargetURLViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piURLViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piURLViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piURLViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindTaskpadViewInCollection(BSTR bstrName, ITaskpadViewDefs *piTaskpadViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindTaskpadViewInCollection
(
    BSTR               bstrName,
    ITaskpadViewDefs  *piTaskpadViewDefs
)
{
    HRESULT            hr = S_OK;
    VARIANT            vtKey;
    ITaskpadViewDef   *piTaskpadViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piTaskpadViewDefs->get_Item(vtKey, &piTaskpadViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateTaskpadViews(HMENU hMenu, int *piCurrentMenuItem, ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDefs *piTargetTaskpadViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateTaskpadViews
(
    HMENU             hMenu,
    int              *piCurrentMenuItem,
    ITaskpadViewDefs *piTaskpadViewDefs,
    ITaskpadViewDefs *piTargetTaskpadViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    ITaskpadViewDef *piTaskpadViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
        IfFailGo(hr);

        hr = piTaskpadViewDef->get_Key(&bstrName);
        IfFailGo(hr);

        hr = FindTaskpadViewInCollection(bstrName, piTargetTaskpadViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piTaskpadViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piTaskpadViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateNodeViewsMenu(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateNodeViewsMenu
(
    HMENU hmenuPopup
)
{
    HRESULT                   hr = S_OK;
    int               iMenuItem = 0;
    IViewDefs        *piTargetViewDefs = NULL;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IListViewDefs    *piTargetListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IOCXViewDefs     *piTargetOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    IURLViewDefs     *piTargetURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDefs *piTargetTaskpadViewDefs = NULL;
    long              lCount = 0;

    ASSERT(m_piSnapInDesignerDef != NULL, "PopulateViews: m_piSnapInDesignerDef is NULL");

    hr = GetOwningViewCollection(&piTargetViewDefs);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        if (NULL != piListViewDefs)
        {
            hr = piTargetViewDefs->get_ListViews(&piTargetListViewDefs);
            IfFailGo(hr);

            hr = PopulateListViews(hmenuPopup, &iMenuItem, piListViewDefs, piTargetListViewDefs);
            IfFailGo(hr);
        }

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        if (NULL != piOCXViewDefs)
        {
            hr = piTargetViewDefs->get_OCXViews(&piTargetOCXViewDefs);
            IfFailGo(hr);

            hr = PopulateOCXViews(hmenuPopup, &iMenuItem, piOCXViewDefs, piTargetOCXViewDefs);
            IfFailGo(hr);
        }

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        if (NULL != piURLViewDefs)
        {
            hr = piTargetViewDefs->get_URLViews(&piTargetURLViewDefs);
            IfFailGo(hr);

            hr = PopulateURLViews(hmenuPopup, &iMenuItem, piURLViewDefs, piTargetURLViewDefs);
            IfFailGo(hr);
        }

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        if (NULL != piTaskpadViewDefs)
        {
            hr = piTargetViewDefs->get_TaskpadViews(&piTargetTaskpadViewDefs);
            IfFailGo(hr);

            hr = PopulateTaskpadViews(hmenuPopup, &iMenuItem, piTaskpadViewDefs, piTargetTaskpadViewDefs);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piTargetListViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piTargetOCXViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piTargetURLViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piTargetTaskpadViewDefs);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piTargetViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CleanPopupNodeViews(HMENU hmenuPopup, int iCmd)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::CleanPopupNodeViews
(
    HMENU hmenuPopup,
    int   iCmd
)
{
    HRESULT                  hr = S_OK;
    HMENU            hExistingViewsMenu = NULL;
    int              iCount = 0;
    int              iItemNumber = 0;
    MENUITEMINFO     menuItemInfo;
    BOOL             bReturn = FALSE;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    switch (m_pCurrentSelection->m_st)
    {
    case SEL_NODES_AUTO_CREATE_ROOT:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 2);
        break;

    case SEL_NODES_AUTO_CREATE_RTVW:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 1);
        break;

    case SEL_NODES_ANY_VIEWS:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 1);
        break;

    case SEL_NODES_ANY_NAME:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 3);
        break;
    }

    if (hExistingViewsMenu == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iCount = ::GetMenuItemCount(hExistingViewsMenu);
    if (iCount == -1)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    for (iItemNumber = 0; iItemNumber < iCount; ++iItemNumber)
    {
        ::memset(&menuItemInfo, 0, sizeof(MENUITEMINFO));
        menuItemInfo.cbSize = sizeof(MENUITEMINFO);
        menuItemInfo.fMask = MIIM_DATA;

        bReturn = ::GetMenuItemInfo(hExistingViewsMenu, iItemNumber, TRUE, &menuItemInfo);
        if (bReturn == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        pMMCViewMenuInfo = reinterpret_cast<MMCViewMenuInfo *>(menuItemInfo.dwItemData);
        if (pMMCViewMenuInfo != NULL)
        {
            if (iItemNumber == iCmd - CMD_ADD_EXISTING_VIEW)
            {
                if (::PostMessage(m_hwnd, CMD_ADD_EXISTING_VIEW, 0, reinterpret_cast<LPARAM>(pMMCViewMenuInfo)) == 0)
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    EXCEPTION_CHECK_GO(hr);
                }
            }
            else
                delete pMMCViewMenuInfo;
        }
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\help\makefile.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file implements the target specified in sources in NTTARGETFILE0.
    It executes a VB tool that generates help ID header files and an RC
    file containing all the help strings used by the runtime IDL

!ENDIF

GenHelpIDs:
    SET THUNDER55=..\..\..\vb98
    SET TOOLS=TOOLS
	..\..\tools\idheader.bat mssnapr.id $(O)\mssnapr_helpids.h $(O)\mssnapr_helpstrs.h $(O)\mssnapr_helpstrs.rc -NoIncludePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\urlvw.cpp ===
//=--------------------------------------------------------------------------------------
// urlvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- URLView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddURLView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddURLView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    IURLViewDefs          *piURLViewDefs = NULL;
    VARIANT                vtEmpty;
    IURLViewDef           *piIURLViewDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        if (piURLViewDefs != NULL)
        {
            ::VariantInit(&vtEmpty);
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piURLViewDefs->Add(vtEmpty, vtEmpty, &piIURLViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piIURLViewDef);
    RELEASE(piURLViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingURLView(IViewDefs *piViewDefs, IURLViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingURLView(IViewDefs *piViewDefs, IURLViewDef *piURLViewDef)
{
    HRESULT           hr = S_OK;
    IURLViewDefs     *piURLViewDefs = NULL;

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    hr = piURLViewDefs->AddFromMaster(piURLViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piURLViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddURLViewDef(CSelectionHolder *pParent, IURLViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddURLViewDef(CSelectionHolder *pParent, IURLViewDef *piURLViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pURLView = NULL;
    IViewDefs           *piViewDefs = NULL;
    IURLViewDefs        *piURLViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddURLViewDef: pParent is NULL");
    ASSERT(NULL != piURLViewDef, "OnAddURLViewDef: piURLViewDef is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL:
        piURLViewDefs = pParent->m_piObject.m_piURLViewDefs;
        piURLViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddURLViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewURLView(piURLViewDefs, piURLViewDef, &pURLView);
    IfFailGo(hr);

    hr = InsertURLViewInTree(pURLView, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pURLView);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pURLView);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pURLView);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piURLViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameURLView(CSelectionHolder *pURLView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameURLView(CSelectionHolder *pURLView, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_VIEWS_URL_NAME == pURLView->m_st, "RenameURLView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pURLView->m_piObject.m_piURLViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pURLView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pURLView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteURLView(CSelectionHolder *pURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteURLView
(
    CSelectionHolder *pURLView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    VARIANT          vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pURLView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pURLView->m_piObject.m_piURLViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pURLView->m_piObject.m_piURLViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pURLView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        if (piURLViewDefs != NULL)
        {
            vtKey.vt = VT_BSTR;
            vtKey.bstrVal = ::SysAllocString(bstrName);
            if (NULL == vtKey.bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK(hr);
            }

            hr = piURLViewDefs->Remove(vtKey);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piURLViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteURLView(CSelectionHolder *pURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteURLView
(
    CSelectionHolder *pURLView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    IURLViewDefs      *piURLViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pURLView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pURLView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pURLView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pURLView);
    IfFailGo(hr);

    delete pURLView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        hr = piURLViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piURLViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowURLViewProperties(IURLViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowURLViewProperties
(
    IURLViewDef *piURLViewDef
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[1];

    hr = GetResourceString(IDS_URL_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piURLViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_URLViewDefGeneralPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 1;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewURLView(IURLViewDefs *piURLViewDefs, IURLViewDef *piURLViewDef, CSelectionHolder **ppURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewURLView
(
    IURLViewDefs      *piURLViewDefs,
    IURLViewDef       *piURLViewDef,
    CSelectionHolder **ppURLView
)
{
    HRESULT                hr = S_OK;

    *ppURLView = New CSelectionHolder(piURLViewDef);
    if (*ppURLView == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewURLView(piURLViewDefs, *ppURLView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewURLView(IURLViewDefs *piURLViewDefs, CSelectionHolder *pURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewURLView
(
    IURLViewDefs     *piURLViewDefs,
    CSelectionHolder *pURLView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pURLViewDefClone = NULL;

    hr = piURLViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewURLView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_URL_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pURLViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pURLView->m_piObject.m_piURLViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pURLView->m_piObject.m_piURLViewDef->put_Key(bstrName);
        IfFailGo(hr);
    }

    hr = pURLView->RegisterHolder();
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertURLViewInTree(CSelectionHolder *pURLView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertURLViewInTree
(
    CSelectionHolder *pURLView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pURLView->m_piObject.m_piURLViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kURLViewIcon, pURLView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\array.h ===
//=--------------------------------------------------------------------------=
// array.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//
//=--------------------------------------------------------------------------=

#ifndef _CARRAY_DEFINED_
#define _CARRAY_DEFINED_


//=--------------------------------------------------------------------------=
//
// class CArray
//
// This is taken directly from MFC's CArray source.
//
//
//=--------------------------------------------------------------------------=

template <class Object>
class CArray
{

       public:

// Construction
           CArray();

// Attributes
           long GetSize() const;
           long GetUpperBound() const;
           HRESULT SetSize(long nNewSize, long nGrowBy = -1L);

// Operations
    // Clean up
           HRESULT FreeExtra();
           void RemoveAll();

    // Accessing elements
           Object GetAt(long nIndex) const;
           void SetAt(long nIndex, Object NewElement);

    // Direct Access to the element data (may return NULL)
           const Object *GetData() const;
           Object *GetData();

    // Potentially growing the array
           HRESULT SetAtGrow(long nIndex, Object NewElement);

           HRESULT Add(Object NewElement, long *plIndex);

    // Operations that move elements around
           HRESULT InsertAt(long nIndex, Object NewElement, long nCount = 1L);

           void RemoveAt(long nIndex, long nCount = 1L);
           HRESULT InsertAt(long nStartIndex, CArray* pNewArray);

// Implementation
       protected:
           Object   *m_pData;     // the actual array of data
           long      m_nSize;     // # of elements (upperBound - 1)
           long      m_nMaxSize;  // max allocated
           long      m_nGrowBy;   // grow amount


       public:
           ~CArray();
};

template <class Object>
CArray<Object>::CArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template <class Object>
CArray<Object>::~CArray()
{
    if (NULL != m_pData)
    {
        ::CtlFree(m_pData);
        m_pData = NULL;
    }
}

template <class Object>
HRESULT CArray<Object>::SetSize(long nNewSize, long nGrowBy)
{
    HRESULT hr = S_OK;

    if (nGrowBy != -1L)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (Object *)::CtlAlloc(nNewSize * sizeof(Object));
        if (NULL == m_pData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        memset(m_pData, 0, nNewSize * sizeof(Object));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(Object));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        long nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024L, max(4L, m_nSize / 8L));
        }
        long nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        Object *pNewData = (Object *)::CtlAlloc(nNewMax * sizeof(Object));
        if (NULL == pNewData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(Object));

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(Object));

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    // Always free up unused space.

    hr = FreeExtra();
Error:
    H_RRETURN(hr);
}


template <class Object>
HRESULT CArray<Object>::FreeExtra()
{
    HRESULT hr = S_OK;
    if (m_nSize != m_nMaxSize)
    {
        Object* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (Object*)::CtlAlloc(m_nSize * sizeof(Object));
            if (NULL == pNewData)
            {
                hr = SID_E_OUTOFMEMORY;
                GLOBAL_EXCEPTION_CHECK_GO(hr)
            }

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(Object));
        }

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
Error:
    H_RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////

template <class Object>
HRESULT CArray<Object>::SetAtGrow(long lIndex, Object NewElement)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        H_IfFailRet(SetSize(lIndex+1L));
    }
    m_pData[lIndex] = NewElement;
    return S_OK;
}


template <class Object>
HRESULT CArray<Object>::InsertAt(long lIndex, Object NewElement, long nCount)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        // adding after the end of the array
        H_IfFailRet(SetSize(lIndex + nCount));  // grow so lIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        long nOldSize = m_nSize;
        H_IfFailRet(SetSize(m_nSize + nCount));  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[lIndex+nCount], &m_pData[lIndex],
                (nOldSize-lIndex) * sizeof(Object));

        // re-init slots we copied from

        memset(&m_pData[lIndex], 0, nCount * sizeof(Object));

    }

    // copy elements into the empty space
    while (nCount--)
    {
        m_pData[lIndex++] = NewElement;
    }

    return S_OK;
}



template <class Object>
void CArray<Object>::RemoveAt(long lIndex, long nCount)
{
    // just remove a range
    long nMoveCount = m_nSize - (lIndex + nCount);

    if (nMoveCount)
        memmove(&m_pData[lIndex], &m_pData[lIndex + nCount],
                nMoveCount * sizeof(Object));
    m_nSize -= nCount;
}

template <class Object>
HRESULT CArray<Object>::InsertAt(long nStartIndex, CArray* pNewArray)
{
    HRESULT hr = S_OK;
    if (pNewArray->GetSize() > 0)
    {
        H_IfFailRet(InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()));
        for (long i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
    return S_OK;
}

template <class Object>
long CArray<Object>::GetSize() const
{
    return m_nSize;
}

template <class Object>
long CArray<Object>::GetUpperBound() const
{
    return m_nSize-1L;
}

template <class Object>
void CArray<Object>::RemoveAll()
{
    (void)SetSize(0);
}

template <class Object>
Object CArray<Object>::GetAt(long lIndex) const
{
    return m_pData[lIndex];
}

template <class Object>
void CArray<Object>::SetAt(long lIndex, Object NewElement)
{ 
    m_pData[lIndex] = NewElement;
}

template <class Object>
const Object *CArray<Object>::GetData() const
{
    return (const Object *)m_pData;
}

template <class Object>
Object *CArray<Object>::GetData()
{
    return m_pData;
}

template <class Object>
HRESULT CArray<Object>::Add(Object NewElement, long *plIndex)
{
    HRESULT hr = S_OK;
    long lIndex = m_nSize;
    H_IfFailRet(SetAtGrow(lIndex, NewElement));
    *plIndex = lIndex;
    return S_OK;
}

//=--------------------------------------------------------------------------=
//
//                              class CIPArray 
// Obsolete. Code not used.
//
//=--------------------------------------------------------------------------=


template <class IObject>
class CIPArray
{

    public:

// Construction
        CIPArray();

// Attributes
        long GetSize() const;
        long GetUpperBound() const;
        HRESULT SetSize(long nNewSize, long nGrowBy = -1L);

// Operations
    // Clean up
        HRESULT FreeExtra();
        void RemoveAll();

    // Accessing elements
        IObject* GetAt(long nIndex) const;
        void SetAt(long nIndex, IObject* piNewElement);

    // Direct Access to the element data (may return NULL)
        const IObject** GetData() const;
        IObject** GetData();

    // Potentially growing the array
        HRESULT SetAtGrow(long nIndex, IObject* piNewElement);

        HRESULT Add(IObject* piNewElement, long *plIndex);

    // Operations that move elements around
        HRESULT InsertAt(long nIndex, IObject* piNewElement, long nCount = 1L);

        void RemoveAt(long nIndex, long nCount = 1L);
        HRESULT InsertAt(long nStartIndex, CIPArray* pNewArray);

// Implementation
    protected:
        IObject  **m_pData;     // the actual array of data
        long       m_nSize;     // # of elements (upperBound - 1)
        long       m_nMaxSize;  // max allocated
        long       m_nGrowBy;   // grow amount


    public:
        ~CIPArray();
};

template <class IObject>
CIPArray<IObject>::CIPArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template <class IObject>
CIPArray<IObject>::~CIPArray()
{
    if (NULL != m_pData)
    {
        ::CtlFree(m_pData);
        m_pData = NULL;
    }
}

template <class IObject>
HRESULT CIPArray<IObject>::SetSize(long nNewSize, long nGrowBy)
{
    HRESULT hr = S_OK;

    if (nGrowBy != -1L)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (IObject **)::CtlAlloc(nNewSize * sizeof(IObject *));
        if (NULL == m_pData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        memset(m_pData, 0, nNewSize * sizeof(IObject *));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(IObject *));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        long nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024L, max(4L, m_nSize / 8L));
        }
        long nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        IObject **pNewData = (IObject **)::CtlAlloc(nNewMax * sizeof(IObject *));
        if (NULL == pNewData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(IObject *));

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(IObject *));

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    // Always free up unused space.
    
    hr = FreeExtra();
Error:
    H_RRETURN(hr);
}


template <class IObject>
HRESULT CIPArray<IObject>::FreeExtra()
{
    HRESULT hr = S_OK;
    if (m_nSize != m_nMaxSize)
    {
        IObject **pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (IObject **)::CtlAlloc(m_nSize * sizeof(IObject *));
            if (NULL == pNewData)
            {
                hr = SID_E_OUTOFMEMORY;
                GLOBAL_EXCEPTION_CHECK_GO(hr)
            }

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(IObject *));
        }

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
Error:
    H_RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////

template <class IObject>
HRESULT CIPArray<IObject>::SetAtGrow(long lIndex, IObject *piNewElement)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        H_IfFailRet(SetSize(lIndex+1L));
    }
    m_pData[lIndex] = piNewElement;
    return S_OK;
}


template <class IObject>
HRESULT CIPArray<IObject>::InsertAt(long lIndex, IObject *piNewElement, long nCount)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        // adding after the end of the array
        H_IfFailRet(SetSize(lIndex + nCount));  // grow so lIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        long nOldSize = m_nSize;
        H_IfFailRet(SetSize(m_nSize + nCount));  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[lIndex+nCount], &m_pData[lIndex],
                (nOldSize-lIndex) * sizeof(IObject *));

        // re-init slots we copied from

        memset(&m_pData[lIndex], 0, nCount * sizeof(IObject *));

    }

    // copy elements into the empty space
    while (nCount--)
    {
        m_pData[lIndex++] = piNewElement;
    }

    return S_OK;
}



template <class IObject>
void CIPArray<IObject>::RemoveAt(long lIndex, long nCount)
{
    // just remove a range
    long nMoveCount = m_nSize - (lIndex + nCount);

    if (nMoveCount)
        memmove(&m_pData[lIndex], &m_pData[lIndex + nCount],
                nMoveCount * sizeof(IObject *));
    m_nSize -= nCount;
}

template <class IObject>
HRESULT CIPArray<IObject>::InsertAt(long nStartIndex, CIPArray* pNewArray)
{
    HRESULT hr = S_OK;
    if (pNewArray->GetSize() > 0)
    {
        H_IfFailRet(InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()));
        for (long i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
    return S_OK;
}

template <class IObject>
long CIPArray<IObject>::GetSize() const
{
    return m_nSize;
}

template <class IObject>
long CIPArray<IObject>::GetUpperBound() const
{
    return m_nSize-1L;
}

template <class IObject>
void CIPArray<IObject>::RemoveAll()
{
    (void)SetSize(0);
}

template <class IObject>
IObject * CIPArray<IObject>::GetAt(long lIndex) const
{
    return m_pData[lIndex];
}

template <class IObject>
void CIPArray<IObject>::SetAt(long lIndex, IObject *piNewElement)
{ 
    m_pData[lIndex] = piNewElement;
}

template <class IObject>
const IObject ** CIPArray<IObject>::GetData() const
{
    return (const IObject **)m_pData;
}

template <class IObject>
IObject ** CIPArray<IObject>::GetData()
{
    return m_pData;
}

template <class IObject>
HRESULT CIPArray<IObject>::Add(IObject *piNewElement, long *plIndex)
{
    HRESULT hr = S_OK;
    long lIndex = m_nSize;
    H_IfFailRet(SetAtGrow(lIndex, piNewElement));
    *plIndex = lIndex;
    return S_OK;
}


#endif // _CARRAY_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\buttons.cpp ===
//=--------------------------------------------------------------------------=
// buttons.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtons class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "buttons.h"
#include "ctlbar.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButtons::CMMCButtons(IUnknown *punkOuter) :
    CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>(
                                               punkOuter,
                                               OBJECT_TYPE_MMCBUTTONS,
                                               static_cast<IMMCButtons *>(this),
                                               static_cast<CMMCButtons *>(this),
                                               CLSID_MMCButton,
                                               OBJECT_TYPE_MMCBUTTON,
                                               IID_IMMCButton,
                                               static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButtons,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButtons::~CMMCButtons()
{
    InitMemberVariables();
}

void CMMCButtons::InitMemberVariables()
{
    m_pMMCToolbar = NULL;
}

IUnknown *CMMCButtons::Create(IUnknown * punkOuter)
{
    CMMCButtons *pMMCButtons = New CMMCButtons(punkOuter);
    if (NULL == pMMCButtons)
    {
        return NULL;
    }
    else
    {
        return pMMCButtons->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IMMCButtons Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCButtons::Add
(
    VARIANT      Index,
    VARIANT      Key, 
    VARIANT      Caption,
    VARIANT      Style,
    VARIANT      Image,
    VARIANT      TooltipText,
    MMCButton  **ppMMCButton
)
{
    HRESULT     hr = S_OK;
    IMMCButton *piMMCButton = NULL;
    CMMCButton *pMMCButton = NULL;
    BOOL        fIsToolbar = FALSE;
    IToolbar   *piToolbar = NULL;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::Add(Index, Key, &piMMCButton);
    IfFailGo(hr);

    if (ISPRESENT(Caption))
    {
        hr = ::VariantChangeType(&varCoerced, &Caption, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButton->put_Caption(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(TooltipText))
    {
        hr = ::VariantChangeType(&varCoerced, &TooltipText, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButton->put_ToolTipText(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Style))
    {
        hr = ::VariantChangeType(&varCoerced, &Style, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButton->put_Style(static_cast<SnapInButtonStyleConstants>(varCoerced.iVal)));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Image))
    {
        IfFailGo(piMMCButton->put_Image(Image));
    }

    *ppMMCButton = reinterpret_cast<MMCButton *>(piMMCButton);

    // If we belong to a live toolbar at runtime, and it is a toolbar (as
    // opposed to a menu button), then add the button to the MMC toolbar

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButton, &pMMCButton));
        IfFailGo(CControlbar::GetToolbar(m_pMMCToolbar->GetSnapIn(),
                                         m_pMMCToolbar,
                                         &piToolbar));
        IfFailGo(m_pMMCToolbar->AddButton(piToolbar, pMMCButton));
    }
            
Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCButton);
    }
    QUICK_RELEASE(piToolbar);
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}



STDMETHODIMP CMMCButtons::Remove(VARIANT Index)
{
    HRESULT     hr = S_OK;
    IMMCButton *piMMCButton = NULL;
    long        lIndex = 0;
    BOOL        fIsToolbar = FALSE;

    // First get the button from the collection

    IfFailGo(get_Item(Index, &piMMCButton));

    // Get its numerical index

    IfFailGo(piMMCButton->get_Index(&lIndex));

    // Check if it is a toolbar before removing the button because if it is
    // the last button then the toolbar has no way to know whether it is a
    // toolbar or a menu button.

    if (NULL != m_pMMCToolbar)
    {
        IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    }

    // Remove the buton from the collection
    
    hr = CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::Remove(Index);
    IfFailGo(hr);

    // If we belong to a live toolbar at runtime, and it is a toolbar (as
    // opposed to a menu button), then remove the button from the MMC toolbar

    IfFalseGo(fIsToolbar, S_OK);
    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->RemoveButton(lIndex));
    
Error:
    QUICK_RELEASE(piMMCButton);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtons::Persist()
{
    HRESULT      hr = S_OK;
    IMMCButton  *piMMCButton = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::Persist(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtons::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCButtons == riid)
    {
        *ppvObjOut = static_cast<IMMCButtons *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\button.cpp ===
//=--------------------------------------------------------------------------=
// button.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButton class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "button.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButton::CMMCButton(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCBUTTON,
                            static_cast<IMMCButton *>(this),
                            static_cast<CMMCButton *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButton,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButton::~CMMCButton()
{
    RELEASE(m_piButtonMenus);
    FREESTRING(m_bstrCaption);
    (void)::VariantClear(&m_varImage);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrToolTipText);

    InitMemberVariables();
}

void CMMCButton::InitMemberVariables()
{
    m_piButtonMenus = NULL;
    m_bstrCaption = NULL;
    m_fvarEnabled = VARIANT_TRUE;

    ::VariantInit(&m_varImage);
    
    m_Index = 0;
    m_bstrKey = NULL;
    m_fvarMixedState = VARIANT_FALSE;
    m_Style = siDefault;

    ::VariantInit(&m_varTag);

    m_bstrToolTipText = NULL;
    m_Value = siUnpressed;
    m_fvarVisible = VARIANT_TRUE;
    m_pMMCToolbar = NULL;
}

IUnknown *CMMCButton::Create(IUnknown * punkOuter)
{
    CMMCButton *pMMCButton = New CMMCButton(punkOuter);
    if (NULL == pMMCButton)
    {
        return NULL;
    }
    else
    {
        return pMMCButton->PrivateUnknown();
    }
}

HRESULT CMMCButton::SetButtonState
(
    MMC_BUTTON_STATE State,
    VARIANT_BOOL     fvarValue
)
{
    HRESULT hr = S_OK;
    BOOL    fIsToolbar = FALSE;
    BOOL    fIsMenuButton = FALSE;

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        IfFailGo(m_pMMCToolbar->SetButtonState(this, State,
                                               VARIANTBOOL_TO_BOOL(fvarValue)));
    }
    else
    {
        IfFailGo(m_pMMCToolbar->IsMenuButton(&fIsMenuButton));
        if (fIsMenuButton)
        {
            IfFailGo(m_pMMCToolbar->SetMenuButtonState(this, State,
                                               VARIANTBOOL_TO_BOOL(fvarValue)));
        }
    }

Error:
    RRETURN(hr);
}



HRESULT CMMCButton::GetButtonState
(
    MMC_BUTTON_STATE  State,
    VARIANT_BOOL     *pfvarValue
)
{
    HRESULT hr = S_OK;
    BOOL    fValue = FALSE;
    BOOL    fIsToolbar = FALSE;

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        IfFailGo(m_pMMCToolbar->GetButtonState(this, State, &fValue));
        *pfvarValue = BOOL_TO_VARIANTBOOL(fValue);
    }

    // If we belong to a menu button then we must use our currently stored
    // state variable as MMC does not support getting menu button state.

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         IMMCButton Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CMMCButton::put_Caption(BSTR bstrCaption)
{
    HRESULT hr = S_OK;
    BOOL    fIsMenuButton = FALSE;

    // Set our member variable first

    IfFailGo(SetBstr(bstrCaption, &m_bstrCaption, DISPID_BUTTON_CAPTION));

    // If we belong to a live menu button then ask MMC to change its text
    
    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsMenuButton(&fIsMenuButton));
    IfFalseGo(fIsMenuButton, S_OK);

    IfFailGo(m_pMMCToolbar->SetMenuButtonText(this,
                                              m_bstrCaption,
                                              m_bstrToolTipText));
Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::put_ToolTipText(BSTR bstrToolTipText)
{
    HRESULT hr = S_OK;
    BOOL    fIsMenuButton = FALSE;

    // Set our member variable first

    IfFailGo(SetBstr(bstrToolTipText, &m_bstrToolTipText, DISPID_BUTTON_TOOLTIP_TEXT));

    // If we belong to a live menu button then ask MMC to change its tooltip

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsMenuButton(&fIsMenuButton));
    IfFalseGo(fIsMenuButton, S_OK);

    IfFailGo(m_pMMCToolbar->SetMenuButtonText(this,
                                              m_bstrCaption,
                                              m_bstrToolTipText));
Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCButton::put_Enabled(VARIANT_BOOL fvarEnabled)
{
    HRESULT hr = S_OK;

    // Set our current value

    IfFailGo(SetSimpleType(fvarEnabled, &m_fvarEnabled, DISPID_BUTTON_ENABLED));

    // If we belong to a live toolbar then set its button state
    
    IfFailGo(SetButtonState(ENABLED, m_fvarEnabled));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_Enabled(VARIANT_BOOL *pfvarEnabled)
{
    HRESULT hr = S_OK;

    // Get our current value
    
    *pfvarEnabled = m_fvarEnabled;

    // If we are attached to a live toolbar then get its value
    
    IfFailGo(GetButtonState(ENABLED, pfvarEnabled));

    // In case we got a live value, store it in our current value
    
    m_fvarEnabled = *pfvarEnabled;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::put_MixedState(VARIANT_BOOL fvarMixedState)
{
    HRESULT hr = S_OK;

    // Set our current value

    IfFailGo(SetSimpleType(fvarMixedState, &m_fvarMixedState, DISPID_BUTTON_MIXEDSTATE));

    // If we belong to a live toolbar then set its button state

    IfFailGo(SetButtonState(INDETERMINATE, m_fvarMixedState));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_MixedState(VARIANT_BOOL *pfvarMixedState)
{
    HRESULT hr = S_OK;

    // Get our current value

    *pfvarMixedState = m_fvarMixedState;

    // If we are attached to a live toolbar then get its value

    IfFailGo(GetButtonState(INDETERMINATE, pfvarMixedState));

    // In case we got a live value, store it in our current value

    m_fvarMixedState = *pfvarMixedState;


Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::put_Value(SnapInButtonValueConstants Value)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fvarPressed = (siPressed == Value) ? VARIANT_TRUE : VARIANT_FALSE;

    // Set our current value

    IfFailGo(SetSimpleType(Value, &m_Value, DISPID_BUTTON_VALUE));

    // If we belong to a live toolbar then set its button state

    IfFailGo(SetButtonState(BUTTONPRESSED, fvarPressed));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_Value(SnapInButtonValueConstants *pValue)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fvarPressed = (siPressed == m_Value) ? VARIANT_TRUE : VARIANT_FALSE;

    // If we are attached to a live toolbar then get its value

    IfFailGo(GetButtonState(BUTTONPRESSED, &fvarPressed));

    // In case we got a live value, store it in our current value

    m_Value = (VARIANT_TRUE == fvarPressed) ? siPressed : siUnpressed;

    // Get our current value

    *pValue = m_Value;

Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCButton::put_Visible(VARIANT_BOOL fvarVisible)
{
    HRESULT hr = S_OK;

    // Set our current value

    IfFailGo(SetSimpleType(fvarVisible, &m_fvarVisible, DISPID_BUTTON_VISIBLE));

    // If we belong to a live toolbar then set its button state

    IfFailGo(SetButtonState(HIDDEN, NEGATE_VARIANTBOOL(m_fvarVisible)));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_Visible(VARIANT_BOOL *pfvarVisible)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fvarPressed = NEGATE_VARIANTBOOL(m_fvarVisible);

    // If we are attached to a live toolbar then get its value

    IfFailGo(GetButtonState(HIDDEN, &fvarPressed));

    // In case we got a live value, store it in our current value

    m_fvarVisible = NEGATE_VARIANTBOOL(fvarPressed);

    // Get our current value

    *pfvarVisible = m_fvarVisible;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButton::Persist()
{
    HRESULT hr = S_OK;
    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistObject(&m_piButtonMenus, CLSID_MMCButtonMenus,
                            OBJECT_TYPE_MMCBUTTONMENUS, IID_IMMCButtonMenus,
                            OLESTR("ButtonMenus")));

    if (InitNewing() || Loading())
    {
        IfFailRet(m_piButtonMenus->putref_Parent(static_cast<IMMCButton *>(this)));
    }

    IfFailRet(PersistBstr(&m_bstrCaption, L"", OLESTR("Caption")));

    IfFailRet(PersistSimpleType(&m_fvarEnabled, VARIANT_TRUE, OLESTR("Enabled")));

    IfFailRet(PersistVariant(&m_varImage, varDefault, OLESTR("Image")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistSimpleType(&m_fvarMixedState, VARIANT_FALSE, OLESTR("MixedState")));

    IfFailRet(PersistSimpleType(&m_Style, siDefault, OLESTR("Style")));

    IfFailRet(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailRet(PersistBstr(&m_bstrToolTipText, L"", OLESTR("ToolTipText")));

    IfFailRet(PersistSimpleType(&m_Value, siUnpressed, OLESTR("Value")));

    IfFailRet(PersistSimpleType(&m_fvarVisible, VARIANT_TRUE, OLESTR("Visible")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButton::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCButton == riid)
    {
        *ppvObjOut = static_cast<IMMCButton *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButton::OnSetHost()
{
    // When the host is being removed need to remove parent from menu buttons
    // to avoid circular ref counts.
    // This is the only opportunity we have to do that and it will occur
    // both at design time and at runtime.

    if (NULL == GetHost())
    {
        RRETURN(m_piButtonMenus->putref_Parent(NULL));
    }
    else
    {
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\button.h ===
//=--------------------------------------------------------------------------=
// button.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButton class definition. Implements the MMCButton object.
//
//=--------------------------------------------------------------------------=

#ifndef _BUTTON_DEFINED_
#define _BUTTON_DEFINED_

#include "toolbar.h"

class CMMCToolbar;

class CMMCButton : public CSnapInAutomationObject,
                   public CPersistence,
                   public IMMCButton
{
    private:
        CMMCButton(IUnknown *punkOuter);
        ~CMMCButton();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButton
        COCLASS_PROPERTY_RO(CMMCButton,     ButtonMenus, MMCButtonMenus, IMMCButtonMenus, DISPID_BUTTON_BUTTON_MENUS);

        BSTR_PROPERTY_RO(CMMCButton,       Caption, DISPID_BUTTON_CAPTION);
        STDMETHOD(put_Caption)(BSTR bstrCaption);

        STDMETHOD(put_Enabled)(VARIANT_BOOL fvarEnabled);
        STDMETHOD(get_Enabled)(VARIANT_BOOL *pfvarEnabled);

        VARIANT_PROPERTY_RW(CMMCButton,    Image, DISPID_BUTTON_IMAGE);
        SIMPLE_PROPERTY_RW(CMMCButton,     Index, long, DISPID_BUTTON_INDEX);
        BSTR_PROPERTY_RW(CMMCButton,       Key, DISPID_BUTTON_KEY);

        STDMETHOD(put_MixedState)(VARIANT_BOOL fvarMixedState);
        STDMETHOD(get_MixedState)(VARIANT_BOOL *pfvarMixedState);

        SIMPLE_PROPERTY_RW(CMMCButton,     Style, SnapInButtonStyleConstants, DISPID_BUTTON_STYLE);
        VARIANTREF_PROPERTY_RW(CMMCButton, Tag, DISPID_BUTTON_TAG);

        BSTR_PROPERTY_RO(CMMCButton,       ToolTipText, DISPID_BUTTON_TOOLTIP_TEXT);
        STDMETHOD(put_ToolTipText)(BSTR bstrToolTipText);

        STDMETHOD(put_Value)(SnapInButtonValueConstants Value);
        STDMETHOD(get_Value)(SnapInButtonValueConstants *pValue);

        STDMETHOD(put_Visible)(VARIANT_BOOL fvarVisible);
        STDMETHOD(get_Visible)(VARIANT_BOOL *pfvarVisible);

    // Public utility methods

    public:
        void SetToolbar(CMMCToolbar *pMMCToolbar) { m_pMMCToolbar = pMMCToolbar; }
        CMMCToolbar *GetToolbar() { return m_pMMCToolbar; }
        long GetIndex() { return m_Index; }
        VARIANT GetImage() { return m_varImage; }
        SnapInButtonStyleConstants GetStyle() { return m_Style; }
        SnapInButtonValueConstants GetValue() { return m_Value; }
        VARIANT_BOOL GetEnabled() { return m_fvarEnabled; }
        VARIANT_BOOL GetVisible() { return m_fvarVisible; }
        VARIANT_BOOL GetMixedState() { return m_fvarMixedState; }
        LPOLESTR GetCaption() { return static_cast<LPOLESTR>(m_bstrCaption); }
        LPOLESTR GetToolTipText() { return static_cast<LPOLESTR>(m_bstrToolTipText); }
        
    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT SetButtonState(MMC_BUTTON_STATE State, VARIANT_BOOL fvarValue);
        HRESULT GetButtonState(MMC_BUTTON_STATE State, VARIANT_BOOL *pfvarValue);

        VARIANT_BOOL                m_fvarEnabled;
        VARIANT_BOOL                m_fvarVisible;
        VARIANT_BOOL                m_fvarMixedState;
        SnapInButtonValueConstants  m_Value;
        CMMCToolbar                *m_pMMCToolbar;

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButton,                   // name
                                &CLSID_MMCButton,            // clsid
                                "MMCButton",                 // objname
                                "MMCButton",                 // lblname
                                &CMMCButton::Create,         // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCButton,             // dispatch IID
                                NULL,                        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _Button_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\buttons.h ===
//=--------------------------------------------------------------------------=
// buttons.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtons class definition - implements the MMCButtons collection 
//
//=--------------------------------------------------------------------------=

#ifndef _BUTTONS_DEFINED_
#define _BUTTONS_DEFINED_

#include "collect.h"
#include "toolbar.h"

class CMMCToolbar;

class CMMCButtons : public CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>,
                    public CPersistence
{
    protected:
        CMMCButtons(IUnknown *punkOuter);
        ~CMMCButtons();

    public:
        static IUnknown *Create(IUnknown * punk);
        void SetToolbar(CMMCToolbar *pMMCToolbar) { m_pMMCToolbar = pMMCToolbar; }

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButtons
        STDMETHOD(Add)(VARIANT      Index,
                       VARIANT      Key, 
                       VARIANT      Caption,
                       VARIANT      Style,
                       VARIANT      Image,
                       VARIANT      ToolTipText,
                       MMCButton  **ppMMCButton);
        STDMETHOD(Remove)(VARIANT Index);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        CMMCToolbar *m_pMMCToolbar; // back pointer to owning toolbar
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButtons,                 // name
                                &CLSID_MMCButtons,          // clsid
                                "MMCButtons",               // objname
                                "MMCButtons",               // lblname
                                &CMMCButtons::Create,       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCButtons,           // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _BUTTONS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\clipbord.cpp ===
//=--------------------------------------------------------------------------=
// clipbord.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCClipboard class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "clipbord.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCClipboard::CMMCClipboard(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCCLIPBOARD,
                            static_cast<IMMCClipboard *>(this),
                            static_cast<CMMCClipboard *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCClipboard::~CMMCClipboard()
{
    // Remove read-only so contained collections can be cleaned up.
    (void)SetReadOnly(FALSE);

    RELEASE(m_piScopeItems);
    RELEASE(m_piListItems);
    RELEASE(m_piDataObjects);
    InitMemberVariables();
}

void CMMCClipboard::InitMemberVariables()
{
    m_SelectionType = siEmpty;
    m_piScopeItems = NULL;
    m_piListItems = NULL;
    m_piDataObjects = NULL;
    m_pScopeItems = NULL;
    m_pListItems = NULL;
    m_pDataObjects = NULL;
}

IUnknown *CMMCClipboard::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punk = NULL;
    CMMCClipboard *pMMCClipboard = New CMMCClipboard(punkOuter);

    if (NULL == pMMCClipboard)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    punk = CScopeItems::Create(NULL);
    if (NULL == punk)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punk->QueryInterface(IID_IScopeItems,
                     reinterpret_cast<void **>(&pMMCClipboard->m_piScopeItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk,
                                                  &pMMCClipboard->m_pScopeItems));
    punk->Release();
    
    punk = CMMCListItems::Create(NULL);
    if (NULL == punk)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punk->QueryInterface(IID_IMMCListItems,
                      reinterpret_cast<void **>(&pMMCClipboard->m_piListItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk,
                                                  &pMMCClipboard->m_pListItems));
    punk->Release();

    punk = CMMCDataObjects::Create(NULL);
    if (NULL == punk)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punk->QueryInterface(IID_IMMCDataObjects,
                    reinterpret_cast<void **>(&pMMCClipboard->m_piDataObjects)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk,
                                                &pMMCClipboard->m_pDataObjects));
    RELEASE(punk);

Error:
    QUICK_RELEASE(punk);
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCClipboard)
        {
            delete pMMCClipboard;
        }
        return NULL;
    }
    else
    {
        return pMMCClipboard->PrivateUnknown();
    }
}

void CMMCClipboard::SetReadOnly(BOOL fReadOnly)
{
    m_pScopeItems->SetReadOnly(fReadOnly);
    m_pListItems->SetReadOnly(fReadOnly);
    m_pDataObjects->SetReadOnly(fReadOnly);
}

HRESULT CMMCClipboard::DetermineSelectionType()
{
    HRESULT hr = S_OK;
    long    cScopeItems = 0;
    long    cListItems = 0;
    long    cForeignItems = 0;

    // Get the counts of everything we're currently holding

    IfFailGo(m_piScopeItems->get_Count(&cScopeItems));
    IfFailGo(m_piListItems->get_Count(&cListItems));
    IfFailGo(m_piDataObjects->get_Count(&cForeignItems));

    // There is no really clean way to code this so we'll use a clear but less
    // efficient algorithm to show exactly the criteria used and to be sure
    // that all cases are covered.

    if ( (0 != cScopeItems) && (0 != cListItems) && (0 != cForeignItems) )
    {
        m_SelectionType = siMultiMixedForeign;
    }
    else if ( (0 != cScopeItems) && (0 != cListItems) && (0 == cForeignItems) )
    {
        m_SelectionType = siMultiMixed;
    }
    else if ( (0 == cScopeItems) && (0 != cListItems) && (0 != cForeignItems) )
    {
        m_SelectionType = siMultiMixedForeign;
    }
    else if ( (0 != cScopeItems) && (0 == cListItems) && (0 != cForeignItems) )
    {
        m_SelectionType = siMultiMixedForeign;
    }
    else if ( (0 != cScopeItems) && (0 == cListItems) && (0 == cForeignItems) )
    {
        if (cScopeItems > 1L)
        {
            m_SelectionType = siMultiScopeItems;
        }
        else
        {
            m_SelectionType = siSingleScopeItem;
        }
    }
    else if ( (0 == cScopeItems) && (0 != cListItems) && (0 == cForeignItems) )
    {
        if (cListItems > 1L)
        {
            m_SelectionType = siMultiListItems;
        }
        else
        {
            m_SelectionType = siSingleListItem;
        }
    }
    else if ( (0 == cScopeItems) && (0 == cListItems) && (0 != cForeignItems) )
    {
        if (cForeignItems > 1L)
        {
            m_SelectionType = siMultiForeign;
        }
        else
        {
            m_SelectionType = siSingleForeign;
        }
    }
    else
    {
        m_SelectionType = siEmpty;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCClipboard::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCClipboard == riid)
    {
        *ppvObjOut = static_cast<IMMCClipboard *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\clipbord.h ===
//=--------------------------------------------------------------------------=
// clipbord.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCClipboard class definition - implements the MMCClipboard object
//
//=--------------------------------------------------------------------------=

#ifndef _CLIPBORD_DEFINED_
#define _CLIPBORD_DEFINED_

#include "snapin.h"
#include "scopitms.h"
#include "listitms.h"
#include "dataobjs.h"

class CScopeItems;
class CMMCListItems;
class CMMCDataObjects;

// Helper macros to weed out seleciton types

#define IsForeign(Type) ( (siSingleForeign     == Type) || \
                          (siMultiMixed        == Type) || \
                          (siMultiForeign      == Type) || \
                          (siMultiMixedForeign == Type) )


#define IsSingle(Type) ( (siSingleForeign   == Type) || \
                         (siSingleScopeItem == Type) || \
                         (siSingleListItem  == Type) )


class CMMCClipboard : public CSnapInAutomationObject,
                      public IMMCClipboard
{
    public:
        CMMCClipboard(IUnknown *punkOuter);
        ~CMMCClipboard();
        static IUnknown *Create(IUnknown *punkOuter);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCClipboard

        SIMPLE_PROPERTY_RO(CMMCClipboard, SelectionType, SnapInSelectionTypeConstants,      DISPID_CLIPBOARD_SELECTION_TYPE);
        COCLASS_PROPERTY_RO(CMMCClipboard, ScopeItems,    ScopeItems,      IScopeItems,     DISPID_CLIPBOARD_SCOPEITEMS);
        COCLASS_PROPERTY_RO(CMMCClipboard, ListItems,     MMCListItems,    IMMCListItems,   DISPID_CLIPBOARD_LISTITEMS);
        COCLASS_PROPERTY_RO(CMMCClipboard, DataObjects,   MMCDataObjects,  IMMCDataObjects, DISPID_CLIPBOARD_DATAOBJECTS);

    // Public Utility Methods
        HRESULT DetermineSelectionType();
        void SetSelectionType(SnapInSelectionTypeConstants Type) { m_SelectionType = Type; }
        SnapInSelectionTypeConstants GetSelectionType() { return m_SelectionType; }
        void SetReadOnly(BOOL fReadOnly);
        CScopeItems *GetScopeItems() { return m_pScopeItems; }
        CMMCListItems *GetListItems() { return m_pListItems; }
        CMMCDataObjects *GetDataObjects() { return m_pDataObjects; }
      
    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // These are the the 3 collections: MMCClipboard.ScopeItems,
        // MMCClipboard.ListItems, and MMCClipboard.DataObjects 

        CScopeItems     *m_pScopeItems;
        CMMCListItems   *m_pListItems;
        CMMCDataObjects *m_pDataObjects;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCClipboard,           // name
                                &CLSID_MMCClipboard,    // clsid
                                "MMCClipboard",         // objname
                                "MMCClipboard",         // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCClipboard,     // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _CLIPBORD_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdr.cpp ===
//=--------------------------------------------------------------------------=
// colhdr.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colhdr.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCColumnHeader::CMMCColumnHeader(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCCOLUMNHEADER,
                            static_cast<IMMCColumnHeader *>(this),
                            static_cast<CMMCColumnHeader *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCColumnHeader,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCColumnHeader::~CMMCColumnHeader()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrText);
    (void)::VariantClear(&m_varTextFilter);
    (void)::VariantClear(&m_varNumericFilter);
    (void)::VariantClear(&m_varTag);
    InitMemberVariables();
}

void CMMCColumnHeader::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

    ::VariantInit(&m_varTextFilter);
    ::VariantInit(&m_varNumericFilter);
    ::VariantInit(&m_varTag);

    m_bstrText = NULL;

    m_sWidth = static_cast<short>(siColumnAutoWidth);
    m_Alignment = siColumnLeft;
    m_fvarHidden = VARIANT_FALSE;
    m_TextFilterMaxLen = MAX_PATH; // This is the header control's default
    m_pMMCColumnHeaders = NULL;
}


IUnknown *CMMCColumnHeader::Create(IUnknown * punkOuter)
{
    CMMCColumnHeader *pMMCColumnHeader = New CMMCColumnHeader(punkOuter);
    if (NULL == pMMCColumnHeader)
    {
        return NULL;
    }
    else
    {
        return pMMCColumnHeader->PrivateUnknown();
    }
}



HRESULT CMMCColumnHeader::SetFilter()
{
    HRESULT hr = S_OK;

    if (VT_EMPTY != m_varTextFilter.vt)
    {
        IfFailGo(SetTextFilter(m_varTextFilter));
    }
    else if (VT_EMPTY != m_varNumericFilter.vt)
    {
        IfFailGo(SetNumericFilter(m_varNumericFilter));
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCColumnHeader::SetTextFilter(VARIANT varTextFilter)
{
    HRESULT         hr = S_OK;
    IHeaderCtrl2   *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD           dwType = MMC_STRING_FILTER;
    CResultView    *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    // Determine the filter value.

    if (VT_EMPTY == varTextFilter.vt)
    {
        dwType |= MMC_FILTER_NOVALUE;
    }
    else
    {
        if (VT_BSTR != varTextFilter.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        FilterData.pszText = varTextFilter.bstrVal;
    }

    FilterData.cchTextMax = static_cast<int>(m_TextFilterMaxLen);

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.
    
    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( (!pResultView->InActivate()) && (!pResultView->InInitialize()) )
    {
        // Set the filter value. Adjust the column index for one-based.

        hr = piHeaderCtrl2->SetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                            dwType, &FilterData);
        if (E_NOTIMPL == hr)
        {
            hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


HRESULT CMMCColumnHeader::SetNumericFilter(VARIANT varNumericFilter)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD         dwType = MMC_INT_FILTER;
    CResultView  *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    // Determine the filter value.

    if (VT_EMPTY == varNumericFilter.vt)
    {
        dwType |= MMC_FILTER_NOVALUE;
    }
    else
    {
        hr = ::ConvertToLong(varNumericFilter, &FilterData.lValue);
        if (S_OK != hr)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( (!pResultView->InActivate()) && (!pResultView->InInitialize()) )
    {
        // Set the filter value. Adjust the column index for one-based.

        hr = piHeaderCtrl2->SetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                            dwType, &FilterData);
        if (E_NOTIMPL == hr)
        {
            hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


HRESULT CMMCColumnHeader::SetHeaderCtrlWidth(int nWidth)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;

    // If we are connected to MMC then change it in the header control too

    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    hr = m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    IfFalseGo(!pResultView->InActivate(), S_OK);
    IfFalseGo(!pResultView->InInitialize(), S_OK);

    hr = piHeaderCtrl2->SetColumnWidth(static_cast<int>(m_Index - 1L), nWidth);
    EXCEPTION_CHECK_GO(hr);

Error:

    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//
//                      IMMCColumnHeader Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCColumnHeader::put_Text(BSTR Text)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;

    // Set the property

    IfFailGo(SetBstr(Text, &m_bstrText, DISPID_COLUMNHEADER_TEXT));

    // If we are connected to MMC then change it in MMC too.
    
    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    hr = m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( (!pResultView->InActivate()) && (!pResultView->InInitialize()) )
    {
        hr = piHeaderCtrl2->SetColumnText(static_cast<int>(m_Index - 1L), Text);
        EXCEPTION_CHECK_GO(hr);
    }
    
Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::put_Width(short sWidth)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;
    int           nWidth = 0;

    // Set the property

    m_sWidth = sWidth;

    if (siColumnAutoWidth == sWidth)
    {
        nWidth = MMCLV_AUTO;
    }
    else
    {
        nWidth = static_cast<int>(sWidth);
    }

    // If we are connected to MMC then change it in the header control too

    IfFailGo(SetHeaderCtrlWidth(nWidth));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::get_Width(short *psWidth)
{
    HRESULT       hr = S_OK;
    int           nWidth = 0;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;

    // Get our stored value of the property

    *psWidth = m_sWidth;

    // If we are connected to MMC then try to get it from MMC so the snap-in
    // can see any changes made by the user.

    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    hr = m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( pResultView->InActivate() || pResultView->InInitialize() )
    {
        goto Error;
    }

    hr = piHeaderCtrl2->GetColumnWidth(static_cast<int>(m_Index - 1L),
                                       &nWidth);
    EXCEPTION_CHECK_GO(hr);

    m_sWidth = static_cast<short>(nWidth);
    if (MMCLV_AUTO == m_sWidth)
    {
        m_sWidth = siColumnAutoWidth;
    }

    *psWidth = m_sWidth;

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::put_Hidden(VARIANT_BOOL fvarHidden)
{
    HRESULT      hr = S_OK;
    int          nWidth = 0;
    IColumnData *piColumnData = NULL; // Not AddRef()ed

    // Set the property

    m_fvarHidden = fvarHidden;

    // If we are connected to MMC then change it in the header control too.
    // This only works on MMC 1.2 so we need to check if a 1.2 interface is
    // available as a version check.

    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    IfFailGo(m_pMMCColumnHeaders->GetIColumnData(&piColumnData));

    if (VARIANT_TRUE == fvarHidden)
    {
        nWidth = HIDE_COLUMN;
    }
    else
    {
        // We are revealing the column. Set its width using the current value
        // of our Width property.

        nWidth = static_cast<int>(m_sWidth);
    }
    IfFailGo(SetHeaderCtrlWidth(nWidth));

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::get_Hidden(VARIANT_BOOL *pfvarHidden)
{
    *pfvarHidden = m_fvarHidden;
    return S_OK;
}


STDMETHODIMP CMMCColumnHeader::put_TextFilter(VARIANT varTextFilter)
{
    HRESULT hr = S_OK;

    // Check for allowable variant types.

    if ( (VT_EMPTY != varTextFilter.vt) && (VT_BSTR != varTextFilter.vt) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set the property value.

    if (VT_EMPTY != varTextFilter.vt)
    {
        IfFailGo(SetVariant(varTextFilter, &m_varTextFilter, DISPID_COLUMNHEADER_TEXT_FILTER));
    }
    else
    {
        // At runtime the snap-in can set this to VT_EMPTY. SetVariant() does not
        // accept VT_EMPTY.

        hr = ::VariantClear(&m_varTextFilter);
        EXCEPTION_CHECK_GO(hr);
    }

    // Try to set it in MMC
    
    IfFailGo(SetTextFilter(m_varTextFilter));

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::get_TextFilter(VARIANT *pvarTextFilter)
{
    HRESULT         hr = S_OK;
    IHeaderCtrl2   *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD           dwType = MMC_STRING_FILTER;
    CResultView    *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    ::VariantInit(pvarTextFilter);

    // Get the property value. If we are connected to MMC we'll overwrite it.

    IfFailGo(GetVariant(pvarTextFilter, m_varTextFilter));

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( pResultView->InActivate() || pResultView->InInitialize() )
    {
        goto Error;
    }

    // Allocate a buffer for the text filter value

    FilterData.pszText =
              (LPOLESTR)CtlAllocZero((m_TextFilterMaxLen + 1) * sizeof(OLECHAR));

    if (NULL == FilterData.pszText)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    FilterData.cchTextMax = static_cast<int>(m_TextFilterMaxLen + 1);

    // Clear out the property value stored above as at this point we will only
    // return what we get from MMC
    hr = ::VariantClear(pvarTextFilter);
    EXCEPTION_CHECK_GO(hr);

    // Get the filter value. Adjust the column index for one-based.

    hr = piHeaderCtrl2->GetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                        &dwType, &FilterData);
    if (E_NOTIMPL == hr)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
    }
    EXCEPTION_CHECK_GO(hr);

    if (MMC_STRING_FILTER == dwType)
    {
        // Store the string returned from MMC
        pvarTextFilter->bstrVal = ::SysAllocString(FilterData.pszText);
        if (NULL == pvarTextFilter->bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        pvarTextFilter->vt = VT_BSTR;
    }
    else
    {
        // Text filter is empty. Returned VARIANT is already empty from the
        // VariantClear() call so nothing to do.
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        (void)::VariantClear(pvarTextFilter);
    }

    if (NULL != FilterData.pszText)
    {
        CtlFree(FilterData.pszText);
    }
    RRETURN(hr);
}



STDMETHODIMP CMMCColumnHeader::put_NumericFilter(VARIANT varNumericFilter)
{
    HRESULT hr = S_OK;
    long    lValue = 0;

    // Check for allowable variant types

    if (VT_EMPTY != varNumericFilter.vt)
    {
        hr = ::ConvertToLong(varNumericFilter, &lValue);
        if (S_OK != hr)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Set the property value.

    if (VT_EMPTY != varNumericFilter.vt)
    {
        IfFailGo(SetVariant(varNumericFilter, &m_varNumericFilter, DISPID_COLUMNHEADER_NUMERIC_FILTER));
    }
    else
    {
        // At runtime the snap-in can set this to VT_EMPTY. SetVariant() does not
        // accept VT_EMPTY.

        hr = ::VariantClear(&m_varNumericFilter);
        EXCEPTION_CHECK_GO(hr);
    }

    // Set the filter value in MMC

    IfFailGo(SetNumericFilter(varNumericFilter));

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

STDMETHODIMP CMMCColumnHeader::get_NumericFilter(VARIANT *pvarNumericFilter)
{
    HRESULT         hr = S_OK;
    IHeaderCtrl2   *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD           dwType = MMC_INT_FILTER;
    CResultView    *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    ::VariantInit(pvarNumericFilter);

    // Get the property value. If we are connected to MMC we'll overwrite it.

    IfFailGo(GetVariant(pvarNumericFilter, m_varNumericFilter));

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( pResultView->InActivate() || pResultView->InInitialize() )
    {
        goto Error;
    }

    // Clear out the property value stored above as at this point we will only
    // return what we get from MMC
    hr = ::VariantClear(pvarNumericFilter);
    EXCEPTION_CHECK_GO(hr);

    // Get the filter value. Adjust the column index for one-based.

    hr = piHeaderCtrl2->GetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                        &dwType, &FilterData);
    if (E_NOTIMPL == hr)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
    }
    EXCEPTION_CHECK_GO(hr);

    if (MMC_INT_FILTER == dwType)
    {
        pvarNumericFilter->vt = VT_I4;
        pvarNumericFilter->lVal = FilterData.lValue;
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeader::Persist()
{
    HRESULT  hr = S_OK;
    VARIANT *pvarTextFilter = &m_varTextFilter;
    VARIANT *pvarNumericFilter = &m_varNumericFilter;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    VARIANT varFilterDefault;
    ::VariantInit(&varFilterDefault);

    varFilterDefault.vt = VT_BSTR;
    varFilterDefault.bstrVal = ::SysAllocString(L"");

    if (NULL == varFilterDefault.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailGo(PersistSimpleType(&m_sWidth, static_cast<short>(siColumnAutoWidth), OLESTR("Width")));

    IfFailGo(PersistSimpleType(&m_Alignment, siColumnLeft, OLESTR("Alignment")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 3) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_fvarHidden, VARIANT_FALSE, OLESTR("Hidden")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 5) )
    {
    }
    else
    {
        // If saving and variants are empty then convert them to empty strings

        if ( Saving() )
        {
            if (VT_EMPTY == m_varTextFilter.vt)
            {
                pvarTextFilter = &varFilterDefault;
            }

            if (VT_EMPTY == m_varNumericFilter.vt)
            {
                pvarNumericFilter = &varFilterDefault;
            }
        }

        IfFailGo(PersistVariant(pvarTextFilter, varFilterDefault, OLESTR("TextFilter")));
        IfFailGo(PersistSimpleType(&m_TextFilterMaxLen, (long)MAX_PATH, OLESTR("TextFilterMaxLen")));
        IfFailGo(PersistVariant(pvarNumericFilter, varFilterDefault, OLESTR("NumericFilter")));

        // If loading and a filter contains an empty BSTR then change it to
        // VT_EMPTY
        
        if ( Loading() )
        {
            if (VT_BSTR == m_varTextFilter.vt)
            {
                if (!ValidBstr(m_varTextFilter.bstrVal))
                {
                    ::SysFreeString(m_varTextFilter.bstrVal);
                    ::VariantInit(&m_varTextFilter);
                }
            }

            if (VT_BSTR == m_varNumericFilter.vt)
            {
                if (!ValidBstr(m_varNumericFilter.bstrVal))
                {
                    ::SysFreeString(m_varNumericFilter.bstrVal);
                    ::VariantInit(&m_varNumericFilter);
                }
            }
        }
    }

Error:
    (void)::VariantClear(&varFilterDefault);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeader::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCColumnHeader == riid)
    {
        *ppvObjOut = static_cast<IMMCColumnHeader *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdr.h ===
//=--------------------------------------------------------------------------=
// colhdr.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class definition - implements MMCColumnHeader object
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNHEADER_DEFINED_
#define _COLUMNHEADER_DEFINED_

#include "colhdrs.h"

class CMMCColumnHeader : public CSnapInAutomationObject,
                         public CPersistence,
                         public IMMCColumnHeader
{
    private:
        CMMCColumnHeader(IUnknown *punkOuter);
        ~CMMCColumnHeader();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCColumnHeader

    public:

        SIMPLE_PROPERTY_RW(CMMCColumnHeader,     Index, long, DISPID_COLUMNHEADER_INDEX);
        BSTR_PROPERTY_RW(CMMCColumnHeader,       Key, DISPID_COLUMNHEADER_KEY);
        VARIANTREF_PROPERTY_RW(CMMCColumnHeader, Tag, DISPID_COLUMNHEADER_TAG);

        // For text we can use the macro for propget because we only need to
        // return our stored value. For propput we may need to call into MMC.
        
        STDMETHOD(put_Text)(BSTR Text);
        BSTR_PROPERTY_RO(CMMCColumnHeader, Text, DISPID_COLUMNHEADER_TEXT);

        STDMETHOD(put_Width)(short sWidth);
        STDMETHOD(get_Width)(short *psWidth);

        SIMPLE_PROPERTY_RW(CMMCColumnHeader, Alignment, SnapInColumnAlignmentConstants, DISPID_COLUMNHEADER_ALIGNMENT);

        STDMETHOD(put_Hidden)(VARIANT_BOOL fvarHidden);
        STDMETHOD(get_Hidden)(VARIANT_BOOL *pfvarHidden);

        STDMETHOD(put_TextFilter)(VARIANT varTextFilter);
        STDMETHOD(get_TextFilter)(VARIANT *pvarTextFilter);

        SIMPLE_PROPERTY_RW(CMMCColumnHeader, TextFilterMaxLen, long, DISPID_COLUMNHEADER_TEXT_FILTER_MAX_LEN);

        STDMETHOD(put_NumericFilter)(VARIANT varNumericFilter);
        STDMETHOD(get_NumericFilter)(VARIANT *pvarNumericFilter);

    // Public Utility methods

    public:

        void SetColumnHeaders(CMMCColumnHeaders *pMMCColumnHeaders) { m_pMMCColumnHeaders = pMMCColumnHeaders; }
        BSTR GetText() { return m_bstrText; }
        long GetPosition() { return m_lPosition; }
        long GetIndex() { return m_Index; }
        BOOL HaveTextFilter() { return VT_EMPTY != m_varTextFilter.vt; }
        BOOL HaveNumericFilter() { return VT_EMPTY != m_varNumericFilter.vt; }
        short GetWidth() { return m_sWidth; }
        SnapInColumnAlignmentConstants GetAlignment() { return m_Alignment; }
        BOOL Hidden() { return VARIANTBOOL_TO_BOOL(m_fvarHidden); }
        HRESULT SetFilter();

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT SetTextFilter(VARIANT varTextFilter);
        HRESULT SetNumericFilter(VARIANT varNumericFilter);
        HRESULT SetHeaderCtrlWidth(int nWidth);

        // These variables hold the values of properties that have explicit
        // put/get functions.

        VARIANT_BOOL       m_fvarHidden;
        long               m_lPosition;
        short              m_sWidth;
        VARIANT            m_varTextFilter;
        VARIANT            m_varNumericFilter;

        CMMCColumnHeaders *m_pMMCColumnHeaders; // back pointer to owning collection
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCColumnHeader,           // name
                                &CLSID_MMCColumnHeader,    // clsid
                                "MMCColumnHeader",         // objname
                                "MMCColumnHeader",         // lblname
                                &CMMCColumnHeader::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IMMCColumnHeader,     // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _COLUMNHEADER_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colset.cpp ===
//=--------------------------------------------------------------------------=
// colset.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colset.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CColumnSetting::CColumnSetting(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_COLUMNSETTING,
                            static_cast<IColumnSetting *>(this),
                            static_cast<CColumnSetting *>(this),
                            0,     // no property pages
                            NULL,  // no property pages
                            NULL)  // no peristence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CColumnSetting::~CColumnSetting()
{
    FREESTRING(m_bstrKey);
    InitMemberVariables();
}

void CColumnSetting::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

    m_Width = 0;
    m_Hidden = VARIANT_FALSE;
    m_Position = 0;
}


IUnknown *CColumnSetting::Create(IUnknown * punkOuter)
{
    CColumnSetting *pColumnSetting = New CColumnSetting(punkOuter);
    if (NULL == pColumnSetting)
    {
        return NULL;
    }
    else
    {
        return pColumnSetting->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CColumnSetting::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IColumnSetting == riid)
    {
        *ppvObjOut = static_cast<IColumnSetting *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdrs.h ===
//=--------------------------------------------------------------------------=
// colhdrs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeaders class definition - implements the MMCColumnHeaders
// collection
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNHEADERS_DEFINED_
#define _COLUMNHEADERS_DEFINED_

#include "collect.h"
#include "view.h"
#include "listview.h"

class CMMCListView;

class CMMCColumnHeaders : public CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>,
                          public CPersistence
{
    protected:
        CMMCColumnHeaders(IUnknown *punkOuter);
        ~CMMCColumnHeaders();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCColumnHeaders
        STDMETHOD(Add)(VARIANT           Index,
                       VARIANT           Key, 
                       VARIANT           Text,
                       VARIANT           Width,
                       VARIANT           Alignment,
                       MMCColumnHeader **ppMMCColumnHeader);

    // Public utility methods

    public:

        void SetListView(CMMCListView *pMMCListView) { m_pMMCListView = pMMCListView; }
        CMMCListView *GetListView() { return m_pMMCListView; }

        HRESULT GetIHeaderCtrl2(IHeaderCtrl2 **ppiHeaderCtrl2);
        HRESULT GetIColumnData(IColumnData **ppiColumnData);

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CMMCListView *m_pMMCListView; // back pointer to owning list view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCColumnHeaders,           // name
                                &CLSID_MMCColumnHeaders,    // clsid
                                "MMCColumnHeaders",         // objname
                                "MMCColumnHeaders",         // lblname
                                &CMMCColumnHeaders::Create, // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCColumnHeaders,     // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _COLUMNHEADERS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdrs.cpp ===
//=--------------------------------------------------------------------------=
// colhdrs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeaders class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colhdrs.h"
#include "colhdr.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCColumnHeaders::CMMCColumnHeaders(IUnknown *punkOuter) :
    CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>(
                      punkOuter,
                      OBJECT_TYPE_MMCCOLUMNHEADERS,
                      static_cast<IMMCColumnHeaders *>(this),
                      static_cast<CMMCColumnHeaders *>(this),
                      CLSID_MMCColumnHeader,
                      OBJECT_TYPE_MMCCOLUMNHEADER,
                      IID_IMMCColumnHeader,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCColumnHeaders,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CMMCColumnHeaders::InitMemberVariables()
{
    m_pMMCListView = NULL;
}

CMMCColumnHeaders::~CMMCColumnHeaders()
{
    InitMemberVariables();
}

IUnknown *CMMCColumnHeaders::Create(IUnknown * punkOuter)
{
    CMMCColumnHeaders *pMMCColumnHeaders = New CMMCColumnHeaders(punkOuter);
    if (NULL == pMMCColumnHeaders)
    {
        return NULL;
    }
    else
    {
        return pMMCColumnHeaders->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
// CMMCColumnHeaders::GetIHeaderCtrl2
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IHeaderCtrl2 **ppiHeaderCtrl2 [out] if non-NULL IHeaderCtrl2 returned here
//                                        NOT AddRef()ed
//                                        DO NOT call Release on the returned
//                                        interface pointer
// Output:
//      HRESULT
//
// Notes:
//
// As we are only a lowly column headers collection and the IHeaderCtrl2 pointer
// is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated column headers collection
// created  by the user or if any object up the hierarchy is isolated then we
// will return SID_E_DETACHED_OBJECT
//

HRESULT CMMCColumnHeaders::GetIHeaderCtrl2(IHeaderCtrl2 **ppiHeaderCtrl2)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pMMCListView, hr);

    pResultView = m_pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, hr);

    pScopePaneItem = pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);
    IfFalseGo(pScopePaneItem->Active(), hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    *ppiHeaderCtrl2 = pView->GetIHeaderCtrl2();
    IfFalseGo(NULL != *ppiHeaderCtrl2, hr);

    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CMMCColumnHeaders::GetIColumnData
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IColumnData **ppiColumnData [out] if non-NULL IColumnData returned here
//                                    NOT AddRef()ed
//                                    DO NOT call Release on the returned
//                                    interface pointer
// Output:
//      HRESULT
//
// Notes:
//
// As we are only a lowly column headers collection and the IColumnData pointer
// is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated column headers collection
// created  by the user or if any object up the hierarchy is isolated then we
// will return SID_E_DETACHED_OBJECT
//

HRESULT CMMCColumnHeaders::GetIColumnData(IColumnData **ppiColumnData)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pMMCListView, hr);

    pResultView = m_pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, hr);

    pScopePaneItem = pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);
    IfFalseGo(pScopePaneItem->Active(), hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    *ppiColumnData = pView->GetIColumnData();

    // If IColumnData is NULL then we are in MMC < 1.2
    
    IfFalseGo(NULL != *ppiColumnData, SID_E_MMC_FEATURE_NOT_AVAILABLE);

    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IMMCColumnHeaders Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCColumnHeaders::Add
(
    VARIANT           Index,
    VARIANT           Key, 
    VARIANT           Text,
    VARIANT           Width,
    VARIANT           Alignment,
    MMCColumnHeader **ppMMCColumnHeader
)
{
    HRESULT           hr = S_OK;
    IMMCColumnHeader *piMMCColumnHeader = NULL;
    CMMCColumnHeader *pMMCColumnHeader = NULL;
    long              lIndex = 0;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>::Add(Index, Key, &piMMCColumnHeader);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varCoerced, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCColumnHeader->put_Text(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);
    
    if (ISPRESENT(Width))
    {
        hr = ::VariantChangeType(&varCoerced, &Width, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCColumnHeader->put_Width(varCoerced.iVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Alignment))
    {
        hr = ::VariantChangeType(&varCoerced, &Alignment, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCColumnHeader->put_Alignment(static_cast<SnapInColumnAlignmentConstants>(varCoerced.iVal)));
    }

    // Give the column header its back pointer to the collection

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCColumnHeader,
                                                   &pMMCColumnHeader));
    pMMCColumnHeader->SetColumnHeaders(this);

    *ppMMCColumnHeader = reinterpret_cast<MMCColumnHeader *>(piMMCColumnHeader);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCColumnHeader);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeaders::Persist()
{
    HRESULT           hr = S_OK;
    IMMCColumnHeader *piMMCColumnHeader = NULL; // Not AddRef()ed
    CMMCColumnHeader *pMMCColumnHeader = NULL;
    long              lIndex = 0;
    long              cCols = 0;
    long              i = 0;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>::Persist(piMMCColumnHeader);

    // If we just loaded then:
    // Give the column headers their back pointers to the collection and set
    // their default Position properties.

    if (Loading())
    {
        cCols = GetCount();
        for (i = 0; i < cCols; i++)
        {
            piMMCColumnHeader = GetItemByIndex(i);

            IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCColumnHeader,
                                                           &pMMCColumnHeader));
            pMMCColumnHeader->SetColumnHeaders(this);
        }
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeaders::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCColumnHeaders == riid)
    {
        *ppvObjOut = static_cast<IMMCColumnHeaders *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colsets.cpp ===
//=--------------------------------------------------------------------------=
// colsets.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSettings class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colsets.h"
#include "colset.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CColumnSettings::CColumnSettings(IUnknown *punkOuter) :
    CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>(
                      punkOuter,
                      OBJECT_TYPE_COLUMNSETTINGS,
                      static_cast<IColumnSettings *>(this),
                      static_cast<CColumnSettings *>(this),
                      CLSID_ColumnSetting,
                      OBJECT_TYPE_COLUMNSETTING,
                      IID_IColumnSetting,
                      NULL)  // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CColumnSettings::InitMemberVariables()
{
    m_pView = NULL;
    m_bstrColumnSetID = NULL;
}

CColumnSettings::~CColumnSettings()
{
    InitMemberVariables();
    FREESTRING(m_bstrColumnSetID);
}

IUnknown *CColumnSettings::Create(IUnknown * punkOuter)
{
    CColumnSettings *pColumnSettings = New CColumnSettings(punkOuter);
    if (NULL == pColumnSettings)
    {
        return NULL;
    }
    else
    {
        return pColumnSettings->PrivateUnknown();
    }
}


static int __cdecl CompareColumnPosition
(
    const MMC_COLUMN_DATA *pCol1,
    const MMC_COLUMN_DATA *pCol2
)
{
    int nResult = 0;

    if (pCol1->ulReserved < pCol2->ulReserved)
    {
        nResult = -1;
    }
    else if (pCol1->ulReserved == pCol2->ulReserved)
    {
        nResult = 0;
    }
    else if (pCol1->ulReserved > pCol2->ulReserved)
    {
        nResult = 1;
    }
    return nResult;
}




//=--------------------------------------------------------------------------=
//                      IColumnSettings Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CColumnSettings::Add
(
    VARIANT         Index,
    VARIANT         Key, 
    VARIANT         Width,
    VARIANT         Hidden,
    VARIANT         Position,
    ColumnSetting **ppColumnSetting
)
{
    HRESULT         hr = S_OK;
    IColumnSetting *piColumnSetting = NULL;
    CColumnSetting *pColumnSetting = NULL;
    long            lIndex = 0;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>::Add(Index, Key, &piColumnSetting);
    IfFailGo(hr);

    if (ISPRESENT(Width))
    {
        hr = ::VariantChangeType(&varCoerced, &Width, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piColumnSetting->put_Width(varCoerced.lVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Hidden))
    {
        hr = ::VariantChangeType(&varCoerced, &Hidden, 0, VT_BOOL);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piColumnSetting->put_Hidden(varCoerced.boolVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Position))
    {
        hr = ::VariantChangeType(&varCoerced, &Position, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piColumnSetting->put_Position(varCoerced.iVal));
    }
    else
    {
        // A new column header's position defaults to its index

        IfFailGo(piColumnSetting->get_Index(&lIndex));
        IfFailGo(piColumnSetting->put_Position(lIndex));
    }

    *ppColumnSetting = reinterpret_cast<ColumnSetting *>(piColumnSetting);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piColumnSetting);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}


STDMETHODIMP CColumnSettings::Persist()
{
    HRESULT              hr = S_OK;
    CColumnSetting      *pColumnSetting = NULL;
    MMC_COLUMN_SET_DATA *pColSetData = NULL;
    MMC_COLUMN_DATA     *pColData = NULL;
    long                 i = 0;
    long                 cColumns = 0;
    size_t               cbBuffer = 0;
    IColumnData         *piColumnData = NULL; // Not AddRef()ed
    SColumnSetID        *pSColumnSetID = NULL;

    if (NULL == m_pView)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    piColumnData = m_pView->GetIColumnData();
    if (NULL == piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::GetColumnSetID(m_bstrColumnSetID, &pSColumnSetID));

    // Allocate memory for the column config data. Use CoTaskMemAlloc() to be
    // compatible with the way MMC allocates it.

    cColumns = GetCount();
    IfFalseGo(0 != cColumns, S_OK); // no columns, nothing to do

    cbBuffer = sizeof(MMC_COLUMN_SET_DATA) +
               (cColumns * sizeof(MMC_COLUMN_DATA));

    pColSetData = (MMC_COLUMN_SET_DATA *)CtlAllocZero(static_cast<DWORD>(cbBuffer));
    if (NULL == pColSetData)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::ZeroMemory(pColSetData, static_cast<DWORD>(cbBuffer));

    pColSetData->cbSize = sizeof(MMC_COLUMN_SET_DATA);
    pColSetData->nNumCols = static_cast<int>(cColumns);
    pColSetData->pColData = (MMC_COLUMN_DATA *)((pColSetData) + 1);

    for (i = 0, pColData = pColSetData->pColData;
         i < cColumns;
         i++, pColData++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pColumnSetting));

        pColData->nColIndex = static_cast<int>(pColumnSetting->GetIndex() - 1L);
        if (pColumnSetting->Hidden())
        {
            pColData->dwFlags |= HDI_HIDDEN;
        }
        pColData->nWidth = static_cast<int>(pColumnSetting->GetWidth());

        // For now put Position in the reserved field. We'll clean it up
        // below afer reordering the columns
        pColData->ulReserved = pColumnSetting->GetPosition();
    }

    // At this point the column data structs are in the array in index order
    // They need to be sorted according to their Position property.

    ::qsort(pColSetData->pColData,
            static_cast<size_t>(cColumns),
            sizeof(MMC_COLUMN_DATA),
            reinterpret_cast<int (__cdecl *)(const void *c1, const void *c2)>
            (CompareColumnPosition)
           );

    // Zero out the reserved field we used above to hold the position

    for (i = 0, pColData = pColSetData->pColData;
         i < cColumns;
         i++, pColData++)
    {
        pColData->ulReserved = 0;
    }

    // Tell MMC do persist the column data

    hr = piColumnData->SetColumnConfigData(pSColumnSetID, pColSetData);
    EXCEPTION_CHECK_GO(hr);

Error:
    if (NULL != pColSetData)
    {
        CtlFree(pColSetData);
    }
    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CColumnSettings::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IColumnSettings == riid)
    {
        *ppvObjOut = static_cast<IColumnSettings *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colset.h ===
//=--------------------------------------------------------------------------=
// colset.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSetting class definition - ColumnSetting object implementation
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNSETTING_DEFINED_
#define _COLUMNSETTING_DEFINED_

#include "colhdrs.h"

class CColumnSetting : public CSnapInAutomationObject,
                       public IColumnSetting
{
    private:
        CColumnSetting(IUnknown *punkOuter);
        ~CColumnSetting();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IColumnSetting

    public:

        SIMPLE_PROPERTY_RW(CColumnSetting, Index,    long,         DISPID_COLUMNSETTING_INDEX);
        BSTR_PROPERTY_RW(CColumnSetting,   Key,                    DISPID_COLUMNSETTING_KEY);
        SIMPLE_PROPERTY_RW(CColumnSetting, Width,    long,         DISPID_COLUMNSETTING_WIDTH);
        SIMPLE_PROPERTY_RW(CColumnSetting, Hidden,   VARIANT_BOOL, DISPID_COLUMNSETTING_HIDDEN);
        SIMPLE_PROPERTY_RW(CColumnSetting, Position, long,         DISPID_COLUMNSETTING_POSITION);

    // Public Utility methods

    public:

        long GetPosition() { return m_Position; }
        long GetIndex() { return m_Index; }
        long GetWidth() { return m_Width; }
        BOOL Hidden() { return VARIANTBOOL_TO_BOOL(m_Hidden); }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ColumnSetting,           // name
                                &CLSID_ColumnSetting,    // clsid
                                "ColumnSetting",         // objname
                                "ColumnSetting",         // lblname
                                &CColumnSetting::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IColumnSetting,     // dispatch IID
                                NULL,                    // event IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _COLUMNSETTING_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\collect.h ===
//=--------------------------------------------------------------------------=
// collect.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInCollection class definition
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPINCOLLECTION_DEFINED_
#define _SNAPINCOLLECTION_DEFINED_

#include "siautobj.h"
#include "help.h"
#include "array.h"
#include "localobj.h"
#include "tlver.h"
#include "errors.h"
#include "error.h"
#include "rtutil.h"

// This macro determines whether a VARIANT has an acceptable type for a
// a collection index


#define IS_VALID_INDEX_TYPE(v) ( (VT_UI1  == (v).vt) || \
                                 (VT_I2   == (v).vt) || \
                                 (VT_I4   == (v).vt) || \
                                 (VT_BSTR == (v).vt) )

// Forward reference to CEnumObjects class that implements IEnumVARIANT
// to support For...Each in VB

template <class IObject, class CoClass, class ICollection>
class CEnumObjects;

//=--------------------------------------------------------------------------=
//
// class CSnapInCollection
//
// This is a template class that implements all the collections in the
// designer runtime.
//
// Template Arguments:
//
// class IObject - this is the interface of the object that is contained in
//                 the collection (e.g. IMMCColumnHeader). Every object interface
//                 must have Index and Key properties.
//
// class CoClass - this is the coclass of the object contained in the collection
//                 (e.g. MMCColumnHeader)
//
// class ICollection - this is the interface of the collection class e.g.
//                     IMMCColumnHeaders
//
// Every object in a collection has a key and an index. The index is simply
// its one-based ordinal position in the colleciton. They key is a string that
// uniquely identifies an object in the collection.
//
// There are two types of collections: master and keys-only.
// A master collection is a 'normal' collection. It contains interface pointers
// to the objects in the collection.
//
// A keys-only collection holds interfaces pointers like a master collection
// when it is new. When it is saved in a project, it serializes only
// the objects' keys and the count of objects.
// Keys-only collections are used in the design-time
// definition objects to deal with the situation where a result view is
// used by multiple nodes and it also appears in the general result views
// section at the bottom of the designer treeview.
// When a keys-only collection is loaded, it creates new objects but only
// sets their Key property. When a caller attempts to
// get an object from a keys-only collection that was read from serialization,
// the collection is updated to hold all of the interface pointers just like
// the master collection.
//
// Collections support notifications to an object model host using
// IObjectModelHost (defined in mssnapr.idl). Notifications are sent for
// updates, adds, and deletes.
//
// When an object is added or removed, the collection calls
// IObjectMode::Increment/DecrementUsageCount. The usage count, (separate from
// the object's reference count) indicates membership in a collection. The
// design time uses this to determine if a result view is in use by checking
// how may collections it belongs to. If it only belongs to one, (i.e. it is
// not used by any nodes), then it can be deleted by the user.
//
// Collections can also be marked read-only to prevent Add/Remove/Clear from
// working.
//
// The class uses a stolen verion of MFC's CArray template class to hold
// the interface pointer.
//=--------------------------------------------------------------------------=

template <class IObject, class CoClass, class ICollection>
class CSnapInCollection : public CSnapInAutomationObject,
                          public ICollection
{
    protected:
        CSnapInCollection(IUnknown     *punkOuter,
                          int           nObjectType,
                          void         *piMainInterface,
                          void         *pThis,
                          REFCLSID      clsidObject,
                          UINT          idObject,
                          REFIID        iidObject,
                          CPersistence *pPersistence);

        ~CSnapInCollection();

    public:

        // Standard collection methods exposed for all collections

        STDMETHOD(get_Count)(long *plCount);
        STDMETHOD(get_Item)(VARIANT Index, IObject **ppiObject);
        STDMETHOD(get_Item)(VARIANT Index, CoClass **ppObject);
        STDMETHOD(get__NewEnum)(IUnknown **ppunkEnum);
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, IObject **ppiNewObject);
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, CoClass **ppNewObject);

        // AddFromMaster adds an existing object from a master collection
        // to a keys-only collection. This is called at design time when
        // the user adds an existing result view to a node.
        
        STDMETHOD(AddFromMaster)(IObject *piMasterObject);

        // More standard collection methods
        
        STDMETHOD(Clear)();
        STDMETHOD(Remove)(VARIANT Index);

        // Swap allows exchanging the position of two elements in a collection
        // Used at design time to implement the moving of menus.
        
        STDMETHOD(Swap)(long lOldIndex, long lNewIndex);

        // Derived collection classes may use this method for adding
        // non-cocreatable objects

        HRESULT AddExisting(VARIANT Index, VARIANT Key, IObject *piObject);

        // Some handy helpers

        // Simple helper for getting directly to collection items by index
        // without AddRef(). NOTE: this is the zero based index.

        IObject *GetItemByIndex(long lIndex) { return m_IPArray.GetAt(lIndex); }

        // Look up an object by name (without using VARIANT index)

        HRESULT GetItemByName(BSTR bstrName, IObject **ppiObject);

        // Get the collection count

        long GetCount() { return m_IPArray.GetSize(); }

        // Set the read-only status of the collection

        void SetReadOnly(BOOL fReadOnly) { m_fReadOnly = fReadOnly; }

        // Get the read-only status of the collection

        BOOL ReadOnly() { return m_fReadOnly; }

    protected:

        // If the collection class supports persistence then it must call
        // this method in its Persist() method. Note that this class does
        // not derive from CPersistence and this method is *not* the override
        // of CPersistence::Persist().

        HRESULT Persist(IObject *piObject);

        // If the collection class is potentially keys-only then it must
        // specialize this method in order to supply an interface pointer
        // to the master collection.

#if defined(MASTER_COLLECTION)
        HRESULT GetMaster(ICollection **ppiCollection);
#endif

    // CSnapInAutomationObject overrides

        // This implementation will call CSnapInAutomationObject::SetObjectHost
        // for each collection member
        virtual HRESULT OnSetHost();

    private:

        void InitMemberVariables();
        HRESULT ReleaseAllItems();
        HRESULT AddToMaster(VARIANT Index, VARIANT Key, IObject **ppiNewObject);
        HRESULT RemoveFromMaster(VARIANT Index);
        HRESULT GetFromMaster(IObject *piKeyItem, IObject **ppiMasterItem);
        HRESULT SyncWithMaster();
        HRESULT CreateItem(IObject **ppiObject);
        HRESULT FindItem(VARIANT Index, long *plIndex, IObject **ppiObject);

        enum FindOptions { DontGenerateExceptionInfoOnError,
                           GenerateExceptionInfoOnError };
        
        HRESULT FindItemByKey(BSTR bstrKey, long *plIndex, FindOptions option,
                              IObject **ppiObject);
        HRESULT FindSlot(VARIANT  Index,
                         VARIANT  Key,
                         long    *plNewIndex,
                         BSTR    *pbstrKey,
                         IObject *piObject);
        HRESULT DecrementObjectUsageCount(IObject *piObject);
        HRESULT IncrementObjectUsageCount(IObject *piObject);
        HRESULT UpdateIndexes(long lStart);

        CArray<IObject *>    m_IPArray;           // holds interface pointers
                                                  // of objects in collection
        CLSID                m_clsidObject;       // CLSID of contained object
        UINT                 m_idObject;          // Framework ID of contained
                                                  // object from localobj.h
                                                  
        IID                  m_iidObject;         // IID of contained object
        CPersistence        *m_pPersistence;      // Used to implement save/load
        BOOL                 m_fSyncedWithMaster; // TRUE=keys-only collection
                                                  // has been synced up with
                                                  // master following
                                                  // deserialization
        BOOL                 m_fReadOnly;         // TRUE=Add/Remove/Clear not
                                                  // allowed
};




//=--------------------------------------------------------------------------=
// CSnapInCollection constructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IUnknown     *punkOuter       [in] outer IUnknown if aggregated
//   int           nObjectType     [in] collection object ID from localobj.h
//   void         *piMainInterface [in] collection object interface (e.g. IMMCButtons)
//   void         *pThis           [in] collection class' this pointer
//   REFCLSID      clsidObject     [in] contained object CLSID
//   UINT          idObject        [in] contained object ID from localobj.h
//   REFIID        iidObject       [in] contained object IID (e.g. IID_IMMCButton)
//   CPersistence *pPersistence    [in] collection's persistence object
//
// Output:
//   None
//
// Notes:
//
// Calls base class contstructor and stores parameters. Cannot fail.
//
template <class IObject, class CoClass, class ICollection>
CSnapInCollection<IObject, CoClass, ICollection>::CSnapInCollection
(
    IUnknown     *punkOuter,
    int           nObjectType,
    void         *piMainInterface,
    void         *pThis,
    REFCLSID      clsidObject,
    UINT          idObject,
    REFIID        iidObject,
    CPersistence *pPersistence
) : CSnapInAutomationObject(punkOuter,
                            nObjectType,
                            piMainInterface,
                            pThis,
                            0,    // no property pages
                            NULL, // no property pages
                            pPersistence)
{
    InitMemberVariables();
    m_clsidObject = clsidObject;
    m_idObject = idObject;
    m_iidObject = iidObject;
    m_pPersistence = pPersistence;
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::InitMemberVariables
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
//
// Initializes member variables
//
template <class IObject, class CoClass, class ICollection>
void CSnapInCollection<IObject, CoClass, ICollection>::InitMemberVariables()
{
    m_pPersistence = NULL;
    m_IPArray.SetSize(0);

    // m_fSyncedWithMaster is initialized to TRUE. When a keys-only collection
    // is deserialized then it will be set to FALSE so that the first Get will
    // do the synchronization.

    m_fSyncedWithMaster = TRUE;
    m_fReadOnly = FALSE;
}



//=--------------------------------------------------------------------------=
// CSnapInCollection destructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
//
// Revokes read-only status, releases all interface pointers, and initializes
// member variables
//
template <class IObject, class CoClass, class ICollection>
CSnapInCollection<IObject, CoClass, ICollection>::~CSnapInCollection()
{
    m_fReadOnly = FALSE;
    (void)Clear();
    InitMemberVariables();
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::get_Count
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long *plCount [out] - count of objects in collection returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Count method
// Asks CArray for current size
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get_Count(long *plCount)
{
    *plCount = m_IPArray.GetSize();
    return S_OK;
}



//=--------------------------------------------------------------------------=
// CSnapInCollection::get__NewEnum
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IUnknown **ppunkEnum [out] - IUnknown of object that implements
//                               IEnumVARIANT returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements For...Each in VB. To implement For...Each VB starts by asking
// the collection for its _NewEnum property. It will QI the returned IUnknown
// for IEnumVARIANT and then call IEnumVARIANT::Next to get each element
// of the collection.
//
// Creates an instance of the CEnumObjects class (defined below in this file)
// and returns its IUnknown.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get__NewEnum
(
    IUnknown **ppunkEnum
)
{
    HRESULT       hr = S_OK;
    CEnumObjects<IObject, CoClass, ICollection> *pEnumObjects = New CEnumObjects<IObject, CoClass, ICollection>(this);

    if (NULL == pEnumObjects)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILED(hr))
    {
        if (NULL != pEnumObjects)
        {
            delete pEnumObjects;
        }
        *ppunkEnum = NULL;
    }
    else
    {
        *ppunkEnum = static_cast<IUnknown *>(static_cast<IEnumVARIANT *>(pEnumObjects));
    }

    H_RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapInCollection::ReleaseAllItems
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   HRESULT
//
// Notes:
//
// Iterates through collection and does:
// 1) Removes object mode host from object so that it will release its back
//    pointer
// 2) Releases inteface pointer on object
// 3) Sets the interface pointer position in the CArray to NULL
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::ReleaseAllItems()
{
   HRESULT hr = S_OK;
   long    i = 0;
   long    cItems = m_IPArray.GetSize();
   IObject *piObject = NULL; 

   while (i < cItems)
   {
       piObject = m_IPArray.GetAt(i);
       if (NULL != piObject)
       {
           H_IfFailRet(RemoveObjectHost(piObject));
           piObject->Release();
           m_IPArray.SetAt(i, NULL);
       }
       i++;
   }
   return S_OK;
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::Clear
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Clear method.
// Calls ReleaseAllItems to release inteface pointers in CArray
// Truncates CArray to zero size
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Clear()
{
   HRESULT hr = S_OK;

   if (m_fReadOnly)
   {
       hr = SID_E_COLLECTION_READONLY;
       EXCEPTION_CHECK_GO(hr);
   }
   
   H_IfFailGo(ReleaseAllItems());
   H_IfFailGo(m_IPArray.SetSize(0));

Error:
   H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::AddToMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index for new object
//  VARIANT   Key          [in]  Key for new object
//  IObject **ppiNewObject [out] Newly added object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Adds a new object to a master collection. This method is called from
// CSnapInCollection::Add when the caller is adding an object to a keys-only
// collection. It calls the virtual function GetMaster which must be overriden
// by the derived collection class as only it know who its master collection is.
// For example, at design time, when the user adds a new list view under a node,
// the designer calls the ScopeItemDef.ViewDefs.ListViewDefs.Add. That collection
// is keys-only, so CSnapInCollection.Add calls this method. CListViewDefs
// (in lvdefs.cpp) overrides GetMaster and returns the master
// SnapInDesignerDef.ViewDefs.ListViewDefs.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::AddToMaster
(
    VARIANT   Index,
    VARIANT   Key,
    IObject **ppiNewObject
)
{
    HRESULT      hr = S_OK;
#if defined(MASTER_COLLECTION)
    ICollection *piMasterCollection = NULL;

    H_IfFailRet(GetMaster(&piMasterCollection));
    hr = piMasterCollection->Add(Index, Key, ppiNewObject);

    QUICK_RELEASE(piMasterCollection);
#endif
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::RemoveFromMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index or key of object to remove
//
// Output:
//   HRESULT
//
// Notes:
//
// Removes an object from a master collection. This method is called from
// CSnapInCollection::Add when the caller is adding an object to a keys-only
// collection and a failure occurs after adding the object. See 
// CSnapInCollection::AddToMaster above for more info
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::RemoveFromMaster(VARIANT Index)
{
    HRESULT      hr = S_OK;
#if defined(MASTER_COLLECTION)
    ICollection *piMasterCollection = NULL;

    H_IfFailGo(GetMaster(&piMasterCollection));
    hr = piMasterCollection->Remove(Index);

Error:
    QUICK_RELEASE(piMasterCollection);
#endif
    H_RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapInCollection::GetFromMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject  *piKeyItem     [in] object from keys-only collection
//  IObject **ppiMasterItem [out] corresponding object from master collection
//
// Output:
//   HRESULT
//
// Notes:
//
// When a keys-only collection receives a get_Item call it must sync up with
// the master collection and replace all of its key-only objects with interface
// pointers on the real objects. This function returns the corresponding object
// from the master collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::GetFromMaster
(
    IObject  *piKeyItem,
    IObject **ppiMasterItem
)
{
    HRESULT      hr = S_OK;
#if defined(MASTER_COLLECTION)
    ICollection *piMasterCollection = NULL;
    VARIANT      varKey;
    ::VariantInit(&varKey);

    // Call the collection's overriden GetMaster to get the master collection.

    H_IfFailGo(GetMaster(&piMasterCollection));
    H_IfFailGo(piKeyItem->get_Key(&varKey.bstrVal));
    varKey.vt = VT_BSTR;
    hr = piMasterCollection->get_Item(varKey, ppiMasterItem);

Error:
    QUICK_RELEASE(piMasterCollection);
    (void)::VariantClear(&varKey);
#endif
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Remove
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT Index     [in] Index or key of object to remove
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Remove method
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Remove(VARIANT Index)
{
    long     lIndex = 0;
    IObject *piObject = NULL;
    HRESULT  hr = S_OK;

    if (m_fReadOnly)
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Do a find to ensure the item is there and to AddRef() it.

    H_IfFailGo(FindItem(Index, &lIndex, &piObject));

    // Release the collection's reference on the object and remove it from the
    // array (we still have the ref from the find)

    m_IPArray.GetAt(lIndex)->Release();
    m_IPArray.SetAt(lIndex, NULL);
    m_IPArray.RemoveAt(lIndex);

    // If this is a real collection (not keys-only) then we need to decrement
    // the indexes of each item following the item that was added. This will
    // ensure that the index property of every item following the deleted item
    // correctly represents its position in the array.

    if (!KeysOnly())
    {
        H_IfFailGo(UpdateIndexes(lIndex));
    }

    // Notify the object host of the deletion

    H_IfFailGo(NotifyDelete(piObject));

    // Decrement the object's usage count as it is now leaving this
    // collection

    H_IfFailGo(DecrementObjectUsageCount(piObject));

    // Remove its object host reference

    H_IfFailGo(RemoveObjectHost(piObject));

    // The QUICK_RELEASE() macro below will release the reference from
    // the find.

Error:
    QUICK_RELEASE(piObject);
    H_RRETURN(hr);
}





//=--------------------------------------------------------------------------=
// CSnapInCollection::GetItemByName
//=--------------------------------------------------------------------------=
//
// Parameters:
//  BSTR      bstrName  [in] Key of object to retrieve
//  IObject **ppiObject [out] Object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Convenient shortcut for get_Item with a VARIANT containing a key. Relieves the
// caller from having to use the VARIANT. Function really should be called
// GetItemByKey.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::GetItemByName(BSTR bstrName, IObject **ppiObject)
{
    VARIANT varIndex;
    ::VariantInit(&varIndex);

    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = bstrName;
    H_RRETURN(get_Item(varIndex, ppiObject));
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::get_Item
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index     [in] Index or key of object to retrieve
//  IObject **ppiObject [out] Object interface pointer returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Item property for gets that return interface
// pointers. Called when VB code
// does:
//          Set SomeInterface = SomeCollection(SomeIndex)
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get_Item
(
    VARIANT   Index,
    IObject **ppiObject
)
{
    HRESULT hr = S_OK;
    long    lIndex = 0;

    if (NULL == ppiObject)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are not yet synced up with the master collection then
    // do it now.

    if ( KeysOnly() && (!m_fSyncedWithMaster) )
    {
        H_IfFailRet(SyncWithMaster());
    }

    H_IfFailRet(FindItem(Index, &lIndex, ppiObject));
Error:
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::get_Item
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index     [in] Index or key of object to retrieve
//  CoClass **ppObject [out] Object pointer returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Item property for gets that return coclasses
// Called when VB code
// does:
//          Set SomeObject = SomeCollection(SomeIndex)
//
// A CoClass pointer is just an inteface pointer to the default interface for the
// coclass. This function just uses the interface pointer version of get_Item
// (see above) and casts the returned pointer to a coclass pointer
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get_Item
(
    VARIANT   Index,
    CoClass **ppObject
)
{
    H_RRETURN(get_Item(Index, reinterpret_cast<IObject **>(ppObject)));
}





//=--------------------------------------------------------------------------=
// CSnapInCollection::Add
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index for new object
//  VARIANT   Key          [in]  Key for new object
//  IObject **ppiNewObject [out] Newly added object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Add that returns interface pointer on new
// object.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Add
(
    VARIANT   Index,
    VARIANT   Key,
    IObject **ppiNewObject)
{
    HRESULT  hr = S_OK;
    BOOL     fAdded = FALSE;
    BOOL     fAddedToMaster = FALSE;
    long     lNewIndex = 0;
    BSTR     bstrKey = NULL;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    if (m_fReadOnly)
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Check that the requested index and key are valid and
    // convert them to a long and a BSTR

    H_IfFailGo(FindSlot(Index, Key, &lNewIndex, &bstrKey, (IObject *)NULL));

    if (KeysOnly())
    {
        // If there is a master collection then do the add there.
        // Don't pass an index as the master collection will append it.
        // The master collection will set *it's* index and the key in
        // the object. In this case the Index property will not match
        // the index in m_IPArray. This is only done for collections
        // used in the extensibility model at design time.

        H_IfFailGo(AddToMaster(varUnspecifiedIndex, Key, ppiNewObject));
        fAddedToMaster = TRUE;
    }
    else
    {
        // Create the new object and set its index and key

        H_IfFailGo(CreateItem(ppiNewObject));
        H_IfFailGo((*ppiNewObject)->put_Index(lNewIndex + 1L));
        H_IfFailGo((*ppiNewObject)->put_Key(bstrKey));
        H_IfFailGo(SetObjectHost(*ppiNewObject));
    }

    // Increment the object's usage count as it is now part of this
    // collection

    H_IfFailGo(IncrementObjectUsageCount(*ppiNewObject));

    H_IfFailGo(m_IPArray.InsertAt(lNewIndex, *ppiNewObject));
    fAdded = TRUE;


    // If this is a real collection (not keys-only) then we need to increment
    // the indexes of each item following the item that was added. In the
    // case of an insert this will ensure that the index property of every
    // item following the new item correctly represents its position in the
    // array. In the case of an append, this call will not do anything.
    
    if (!KeysOnly())
    {
        H_IfFailGo(UpdateIndexes(lNewIndex + 1L));
    }

    // In both cases notify the UI of the addition

    hr = NotifyAdd(m_IPArray.GetAt(lNewIndex));

Error:
    FREESTRING(bstrKey);
    if (SUCCEEDED(hr))
    {
        // The collection has one ref. Add a ref for return to caller. 
        (*ppiNewObject)->AddRef();
    }
    else
    {
        if (fAddedToMaster)
        {
            (void)RemoveFromMaster(Key);
        }
        if (fAdded)
        {
            (void)RemoveObjectHost(*ppiNewObject);
            m_IPArray.RemoveAt(lNewIndex);
        }
        QUICK_RELEASE(*ppiNewObject);
    }
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Add
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index for new object
//  VARIANT   Key          [in]  Key for new object
//  CoClass **ppNewObject  [out] Newly added object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Add that returns object pointer on new
// object.
//
// A CoClass pointer is just an inteface pointer to the default interface for the
// coclass. This function just uses the interface pointer version of Add
// (see above) and casts the returned pointer to a coclass pointer
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Add
(
    VARIANT   Index,
    VARIANT   Key,
    CoClass **ppNewObject
)
{
    H_RRETURN(Add(Index, Key, reinterpret_cast<IObject **>(ppNewObject)));
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::UpdateIndexes
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long lStart [in] First index to be updated
//
// Output:
//   HRESULT
//
// Notes:
//
// Increments the Index property of every object in the collection starting with
// the object whose current Index value is lStart
// object.
//
// This function is used when adding or removing objects from the collection
// so that the Index property always reflects the object's ordinal position
// in the collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::UpdateIndexes(long lStart)
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cItems = m_IPArray.GetSize();

    // Starting at the specified array index, update each object's
    // index property to its position in the array + 1 (as we are a one
    // based collection).

    for (i = lStart; i < cItems; i++)
    {
        H_IfFailGo(m_IPArray.GetAt(i)->put_Index(i + 1L));
    }

Error:    
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::AddExisting
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT  Index        [in] Index for new object
//  VARIANT  Key          [in] Key for new object
//  IObject *piNewObject  [in] Object to be added
//
// Output:
//   HRESULT
//
// Notes:
//
// Adds an existing object to the collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::AddExisting
(
    VARIANT  Index,
    VARIANT  Key,
    IObject  *piObject
)
{
    HRESULT  hr = S_OK;
    BOOL     fAdded = FALSE;
    long     lNewIndex = 0;
    BSTR     bstrKey = NULL;

    // Check that the requested index and key are valid and
    // convert them to a long and a BSTR

    H_IfFailGo(FindSlot(Index, Key, &lNewIndex, &bstrKey, (IObject *)NULL));

    H_IfFailGo(piObject->put_Index(lNewIndex + 1L));
    H_IfFailGo(piObject->put_Key(bstrKey));
    H_IfFailGo(SetObjectHost(piObject));
    H_IfFailGo(m_IPArray.InsertAt(lNewIndex, piObject));
    fAdded = TRUE;

    // Increment the object's usage count as it is now part of this
    // collection

    H_IfFailGo(IncrementObjectUsageCount(piObject));

    // If this is a real collection (not keys-only) then we need to increment
    // the indexes of each item following the item that was added. In the
    // case of an insert this will ensure that the index property of every
    // item following the new item correctly represents its position in the
    // array. In the case of an append, this call will not do anything.

    if (!KeysOnly())
    {
        H_IfFailGo(UpdateIndexes(lNewIndex + 1L));
    }

    // Notify the UI of the addition

    hr = NotifyAdd(m_IPArray.GetAt(lNewIndex));

    // Add a ref for the collection

    piObject->AddRef();

Error:
    FREESTRING(bstrKey);
    if (FAILED(hr))
    {
        if (fAdded)
        {
            (void)RemoveObjectHost(piObject);
            m_IPArray.RemoveAt(lNewIndex);
        }
    }
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::AddExisting
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject *piMasterObject  [in] Object to be added
//
// Output:
//   HRESULT
//
// Notes:
//
// Adds an existing object from a master collection
// to a keys-only collection. This is called at design time when
// the user adds an existing result view to a node.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::AddFromMaster
(
    IObject *piMasterObject
)
{
    HRESULT  hr = S_OK;
    BOOL     fAdded = FALSE;
    long     lNewIndex = 0;

    H_IfFailGo(m_IPArray.Add(piMasterObject, &lNewIndex));
    piMasterObject->AddRef();
    fAdded = TRUE;

    // Increment the object's usage count as it is now part of this
    // collection

    H_IfFailGo(IncrementObjectUsageCount(piMasterObject));

    // Notify the UI of the addition

    hr = NotifyAdd(m_IPArray.GetAt(lNewIndex));

Error:
    if (FAILED(hr) && fAdded)
    {
        m_IPArray.RemoveAt(lNewIndex);
    }
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Swap
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long lIndex1 [in] index of first object to swap
//  long lIndex2 [in] index of second object to swap
//
// Output:
//   HRESULT
//
// Notes:
//
// Echanges the positions of two objects in the collection and updates their
// Index properties to reflect the new positions. Used at design time when
// a user moves a menu.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Swap
(
    long lIndex1,
    long lIndex2
)
{
    HRESULT  hr = S_OK;
    IObject *piObject1 = NULL; // Not AddRef()ed
    IObject *piObject2 = NULL; // Not AddRef()ed
    long     cItems = m_IPArray.GetSize();

    // Check index validity (1 based).
    // Old index must be somewhere in the collection. New index must be either
    // in the collection or 1 past the end (i.e append to end).

    if ( (lIndex1 < 1L) || (lIndex1 > cItems) ||
         (lIndex2 < 1L) || (lIndex2 > cItems)
       )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get object pointers and switch 'em

    piObject1 = m_IPArray.GetAt(lIndex1 - 1L);
    piObject2 = m_IPArray.GetAt(lIndex2 - 1L);
    m_IPArray.SetAt(lIndex1 - 1L, piObject2);
    m_IPArray.SetAt(lIndex2 - 1L, piObject1);

    // Update both objects' index properties
    
    H_IfFailGo(piObject1->put_Index(lIndex2));
    H_IfFailGo(piObject2->put_Index(lIndex1));

Error:
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Persist
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject *piObject [in] a NULL interface pointer on the contained object
//                         Only used internally within the function. Does not
//                         affect the caller.
//
// Output:
//   HRESULT
//
// Notes:
// If the collection class supports persistence then it must call
// this method in its Persist() functon override. Note that this class does
// not derive from CPersistence and this method is *not* the override
// of CPersistence::Persist(). Collections that support persistence must pass
// their CPersistence pointer to the CSnapInCollection constructor.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::Persist(IObject *piObject)
{
    HRESULT  hr = S_OK;
    long     cItems = m_IPArray.GetSize();
    long     iItem = 0;
    long     lNewIndex = 0;
    IObject *piNewObject = NULL;
    BOOL     fKeysOnly = FALSE;
    BSTR     bstrKey = NULL;
    
    OLECHAR  wszPropBagItem[32];
    ::ZeroMemory(wszPropBagItem, sizeof(wszPropBagItem));

    VARIANT varIndex;
    ::VariantInit(&varIndex);
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    // Always persist count and KeysOnly. Need to persist KeysOnly even for
    // an empty collection because it is only set during InitNew. If we didn't
    // serialize it then when the project is next loaded it will revert to
    // its default value because InitNew will not be called.

    H_IfFalseGo(NULL != m_pPersistence, S_OK);
    H_IfFailGo(m_pPersistence->PersistSimpleType(&cItems, 0L, OLESTR("Count")));

    if (m_pPersistence->Saving())
    {
        fKeysOnly = KeysOnly();
    }

    H_IfFailGo(m_pPersistence->PersistSimpleType(&fKeysOnly, FALSE, OLESTR("KeysOnly")));

    if (m_pPersistence->Loading())
    {
        SetKeysOnly(fKeysOnly);
    }

    // If the collection is empty then we're done.
    
    H_IfFalseGo(0 != cItems, S_OK);

    // Set up prefix of prop bag item name. For each item we will append
    // its index (Item0, Item1, etc.) and use this as the property name
    // for they item's key in a keys only collection.

    ::wcscpy(wszPropBagItem, L"Item");

    if (m_pPersistence->Saving())
    {
        while(varIndex.lVal <= cItems)
        {
            H_IfFailGo(get_Item(varIndex, &piObject));
            ::_ltow(varIndex.lVal, &wszPropBagItem[4], 10); // Creates string "Item<n>"
            if (fKeysOnly)
            {
                H_IfFailGo(piObject->get_Key(&bstrKey));
                H_IfFailGo(m_pPersistence->PersistBstr(&bstrKey, L"", wszPropBagItem));
            }
            else
            {
                H_IfFailGo(m_pPersistence->PersistObject(&piObject,
                                                         m_clsidObject,
                                                         m_idObject,
                                                         m_iidObject,
                                                         wszPropBagItem));
            }
            FREESTRING(bstrKey);
            RELEASE(piObject);
            varIndex.lVal++;
        }
    }

    else if (m_pPersistence->Loading())
    {
        // Need to clean out collection before we load it

        H_IfFailGo(ReleaseAllItems());

        // Set array size up front to avoid multiple reallocations

        H_IfFailGo(m_IPArray.SetSize(cItems));

        if (fKeysOnly)
        {
            m_fSyncedWithMaster = FALSE; // sync with master on 1st Get
        }
        else
        {
            m_fSyncedWithMaster = TRUE; // we are the master, no sync
        }

        while(varIndex.lVal <= cItems)
        {
            ::_ltow(varIndex.lVal, &wszPropBagItem[4], 10); // Creates string "Item<n>"
            if (fKeysOnly)
            {
                // Create a new object and set only its key. When
                // the first get_Item occurs we will sync with the
                // master using this key.
                H_IfFailGo(CreateItem(&piNewObject));
                H_IfFailGo(m_pPersistence->PersistBstr(&bstrKey, L"", wszPropBagItem));
                H_IfFailGo(piNewObject->put_Key(bstrKey));
                FREESTRING(bstrKey);
            }
            else
            {
                H_IfFailGo(m_pPersistence->PersistObject(&piNewObject,
                                                         m_clsidObject,
                                                         m_idObject,
                                                         m_iidObject,
                                                         wszPropBagItem));
            }

            // Increment the object's usage count as it is now part of this
            // collection

            H_IfFailGo(IncrementObjectUsageCount(piNewObject));
            
            m_IPArray.SetAt(varIndex.lVal - 1L, piNewObject);

            piNewObject = NULL; // don't release because collection owns it
            varIndex.lVal++;
        }
    }

Error:
    FREESTRING(bstrKey);
    QUICK_RELEASE(piNewObject);
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::CreateItem
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject **ppiObject [out] interface pointer on newly created object
//
// Output:
//   HRESULT
//
// Notes:
//
// Used when adding a new object to the collection or when deserializing a
// collection. Creates the object, calls IPersistStreamInit::InitNew, and returns
// the object
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::CreateItem(IObject **ppiObject)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;

    *ppiObject = NULL;

    // Create the object and get its native interface (CreateObject function
    // is in rtutil.cpp).

    H_IfFailGo(CreateObject(m_idObject, m_iidObject, ppiObject));

    // If the object supports persistence then call InitNew

    hr = (*ppiObject)->QueryInterface(IID_IPersistStreamInit,
                               reinterpret_cast<void **>(&piPersistStreamInit));
    if (FAILED(hr))
    {
        if (E_NOINTERFACE == hr)
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = piPersistStreamInit->InitNew();
    }

Error:
    if (FAILED(hr))
    {
        RELEASE(*ppiObject);
    }
    QUICK_RELEASE(piPersistStreamInit);
    H_RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// FindItem
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT  Index      [in]  Index or key of object
//  long    *plIndex    [out] Index of object returned here (if found)
//  IObject **ppiObject [out] Interface pointer on object returned here (if found)
//
// Output:
//      HRESULT 
//
// Notes:
//
// Finds an object in the collection referenced by index or key.
// Index is interpreted as a one-based array index.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::FindItem
(
    VARIANT   Index,
    long     *plIndex,
    IObject **ppiObject
)
{
    HRESULT  hr = S_OK;
    long     lIndex = 0;
    BSTR     bstrKey = NULL; // Do not free with SysFreeString()

    VARIANT varLong;
    ::VariantInit(&varLong);

    // First check if Index contains a string. If it does then do
    // a key lookup otherwise attempt to convert to a long.

    if (::IsString(Index, &bstrKey))
    {
        H_IfFailGo(FindItemByKey(Index.bstrVal, plIndex,
                                 GenerateExceptionInfoOnError, ppiObject));
    }
    else if (S_OK == ::ConvertToLong(Index, &lIndex))
    {
        // Adjust to zero based and use it to directly index the array
        lIndex--;

        if ( (lIndex < 0) || (lIndex >= m_IPArray.GetSize()) )
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            EXCEPTION_CHECK_GO(hr);
        }
        *ppiObject = m_IPArray.GetAt(lIndex);
        (*ppiObject)->AddRef();
        *plIndex = lIndex;
    }
    else
    {
        // Anything else is unusable.
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// FindItemByKey
//=--------------------------------------------------------------------------=
//
// Parameters:
//  BSTR          bstrKey   [in]  Key of object
//  long         *plIndex   [out] Index returned here if object found
//  FindOptions   option    [in]  DontGenerateExceptionInfoOnError or
//                                GenerateExceptionInfoOnError. Don't option
//                                is used when testing for presence of item
//                                in collection.
//  IObject     **ppiObject [out] Interface pointer on object returned here (if found)
//
// Output:
//      HRESULT
//
// Notes:
//
// Determines the array index of an existing item by doing a linear search for
// an item that has the same key.
//
// CONSIDER: simple linear search is used because snap-in collections tend to be
// small. If performance every becomes an issue this should probably changed to
// use hash buckets.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::FindItemByKey
(
    BSTR          bstrKey,
    long         *plIndex,
    FindOptions   option,
    IObject     **ppiObject
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrItemKey = NULL;
    BOOL     fFound = FALSE;
    IObject *piObject = NULL;
    long     i = 0;
    long     cItems = m_IPArray.GetSize();

    if (NULL != bstrKey)
    {
        while ( (i < cItems) && (!fFound) )
        {
            piObject = m_IPArray.GetAt(i);
            H_IfFailGo(piObject->get_Key(&bstrItemKey));
            if (NULL != bstrItemKey)
            {
                if (::_wcsicmp(bstrKey, bstrItemKey) == 0)
                {
                    piObject->AddRef();
                    *ppiObject = piObject;
                    *plIndex = i;
                    fFound = TRUE;
                }
            }
            FREESTRING(bstrItemKey);
            i++;
        }
    }

    if (!fFound)
    {
        hr = SID_E_ELEMENT_NOT_FOUND;
        if (GenerateExceptionInfoOnError == option)
        {
            EXCEPTION_CHECK(hr);
        }
    }

Error:
    H_RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapInCollection::FindSlot
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  Index      [in]  Index specified in Add method (one based)
//      VARIANT  Key        [in]  Key specified in Add method
//      long    *plNewIndex [out] Index of new item in array (zero based)
//      BSTR    *pbstrKey   [out] Key of new item
//      IObject *piObject   [in]  Bogus pointer for template arg
//
// Output:
//      HRESULT
//
// Notes:
//
// Determines the array index and key of a new item being added to the
// collection.
//
// If Index is unspecified then the new index will be at the end of the
// collection.
// If Index is specified then:
// If Index is an object then it is an invalid argument.
// If Index cannot be converted to an integer then it is an invalid argument.
// If Index is not within the current bounds of the array then it is invalid.
// If Index is within bounds then then the operation is treated as an insert
// and Index.lVal will be returned in *plNewIndex.
// 
// If Key is unspecified then it will be set to a NULL BSTR.
// If Key is specified then:
// If Key is an object then it is an invalid argument.
// If Key cannot be converted to a string then it is invalid.
// If Key already exists in the collection then it is invalid.
//

template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::FindSlot
(
    VARIANT  Index,
    VARIANT  Key,
    long    *plNewIndex,
    BSTR    *pbstrKey,
    IObject *piObject
)
{
    HRESULT   hr = S_OK;
    long      lIndex = 0;
    long      cItems = m_IPArray.GetSize();
    VARIANT   varKey;

    ::VariantInit(&varKey);

    // Attempt to convert key to string

    if (ISPRESENT(Key))
    {
        hr = ::VariantChangeType(&varKey, &Key, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        if (SUCCEEDED(FindItemByKey(varKey.bstrVal, &lIndex,
                                    DontGenerateExceptionInfoOnError,
                                    &piObject)))
        {
            piObject->Release();
            hr = SID_E_KEY_NOT_UNIQUE;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Process Index as described above

    if (!ISPRESENT(Index))
    {
        lIndex = cItems; // append to end
    }
    else
    {
        if (S_OK != ConvertToLong(Index, &lIndex))
        {
            hr = SID_E_INVALIDARG;
            goto Error;
        }

        lIndex--; // convert from 1-based to 0-based for our internal array

        if (0 == cItems)
        {
            if (lIndex != 0)
            {
                hr = SID_E_INDEX_OUT_OF_RANGE;
                goto Error;
            }
        }
        else if ( (lIndex < 0) || (lIndex > cItems) )
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            goto Error;
        }
        EXCEPTION_CHECK_GO(hr);
    }

    // If no key was specified then return NULL bstr for key

    if (!ISPRESENT(Key))
    {
        varKey.vt = VT_BSTR;
        varKey.bstrVal = NULL;
    }

Error:
    if (FAILED(hr))
    {
        ::VariantClear(&varKey);
    }
    else
    {
        *plNewIndex = lIndex;
        *pbstrKey = varKey.bstrVal;
    }
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::SyncWithMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//      HRESULT
//
// Notes:
// Used in a keys-only collection when caller does its first get_Item. Replaces
// all of the key-only objects in the collection with the corresponding object
// from the master collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::SyncWithMaster()
{
    HRESULT   hr = S_OK;
#if defined(MASTER_COLLECTION)
    IObject  *piMasterItem = NULL;
    long      cItems = m_IPArray.GetSize();
    long      i = 0;

    while(i < cItems)
    {
        // Get the item from the master collection. This will come back
        // AddRef()ed
        
        H_IfFailGo(GetFromMaster(m_IPArray.GetAt(i), &piMasterItem));

        // Release the item in our collection. No need to dec its usage count
        // as it will be destroyed at this point.
        
        H_IfFailRet(RemoveObjectHost(m_IPArray.GetAt(i)));
        m_IPArray.GetAt(i)->Release();

        // Put the master item in its place.
        
        m_IPArray.SetAt(i, piMasterItem);

        // Increment the master item's usage count as it is now part of this
        // collection as wekk

        H_IfFailGo(IncrementObjectUsageCount(piMasterItem));

        piMasterItem = NULL;
        i++;
    }

    m_fSyncedWithMaster = TRUE;

Error:
    QUICK_RELEASE(piMasterItem);
#endif
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::DecrementObjectUsageCount
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IObject *piObject [in] Object for which usage count should be decremented
//
// Output:
//      HRESULT
//
// Notes:
// 
// Calls IObjectModel->DecrementUsageCount on the object. Usage count indicates
// membership in a collection and is used by the design time to keep track
// of result views used by multiple nodes.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::DecrementObjectUsageCount
(
    IObject *piObject
)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    H_IfFailGo(piObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));
    H_IfFailGo(piObjectModel->DecrementUsageCount());

Error:
    QUICK_RELEASE(piObjectModel);
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::IncrementObjectUsageCount
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IObject *piObject [in] Object for which usage count should be incremented
//
// Output:
//      HRESULT
//
// Notes:
// 
// Calls IObjectModel->IncrementUsageCount on the object. Usage count indicates
// membership in a collection and is used by the design time to keep track
// of result views used by multiple nodes.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::IncrementObjectUsageCount
(
    IObject *piObject
)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    H_IfFailGo(piObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));
    H_IfFailGo(piObjectModel->IncrementUsageCount());

Error:
    QUICK_RELEASE(piObjectModel);
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapInCollection::OnSetHost                      [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//      HRESULT
//
// Notes:
// 
// When a caller calls IObjectModel::SetHost, the CSnapInAutomationObject
// implementation of that method calls the virtual function OnSetHost.
// This class overrides it and calls IObjectModel::SetHost on every object
// in the collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::OnSetHost()
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cItems = m_IPArray.GetSize();

    while (i < cItems)
    {
        H_IfFailRet(SetObjectHost(m_IPArray.GetAt(i)));
        i++;
    }
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                        Class CEnumObjects
//
// This class implements IEnumVARIANT for all collections. IEnumVARIANT is
// used when VB code does For...Each on a collection. (See
// CSnapInCollection::get__NewEnum above).
//
// The class maintains a back pointer to the CSnapInCollection class and
// enumerates it based on a simple current index member variable. If the
// collection changes during the enumeration then the For...Each will not
// work correctly.
//
// This class could not be derived from the framework's CUnknown object because
// compiler won't allow passing this pointer to base member constructor
// (CUnknown's ctor) from a  template class' ctor.
// This error occurrs even if warning 4355 is disabled.
//=--------------------------------------------------------------------------=


template <class IObject, class CoClass, class ICollection>
class CEnumObjects : public CtlNewDelete,
                     public IEnumVARIANT,
                     public ISupportErrorInfo
  
{
       public:
           CEnumObjects(CSnapInCollection<IObject, CoClass, ICollection> *pCollection);
           ~CEnumObjects();

       private:

        // IUnknown
           STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
           STDMETHOD_(ULONG, AddRef)(void);
           STDMETHOD_(ULONG, Release)(void);

        // ISupportErrorInfo
           STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

        // IEnumVARIANT
           STDMETHOD(Next)(unsigned long   celt,
                           VARIANT        *rgvar,
                           unsigned long  *pceltFetched);        
           STDMETHOD(Skip)(unsigned long celt);        
           STDMETHOD(Reset)();        
           STDMETHOD(Clone)(IEnumVARIANT **ppenum);

           void InitMemberVariables();

           long  m_iCurrent;    // Current element for Next method
           ULONG m_cRefs;       // ref count on this object

           // Back pointer to collection class

           CSnapInCollection<IObject, CoClass, ICollection> *m_pCollection;
};


//=--------------------------------------------------------------------------=
// CEnumObjects constructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//   CSnapInCollection<IObject, CoClass, ICollection> *pCollection
//
//   [in] pointer to owning collection class. Will be stored and used while enumerator
//   is alive. The enumerator does not AddRef the collection.
//
// Output:
//   None
//
// Notes:
//
// Sets enumerator ref count to 1
//
template <class IObject, class CoClass, class ICollection>
CEnumObjects<IObject, CoClass, ICollection>::CEnumObjects
(
    CSnapInCollection<IObject, CoClass, ICollection> *pCollection
)
{
    InitMemberVariables();
    m_pCollection = pCollection;
    m_cRefs = 1;
}



//=--------------------------------------------------------------------------=
// CEnumObjects destructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//
// Output:
//   None
//
// Notes:
//
template <class IObject, class CoClass, class ICollection>
CEnumObjects<IObject, CoClass, ICollection>::~CEnumObjects()
{
    InitMemberVariables();
}


//=--------------------------------------------------------------------------=
// CEnumObjects::InitMemberVariables
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//
// Output:
//   None
//
// Notes:
//
template <class IObject, class CoClass, class ICollection>
void CEnumObjects<IObject, CoClass, ICollection>::InitMemberVariables()
{
    m_iCurrent = 0;
    m_cRefs = 0;
    m_pCollection = NULL;
}

//=--------------------------------------------------------------------------=
//                        IUnknown Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CEnumObjects::QueryInterface                                    [IUnknnown]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  REFIID   riid       [in]  IID of interface requested
//  void   **ppvObjOut  [out] interface pointer returned here
//
// Output:
//   None
//
// Notes:
// Interfaces supported:
//      IID_IUnknown
//      IID_IEnumVARIANT
//      IID_ISupportErrorInfo
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::QueryInterface
(
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr = S_OK;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObjOut = static_cast<IUnknown *>(static_cast<IEnumVARIANT *>(this));
    }
    else if (DO_GUIDS_MATCH(riid, IID_IEnumVARIANT))
    {
        AddRef();
        *ppvObjOut = static_cast<IEnumVARIANT *>(this);
    }
    else if (DO_GUIDS_MATCH(riid, IID_ISupportErrorInfo))
    {
        AddRef();
        *ppvObjOut = static_cast<ISupportErrorInfo *>(this);
    }
    else
    {
        *ppvObjOut = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::AddRef                                            [IUnknnown]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP_(ULONG) CEnumObjects<IObject, CoClass, ICollection>::AddRef()
{
    m_cRefs++;
    return m_cRefs;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Release                                           [IUnknnown]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
//  Deletes object when ref count reaches zero
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP_(ULONG) CEnumObjects<IObject, CoClass, ICollection>::Release()
{
    if (m_cRefs > 0)
    {
        m_cRefs--;
        if (0 == m_cRefs)
        {
            delete this;
            return 0;
        }
        else
        {
            return m_cRefs;
        }
    }
    else
    {
        H_ASSERT(FALSE, "CEnumObjects::Release() past zero refs");
        return m_cRefs;
    }
}

//=--------------------------------------------------------------------------=
//                      ISupportErrorInfo Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CEnumObjects::InterfaceSupportsErrorInfo                 [ISupportErrorInfo]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  REFIID riid [in] Caller requests to know if this inteface supports rich
//                   error info
//
// Output:
//   None
//
// Notes:
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    return (riid == IID_IEnumVARIANT) ? S_OK : S_FALSE;
}


//=--------------------------------------------------------------------------=
//                        IEnumVARIANT Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CEnumObjects::Next                                           [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long   celt         [in] number of elements to fetch
//  VARIANT        *rgvar        [in, out] array in which to place elements
//  unsigned long  *pceltFetched [out] no. of elements placed in rgvar returned here
//
// Output:
//   None
//
// Notes:
// Returns the next celt IDispatch pointers of objects in the collection
// starting at the current position. Current position starts at 0 and continues
// until end of collection. Current position can be returned to zero by calling
// Reset (see below)
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Next
(
    unsigned long   celt,
    VARIANT        *rgvar,
    unsigned long  *pceltFetched
)
{
    HRESULT       hr = S_OK;
    unsigned long i = 0;
    
    // Initialize result array.

    for (i = 0; i < celt; i++)
    {
        ::VariantInit(&rgvar[i]);
    }

    // Copy in IDispatch pointers

    for (i = 0; i < celt; i++) 
    {
        H_IfFalseGo(m_iCurrent < m_pCollection->GetCount(), S_FALSE);

        H_IfFailGo(m_pCollection->GetItemByIndex(m_iCurrent)->QueryInterface(
                                 IID_IDispatch,
                                reinterpret_cast<void **>(&rgvar[i].pdispVal)));

        rgvar[i].vt = VT_DISPATCH;
        m_iCurrent++;
    }

Error:

    if (FAILED(hr))
    {
        for (i = 0; i < celt; i++)
        {
            (void)::VariantClear(&rgvar[i]);
        }
    }

    if (pceltFetched != NULL)
    {
        if (FAILED(hr))
        {
            *pceltFetched = 0;
        }
        else
        {
            *pceltFetched = i;
        }
    }

    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Skip                                           [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long   celt         [in] number of elements to skip
//
// Output:
//   None
//
// Notes:
// Advances the current position to be used in a Next method call by celt. If
// overflows past end of collection, wraps around to the start.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Skip
(
    unsigned long celt
)
{
    m_iCurrent += celt;
    m_iCurrent %= m_pCollection->GetCount();
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Reset                                          [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
// Resets the current position to be used in a Next method call to zero.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Reset()
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Clone                                          [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IEnumVARIANT **ppenum [out] newly cloned enumerator
//
// Output:
//   None
//
// Notes:
// Creates a new CEnumObjects and passes it the same collection. Sets the
// new CEnumObjects' current position to the same as this one's.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Clone(IEnumVARIANT **ppenum)
{
    HRESULT hr = S_OK;

    CEnumObjects<IObject, CoClass, ICollection> *pClone =
                           New CEnumObjects<IObject, CoClass, ICollection>(m_pCollection);

    if (NULL == pClone)
    {
        *ppenum = NULL;
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    pClone->m_iCurrent = m_iCurrent;
    *ppenum = static_cast<IEnumVARIANT *>(pClone);

Error:
    H_RRETURN(hr);
}

#endif // _SNAPINCOLLECTION_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\common.h ===
//=--------------------------------------------------------------------------------------
// common.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Common header files for mssnapr that cannot go into the pch because they
// have symbols that are defined differently in different source files (e.g.
// INITGUIDS and INITOBJECTS.
//=-------------------------------------------------------------------------------------=

#include <ad98.h>
#include <autoobj.h>
#include "errors.h"
#include "error.h"
#include "persobj.h"
#include "siautobj.h"
#include "rtutil.h"
#include "..\..\mssnapd\mssnapd\guids.h" // for design time property page CLSIDs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colsets.h ===
//=--------------------------------------------------------------------------=
// colsets.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSettings class definition - ColumnSettings collection implementation
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNSETTINGS_DEFINED_
#define _COLUMNSETTINGS_DEFINED_

#include "collect.h"
#include "view.h"

class CColumnSettings : public CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>
{
    protected:
        CColumnSettings(IUnknown *punkOuter);
        ~CColumnSettings();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IColumnSettings
        BSTR_PROPERTY_RW(CColumnSettings, ColumnSetID, DISPID_COLUMNSETTINGS_COLUMN_SET_ID);
        STDMETHOD(Add)(VARIANT           Index,
                       VARIANT           Key, 
                       VARIANT           Width,
                       VARIANT           Hidden,
                       VARIANT           Position,
                       ColumnSetting **ppColumnSetting);
        STDMETHOD(Persist)();

    // Public utility methods

    public:

        void SetView(CView *pView) { m_pView = pView; }
        CView *GetView() { return m_pView; }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CView *m_pView; // back pointer to owning view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ColumnSettings,           // name
                                &CLSID_ColumnSettings,    // clsid
                                "ColumnSettings",         // objname
                                "ColumnSettings",         // lblname
                                &CColumnSettings::Create, // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IColumnSettings,     // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _COLUMNSETTINGS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converb.cpp ===
//=--------------------------------------------------------------------------=
// converb.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerb class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "converb.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCConsoleVerb::CMMCConsoleVerb(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCCONSOLEVERB,
                            static_cast<IMMCConsoleVerb *>(this),
                            static_cast<CMMCConsoleVerb *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCConsoleVerb::~CMMCConsoleVerb()
{
    FREESTRING(m_bstrKey);
    InitMemberVariables();
}

void CMMCConsoleVerb::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_Verb = siNone;
    m_pView = NULL;
}

IUnknown *CMMCConsoleVerb::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMMCConsoleVerb = NULL;

    CMMCConsoleVerb *pMMCConsoleVerb = New CMMCConsoleVerb(punkOuter);

    IfFalseGo(NULL != pMMCConsoleVerb, SID_E_OUTOFMEMORY);
    punkMMCConsoleVerb = pMMCConsoleVerb->PrivateUnknown();

Error:
    return punkMMCConsoleVerb;
}



//=--------------------------------------------------------------------------=
// CMMCConsoleVerb::GetIConsoleVerb
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IConsoleVerb *ppiConsoleVerb  [out] MMC's IConsoleVerb for the owning view
//                                      not AddRef()ed
//    
//
// Output:
//      HRESULT
//
// Notes:
//
// Gets a non-AddRef()ed IConsoleVerb from the current view.
//

HRESULT CMMCConsoleVerb::GetIConsoleVerb(IConsoleVerb **ppiConsoleVerb)
{
    HRESULT hr = S_OK;

    IfFalseGo(NULL != m_pView, SID_E_DETACHED_OBJECT);
    *ppiConsoleVerb = m_pView->GetIConsoleVerb();
    IfFalseGo(NULL != *ppiConsoleVerb, SID_E_INTERNAL);

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


HRESULT CMMCConsoleVerb::SetVerbState
(
    MMC_BUTTON_STATE StateType,
    BOOL             fNewState
)
{
    HRESULT       hr = S_OK;
    IConsoleVerb *piConsoleVerb = NULL; // Not AddRef()ed

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));

    hr = piConsoleVerb->SetVerbState(static_cast<MMC_CONSOLE_VERB>(m_Verb),
                                     StateType, fNewState);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


HRESULT CMMCConsoleVerb::GetVerbState
(
    MMC_BUTTON_STATE  StateType,
    VARIANT_BOOL     *pfvarCurrentState
)
{
    HRESULT       hr = S_OK;
    BOOL          fCurrentState = FALSE;
    IConsoleVerb *piConsoleVerb = NULL; // Not AddRef()ed

    *pfvarCurrentState = VARIANT_FALSE;

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));

    hr = piConsoleVerb->GetVerbState(static_cast<MMC_CONSOLE_VERB>(m_Verb),
                                     StateType, &fCurrentState);
    EXCEPTION_CHECK_GO(hr);

    *pfvarCurrentState = VARIANTBOOL_TO_BOOL(fCurrentState);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//
//                      IMMCConsoleVerb Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCConsoleVerb::put_Enabled(VARIANT_BOOL fvarEnabled)
{
    RRETURN(SetVerbState(ENABLED, VARIANTBOOL_TO_BOOL(fvarEnabled)));
}

STDMETHODIMP CMMCConsoleVerb::get_Enabled(VARIANT_BOOL *pfvarEnabled)
{
    RRETURN(GetVerbState(ENABLED, pfvarEnabled));
}


STDMETHODIMP CMMCConsoleVerb::put_Checked(VARIANT_BOOL fvarChecked)
{
    RRETURN(SetVerbState(CHECKED, VARIANTBOOL_TO_BOOL(fvarChecked)));
}


STDMETHODIMP CMMCConsoleVerb::get_Checked(VARIANT_BOOL *pfvarChecked)
{
    RRETURN(GetVerbState(CHECKED, pfvarChecked));
}


STDMETHODIMP CMMCConsoleVerb::put_Hidden(VARIANT_BOOL fvarHidden)
{
    RRETURN(SetVerbState(HIDDEN, VARIANTBOOL_TO_BOOL(fvarHidden)));
}


STDMETHODIMP CMMCConsoleVerb::get_Hidden(VARIANT_BOOL *pfvarHidden)
{
    RRETURN(GetVerbState(HIDDEN, pfvarHidden));
}


STDMETHODIMP CMMCConsoleVerb::put_Indeterminate(VARIANT_BOOL fvarIndeterminate)
{
    RRETURN(SetVerbState(INDETERMINATE, VARIANTBOOL_TO_BOOL(fvarIndeterminate)));
}


STDMETHODIMP CMMCConsoleVerb::get_Indeterminate(VARIANT_BOOL *pfvarIndeterminate)
{
    RRETURN(GetVerbState(INDETERMINATE, pfvarIndeterminate));
}


STDMETHODIMP CMMCConsoleVerb::put_ButtonPressed(VARIANT_BOOL fvarButtonPressed)
{
    RRETURN(SetVerbState(BUTTONPRESSED, VARIANTBOOL_TO_BOOL(fvarButtonPressed)));
}


STDMETHODIMP CMMCConsoleVerb::get_ButtonPressed(VARIANT_BOOL *pfvarButtonPressed)
{
    RRETURN(GetVerbState(BUTTONPRESSED, pfvarButtonPressed));
}


STDMETHODIMP CMMCConsoleVerb::put_Default(VARIANT_BOOL fvarDefault)
{
    HRESULT           hr = S_OK;
    MMC_CONSOLE_VERB  Verb = static_cast<MMC_CONSOLE_VERB>(m_Verb);
    IConsoleVerb     *piConsoleVerb = NULL; // Not AddRef()ed

    if (VARIANT_FALSE == fvarDefault)
    {
        Verb = MMC_VERB_NONE;
    }

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));
    
    hr = piConsoleVerb->SetDefaultVerb(Verb);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCConsoleVerb::get_Default(VARIANT_BOOL *pfvarDefault)
{
    HRESULT           hr = S_OK;
    MMC_CONSOLE_VERB  Verb = MMC_VERB_NONE;
    IConsoleVerb     *piConsoleVerb = NULL; // Not AddRef()ed

    *pfvarDefault = VARIANT_FALSE;

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));

    hr = piConsoleVerb->GetDefaultVerb(&Verb);
    EXCEPTION_CHECK_GO(hr);

    if (Verb == static_cast<MMC_CONSOLE_VERB>(m_Verb))
    {
        *pfvarDefault = VARIANT_TRUE;
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCConsoleVerb::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCConsoleVerb == riid)
    {
        *ppvObjOut = static_cast<IMMCConsoleVerb *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converbs.cpp ===
//=--------------------------------------------------------------------------=
// converbs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerbs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "converbs.h"
#include "converb.h"

// for ASSERT and FAIL
//
SZTHISFILE



struct
{
    SnapInConsoleVerbConstants  Verb;
    WCHAR                      *pwszKey;

} static const g_Verbs[] =
{
    { siNone,       L"siNone"       },
    { siOpen,       L"siOpen"       },
    { siCopy,       L"siCopy"       },
    { siPaste,      L"siPaste"      },
    { siDelete,     L"siDelete"     },
    { siProperties, L"siProperties" },
    { siRename,     L"siRename"     },
    { siRefresh,    L"siRefresh"    },
    { siPrint,      L"siPrint"      },
    { siCut,        L"siCut"        }
};

static const size_t g_cVerbs = sizeof(g_Verbs) / sizeof(g_Verbs[0]);





#pragma warning(disable:4355)  // using 'this' in constructor

//=--------------------------------------------------------------------------=
// CMMCConsoleVerbs::CMMCConsoleVerbs
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IUnknown *punkOuter [in] controlling unknown
//
// Output:
//
// Notes:
//
// Constructor.
//
// Passes CLSID_NULL to the CSnapInCollection constructor because the
// contained object (MMCConsoleVerb) is not co-createable. CSnapInCollection
// only uses it for persistence and Add(). This collection does not use those
// features.
//

CMMCConsoleVerbs::CMMCConsoleVerbs(IUnknown *punkOuter) :
    CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>(punkOuter,
                                           OBJECT_TYPE_MMCCONSOLEVERBS,
                                           static_cast<IMMCConsoleVerbs *>(this),
                                           static_cast<CMMCConsoleVerbs *>(this),
                                           CLSID_NULL,
                                           OBJECT_TYPE_MMCCONSOLEVERB,
                                           IID_IMMCConsoleVerb,
                                           NULL) // no persistence
{
    m_pView = NULL;
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCConsoleVerbs::~CMMCConsoleVerbs()
{
    m_pView = NULL;
}

IUnknown *CMMCConsoleVerbs::Create(IUnknown * punkOuter)
{
    HRESULT           hr = S_OK;
    IUnknown         *punkMMCConsoleVerb = NULL;
    IMMCConsoleVerb  *piMMCConsoleVerb = NULL;
    CMMCConsoleVerbs *pMMCConsoleVerbs = New CMMCConsoleVerbs(punkOuter);
    size_t            i = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Was the MMCConsoleVerb collection object created?

    if (NULL == pMMCConsoleVerbs)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }


    // Add an item to the collection for each of the verbs.

    varIndex.vt = VT_I4;

    for (i = 0; i < g_cVerbs; i++)
    {
        punkMMCConsoleVerb = CMMCConsoleVerb::Create(NULL);
        if (NULL == punkMMCConsoleVerb)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(punkMMCConsoleVerb->QueryInterface(IID_IMMCConsoleVerb,
                                  reinterpret_cast<void **>(&piMMCConsoleVerb)));

        IfFailGo(piMMCConsoleVerb->put_Verb(g_Verbs[i].Verb));

        varIndex.lVal = static_cast<long>(i) + 1L; // 1 based collection

        // Use the text version of the enum for the key

        varKey.bstrVal = ::SysAllocString(g_Verbs[i].pwszKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        varKey.vt = VT_BSTR;

        IfFailGo(pMMCConsoleVerbs->AddExisting(varIndex, varKey, piMMCConsoleVerb));

        RELEASE(punkMMCConsoleVerb);
        RELEASE(piMMCConsoleVerb);

        hr = ::VariantClear(&varKey);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }


Error:
    QUICK_RELEASE(punkMMCConsoleVerb);
    QUICK_RELEASE(piMMCConsoleVerb);
    (void)::VariantClear(&varKey);
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCConsoleVerbs)
        {
            delete pMMCConsoleVerbs;
        }
        return NULL;
    }
    else
    {
        return pMMCConsoleVerbs->PrivateUnknown();
    }
}


HRESULT CMMCConsoleVerbs::SetView(CView *pView)
{
    HRESULT          hr = S_OK;
    long             cVerbs = GetCount();
    long             i = 0;
    CMMCConsoleVerb *pMMCConsoleVerb = NULL;

    m_pView = pView;

    for (i = 0; i < cVerbs; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pMMCConsoleVerb));
        pMMCConsoleVerb->SetView(pView);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         IMMCConsoleVerbs Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCConsoleVerbs::get_Item
(
    VARIANT          Index,
    MMCConsoleVerb **ppMMCConsoleVerb
)
{
    HRESULT          hr = S_OK;
    size_t           i = 0;
    long             lIndex = 0;
    BOOL             fFound = FALSE;;
    IMMCConsoleVerb *piMMCConsoleVerb = NULL; // Not AddRef()ed

    // If the index can be converted to a long then check whether it contains a
    // SnapInConsoleVerbConstants enum.

    hr = ::ConvertToLong(Index, &lIndex);
    if (SUCCEEDED(hr))
    {
        for (i = 0, fFound = FALSE; (i < g_cVerbs) && (!fFound); i++)
        {
            if (g_Verbs[i].Verb == static_cast<SnapInConsoleVerbConstants>(lIndex))
            {
                // Found it. Return to caller.

                piMMCConsoleVerb = GetItemByIndex(i);
                piMMCConsoleVerb->AddRef();
                fFound = TRUE;
            }
        }
        IfFalseGo(!fFound, S_OK);
    }

    // Index is something else, this is a normal get_Item by ordinal index
    // or key

    hr = CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>::get_Item(Index, &piMMCConsoleVerb);
    EXCEPTION_CHECK_GO(hr);

Error:
    if (NULL != piMMCConsoleVerb)
    {
        *ppMMCConsoleVerb = reinterpret_cast<MMCConsoleVerb *>(piMMCConsoleVerb);
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCConsoleVerbs::get_DefaultVerb
(
    SnapInConsoleVerbConstants *pVerb
)
{
    HRESULT           hr = S_OK;
    MMC_CONSOLE_VERB  Verb = MMC_VERB_NONE;
    IConsoleVerb     *piConsoleVerb = NULL; // Not AddRef()ed
    

    IfFalseGo(NULL != m_pView, SID_E_DETACHED_OBJECT);
    piConsoleVerb = m_pView->GetIConsoleVerb();
    IfFalseGo(NULL != piConsoleVerb, SID_E_INTERNAL);

    hr = piConsoleVerb->GetDefaultVerb(&Verb);

    *pVerb = static_cast<SnapInConsoleVerbConstants>(Verb);

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCConsoleVerbs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCConsoleVerbs == riid)
    {
        *ppvObjOut = static_cast<IMMCConsoleVerbs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converb.h ===
//=--------------------------------------------------------------------------=
// converb.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerb class definition - implements MMCConsoleVerb object
//
//=--------------------------------------------------------------------------=

#ifndef _CONVERB_DEFINED_
#define _CONVERB_DEFINED_

#include "view.h"

class CMMCConsoleVerb : public CSnapInAutomationObject,
                        public IMMCConsoleVerb
{
    private:
        CMMCConsoleVerb(IUnknown *punkOuter);
        ~CMMCConsoleVerb();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCConsoleVerb
        SIMPLE_PROPERTY_RW(CMMCConsoleVerb, Index, long, DISPID_CONSOLEVERB_INDEX);

        BSTR_PROPERTY_RW(CMMCConsoleVerb, Key, DISPID_CONSOLEVERB_KEY);

        SIMPLE_PROPERTY_RW(CMMCConsoleVerb, Verb, SnapInConsoleVerbConstants, DISPID_CONSOLEVERB_VERB);

        STDMETHOD(put_Enabled)(VARIANT_BOOL fvarEnabled);
        STDMETHOD(get_Enabled)(VARIANT_BOOL *pfvarEnabled);

        STDMETHOD(put_Checked)(VARIANT_BOOL fvarChecked);
        STDMETHOD(get_Checked)(VARIANT_BOOL *pfvarChecked);

        STDMETHOD(put_Hidden)(VARIANT_BOOL fvarHidden);
        STDMETHOD(get_Hidden)(VARIANT_BOOL *pfvarHidden);

        STDMETHOD(put_Indeterminate)(VARIANT_BOOL fvarIndeterminate);
        STDMETHOD(get_Indeterminate)(VARIANT_BOOL *pfvarIndeterminate);

        STDMETHOD(put_ButtonPressed)(VARIANT_BOOL fvarButtonPressed);
        STDMETHOD(get_ButtonPressed)(VARIANT_BOOL *pfvarButtonPressed);

        STDMETHOD(put_Default)(VARIANT_BOOL fvarDefault);
        STDMETHOD(get_Default)(VARIANT_BOOL *pfvarDefault);

    // Public utility methods
    public:
        void SetView(CView *pView) { m_pView = pView; }
        CView *GetView() { return m_pView; };

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        HRESULT SetVerbState(MMC_BUTTON_STATE StateType,
                             BOOL             fNewState);

        HRESULT GetVerbState(MMC_BUTTON_STATE StateType,
                             VARIANT_BOOL     *pfvarCurrentState);

        HRESULT GetIConsoleVerb(IConsoleVerb **ppiConsoleVerb);

        CView *m_pView; //owning view, needed for access to MMC's IConsoleVerb
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCConsoleVerb,             // name
                                NULL,                       // clsid
                                NULL,                       // objname
                                NULL,                       // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCConsoleVerb,       // dispatch IID
                                NULL,                       // no event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _CONVERB_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctlbar.h ===
//=--------------------------------------------------------------------------=
// ctlbar.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CControlbar class definition
//
//=--------------------------------------------------------------------------=

#ifndef _CTLBAR_DEFINED_
#define _CTLBAR_DEFINED_

#include "toolbars.h"
#include "button.h"
#include "mbutton.h"

class CMMCButton;
class CMMCButtonMenu;

//=--------------------------------------------------------------------------=
//
// class CControlbar
//
// Used by both CSnapIn (IComponentData) and CView (IComponent) to implement
// IExtendControlbar
//
//=--------------------------------------------------------------------------=

class CControlbar : public CSnapInAutomationObject,
                    public IMMCControlbar
{
    protected:
        CControlbar(IUnknown *punkOuter);
        ~CControlbar();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT SetControlbar(IControlbar *piControlbar);
        HRESULT OnControlbarSelect(IDataObject *piDataObject,
                                   BOOL fScopeItem, BOOL fSelected);
        HRESULT OnButtonClick(IDataObject *piDataObject, int idButton);
        HRESULT OnMenuButtonClick(IDataObject *piDataObject,
                                  MENUBUTTONDATA *pMENUBUTTONDATA);
        HRESULT FireMenuButtonDropDown(int              idCommand,
                                       IMMCClipboard   *piMMCClipboard,
                                       CMMCButton     **ppMMCButton);
        HRESULT DisplayPopupMenu(CMMCButton *pMMCButton,
                                 int x, int y,
                                 CMMCButtonMenu **ppMMCButtonMenuClicked);

        HRESULT MenuButtonClick(IDataObject   *piDataObject,
                                int             idCommand,
                                POPUP_MENUDEF **ppPopupMenuDef);
        HRESULT PopupMenuClick(IDataObject *piDataObject,
                               UINT         uIDItem,
                               IUnknown    *punkParam);

        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        void SetView(CView *pView) { m_pView = pView; }

        static HRESULT GetControl(CSnapIn      *pSnapin,
                                  IMMCToolbar  *piMMCToolbar,
                                  IUnknown    **ppunkControl);
        static HRESULT GetToolbar(CSnapIn      *pSnapin,
                                  IMMCToolbar  *piMMCToolbar,
                                  IToolbar    **ppiToolbar);
        static HRESULT GetMenuButton(CSnapIn      *pSnapin,
                                     IMMCToolbar  *piMMCToolbar,
                                     IMenuButton **ppiMenuButton);

    // CSnapInAutomationObject overrides
    protected:
        HRESULT OnSetHost();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IMMCControlbar
    private:
        STDMETHOD(Attach)(IDispatch *Control);
        STDMETHOD(Detach)(IDispatch *Control);

        void InitMemberVariables();

        HRESULT GetControlIndex(IMMCToolbar *piMMCToolbar, long *plIndex);

        // We keep a collection of all MMCToolbar objects that have been
        // attached to this controlbar

        CMMCToolbars            *m_pToolbars;

        // An MMCToolbar may be used in more than one view simultaneously.
        // Consequently it can't hold onto the MMC control IUnknown. This
        // array parallels the collection and holds an IUnknown per MMCToolbar.
        // When an MMCToolbar needs to call a method on MMC's IToolbar or
        // IMenuButton it gets the current View and gets the View's CControlbar.
        // It then asks the CControlbar for the IUnknown of the MMC control
        // which it represents in that View. (See GetControl()).
        
        IUnknown              **m_ppunkControls;  // array of IUnknowns
        long                    m_cControls;      // count of IUnknowns in array

        CSnapIn                 *m_pSnapIn;       // Back pointer to owning CSnapIn
        CView                   *m_pView;         // Back pointer to owning CView
        IControlbar             *m_piControlbar;  // MMC's IControlbar interface
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(Controlbar,             // name
                                NULL,                   // clsid
                                NULL,                   // objname
                                NULL,                   // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCControlbar,    // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif _CTLBAR_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converbs.h ===
//=--------------------------------------------------------------------------=
// converbs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerbs class definition - implements MMCConsoleVerbs collection
//
//=--------------------------------------------------------------------------=

#ifndef _CONVERBS_DEFINED_
#define _CONVERBS_DEFINED_

#include "collect.h"
#include "view.h"

class CView;

class CMMCConsoleVerbs : public CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>
{
    protected:
        CMMCConsoleVerbs(IUnknown *punkOuter);
        ~CMMCConsoleVerbs();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCConsoleVerbs
        STDMETHOD(get_Item)(VARIANT Index, MMCConsoleVerb **ppMMCConsoleVerb);
        STDMETHOD(get_DefaultVerb)(SnapInConsoleVerbConstants *pVerb);

    // Public utility methods
    public:
        HRESULT SetView(CView *pView);
        CView *GetView() { return m_pView; };

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

        CView *m_pView; //owning view, needed for access to MMC's IConsoleVerb
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCConsoleVerbs,            // name
                                NULL,                       // clsid
                                NULL,                       // objname
                                NULL,                       // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCConsoleVerbs,      // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _CONVERBS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtmenu.cpp ===
//=--------------------------------------------------------------------------=
// ctxtmenu.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CContextMenu class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ctxtmenu.h"
#include "menu.h"
#include "spanitem.h"
#include "lvdefs.h"
#include "lvdef.h"
#include "ocxvdefs.h"
#include "ocxvdef.h"
#include "urlvdefs.h"
#include "urlvdef.h"
#include "tpdvdefs.h"
#include "tpdvdef.h"



// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CContextMenu::CContextMenu(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                            OBJECT_TYPE_CONTEXTMENU,
                                            static_cast<IContextMenu *>(this),
                                            static_cast<CContextMenu *>(this),
                                            0,    // no property pages
                                            NULL, // no property pages
                                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CContextMenu::Create(IUnknown *punkOuter)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkMMCMenus = CMMCMenus::Create(NULL);
    CContextMenu *pContextMenu = New CContextMenu(punkOuter);

    if ( (NULL == pContextMenu) || (NULL == punkMMCMenus) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCMenus,
                                                   &pContextMenu->m_pMenus));

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pContextMenu)
        {
            delete pContextMenu;
        }
        return NULL;
    }
    else
    {
        return pContextMenu->PrivateUnknown();
    }
}

CContextMenu::~CContextMenu()
{
    if (NULL != m_pMenus)
    {
        m_pMenus->Release();
    }
    RELEASE(m_piContextMenuCallback);
    InitMemberVariables();
}

void CContextMenu::InitMemberVariables()
{
    m_pMenus = NULL;
    m_piContextMenuCallback = NULL;
    m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_TOP;
    m_pView = NULL;
    m_pSnapIn = NULL;
}

//=--------------------------------------------------------------------------=
// CContextMenu::AddMenuToMMC
//=--------------------------------------------------------------------------=
//
// Parameters:
//      CMMCMenu *pMMCMenu       [in] menu to be added to MMC
//      long     lInsertionPoint [in] insertion point ID for MMC
//
// Output:
//      HRESULT
//
// Notes:
//
//
// Adds each of the MMCMenu's children to the MMC menu at the
// specified insertion point. If a child has children of its own then it
// represents a submenu. This function is called recursively to add the
// submenu.
//    
// CContextMenu maintains a collection of MMCMenu objects that has a member
// for each menu item added to MMC's context menu. This collection is
// cleaned out in our IExtendContextMenu::AddMenuItems() implementation
// (see CContextMenu::AddMenuItems()). The command ID of a menu item added to
// MMC is the index into the collection. It would have been preferable
// to use a pointer the MMCMenu object as the command ID but MMC only
// allows 16 bit command IDs.
//
// When an item is selected we used the command ID to index the
// collection and use the corresponding MMCMenu object to fire the
// event. (See our IExtendContextMenu::Command implementation in
// CContextMenu::Command()).

HRESULT CContextMenu::AddMenuToMMC(CMMCMenu *pMMCMenu, long lInsertionPoint)
{
    HRESULT          hr = S_OK;
    IMMCMenus       *piMenuItems = NULL;
    CMMCMenus       *pMMCMenuItems = NULL;
    CMMCMenu        *pMMCMenuItem = NULL;
    long             cMenuItems = 0;
    long             i = 0;
    long             lIndexCmdID = 0;
    BOOL             fSkip = FALSE;
    BOOL             fHasChildren = FALSE;

    CONTEXTMENUITEM cmi;
    ::ZeroMemory(&cmi, sizeof(cmi));

    // Get the children of the MMCMenu. These represent the items that
    // are being added to MMC's menu at the specified insertion point.

    IfFailGo(pMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMenuItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMenuItems, &pMMCMenuItems));

    cMenuItems = pMMCMenuItems->GetCount();

    // Iterate through the menu items and add each one to MMC

    for (i = 0; i < cMenuItems; i++)
    {
        // Add the menu item to our MMCMenus collection and get its command ID
        IfFailGo(AddItemToCollection(m_pMenus, pMMCMenuItems, i,
                                     &pMMCMenuItem, &lIndexCmdID,
                                     &fHasChildren, &fSkip));
        if (fSkip)
        {
            // Menu item is not visible, skip it.
            continue;
        }

        // Fill in MMC's CONTEXTMENUITEM
        
        ::ZeroMemory(&cmi, sizeof(cmi));
        cmi.strName = pMMCMenuItem->GetCaption();
        cmi.strStatusBarText = pMMCMenuItem->GetStatusBarText();
        cmi.lCommandID = lIndexCmdID;
        cmi.lInsertionPointID = lInsertionPoint;

        cmi.fFlags |= pMMCMenuItem->GetChecked() ? MF_CHECKED : MF_UNCHECKED;
        cmi.fFlags |= pMMCMenuItem->GetEnabled() ? MF_ENABLED : MF_DISABLED;

        if (pMMCMenuItem->GetGrayed())
        {
            cmi.fFlags |= MF_GRAYED;
        }

        if (pMMCMenuItem->GetMenuBreak())
        {
            cmi.fFlags |= MF_MENUBREAK;
        }

        if (pMMCMenuItem->GetMenuBarBreak())
        {
            cmi.fFlags |= MF_MENUBARBREAK;
        }

        if (fHasChildren)
        {
            cmi.fFlags |= MF_POPUP;
        }

        if (pMMCMenuItem->GetDefault())
        {
            cmi.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;
        }

        hr = m_piContextMenuCallback->AddItem(&cmi);
        EXCEPTION_CHECK_GO(hr);

        // If the item is a popup then call this function recursively to add its
        // items. Pass the command ID of this menu as the insertion point for
        // the submenu.

        if (fHasChildren)
        {
            IfFailGo(AddMenuToMMC(pMMCMenuItem, cmi.lCommandID));
        }
    }

Error:
    QUICK_RELEASE(piMenuItems);
    RRETURN(hr);
}


HRESULT CContextMenu::AddItemToCollection
(
    CMMCMenus  *pMMCMenus,
    CMMCMenus  *pMMCMenuItems,
    long        lIndex,
    CMMCMenu  **ppMMCMenuItem,
    long       *plIndexCmdID,
    BOOL       *pfHasChildren,
    BOOL       *pfSkip
)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piSubMenuItems = NULL;
    CMMCMenus *pOwningCollection = NULL;
    IMMCMenu  *piMMCMenuItem = NULL; // Not AddRef()ed
    CMMCMenu  *pMMCMenuItem = NULL;
    long       cSubMenuItems = 0;
    BSTR       bstrKey = NULL;

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    *ppMMCMenuItem = NULL;
    *plIndexCmdID = 0;
    *pfHasChildren = FALSE;
    *pfSkip = TRUE;

    // Get the menu item and its MMCMenu object

    piMMCMenuItem = pMMCMenuItems->GetItemByIndex(lIndex);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuItem, &pMMCMenuItem));

    // If the item is not marked as visible then go on to the next one

    IfFalseGo(pMMCMenuItem->GetVisible(), S_OK);
    *pfSkip = FALSE;

    // Store the index of the menu in its owning collection. We will need
    // to restore its index after we add the menu to our own collection
    // that represents this context menu.

    lIndex = pMMCMenuItem->GetIndex();

    // Store the key of the menu. CMMCMenus::AddExisting()
    // will use the name as the key (which is the default setting at
    // design time) but the dev may have changed it.
    // After we add it to our collection we will restore the key.
    // Note: there should never be duplicate menu names in a snap-in
    // project because the designer will not allow it.

    IfFailGo(piMMCMenuItem->get_Key(&bstrKey));

    // Store the owning collection of the menu as we will need to
    // restore that too after adding it to our collection.

    pOwningCollection = pMMCMenuItem->GetCollection();

    // Add the menu item to the MMCMenus collection. This will change its index
    // to its position in our collection.

    IfFailGo(pMMCMenus->AddExisting(piMMCMenuItem, varIndex));

    // Get the index in the MMCMenus collection to use as the command ID.

    *plIndexCmdID = pMMCMenuItem->GetIndex();

    // Restore the menu's original index that indicates its position
    // in its owning collection.

    pMMCMenuItem->SetIndex(lIndex);

    // Restore the menu's original key.

    IfFailGo(pMMCMenuItem->put_Key(bstrKey));
    FREESTRING(bstrKey);

    // Restore its real owning collection (the AddExisting call above
    // switched the owner to our collection).

    pMMCMenuItem->SetCollection(pOwningCollection);

    // The index trick above will work because when the menu item is
    // selected, we will use the command ID to access the menu in the MMCMenus
    // collection. Even though the index is technically incorrect,
    // CSnapInCollection (in collect.h) does not do a lookup when get_Item is
    // called with an integer index. It simply checks that the index is within
    // the bounds of the collection and returns the item at that offset.

    // This is extremely unlikely but as a command ID can only be 16 bits
    // we need to check that the item we just added is not number 0x10000.

    if ( ((*plIndexCmdID) & CCM_COMMANDID_MASK_RESERVED) != 0 )
    {
        hr = SID_E_TOO_MANY_MENU_ITEMS;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get count of submenu items for this item

    IfFailGo(pMMCMenuItem->get_Children(reinterpret_cast<MMCMenus **>(&piSubMenuItems)));
    IfFailGo(piSubMenuItems->get_Count(&cSubMenuItems));

    if (0 != cSubMenuItems)
    {
        *pfHasChildren = TRUE;
    }

    *ppMMCMenuItem = pMMCMenuItem;

Error:
    QUICK_RELEASE(piSubMenuItems);
    FREESTRING(bstrKey);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CContextMenu::AddPredefinedViews
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IContextMenuCallback *piContextMenuCallback [in] MMC interface for
//                                                       adding menu items
//      CScopeItem           *pScopeItem            [in] currently selected
//                                                       scope item
//
// Output:
//      HRESULT
//
// Notes:
//
// If the scope item has a design time defintion (IScopeItemDef) and
// that definition has views and those views are marked to be added to
// the view menu, then add 'em.
//

HRESULT CContextMenu::AddPredefinedViews
(
    IContextMenuCallback *piContextMenuCallback,
    CScopeItem           *pScopeItem,
    BSTR                  bstrCurrentDisplayString
)
{
    HRESULT           hr = S_OK;
    IScopeItemDef    *piScopeItemDef = NULL;// Not AddRef()ed
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IListViewDef     *piListViewDef = NULL;
    CListViewDef     *pListViewDef = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IOCXViewDef      *piOCXViewDef = NULL;
    COCXViewDef      *pOCXViewDef = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    IURLViewDef      *piURLViewDef = NULL;
    CURLViewDef      *pURLViewDef = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    CTaskpadViewDef  *pTaskpadViewDef = NULL;
    long              cContextMenus = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    varIndex.vt = VT_I4;

    // Need to get the design time definition. If this is the static node
    // then it is SnapInDef. If not, then it is a ScopeItemDef.

    if (pScopeItem->IsStaticNode())
    {
        IfFailGo(GetSnapInViewDefs(&piViewDefs));
    }
    else
    {
        piScopeItemDef = pScopeItem->GetScopeItemDef();// Not AddRef()ed

        // If no design time definition then there's nothing to do as this
        // scope item was defined entirely in VB code.

        IfFalseGo(NULL != piScopeItemDef, S_OK);
        IfFailGo(piScopeItemDef->get_ViewDefs(&piViewDefs));
    }

    // Get each view collection and search for auto-view-menu definitions.
    // Note that we cannot use the shortcut CCollection::GetItemByIndex to
    // iterate through these collections because they are not master
    // collections and only get_Item() will sync up with the master.

    // Listviews

    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(piListViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piListViewDef);
        IfFailGo(piListViewDefs->get_Item(varIndex, &piListViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piListViewDef, &pListViewDef));

        if (!pListViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pListViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pListViewDef->GetViewMenuText(),
                                 pListViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }
    
    // OCX views

    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));
    IfFailGo(piOCXViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piOCXViewDef);
        IfFailGo(piOCXViewDefs->get_Item(varIndex, &piOCXViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piOCXViewDef, &pOCXViewDef));

        if (!pOCXViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pOCXViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pOCXViewDef->GetViewMenuText(),
                                 pOCXViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }

    // URL views

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));
    IfFailGo(piURLViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piURLViewDef);
        IfFailGo(piURLViewDefs->get_Item(varIndex, &piURLViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piURLViewDef, &pURLViewDef));

        if (!pURLViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pURLViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pURLViewDef->GetViewMenuText(),
                                 pURLViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }

    // Taskpad views

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(piTaskpadViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piTaskpadViewDef);
        IfFailGo(piTaskpadViewDefs->get_Item(varIndex, &piTaskpadViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piTaskpadViewDef, &pTaskpadViewDef));

        if (!pTaskpadViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pTaskpadViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pTaskpadViewDef->GetViewMenuText(),
                                 pTaskpadViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }

    
Error:
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    QUICK_RELEASE(piOCXViewDefs);
    QUICK_RELEASE(piOCXViewDef);
    QUICK_RELEASE(piURLViewDefs);
    QUICK_RELEASE(piURLViewDef);
    QUICK_RELEASE(piTaskpadViewDefs);
    QUICK_RELEASE(piTaskpadViewDef);
    RRETURN(hr);
}


HRESULT CContextMenu::AddViewMenuItem
(
    BSTR                  bstrDisplayString,
    BSTR                  bstrCurrentDisplayString,
    LPWSTR                pwszText,
    LPWSTR                pwszToolTipText,
    IContextMenuCallback *piContextMenuCallback
)
{
    HRESULT      hr = S_OK;
    IMMCMenu    *piMMCMenu = NULL;
    CMMCMenu    *pMMCMenu = NULL;
    long         lIndex = 0;

    CONTEXTMENUITEM cmi;
    ::ZeroMemory(&cmi, sizeof(cmi));

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    // Add an MMCMenu to our collection of currently displayed context
    // menu items.

    IfFailGo(m_pMenus->Add(varUnspecified, varUnspecified, &piMMCMenu));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));

    // Get its index to use as the command ID.

    lIndex = pMMCMenu->GetIndex();

    // Tell the MMCMenu object is is being used as an auto-view-menu item.
    
    pMMCMenu->SetAutoViewMenuItem();

    // Set its display string so that the menu command handler (CContextMenu::Command)
    // can use it to change the result view.

    IfFailGo(pMMCMenu->SetResultViewDisplayString(bstrDisplayString));
    
    // Build the MMC ContextMenuItem and add it to the View menu

    cmi.strName = pwszText;
    cmi.strStatusBarText = pwszToolTipText;
    cmi.lCommandID = lIndex;
    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
    cmi.fFlags = 0;
    cmi.fSpecialFlags = 0;

    // Check whether this result view is the scope item's current result view.
    // If so then add a check mark.

    if (NULL != bstrCurrentDisplayString)
    {
        if (0 == ::wcscmp(bstrDisplayString, bstrCurrentDisplayString))
        {
            cmi.fFlags |= MF_CHECKED;
        }
    }

    hr = piContextMenuCallback->AddItem(&cmi);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMMCMenu);
    RRETURN(hr);
}


HRESULT CContextMenu::AddMenuItems
(
    IDataObject          *piDataObject,
    IContextMenuCallback *piContextMenuCallback,
    long                 *plInsertionAllowed,
    CScopePaneItem       *pSelectedItem
)
{
    HRESULT           hr = S_OK;
    IMMCClipboard    *piMMCClipboard = NULL;
    CMMCDataObject   *pMMCDataObject  = NULL;
    IScopeItems      *piScopeItems = NULL;
    IMMCListItems    *piMMCListItems = NULL;
    IMMCDataObjects  *piMMCDataObjects = NULL;
    long              cItems = 0;
    VARIANT_BOOL      fvarInsertionAllowed = VARIANT_FALSE;
    VARIANT_BOOL      fvarAddPredefinedViews = VARIANT_FALSE;
    BOOL              fExtension = FALSE;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Clean out our MMCMenu collection. This collection holds all the items
    // that will be added to the context menu during this method. If this is
    // not the first context menu in the life of the snap-in then the collection
    // will contain the items from the previously displayed context menu.

    IfFailGo(m_pMenus->Clear());

    // Even though MMC specifically says not to hold on to the callback
    // interface we do this here so that VB event handler code called from here
    // can call back into us (using ContextMenu.AddMenu) to insert menu
    // items. From MMC's point of view we are not holding this interface pointer
    // after this method returns. The AddRef() is technically not necessary
    // but is done as an extra safety measure.
    
    piContextMenuCallback->AddRef();
    m_piContextMenuCallback = piContextMenuCallback;

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0 )
    {
        m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        fvarInsertionAllowed = VARIANT_TRUE;
        m_pSnapIn->GetViews()->FireAddTopMenuItems(
                              static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                              piMMCClipboard,
                              static_cast<IContextMenu *>(this),
                              &fvarInsertionAllowed);
        if (VARIANT_FALSE == fvarInsertionAllowed)
        {
            *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_TOP;
        }
    }

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0 )
    {
        if (!IsForeign(SelectionType))
        {
            // Snap-in owns the selected items. Fire Views_AddNewMenuItems.

            m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_NEW;
            fvarInsertionAllowed = VARIANT_TRUE;
            m_pSnapIn->GetViews()->FireAddNewMenuItems(
                                  static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                                  piMMCClipboard,
                                  static_cast<IContextMenu *>(this),
                                  &fvarInsertionAllowed);
            if (VARIANT_FALSE == fvarInsertionAllowed)
            {
                *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_NEW;
            }
        }
        else
        {
            // We are acting as an extension.
            // Fire ExtensionSnapIn_AddNewMenuItems

            m_lInsertionPoint = CCM_INSERTIONPOINTID_3RDPARTY_NEW;

            IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
            m_pSnapIn->GetExtensionSnapIn()->FireAddNewMenuItems(
                                              piMMCDataObjects,
                                              static_cast<IContextMenu *>(this));
            // Release the data objects here because in an extension we could
            // be asked for new and task items and the code below also get
            // the data objects.
            RELEASE(piMMCDataObjects);
        }
    }

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0 )
    {
        if (!IsForeign(SelectionType))
        {
            // Snap-in owns the selected items. Fire Views_AddTaskMenuItems.

            m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_TASK;
            fvarInsertionAllowed = VARIANT_TRUE;
            m_pSnapIn->GetViews()->FireAddTaskMenuItems(
                                  static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                                  piMMCClipboard,
                                  static_cast<IContextMenu *>(this),
                                  &fvarInsertionAllowed);
            if (VARIANT_FALSE == fvarInsertionAllowed)
            {
                *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_TASK;
            }
        }
        else
        {
            // We are acting as an extension.
            // Fire ExtensionSnapIn_AddTaskMenuItems

            m_lInsertionPoint = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
            IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
            m_pSnapIn->GetExtensionSnapIn()->FireAddTaskMenuItems(
                                              piMMCDataObjects,
                                              static_cast<IContextMenu *>(this));
            RELEASE(piMMCDataObjects);
        }
    }

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) != 0 )
    {
        m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
        fvarInsertionAllowed = VARIANT_TRUE;
        fvarAddPredefinedViews = VARIANT_TRUE;

        m_pSnapIn->GetViews()->FireAddViewMenuItems(
                              static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                              piMMCClipboard,
                              static_cast<IContextMenu *>(this),
                              &fvarInsertionAllowed,
                              &fvarAddPredefinedViews);
        if (VARIANT_FALSE == fvarInsertionAllowed)
        {
            *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_TASK;
        }

        // If the snap-in didn't nix the addition of predefined views then
        // add them to the view menu
        if (VARIANT_TRUE == fvarAddPredefinedViews)
        {
            // Check if the data object represents a single scope item and that
            // it is the currently selected scope item.
            // If MMC is allowing adding to the view menu then this should be 
            // the case but we need to check to be sure.

            IfFalseGo(NULL != pSelectedItem, S_OK);

            IfFailGo(piMMCClipboard->get_ScopeItems(reinterpret_cast<ScopeItems **>(&piScopeItems)));
            IfFailGo(piScopeItems->get_Count(&cItems));
            IfFalseGo(1L == cItems, S_OK);

            // Get the scope item from the data object and compare it to the
            // selected scope item. We can't use the scope item from the
            // clipboard for a pointer comparison as it is a clone of the
            // real scope item.

            IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
            IfFalseGo(pMMCDataObject->GetScopeItem() == pSelectedItem->GetScopeItem(), S_OK);

            // Make sure there is nothing else in the selection
            
            IfFailGo(piMMCClipboard->get_ListItems(reinterpret_cast<MMCListItems **>(&piMMCListItems)));
            IfFailGo(piMMCListItems->get_Count(&cItems));
            IfFalseGo(0 == cItems, S_OK);

            IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
            IfFailGo(piMMCDataObjects->get_Count(&cItems));
            IfFalseGo(0 == cItems, S_OK);

            // Get the display string from the selected item so that we
            // can check its menu item if it is a predefined result view and
            // add the predefined views to the view menu.

            IfFailGo(AddPredefinedViews(piContextMenuCallback,
                                        pMMCDataObject->GetScopeItem(),
                                        pSelectedItem->GetDisplayString()));
        }
    }

Error:
    m_piContextMenuCallback = NULL;
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piScopeItems);
    QUICK_RELEASE(piMMCListItems);
    QUICK_RELEASE(piContextMenuCallback);
    QUICK_RELEASE(piMMCDataObjects);
    RRETURN(hr);
}


HRESULT CContextMenu::Command
(
    long            lCommandID,
    IDataObject    *piDataObject,
    CScopePaneItem *pSelectedItem
)
{
    HRESULT         hr = S_OK;
    IMMCClipboard  *piMMCClipboard = NULL;
    IMMCMenu       *piMMCMenu = NULL;
    CMMCMenu       *pMMCMenu = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Check for listview selection notification. This is sent by MMC when
    // a non-listview is in the result pane and the user selects one of the
    // listview options from the view menu (list, small, large, etc). We
    // notify the view that owns this CContextMenu object so the information
    // can be used for the subsequent IComponent::GetResultViewType() call.

    if (MMCC_STANDARD_VIEW_SELECT == lCommandID)
    {
        if (NULL != pSelectedItem)
        {
            IfFailGo(pSelectedItem->OnListViewSelected());
        }
        goto Error; // we're done
    }

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // The command ID is an index into our MMCMenus collection. Use it
    // to get the  the MMCMenu object for the selected item.

    varIndex.vt = VT_I4;
    varIndex.lVal = lCommandID;
    IfFailGo(m_pMenus->get_Item(varIndex, &piMMCMenu));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));

    // If this is an auto view menu item then initiate the new result view
    // display

    if (pMMCMenu->IsAutoViewMenuItem())
    {
        if (NULL != pSelectedItem)
        {
            // Get the result view display string from the MMCMenu
            // and set it in the currently selected ScopePaneItem as a
            // predefined view type. Reselect the scope item so that MMC
            // will change the result view.

            IfFailGo(pSelectedItem->DisplayNewResultView(
                                         pMMCMenu->GetResultViewDisplayString(),
                                         siPreDefined));
        }
    }
    else
    {
        // It is a snap-in defined menu item. Fire the menu click event.
        FireMenuClick(pMMCMenu, piMMCClipboard);
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCMenu);
    RRETURN(hr);
}


void CContextMenu::FireMenuClick
(
    CMMCMenu      *pMMCMenu,
    IMMCClipboard *piMMCClipboard
)
{
    CMMCMenus *pMMCMenus = NULL;
    CMMCMenu  *pMMCParentMenu = NULL;

    // Fire the event on the menu item first.

    pMMCMenu->FireClick(pMMCMenu->GetIndex(), piMMCClipboard);

    // The snap-in may also be sinking events on the parent menu so if
    // there is one then fire it there too.

    pMMCMenus = pMMCMenu->GetCollection();

    if (NULL != pMMCMenus)
    {
        // Get the MMCMenu that owns the collection containing the menu
        // item that was clicked.

        pMMCParentMenu = pMMCMenus->GetParent();

        // Fire the event with the selected item's index

        if (NULL != pMMCParentMenu)
        {
            pMMCParentMenu->FireClick(pMMCMenu->GetIndex(), piMMCClipboard);
        }
    }
}

//=--------------------------------------------------------------------------=
//                         IContextMenu Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CContextMenu::AddMenu(MMCMenu *Menu)
{
    HRESULT   hr = S_OK;
    CMMCMenu *pMMCMenu = NULL;

    if (NULL == Menu)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                reinterpret_cast<IMMCMenu *>(Menu), &pMMCMenu));

    // Ask MMC to add the menu to the appropriate insertion point

    IfFailGo(AddMenuToMMC(pMMCMenu, m_lInsertionPoint));

Error:
    if (SID_E_DETACHED_OBJECT == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CContextMenu::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IContextMenu == riid)
    {
        *ppvObjOut = static_cast<IContextMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctlbar.cpp ===
//=--------------------------------------------------------------------------=
// ctlbar.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CControlbar class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ctlbar.h"
#include "toolbar.h"
#include "mbuttons.h"
#include "clipbord.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CControlbar::CControlbar(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                            OBJECT_TYPE_CONTROLBAR,
                                            static_cast<IMMCControlbar *>(this),
                                            static_cast<CControlbar *>(this),
                                            0,    // no property pages
                                            NULL, // no property pages
                                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CControlbar::Create(IUnknown *punkOuter)
{
    HRESULT      hr = S_OK;
    IUnknown    *punkToolbars = CMMCToolbars::Create(NULL);
    CControlbar *pControlbar = New CControlbar(punkOuter);

    if ( (NULL == pControlbar) || (NULL == punkToolbars) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkToolbars,
                                                   &pControlbar->m_pToolbars));
Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pControlbar)
        {
            delete pControlbar;
        }
        return NULL;
    }
    else
    {
        return pControlbar->PrivateUnknown();
    }
}

CControlbar::~CControlbar()
{
    long i = 0;

    RELEASE(m_piControlbar);
    if (NULL != m_pToolbars)
    {
        m_pToolbars->Release();
    }

    if (NULL != m_ppunkControls)
    {
        for (i = 0; i < m_cControls; i++)
        {
            if (NULL != m_ppunkControls[i])
            {
                m_ppunkControls[i]->Release();
            }
        }
        ::CtlFree(m_ppunkControls);
    }
    
    InitMemberVariables();
}

void CControlbar::InitMemberVariables()
{
    m_pToolbars = NULL;
    m_pSnapIn = NULL;
    m_pView = NULL;
    m_piControlbar = NULL;
    m_ppunkControls = NULL;
    m_cControls = 0;
}


HRESULT CControlbar::GetControlIndex(IMMCToolbar *piMMCToolbar, long *plIndex)
{
    HRESULT hr = SID_E_INVALIDARG;
    long    cToolbars = m_pToolbars->GetCount();
    long    i = 0;

    *plIndex = 0;

    for (i = 0; (i < cToolbars) && (S_OK != hr); i++)
    {
        if (m_pToolbars->GetItemByIndex(i) == piMMCToolbar)
        {
            *plIndex = i;
            hr = S_OK;
        }
    }

    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


HRESULT CControlbar::GetControl
(
    CSnapIn      *pSnapIn,
    IMMCToolbar  *piMMCToolbar,
    IUnknown    **ppunkControl
)
{
    HRESULT     hr = S_OK;
    CControlbar *pControlbar = pSnapIn->GetCurrentControlbar();
    long         lIndex = 0;

    *ppunkControl = NULL;

    if (NULL == pControlbar)
    {
        hr = SID_E_CONTROLBAR_NOT_AVAILABLE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }


    // UNDONE: in an extension that does both namespace and toolbars, can
    // there be confusion between an old current view and the extension?

    if (SUCCEEDED(pControlbar->GetControlIndex(piMMCToolbar, &lIndex)))
    {
        *ppunkControl = pControlbar->m_ppunkControls[lIndex];
        (*ppunkControl)->AddRef();
    }

Error:
    RRETURN(hr);
}


HRESULT CControlbar::GetToolbar
(
    CSnapIn      *pSnapIn,
    IMMCToolbar  *piMMCToolbar,
    IToolbar    **ppiToolbar
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkToolbar = NULL;

    IfFailGo(GetControl(pSnapIn, piMMCToolbar, &punkToolbar));

    IfFailGo(punkToolbar->QueryInterface(IID_IToolbar,
                                         reinterpret_cast<void **>(ppiToolbar)));
Error:
    QUICK_RELEASE(punkToolbar);
    RRETURN(hr);
}


HRESULT CControlbar::GetMenuButton
(
    CSnapIn      *pSnapIn,
    IMMCToolbar  *piMMCToolbar,
    IMenuButton **ppiMenuButton
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMenuButton = NULL;

    IfFailGo(GetControl(pSnapIn, piMMCToolbar, &punkMenuButton));

    IfFailGo(punkMenuButton->QueryInterface(IID_IMenuButton,
                                         reinterpret_cast<void **>(ppiMenuButton)));
Error:
    QUICK_RELEASE(punkMenuButton);
    RRETURN(hr);
}





HRESULT CControlbar::OnControlbarSelect
(
    IDataObject *piDataObject,
    BOOL         fSelectionInScopePane,
    BOOL         fSelected
)
{
    HRESULT          hr = S_OK;
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCDataObjects *piMMCDataObjects = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // If we have an owning View then fire Views_UpdateControlbar.
    
    if (NULL != m_pView)
    {
        // Fire Views_UpdateControlbar

        m_pSnapIn->GetViews()->FireUpdateControlbar(
                                           static_cast<IView *>(m_pView),
                                           piMMCClipboard,
                                           BOOL_TO_VARIANTBOOL(fSelected),
                                           static_cast<IMMCControlbar *>(this));
    }
    else
    {
        // No owning View. Fire ExtensionSnapIn_UpdateControlbar

        ASSERT(IsForeign(SelectionType), "IExtendControlbar::ControlbarNotify(MMCN_SELECT) in an extension received a selection belonging to itself.")

        IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));

        m_pSnapIn->GetExtensionSnapIn()->FireUpdateControlbar(
                                     BOOL_TO_VARIANTBOOL(fSelectionInScopePane),
                                     BOOL_TO_VARIANTBOOL(fSelected),
                                     piMMCDataObjects,
                                     static_cast<IMMCControlbar *>(this));
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCDataObjects);
    RRETURN(hr);
}



HRESULT CControlbar::OnButtonClick(IDataObject *piDataObject, int idButton)
{
    HRESULT           hr = S_OK;
    CMMCToolbar      *pMMCToolbar = NULL;
    CMMCButton       *pMMCButton = NULL;
    IMMCClipboard    *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Get the MMCToolbar and MMCButton objects for the button clicked.

    IfFailGo(CMMCToolbar::GetToolbarAndButton(idButton, &pMMCToolbar,
                                              &pMMCButton, m_pSnapIn));
    // Fire MMCToolbar_ButtonClick
    
    pMMCToolbar->FireButtonClick(piMMCClipboard,
                                 static_cast<IMMCButton *>(pMMCButton));

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(S_OK);
}




//=--------------------------------------------------------------------------=
// CControlbar::OnMenuButtonClick
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject     [in] from MMCN_MENU_BTNCLICK
//      MENUBUTTONDATA *pMENUBUTTONDATA  [in] from MMCN_MENU_BTNCLICK
//
// Output:
//
// Notes:
//
// This function handles the MMCN_MENU_BTNCLICK notification. It will not
// be invoked during a debug session. In that circumstance the proxy for
// IExtendControlbar::ControlbarNotify() will QI for IExtendControlbarRemote
// and call its MenuButtonClick() method.
//


HRESULT CControlbar::OnMenuButtonClick
(
    IDataObject    *piDataObject,
    MENUBUTTONDATA *pMENUBUTTONDATA
)
{
    HRESULT           hr = S_OK;
    CMMCToolbar      *pMMCToolbar = NULL;
    CMMCButton       *pMMCButton = NULL;
    CMMCButtonMenu   *pMMCButtonMenu = NULL;
    IMMCClipboard    *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Fire MMCToolbar_ButtonDropDown

    IfFailGo(FireMenuButtonDropDown(pMENUBUTTONDATA->idCommand,
                                    piMMCClipboard, &pMMCButton));

    // At this point the VB event handler has run and the snap-in has had a
    // chance to configure all the items on the menu by setting properties
    // such as MMCButton.ButtonMenus(i).Enabled, adding/removing items, etc.
    // We now need to display a popup menu at the co-ordinates passed by MMC.

    IfFailGo(DisplayPopupMenu(pMMCButton,
                              pMENUBUTTONDATA->x,
                              pMENUBUTTONDATA->y,
                              &pMMCButtonMenu));

   // If the user cancelled the selection or the snap-in gave us an empty
   // menu button then we're done.

   IfFalseGo(NULL != pMMCButtonMenu, S_OK);

   // Fire MMCToolbar_ButtonMenuClick. The button can give us its owning toolbar.

   pMMCToolbar = pMMCButton->GetToolbar();

   pMMCToolbar->FireButtonMenuClick(piMMCClipboard,
                                    static_cast<IMMCButtonMenu *>(pMMCButtonMenu));

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CControlbar::FireMenuButtonDropDown
(
    int              idCommand,
    IMMCClipboard   *piMMCClipboard,
    CMMCButton     **ppMMCButton
)
{
    HRESULT           hr = S_OK;
    CMMCToolbar      *pMMCToolbar = NULL;
    CMMCButton       *pMMCButton = NULL;
    CMMCButtonMenu   *pMMCButtonMenu = NULL;

    // MENUBUTTONDATA.idCommand contains a pointer to the CMMCButton that owns
    // the menu button.

    pMMCButton = reinterpret_cast<CMMCButton *>(idCommand);

    // The button can give us its owning toolbar

    pMMCToolbar = pMMCButton->GetToolbar();

    // Fire MMCToolbar_ButtonDropDown

    pMMCToolbar->FireButtonDropDown(piMMCClipboard,
                                    static_cast<IMMCButton *>(pMMCButton));

    *ppMMCButton = pMMCButton;

    RRETURN(hr);
}




HRESULT CControlbar::DisplayPopupMenu
(
    CMMCButton      *pMMCButton,
    int              x,
    int              y,
    CMMCButtonMenu **ppMMCButtonMenuClicked
)
{
    HRESULT           hr = S_OK;
    IMMCButtonMenus  *piMMCButtonMenus = NULL;
    CMMCButtonMenus  *pMMCButtonMenus = NULL;
    CMMCButtonMenu   *pMMCButtonMenu = NULL;
    long              cItems = 0;
    long              i = 0;
    long              cPopupMenuItems = 0;
    HMENU             hMenu = NULL;
    UINT              uiFlags = 0;
    HWND              hwndConsoleFrame = NULL;
    char             *pszText = NULL;

    *ppMMCButtonMenuClicked = NULL;

    // First create an empty Win32 menu
    hMenu = ::CreatePopupMenu();
    if (NULL == hMenu)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Now iterate through each of the items and add them to the menu

    IfFailGo(pMMCButton->get_ButtonMenus(
                       reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus)));

    IfFailGo(piMMCButtonMenus->get_Count(&cItems));

    // If the collection is empty then don't do anything
    
    IfFalseGo(0 != cItems, S_OK);
    
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButtonMenus,
                                                   &pMMCButtonMenus));

    for (i = 0; i < cItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                             pMMCButtonMenus->GetItemByIndex(i),
                                             &pMMCButtonMenu));

        // If the button menu is not marked visible then don't add it to
        // the popup menu

        if (!pMMCButtonMenu->GetVisible())
        {
            continue;
        }

        // Get all of the button menu properties to set the menu item flags
        
        uiFlags = MF_STRING;

        if (pMMCButtonMenu->GetChecked())
        {
            uiFlags |= MF_CHECKED;
        }
        else
        {
            uiFlags |= MF_UNCHECKED;
        }

        if (pMMCButtonMenu->GetGrayed())
        {
            uiFlags |= MF_GRAYED;
        }

        if (pMMCButtonMenu->GetEnabled())
        {
            uiFlags |= MF_ENABLED;
        }
        else
        {
            uiFlags |= MF_DISABLED;
        }

        if (pMMCButtonMenu->GetMenuBreak())
        {
            uiFlags |= MF_MENUBREAK;
        }

        if (pMMCButtonMenu->GetMenuBarBreak())
        {
            uiFlags |= MF_MENUBARBREAK;
        }

        if (pMMCButtonMenu->GetSeparator())
        {
            uiFlags |= MF_SEPARATOR;
        }

        IfFailGo(::ANSIFromWideStr(pMMCButtonMenu->GetText(), &pszText));

        // Append the menu item

        if (!::AppendMenu(hMenu, uiFlags, static_cast<UINT>(i + 1L), pszText))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        cPopupMenuItems++;

        ::CtlFree(pszText);
        pszText = NULL;
    }

    // If there are no items in the popup menu then don't display one. This
    // could happen if the user marked all items as invisible.

    IfFalseGo(0 != cPopupMenuItems, S_OK);

    // Get the console's main frame hwnd as owner for the menu. If we are a
    // primary snap-in then we'll have a view.

    if (NULL != m_pView)
    {
        hr = m_pView->GetIConsole2()->GetMainWindow(&hwndConsoleFrame);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        // As an extension we have no access to IConsole2 so do the next best
        // thing: use the active window for this thread as the owner of the
        // popup menu.

        hwndConsoleFrame = ::GetActiveWindow();
    }

    // Display the popup and wait for the selection.

    i = (long)::TrackPopupMenu(
                  hMenu,            // menu to display
                  TPM_LEFTALIGN |   // align left side of menu with x
                  TPM_TOPALIGN  |   // align top of menu with y
                  TPM_NONOTIFY  |   // don't send any messages during selection
                  TPM_RETURNCMD |   // make the ret val the selected item
                  TPM_LEFTBUTTON,   // allow selection with left button only
                  x,                // left side coordinate
                  y,                // top coordinate
                  0,                // reserved,
                  hwndConsoleFrame, // owner window
                  NULL);            // not used

    // A zero return could indicate either an error or that the user hit
    // Escape or clicked off of the menu to cancel the operation. GetLastError()
    // determines whether there was an error.

    if (0 == i)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // if i is non-zero then it contains the index of the selected item + 1.
    // Use it to return the MMCButtonMenu object for the selected item.

    if (0 != i)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                        pMMCButtonMenus->GetItemByIndex(i - 1L),
                                        ppMMCButtonMenuClicked));
    }

Error:
    if (NULL != hMenu)
    {
        (void)::DestroyMenu(hMenu);
    }
    if (NULL != pszText)
    {
        ::CtlFree(pszText);
    }
    QUICK_RELEASE(piMMCButtonMenus);
    RRETURN(S_OK);
}


//=--------------------------------------------------------------------------=
// CControlbar::MenuButtonClick
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject   [in]  from MMCN_MENU_BTNCLICK
//      int             idCommand      [in]  from MENUBUTTONDATA.idCommand passed
//                                           to the proxy with MMCN_MENU_BTNCLICK
//      POPUP_MENUDEF **ppPopupMenuDef [out] popup menu definition returned here
//                                           so proxy can display it
//
// Output:
//
// Notes:
//
// This function effectively handles MMCN_MENU_BTNCLICK when running
// under a debugging session.
//
// The proxy for IExtendControlbar::ControlbarNotify() will QI for
// IExtendControlbarRemote and call this method when it gets MMCN_MENU_BTNCLICK.
// We fire MMCToolbar_ButtonDropDown and then return an array of menu item
// definitions. The proxy will display the popup menu on the MMC side and then
// call IExtendControlbarRemote::PopupMenuClick() if the user makes a selection.
// (See implementation below in CControlbar::PopupMenuClick()).
//

HRESULT CControlbar::MenuButtonClick
(
    IDataObject    *piDataObject,
    int             idCommand,
    POPUP_MENUDEF **ppPopupMenuDef
)
{
    HRESULT          hr = S_OK;
    CMMCButton      *pMMCButton = NULL;
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    CMMCButtonMenus *pMMCButtonMenus = NULL;
    CMMCButtonMenu  *pMMCButtonMenu = NULL;
    long             cItems = 0;
    long             i = 0;
    long             cPopupMenuItems = 0;
    UINT             uiFlags = 0;
    POPUP_MENUDEF   *pPopupMenuDef = NULL;
    POPUP_MENUITEM  *pPopupMenuItem = NULL;
    char            *pszText = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    *ppPopupMenuDef = NULL;

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Fire MMCToolbar_ButtonDropDown

    IfFailGo(FireMenuButtonDropDown(idCommand, piMMCClipboard, &pMMCButton));

    // At this point the VB event handler has run and the snap-in has had a
    // chance to configure all the items on the menu by setting properties
    // such as MMCButton.ButtonMenus(i).Enabled, adding/removing items, etc.
    // We now need to return an array of popup menu items for the proxy to
    // display.

    // Get the ButtonMenus collection and check if there is anything in there

    IfFailGo(pMMCButton->get_ButtonMenus(
                     reinterpret_cast<MMCButtonMenus **>((&piMMCButtonMenus))));

    IfFailGo(piMMCButtonMenus->get_Count(&cItems));

    // If the collection is empty then don't do anything

    IfFalseGo(0 != cItems, S_OK);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButtonMenus,
                                                   &pMMCButtonMenus));

    // Iterate through each of the items and add them to the menu definition

    for (i = 0; i < cItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                              pMMCButtonMenus->GetItemByIndex(i),
                                              &pMMCButtonMenu));

        // If the button menu is not marked visible then don't add it to
        // the popup menu

        if (!pMMCButtonMenu->GetVisible())
        {
            continue;
        }

        // Get all of the button menu properties to set the menu item flags

        uiFlags = MF_STRING;

        if (pMMCButtonMenu->GetChecked())
        {
            uiFlags |= MF_CHECKED;
        }
        else
        {
            uiFlags |= MF_UNCHECKED;
        }

        if (pMMCButtonMenu->GetGrayed())
        {
            uiFlags |= MF_GRAYED;
        }

        if (pMMCButtonMenu->GetEnabled())
        {
            uiFlags |= MF_ENABLED;
        }
        else
        {
            uiFlags |= MF_DISABLED;
        }

        if (pMMCButtonMenu->GetMenuBreak())
        {
            uiFlags |= MF_MENUBREAK;
        }

        if (pMMCButtonMenu->GetMenuBarBreak())
        {
            uiFlags |= MF_MENUBARBREAK;
        }

        if (pMMCButtonMenu->GetSeparator())
        {
            uiFlags |= MF_SEPARATOR;
        }

        IfFailGo(::ANSIFromWideStr(pMMCButtonMenu->GetText(), &pszText));

        // (Re)allocate the POPUP_MENUDEF structure to accomodate the new item.

        pPopupMenuDef = (POPUP_MENUDEF *)::CoTaskMemRealloc(pPopupMenuDef,
                               sizeof(POPUP_MENUDEF) +
                              ((cPopupMenuItems + 1L) * sizeof(POPUP_MENUITEM)));

        if (NULL == pPopupMenuDef)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        pPopupMenuDef->cMenuItems = cPopupMenuItems + 1L;

        // Fill in the menu item info. Need to CoTaskMemAlloc() a copy of the
        // string because it will be freed by the stub after it is transmitted.
        // This is a double allocation but the perf is not an issue here and we
        // would have to copy all of the code in ANSIFromWideStr() to avoid it.

        pPopupMenuItem = &pPopupMenuDef->MenuItems[cPopupMenuItems];
        
        pPopupMenuItem->uiFlags = uiFlags;
        pPopupMenuItem->uiItemID = static_cast<UINT>(i + 1L);

        pPopupMenuItem->pszItemText =
                        (char *)::CoTaskMemAlloc(::strlen((char *)pszText) + 1);

        if (NULL == pPopupMenuItem->pszItemText)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        ::strcpy((char *)pPopupMenuItem->pszItemText, pszText);

        cPopupMenuItems++;

        ::CtlFree(pszText);
        pszText = NULL;
    }

    // If there are no items in the popup menu then don't display one. This
    // could happen if the user marked all items as invisible.

    IfFalseGo(0 != cPopupMenuItems, S_OK);

    // Set POPUP_MENUDEF members and return the definition to the stub

    IfFailGo(pMMCButton->QueryInterface(IID_IUnknown,
                  reinterpret_cast<void **>(&pPopupMenuDef->punkSnapInDefined)));

    // Get the console's main frame hwnd as owner for the popup menu. If we are
    // an extension then upon return from this call the proxy will note that
    // pPopupMenuDef->hwndMenuOwner is NULL and call GetActiveWindow() to fill
    // it in. There is nothing better that we can do because an extension does
    // not have access to IConsole2 on MMC.

    if (NULL != m_pView)
    {
        hr = m_pView->GetIConsole2()->GetMainWindow(&pPopupMenuDef->hwndMenuOwner);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        pPopupMenuDef->hwndMenuOwner = NULL;
    }

    *ppPopupMenuDef = pPopupMenuDef;

Error:
    if (NULL != pszText)
    {
        ::CtlFree(pszText);
    }

    if ( FAILED(hr) && (NULL != pPopupMenuDef) )
    {
        for (i = 0; i < pPopupMenuDef->cMenuItems; i++)
        {
            if (NULL != pPopupMenuDef->MenuItems[i].pszItemText)
            {
                ::CoTaskMemFree(pPopupMenuDef->MenuItems[i].pszItemText);
            }
        }
        if (NULL != pPopupMenuDef->punkSnapInDefined)
        {
            pPopupMenuDef->punkSnapInDefined->Release();
        }
        ::CoTaskMemFree(pPopupMenuDef);
    }

    QUICK_RELEASE(piMMCButtonMenus);
    RRETURN(S_OK);
}



//=--------------------------------------------------------------------------=
// CControlbar::PopupMenuClick
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject *piDataObject [in] from MMCN_MENU_BTNCLICK
//      UINT         uIDItem      [in] ID of popup menu item selected
//      IUnknown    *punkParam    [in] punk we returned to stub in
//                                     CControlbar::MenuButtonClick() (see above).
//                                     This is IUnknown on CMMCButton.
//
// Output:
//
// Notes:
//
// This function effectively handles a popup menu selection for a menu button
// when running under a debugging session.
//
// After the proxy for IExtendControlbar::ControlbarNotify() has displayed
// a popup menu on our behalf, if the user made a selection it will call this
// method. See CControlbar::MenuButtonClick() above for more info.
//

HRESULT CControlbar::PopupMenuClick
(
    IDataObject *piDataObject,
    UINT         uiIDItem,
    IUnknown    *punkParam
)
{
    HRESULT          hr = S_OK;
    CMMCButton      *pMMCButton = NULL;
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    CMMCButtonMenus *pMMCButtonMenus = NULL;
    CMMCToolbar     *pMMCToolbar = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Check the parameters

    IfFalseGo(0 < uiIDItem, E_INVALIDARG);
    IfFalseGo(NULL != punkParam, E_INVALIDARG);

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Get the CMMCButton from punkParam.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkParam, &pMMCButton));

    // Get the MMCButtonMenus collection

    IfFailGo(pMMCButton->get_ButtonMenus(
                       reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButtonMenus,
                                                   &pMMCButtonMenus));

    // Fire MMCToolbar_ButtonMenuClick. The button can give us its owning toolbar.
    // The selected item is indexed by the menu item ID - 1

    pMMCToolbar = pMMCButton->GetToolbar();

    pMMCToolbar->FireButtonMenuClick(piMMCClipboard,
               pMMCButtonMenus->GetItemByIndex(static_cast<long>(uiIDItem - 1)));

Error:
    QUICK_RELEASE(piMMCButtonMenus);
    RRETURN(S_OK);
}




HRESULT CControlbar::SetControlbar(IControlbar *piControlbar)
{
    HRESULT      hr = S_OK;
    long         cToolbars = 0;
    long         i = 0;
    CMMCToolbar *pMMCToolbar = NULL;

    if (NULL != piControlbar)
    {
        RELEASE(m_piControlbar);
        piControlbar->AddRef();
        m_piControlbar = piControlbar;

        // If we have an owning View then fire Views_SetControlbar

        if (NULL != m_pView)
        {
            m_pSnapIn->GetViews()->FireSetControlbar(
                                           static_cast<IView *>(m_pView),
                                           static_cast<IMMCControlbar *>(this));
        }
        else
        {
            // No View. Fire ExtensionSnapIn_SetControlbar

            m_pSnapIn->GetExtensionSnapIn()->FireSetControlbar(
                                           static_cast<IMMCControlbar *>(this));
        }
    }
    else if (NULL != m_piControlbar)
    {
        // This is a cleanup call and we might have stuff on the controlbar

        cToolbars = m_pToolbars->GetCount();

        ASSERT(cToolbars <= m_cControls, "Toolbar and MMC control count are out of sync");

        IfFalseGo(cToolbars <= m_cControls, SID_E_INTERNAL);

        for (i = 0; i < cToolbars; i++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 m_pToolbars->GetItemByIndex(i),
                                                 &pMMCToolbar));

            if (NULL != m_ppunkControls[i])
            {
                hr = m_piControlbar->Detach(m_ppunkControls[i]);
                EXCEPTION_CHECK_GO(hr);
                m_ppunkControls[i]->Release();
                m_ppunkControls[i] = NULL;
            }

            pMMCToolbar->Detach();
        }
        IfFailGo(m_pToolbars->Clear());
        RELEASE(m_piControlbar);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      IMMCControlbar Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CControlbar::Attach(IDispatch *Control)
{
    HRESULT            hr = S_OK;
    IMMCToolbar       *piMMCToolbar = NULL;
    CMMCToolbar       *pMMCToolbar = NULL;
    IUnknown          *punkControl = NULL;
    MMC_CONTROL_TYPE   nType = TOOLBAR;
    BOOL               fIsToolbar = FALSE;
    BOOL               fIsMenuButton = FALSE;
    long               lIndex = 0;
    IExtendControlbar *piExtendControlbar = NULL;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    VARIANT varKey;
    ::VariantInit(&varKey);

    if (NULL == Control)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // QI to determine the type of control. We only support IMMCToolbar.

    hr = Control->QueryInterface(IID_IMMCToolbar,
                                 reinterpret_cast<void **>(&piMMCToolbar));
    if (E_NOINTERFACE == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbar, &pMMCToolbar));

    // MMCToolbars must be all buttons or all menu buttons. That's how we
    // know whether to ask MMC to create a toolbar or menu button. Check
    // which to determine the control type we will as MMC to create

    IfFailGo(pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        nType = TOOLBAR;
    }
    else
    {
        IfFailGo(pMMCToolbar->IsMenuButton(&fIsMenuButton));
        if (fIsMenuButton)
        {
            nType = MENUBUTTON;
        }
        else
        {
            hr = SID_E_TOOLBAR_INCONSISTENT;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Determine which object implements IExtendControlbar for us

    if (NULL != m_pView)
    {
        piExtendControlbar = static_cast<IExtendControlbar *>(m_pView);
    }
    else
    {
        piExtendControlbar = static_cast<IExtendControlbar *>(m_pSnapIn);
    }

    // Ask MMC to create the control and get MMC's IToolbar or IMenuButton

    hr = m_piControlbar->Create(nType, piExtendControlbar, &punkControl);
    EXCEPTION_CHECK_GO(hr);

    // Ask MMC to attach it

    hr = m_piControlbar->Attach(nType, punkControl);
    EXCEPTION_CHECK_GO(hr);

    // Set up the control with buttons, bitmaps etc.

    IfFailGo(pMMCToolbar->Attach(punkControl));

    if (NULL != m_pSnapIn)
    {
        pMMCToolbar->SetSnapIn(m_pSnapIn);
    }
    else
    {
        pMMCToolbar->SetSnapIn(m_pView->GetSnapIn());
    }

    // Add it to our list of controls. We need to remember them so that
    // we can remove them when IExtendControlbar::SetControlbar(NULL) is called.
    // Controls are indexed by name.

    IfFailGo(pMMCToolbar->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    IfFailGo(m_pToolbars->AddExisting(varUnspecifiedIndex, varKey, piMMCToolbar));

    // Add the control to the parallel array of IUnknown *. The AddExisting call
    // will have set the toolbar's index to its position in this collection. (It
    // is changed every time it is attached to a controlbar, but the index
    // property is not used other than right here).

    IfFailGo(pMMCToolbar->get_Index(&lIndex));

    lIndex--; // move from one-based collection index to zero-based array index

    // We never shrink, the IUnknown array, so if its size is large enough then
    // the corresponding slot it is free. If it is not large enough then grow
    // it now.

    if (m_cControls < (lIndex + 1L))
    {
        if (NULL == m_ppunkControls)
        {
            m_ppunkControls = (IUnknown **)::CtlAllocZero(sizeof(IUnknown *));
        }
        else
        {
            m_ppunkControls = (IUnknown **)::CtlReAllocZero(m_ppunkControls,
                                       sizeof(IUnknown *) * (m_cControls + 1L));
        }
        if (NULL == m_ppunkControls)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        m_cControls++;
    }

    punkControl->AddRef();
    m_ppunkControls[lIndex] = punkControl;

Error:
    QUICK_RELEASE(piMMCToolbar);
    QUICK_RELEASE(punkControl);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}



STDMETHODIMP CControlbar::Detach(IDispatch *Control)
{
    HRESULT      hr = S_OK;
    IMMCToolbar *piMMCToolbar = NULL;
    CMMCToolbar *pMMCToolbar = NULL;
    long         lIndex = 0;

    VARIANT varKey;
    ::VariantInit(&varKey);

    if (NULL == Control)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // QI to determine control type. We only support IMMCToolbar.

    hr = Control->QueryInterface(IID_IMMCToolbar,
                                 reinterpret_cast<void **>(&piMMCToolbar));
    if (E_NOINTERFACE == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbar, &pMMCToolbar));

    // Lookup the IMMCToolbar in our collection and get the index of its
    // corresponding MMC control IUnknown

    IfFailGo(GetControlIndex(piMMCToolbar, &lIndex));

    // Ask MMC to detach it and release it

    hr = m_piControlbar->Detach(m_ppunkControls[lIndex]);
    m_ppunkControls[lIndex]->Release();

    // Compress the IUnknown array

    while (lIndex < (m_cControls - 1L))
    {
        m_ppunkControls[lIndex] = m_ppunkControls[lIndex + 1L];
        lIndex++;
    }
    m_ppunkControls[lIndex] = NULL;

    // Tell the toolbar it is no longer attached to this controlbar in MMC

    pMMCToolbar->Detach();

    // Get its name and remove it from our list

    IfFailGo(pMMCToolbar->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    IfFailGo(m_pToolbars->Remove(varKey));

Error:
    QUICK_RELEASE(piMMCToolbar);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CControlbar::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCControlbar == riid)
    {
        *ppvObjOut = static_cast<IMMCControlbar *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CControlbar::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(static_cast<IMMCToolbars *>(m_pToolbars)));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtmenu.h ===
//=--------------------------------------------------------------------------=
// ctxtmenu.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CContextMenu class definition - implements ContextMenu object
//
//=--------------------------------------------------------------------------=

#ifndef _CTXTMENU_DEFINED_
#define _CTXTMENU_DEFINED_

#include "menus.h"
#include "spanitem.h"
#include "view.h"

class CScopePaneItem;
class CMMCMenus;
class CMMCMenu;
class CView;

//=--------------------------------------------------------------------------=
// 
// class CContextMenu
//
// Implements ContextMenu object used by VB and implements IExtendContextMenu
// for CSnapIn and CView.
//
//=--------------------------------------------------------------------------=
class CContextMenu : public CSnapInAutomationObject,
                     public IContextMenu
{
    protected:
        CContextMenu(IUnknown *punkOuter);
        ~CContextMenu();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT AddMenuItems(IDataObject          *piDataObject,
                             IContextMenuCallback *piContextMenuCallback,
                             long                 *plInsertionAllowed,
                             CScopePaneItem       *pSelectedItem);
        HRESULT Command(long            lCommandID,
                        IDataObject    *piDataObject,
                        CScopePaneItem *pSelectedItem);

        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        void SetView(CView *pView) { m_pView = pView; }

        static void FireMenuClick(CMMCMenu      *pMMCMenu,
                                  IMMCClipboard *piMMCClipboard);

        static HRESULT AddItemToCollection(CMMCMenus  *pMMCMenus,
                                           CMMCMenus  *pMMCMenuItems,
                                           long        lIndex,
                                           CMMCMenu  **ppMMCMenu,
                                           long       *plIndexCmdID,
                                           BOOL       *pfHasChildren,
                                           BOOL       *pfSkip);

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IContextMenu
    private:

        STDMETHOD(AddMenu)(MMCMenu *Menu);

        void InitMemberVariables();
        HRESULT AddMenuToMMC(CMMCMenu *pMMCMenu, long lInsertionPoint);
        HRESULT AddPredefinedViews(IContextMenuCallback *piContextMenuCallback,
                                   CScopeItem           *pScopeItem,
                                   BSTR                  bstrCurrentDisplayString);
        HRESULT AddViewMenuItem(BSTR bstrDisplayString,
                                BSTR bstrCurrentDisplayString,
                                LPWSTR pwszText,
                                LPWSTR pwszToolTipText,
                                IContextMenuCallback *piContextMenuCallback);

        CMMCMenus            *m_pMenus;
        IContextMenuCallback *m_piContextMenuCallback; // MMC interface
        long                  m_lInsertionPoint;       // Current insertion point
        CView                *m_pView;                 // Owning CView
        CSnapIn              *m_pSnapIn;               // Owning CSnapIn
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(ContextMenu,            // name
                                NULL,                   // clsid
                                NULL,                   // objname
                                NULL,                   // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IContextMenu,      // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif _CTXTMENU_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtprov.cpp ===
//=--------------------------------------------------------------------------=
// ctxtprov.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCContextMenuProvider class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ctxtprov.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CMMCContextMenuProvider::CMMCContextMenuProvider(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                   OBJECT_TYPE_CONTEXTMENUPROVIDER,
                                   static_cast<IMMCContextMenuProvider *>(this),
                                   static_cast<CMMCContextMenuProvider *>(this),
                                   0,    // no property pages
                                   NULL, // no property pages
                                   NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


IUnknown *CMMCContextMenuProvider::Create(IUnknown *punkOuter)
{
    CMMCContextMenuProvider *pContextMenuProvider =
                                          New CMMCContextMenuProvider(punkOuter);

    if (NULL == pContextMenuProvider)
    {
        GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
        return NULL;
    }
    else
    {
        return pContextMenuProvider->PrivateUnknown();
    }
}

CMMCContextMenuProvider::~CMMCContextMenuProvider()
{
    RELEASE(m_piContextMenuProvider);
    RELEASE(m_punkView);
    InitMemberVariables();
}

void CMMCContextMenuProvider::InitMemberVariables()
{
    m_piContextMenuProvider = NULL;
    m_pView = NULL;
    m_punkView = NULL;
}


HRESULT CMMCContextMenuProvider::SetProvider
(
    IContextMenuProvider *piContextMenuProvider,
    CView                *pView
)
{
    HRESULT hr = S_OK;

    RELEASE(m_piContextMenuProvider);
    if (NULL != piContextMenuProvider)
    {
        piContextMenuProvider->AddRef();
    }
    m_piContextMenuProvider = piContextMenuProvider;

    m_pView = pView;
    RELEASE(m_punkView);

    IfFalseGo(NULL != pView, S_OK);

    IfFailGo(pView->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&m_punkView)));
    
Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IMMCContextMenuProvider Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCContextMenuProvider::AddSnapInItems(VARIANT Objects)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    IDataObject *piDataObject = NULL;

    if ( (NULL == m_piContextMenuProvider) || (NULL == m_punkView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    hr = m_piContextMenuProvider->AddPrimaryExtensionItems(m_punkView,
                                                           piDataObject);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCContextMenuProvider::AddExtensionItems(VARIANT Objects)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    IDataObject *piDataObject = NULL;

    if (NULL == m_piContextMenuProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    hr = m_piContextMenuProvider->AddThirdPartyExtensionItems(piDataObject);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCContextMenuProvider::ShowContextMenu
(
    VARIANT     Objects,
    OLE_HANDLE  hwnd,
    long        xPos,
    long        yPos
)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    long         lSelected = 0;
    IDataObject *piDataObject = NULL;

    if ( (NULL == m_piContextMenuProvider) || (NULL == m_pView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piContextMenuProvider->ShowContextMenu(reinterpret_cast<HWND>(hwnd),
                                                  xPos, yPos, &lSelected);
    EXCEPTION_CHECK_GO(hr);

    IfFalseGo(0 != lSelected, S_OK);

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    IfFailGo(m_pView->Command(lSelected, piDataObject));

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCContextMenuProvider::Clear()
{
    HRESULT       hr = S_OK;

    if (NULL == m_piContextMenuProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piContextMenuProvider->EmptyMenuList();
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCContextMenuProvider::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCContextMenuProvider == riid)
    {
        *ppvObjOut = static_cast<IMMCContextMenuProvider *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtprov.h ===
//=--------------------------------------------------------------------------=
// ctxtprov.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCContextMenuProvider class definition
//
// Not used as MMC does not support IContextMenuProvier
//=--------------------------------------------------------------------------=

#ifndef _CTXTPROV_DEFINED_
#define _CTXTPROV_DEFINED_

#include "view.h"

class CMMCContextMenuProvider : public CSnapInAutomationObject,
                                public IMMCContextMenuProvider
{
    protected:
        CMMCContextMenuProvider(IUnknown *punkOuter);
        ~CMMCContextMenuProvider();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT SetProvider(IContextMenuProvider *piContextMenuProvider,
                            CView                *pView);

    // IMMCContextMenuProvider
    protected:
        STDMETHOD(AddSnapInItems)(VARIANT Objects);
        STDMETHOD(AddExtensionItems)(VARIANT Objects);
        STDMETHOD(ShowContextMenu)(VARIANT Objects, OLE_HANDLE hwnd,
                                   long xPos, long yPos);
        STDMETHOD(Clear)();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IContextMenu
    private:

        void InitMemberVariables();

        IContextMenuProvider *m_piContextMenuProvider;
        IUnknown             *m_punkView;
        CView                *m_pView;
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCContextMenuProvider,       // name
                                NULL,                         // clsid
                                NULL,                         // objname
                                NULL,                         // lblname
                                NULL,                         // creation function
                                TLIB_VERSION_MAJOR,           // major version
                                TLIB_VERSION_MINOR,           // minor version
                                &IID_IMMCContextMenuProvider, // dispatch IID
                                NULL,                         // event IID
                                HELP_FILENAME,                // help file
                                TRUE);                        // thread safe


#endif _CTXTPROV_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmt.cpp ===
//=--------------------------------------------------------------------------=
// datafmt.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormat class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "datafmt.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CDataFormat::CDataFormat(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_DATAFORMAT,
                            static_cast<IDataFormat *>(this),
                            static_cast<CDataFormat *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_DataFormat,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CDataFormat::~CDataFormat()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrFileName);
    InitMemberVariables();
}

void CDataFormat::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrFileName = NULL;
}

IUnknown *CDataFormat::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkDataFormat = NULL;

    CDataFormat *pDataFormat = New CDataFormat(punkOuter);

    IfFalseGo(NULL != pDataFormat, SID_E_OUTOFMEMORY);
    punkDataFormat = pDataFormat->PrivateUnknown();

Error:
    return punkDataFormat;
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormat::Persist()
{
    HRESULT hr = S_OK;

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrFileName, L"", OLESTR("FileName")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormat::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IDataFormat == riid)
    {
        *ppvObjOut = static_cast<IDataFormat *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmt.h ===
//=--------------------------------------------------------------------------=
// datafmt.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormat class definition
//
// Not used. Was going to encapulate use of XML to describe exported data formats
//=--------------------------------------------------------------------------=

#ifndef _DATAFMT_DEFINED_
#define _DATAFMT_DEFINED_


class CDataFormat : public CSnapInAutomationObject,
                    public CPersistence,
                    public IDataFormat
{
    private:
        CDataFormat(IUnknown *punkOuter);
        ~CDataFormat();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IDataFormat
        BSTR_PROPERTY_RW(CDataFormat,    Name,                      DISPID_DATAFORMAT_NAME);
        SIMPLE_PROPERTY_RW(CDataFormat,  Index,    long,            DISPID_DATAFORMAT_INDEX);
        BSTR_PROPERTY_RW(CDataFormat,    Key,                       DISPID_DATAFORMAT_KEY);
        BSTR_PROPERTY_RW(CDataFormat,    FileName,                  DISPID_DATAFORMAT_FILENAME);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(DataFormat,                  // name
                                &CLSID_DataFormat,           // clsid
                                "DataFormat",                // objname
                                "DataFormat",                // lblname
                                &CDataFormat::Create,        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IDataFormat,            // dispatch IID
                                NULL,                        // no event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _DATAFMT_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmts.cpp ===
//=--------------------------------------------------------------------------=
// datafmts.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormats class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "datafmts.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CDataFormats::CDataFormats(IUnknown *punkOuter) :
    CSnapInCollection<IDataFormat, DataFormat, IDataFormats>(punkOuter,
                                           OBJECT_TYPE_DATAFORMATS,
                                           static_cast<IDataFormats *>(this),
                                           static_cast<CDataFormats *>(this),
                                           CLSID_DataFormat,
                                           OBJECT_TYPE_DATAFORMAT,
                                           IID_IDataFormat,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_DataFormats,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CDataFormats::~CDataFormats()
{
}

IUnknown *CDataFormats::Create(IUnknown * punkOuter)
{
    CDataFormats *pMMCMenus = New CDataFormats(punkOuter);
    if (NULL == pMMCMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCMenus->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IDataFormats Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CDataFormats::Add
(
    VARIANT       Index,
    VARIANT       Key,
    VARIANT       FileName,
    IDataFormat **ppiDataFormat
)
{
    HRESULT      hr = S_OK;
    IDataFormat *piDataFormat = NULL;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    // Add the item to the collection.

    hr = CSnapInCollection<IDataFormat, DataFormat, IDataFormats>::Add(Index,
                                                           Key,
                                                           &piDataFormat);
    IfFailGo(hr);

    // If a file name was specified then set it

    if (ISPRESENT(FileName))
    {
        hr = ::VariantChangeType(&varCoerced, &FileName, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piDataFormat->put_FileName(varCoerced.bstrVal));
    }

    *ppiDataFormat = piDataFormat;
    
Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piDataFormat);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormats::Persist()
{
    HRESULT      hr = S_OK;
    IDataFormat *piDataFormat = NULL;

    // Do persistence operation

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IDataFormat, DataFormat, IDataFormats>::Persist(piDataFormat);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormats::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IDataFormats == riid)
    {
        *ppvObjOut = static_cast<IDataFormats *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IDataFormat, DataFormat, IDataFormats>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmts.h ===
//=--------------------------------------------------------------------------=
// datafmts.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormats class definition
//
// Not used. Was going to encapulate use of XML to describe exported data formats
//=--------------------------------------------------------------------------=

#ifndef _DATAFMTS_DEFINED_
#define _DATAFMTS_DEFINED_

#include "collect.h"

class CDataFormats : public CSnapInCollection<IDataFormat, DataFormat, IDataFormats>,
                     public CPersistence
{
    protected:
        CDataFormats(IUnknown *punkOuter);
        ~CDataFormats();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IDataFormats
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, VARIANT FileName, IDataFormat **ppiDataFormat);

    // CPersistence overrides
    protected:
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(DataFormats,              // name
                                &CLSID_DataFormats,       // clsid
                                "DataFormats",            // objname
                                "DataFormats",            // lblname
                                &CDataFormats::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IDataFormats,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _DATAFMTS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobj.cpp ===
//=--------------------------------------------------------------------------=
// dataobj.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObject class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "dataobj.h"
#include "xtensons.h"
#include "xtenson.h"

// for ASSERT and FAIL
//
SZTHISFILE

BOOL CMMCDataObject::m_ClipboardFormatsRegistered = FALSE;
BOOL CMMCDataObject::m_fUsingUNICODEFormats = FALSE;

CLIPFORMAT CMMCDataObject::m_cfDisplayName              = 0;
CLIPFORMAT CMMCDataObject::m_cfNodeType                 = 0;
CLIPFORMAT CMMCDataObject::m_cfSzNodeType               = 0;
CLIPFORMAT CMMCDataObject::m_cfSnapinClsid              = 0;
CLIPFORMAT CMMCDataObject::m_cfWindowTitle              = 0;
CLIPFORMAT CMMCDataObject::m_cfDyanmicExtensions        = 0;
CLIPFORMAT CMMCDataObject::m_cfSnapInPreloads           = 0;
CLIPFORMAT CMMCDataObject::m_cfObjectTypesInMultiSelect = 0;
CLIPFORMAT CMMCDataObject::m_cfMultiSelectSnapIns       = 0;
CLIPFORMAT CMMCDataObject::m_cfMultiSelectDataObject    = 0;
CLIPFORMAT CMMCDataObject::m_cfSnapInInstanceID         = 0;
CLIPFORMAT CMMCDataObject::m_cfThisPointer              = 0;
CLIPFORMAT CMMCDataObject::m_cfNodeID                   = 0;
CLIPFORMAT CMMCDataObject::m_cfNodeID2                  = 0;
CLIPFORMAT CMMCDataObject::m_cfColumnSetID              = 0;

#if defined(DEBUG)
long g_cDataObjects = 0;
#endif


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCDataObject::CMMCDataObject(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCDATAOBJECT,
                            static_cast<IMMCDataObject *>(this),
                            static_cast<CMMCDataObject *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
#if defined(DEBUG)
    g_cDataObjects++;
#endif
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCDataObject::~CMMCDataObject()
{
#if defined(DEBUG)
    g_cDataObjects--;
#endif

    FREESTRING(m_bstrKey);

#if defined(USING_SNAPINDATA)
    RELEASE(m_piDefaultFormat);
#endif

    if (NULL != m_pSnapIn)
    {
        m_pSnapIn->Release();
    }

    if (NULL != m_pScopeItems)
    {
        m_pScopeItems->Release();
    }

    if (NULL != m_pScopeItem)
    {
        m_pScopeItem->Release();
    }

    if (NULL != m_pListItems)
    {
        m_pListItems->Release();
    }

    if (NULL != m_pListItem)
    {
        m_pListItem->Release();
    }

    FREESTRING(m_bstrCaption);
    RELEASE(m_piDataObjectForeign);

    if (NULL != m_pMMCObjectTypes)
    {
        ::CtlFree(m_pMMCObjectTypes);
    }

    (void)Clear();

    InitMemberVariables();
}

void CMMCDataObject::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

#if defined(USING_SNAPINDATA)
    m_piDefaultFormat = NULL;
#endif

    m_pSnapIn = NULL;
    m_pScopeItems = NULL;
    m_pScopeItem = NULL;
    m_pListItems = NULL;
    m_pListItem = NULL;
    m_bstrCaption = NULL;
    m_piDataObjectForeign = NULL;
    m_Type = ScopeItem;
    m_Context = CCT_UNINITIALIZED;
    m_pMMCObjectTypes = NULL;
    m_cFormats = 0;
    m_pcfFormatsANSI = NULL;
    m_pcfFormatsUNICODE = NULL;
    m_paData = NULL;
}

IUnknown *CMMCDataObject::Create(IUnknown * punkOuter)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = New CMMCDataObject(punkOuter);

    if (NULL == pMMCDataObject)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(RegisterClipboardFormats());

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCDataObject)
        {
            delete pMMCDataObject;
        }
        return NULL;
    }
    else
    {
        return pMMCDataObject->PrivateUnknown();
    }
}

HRESULT CMMCDataObject::RegisterClipboardFormats()
{
    HRESULT    hr = S_OK;
    FormatType Type = ANSI; // assume Win9x

    OSVERSIONINFO VerInfo;
    ::ZeroMemory(&VerInfo, sizeof(VerInfo));

    // If formats are already registered then return S_OK

    IfFalseGo(!m_ClipboardFormatsRegistered, S_OK);

    // Determine whether we are on NT or Win9x so that we know whether to
    // register clipboard format strings as UNICODE or ANSI.

    VerInfo.dwOSVersionInfoSize = sizeof(VerInfo);
    if (!::GetVersionEx(&VerInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (VER_PLATFORM_WIN32_NT == VerInfo.dwPlatformId)
    {
        Type = UNICODE;
        m_fUsingUNICODEFormats = TRUE;
    }

    IfFailGo(RegisterClipboardFormat(CCF_DISPLAY_NAME, &m_cfDisplayName, Type));
    IfFailGo(RegisterClipboardFormat(CCF_NODETYPE, &m_cfNodeType, Type));
    IfFailGo(RegisterClipboardFormat(CCF_SZNODETYPE, &m_cfSzNodeType, Type));
    IfFailGo(RegisterClipboardFormat(CCF_SNAPIN_CLASSID, &m_cfSnapinClsid, Type));
    IfFailGo(RegisterClipboardFormat(CCF_WINDOW_TITLE, &m_cfWindowTitle, Type));
    IfFailGo(RegisterClipboardFormat(CCF_MMC_DYNAMIC_EXTENSIONS, &m_cfDyanmicExtensions, Type));
    IfFailGo(RegisterClipboardFormat(CCF_SNAPIN_PRELOADS, &m_cfSnapInPreloads, Type));
    IfFailGo(RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT, &m_cfObjectTypesInMultiSelect, Type));
    IfFailGo(RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS, &m_cfMultiSelectSnapIns, Type));
    IfFailGo(RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT, &m_cfMultiSelectDataObject, Type));
    IfFailGo(RegisterClipboardFormat(L"SnapInDesigner-SnapInInstanceID", &m_cfSnapInInstanceID, Type));
    IfFailGo(RegisterClipboardFormat(L"SnapInDesigner-ThisPointer", &m_cfThisPointer, Type));
    IfFailGo(RegisterClipboardFormat(CCF_NODEID, &m_cfNodeID, Type));
    IfFailGo(RegisterClipboardFormat(CCF_NODEID2, &m_cfNodeID2, Type));
    IfFailGo(RegisterClipboardFormat(CCF_COLUMN_SET_ID, &m_cfColumnSetID, Type));
    m_ClipboardFormatsRegistered = TRUE;

Error:
    RRETURN(hr);
}

HRESULT CMMCDataObject::RegisterClipboardFormat
(
    WCHAR       *pwszFormatName,
    CLIPFORMAT  *pcfFormat,
    FormatType   Type
)
{
    HRESULT  hr = S_OK;
    char    *pszFormatName = NULL;

    if (ANSI == Type)
    {
        IfFailGo(::ANSIFromWideStr(pwszFormatName, &pszFormatName));
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatA(pszFormatName));
    }
    else
    {
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatW(pwszFormatName));
    }

    if (0 == *pcfFormat)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pszFormatName)
    {
        ::CtlFree(pszFormatName);
    }
    RRETURN(hr);
}


void CMMCDataObject::SetSnapIn(CSnapIn *pSnapIn)
{
    if (NULL != m_pSnapIn)
    {
        m_pSnapIn->Release();
    }
    if (NULL != pSnapIn)
    {
        pSnapIn->AddRef();
    }
    m_pSnapIn = pSnapIn;
}


void CMMCDataObject::SetType(Type type)
{
    m_Type = type;
}

CMMCDataObject::Type CMMCDataObject::GetType()
{
    return m_Type;
}

void CMMCDataObject::SetScopeItems(CScopeItems *pScopeItems)
{
    if (NULL != m_pScopeItems)
    {
        m_pScopeItems->Release();
    }
    if (NULL != pScopeItems)
    {
        pScopeItems->AddRef();
    }
    m_pScopeItems = pScopeItems;
}

CScopeItems *CMMCDataObject::GetScopeItems()
{
    return m_pScopeItems;
}


void CMMCDataObject::SetScopeItem(CScopeItem *pScopeItem)
{
    if (NULL != m_pScopeItem)
    {
        m_pScopeItem->Release();
    }
    if (NULL != pScopeItem)
    {
        pScopeItem->AddRef();
    }
    m_pScopeItem = pScopeItem;
}

CScopeItem *CMMCDataObject::GetScopeItem()
{
    return m_pScopeItem;
}


void CMMCDataObject::SetListItems(CMMCListItems *pListItems)
{
    if (NULL != m_pListItems)
    {
        m_pListItems->Release();
    }
    if (NULL != pListItems)
    {
        pListItems->AddRef();
    }
    m_pListItems = pListItems;
}

CMMCListItems *CMMCDataObject::GetListItems()
{
    return m_pListItems;
}

void CMMCDataObject::SetListItem(CMMCListItem *pListItem)
{
    m_pListItem = pListItem;
}

CMMCListItem *CMMCDataObject::GetListItem()
{
    return m_pListItem;
}


HRESULT CMMCDataObject::SetCaption(BSTR bstrCaption)
{
    RRETURN(CSnapInAutomationObject::SetBstr(bstrCaption, &m_bstrCaption, 0));
}


void CMMCDataObject::SetForeignData(IDataObject *piDataObject)
{
    RELEASE(m_piDataObjectForeign);
    if (NULL != piDataObject)
    {
        piDataObject->AddRef();
    }
    m_piDataObjectForeign = piDataObject;
}


HRESULT CMMCDataObject::WriteDisplayNameToStream(IStream *piStream)
{
    HRESULT hr = S_OK;

    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);
    IfFalseGo(NULL != m_pScopeItem, DV_E_CLIPFORMAT);

    IfFailGo(WriteWideStrToStream(piStream,
                            m_pScopeItem->GetScopeNode()->GetDisplayNamePtr()));
Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteSnapInCLSIDToStream(IStream *piStream)
{
    HRESULT   hr = S_OK;
    WCHAR    *pwszClsid = NULL;
    char      szClsid[256] = "";
    
    IfFalseGo(NULL != m_pSnapIn, DV_E_CLIPFORMAT);

    IfFailGo(::GetSnapInCLSID(m_pSnapIn->GetNodeTypeGUID(),
                              szClsid, sizeof(szClsid)));

    IfFailGo(::WideStrFromANSI(szClsid, &pwszClsid));
    IfFailGo(WriteGUIDToStream(piStream, pwszClsid));

Error:
    if (NULL != pwszClsid)
    {
        ::CtlFree(pwszClsid);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CMMCDataObject::WriteDynamicExtensionsToStream
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IStream *piStream [in] stream to which SMMCDynamicExtensions structure
//                             is written
//
// Output:
//      HRESULT
//
// Notes:
//
// If the data object is not for a scope item or a list item then return
// DV_E_CLIPFORMAT.
//
// If the scope item or list item does not have any dynamic extenions then
// return DV_E_CLIPFORMAT.
//
// Get the DynamicExtensions collection for the scope item or list item and
// write an SMMCDynamicExtensions structure to the stream containing the CLISDs
// of all the enabled extensions.
//
// SMMCDynamicExtensions is typedefed to be an SMMCObjectTypes which looks like
// this:
//
// typedef struct  _SMMCObjectTypes
// {
//     DWORD count;
//     GUID guid[ 1 ];
// } SMMCObjectTypes;
//
// As the array of GUIDs might be padded using the default alignment, when
// writing consecutive CLSIDs to the stream we need to account for that. This
// is done by creating an array of two clsids, filling the first one, and writing
// half the size of the array.
// 
// A note on the choice of using a stream for this format: at the time of this
// writing MMC only requests this format in an HGLOBAL. CMMCDataObject has been
// written to create a stream on an HGLOBAL in a data request in order to
// conveniently support TYMED_ISTREAM and TYMED_HGLOBAL without duplicating code.
// In the case of this format where iterating a collection is required to
// discover the actual size of the data, we could either iterate twice or do
// reallocs. I chose the reallocs for the ease of programming and from a perf
// perspective it is probably close. Given that extending a stream on an
// HGLOBAL consists of reallocs I decided to go for ease and consistency in the
// code rather than the small potential perf increase with the added complexity.
//
// Peter Shier 1-8-99
//

HRESULT CMMCDataObject::WriteDynamicExtensionsToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    long         cExtensions = 0;
    long         i = 0;
    DWORD        cEnabled = 0;
    IExtensions *piExtensions = NULL; // Not AddRef()ed
    CExtensions *pExtensions = NULL;
    CExtension  *pExtension = NULL;

    CLSID clsids[2];
    ::ZeroMemory(clsids, sizeof(clsids));

    LARGE_INTEGER liOffset;
    ::ZeroMemory(&liOffset, sizeof(liOffset));

    ULARGE_INTEGER uliStartSeekPos;
    ::ZeroMemory(&uliStartSeekPos, sizeof(uliStartSeekPos));

    ULARGE_INTEGER uliEndSeekPos;
    ::ZeroMemory(&uliEndSeekPos, sizeof(uliEndSeekPos));

    // Get the IExtensions collection for the object

    if (ScopeItem == m_Type)
    {
        piExtensions = m_pScopeItem->GetDynamicExtensions();
        IfFalseGo(NULL != piExtensions, DV_E_CLIPFORMAT);
    }
    else if (ListItem == m_Type)
    {
        piExtensions = m_pListItem->GetDynamicExtensions();
        IfFalseGo(NULL != piExtensions, DV_E_CLIPFORMAT);
    }
    else
    {
        IfFailGo(DV_E_CLIPFORMAT);
    }

    // Check whether there are any extensions in the collection

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piExtensions, &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(0 != cExtensions, DV_E_CLIPFORMAT); 

    // Get the current seek pointer so that we can later rewind and write the
    // correct number of clsids.

    hr = piStream->Seek(liOffset, STREAM_SEEK_CUR, &uliStartSeekPos);
    EXCEPTION_CHECK_GO(hr);

    // Write a bogus number of enabled extensions so that we can fill it in
    // later

    IfFailGo(WriteToStream(piStream, &cEnabled, sizeof(cEnabled)));

    // Iterate through the collection and use each non-namespace extension
    // that is enabled

    for (i = 0; i < cExtensions; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                   pExtensions->GetItemByIndex(i), &pExtension));

        if (!pExtension->Enabled())
        {
            continue;
        }

        if ( (pExtension->ExtendsContextMenu())   ||
             (pExtension->ExtendsToolbar())       ||
             (pExtension->ExtendsPropertySheet()) ||
             (pExtension->ExtendsTaskpad())
           )
        {
            hr = ::CLSIDFromString(pExtension->GetCLSID(), &clsids[0]);
            EXCEPTION_CHECK_GO(hr);

            // Write the CLSID. Use the clsids array to make sure that we
            // write a correctly padded number of bytes

            IfFailGo(WriteToStream(piStream, &clsids[0], sizeof(clsids) / 2));
            cEnabled++;
        }
    }

    // If none were enabled then don't return the format. Rewind the stream
    // so that is untouched in this case.

    if (0 == cEnabled)
    {
        liOffset.LowPart = uliStartSeekPos.LowPart;
        liOffset.HighPart = uliStartSeekPos.HighPart;

        hr = piStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
        EXCEPTION_CHECK_GO(hr);

        IfFailGo(DV_E_CLIPFORMAT);
    }

    // Some extensions are enabled. We need to write the correct count
    // of enabled extensions at the stream starting point

    // Get the final stream pointer so we can restore it after rewriting the
    // count

    hr = piStream->Seek(liOffset, STREAM_SEEK_CUR, &uliEndSeekPos);
    EXCEPTION_CHECK_GO(hr);

    // Seek back to the starting stream position and write the correct count

    liOffset.LowPart = uliStartSeekPos.LowPart;
    liOffset.HighPart = uliStartSeekPos.HighPart;
    
    hr = piStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
    EXCEPTION_CHECK_GO(hr);

    IfFailGo(WriteToStream(piStream, &cEnabled, sizeof(cEnabled)));

    // Restore the stream pointer to the end of the stream

    liOffset.LowPart = uliEndSeekPos.LowPart;
    liOffset.HighPart = uliEndSeekPos.HighPart;

    hr = piStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



HRESULT CMMCDataObject::WritePreloadsToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    BOOL    fPreloads = FALSE;

    if (NULL != m_pSnapIn)
    {
        fPreloads = m_pSnapIn->GetPreload();
    }

    IfFailGo(WriteToStream(piStream, &fPreloads, sizeof(fPreloads)));

Error:
    RRETURN(hr);
}



HRESULT CMMCDataObject::WriteSnapInInstanceIDToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    DWORD   SnapInInstanceID = 0;

    if (NULL == m_pSnapIn)
    {
        hr = DV_E_CLIPFORMAT;
    }
    else
    {
        SnapInInstanceID = GetSnapInInstanceID();
        IfFailGo(WriteToStream(piStream, &SnapInInstanceID, sizeof(SnapInInstanceID)));
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteNodeIDToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    BSTR    bstrNodeID = NULL; // Not allocated, do not free

    SNodeID SNodeIDStruct;
    ::ZeroMemory(&SNodeIDStruct, sizeof(SNodeIDStruct));

    // If this is not a single scope item then we don't have the format.
    
    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);

    bstrNodeID = m_pScopeItem->GetNodeID();

    if ( (!m_pScopeItem->SlowRetrieval()) && ValidBstr(bstrNodeID) )
    {
        // The snap-in says this node is not slow to retrieve and has
        // supplied a valid node ID. Return the node ID.

        SNodeIDStruct.cBytes = ::wcslen(bstrNodeID) * sizeof(WCHAR);

        // Note that in order to preserve alignment without having to reallocate
        // a real SNodeID we calculate the actual size of the ID portion of
        // the struct by subtracting the address of the struct from the address
        // of the the ID.
        
        IfFailGo(WriteToStream(piStream, &SNodeIDStruct,
                               (BYTE *)&SNodeIDStruct.id - (BYTE *)&SNodeIDStruct));

        IfFailGo(WriteToStream(piStream, bstrNodeID, SNodeIDStruct.cBytes));
    }
    else
    {
        // The snap-in has either indicated that that the node is slow to
        // retrieve or has set an empty node ID. Return a zero-length node ID.

        IfFailGo(WriteToStream(piStream, &SNodeIDStruct, sizeof(SNodeIDStruct)));
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteNodeID2ToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    BSTR    bstrNodeID = NULL; // Not allocated, do not free

    SNodeID2 SNodeID2Struct;
    ::ZeroMemory(&SNodeID2Struct, sizeof(SNodeID2Struct));

    // If this is not a single scope item then we don't have the format.

    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);

    bstrNodeID = m_pScopeItem->GetNodeID();

    // If the snap-in has set an empty node ID then we cannot return this
    // format.
    
    IfFalseGo(ValidBstr(bstrNodeID), DV_E_CLIPFORMAT);

    if (m_pScopeItem->SlowRetrieval())
    {
        SNodeID2Struct.dwFlags = MMC_NODEID_SLOW_RETRIEVAL;
    }

    SNodeID2Struct.cBytes = ::wcslen(bstrNodeID) * sizeof(WCHAR);

    // Note that in order to preserve alignment without having to reallocate
    // a real SNodeID we calculate the actual size of the ID portion of
    // the struct by subtracting the address of the struct from the address
    // of the the ID.

    IfFailGo(WriteToStream(piStream, &SNodeID2Struct,
                           (BYTE *)&SNodeID2Struct.id - (BYTE *)&SNodeID2Struct));

    IfFailGo(WriteToStream(piStream, bstrNodeID, SNodeID2Struct.cBytes));

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteColumnSetIDToStream(IStream *piStream)
{
    HRESULT          hr = S_OK;
    CView           *pCurrentView = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    IScopePaneItem  *piScopePaneItem = NULL;
    BSTR             bstrColumnSetID = NULL; // Not allocated, do not free

    SNodeID2 SNodeID2Struct;
    ::ZeroMemory(&SNodeID2Struct, sizeof(SNodeID2Struct));

    // If this is not a single scope item then we don't have the format.

    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);

    // The column set ID is obtained from the ScopePaneItem
    // in Views.CurrentView.ScopePaneItems that corresponds to the ScopeItem
    // that owns this data object.

    IfFalseGo(NULL != m_pSnapIn, DV_E_CLIPFORMAT);

    pCurrentView = m_pSnapIn->GetCurrentView();
    IfFalseGo(NULL != pCurrentView, DV_E_CLIPFORMAT);

    pScopePaneItems = pCurrentView->GetScopePaneItems();
    IfFalseGo(NULL != pScopePaneItems, DV_E_CLIPFORMAT);

    // If the ScopePaneItem is not there then create it now because when MMC
    // retrieves this data format it is due to the selection of the ScopeItem
    // in the scope pane or the restoration of the selection following console
    // load.

    hr = pScopePaneItems->GetItemByName(m_pScopeItem->GetNamePtr(),
                                        &piScopePaneItem);
    if (SUCCEEDED(hr))
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem,
                                                       &pScopePaneItem));
    }
    else if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        IfFailGo(pScopePaneItems->AddNode(m_pScopeItem, &pScopePaneItem));
    }
    else
    {
        IfFailGo(hr);
    }

    bstrColumnSetID = pScopePaneItem->GetColumnSetID();

    IfFalseGo(ValidBstr(bstrColumnSetID), DV_E_CLIPFORMAT);

    SNodeID2Struct.cBytes = ::wcslen(bstrColumnSetID) * sizeof(WCHAR);

    // Note that in order to preserve alignment without having to reallocate
    // a real SNodeID2 we calculate the actual size of the ID portion of
    // the struct by subtracting the address of the struct from the address
    // of the member following the ID.

    IfFailGo(WriteToStream(piStream, &SNodeID2Struct,
                          (BYTE *)&SNodeID2Struct.id - (BYTE *)&SNodeID2Struct));

    IfFailGo(WriteToStream(piStream, bstrColumnSetID, SNodeID2Struct.cBytes));

Error:
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}

HRESULT CMMCDataObject::GetOurObjectTypes()
{
    HRESULT          hr = S_OK;
    long             i = 0;
    long             cScopeItems = 0;
    long             cListItems = 0;
    CScopeItem      *pScopeItem = NULL;
    CMMCListItem    *pMMCListItem = NULL;
    CScopeNode      *pScopeNode = NULL;
    GUID             guid = GUID_NULL;
    size_t           cMaxGuids = 0;

    // Determine how many objects we have

    if (NULL != m_pScopeItems)
    {
        cScopeItems = m_pScopeItems->GetCount();
    }

    if (NULL != m_pListItems)
    {
        cListItems = m_pListItems->GetCount();
    }

    // Allocate the SMMCObjectTypes structure using the maximum possible
    // number of GUIDs. After iterating through the items we are holding the
    // real number will be determined and that will be written to the stream.

    cMaxGuids = cScopeItems + cListItems;
    if (cMaxGuids > 0)
    {
        cMaxGuids--; // sub 1 because the structure defines an array of 1
    }

    m_pMMCObjectTypes = (SMMCObjectTypes *)::CtlAllocZero(
        sizeof(*m_pMMCObjectTypes) + cMaxGuids * sizeof(GUID));
    if (NULL == m_pMMCObjectTypes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    for (i = 0; i < cScopeItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
            m_pScopeItems->GetItemByIndex(i), &pScopeItem));
        pScopeNode = pScopeItem->GetScopeNode();
        if (NULL != pScopeNode)
        {
            hr = ::CLSIDFromString(pScopeNode->GetNodeTypeGUID(),
                                   &guid);
            EXCEPTION_CHECK_GO(hr);
            AddGuid(m_pMMCObjectTypes, &guid);
        }
    }

    for (i = 0; i < cListItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
            m_pListItems->GetItemByIndex(i), &pMMCListItem));
        hr = ::CLSIDFromString(pMMCListItem->GetNodeTypeGUID(),
                               &guid);
        EXCEPTION_CHECK_GO(hr);
        AddGuid(m_pMMCObjectTypes, &guid);
    }

Error:
    if ( (FAILED(hr)) && (NULL != m_pMMCObjectTypes) )
    {
        ::CtlFree(m_pMMCObjectTypes);
        m_pMMCObjectTypes = NULL;
    }
    RRETURN(hr);
}


HRESULT CMMCDataObject::GetForeignObjectTypes()
{
    HRESULT          hr = S_OK;
    SMMCObjectTypes *pMMCObjectTypes = NULL;
    BOOL             fGotData = FALSE;
    size_t           cbObjectTypes = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    if (NULL == m_piDataObjectForeign)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    FmtEtc.cfFormat = m_cfObjectTypesInMultiSelect;
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
    if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) )
    {
        hr = SID_E_FORMAT_NOT_AVAILABLE;
    }
    EXCEPTION_CHECK_GO(hr);

    fGotData = TRUE;

    pMMCObjectTypes = (SMMCObjectTypes *)::GlobalLock(StgMed.hGlobal);
    if (NULL == pMMCObjectTypes)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    cbObjectTypes = sizeof(*pMMCObjectTypes) +
                    (pMMCObjectTypes->count * sizeof(GUID)) -
                    sizeof(GUID);

    m_pMMCObjectTypes = (SMMCObjectTypes *)::CtlAllocZero(cbObjectTypes);
    if (NULL == m_pMMCObjectTypes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(m_pMMCObjectTypes, pMMCObjectTypes, cbObjectTypes);

Error:
    if (NULL != pMMCObjectTypes)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ::ReleaseStgMedium(&StgMed);
    }

    RRETURN(hr);
}


HRESULT CMMCDataObject::GetObjectTypes()
{
    HRESULT hr = S_OK;

    if (Foreign == m_Type)
    {
        IfFailGo(GetForeignObjectTypes());
    }
    else
    {
        IfFailGo(GetOurObjectTypes());
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteObjectTypesToStream(IStream *piStream)
{
    HRESULT hr = S_OK;

    if (NULL == m_pMMCObjectTypes)
    {
        IfFailGo(GetObjectTypes());
    }

    if (m_pMMCObjectTypes->count > 0)
    {
        IfFailGo(WriteToStream(piStream, m_pMMCObjectTypes,
                          sizeof(*m_pMMCObjectTypes) +
                          sizeof(GUID) * (m_pMMCObjectTypes->count - (DWORD)1)));
    }
    else
    {
        hr = DV_E_CLIPFORMAT;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



void CMMCDataObject::AddGuid(SMMCObjectTypes *pMMCObjectTypes, GUID *pguid)
{
    DWORD i = 0;
    BOOL  fFound = FALSE;

    while ( (i < pMMCObjectTypes->count) && (!fFound) )
    {
        if (pMMCObjectTypes->guid[i] == *pguid)
        {
            fFound = TRUE;
        }
        i++;
    }

    if (!fFound)
    {
        pMMCObjectTypes->guid[pMMCObjectTypes->count] = *pguid;
        pMMCObjectTypes->count++;
    }
}


HRESULT CMMCDataObject::WriteGUIDToStream
(
    IStream *piStream,
    OLECHAR *pwszGUID
)
{
    HRESULT hr = S_OK;
    GUID    guid = GUID_NULL;

    hr = ::CLSIDFromString(pwszGUID, &guid); 
    EXCEPTION_CHECK_GO(hr);

    hr = WriteToStream(piStream, &guid, sizeof(guid));

Error:
    RRETURN(hr);
}



HRESULT CMMCDataObject::WriteWideStrToStream
(
    IStream *piStream,
    WCHAR   *pwszString
)
{
    size_t  cbString = sizeof(WCHAR); // for terminating null

    if (NULL != pwszString)
    {
        cbString += (::wcslen(pwszString) * sizeof(WCHAR));
    }
    else
    {
        pwszString = L"";
    }
    RRETURN(WriteToStream(piStream, pwszString, static_cast<ULONG>(cbString)));
}


HRESULT CMMCDataObject::WriteToStream
(
    IStream *piStream,
    void    *pvBuffer,
    ULONG    cbToWrite
)
{
    ULONG   cbWritten = 0;
    HRESULT hr = piStream->Write(pvBuffer, cbToWrite, &cbWritten);
    EXCEPTION_CHECK_GO(hr);
    if (cbWritten != cbToWrite)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        EXCEPTION_CHECK(hr);
    }
Error:
    RRETURN(hr);
}


DWORD CMMCDataObject::GetSnapInInstanceID()
{
    if (NULL != m_pSnapIn)
    {
        return m_pSnapIn->GetInstanceID();
    }
    else
    {
        return 0;
    }
}


BOOL CMMCDataObject::GetFormatIndex(CLIPFORMAT cfFormat, ULONG *piFormat)
{
    ULONG i = 0;
    BOOL  fFound = FALSE;

    if (NULL != m_pcfFormatsANSI)
    {
        while ( (i < m_cFormats) && (!fFound) )
        {
            if (cfFormat == m_pcfFormatsANSI[i])
            {
                fFound = TRUE;
                *piFormat = i;
            }
            i++;
        }
    }
    if ( (!fFound) && (NULL != m_pcfFormatsUNICODE) )
    {
        while ( (i < m_cFormats) && (!fFound) )
        {
            if (cfFormat == m_pcfFormatsUNICODE[i])
            {
                fFound = TRUE;
                *piFormat = i;
            }
            i++;
        }
    }
    return fFound;
}


HRESULT CMMCDataObject::GetSnapInData(CLIPFORMAT cfFormat, IStream *piStream)
{
    HRESULT   hr = S_OK;
    ULONG     iFormat = 0;
    IUnknown *punkObject = NULL; // Not AddRef()ed

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    // Use a CStreamer object for its ability to write a VARIANT to a stream
    
    CStreamer *pStreamer = New CStreamer();

    if (NULL == pStreamer)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    pStreamer->SetStream(piStream);

    // Check if this is a snap-in defined format
    
    if (!GetFormatIndex(cfFormat, &iFormat))
    {
        hr = DV_E_CLIPFORMAT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Write the data to the stream. For BSTR's and UI1 arrays we don't call
    // CStreamer::StreamVariant() because it prepends the length for a
    // BSTR and it doesn't support arrays.

    switch (m_paData[iFormat].varData.vt)
    {
        case VT_UI1:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_DATE:
        case VT_CY:
            IfFailGo(pStreamer->StreamVariant(m_paData[iFormat].varData.vt,
                                              &m_paData[iFormat].varData,
                                              varDefault));
            break;

        case VT_UNKNOWN:
        case VT_DISPATCH:
            if (siPersistedObject == m_paData[iFormat].ObjectFormat)
            {
                IfFailGo(pStreamer->StreamVariant(m_paData[iFormat].varData.vt,
                                                  &m_paData[iFormat].varData,
                                                  varDefault));
            }
            else
            {
                if (VT_UNKNOWN == m_paData[iFormat].varData.vt)
                {
                    punkObject = m_paData[iFormat].varData.punkVal;
                }
                else
                {
                    punkObject = static_cast<IUnknown *>(m_paData[iFormat].varData.pdispVal);
                }
                hr = ::CoMarshalInterface(piStream,
                                          IID_IUnknown,
                                          punkObject,
                                          MSHCTX_INPROC, NULL,
                                          MSHLFLAGS_NORMAL);
                EXCEPTION_CHECK_GO(hr);
            }
            break;


        case VT_ARRAY | VT_UI1:
            IfFailGo(::WriteSafeArrayToStream(m_paData[iFormat].varData.parray,
                                              piStream,
                                              DontWriteLength));
            break;

        case VT_BSTR:
            IfFailGo(WriteWideStrToStream(piStream,
                                          m_paData[iFormat].varData.bstrVal));
            break;

        case VT_ARRAY | VT_BSTR:
            IfFailGo(WriteStringArrayToStream(piStream,
                                              m_paData[iFormat].varData.parray));
            break;

        default:
            hr = DV_E_CLIPFORMAT;
            EXCEPTION_CHECK_GO(hr);
            break;
    }

Error:
    if (NULL != pStreamer)
    {
        delete pStreamer;
    }
    RRETURN(hr);
}



HRESULT CMMCDataObject::WriteStringArrayToStream
(
    IStream   *piStream,
    SAFEARRAY *psaStrings
)
{
    HRESULT     hr = S_OK;
    LONG        lUBound = 0;
    LONG        lLBound = 0;
    LONG        cStrings = 0;
    LONG        i = 0;
    WCHAR       wchNull = L'\0';
    BSTR HUGEP *pbstr = NULL;

    // Get the upper and lower bounds to determine the number of strings

    hr = ::SafeArrayGetLBound(psaStrings, 1, &lLBound);
    EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(psaStrings, 1, &lUBound);
    EXCEPTION_CHECK_GO(hr);

    cStrings = (lUBound - lLBound) + 1L;

    // Access the array data and write the strings one after the other into
    // the stream

    hr = ::SafeArrayAccessData(psaStrings,
                               reinterpret_cast<void HUGEP **>(&pbstr));
    EXCEPTION_CHECK_GO(hr);

    for (i = 0; i < cStrings; i++)
    {
        IfFailGo(WriteWideStrToStream(piStream, pbstr[i]));
    }

    // Write a terminating null to the stream (giving a double null at the end)

    IfFailGo(WriteToStream(piStream, &wchNull, sizeof(wchNull)));

Error:
    if (NULL != pbstr)
    {
        (void)::SafeArrayUnaccessData(psaStrings);
    }
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                         IMMCDataObject Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCDataObject::get_ObjectTypes(SAFEARRAY **ppsaObjectTypes)
{
    HRESULT     hr = S_OK;
    DWORD       i = 0;
    OLECHAR     wszGUID[64];
    BSTR HUGEP *pbstr = NULL;

    if (NULL == ppsaObjectTypes)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    *ppsaObjectTypes = NULL;

    // First make sure we have the set of unique object types

    if (NULL == m_pMMCObjectTypes)
    {
        IfFailGo(GetObjectTypes());
    }

    // Allocate a SafeArray of BSTRs to hold the object type GUIDs

    *ppsaObjectTypes = ::SafeArrayCreateVector(VT_BSTR, 1,
                           static_cast<unsigned long>(m_pMMCObjectTypes->count));
    if (NULL == *ppsaObjectTypes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ::SafeArrayAccessData(*ppsaObjectTypes,
                               reinterpret_cast<void HUGEP **>(&pbstr));
    EXCEPTION_CHECK_GO(hr);

    for (i = 0; i < m_pMMCObjectTypes->count; i++)
    {
        if (0 == ::StringFromGUID2(m_pMMCObjectTypes->guid[i], wszGUID,
                                   sizeof(wszGUID) / sizeof (wszGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        pbstr[i] = ::SysAllocString(wszGUID);
        if (NULL == pbstr[i])
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (NULL != pbstr)
    {
        (void)::SafeArrayUnaccessData(*ppsaObjectTypes);
    }

    if (FAILED(hr) && (NULL != *ppsaObjectTypes))
    {
        (void)::SafeArrayDestroy(*ppsaObjectTypes);
        *ppsaObjectTypes = NULL;
    }

    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::Clear()
{
    ULONG i = 0;

    if ( (0 != m_cFormats) && (NULL != m_paData) )
    {
        for (i = 0; i < m_cFormats; i++)
        {
            (void)::VariantClear(&m_paData[i].varData);
        }
        ::CtlFree(m_paData);
        m_paData = NULL;
        m_cFormats = 0;
    }

    if (NULL != m_pcfFormatsANSI)
    {
        ::CtlFree(m_pcfFormatsANSI);
        m_pcfFormatsANSI = NULL;
    }

    if (NULL != m_pcfFormatsUNICODE)
    {
        ::CtlFree(m_pcfFormatsUNICODE);
        m_pcfFormatsUNICODE = NULL;
    }
    return S_OK;
}


#if defined(USING_SNAPINDATA)
STDMETHODIMP CMMCDataObject::GetData
(
    BSTR          Format,
    ISnapInData **ppiSnapInData
)
{
    // UNDONE
    return E_NOTIMPL;
}
#endif


#if defined(USING_SNAPINDATA)
STDMETHODIMP CMMCDataObject::GetRawData
#else
STDMETHODIMP CMMCDataObject::GetData
#endif
(
    BSTR     Format,
    VARIANT  MaximumLength,
    VARIANT *pvarData
)
{
    HRESULT     hr = S_OK;
    ULONG       iFormat = 0;
    BOOL        fGotData = FALSE;
    DWORD       dwSize = 0;
    void       *pvSourceData = NULL;
    void HUGEP *pvArrayData = NULL;
    long        cbMax = 0;
    CLIPFORMAT  cfANSI = 0;
    CLIPFORMAT  cfUNICODE = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    STATSTG StatStg;
    ::ZeroMemory(&StatStg, sizeof(StatStg));

    // Check arguments

    if (NULL == pvarData)
    {
        hr = SID_E_INVALIDARG;
    }
    else
    {
        ::VariantInit(pvarData);
        if (NULL == Format)
        {
            hr = SID_E_INVALIDARG;
        }
        else if (ISPRESENT(MaximumLength))
        {
            hr = ::ConvertToLong(MaximumLength, &cbMax);
            if (S_FALSE == hr)
            {
                hr = SID_E_INVALIDARG;
            }
        }
    }
    EXCEPTION_CHECK_GO(hr);

    // Get the clipformat

    IfFailGo(RegisterClipboardFormat(Format, &cfANSI, ANSI));
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(RegisterClipboardFormat(Format, &cfUNICODE, UNICODE));
    }

    // If this is one of our own data objects then find the format and
    // copy the VARIANT

    if (Foreign != m_Type)
    {
        if (!GetFormatIndex(cfANSI, &iFormat))
        {
            hr = SID_E_FORMAT_NOT_AVAILABLE;
            EXCEPTION_CHECK_GO(hr);
        }
        hr = ::VariantCopy(pvarData, &m_paData[iFormat].varData);
        EXCEPTION_CHECK_GO(hr);
        goto Cleanup;
    }

    // This is a foreign data object. Need to request the data and copy it
    // to a SafeArray of Byte within the returned variant

    if (NULL == m_piDataObjectForeign)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }


    // Get the data from the foreign data object.
    // If maximum length is specified then do GetDataHere(TYMED_HGLOBAL)
    // Else try in this order:
    //  GetData(TYMED_HGLOBAL)
    //  GetData(TYMED_ISTREAM)
    //  GetDataHere(TYMED_ISTREAM)
    //  GetDataHere(TYMED_HGLOBAL) with a 1K buffer
    //
    // In all cases, if on a UNICODE system (NT4, Win2K) then try both ANSI
    // and UNICODE CLIPFORMATs as we have no way of knowing how the snap-in
    // registers its format.

    FmtEtc.cfFormat = cfANSI;
    FmtEtc.dwAspect = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    if (0 != cbMax)
    {
        StgMed.hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, cbMax);
        if (NULL == StgMed.hGlobal)
        {
            hr = HRESULT_FROM_WIN32(hr);
            EXCEPTION_CHECK_GO(hr);
        }
        hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
        if (FAILED(hr) && m_fUsingUNICODEFormats)
        {
            FmtEtc.cfFormat = cfUNICODE;
            hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
        }
        EXCEPTION_CHECK_GO(hr);
        goto CopyData;
    }

    // No maximum length. Try the options listed above. Start with
    // GetData(TYMED_HGLOBAL)
    
    hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
    if (FAILED(hr) && m_fUsingUNICODEFormats)
    {
        FmtEtc.cfFormat = cfUNICODE;
        hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
    }
    if (FAILED(hr))
    {
        // GetData(TYMED_HGLOBAL) didn't work. Try GetData(TYMED_ISTREAM).

        FmtEtc.tymed = TYMED_ISTREAM;
        StgMed.tymed = TYMED_ISTREAM;

        FmtEtc.cfFormat = cfANSI;
        hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
        if (FAILED(hr) && m_fUsingUNICODEFormats)
        {
            FmtEtc.cfFormat = cfUNICODE;
            hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
        }
        if (FAILED(hr))
        {
            // GetData(TYMED_ISTREAM) didn't work.
            // Try GetDataHere(TYMED_ISTREAM)

            hr = ::CreateStreamOnHGlobal(NULL, // stream should allocate buffer
                                         TRUE, // stream should free buffer on release
                                         &StgMed.pstm);
            EXCEPTION_CHECK_GO(hr);

            FmtEtc.cfFormat = cfANSI;
            hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
            if (FAILED(hr) && m_fUsingUNICODEFormats)
            {
                FmtEtc.cfFormat = cfUNICODE;
                hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
            }
            if (FAILED(hr))
            {
                // GetDataHere(TYMED_ISTREAM) didn't work.
                // Try GetDataHere(TYMED_HGLOBAL) with a 1K buffer

                StgMed.pstm->Release();
                StgMed.pstm = NULL;

                StgMed.hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                               1024);
                if (NULL == StgMed.hGlobal)
                {
                    hr = HRESULT_FROM_WIN32(hr);
                    EXCEPTION_CHECK_GO(hr);
                }

                FmtEtc.tymed = TYMED_HGLOBAL;
                StgMed.tymed = TYMED_HGLOBAL;

                FmtEtc.cfFormat = cfANSI;
                hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
                if (FAILED(hr) && m_fUsingUNICODEFormats)
                {
                    FmtEtc.cfFormat = cfUNICODE;
                    hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
    }

    // At this point we have the data and it is either in TYMED_HGLOBAL
    // or TYMED_ISTREAM. First we need to determine how big it is.

CopyData:

    if (TYMED_HGLOBAL == StgMed.tymed)
    {
        dwSize = ::GlobalSize(StgMed.hGlobal);
        if (0 == dwSize)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else if (TYMED_ISTREAM == StgMed.tymed)
    {
        hr = StgMed.pstm->Stat(&StatStg, STATFLAG_NONAME);
        EXCEPTION_CHECK_GO(hr);

        if (0 != StatStg.cbSize.HighPart)
        {
            hr = SID_E_DATA_TOO_LARGE;
            EXCEPTION_CHECK_GO(hr);
        }
        dwSize = StatStg.cbSize.LowPart;
    }
    else
    {
        hr = SID_E_UNSUPPORTED_TYMED;
        EXCEPTION_CHECK_GO(hr);
    }

    // Create the SafeArray and get a pointer to its data buffer

    pvarData->parray = ::SafeArrayCreateVector(VT_UI1, 1,
                                           static_cast<unsigned long>(dwSize));
    if (NULL == pvarData->parray)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    pvarData->vt = VT_ARRAY | VT_UI1;

    hr = ::SafeArrayAccessData(pvarData->parray, &pvArrayData);
    EXCEPTION_CHECK_GO(hr);

    // Get access to the data and copy it to the SafeArray data buffer

    if (TYMED_HGLOBAL == StgMed.tymed)
    {
        pvSourceData = ::GlobalLock(StgMed.hGlobal);
        if (NULL == pvSourceData)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        ::memcpy(pvArrayData, pvSourceData, static_cast<size_t>(dwSize));
    }
    else
    {
        hr = StgMed.pstm->Read(pvArrayData, dwSize, NULL);
        EXCEPTION_CHECK_GO(hr);
    }

Cleanup:
Error:
    if (NULL != pvSourceData)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(pvarData->parray);
    }

    ::ReleaseStgMedium(&StgMed);

    if ( FAILED(hr) && ((VT_ARRAY | VT_UI1) == pvarData->vt) )
    {
        
        (void)::VariantClear(pvarData);
    }

    RRETURN(hr);
}



STDMETHODIMP CMMCDataObject::GetFormat
(
    BSTR          Format,
    VARIANT_BOOL *pfvarHaveFormat
)
{
    HRESULT    hr = S_OK;
    ULONG      iFormat = 0;
    CLIPFORMAT cfANSI = 0;
    CLIPFORMAT cfUNICODE = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));


    if ( (NULL == Format) || (NULL == pfvarHaveFormat) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarHaveFormat = VARIANT_FALSE;

    // Get the clipformat

    IfFailGo(RegisterClipboardFormat(Format, &cfANSI, ANSI));
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(RegisterClipboardFormat(Format, &cfUNICODE, UNICODE));
    }

    if (Foreign != m_Type)
    {
        if (GetFormatIndex(cfANSI, &iFormat))
        {
            *pfvarHaveFormat = VARIANT_TRUE;
        }
        goto Cleanup;
    }

    // This is a foreign data object. Need to query it for the format. We
    // query only for IStream because we get all foreign data that way.

    if (NULL == m_piDataObjectForeign)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    
    FmtEtc.cfFormat = cfANSI;
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_ISTREAM;

    // Query the data object

    hr = m_piDataObjectForeign->QueryGetData(&FmtEtc);
    if (FAILED(hr) && m_fUsingUNICODEFormats)
    {
        FmtEtc.cfFormat = cfUNICODE;
        hr = m_piDataObjectForeign->QueryGetData(&FmtEtc);
    }
    if (SUCCEEDED(hr))
    {
        *pfvarHaveFormat = VARIANT_TRUE;
    }
    else if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) )
    {
        hr = S_OK; // not an error, the format just isn't available.
    }
    else
    {
        EXCEPTION_CHECK_GO(hr);
    }

Cleanup:
Error:

    RRETURN(hr);
}



#if defined(USING_SNAPINDATA)

STDMETHODIMP CMMCDataObject::SetData
(
    ISnapInData *Data,
    BSTR         Format
)
{
    // UNDONE
    return E_NOTIMPL;
}
#endif


#if defined(USING_SNAPINDATA)
STDMETHODIMP CMMCDataObject::SetRawData
#else
STDMETHODIMP CMMCDataObject::SetData
#endif
(
    VARIANT Data,
    BSTR    Format,
    VARIANT ObjectFormat
)
{
    HRESULT     hr = S_OK;
    ULONG       iFormat = 0;
    CLIPFORMAT  cfANSI = 0;
    CLIPFORMAT  cfUNICODE = 0;
    DATA       *paData = NULL;
    long        lObjectFormat = 0;
    BOOL        fIsObject = FALSE;

    SnapInObjectFormatConstants  eObjectFormat = siObjectReference;

    // Make sure we received format

    if (NULL == Format)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the data is an object then check if we received the ObjectFormat
    // parameter that tells us how to respond to IDataObject::GetData

    if (::IsObject(Data))
    {
        fIsObject = TRUE;
        if (ISPRESENT(ObjectFormat))
        {
            if (S_OK != ::ConvertToLong(ObjectFormat, &lObjectFormat))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }

            if (siObjectReference == static_cast<SnapInObjectFormatConstants>(lObjectFormat))
            {
                eObjectFormat = siObjectReference;
            }
            else if (siPersistedObject == static_cast<SnapInObjectFormatConstants>(lObjectFormat))
            {
                eObjectFormat = siPersistedObject;
            }
            else
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
        }
    }

    // Make sure data contains a data type we support

    switch (Data.vt)
    {
        case VT_UI1:
        case VT_I4:
        case VT_I2:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_DATE:
        case VT_CY:
        case VT_BSTR:
        case VT_UNKNOWN:
        case VT_DISPATCH:
            break;

        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_BSTR:
            if (1 != ::SafeArrayGetDim(Data.parray))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            break;

        default:
            hr = SID_E_INVALID_RAW_DATA_TYPE;
            EXCEPTION_CHECK_GO(hr);
    }

    // Check whether the format is already present. If so we need to replace it.

    IfFailGo(RegisterClipboardFormat(Format, &cfANSI, ANSI));
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(RegisterClipboardFormat(Format, &cfUNICODE, UNICODE));
    }

    if (GetFormatIndex(cfANSI, &iFormat))
    {
        // VariantCopy() will call VariantClear() on the destination before
        // copying so we don't need to explicitly do that to the old data.

        hr = ::VariantCopy(&m_paData[iFormat].varData, &Data);
        m_paData[iFormat].ObjectFormat = eObjectFormat;
        EXCEPTION_CHECK_GO(hr);
        goto Cleanup;
    }

    // Format is not present. Need to reallocate arrays.
    // Make room for format name and copy it.

    IfFailGo(ReallocFormats(&m_pcfFormatsANSI));
    m_pcfFormatsANSI[m_cFormats] = cfANSI;
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(ReallocFormats(&m_pcfFormatsUNICODE));
        m_pcfFormatsUNICODE[m_cFormats] = cfUNICODE;
    }

    m_pcfFormatsANSI[m_cFormats] = cfANSI;

    // Make room for data and copy it.

    if (NULL == m_paData)
    {
        paData = (DATA *)::CtlAllocZero(static_cast<DWORD>(sizeof(DATA)));
    }
    else
    {
        paData = (DATA *)::CtlReAllocZero(m_paData,
                           static_cast<DWORD>((m_cFormats + 1) * sizeof(DATA)));
    }

    if (NULL == paData)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    m_paData = paData;
    ::VariantInit(&m_paData[m_cFormats].varData);
    m_paData[m_cFormats].ObjectFormat = siObjectReference;

    m_cFormats++; // increment here so further SetData calls will
                  // have correct data array size even if VariantCopy() fails

    hr = ::VariantCopy(&m_paData[m_cFormats - 1].varData, &Data);
    EXCEPTION_CHECK_GO(hr);
    m_paData[m_cFormats - 1].ObjectFormat = eObjectFormat;

Cleanup:
Error:

    RRETURN(hr);
}


HRESULT CMMCDataObject::ReallocFormats(CLIPFORMAT **ppcfFormats)
{
    HRESULT     hr = S_OK;
    CLIPFORMAT *pcfFormats = NULL;

    if (NULL == *ppcfFormats)
    {
        pcfFormats = (CLIPFORMAT *)::CtlAllocZero(
                                       static_cast<DWORD>(sizeof(CLIPFORMAT)));
    }
    else
    {
        pcfFormats = (CLIPFORMAT *)::CtlReAllocZero(*ppcfFormats,
                    static_cast<DWORD>((m_cFormats + 1) * sizeof(CLIPFORMAT)));
    }

    if (NULL == pcfFormats)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppcfFormats = pcfFormats;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::FormatData
(
    VARIANT                Data,
    long                   StartingIndex,
    SnapInFormatConstants  Format,
    VARIANT               *BytesUsed,
    VARIANT               *pvarFormattedData
)
{
    HRESULT hr = S_OK;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(m_pSnapIn->FormatData(Data, StartingIndex, Format, BytesUsed,
                                   pvarFormattedData));
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IDataObject Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CMMCDataObject::GetData
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium
)
{
    HRESULT    hr = S_OK;
    HGLOBAL    hGlobal = NULL;
    IStream   *piStream = NULL;
    FORMATETC  FmtEtc = *pFormatEtc;
    STGMEDIUM  StgMed = *pmedium;

    // We only support stream and HGLOBAL for GetData

    IfFalseGo( ((TYMED_ISTREAM == pFormatEtc->tymed) ||
                (TYMED_HGLOBAL == pFormatEtc->tymed)), DV_E_TYMED);

    // Create a stream and call GetDataHere() to do the actual work
    
    hr = ::CreateStreamOnHGlobal(NULL,
                                 FALSE, // don't free buffer on final release
                                 &piStream);
    EXCEPTION_CHECK_GO(hr);

    FmtEtc.tymed = TYMED_ISTREAM;
    StgMed.tymed = TYMED_ISTREAM;
    StgMed.pstm = piStream;

    IfFailGo(GetDataHere(&FmtEtc, &StgMed));

    // We have the data. Now return it in the requested format.

    if (TYMED_ISTREAM == pFormatEtc->tymed)
    {
        piStream->AddRef();
        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pstm = piStream;
    }
    else
    {
        // TYMED_HGLOBAL - need to get the HGLOBAL from the stream.

        hr = ::GetHGlobalFromStream(piStream, &hGlobal);
        EXCEPTION_CHECK_GO(hr);

        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = hGlobal;
    }

Error:
    if ( FAILED(hr) && (NULL != piStream) )
    {
        // Need to free the memory because we specified don't free on final
        // release above

        if (SUCCEEDED(::GetHGlobalFromStream(piStream, &hGlobal)))
        {
            (void)::GlobalFree(hGlobal);
        }
    }
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}



STDMETHODIMP CMMCDataObject::GetDataHere
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pThis = this;
    IStream        *piStream = NULL;
    BSTR            bstrNodeTypeGUID = NULL; // Not allocated, don't free

    // If this data object is not connected to the snap-in then we can't
    // suppply the data. This error code is a lie but we don't want to cause
    // gyrations within MMC due to an unexpected return code here. If the format
    // is required for the operation and we return FORMATETC MMC will
    // abort the operation.
    
    IfFalseGo(NULL != m_pSnapIn, DV_E_CLIPFORMAT);

    // We only support stream and HGLOBAL for GetDataHere

    IfFalseGo( ((TYMED_ISTREAM == pFormatEtc->tymed) ||
                (TYMED_HGLOBAL == pFormatEtc->tymed)), DV_E_TYMED);

    // Either way get an IStream pointer to work with

    if (TYMED_HGLOBAL == pFormatEtc->tymed)
    {
        IfFalseGo(NULL != pmedium->hGlobal, E_INVALIDARG);
        hr = ::CreateStreamOnHGlobal(pmedium->hGlobal,
                                     FALSE, // don't free buffer on final release
                                     &piStream);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        IfFalseGo(NULL != pmedium->pstm, E_INVALIDARG);
        piStream = pmedium->pstm;

        // AddRef so release at func exit will be OK for both stream & HGLOBAL
        piStream->AddRef(); 
    }

    // Check the format and write the data to the stream

    if (pFormatEtc->cfFormat == m_cfDisplayName)
    {
        IfFailGo(WriteDisplayNameToStream(piStream));
    }
    else if ( (pFormatEtc->cfFormat == m_cfNodeType) ||
              (pFormatEtc->cfFormat == m_cfSzNodeType) )
    {
        if (ScopeItem == m_Type)
        {
            if (m_pScopeItem->IsStaticNode())
            {
                bstrNodeTypeGUID = m_pSnapIn->GetNodeTypeGUID();
            }
            else
            {
                bstrNodeTypeGUID = m_pScopeItem->GetScopeNode()->GetNodeTypeGUID();
            }
        }
        else if (ListItem == m_Type)
        {
            bstrNodeTypeGUID = m_pListItem->GetNodeTypeGUID();
        }
        else
        {
            hr = DV_E_CLIPFORMAT;
        }

        if (SUCCEEDED(hr))
        {
            if (pFormatEtc->cfFormat == m_cfNodeType)
            {
                IfFailGo(WriteGUIDToStream(piStream, bstrNodeTypeGUID));
            }
            else
            {
                IfFailGo(WriteWideStrToStream(piStream, bstrNodeTypeGUID));
            }
        }
    }
    else if (pFormatEtc->cfFormat == m_cfSnapinClsid)
    {
        IfFailGo(WriteSnapInCLSIDToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfDyanmicExtensions)
    {
        IfFailGo(WriteDynamicExtensionsToStream(piStream));
    }
    else if ( (pFormatEtc->cfFormat == m_cfWindowTitle) &&
              (NULL != m_bstrCaption) )
    {
        IfFailGo(WriteWideStrToStream(piStream, m_bstrCaption));
    }
    else if (pFormatEtc->cfFormat == m_cfSnapInPreloads)
    {
        IfFailGo(WritePreloadsToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfObjectTypesInMultiSelect)
    {
        IfFailGo(WriteObjectTypesToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfSnapInInstanceID)
    {
        IfFailGo(WriteSnapInInstanceIDToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfThisPointer)
    {
        IfFailGo(WriteToStream(piStream, &pThis, sizeof(this)));
    }
    else if (pFormatEtc->cfFormat == m_cfNodeID)
    {
        IfFailGo(WriteNodeIDToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfNodeID2)
    {
        IfFailGo(WriteNodeID2ToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfColumnSetID)
    {
        IfFailGo(WriteColumnSetIDToStream(piStream));
    }
    else
    {
        IfFailGo(GetSnapInData(pFormatEtc->cfFormat, piStream));
    }

Error:
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::QueryGetData(FORMATETC *pFormatEtc)
{
    HRESULT hr = DV_E_CLIPFORMAT;
    ULONG   iFormat = 0;

    try
    {
        IfFalseGo( ((TYMED_ISTREAM == pFormatEtc->tymed) ||
                    (TYMED_HGLOBAL == pFormatEtc->tymed)), DV_E_FORMATETC);

        if ( (pFormatEtc->cfFormat == m_cfDisplayName)              ||
             (pFormatEtc->cfFormat == m_cfNodeType)                 ||
             (pFormatEtc->cfFormat == m_cfSzNodeType)               ||
             (pFormatEtc->cfFormat == m_cfSnapinClsid)              ||
             (pFormatEtc->cfFormat == m_cfSnapInPreloads)           ||
             (pFormatEtc->cfFormat == m_cfObjectTypesInMultiSelect) ||
             (pFormatEtc->cfFormat == m_cfNodeID)                   ||

             ( (pFormatEtc->cfFormat == m_cfColumnSetID) &&
               (ScopeItem == m_Type) )                              ||

              ( (pFormatEtc->cfFormat == m_cfWindowTitle) &&
                (NULL != m_bstrCaption) )                           ||

             (GetFormatIndex(pFormatEtc->cfFormat, &iFormat))
           )
        {
            hr = S_OK;
        }
        else if (pFormatEtc->cfFormat == m_cfDyanmicExtensions)
        {
            if (ScopeItem == m_Type)
            {
                if (NULL != m_pScopeItem->GetDynamicExtensions())
                {
                    hr = S_OK;
                }
            }
            else if (ListItem == m_Type)
            {
                if (NULL != m_pListItem->GetDynamicExtensions())
                {
                    hr = S_OK;
                }
            }
        }
    }
    catch(...)
    {
        hr = E_INVALIDARG;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::GetCanonicalFormatEtc
(
    FORMATETC *pformatectIn,
    FORMATETC *pformatetcOut
)
{
    return E_NOTIMPL;
}


STDMETHODIMP CMMCDataObject::SetData
(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL       fRelease
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMMCDataObject::EnumFormatEtc
(
    DWORD            dwDirection,
    IEnumFORMATETC **ppenumFormatEtc
)
{
    return E_NOTIMPL;
}


STDMETHODIMP CMMCDataObject::DAdvise
(
    FORMATETC   *pformatetc,
    DWORD        advf,
    IAdviseSink *pAdvSink,
    DWORD       *pdwConnection
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMMCDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMMCDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCDataObject::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCDataObject == riid)
    {
        *ppvObjOut = static_cast<IMMCDataObject *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IDataObject == riid)
    {
        *ppvObjOut = static_cast<IDataObject *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobjs.h ===
//=--------------------------------------------------------------------------=
// dataobjs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObjects class definition - implements MMCDataObjects collection
//
//=--------------------------------------------------------------------------=

#ifndef _DATAOBJS_DEFINED_
#define _DATAOBJS_DEFINED_

#include "collect.h"

class CMMCDataObjects : public CSnapInCollection<IMMCDataObject, MMCDataObject, IMMCDataObjects>
{
    protected:
        CMMCDataObjects(IUnknown *punkOuter);
        ~CMMCDataObjects();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCDataObjects,           // name
                                &CLSID_MMCDataObjects,    // clsid
                                "MMCDataObjects",         // objname
                                "MMCDataObjects",         // lblname
                                NULL,                     // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCDataObjects,     // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _DATAOBJS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobjs.cpp ===
//=--------------------------------------------------------------------------=
// dataobjs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObjects class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "dataobjs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCDataObjects::CMMCDataObjects(IUnknown *punkOuter) :
    CSnapInCollection<IMMCDataObject, MMCDataObject, IMMCDataObjects>(punkOuter,
                                           OBJECT_TYPE_MMCDATAOBJECTS,
                                           static_cast<IMMCDataObjects *>(this),
                                           static_cast<CMMCDataObjects *>(this),
                                           CLSID_MMCDataObject,
                                           OBJECT_TYPE_MMCDATAOBJECT,
                                           IID_IMMCDataObject,
                                           NULL)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCDataObjects::~CMMCDataObjects()
{
}

IUnknown *CMMCDataObjects::Create(IUnknown * punkOuter)
{
    CMMCDataObjects *pMMCDataObjects = New CMMCDataObjects(punkOuter);
    if (NULL == pMMCDataObjects)
    {
        return NULL;
    }
    else
    {
        return pMMCDataObjects->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCDataObjects::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IMMCDataObjects == riid)
    {
        *ppvObjOut = static_cast<IMMCDataObjects *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCDataObject, MMCDataObject, IMMCDataObjects>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobj.h ===
//=--------------------------------------------------------------------------=
// dataobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObject class definition - implements MMCDataObject
//
//=--------------------------------------------------------------------------=

#ifndef _DATAOBJECT_DEFINED_
#define _DATAOBJECT_DEFINED_

#include "snapin.h"
#include "scopitem.h"
#include "listitem.h"

class CSnapIn;
class CScopeItem;
class CMMCListItem;

//=--------------------------------------------------------------------------=
//
// class CMMCDataObject
//
// Implements MMCDataObject for VB and implements IDataObject for external
// clients (MMC and extension snap-ins)
//
// Note: all of the #if defined(USING_SNAPINDATA) code is not used. That was
// from an old plan to have default data formats and use XML to describe them.
//=--------------------------------------------------------------------------=
class CMMCDataObject : public CSnapInAutomationObject,
                       public IMMCDataObject,
                       public IDataObject
{
    public:
        CMMCDataObject(IUnknown *punkOuter);
        ~CMMCDataObject();
        static IUnknown *Create(IUnknown *punkOuter);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    private:

    // IDataObject
        STDMETHOD(GetData)(FORMATETC *pFormatEtcIn, STGMEDIUM *pmedium);
        STDMETHOD(GetDataHere)(FORMATETC *pFormatEtc, STGMEDIUM *pmedium);
        STDMETHOD(QueryGetData)(FORMATETC *pFormatEtc);
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *pFormatEtcIn,
                                         FORMATETC *pFormatEtcOut);
        STDMETHOD(SetData)(FORMATETC *pFormatEtc,
                           STGMEDIUM *pmedium,
                           BOOL fRelease);
        STDMETHOD(EnumFormatEtc)(DWORD            dwDirection,
                                 IEnumFORMATETC **ppenumFormatEtc);
        STDMETHOD(DAdvise)(FORMATETC   *pFormatEtc,
                           DWORD        advf,
                           IAdviseSink *pAdvSink,
                           DWORD       *pdwConnection);
        STDMETHOD(DUnadvise)(DWORD dwConnection);
        STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise);


    // IMMCDataObject

        SIMPLE_PROPERTY_RW(CMMCDataObject, Index, long, DISPID_DATAOBJECT_INDEX);
        BSTR_PROPERTY_RW(CMMCDataObject,   Key, DISPID_DATAOBJECT_KEY);

#if defined(USING_SNAPINDATA)
        OBJECT_PROPERTY_RO(CMMCDataObject, DefaultFormat, ISnapInData, DISPID_VALUE);
#endif

        STDMETHOD(get_ObjectTypes)(SAFEARRAY **ppsaObjectTypes);
        STDMETHOD(Clear)();

#if defined(USING_SNAPINDATA)
        STDMETHOD(GetData)(BSTR Format, ISnapInData **ppiSnapInData);
        STDMETHOD(GetRawData)(BSTR Format, VARIANT *pvarData);
#else
        STDMETHOD(GetData)(BSTR     Format,
                           VARIANT  MaximumLength,
                           VARIANT *pvarData);
#endif

        STDMETHOD(GetFormat)(BSTR Format, VARIANT_BOOL *pfvarHaveFormat);

#if defined(USING_SNAPINDATA)
        STDMETHOD(SetData)(ISnapInData *Data, BSTR Format);
        STDMETHOD(SetRawData)(VARIANT Data, BSTR Format);
#else
        STDMETHOD(SetData)(VARIANT Data, BSTR Format, VARIANT ObjectFormat);
#endif
        STDMETHOD(FormatData)(VARIANT                Data,
                              long                   StartingIndex,
                              SnapInFormatConstants  Format,
                              VARIANT               *BytesUsed,
                              VARIANT               *pvarFormattedData);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:

    // Non-interface public methods
        void SetSnapIn(CSnapIn *pSnapIn);
        
        enum Type
        {
            ScopeItem,      // Data object holds a single scope item
            ListItem,       // Data object holds a single list item
            MultiSelect,    // Data object holds multiple list and/or scope items
            Foreign,        // Data object is from another snap-in or from MMC
            WindowTitle,    // Data object holds MMC's CCF_WINDOW_TITLE
            CutOrMove       // Data object holds MMC_CUT_OR_MOVE data (this is
                            // set by target snap-in to return to source in a
                            // format defined by the source)
        };

        void SetType(Type type);
        Type GetType();

        void SetScopeItems(CScopeItems *pScopeItems);
        CScopeItems *GetScopeItems();

        void SetScopeItem(CScopeItem *pScopeItem);
        CScopeItem *GetScopeItem();
        
        void SetListItems(CMMCListItems *pListItems);
        CMMCListItems *GetListItems();

        void SetListItem(CMMCListItem *pListItem);
        CMMCListItem *GetListItem();

        HRESULT SetCaption(BSTR bstrCaption);

        void SetForeignData(IDataObject *piDataObject);

        void SetContext(DATA_OBJECT_TYPES Context) { m_Context = Context; }
        DATA_OBJECT_TYPES GetContext() { return m_Context; }

        DWORD GetSnapInInstanceID();

        static HRESULT RegisterClipboardFormats();

        // Public methods to get registered clipboard formats
        
        static CLIPFORMAT GetcfSzNodeType() { return m_cfSzNodeType; }
        static CLIPFORMAT GetcfDisplayName() { return m_cfDisplayName; }
        static CLIPFORMAT GetcfMultiSelectSnapIns() { return m_cfMultiSelectSnapIns; }
        static CLIPFORMAT GetcfMultiSelectDataObject() { return m_cfMultiSelectDataObject; }
        static CLIPFORMAT GetcfSnapInInstanceID() { return m_cfSnapInInstanceID; }
        static CLIPFORMAT GetcfThisPointer() { return m_cfThisPointer; }

    private:

        void InitMemberVariables();
        HRESULT WriteDisplayNameToStream(IStream *piStream);
        HRESULT WriteSnapInCLSIDToStream(IStream *piStream);
        HRESULT WriteDynamicExtensionsToStream(IStream *piStream);
        HRESULT WritePreloadsToStream(IStream *piStream);
        HRESULT WriteSnapInInstanceIDToStream(IStream *piStream);
        HRESULT WriteObjectTypesToStream(IStream *piStream);
        HRESULT WriteNodeIDToStream(IStream *piStream);
        HRESULT WriteNodeID2ToStream(IStream *piStream);
        HRESULT WriteColumnSetIDToStream(IStream *piStream);
        HRESULT WriteGUIDToStream(IStream *piStream, OLECHAR *pwszGUID);
        HRESULT WriteWideStrToStream(IStream *piStream, WCHAR *pwszString);
        HRESULT WriteStringArrayToStream(IStream *piStream, SAFEARRAY *psaStrings);
        HRESULT WriteToStream(IStream *piStream, void *pvBuffer, ULONG cbToWrite);
        enum FormatType { ANSI, UNICODE };
        static HRESULT RegisterClipboardFormat(WCHAR      *pwszFormatName,
                                               CLIPFORMAT *puiFormat,
                                               FormatType  Type);
        BOOL GetFormatIndex(CLIPFORMAT cfFormat, ULONG *piFormat);
        HRESULT GetSnapInData(CLIPFORMAT cfFormat, IStream *piStream);
        HRESULT GetObjectTypes();
        HRESULT GetOurObjectTypes();
        HRESULT GetForeignObjectTypes();
        void AddGuid(SMMCObjectTypes *pMMCObjectTypes, GUID *pguid);
        HRESULT ReallocFormats(CLIPFORMAT **ppcfFormats);

        // Registered clipboard formats kept here

        static CLIPFORMAT   m_cfDisplayName;
        static CLIPFORMAT   m_cfNodeType;
        static CLIPFORMAT   m_cfSzNodeType;
        static CLIPFORMAT   m_cfSnapinClsid;
        static CLIPFORMAT   m_cfWindowTitle;
        static CLIPFORMAT   m_cfDyanmicExtensions;
        static CLIPFORMAT   m_cfSnapInPreloads;
        static CLIPFORMAT   m_cfObjectTypesInMultiSelect;
        static CLIPFORMAT   m_cfMultiSelectSnapIns;
        static CLIPFORMAT   m_cfMultiSelectDataObject;
        static CLIPFORMAT   m_cfSnapInInstanceID;
        static CLIPFORMAT   m_cfThisPointer;
        static CLIPFORMAT   m_cfNodeID;
        static CLIPFORMAT   m_cfNodeID2;
        static CLIPFORMAT   m_cfColumnSetID;
        static BOOL         m_ClipboardFormatsRegistered;
        static BOOL         m_fUsingUNICODEFormats;

        CSnapIn            *m_pSnapIn;             // Owning CSnapIn
        CScopeItems        *m_pScopeItems;         // ScopeItems in data object
        CScopeItem         *m_pScopeItem;          // Single ScopeItem in data object
        CMMCListItems      *m_pListItems;          // ListItems in data object
        CMMCListItem       *m_pListItem;           // Single ListItem in data object
        BSTR                m_bstrCaption;         // Caption for CCF_WINDOW_TITLE
        IDataObject        *m_piDataObjectForeign; // If MMCDataObject represents
                                                   // a foreign data object (from
                                                   // an extension or an extendee)
                                                   // then this holds its
                                                   // IDataObject
        Type                m_Type;                // See enum above
        DATA_OBJECT_TYPES   m_Context;             // From MMC
        SMMCObjectTypes    *m_pMMCObjectTypes;     // for CCF_OBJECT_TYPES_IN_MULTI_SELECT

        ULONG               m_cFormats;            // # of data formats exported
                                                   // by the owning snap-in
        CLIPFORMAT         *m_pcfFormatsANSI;      // ANSI registered clipformat
        CLIPFORMAT         *m_pcfFormatsUNICODE;   // UNICODE registered clipformat

        // This struct holds the data passed to MMCDataObject.SetData
        
        typedef struct
        {
            VARIANT                     varData;
            SnapInObjectFormatConstants ObjectFormat;
        } DATA;

        // Array of data passed to MMCDataObject.SetData
        
        DATA *m_paData;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCDataObject,           // name
                                &CLSID_MMCDataObject,    // clsid
                                "MMCDataObject",         // objname
                                "MMCDataObject",         // lblname
                                &CMMCDataObject::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IMMCDataObject,     // dispatch IID
                                NULL,                    // event IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _DATAOBJECT_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\enumtask.h ===
//=--------------------------------------------------------------------------=
// enumtask.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CEnumTask class definition - implements IEnumTASK interface
//
//=--------------------------------------------------------------------------=

#ifndef _ENUMTASK_DEFINED_
#define _ENUMTASK_DEFINED_

#include "tasks.h"
#include "task.h"
#include "snapin.h"

//=--------------------------------------------------------------------------=
//
// class CEnumTask
// 
// Implements IEnumTASK interface. Used by CView to respond to
// IExtendTaskpad::EnumTasks
//
//=--------------------------------------------------------------------------=
class CEnumTask : public CSnapInAutomationObject,
                  public IEnumTASK
{
    private:
        CEnumTask(IUnknown *punkOuter);
        virtual ~CEnumTask();
    
    public:
        static IUnknown *Create(IUnknown * punk);
        void SetTasks(ITasks *piTasks);
        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    private:

    // IEnumTASK

        STDMETHOD(Next)(ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)();
        STDMETHOD(Clone)(IEnumTASK **ppEnumTASK);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT GetEnumVARIANT();

        ITasks       *m_piTasks;        // Taskpad.Tasks collection
        IEnumVARIANT *m_piEnumVARIANT;  // IEnumVARIANT on that collection
        CSnapIn      *m_pSnapIn;        // Back pointer to owning CSnapIn
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(EnumTask,           // name
                                NULL,               // clsid
                                NULL,               // objname
                                NULL,               // lblname
                                NULL,               // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_IEnumTASK,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _ENUMTASK_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dlregdes.cpp ===
//=--------------------------------------------------------------------------------------
// dlregdes.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// DllRegisterDesigner and DllUnregisterDesigner
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"

// for ASSERT and FAIL
//
SZTHISFILE

// Local utility function prototypes


enum ProcessingType { Register, Unregister };

HRESULT ProcessRegistration(DESIGNERREGINFO* pdri, ProcessingType Processing);

HRESULT LoadRegInfo(IRegInfo **ppiRegInfo, BYTE *rgbRegInfo);

HRESULT CreateKey(HKEY  hkeyParent,
                  char *pszKeyName,
                  char *pszDefaultValue,
                  HKEY *phKey);

HRESULT ProcessSnapInKeys(IRegInfo       *piRegInfo,
                          char           *pszClsid,
                          char           *pszDisplayName,
                          ProcessingType  Processing);

HRESULT ProcessNodeType(HKEY            hkeyNodeTypes,
                        INodeType      *piNodeType,
                        ProcessingType  Processing);

HRESULT CreateNodeTypesKey(BSTR  bstrNodeTypeGUID,
                           char *pszNodeTypeName,
                           HKEY *phKey);

HRESULT DeleteKey(HKEY hkey, char *pszSubKey);

HRESULT ProcessExtensions(IRegInfo       *piRegInfo,
                           char           *pszClsid,
                           char           *pszDisplayName,
                           ProcessingType  Processing);

HRESULT ProcessExtendedSnapIn(IExtendedSnapIn *piExtendedSnapIn,
                              char            *pszClsid,
                              char            *pszDisplayName,
                              ProcessingType   Processing);

HRESULT ProcessExtension(HKEY            hkeyExtensions,
                         char           *pszKeyName,
                         char           *pszClsid,
                         char           *pszDisplayName,
                         ProcessingType  Processing);

HRESULT SetValue(HKEY hkey, char *pszName, char *pszData);

HRESULT ProcessCLSID(IRegInfo       *piRegInfo,
                     char           *pszClsid,
                     ProcessingType  Processing);



//=--------------------------------------------------------------------------=
// DllRegisterDesigner
//=--------------------------------------------------------------------------=
//
// Parameters:
//      DESIGNERREGINFO* pdri [in] registration info saved at design time
//                            in IDesignerRegistration::GetRegistrationInfo
//
// Output:
//      HRESULT
//
// Notes:
//
// This method is called by the VB runtime when the snap-in's DLL is registered.
// It is passed the regsitration info that was saved by the design time in
// its IDesignerRegistration::GetRegistrationInfo method (see
// CSnapInDesigner::GetRegistrationInfo in mssnapd\desreg.cpp).
//

STDAPI DllRegisterDesigner(DESIGNERREGINFO* pdri)
{
    RRETURN(::ProcessRegistration(pdri, Register));
}


//=--------------------------------------------------------------------------=
// DllUnregisterDesigner
//=--------------------------------------------------------------------------=
//
// Parameters:
//      DESIGNERREGINFO* pdri [in] registration info saved at design time
//                            in IDesignerRegistration::GetRegistrationInfo
//
// Output:
//      HRESULT
//
// Notes:
//
// This method is called by the VB runtime when the snap-in's DLL is unregistered.
// It is passed the regsitration info that was saved by the design time in
// its IDesignerRegistration::GetRegistrationInfo method (see
// CSnapInDesigner::GetRegistrationInfo in mssnapd\desreg.cpp).
//

STDAPI DllUnregisterDesigner(DESIGNERREGINFO* pdri)
{
    RRETURN(::ProcessRegistration(pdri, Unregister));
}



//=--------------------------------------------------------------------------=
// ProcessRegistration
//=--------------------------------------------------------------------------=
//
// Parameters:
//      DESIGNERREGINFO* pdri [in] registration info saved at design time
//                            in IDesignerRegistration::GetRegistrationInfo
//      ProcessingType Processing [in] Register or Unregister
//
// Output:
//      HRESULT
//
// Notes:
//
// This function either registers or unregisters the snap-in based on the
// Processing parameter.
//
// See mssnapd\desreg.cpp for how the registration info was saved.
//
// The registation info is copied to a GlobalAlloc()ed buffer and converted
// to a stream. A RegInfo object is loaded from the stream.
//
// The snap-in is registered/unregistered under MMC's "SnapIns" key as follows:
// 
// HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns\pdri->clsid
//  NameString:      REG_SZ RegInfo.DisplayName
//  About:           REG_SZ pdri->clsid
//  StandAlone:      added if RegInfo.Standalone is VARIANT_TRUE
//  NodeTypes:
//      RegInfo.NodeType(0).GUID
//      RegInfo.NodeType(1).GUID
//      etc.
// 
// The MMC NodeTypes key is populated/depopulated from RegInfo.NodeTypes
// 
// HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\RegInfo.NodeTypes(i).GUID=RegInfo.NodeTypes(i).Name
//
// If the snap-in extends other snap-ins then the appropriate entries are
// addded/removed under
// HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<other snap-in GUID>.
//
//
// An additional key is created/removed:
// HKEY_LOCAL_MACHINE\Software\Microsoft\Visual Basic\6.0\SnapIns\<node type guid>
// with default REG_SZ value of snap-in CLSID. Runtime uses this to get
// the snap-in's CLSID needed for CCF_SNAPIN_CLSID data object queries
// from MMC. If all snap-ins were extensible then this key wouldn't be necessary
// as the runtime could just query the static node type key but as we cannot
// guarantee extensibility (it is a design time choice made in the designer) we
// need to use this extra key.
   

HRESULT ProcessRegistration(DESIGNERREGINFO* pdri, ProcessingType Processing)
{
    HRESULT   hr = S_OK;
    IRegInfo *piRegInfo = NULL;
    BSTR      bstrDisplayName = NULL;
    char     *pszDisplayName = NULL;
    char     *pszClsid = NULL;
    WCHAR     wszClsid[64];
    ::ZeroMemory(wszClsid, sizeof(wszClsid));

    IfFalseGo(0 != ::StringFromGUID2(pdri->clsid, wszClsid,
                                     sizeof(wszClsid) / sizeof(wszClsid[0])),
              E_FAIL);

    IfFailGo(::ANSIFromWideStr(wszClsid, &pszClsid));

    IfFailGo(::LoadRegInfo(&piRegInfo, pdri->rgbRegInfo));

    IfFailGo(piRegInfo->get_DisplayName(&bstrDisplayName));
    IfFailGo(::ANSIFromWideStr(bstrDisplayName, &pszDisplayName));

    IfFailGo(::ProcessSnapInKeys(piRegInfo, pszClsid, pszDisplayName, Processing));
    IfFailGo(::ProcessExtensions(piRegInfo, pszClsid, pszDisplayName, Processing));
    IfFailGo(::ProcessCLSID(piRegInfo, pszClsid, Processing));

Error:
    if (NULL != pszDisplayName)
    {
        ::CtlFree(pszDisplayName);
    }
    FREESTRING(bstrDisplayName);
    QUICK_RELEASE(piRegInfo);
    if (NULL != pszClsid)
    {
        ::CtlFree(pszClsid);
    }
    RRETURN(hr);
}



static HRESULT LoadRegInfo
(
    IRegInfo **ppiRegInfo,
    BYTE      *rgbRegInfo
)
{
    HRESULT  hr = S_OK;
    ULONG    cbBuffer = *((ULONG *)(rgbRegInfo));
    HGLOBAL  hglobal = NULL;
    BYTE    *pbBuffer = NULL;
    IStream *piStream = NULL;

    // GlobalAlloc() a buffer and copy the reg info to it

    hglobal = ::GlobalAlloc(GMEM_MOVEABLE, (DWORD)cbBuffer);
    IfFalseGo(NULL != hglobal, HRESULT_FROM_WIN32(::GetLastError()));

    pbBuffer = (BYTE *)::GlobalLock(hglobal);
    IfFalseGo(NULL != pbBuffer, HRESULT_FROM_WIN32(::GetLastError()));

    ::memcpy(pbBuffer, rgbRegInfo + sizeof(ULONG), cbBuffer);

    IfFalseGo(!::GlobalUnlock(hglobal), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::GetLastError() == NOERROR, HRESULT_FROM_WIN32(::GetLastError()));

    // Create stream on HGLOBAL and load the RegInfo object
    hr = ::CreateStreamOnHGlobal(hglobal, // Allocate buffer
                                 TRUE,    // Free buffer on release
                                 &piStream);
    IfFailGo(hr);

    IfFailGo(::OleLoadFromStream(piStream, IID_IRegInfo,
                                 reinterpret_cast<void **>(ppiRegInfo)));

Error:
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}



static HRESULT ProcessSnapInKeys
(
    IRegInfo       *piRegInfo,
    char           *pszClsid,
    char           *pszDisplayName,
    ProcessingType  Processing
)
{
    HRESULT       hr = S_OK;
    char         *pszSnapInsKey = NULL;
    HKEY          hkeySnapIns = NULL;
    HKEY          hkeySnapInNodeTypes = NULL;
    VARIANT_BOOL  fStandAlone = VARIANT_FALSE;
    INodeTypes   *piNodeTypes = NULL;
    INodeType    *piNodeType = NULL;
    long          cNodeTypes = 0;
    long          lRc = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Create key: HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns\<clsid>

    IfFailGo(::CreateKeyName(MMCKEY_SNAPINS, MMCKEY_SNAPINS_LEN,
                             pszClsid, ::strlen(pszClsid), &pszSnapInsKey));

    IfFailGo(::CreateKey(HKEY_LOCAL_MACHINE, pszSnapInsKey, NULL, &hkeySnapIns));

    if (Register == Processing)
    {
        // Add the NameString value and set it to the display name

        IfFailGo(::SetValue(hkeySnapIns, MMCKEY_NAMESTRING, pszDisplayName));

        // Add the About value and set its to the snap-in's CLSID

        IfFailGo(::SetValue(hkeySnapIns, MMCKEY_ABOUT, pszClsid));
    }

    // Process the StandAlone key if applicable

    IfFailGo(piRegInfo->get_StandAlone(&fStandAlone));
    if (VARIANT_TRUE == fStandAlone)
    {
        if (Register == Processing)
        {
            IfFailGo(::CreateKey(hkeySnapIns, MMCKEY_STANDALONE, NULL, NULL));
        }
        else
        {
            IfFailGo(::DeleteKey(hkeySnapIns, MMCKEY_STANDALONE));
        }
    }

    // Process node types if applicable

    IfFailGo(piRegInfo->get_NodeTypes(&piNodeTypes));
    IfFailGo(piNodeTypes->get_Count(&cNodeTypes));

    if (0 != cNodeTypes)
    {
        IfFailGo(::CreateKey(hkeySnapIns, MMCKEY_SNAPIN_NODETYPES, NULL,
                             &hkeySnapInNodeTypes));

        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;

        while (varIndex.lVal <= cNodeTypes)
        {
            IfFailGo(piNodeTypes->get_Item(varIndex, &piNodeType));
            IfFailGo(::ProcessNodeType(hkeySnapInNodeTypes, piNodeType, Processing));
            RELEASE(piNodeType);
            varIndex.lVal++;
        }

        // If unregistering then remove NodeTypes key now after all node types
        // have been removed as NT does not allow deleting a key that has subkeys
        if (Unregister == Processing)
        {
            IfFailGo(::DeleteKey(hkeySnapIns, MMCKEY_SNAPIN_NODETYPES));
        }
    }

    // If unregistering then remove SnapIns key now after all subkeys are gone

    if (Unregister == Processing)
    {
        IfFailGo(::DeleteKey(HKEY_LOCAL_MACHINE, pszSnapInsKey));
    }

Error:
    QUICK_RELEASE(piNodeTypes);
    QUICK_RELEASE(piNodeType);
    if (NULL != hkeySnapIns)
    {
        (void)::RegCloseKey(hkeySnapIns);
    }
    if (NULL != hkeySnapInNodeTypes)
    {
        (void)::RegCloseKey(hkeySnapInNodeTypes);
    }
    if (NULL != pszSnapInsKey)
    {
        ::CtlFree(pszSnapInsKey);
    }
    RRETURN(hr);
}





static HRESULT CreateKey
(
    HKEY  hkeyParent,
    char *pszKeyName,
    char *pszDefaultValue,
    HKEY *phKey
)
{
    HRESULT hr = S_OK;
    long    lRc = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DWORD   dwActionTaken = REG_CREATED_NEW_KEY;

    lRc = ::RegCreateKeyEx(hkeyParent,              // parent key
                           pszKeyName,              // name of new sub-key
                           0,                       // reserved
                           "",                      // class
                           REG_OPTION_NON_VOLATILE, // options
                           KEY_WRITE |              // access
                           KEY_ENUMERATE_SUB_KEYS,  // need enum for deletion
                           NULL,                    // use inherited security
                           &hKey,                   // new key returned here
                           &dwActionTaken);         // action returned here

    IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));

    IfFalseGo(NULL != pszDefaultValue, S_OK);

    lRc = ::RegSetValueEx(hKey,                           // key
                          NULL,                           // set default value
                          0,                              // reserved
                          REG_SZ,                         // string type
                          (CONST BYTE *)pszDefaultValue,  // data
                          ::strlen(pszDefaultValue) + 1); // length of data

    IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));

Error:
    if (NULL != hKey)
    {
        if (SUCCEEDED(hr) && (NULL != phKey))
        {
            *phKey = hKey;
        }
        else
        {
            (void)::RegCloseKey(hKey);
        }
    }
    RRETURN(hr);
}



static HRESULT ProcessNodeType
(
    HKEY            hkeySnapInNodeTypes,
    INodeType      *piNodeType,
    ProcessingType  Processing
)
{
    HRESULT  hr = S_OK;
    char    *pszNodeTypeGUID = NULL;
    BSTR     bstrNodeTypeGUID = NULL;
    char    *pszNodeTypeName = NULL;
    BSTR     bstrNodeTypeName = NULL;
    char    *pszNodeTypeKeyName = NULL;
    HKEY     hkeyNodeTypes = NULL;
    long     lRc = 0;

    // Add the node type GUID as a sub-key of the snap-in's NodeTypes sub key

    IfFailGo(piNodeType->get_GUID(&bstrNodeTypeGUID));
    
    IfFailGo(::ANSIFromWideStr(bstrNodeTypeGUID, &pszNodeTypeGUID));

    IfFailGo(piNodeType->get_Name(&bstrNodeTypeName));

    IfFailGo(::ANSIFromWideStr(bstrNodeTypeName, &pszNodeTypeName));

    if (Register == Processing)
    {
        IfFailGo(::CreateKey(hkeySnapInNodeTypes, pszNodeTypeGUID,
                             pszNodeTypeName, NULL));

        // Create the key under MMC's NodeTypes:
        // HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<node type GUID>

        IfFailGo(::CreateNodeTypesKey(bstrNodeTypeGUID, pszNodeTypeName,
                                      &hkeyNodeTypes));
    }
    else
    {
        IfFailGo(::DeleteKey(hkeySnapInNodeTypes, pszNodeTypeGUID));

        IfFailGo(::CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                                bstrNodeTypeGUID, &pszNodeTypeKeyName));

        IfFailGo(::DeleteKey(HKEY_LOCAL_MACHINE, pszNodeTypeKeyName));
    }

Error:
    FREESTRING(bstrNodeTypeGUID);
    if (NULL != pszNodeTypeGUID)
    {
        ::CtlFree(pszNodeTypeGUID);
    }
    FREESTRING(bstrNodeTypeName);
    if (NULL != pszNodeTypeName)
    {
        ::CtlFree(pszNodeTypeName);
    }
    if (NULL != hkeyNodeTypes)
    {
        (void)::RegCloseKey(hkeyNodeTypes);
    }
    if (NULL != pszNodeTypeKeyName)
    {
        ::CtlFree(pszNodeTypeKeyName);
    }
    RRETURN(hr);
}


static HRESULT CreateNodeTypesKey
(
    BSTR            bstrNodeTypeGUID,
    char           *pszNodeTypeName,
    HKEY           *phKey
)
{
    HRESULT  hr = S_OK;
    char    *pszNodeTypeKeyName = NULL;
    size_t   cbNodeTypeGUID = 0;

    IfFailGo(::CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                              bstrNodeTypeGUID, &pszNodeTypeKeyName));

    IfFailGo(::CreateKey(HKEY_LOCAL_MACHINE, pszNodeTypeKeyName,
                         pszNodeTypeName, phKey));

Error:
    if (NULL != pszNodeTypeKeyName)
    {
        ::CtlFree(pszNodeTypeKeyName);
    }
    RRETURN(hr);
}


static HRESULT DeleteKey(HKEY hkey, char *pszSubKey)
{
    HKEY    hkeySub = NULL;
    HRESULT hr = S_OK;
    char    szNextSubKey[MAX_PATH + 1] = "";
    long    lRc = 0;

    IfFailGo(::CreateKey(hkey, pszSubKey, NULL, &hkeySub));

    // We continually re-enumerate from zero because we are deleting the
    // keys as we go. If we don't do that then NT gets confused and says
    // there are no more keys.

    lRc = ::RegEnumKey(hkeySub, 0, szNextSubKey, sizeof(szNextSubKey));
    while (ERROR_SUCCESS == lRc)
    {
        IfFailGo(::DeleteKey(hkeySub, szNextSubKey));
        lRc = ::RegEnumKey(hkeySub, 0, szNextSubKey, sizeof(szNextSubKey));
    }

    IfFalseGo(ERROR_NO_MORE_ITEMS == lRc, HRESULT_FROM_WIN32(lRc));

    lRc = ::RegDeleteKey(hkey, pszSubKey);
    IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));

Error:
    if (NULL != hkeySub)
    {
        (void)::RegCloseKey(hkeySub);
    }
    RRETURN(hr);
}


static HRESULT ProcessExtensions
(
    IRegInfo       *piRegInfo,
    char           *pszClsid,
    char           *pszDisplayName,
    ProcessingType  Processing
)
{
    HRESULT           hr = S_OK;
    IExtendedSnapIns *piExtendedSnapIns = NULL;
    IExtendedSnapIn  *piExtendedSnapIn = NULL;
    long              cExtendedSnapIns = 0;
    VARIANT           varIndex;
    ::VariantInit(&varIndex);

    // Get the collection of extended snap-ins

    IfFailGo(piRegInfo->get_ExtendedSnapIns(&piExtendedSnapIns));
    IfFailGo(piExtendedSnapIns->get_Count(&cExtendedSnapIns));
    IfFalseGo(0 != cExtendedSnapIns, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    // Add the supported extensions to each snap-in's node types key

    while (varIndex.lVal <= cExtendedSnapIns)
    {
        IfFailGo(piExtendedSnapIns->get_Item(varIndex, &piExtendedSnapIn));
        IfFailGo(::ProcessExtendedSnapIn(piExtendedSnapIn, pszClsid,
                                         pszDisplayName, Processing));
        RELEASE(piExtendedSnapIn);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piExtendedSnapIns);
    QUICK_RELEASE(piExtendedSnapIn);
    RRETURN(hr);
}



static HRESULT ProcessExtendedSnapIn
(
    IExtendedSnapIn *piExtendedSnapIn,
    char            *pszClsid,
    char            *pszDisplayName,
    ProcessingType   Processing
)
{
    HRESULT      hr = S_OK;
    long         lRc = ERROR_SUCCESS;
    HKEY         hkeyNodeTypes = NULL;
    HKEY         hkeyExtensions = NULL;
    HKEY         hkeyDynamicExtensions = NULL;
    BSTR         bstrNodeTypeGUID = NULL;
    VARIANT_BOOL fExtends = VARIANT_FALSE;
    VARIANT_BOOL fDynamic = VARIANT_FALSE;

    // Create or open key:
    // HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<node type GUID>

    IfFailGo(piExtendedSnapIn->get_NodeTypeGUID(&bstrNodeTypeGUID));
    IfFailGo(::CreateNodeTypesKey(bstrNodeTypeGUID, NULL, &hkeyNodeTypes));

    // Create/open Extensions Key

    IfFailGo(::CreateKey(hkeyNodeTypes, MMCKEY_EXTENSIONS, NULL, &hkeyExtensions));

    // Check the extension types and add keys and values as needed

    IfFailGo(piExtendedSnapIn->get_ExtendsNewMenu(&fExtends));
    if (VARIANT_FALSE == fExtends)
    {
        IfFailGo(piExtendedSnapIn->get_ExtendsTaskMenu(&fExtends));
    }
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_CONTEXTMENU, pszClsid,
                                    pszDisplayName, Processing));
    }
    
    IfFailGo(piExtendedSnapIn->get_ExtendsPropertyPages(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_PROPERTYSHEET,
                                    pszClsid, pszDisplayName, Processing));
    }
    
    IfFailGo(piExtendedSnapIn->get_ExtendsToolbar(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_TOOLBAR, pszClsid,
                                    pszDisplayName, Processing));
    }

    IfFailGo(piExtendedSnapIn->get_ExtendsTaskpad(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_TASK, pszClsid,
                                    pszDisplayName, Processing));
    }

    IfFailGo(piExtendedSnapIn->get_ExtendsNameSpace(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_NAMESPACE, pszClsid,
                                    pszDisplayName, Processing));
    }

    // If the snap-in extends this node type dynamically then add/delete a value
    // to the DynamicExtensions sub-key:
    // HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<node type GUID>\Dynamic Extensions
    //
    // The value is the same form as for the Extensions sub-keys:
    // <CLSID>=<DisplayName>

    IfFailGo(piExtendedSnapIn->get_Dynamic(&fDynamic));
    IfFalseGo(VARIANT_TRUE == fDynamic, S_OK);

    IfFailGo(::CreateKey(hkeyNodeTypes, MMCKEY_DYNAMIC_EXTENSIONS, NULL,
                         &hkeyDynamicExtensions));

    if (Register == Processing)
    {
        IfFailGo(::SetValue(hkeyDynamicExtensions, pszClsid, pszDisplayName));
    }
    else
    {
        lRc = ::RegDeleteValue(hkeyDynamicExtensions, pszClsid);
        if (ERROR_FILE_NOT_FOUND == lRc) // If the value is not there then 
        {                                // ignore the error
            lRc = ERROR_SUCCESS;
        }
        IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));
    }

Error:
    FREESTRING(bstrNodeTypeGUID);
    if (NULL != hkeyNodeTypes)
    {
        (void)::RegCloseKey(hkeyNodeTypes);
    }
    if (NULL != hkeyExtensions)
    {
        (void)::RegCloseKey(hkeyExtensions);
    }
    if (NULL != hkeyDynamicExtensions)
    {
        (void)::RegCloseKey(hkeyDynamicExtensions);
    }
    RRETURN(hr);
}



static HRESULT ProcessExtension
(
    HKEY            hkeyExtensions,
    char           *pszKeyName,
    char           *pszClsid,
    char           *pszDisplayName,
    ProcessingType  Processing
)
{
    HRESULT hr = S_OK;
    HKEY    hkeyExtension = NULL;
    long    lRc = 0;

    IfFailGo(::CreateKey(hkeyExtensions, pszKeyName, NULL, &hkeyExtension));

    if (Register == Processing)
    {
        IfFailGo(::SetValue(hkeyExtension, pszClsid, pszDisplayName));
    }
    else
    {
        lRc = ::RegDeleteValue(hkeyExtension, pszClsid);
        if (ERROR_FILE_NOT_FOUND == lRc) // If the value is not there then 
        {                                // ignore the error
            lRc = ERROR_SUCCESS;
        }
        IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));
    }

Error:
    if (NULL != hkeyExtension)
    {
        (void)::RegCloseKey(hkeyExtension);
    }
    RRETURN(hr);
}


static HRESULT SetValue
(
    HKEY  hKey,
    char *pszName,
    char *pszData
)
{
    long lRc = ::RegSetValueEx(hKey,                   // key
                               pszName,                // value name
                               0,                      // reserved
                               REG_SZ,                 // string type
                               (CONST BYTE *)pszData,  // data
                               ::strlen(pszData) + 1); // data length

    IfFalseRet(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));
    return S_OK;
}



static HRESULT ProcessCLSID
(
    IRegInfo       *piRegInfo,
    char           *pszClsid,
    ProcessingType  Processing
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrGUID = NULL;
    char    *pszKeyName = NULL;

    // Create key:
    // HKEY_LOCAL_MACHINE\Software\Microsoft\Visual Basic\6.0\SnapIns\<node type guid>
    // with default REG_SZ value of snap-in CLSID. Runtime uses this to get
    // the snap-in's CLSID needed for CCF_SNAPIN_CLSID data object queries
    // from MMC

    IfFailGo(piRegInfo->get_StaticNodeTypeGUID(&bstrGUID));
    IfFailGo(::CreateKeyNameW(KEY_SNAPIN_CLSID, KEY_SNAPIN_CLSID_LEN, bstrGUID,
                              &pszKeyName));
    if (Register == Processing)
    {
        IfFailGo(::CreateKey(HKEY_LOCAL_MACHINE, pszKeyName, pszClsid, NULL));
    }
    else
    {
        IfFailGo(::DeleteKey(HKEY_LOCAL_MACHINE, pszKeyName));
    }

Error:
    FREESTRING(bstrGUID);
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dispid.h ===
//=--------------------------------------------------------------------------------------
// dispid.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=--------------------------------------------------------------------------=
//
//  Notes
//      Contains defintions of all the dispids used in the snap-in
//      designer type library
//
//=--------------------------------------------------------------------------=

// This is the lowest DISPID for dynamic snap-in properties (toolbars, image
// lists and menus.

#define DISPID_DYNAMIC_BASE                                     1000

// ISnapIn
#define DISPID_SNAPIN_NAME                                      DISPID_VALUE
#define DISPID_SNAPIN_NODE_TYPE_NAME                            1
#define DISPID_SNAPIN_NODE_TYPE_GUID                            2
#define DISPID_SNAPIN_DISPLAY_NAME                              3
#define DISPID_SNAPIN_TYPE                                      4
#define DISPID_SNAPIN_DESCRIPTION                               5
#define DISPID_SNAPIN_PROVIDER                                  6
#define DISPID_SNAPIN_VERSION                                   7
#define DISPID_SNAPIN_SMALL_FOLDERS                             8
#define DISPID_SNAPIN_SMALL_FOLDERS_OPEN                        9
#define DISPID_SNAPIN_LARGE_FOLDERS                             10
#define DISPID_SNAPIN_ICON                                      11
#define DISPID_SNAPIN_WATERMARK                                 12
#define DISPID_SNAPIN_HEADER                                    13
#define DISPID_SNAPIN_PALETTE                                   14
#define DISPID_SNAPIN_STRETCH_WATERMARK                         15
#define DISPID_SNAPIN_STATIC_FOLDER                             16
#define DISPID_SNAPIN_SCOPEITEMS                                17
#define DISPID_SNAPIN_VIEWS                                     18
#define DISPID_SNAPIN_SCOPE_PANE_ITEMS                          19
#define DISPID_SNAPIN_RESULT_VIEWS                              20
#define DISPID_SNAPIN_CLIPBOARD                                 21
#define DISPID_SNAPIN_HELP_FILE                                 22
#define DISPID_SNAPIN_RUNTIME_MODE                              23
#define DISPID_SNAPIN_TASKPAD_VIEW_PREFERRED                    24
#define DISPID_SNAPIN_REQUIRED_EXTENSIONS                       25
#define DISPID_SNAPIN_CONSOLE_MSGBOX                            26
#define DISPID_SNAPIN_SHOW_HELP_TOPIC                           27
#define DISPID_SNAPIN_EXTENSION_SNAPIN                          28
#define DISPID_SNAPIN_TRACE                                     29
#define DISPID_SNAPIN_FIRE_CONFIG_COMPLETE                      30
#define DISPID_SNAPIN_PRELOAD                                   31
#define DISPID_SNAPIN_STRINGTABLE                               32
#define DISPID_SNAPIN_FORMAT_DATA                               33
#define DISPID_SNAPIN_LINKED_TOPICS                             34
#define DISPID_SNAPIN_CURRENT_VIEW                              35
#define DISPID_SNAPIN_CURRENT_SCOPEPANEITEM                     36
#define DISPID_SNAPIN_CURRENT_SCOPEITEM                         37
#define DISPID_SNAPIN_CURRENT_RESULTVIEW                        38
#define DISPID_SNAPIN_CURRENT_LISTVIEW                          39
#define DISPID_SNAPIN_MMC_COMMAND_LINE                          40

// DSnapInEvents
#define DISPID_SNAPIN_EVENT_LOAD                                1
#define DISPID_SNAPIN_EVENT_UNLOAD                              2
#define DISPID_SNAPIN_EVENT_HELP                                3
#define DISPID_SNAPIN_EVENT_WRITE_PROPERTIES                    4
#define DISPID_SNAPIN_EVENT_READ_PROPERTIES                     5
#define DISPID_SNAPIN_EVENT_QUERY_CONFIGURATION_WIZARD          6
#define DISPID_SNAPIN_EVENT_CREATE_CONFIGURATION_WIZARD         7
#define DISPID_SNAPIN_EVENT_CONFIGURATION_COMPLETE              8
#define DISPID_SNAPIN_EVENT_PRELOAD                             9


// DExtensionSnapInEvents
#define DISPID_EXTENSIONSNAPIN_EVENT_EXPAND                     1
#define DISPID_EXTENSIONSNAPIN_EVENT_EXPAND_SYNC                2
#define DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE                   3
#define DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE_SYNC              4
#define DISPID_EXTENSIONSNAPIN_EVENT_SET_CONTROLBAR             5
#define DISPID_EXTENSIONSNAPIN_EVENT_UPDATE_CONTROLBAR          6
#define DISPID_EXTENSIONSNAPIN_EVENT_ADD_NEW_MENU_ITEMS         7
#define DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASK_MENU_ITEMS        8
#define DISPID_EXTENSIONSNAPIN_EVENT_CREATE_PROPERTY_PAGES      9
#define DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASKS                  10
#define DISPID_EXTENSIONSNAPIN_EVENT_TASK_CLICK                 11

// IScopeItems
#define DISPID_SCOPEITEMS_ITEM                                  DISPID_VALUE
#define DISPID_SCOPEITEMS_COUNT                                 1
#define DISPID_SCOPEITEMS_ADD                                   2
#define DISPID_SCOPEITEMS_ADD_PREDEFINED                        3
#define DISPID_SCOPEITEMS_REMOVE                                4

// DScopeItemsEvents
#define DISPID_SCOPEITEMS_EVENT_INITIALIZE                      1
#define DISPID_SCOPEITEMS_EVENT_TERMINATE                       2
#define DISPID_SCOPEITEMS_EVENT_GET_DISPLAY_INFO                3
#define DISPID_SCOPEITEMS_EVENT_EXPAND                          4
#define DISPID_SCOPEITEMS_EVENT_EXPAND_SYNC                     5
#define DISPID_SCOPEITEMS_EVENT_COLLAPSE                        6
#define DISPID_SCOPEITEMS_EVENT_COLLAPSE_SYNC                   7
#define DISPID_SCOPEITEMS_EVENT_RENAME                          8
#define DISPID_SCOPEITEMS_EVENT_DELETE                          9
#define DISPID_SCOPEITEMS_EVENT_REMOVE_CHILDREN                 10
#define DISPID_SCOPEITEMS_EVENT_PROPERTY_CHANGE                 11
#define DISPID_SCOPEITEMS_EVENT_HELP                            12
#define DISPID_SCOPEITEMS_EVENT_PROPERTY_CHANGED                13

// IScopeItem
#define DISPID_SCOPEITEM_NAME                                   DISPID_VALUE
#define DISPID_SCOPEITEM_INDEX                                  1
#define DISPID_SCOPEITEM_KEY                                    2
#define DISPID_SCOPEITEM_FOLDER                                 3
#define DISPID_SCOPEITEM_DATA                                   4
#define DISPID_SCOPEITEM_DEFAULT_DATA_FORMAT                    5
#define DISPID_SCOPEITEM_DYNAMIC_EXTENSIONS                     6
#define DISPID_SCOPEITEM_SLOW_RETRIEVAL                         7
#define DISPID_SCOPEITEM_NODE_ID                                8
#define DISPID_SCOPEITEM_TAG                                    9
#define DISPID_SCOPEITEM_SCOPENODE                              10
#define DISPID_SCOPEITEM_PASTED                                 11
#define DISPID_SCOPEITEM_UPDATE_ALL_VIEWS                       12
#define DISPID_SCOPEITEM_COLUMN_HEADERS                         13
#define DISPID_SCOPEITEM_SUBITEMS                               14
#define DISPID_SCOPEITEM_LIST_SUBITEMS                          15
#define DISPID_SCOPEITEM_BOLD                                   16
#define DISPID_SCOPEITEM_PROPERTY_CHANGED                       17
#define DISPID_SCOPEITEM_REMOVE_CHILDREN                        18

// IScopeNode
#define DISPID_SCOPENODE_NODE_TYPE_NAME                         1
#define DISPID_SCOPENODE_NODE_TYPE_GUID                         2
#define DISPID_SCOPENODE_DISPLAY_NAME                           3
#define DISPID_SCOPENODE_PARENT                                 4
#define DISPID_SCOPENODE_HAS_CHILDREN                           5
#define DISPID_SCOPENODE_CHILD                                  6
#define DISPID_SCOPENODE_FIRST_SIBLING                          7  
#define DISPID_SCOPENODE_NEXT                                   8
#define DISPID_SCOPENODE_LAST_SIBLING                           9 
#define DISPID_SCOPENODE_EXPANDEDONCE                           10
#define DISPID_SCOPENODE_OWNED                                  11
#define DISPID_SCOPENODE_EXPAND_IN_NAMESPACE                    12

// IViews
#define DISPID_VIEWS_ITEM                                       DISPID_VALUE
#define DISPID_VIEWS_COUNT                                      1
#define DISPID_VIEWS_CURRENT_VIEW                               2
#define DISPID_VIEWS_ADD                                        3
#define DISPID_VIEWS_CLEAR                                      4
#define DISPID_VIEWS_REMOVE                                     5

// DViewsEvents
#define DISPID_VIEWS_EVENT_INITIALIZE                           1
#define DISPID_VIEWS_EVENT_TERMINATE                            2
#define DISPID_VIEWS_EVENT_ACTIVATE                             3
#define DISPID_VIEWS_EVENT_DEACTIVATE                           4
#define DISPID_VIEWS_EVENT_MINIMIZE                             5
#define DISPID_VIEWS_EVENT_MAXIMIZE                             6
#define DISPID_VIEWS_EVENT_SET_CONTROL_BAR                      7
#define DISPID_VIEWS_EVENT_UPDATE_CONTROLBAR                    8
#define DISPID_VIEWS_EVENT_SELECT                               9
#define DISPID_VIEWS_EVENT_ADD_TOP_MENU_ITEMS                   10
#define DISPID_VIEWS_EVENT_ADD_NEW_MENU_ITEMS                   11
#define DISPID_VIEWS_EVENT_ADD_TASK_MENU_ITEMS                  12
#define DISPID_VIEWS_EVENT_ADD_VIEW_MENU_ITEMS                  13
#define DISPID_VIEWS_EVENT_GET_MULTISELECT_DATA                 14
#define DISPID_VIEWS_EVENT_QUERY_PASTE                          15
#define DISPID_VIEWS_EVENT_PASTE                                16
#define DISPID_VIEWS_EVENT_CUT                                  17
#define DISPID_VIEWS_EVENT_DELETE                               18
#define DISPID_VIEWS_EVENT_QUERY_PAGES_FOR                      19
#define DISPID_VIEWS_EVENT_CREATE_PROPERTY_PAGES                20
#define DISPID_VIEWS_EVENT_REFRESH                              21
#define DISPID_VIEWS_EVENT_PRINT                                22
#define DISPID_VIEWS_EVENT_SPECIAL_PROPERTIES_CLICK             23
#define DISPID_VIEWS_EVENT_LOAD                                 24
#define DISPID_VIEWS_EVENT_WRITE_PROPERTIES                     25
#define DISPID_VIEWS_EVENT_READ_PROPERTIES                      26


// IView
#define DISPID_VIEW_NAME                                        DISPID_VALUE
#define DISPID_VIEW_INDEX                                       1
#define DISPID_VIEW_KEY                                         2
#define DISPID_VIEW_SCOPEPANEITEMS                              3
#define DISPID_VIEW_TAG                                         4
#define DISPID_VIEW_CAPTION                                     5
#define DISPID_VIEW_SET_STATUS_BAR_TEXT                         6
#define DISPID_VIEW_CONTEXT_MENU_PROVIDER                       7
#define DISPID_VIEW_PROPERTY_SHEET_PROVIDER                     8
#define DISPID_VIEW_MMC_MAJOR_VERSION                           9
#define DISPID_VIEW_MMC_MINOR_VERSION                           10
#define DISPID_VIEW_SELECT_SCOPE_ITEM                           11
#define DISPID_VIEW_POPUP_MENU                                  12
#define DISPID_VIEW_COLUMN_SETTINGS                             13
#define DISPID_VIEW_SORT_SETTINGS                               14
#define DISPID_VIEW_EXPAND_IN_TREEVIEW                          15
#define DISPID_VIEW_COLLAPSE_IN_TREEVIEW                        16
#define DISPID_VIEW_NEW_WINDOW                                  17

// IScopePaneItems
#define DISPID_SCOPEPANEITEMS_ITEM                              DISPID_VALUE
#define DISPID_SCOPEPANEITEMS_COUNT                             1
#define DISPID_SCOPEPANEITEMS_SELECTED_ITEM                     2
#define DISPID_SCOPEPANEITEMS_PARENT                            3

// DScopePaneItemsEvents
#define DISPID_SCOPEPANEITEMS_EVENT_INITIALIZE                      1
#define DISPID_SCOPEPANEITEMS_EVENT_TERMINATE                       2
#define DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW_INFO             3
#define DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW                  4
#define DISPID_SCOPEPANEITEMS_EVENT_GET_COLUMN_SET_ID               5

// IScopePaneItem
#define DISPID_SCOPEPANEITEM_NAME                                   DISPID_VALUE
#define DISPID_SCOPEPANEITEM_INDEX                                  1
#define DISPID_SCOPEPANEITEM_KEY                                    2
#define DISPID_SCOPEPANEITEM_SCOPEITEM                              3
#define DISPID_SCOPEPANEITEM_RESULTVIEW_TYPE                        4
#define DISPID_SCOPEPANEITEM_DISPLAY_STRING                         5
#define DISPID_SCOPEPANEITEM_HAS_LISTVIEWS                          6
#define DISPID_SCOPEPANEITEM_RESULTVIEW                             7
#define DISPID_SCOPEPANEITEM_RESULTVIEWS                            8
#define DISPID_SCOPEPANEITEM_PARENT                                 9
#define DISPID_SCOPEPANEITEM_TAG                                    10
#define DISPID_SCOPEPANEITEM_DISPLAY_NEW_RESULTVIEW                 11
#define DISPID_SCOPEPANEITEM_COLUMN_SET_ID                          12
#define DISPID_SCOPEPANEITEM_DISPLAY_MESSAGEVIEW                    13

// IResultViews
#define DISPID_RESULTVIEWS_ITEM                                 DISPID_VALUE
#define DISPID_RESULTVIEWS_COUNT                                1
#define DISPID_RESULTVIEWS_ADD                                  2
#define DISPID_RESULTVIEWS_CLEAR                                3
#define DISPID_RESULTVIEWS_REMOVE                               4

// DResultViewsEvents
#define DISPID_RESULTVIEWS_EVENT_INITIALIZE                     1
#define DISPID_RESULTVIEWS_EVENT_INITIALIZE_CONTROL             2
#define DISPID_RESULTVIEWS_EVENT_TERMINATE                      3
#define DISPID_RESULTVIEWS_EVENT_GET_DISPLAY_INFO               4
#define DISPID_RESULTVIEWS_EVENT_HELP                           5
#define DISPID_RESULTVIEWS_EVENT_LISTITEM_DBLCLICK              6
#define DISPID_RESULTVIEWS_EVENT_SCOPEITEM_DBLCLICK             7
#define DISPID_RESULTVIEWS_EVENT_PROPERTY_CHANGE                8
#define DISPID_RESULTVIEWS_EVENT_ITEM_RENAME                    9
#define DISPID_RESULTVIEWS_EVENT_ACTIVATE                       10
#define DISPID_RESULTVIEWS_EVENT_DEACTIVATE                     11
#define DISPID_RESULTVIEWS_EVENT_ITEM_VIEW_CHANGE               12
#define DISPID_RESULTVIEWS_EVENT_COLUMN_CLICK                   13
#define DISPID_RESULTVIEWS_EVENT_DESELECT_ALL                   14
#define DISPID_RESULTVIEWS_EVENT_COMPARE_ITEMS                  15
#define DISPID_RESULTVIEWS_EVENT_FIND_ITEM                      16
#define DISPID_RESULTVIEWS_EVENT_CACHE_HINT                     17
#define DISPID_RESULTVIEWS_EVENT_SORT_ITEMS                     18
#define DISPID_RESULTVIEWS_EVENT_TASK_CLICK                     19
#define DISPID_RESULTVIEWS_EVENT_LISTPAD_BUTTON_CLICK           20
#define DISPID_RESULTVIEWS_EVENT_TASK_NOTIFY                    21
#define DISPID_RESULTVIEWS_EVENT_PROPERTY_CHANGED               22
#define DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DATA          23
#define DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DISPLAY_INFO  24
#define DISPID_RESULTVIEWS_EVENT_COLUMNS_CHANGED                25
#define DISPID_RESULTVIEWS_EVENT_FILTER_CHANGE                  26
#define DISPID_RESULTVIEWS_EVENT_FILTER_BUTTON_CLICK            27


// IResultView
#define DISPID_RESULTVIEW_NAME                                  DISPID_VALUE
#define DISPID_RESULTVIEW_INDEX                                 1
#define DISPID_RESULTVIEW_KEY                                   2
#define DISPID_RESULTVIEW_SCOPEPANEITEM                         3
#define DISPID_RESULTVIEW_CONTROL                               4
#define DISPID_RESULTVIEW_ADD_TO_VIEW_MENU                      5
#define DISPID_RESULTVIEW_VIEW_MENU_TEXT                        6
#define DISPID_RESULTVIEW_DATA                                  7
#define DISPID_RESULTVIEW_TYPE                                  8
#define DISPID_RESULTVIEW_DISPLAY_STRING                        9
#define DISPID_RESULTVIEW_LISTVIEW                              10
#define DISPID_RESULTVIEW_TASKPAD                               11
#define DISPID_RESULTVIEW_MESSAGEVIEW                           12
#define DISPID_RESULTVIEW_TAG                                   13
#define DISPID_RESULTVIEW_DEFAULT_ITEM_TYPE_GUID                14
#define DISPID_RESULTVIEW_DEFAULT_DATA_FORMAT                   15
#define DISPID_RESULTVIEW_ALWAYS_CREATE_NEW_OCX                 16
#define DISPID_RESULTVIEW_SET_DESCBAR_TEXT                      17

// IMMCImageList
#define DISPID_IMAGELIST_NAME                                   DISPID_VALUE
#define DISPID_IMAGELIST_INDEX                                  1
#define DISPID_IMAGELIST_KEY                                    2
#define DISPID_IMAGELIST_TAG                                    3
#define DISPID_IMAGELIST_MASK_COLOR                             4
#define DISPID_IMAGELIST_LIST_IMAGES                            5

// IMMCImages
#define DISPID_IMAGES_ITEM                                      DISPID_VALUE
#define DISPID_IMAGES_COUNT                                     1
#define DISPID_IMAGES_ADD                                       2
#define DISPID_IMAGES_CLEAR                                     3
#define DISPID_IMAGES_REMOVE                                    4

// IMMCImage
#define DISPID_IMAGE_INDEX                                      1
#define DISPID_IMAGE_KEY                                        2
#define DISPID_IMAGE_TAG                                        3
#define DISPID_IMAGE_PICTURE                                    4

// IMMCListView
#define DISPID_LISTVIEW_COLUMN_HEADERS                          1
#define DISPID_LISTVIEW_ICONS                                   2
#define DISPID_LISTVIEW_LIST_ITEMS                              3
#define DISPID_LISTVIEW_SELECTED_ITEMS                          4
#define DISPID_LISTVIEW_SMALL_ICONS                             5
#define DISPID_LISTVIEW_SORTED                                  6
#define DISPID_LISTVIEW_SORT_KEY                                7
#define DISPID_LISTVIEW_SORT_ORDER                              8
#define DISPID_LISTVIEW_VIEW                                    9
#define DISPID_LISTVIEW_VIRTUAL                                 10
#define DISPID_LISTVIEW_USE_FONT_LINKING                        11
#define DISPID_LISTVIEW_MULTI_SELECT                            12
#define DISPID_LISTVIEW_HIDE_SELECTION                          13
#define DISPID_LISTVIEW_SORT_HEADER                             14
#define DISPID_LISTVIEW_SORT_ICON                               15
#define DISPID_LISTVIEW_FILTER_CHANGE_TIMEOUT                   16
#define DISPID_LISTVIEW_SHOW_CHILD_SCOPEITEMS                   17
#define DISPID_LISTVIEW_LEXICAL_SORT                            18
#define DISPID_LISTVIEW_TAG                                     19
#define DISPID_LISTVIEW_SET_SCOPE_ITEM_STATE                    20

// IMMCListItems
#define DISPID_LISTITEMS_ITEM                                   DISPID_VALUE
#define DISPID_LISTITEMS_COUNT                                  1
#define DISPID_LISTITEMS_ADD                                    2
#define DISPID_LISTITEMS_CLEAR                                  3
#define DISPID_LISTITEMS_REMOVE                                 4
#define DISPID_LISTITEMS_SET_ITEM_COUNT                         5

// IMMCListItem
#define DISPID_LISTITEM_TEXT                                    DISPID_VALUE
#define DISPID_LISTITEM_INDEX                                   1
#define DISPID_LISTITEM_KEY                                     2
#define DISPID_LISTITEM_ID                                      3
#define DISPID_LISTITEM_TAG                                     4
#define DISPID_LISTITEM_ICON                                    5
#define DISPID_LISTITEM_SMALL_ICON                              6
#define DISPID_LISTITEM_SELECTED                                7
#define DISPID_LISTITEM_CUT                                     8
#define DISPID_LISTITEM_DROPHILITED                             9
#define DISPID_LISTITEM_FOCUSED                                 10
#define DISPID_LISTITEM_PASTED                                  11
#define DISPID_LISTITEM_SUBITEMS                                12
#define DISPID_LISTITEM_LIST_SUBITEMS                           13
#define DISPID_LISTITEM_DYNAMIC_EXTENSIONS                      14
#define DISPID_LISTITEM_UPDATE                                  15
#define DISPID_LISTITEM_DATA                                    16
#define DISPID_LISTITEM_UPDATE_ALL_VIEWS                        17
#define DISPID_LISTITEM_ITEM_TYPE_GUID                          18
#define DISPID_LISTITEM_DEFAULT_DATA_FORMAT                     19
#define DISPID_LISTITEM_PROPERTY_CHANGED                        20

// IMMCListSubItems
#define DISPID_LISTSUBITEMS_ITEM                                DISPID_VALUE
#define DISPID_LISTSUBITEMS_COUNT                               1
#define DISPID_LISTSUBITEMS_ADD                                 2
#define DISPID_LISTSUBITEMS_CLEAR                               3
#define DISPID_LISTSUBITEMS_REMOVE                              4

// IMMCListSubItem
#define DISPID_LISTSUBITEM_TEXT                                 DISPID_VALUE
#define DISPID_LISTSUBITEM_INDEX                                1
#define DISPID_LISTSUBITEM_KEY                                  2
#define DISPID_LISTSUBITEM_TAG                                  3

// IMMCColumnHeaders
#define DISPID_COLUMNHEADERS_ITEM                               DISPID_VALUE
#define DISPID_COLUMNHEADERS_COUNT                              1
#define DISPID_COLUMNHEADERS_ADD                                2
#define DISPID_COLUMNHEADERS_CLEAR                              3
#define DISPID_COLUMNHEADERS_REMOVE                             4

// IMMCColumnHeaders
#define DISPID_COLUMNHEADER_TEXT                                DISPID_VALUE
#define DISPID_COLUMNHEADER_INDEX                               1
#define DISPID_COLUMNHEADER_KEY                                 2
#define DISPID_COLUMNHEADER_TAG                                 3
#define DISPID_COLUMNHEADER_WIDTH                               4
#define DISPID_COLUMNHEADER_ALIGNMENT                           5
#define DISPID_COLUMNHEADER_HIDDEN                              6
#define DISPID_COLUMNHEADER_POSITION                            7
#define DISPID_COLUMNHEADER_TEXT_FILTER                         8
#define DISPID_COLUMNHEADER_NUMERIC_FILTER                      9
#define DISPID_COLUMNHEADER_TEXT_FILTER_MAX_LEN                 10

// IColumnSettings
#define DISPID_COLUMNSETTINGS_ITEM                              DISPID_VALUE
#define DISPID_COLUMNSETTINGS_COLUMN_SET_ID                     1
#define DISPID_COLUMNSETTINGS_COUNT                             2
#define DISPID_COLUMNSETTINGS_ADD                               3
#define DISPID_COLUMNSETTINGS_CLEAR                             4
#define DISPID_COLUMNSETTINGS_REMOVE                            5
#define DISPID_COLUMNSETTINGS_PERSIST                           6

// IColumnSetting
#define DISPID_COLUMNSETTING_INDEX                              1
#define DISPID_COLUMNSETTING_KEY                                2
#define DISPID_COLUMNSETTING_WIDTH                              3
#define DISPID_COLUMNSETTING_HIDDEN                             4
#define DISPID_COLUMNSETTING_POSITION                           5

// ISortKeys
#define DISPID_SORTKEYS_ITEM                                    DISPID_VALUE
#define DISPID_SORTKEYS_COLUMN_SET_ID                           2
#define DISPID_SORTKEYS_COUNT                                   3
#define DISPID_SORTKEYS_ADD                                     4
#define DISPID_SORTKEYS_CLEAR                                   5
#define DISPID_SORTKEYS_REMOVE                                  6
#define DISPID_SORTKEYS_PERSIST                                 7

// ISortKey
#define DISPID_SORTKEY_INDEX                                    1
#define DISPID_SORTKEY_KEY                                      2
#define DISPID_SORTKEY_COLUMN                                   3
#define DISPID_SORTKEY_SORTORDER                                4
#define DISPID_SORTKEY_SORTICON                                 5

// ISnapInData
#define DISPID_SNAPINDATA_ITEM                                  DISPID_VALUE
#define DISPID_SNAPINDATA_CLEAR                                 1
#define DISPID_SNAPINDATA_REMOVE                                2

// IMMCDataObjects
#define DISPID_DATAOBJECTS_ITEM                                 DISPID_VALUE
#define DISPID_DATAOBJECTS_COUNT                                1
#define DISPID_DATAOBJECTS_ADD                                  2
#define DISPID_DATAOBJECTS_CLEAR                                3
#define DISPID_DATAOBJECTS_REMOVE                               4

// IMMCDataObject
#define DISPID_DATAOBJECT_DEFAULT_DATA_FORMAT                   DISPID_VALUE
#define DISPID_DATAOBJECT_INDEX                                 1
#define DISPID_DATAOBJECT_KEY                                   2
#define DISPID_DATAOBJECT_OBJECT_TYPES                          3
#define DISPID_DATAOBJECT_CLEAR                                 4
#define DISPID_DATAOBJECT_GET_DATA                              5
#define DISPID_DATAOBJECT_GET_RAW_DATA                          6
#define DISPID_DATAOBJECT_GET_FORMAT                            7
#define DISPID_DATAOBJECT_SET_DATA                              8
#define DISPID_DATAOBJECT_SET_RAW_DATA                          9
#define DISPID_DATAOBJECT_FORMAT_DATA                           10

// IMMCClipboard
#define DISPID_CLIPBOARD_SELECTION_TYPE                         1
#define DISPID_CLIPBOARD_SCOPEITEMS                             2
#define DISPID_CLIPBOARD_LISTITEMS                              3
#define DISPID_CLIPBOARD_DATAOBJECTS                            4

// IMMCMenu
#define DISPID_MENU_NAME                                        DISPID_VALUE
#define DISPID_MENU_INDEX                                       1
#define DISPID_MENU_KEY                                         2
#define DISPID_MENU_CAPTION                                     3
#define DISPID_MENU_VISIBLE                                     4
#define DISPID_MENU_CHECKED                                     5
#define DISPID_MENU_ENABLED                                     6
#define DISPID_MENU_GRAYED                                      7
#define DISPID_MENU_MENU_BREAK                                  8
#define DISPID_MENU_MENU_BAR_BREAK                              9
#define DISPID_MENU_TAG                                         10
#define DISPID_MENU_STATUS_BAR_TEXT                             11
#define DISPID_MENU_CHILDREN                                    12
#define DISPID_MENU_DEFAULT                                     13

// DMMCMenuEvents
#define DISPID_MENU_EVENT_CLICK                                 1

// IMMCMenus
#define DISPID_MENUS_COUNT                                      1
#define DISPID_MENUS_ADD                                        2
#define DISPID_MENUS_ADD_EXISTING                               3
#define DISPID_MENUS_CLEAR                                      4
#define DISPID_MENUS_REMOVE                                     5
#define DISPID_MENUS_SWAP                                       6

// IContextMenu
#define DISPID_CONTEXTMENU_ADD_MENU                             1

// IMMCContextMenuProvider
#define DISPID_CONTEXTMENUPROVIDER_ADD_SNAPIN_ITEMS             1
#define DISPID_CONTEXTMENUPROVIDER_ADD_EXTENSION_ITEMS          2
#define DISPID_CONTEXTMENUPROVIDER_ADD_SHOW_CONTEXT_MENU        3
#define DISPID_CONTEXTMENUPROVIDER_CLEAR                        4

// IPropertySheet
#define DISPID_PROPERTYSHEET_ADD_PAGE                           1
#define DISPID_PROPERTYSHEET_ADD_WIZARD_PAGE                    2
#define DISPID_PROPERTYSHEET_ADD_PAGE_PROVIDER                  3
#define DISPID_PROPERTYSHEET_CHANGE_CANCEL_TO_CLOSE             4
#define DISPID_PROPERTYSHEET_INSERT_PAGE                        5
#define DISPID_PROPERTYSHEET_PRESS_BUTTON                       6
#define DISPID_PROPERTYSHEET_RECALC_PAGE_SIZES                  7
#define DISPID_PROPERTYSHEET_REMOVE_PAGE                        8
#define DISPID_PROPERTYSHEET_ACTIVATE_PAGE                      9
#define DISPID_PROPERTYSHEET_SET_FINISH_BUTTON_TEXT             10
#define DISPID_PROPERTYSHEET_SET_TITLE                          11
#define DISPID_PROPERTYSHEET_SET_WIZARD_BUTTONS                 12
#define DISPID_PROPERTYSHEET_GET_PAGE_POSITION                  13
#define DISPID_PROPERTYSHEET_RESTART_WINDOWS                    14
#define DISPID_PROPERTYSHEET_REBOOT_SYSTEM                      15


// IMMCPropertySheetProvider
#define DISPID_PROPERTYSHEETPROVIDER_CREATE_PROPERTY_SHEET      1
#define DISPID_PROPERTYSHEETPROVIDER_ADD_PRIMARY_PAGES          2
#define DISPID_PROPERTYSHEETPROVIDER_ADD_EXTENSION_ITEMS        3
#define DISPID_PROPERTYSHEETPROVIDER_FIND_PROPERTY_SHEET        4
#define DISPID_PROPERTYSHEETPROVIDER_SHOW                       5
#define DISPID_PROPERTYSHEETPROVIDER_CLEAR                      6

// IControlBar
#define DISPID_CONTROLBAR_ATTACH                                1
#define DISPID_CONTROLBAR_DETACH                                2

// IConsoleVerbs
#define DISPID_CONSOLEVERBS_ITEM                                DISPID_VALUE
#define DISPID_CONSOLEVERBS_COUNT                               1
#define DISPID_CONSOLEVERBS_DEFAULT_VERB                        2

// IConsoleVerb
#define DISPID_CONSOLEVERB_INDEX                                1
#define DISPID_CONSOLEVERB_KEY                                  2
#define DISPID_CONSOLEVERB_VERB                                 3
#define DISPID_CONSOLEVERB_ENABLED                              4
#define DISPID_CONSOLEVERB_CHECKED                              5
#define DISPID_CONSOLEVERB_HIDDEN                               6
#define DISPID_CONSOLEVERB_INDETERMINATE                        7
#define DISPID_CONSOLEVERB_BUTTON_PRESSED                       8
#define DISPID_CONSOLEVERB_DEFAULT                              9

// IMMCToolbar
#define DISPID_TOOLBAR_NAME                                     DISPID_VALUE
#define DISPID_TOOLBAR_INDEX                                    1
#define DISPID_TOOLBAR_KEY                                      2
#define DISPID_TOOLBAR_BUTTONS                                  3
#define DISPID_TOOLBAR_IMAGE_LIST                               4
#define DISPID_TOOLBAR_TAG                                      5

// DMMCToolbarEvents
#define DISPID_TOOLBAR_EVENT_BUTTON_CLICK                       1
#define DISPID_TOOLBAR_EVENT_BUTTON_DROPDOWN                    2
#define DISPID_TOOLBAR_EVENT_BUTTON_MENU_CLICK                  3

// IMMCButtons
#define DISPID_BUTTONS_ITEM                                     DISPID_VALUE
#define DISPID_BUTTONS_COUNT                                    1
#define DISPID_BUTTONS_ADD                                      2
#define DISPID_BUTTONS_CLEAR                                    3
#define DISPID_BUTTONS_REMOVE                                   4

// IMMCButton
#define DISPID_BUTTON_BUTTON_MENUS                              1
#define DISPID_BUTTON_CAPTION                                   2
#define DISPID_BUTTON_ENABLED                                   3
#define DISPID_BUTTON_IMAGE                                     4
#define DISPID_BUTTON_INDEX                                     5
#define DISPID_BUTTON_KEY                                       6
#define DISPID_BUTTON_MIXEDSTATE                                7
#define DISPID_BUTTON_STYLE                                     8
#define DISPID_BUTTON_TAG                                       9
#define DISPID_BUTTON_TOOLTIP_TEXT                              10
#define DISPID_BUTTON_VALUE                                     11
#define DISPID_BUTTON_VISIBLE                                   12

// IMMCButtonMenus
#define DISPID_BUTTONMENUS_ITEM                                 DISPID_VALUE
#define DISPID_BUTTONMENUS_COUNT                                1
#define DISPID_BUTTONMENUS_PARENT                               2
#define DISPID_BUTTONMENUS_ADD                                  3
#define DISPID_BUTTONMENUS_CLEAR                                4
#define DISPID_BUTTONMENUS_REMOVE                               5

// IMMCButtonMenu
#define DISPID_BUTTONMENU_ENABLED                               1
#define DISPID_BUTTONMENU_INDEX                                 2
#define DISPID_BUTTONMENU_KEY                                   3
#define DISPID_BUTTONMENU_PARENT                                4
#define DISPID_BUTTONMENU_TAG                                   5
#define DISPID_BUTTONMENU_TEXT                                  6
#define DISPID_BUTTONMENU_VISIBLE                               7
#define DISPID_BUTTONMENU_CHECKED                               8
#define DISPID_BUTTONMENU_GRAYED                                9
#define DISPID_BUTTONMENU_SEPARATOR                             10
#define DISPID_BUTTONMENU_MENU_BREAK                            11
#define DISPID_BUTTONMENU_MENU_BAR_BREAK                        12


// ITaskPad
#define DISPID_TASKPAD_NAME                                     DISPID_VALUE
#define DISPID_TASKPAD_TYPE                                     1
#define DISPID_TASKPAD_TITLE                                    2
#define DISPID_TASKPAD_DESCRIPTIVE_TEXT                         3
#define DISPID_TASKPAD_URL                                      4
#define DISPID_TASKPAD_BACKGROUND_TYPE                          5
#define DISPID_TASKPAD_MOUSE_OVER_IMAGE                         6
#define DISPID_TASKPAD_MOUSE_OFF_IMAGE                          7
#define DISPID_TASKPAD_FONT_FAMILY                              8
#define DISPID_TASKPAD_EOT_FILE                                 9
#define DISPID_TASKPAD_SYMBOL_STRING                            10
#define DISPID_TASKPAD_LISTPAD_STYLE                            11
#define DISPID_TASKPAD_LISTPAD_TITLE                            12
#define DISPID_TASKPAD_LISTPAD_HAS_BUTTON                       13
#define DISPID_TASKPAD_LISTPAD_BUTTON_TEXT                      14
#define DISPID_TASKPAD_LISTVIEW                                 15
#define DISPID_TASKPAD_TASKS                                    16

// ITasks
#define DISPID_TASKS_ITEM                                       DISPID_VALUE
#define DISPID_TASKS_COUNT                                      1
#define DISPID_TASKS_ADD                                        2
#define DISPID_TASKS_CLEAR                                      3
#define DISPID_TASKS_REMOVE                                     4

// ITask
#define DISPID_TASK_TEXT                                        DISPID_VALUE
#define DISPID_TASK_INDEX                                       1
#define DISPID_TASK_KEY                                         2
#define DISPID_TASK_VISIBLE                                     3
#define DISPID_TASK_TAG                                         4
#define DISPID_TASK_IMAGE_TYPE                                  5
#define DISPID_TASK_MOUSE_OVER_IMAGE                            6
#define DISPID_TASK_MOUSE_OFF_IMAGE                             7
#define DISPID_TASK_FONT_FAMILY                                 8
#define DISPID_TASK_EOT_FILE                                    9
#define DISPID_TASK_SYMBOL_STRING                               10
#define DISPID_TASK_HELP_STRING                                 11
#define DISPID_TASK_ACTION_TYPE                                 12
#define DISPID_TASK_URL                                         13
#define DISPID_TASK_SCRIPT                                      14

// IMMCMessageView
#define DISPID_MESSAGEVIEW_TITLE_TEXT                           1
#define DISPID_MESSAGEVIEW_BODY_TEXT                            2
#define DISPID_MESSAGEVIEW_ICON_TYPE                            3
#define DISPID_MESSAGEVIEW_CLEAR                                4

// IExtensions
#define DISPID_EXTENSIONS_ITEM                                  DISPID_VALUE
#define DISPID_EXTENSIONS_COUNT                                 1
#define DISPID_EXTENSIONS_ENABLE_ALL                            2
#define DISPID_EXTENSIONS_ENABLE_ALL_STATIC                     3

// IExtension
#define DISPID_EXTENSION_INDEX                                  1
#define DISPID_EXTENSION_KEY                                    2
#define DISPID_EXTENSION_CLSID                                  3
#define DISPID_EXTENSION_NAME                                   4
#define DISPID_EXTENSION_TYPE                                   5
#define DISPID_EXTENSION_EXTENDS_NAME_SPACE                     6
#define DISPID_EXTENSION_EXTENDS_CONTEXT_MENU                   7
#define DISPID_EXTENSION_EXTENDS_TOOLBAR                        8
#define DISPID_EXTENSION_EXTENDS_PROPERTY_SHEET                 9
#define DISPID_EXTENSION_EXTENDS_TASKPAD                        10
#define DISPID_EXTENSION_ENABLED                                11
#define DISPID_EXTENSION_NAMESPACE_ENABLED                      12

// IMMCStringTable
#define DISPID_MMCSTRINGTABLE_ADD                               1
#define DISPID_MMCSTRINGTABLE_FIND                              2
#define DISPID_MMCSTRINGTABLE_REMOVE                            3
#define DISPID_MMCSTRINGTABLE_CLEAR                             4

//=-------------------------------------------------------------------------=
//
//                  Extensibility Object Model DISPIDs
//
//=-------------------------------------------------------------------------=

// ISnapInDesignerDef
#define DISPID_SNAPINDESIGNERDEF_SNAPINDEF                         1
#define DISPID_SNAPINDESIGNERDEF_EXTENSIONDEFS                     2
#define DISPID_SNAPINDESIGNERDEF_AUTOCREATE_NODES                  3
#define DISPID_SNAPINDESIGNERDEF_OTHER_NODES                       4
#define DISPID_SNAPINDESIGNERDEF_IMAGELISTS                        5
#define DISPID_SNAPINDESIGNERDEF_MENUS                             6
#define DISPID_SNAPINDESIGNERDEF_TOOLBARS                          7
#define DISPID_SNAPINDESIGNERDEF_VIEWDEFS                          8
#define DISPID_SNAPINDESIGNERDEF_DATA_FORMATS                      9
#define DISPID_SNAPINDESIGNERDEF_REGINFO                           10
#define DISPID_SNAPINDESIGNERDEF_TYPEINFO_COOKIE                   11
#define DISPID_SNAPINDESIGNERDEF_PROJECTNAME                       12

// IViewDefs
#define DISPID_VIEWDEFS_LIST_VIEWS                              1
#define DISPID_VIEWDEFS_OCX_VIEWS                               2
#define DISPID_VIEWDEFS_URL_VIEWS                               3
#define DISPID_VIEWDEFS_TASKPAD_VIEWS                           4

// ISnapInDef
#define DISPID_SNAPINDEF_NAME                                   DISPID_VALUE
#define DISPID_SNAPINDEF_NODE_TYPE_NAME                         1
#define DISPID_SNAPINDEF_NODE_TYPE_GUID                         2
#define DISPID_SNAPINDEF_DISPLAY_NAME                           3
#define DISPID_SNAPINDEF_TYPE                                   4
#define DISPID_SNAPINDEF_HELP_FILE                              5
#define DISPID_SNAPINDEF_DESCRIPTION                            6
#define DISPID_SNAPINDEF_PROVIDER                               7
#define DISPID_SNAPINDEF_VERSION                                8
#define DISPID_SNAPINDEF_SMALL_FOLDERS                          9
#define DISPID_SNAPINDEF_SMALL_FOLDERS_OPEN                     10
#define DISPID_SNAPINDEF_LARGE_FOLDERS                          11
#define DISPID_SNAPINDEF_ICON                                   12
#define DISPID_SNAPINDEF_WATERMARK                              13
#define DISPID_SNAPINDEF_HEADER                                 14
#define DISPID_SNAPINDEF_PALETTE                                15
#define DISPID_SNAPINDEF_STRETCH_WATERMARK                      16
#define DISPID_SNAPINDEF_STATIC_FOLDER                          17
#define DISPID_SNAPINDEF_CAPTION                                18
#define DISPID_SNAPINDEF_DEFAULTVIEW                            19
#define DISPID_SNAPINDEF_EXTENSIBLE                             20
#define DISPID_SNAPINDEF_VIEWDEFS                               21
#define DISPID_SNAPINDEF_CHILDREN                               22
#define DISPID_SNAPINDEF_IID                                    23
#define DISPID_SNAPINDEF_PRELOAD                                24
#define DISPID_SNAPINDEF_LINKED_TOPICS                          25

// IExtensionDefs
#define DISPID_EXTENSIONDEFS_NAME                               0
#define DISPID_EXTENSIONDEFS_EXTENDS_NEW_MENU                   1
#define DISPID_EXTENSIONDEFS_EXTENDS_TASK_MENU                  2
#define DISPID_EXTENSIONDEFS_EXTENDS_TOP_MENU                   3
#define DISPID_EXTENSIONDEFS_EXTENDS_VIEW_MENU                  4
#define DISPID_EXTENSIONDEFS_EXTENDS_PROPERTYPAGES              5
#define DISPID_EXTENSIONDEFS_EXTENDS_TOOLBAR                    6
#define DISPID_EXTENSIONDEFS_EXTENDS_NAMESPACE                  7
#define DISPID_EXTENSIONDEFS_EXTENDED_SNAPINS                   8

// IExtendedSnapIn
#define DISPID_EXTENDEDSNAPIN_NAME                              DISPID_VALUE
#define DISPID_EXTENDEDSNAPIN_INDEX                             1
#define DISPID_EXTENDEDSNAPIN_KEY                               2
#define DISPID_EXTENDEDSNAPIN_NODE_TYPE_GUID                    3
#define DISPID_EXTENDEDSNAPIN_NODE_TYPE_NAME                    4
#define DISPID_EXTENDEDSNAPIN_DYNAMIC                           5
#define DISPID_EXTENDEDSNAPIN_EXTENDS_NAMESPACE                 6
#define DISPID_EXTENDEDSNAPIN_EXTENDS_NEW_MENU                  7
#define DISPID_EXTENDEDSNAPIN_EXTENDS_TASK_MENU                 8
#define DISPID_EXTENDEDSNAPIN_EXTENDS_PROPERTYPAGES             9
#define DISPID_EXTENDEDSNAPIN_EXTENDS_TOOLBAR                   10
#define DISPID_EXTENDEDSNAPIN_EXTENDS_TASKPAD                   11

// IScopeItemDef
#define DISPID_SCOPEITEMDEF_NAME                                DISPID_VALUE
#define DISPID_SCOPEITEMDEF_INDEX                               1
#define DISPID_SCOPEITEMDEF_KEY                                 2
#define DISPID_SCOPEITEMDEF_NODE_TYPE_NAME                      3
#define DISPID_SCOPEITEMDEF_NODE_TYPE_GUID                      4
#define DISPID_SCOPEITEMDEF_DISPLAY_NAME                        5
#define DISPID_SCOPEITEMDEF_FOLDER                              6
#define DISPID_SCOPEITEMDEF_DEFAULT_DATA_FORMAT                 7
#define DISPID_SCOPEITEMDEF_AUTOCREATE                          8
#define DISPID_SCOPEITEMDEF_DEFAULTVIEW                         9
#define DISPID_SCOPEITEMDEF_EXTENSIBLE                          10
#define DISPID_SCOPEITEMDEF_HAS_CHILDREN                        11
#define DISPID_SCOPEITEMDEF_VIEWDEFS                            12
#define DISPID_SCOPEITEMDEF_CHILDREN                            13
#define DISPID_SCOPEITEMDEF_TAG                                 14
#define DISPID_SCOPEITEMDEF_COLUMN_HEADERS                      15

// INodeType
#define DISPID_NODETYPE_INDEX                                   1
#define DISPID_NODETYPE_KEY                                     2
#define DISPID_NODETYPE_NAME                                    3
#define DISPID_NODETYPE_GUID                                    4

// INodeTypes
#define DISPID_NODETYPES_COUNT                                  1
#define DISPID_NODETYPES_ADD                                    2
#define DISPID_NODETYPES_CLEAR                                  3
#define DISPID_NODETYPES_REMOVE                                 4

// IRegInfo
#define DISPID_REGINFO_DISPLAY_NAME                             1
#define DISPID_REGINFO_STATIC_NODE_TYPE_GUID                    2
#define DISPID_REGINFO_STANDALONE                               3
#define DISPID_REGINFO_NODETYPES                                4
#define DISPID_REGINFO_EXTENDED_SNAPINS                         5

// IListViewDef
#define DISPID_LISTVIEWDEF_NAME                                 DISPID_VALUE
#define DISPID_LISTVIEWDEF_INDEX                                1
#define DISPID_LISTVIEWDEF_KEY                                  2
#define DISPID_LISTVIEWDEF_TAG                                  3
#define DISPID_LISTVIEWDEF_ADD_TO_VIEW_MENU                     4
#define DISPID_LISTVIEWDEF_VIEW_MENU_TEXT                       5
#define DISPID_LISTVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT            6
#define DISPID_LISTVIEWDEF_DEFAULT_ITEM_TYPE_GUID               7
#define DISPID_LISTVIEWDEF_EXTENSIBLE                           8
#define DISPID_LISTVIEWDEF_MULTI_SELECT                         9
#define DISPID_LISTVIEWDEF_HIDE_SELECTION                       10
#define DISPID_LISTVIEWDEF_SORT_HEADER                          11
#define DISPID_LISTVIEWDEF_SORT_ICON                            12
#define DISPID_LISTVIEWDEF_SORTED                               13
#define DISPID_LISTVIEWDEF_SORT_KEY                             14
#define DISPID_LISTVIEWDEF_SORT_ORDER                           15
#define DISPID_LISTVIEWDEF_VIEW                                 16
#define DISPID_LISTVIEWDEF_VIRTUAL                              17
#define DISPID_LISTVIEWDEF_USE_FONT_LINKING                     18
#define DISPID_LISTVIEWDEF_FILTER_CHANGE_TIMEOUT                19
#define DISPID_LISTVIEWDEF_SHOW_CHILD_SCOPEITEMS                20
#define DISPID_LISTVIEWDEF_LEXICAL_SORT                         21
#define DISPID_LISTVIEWDEF_LISTVIEW                             22


// IOCXViewDef
#define DISPID_OCXVIEWDEF_NAME                                  DISPID_VALUE
#define DISPID_OCXVIEWDEF_INDEX                                 1
#define DISPID_OCXVIEWDEF_KEY                                   2
#define DISPID_OCXVIEWDEF_TAG                                   3
#define DISPID_OCXVIEWDEF_ADD_TO_VIEW_MENU                      4
#define DISPID_OCXVIEWDEF_VIEW_MENU_TEXT                        5
#define DISPID_OCXVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT             6
#define DISPID_OCXVIEWDEF_PROGID                                7
#define DISPID_OCXVIEWDEF_ALWAYS_CREATE_NEW_OCX                 8

// IURLViewDef
#define DISPID_URLVIEWDEF_NAME                                  DISPID_VALUE
#define DISPID_URLVIEWDEF_INDEX                                 1
#define DISPID_URLVIEWDEF_KEY                                   2
#define DISPID_URLVIEWDEF_TAG                                   3
#define DISPID_URLVIEWDEF_ADD_TO_VIEW_MENU                      4
#define DISPID_URLVIEWDEF_VIEW_MENU_TEXT                        5
#define DISPID_URLVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT             6
#define DISPID_URLVIEWDEF_URL                                   7

// ITaskpadViewDef
#define DISPID_TASKPADVIEWDEF_NAME                              DISPID_VALUE
#define DISPID_TASKPADVIEWDEF_INDEX                             1
#define DISPID_TASKPADVIEWDEF_KEY                               2
#define DISPID_TASKPADVIEWDEF_ADD_TO_VIEW_MENU                  3
#define DISPID_TASKPADVIEWDEF_VIEW_MENU_TEXT                    4
#define DISPID_TASKPADVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT         5
#define DISPID_TASKPADVIEWDEF_USE_WHEN_TASKPAD_VIEW_PREFERRED   6
#define DISPID_TASKPADVIEWDEF_TASKPAD                           7

// IScopeItemsDefs
#define DISPID_SCOPEITEMDEFS_COUNT                              1
#define DISPID_SCOPEITEMDEFS_CLEAR                              2
#define DISPID_SCOPEITEMDEFS_REMOVE                             3
#define DISPID_SCOPEITEMDEFS_ADD                                4

// IExtendedSnapIns
#define DISPID_EXTENDEDSNAPINS_COUNT                            1
#define DISPID_EXTENDEDSNAPINS_CLEAR                            2
#define DISPID_EXTENDEDSNAPINS_REMOVE                           3
#define DISPID_EXTENDEDSNAPINS_ADD                              4

// IMMCImageLists
#define DISPID_MMCIMAGELISTS_COUNT                              1
#define DISPID_MMCIMAGELISTS_CLEAR                              2
#define DISPID_MMCIMAGELISTS_REMOVE                             3
#define DISPID_MMCIMAGELISTS_ADD                                4

// IMMCMenuDef
#define DISPID_MMCMENUDEF_INDEX                                 1
#define DISPID_MMCMENUDEF_KEY                                   2
#define DISPID_MMCMENUDEF_MENU                                  3
#define DISPID_MMCMENUDEF_CHILDREN                              4

// IMMCMenuDefs
#define DISPID_MMCMENUDEFS_COUNT                                1
#define DISPID_MMCMENUDEFS_ADD                                  2
#define DISPID_MMCMENUDEFS_ADD_EXISTING                         3
#define DISPID_MMCMENUDEFS_CLEAR                                4
#define DISPID_MMCMENUDEFS_REMOVE                               5
#define DISPID_MMCMENUDEFS_SWAP                                 6

// IMMCToolbars
#define DISPID_MMCTOOLBARS_COUNT                                1
#define DISPID_MMCTOOLBARS_CLEAR                                2
#define DISPID_MMCTOOLBARS_REMOVE                               3
#define DISPID_MMCTOOLBARS_ADD                                  4

// IListViewDefs
#define DISPID_LISTVIEWDEFS_COUNT                               1
#define DISPID_LISTVIEWDEFS_CLEAR                               2
#define DISPID_LISTVIEWDEFS_REMOVE                              3
#define DISPID_LISTVIEWDEFS_ADD                                 4
#define DISPID_LISTVIEWDEFS_ADD_FROM_MASTER                     5

// IOCXViewDefs
#define DISPID_OCXVIEWDEFS_COUNT                                1
#define DISPID_OCXVIEWDEFS_CLEAR                                2
#define DISPID_OCXVIEWDEFS_REMOVE                               3
#define DISPID_OCXVIEWDEFS_ADD                                  4
#define DISPID_OCXVIEWDEFS_ADD_FROM_MASTER                      5

// IURLViewDefs
#define DISPID_URLVIEWDEFS_COUNT                                1
#define DISPID_URLVIEWDEFS_CLEAR                                2
#define DISPID_URLVIEWDEFS_REMOVE                               3
#define DISPID_URLVIEWDEFS_ADD                                  4
#define DISPID_URLVIEWDEFS_ADD_FROM_MASTER                      5

// ITaskpadViewDefs
#define DISPID_TASKPADVIEWDEFS_COUNT                            1
#define DISPID_TASKPADVIEWDEFS_CLEAR                            2
#define DISPID_TASKPADVIEWDEFS_REMOVE                           3
#define DISPID_TASKPADVIEWDEFS_ADD                              4
#define DISPID_TASKPADVIEWDEFS_ADD_FROM_MASTER                  5

// IDataFormat
#define DISPID_DATAFORMAT_NAME                                  DISPID_VALUE
#define DISPID_DATAFORMAT_INDEX                                 1  
#define DISPID_DATAFORMAT_KEY                                   2    
#define DISPID_DATAFORMAT_FILENAME                              3

// IDataFormats
#define DISPID_DATAFORMATS_COUNT                                1 
#define DISPID_DATAFORMATS_ADD                                  2   
#define DISPID_DATAFORMATS_CLEAR                                3 
#define DISPID_DATAFORMATS_REMOVE                               4

// IWizardPage
#define DISPID_WIZARD_PAGE_ACTIVATE                             1
#define DISPID_WIZARD_PAGE_BACK                                 2
#define DISPID_WIZARD_PAGE_NEXT                                 3
#define DISPID_WIZARD_PAGE_FINISH                               4

// IMMCPropertyPage
#define DISPID_PROPERTYPAGE_INITIALIZE                          1
#define DISPID_PROPERTYPAGE_HELP                                2
#define DISPID_PROPERTYPAGE_GET_DIALOG_UNIT_SIZE                3
#define DISPID_PROPERTYPAGE_PAGE_QUERY_CANCEL                   4
#define DISPID_PROPERTYPAGE_PAGE_CANCEL                         5
#define DISPID_PROPERTYPAGE_PAGE_CLOSE                          6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\error.cpp ===
//=--------------------------------------------------------------------------=
// error.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CError class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "error.h"

// for ASSERT and FAIL
//
SZTHISFILE


CError::CError(CAutomationObject *pao)
{
    m_pao = pao;
}

CError::CError()
{
    m_pao = NULL;
}

CError::~CError()
{
    m_pao = NULL;
}

static HRESULT BuildDescription
(
    HRESULT  hrException,
    va_list  pArgList,
    DWORD   *pdwHelpID,
    LPWSTR  *ppwszDescription
)
{
    HRESULT hr = S_OK;
    DWORD   cchMsg = 0;
    SCODE   scode = HRESULT_CODE(hrException);
    char   *pszFormatted = NULL;

    char    szFormatString[512];
    ::ZeroMemory(szFormatString, sizeof(szFormatString));

    static const size_t cchMaxMsg = 1024; // max possible formatted msg size

    *pdwHelpID = 0;
    *ppwszDescription = NULL;
    
    // Check whether this is a designer error (from errors.h and mssnapr.id)
    // or a foreign error (e.g. system error). The error range for the designer
    // is hard coded in mssnapr.id and it is based on VB's error range scheme.
    // For information contact Stephen Weatherford (StephWe)
    // There is no define for this.

    if ( (scode >= 9500) && (scode <= 9749) )
    {
        // It's one of our ours. Load the string from the RC

        *pdwHelpID = (DWORD)scode; // UNDONE check that this how helpfile numbers errors

        if (0 != ::LoadString(::GetResourceHandle(), (UINT)scode,
                              szFormatString, sizeof(szFormatString)))
        {
            // Format it.
            cchMsg = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_STRING,
                                     (LPCVOID)szFormatString,
                                     0, // don't need msg ID
                                     0, // don't need lang ID
                                     (LPTSTR)&pszFormatted,
                                     1, // minimum buffer to allocate in chars
                                     &pArgList);
        }
    }
    else
    {
        // It is a system or other foreign error. Ask FormatMessage() to
        // produce the error message. If it can't then use a generic message.

        *pdwHelpID = HID_mssnapr_err_SystemError;

        cchMsg = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                 FORMAT_MESSAGE_FROM_SYSTEM     |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                                 NULL,      // no source
                                 hrException,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 (LPTSTR)&pszFormatted,
                                 0,
                                 NULL);
    }

    // At this point we might have a formatted message. If not then use
    // a generic one. If that won't load then use a hard coded message.

    if ( (0 == cchMsg) || (NULL == pszFormatted) )
    {
        if (0 == ::LoadString(GetResourceHandle(), IDS_GENERIC_ERROR_MSG,
                              szFormatString, sizeof(szFormatString)))
        {
            ::strcpy(szFormatString, "Snap-in designer runtime error: 0x%08.8X");
        }
        pszFormatted = (char *)::LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cchMaxMsg);
        IfFalseGo(NULL != pszFormatted, E_OUTOFMEMORY);
        cchMsg = (DWORD)((UINT)::_snprintf(pszFormatted, cchMaxMsg,
                                           szFormatString, hrException));
        IfFalseGo(0 != cchMsg, E_FAIL);
    }

    // If we made it to here then we have a message. Now we need to convert it
    // to UNICODE.

    IfFailGo(::WideStrFromANSI(pszFormatted, ppwszDescription));

Error:
    if (NULL != pszFormatted)
    {
        ::LocalFree(pszFormatted);
    }
    RRETURN(hr);
}


static void SetExceptionInfo
(
    LPWSTR  pwszDescription,
    DWORD   dwHelpContextID
)
{
    HRESULT           hr = S_OK;
    ICreateErrorInfo *piCreateErrorInfo;
    IErrorInfo       *piErrorInfo;

    // Get the CreateErrorInfo object.

    IfFailGo(::CreateErrorInfo(&piCreateErrorInfo));

    // Put in all the exception information

    IfFailGo(piCreateErrorInfo->SetGUID(GUID_NULL));
    IfFailGo(piCreateErrorInfo->SetHelpFile(HELP_FILENAME_WIDE));
    IfFailGo(piCreateErrorInfo->SetHelpContext(dwHelpContextID));
    IfFailGo(piCreateErrorInfo->SetDescription(pwszDescription));
    IfFailGo(piCreateErrorInfo->SetSource(L"SnapInDesignerRuntime.SnapIn"));

    // Set the ErrorInfo object in the system

    IfFailGo(piCreateErrorInfo->QueryInterface(IID_IErrorInfo,
                                      reinterpret_cast<void **>(&piErrorInfo)));
    IfFailGo(::SetErrorInfo(0, piErrorInfo));

Error:
    QUICK_RELEASE(piErrorInfo);
    QUICK_RELEASE(piCreateErrorInfo);
}




void cdecl CError::GenerateExceptionInfo(HRESULT hrException, ...)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszDescription = NULL;
    DWORD   dwHelpID = 0;
    va_list pArgList;
    va_start(pArgList, hrException);

    // Build the description string and determine the help context ID

    IfFailGo(::BuildDescription(hrException, pArgList, &dwHelpID, &pwszDescription));

    // Pass it on to CAutomationObject if we have one or generate
    // our own error.

    if (NULL == m_pao)
    {
        ::SetExceptionInfo(pwszDescription, dwHelpID);
    }
    else
    {
        (void)m_pao->Exception(hrException, pwszDescription, dwHelpID);
    }

Error:
    if (NULL != pwszDescription)
    {
        ::CtlFree(pwszDescription);
    }
}

void cdecl CError::GenerateInternalExceptionInfo(HRESULT hrException, ...)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszDescription = NULL;
    DWORD   dwHelpID = 0;
    va_list pArgList;
    va_start(pArgList, hrException);

    // Build the description string and determine the help context ID

    IfFailGo(::BuildDescription(hrException, pArgList, &dwHelpID, &pwszDescription));

    // Set the ErrorInfo stuff

    ::SetExceptionInfo(pwszDescription, dwHelpID);

Error:
    if (NULL != pwszDescription)
    {
        ::CtlFree(pwszDescription);
    }
}

void CError::DisplayErrorInfo()
{
// UNDONE
}

void cdecl CError::WriteEventLog(UINT idMessage, ...)
{
// UNDONE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\enumtask.cpp ===
//=--------------------------------------------------------------------------=
// enumtask.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CEnumTask class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "enumtask.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CEnumTask::CEnumTask(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_ENUM_TASK,
                            static_cast<IEnumTASK *>(this),
                            static_cast<CEnumTask *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CEnumTask::~CEnumTask()
{
    RELEASE(m_piTasks);
    RELEASE(m_piEnumVARIANT);
    InitMemberVariables();
}

void CEnumTask::InitMemberVariables()
{
    m_piTasks = NULL;
    m_piEnumVARIANT = NULL;
    m_pSnapIn = NULL;
}

IUnknown *CEnumTask::Create(IUnknown * punkOuter)
{
    CEnumTask *pTask = New CEnumTask(punkOuter);
    if (NULL == pTask)
    {
        return NULL;
    }
    else
    {
        return pTask->PrivateUnknown();
    }
}


void CEnumTask::SetTasks(ITasks *piTasks)
{
    RELEASE(m_piTasks);
    if (NULL != piTasks)
    {
        piTasks->AddRef();
    }
    m_piTasks = piTasks;
}

HRESULT CEnumTask::GetEnumVARIANT()
{
    HRESULT   hr = S_OK;
    IUnknown *punkNewEnum = NULL;

    // If we didn't get our task collection then that is a bug
    
    IfFalseGo(NULL != m_piTasks, SID_E_INTERNAL);

    // If we already got the IEnumVARIANT from the tasks collection then there's
    // nothing to do.
    
    IfFalseGo(NULL == m_piEnumVARIANT, S_OK);

    IfFailGo(m_piTasks->get__NewEnum(&punkNewEnum));

    IfFailGo(punkNewEnum->QueryInterface(IID_IEnumVARIANT,
                                   reinterpret_cast<void **>(&m_piEnumVARIANT)));

Error:
    QUICK_RELEASE(punkNewEnum);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IEnumTASK Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CEnumTask::Next
(
    ULONG     celt,
    MMC_TASK *rgelt,
    ULONG    *pceltFetched
)
{
    HRESULT                  hr = S_OK;
    ITask                   *piTask = NULL;
    CTask                   *pTask = NULL;
    ULONG                    i = 0;
    ULONG                    cFetched = 0;
    ULONG                    cTotalFetched = 0;
    MMC_TASK                *pMMCTask = rgelt;
    MMC_TASK_DISPLAY_OBJECT *pDispObj = NULL;

    VARIANT varTask;
    ::VariantInit(&varTask);

    // Zero the out parameters

    ::ZeroMemory(pMMCTask, sizeof(*pMMCTask) * celt);

    *pceltFetched = 0;

    // Get the IEnumVARIANT on the tasks collection

    IfFailGo(GetEnumVARIANT());

    // Fetch the task(s). We do these one at a time because MMC documents that
    // it will only request them that way. This loop (in theory) should never run
    // more than once so we do not allocate the VARIANT array and ask for celt
    // items in one shot in order to avoid the extra allocation (not that it will
    // help much given all the others that will occur in the loop).

    for (i = 0; i < celt; i++)
    {
        // Get a CTask * on the next visible task

        do
        {
            RELEASE(piTask);

            // Get the next task.

            IfFailGo(m_piEnumVARIANT->Next(1L, &varTask, &cFetched));

            // If there are no more then we're done

            IfFalseGo(S_OK == hr, hr);

            // Make sure we got exactly 1 task back

            IfFalseGo(1L == cFetched, SID_E_INTERNAL);

            // Get an ITask on it and release the IDispatch in the VARIANT

            IfFailGo(varTask.pdispVal->QueryInterface(IID_ITask,
                                          reinterpret_cast<void **>(&piTask)));
            hr = ::VariantClear(&varTask);
            EXCEPTION_CHECK_GO(hr);

            // Get the CTask from it so we can use direct-dial property fetch
            // routines rather than automation BSTR fetches.

            IfFailGo(CSnapInAutomationObject::GetCxxObject(piTask, &pTask));

        } while (!pTask->Visible());

        // Fill in the MMC_TASK from the Task object's properties
        // Do the display object first.

        pDispObj = &pMMCTask->sDisplayObject;

        switch (pTask->GetImageType())
        {
            case siVanillaGIF:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_VANILLA_GIF;
                break;

            case siChocolateGIF:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF;
                break;

            case siBitmap:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
                break;

            case siSymbol:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_SYMBOL;

                if (ValidBstr(pTask->GetFontfamily()))
                {
                    IfFailGo(::CoTaskMemAllocString(pTask->GetFontfamily(),
                                           &pDispObj->uSymbol.szFontFamilyName));
                }

                if (ValidBstr(pTask->GetEOTFile()))
                {
                    IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetEOTFile(),
                                                &pDispObj->uSymbol.szURLtoEOT));
                }

                if (ValidBstr(pTask->GetSymbolString()))
                {
                    IfFailGo(::CoTaskMemAllocString(pTask->GetSymbolString(),
                                             &pDispObj->uSymbol.szSymbolString));
                }
                break;

            default:
                IfFailGo(SID_E_INTERNAL);
                break;
        }

        if (siSymbol != pTask->GetImageType())
        {
            if (ValidBstr(pTask->GetMouseOverImage()))
            {
                IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetMouseOverImage(),
                                         &pDispObj->uBitmap.szMouseOverBitmap));
            }

            if (ValidBstr(pTask->GetMouseOffImage()))
            {
                IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetMouseOffImage(),
                                         &pDispObj->uBitmap.szMouseOffBitmap));
            }
        }

        // Do text and helpstring

        IfFailGo(::CoTaskMemAllocString(pTask->GetText(), &pMMCTask->szText));

        IfFailGo(::CoTaskMemAllocString(pTask->GetHelpString(),
                                        &pMMCTask->szHelpString));

        // Get the action type

        switch (pTask->GetActionType())
        {
            case siNotify:
                // The user wants a ResultViews_TaskClick event. Set the command
                // ID to the one-based index of the task in its collection.
                pMMCTask->eActionType = MMC_ACTION_ID;
                pMMCTask->nCommandID = pTask->GetIndex();
                break;

            case siURL:
                // The user want the result pane to navigate to this URL when the
                // task is clicked.
                pMMCTask->eActionType = MMC_ACTION_LINK;
                IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetURL(),
                                                &pMMCTask->szActionURL));
                break;
                
            case siScript:
                // The user wants to run the specied DHTML script when the task
                // is clicked.
                pMMCTask->eActionType = MMC_ACTION_SCRIPT;
                IfFailGo(::CoTaskMemAllocString(pTask->GetScript(),
                                                &pMMCTask->szScript));
                break;

            default:
                IfFailGo(SID_E_INTERNAL);
                break;
        }

        RELEASE(piTask);
        pMMCTask++;
        cTotalFetched++;
    }

    if (NULL != pceltFetched)
    {
        *pceltFetched = cTotalFetched;
    }

Error:
    (void)::VariantClear(&varTask);
    if (SID_E_INTERNAL == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    QUICK_RELEASE(piTask);
    RRETURN(hr);
}



STDMETHODIMP CEnumTask::Skip(ULONG celt)
{
    HRESULT hr = S_OK;

    IfFailGo(GetEnumVARIANT());
    IfFailGo(m_piEnumVARIANT->Skip(celt));

Error:
    RRETURN(hr);
}




STDMETHODIMP CEnumTask::Reset()
{
    HRESULT hr = S_OK;

    IfFailGo(GetEnumVARIANT());
    IfFailGo(m_piEnumVARIANT->Reset());

Error:
    if (SID_E_INTERNAL == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


STDMETHODIMP CEnumTask::Clone(IEnumTASK **ppEnumTASK)
{
    HRESULT    hr = S_OK;
    IUnknown  *punkEnumTask = CEnumTask::Create(NULL);
    CEnumTask *pEnumTask = NULL;

    IfFailGo(GetEnumVARIANT());

    if (NULL == pEnumTask)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkEnumTask, &pEnumTask));
    pEnumTask->SetTasks(m_piTasks);

    IfFailGo(pEnumTask->QueryInterface(IID_IEnumTASK,
                                       reinterpret_cast<void **>(ppEnumTASK)));

Error:
    QUICK_RELEASE(punkEnumTask);
    if (SID_E_INTERNAL == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CEnumTask::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IEnumTASK == riid)
    {
        *ppvObjOut = static_cast<IEnumTASK *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\errors.h ===
//=--------------------------------------------------------------------------=
// errors.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Error Codes Defined by the Designer Runtime
//
//=--------------------------------------------------------------------------=


#ifndef _ERRORS_DEFINED_
#define _ERRORS_DEFINED_

#include "mssnapr_helpids.h"

// Replacements for framework's macros.h stuff that does not work in header
// files.

#if defined(DEBUG)
extern HRESULT HrDebugTraceReturn(HRESULT hr, char *szFile, int iLine);
#define H_RRETURN(hr) return HrDebugTraceReturn(hr, __FILE__, __LINE__)
#else
#define H_RRETURN(hr) return (hr)
#endif

#if defined(DEBUG)
#define H_FAILEDHR(HR) _H_FAILEDHR(HR, __FILE__, __LINE__)

inline BOOL _H_FAILEDHR(HRESULT hr, char* pszFile, unsigned int uiLine)
{
    if (FAILED(hr))
    {
        HrDebugTraceReturn(hr, pszFile, uiLine);
    }
    return FAILED(hr);
}
#else
#define H_FAILEDHR(HR) FAILED(HR)
#endif

#if defined(DEBUG)

#define H_ASSERT(fTest, szMsg)                                  \
    if (!(fTest))                                               \
    {                                                           \
        static char szMsgCode[] = szMsg;                        \
        static char szAssert[] = #fTest;                        \
        DisplayAssert(szMsgCode, szAssert, __FILE__, __LINE__); \
    }

#else
#define H_ASSERT(fTest, err)
#endif


#define H_IfFailGoto(EXPR, LABEL) \
    { hr = (EXPR); if(H_FAILEDHR(hr)) goto LABEL; }

#define H_IfFailRet(EXPR) \
    { hr = (EXPR); if(H_FAILEDHR(hr)) H_RRETURN(hr); }

#define H_IfFailGo(EXPR) H_IfFailGoto(EXPR, Error)

#define H_IfFalseGoto(EXPR, HR, LABEL) \
   { if(!(EXPR)) { hr = (HR); goto LABEL; } }

#define H_IfFalseGo(EXPR, HR) H_IfFalseGoto(EXPR, HR, Error)

#define H_IfFalseRet(EXPR, HR) \
    { if(!(EXPR)) H_RRETURN(HR); }

// Macro to create a return code from an error name in the ID file.
// See below for examples of usage.

#define _MKERR(x)   MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)
#define MKERR(x)    _MKERR(HID_mssnapr_err_##x)


//---------------------------------------------------------------------------
//
// HOW TO ADD A NEW ERROR
//
//
// 1) Add the error to mssnapr.id. Both design time and runtime errors should
//    be defined in this file.
//    Do *not* use devid to determine the help context id, but rather use
//    the error number itself
// 2) Add a define below for the error, using the MKERR macro
// 3) You may only return Win32 error codes and snap-in defined SID_E_XXXX
//    error codes. Do not use OLE E_XXX error codes directly as the
//    system message table does not have description strings for all of these
//    errors. If any OLE E_XXXX, CO_E_XXX, CTL_E_XXX or other such errors are
//    needed then add them as SID_E errors using the procedure described
//    above. If an error comes from an outside source and you are not sure
//    if error information is available for it then return SIR_E_EXTERNAL
//    and write the error to the event log using CError::WriteEventLog (see
//    error.h).
// 4) Add an entry to the SnapInErrorConstants section in mssnapr.idl
// 5) Check out mmcvbderr.csf from VSS. Contact Gary Kraut for this (a-GaryK).
//    Add an explanation for the new error and then ask Gary to update the
//    footnotes and the ALIAS and MAP sections in the HHP file for the snap-in
//    docs.
//---------------------------------------------------------------------------

// Errors defined by the snap-in designer

#define SID_E_EXCEPTION                     MKERR(Exception)
#define SID_E_OUTOFMEMORY                   MKERR(OutOfMemory)
#define SID_E_INVALIDARG                    MKERR(InvalidArg)
#define SID_E_CONSOLEERROR                  MKERR(ConsoleError)
#define SID_E_UNKNOWNFORMAT                 MKERR(UnknownFormat)
#define SID_E_TEXT_SERIALIZATION            MKERR(TextSerialzation)
#define SID_E_INTERNAL                      MKERR(InternalError)
#define SID_E_UNSUPPORTED_STGMEDIUM         MKERR(UnsupportedStgMedium)
#define SID_E_INCOMPLETE_WRITE              MKERR(IncompleteWrite)
#define SID_E_INCOMPLETE_READ               MKERR(IncompleteRead)
#define SID_E_UNSUPPORTED_TYPE              MKERR(UnsupportedType)
#define SID_E_KEY_NOT_UNIQUE                MKERR(KeyNotUnique)
#define SID_E_ELEMENT_NOT_FOUND             MKERR(ElementNotFound)
#define SID_E_CLIPFORMATS_NOT_REGISTERED    MKERR(ClipformatsNotRegistered)
#define SID_E_INVALID_IMAGE_TYPE            MKERR(InvalidImageType)
#define SID_E_DETACHED_OBJECT               MKERR(DetachedObject)
#define SID_E_TOOLBAR_HAS_NO_IMAGELIST      MKERR(ToolbarHasNoImageList)
#define SID_E_TOOLBAR_HAS_NO_IMAGES         MKERR(ToolbarHasNoImages)
#define SID_E_TOOLBAR_IMAGE_NOT_FOUND       MKERR(ToolbarImageNotFound)
#define SID_E_SYSTEM_ERROR                  MKERR(SystemError)
#define SID_E_TOO_MANY_MENU_ITEMS           MKERR(TooManyMenuItems)
#define SID_E_READ_ONLY_AT_RUNTIME          MKERR(ReadOnlyAtRuntime);
#define SID_E_MENUTOPLEVEL                  MKERR(MenuItemDistinct);
#define SID_E_DUPLICATEMENU                 MKERR(DuplicateMenu);
#define SID_E_INVALIDIDENTIFIER             MKERR(InvalidIdentifier);
#define SID_E_INVALID_PROPERTY_PAGE_NAME    MKERR(InvalidPropertyPageName);
#define SID_E_INVALID_VARIANT               MKERR(InvalidVariant)
#define SID_E_OBJECT_NOT_PERSISTABLE        MKERR(ObjectNotPersistable);
#define SID_E_OBJECT_NOT_PUBLIC_CREATABLE   MKERR(ObjectNotPublicCreatable);
#define SID_E_UNKNOWN_LISTVIEW              MKERR(UnknownListView)
#define SID_E_INVALID_RAW_DATA_TYPE         MKERR(InvalidRawDataType)
#define SID_E_FORMAT_NOT_AVAILABLE          MKERR(FormatNotAvailable);
#define SID_E_NOT_EXTENSIBLE                MKERR(NotExtensible);
#define SID_E_SERIALIZATION_CORRUPT         MKERR(SerialzationCorrupt);
#define SID_E_CANT_REMOVE_STATIC_NODE       MKERR(CantRemoveStaticNode);
#define SID_E_CANT_CHANGE_UNOWNED_SCOPENODE MKERR(CantChangeUnownedScopeNode)
#define SID_E_UNSUPPORTED_ON_VIRTUAL_LIST   MKERR(UnsupportedOnVirtualList)
#define SID_E_NO_KEY_ON_VIRTUAL_ITEMS       MKERR(NoKeyOnVirtualItems)
#define SID_E_INDEX_OUT_OF_RANGE            MKERR(IndexOutOfRange)
#define SID_E_NOT_CONNECTED_TO_MMC          MKERR(NotConnectedToMMC)
#define SID_E_DATA_NOT_AVAILABLE_IN_HGLOBAL MKERR(DataNotAvailableInHglobal)
#define SID_E_CANT_DELETE_PICTURE           MKERR(CantDeletePicture)
#define SID_E_CONTROLBAR_NOT_AVAILABLE      MKERR(ControlbarNotAvailable)
#define SID_E_COLLECTION_READONLY           MKERR(CollectionReadOnly)
#define SID_E_INVALID_COLUMNSETID           MKERR(InvalidColumnSetID)
#define SID_E_MMC_FEATURE_NOT_AVAILABLE     MKERR(MMCFeatureNotAvailable)
#define SID_E_COLUMNS_NOT_PERSISTED         MKERR(ColumnsNotPersisted)
#define SID_E_ICON_REQUIRED                 MKERR(IconRequired)
#define SID_E_CANT_DELETE_ICON              MKERR(CantDeleteIcon)
#define SID_E_TOOLBAR_INCONSISTENT          MKERR(ToolbarInconsistent)
#define SID_E_UNSUPPORTED_TYMED             MKERR(UnsupportedDataMedium)
#define SID_E_DATA_TOO_LARGE                MKERR(DataTooLarge)
#define SID_E_MMC_VERSION_NOT_AVAILABLE     MKERR(MMCVersionNotAvailable)
#define SID_E_SORT_SETTINGS_NOT_PERSISTED   MKERR(SortSettingsNotPersisted)
#define SID_E_SCOPE_NODE_NOT_CONNECTED      MKERR(ScopeNodeNotConnectedToMMC)
#define SID_E_NO_SCOPEITEMS_IN_VIRTUAL_LIST MKERR(NoScopeItemsInVirtualList)
#define SID_E_CANT_ALTER_PAGE_COUNT         MKERR(CantAlterPageCount)

#endif // _ERRORS_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\error.h ===
//=--------------------------------------------------------------------------=
// error.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CError class definition
//
//=--------------------------------------------------------------------------=


#ifndef _ERROR_DEFINED_
#define _ERROR_DEFINED_


//---------------------------------------------------------------------------
//
//                      How to Use the CError Class
//                      ===========================
//
// Classes that derive from Framework CAutomationXxxx classes should also
// derive from CError. This gives CError access to the various bits of
// information it needs to generate rich error info. To generate error
// info call GenerateExceptionInfo(hr, ...). Error messages use FormatMessage
// replacement syntax and replacement parameters may be of any type.
// 
// Classes that are not automation objects may use the static
// method GenerateInternalExceptionInfo().
//
// Note that the excpetion info generation methods may be called at any level
// of depth in UI, extensibility, or programming model code. For
// extensibility and programming model the error info will optionally be
// retrieved by the client code if desired. For UI, the UI entry point (e.g.
// mouse click handler) should call the static method DisplayErrorInfo().
//
// Exception info should be generated at the point at which the error occurs.
// For example, if CoCreateInstance() returns an error then the exception
// info should be generated at that point because you know that
// CoCreateInstance() will not generate it. On the other hand, if you call
// into a lower level of designer code and it returns an error then you can
// assume that the exception info was generated.
//
//---------------------------------------------------------------------------


#if defined(MSSNAPR_BUILD)
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT __declspec(dllimport)
#endif

// Some useful macros to insert at the end of a function if not explicitly
// generating an exception with specific arguments.

#if defined(DEBUG)

#define EXCEPTION_CHECK(hr)             if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); }

#define EXCEPTION_CHECK_GO(hr)          if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); goto Error; }

#define GLOBAL_EXCEPTION_CHECK(hr)    if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); }

#define GLOBAL_EXCEPTION_CHECK_GO(hr) if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); goto Error; }

#else

#define EXCEPTION_CHECK(hr)             if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); }

#define EXCEPTION_CHECK_GO(hr)          if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); goto Error; }

#define GLOBAL_EXCEPTION_CHECK(hr)    if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); }

#define GLOBAL_EXCEPTION_CHECK_GO(hr) if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); goto Error; }

#endif

class DLLEXPORT CError
{
    public:
        CError(CAutomationObject *pao);
        CError();
        ~CError();

        void cdecl GenerateExceptionInfo(HRESULT hr, ...);
        static void cdecl GenerateInternalExceptionInfo(HRESULT hr, ...);
        static void DisplayErrorInfo();
        static void cdecl WriteEventLog(UINT idMessage, ...);

    private:
        CAutomationObject *m_pao;
};

#endif // _ERRORS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extdefs.h ===
//=--------------------------------------------------------------------------=
// extdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionDefs class definition - design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENSIONDEFS_DEFINED_
#define _EXTENSIONDEFS_DEFINED_


class CExtensionDefs : public CSnapInAutomationObject,
                       public CPersistence,
                       public IExtensionDefs
{
    private:
        CExtensionDefs(IUnknown *punkOuter);
        ~CExtensionDefs();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtensionDefs

        BSTR_PROPERTY_RO(CExtensionDefs,   Name, DISPID_VALUE);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsNewMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_NEW_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsTaskMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_TASK_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsTopMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_TOP_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsViewMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_VIEW_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsPropertyPages, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_PROPERTYPAGES);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsToolbar, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_TOOLBAR);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsNameSpace, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_NAMESPACE);
        OBJECT_PROPERTY_RW(CExtensionDefs, ExtendedSnapIns, IExtendedSnapIns, DISPID_EXTENSIONDEFS_EXTENDED_SNAPINS);
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtensionDefs,              // name
                                &CLSID_ExtensionDefs,       // clsid
                                "ExtensionDefs",            // objname
                                "ExtensionDefs",            // lblname
                                &CExtensionDefs::Create,    // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IExtensionDefs,        // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _EXTENSIONDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extdefs.cpp ===
//=--------------------------------------------------------------------------=
// extdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "extdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtensionDefs::CExtensionDefs(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_EXTENSIONDEFS,
                            static_cast<IExtensionDefs *>(this),
                            static_cast<CExtensionDefs *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ExtensionDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtensionDefs::~CExtensionDefs()
{
    FREESTRING(m_bstrName);
    RELEASE(m_piExtendedSnapIns);
    InitMemberVariables();
}

void CExtensionDefs::InitMemberVariables()
{
    m_bstrName = NULL;
    m_ExtendsNewMenu = VARIANT_FALSE;
    m_ExtendsTaskMenu = VARIANT_FALSE;
    m_ExtendsTopMenu = VARIANT_FALSE;
    m_ExtendsViewMenu = VARIANT_FALSE;
    m_ExtendsPropertyPages = VARIANT_FALSE;
    m_ExtendsNameSpace = VARIANT_FALSE;
    m_ExtendsToolbar = VARIANT_FALSE;
    m_piExtendedSnapIns = NULL;
}

IUnknown *CExtensionDefs::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;
    char    szName[512];
    
    CExtensionDefs *pExtensionDefs = New CExtensionDefs(punkOuter);
    if (NULL == pExtensionDefs)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 == ::LoadString(::GetResourceHandle(), IDS_EXTENSIONDEFS_NAME,
                          szName, sizeof(szName)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(BSTRFromANSI(szName, &pExtensionDefs->m_bstrName));

Error:
    if (FAILED(hr))
    {
        if (NULL != pExtensionDefs)
        {
            delete pExtensionDefs;
        }
        return NULL;
    }
    else
    {
        return pExtensionDefs->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionDefs::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_ExtendsNewMenu, VARIANT_FALSE, OLESTR("ExtendsNewMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsTaskMenu, VARIANT_FALSE, OLESTR("ExtendsTaskMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsTopMenu, VARIANT_FALSE, OLESTR("ExtendsTopMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsViewMenu, VARIANT_FALSE, OLESTR("ExtendsViewMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsPropertyPages, VARIANT_FALSE, OLESTR("ExtendsPropertyPages")));

    IfFailRet(PersistSimpleType(&m_ExtendsToolbar, VARIANT_FALSE, OLESTR("ExtendsToolbar")));

    IfFailRet(PersistSimpleType(&m_ExtendsNameSpace, VARIANT_FALSE, OLESTR("ExtendsNameSpace")));

    IfFailRet(PersistObject(&m_piExtendedSnapIns, CLSID_ExtendedSnapIns,
                            OBJECT_TYPE_EXTENDEDSNAPINS, IID_IExtendedSnapIns,
                            OLESTR("ExtendedSnapIns")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtensionDefs == riid)
    {
        *ppvObjOut = static_cast<IExtensionDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionDefs::OnSetHost()
{
    RRETURN(SetObjectHost(m_piExtendedSnapIns));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\help.h ===
//---------------------------------------------------------------------------
// help.h
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
//
// Contains help info needed by the .IDL file and the
// DEFINE_AUTOMATIONOBJECTWEVENTS2 structure.  Define everything here once
// so we keep both items in sync. 
//

#ifndef _HELP_H
#define _HELP_H

#define HELP_FILENAME "VBSnapInsGuide.chm"
#define HELP_DLLFILENAME "MSSNAPR.DLL"
#define HELP_PPFILENAME HELP_FILENAME // Property page filename

#define merge(a,b) a ## b
#define WIDESTRINGCONSTANT(x) merge(L,x)
#define HELP_FILENAME_WIDE WIDESTRINGCONSTANT(HELP_FILENAME)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extsnap.cpp ===
//=--------------------------------------------------------------------------=
// extsnap.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionSnapIn class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "extsnap.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CExtensionSnapIn::m_rgvtAddNewMenuItems[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiAddNewMenuItems =
{
    DISPID_EXTENSIONSNAPIN_EVENT_ADD_NEW_MENU_ITEMS,
    sizeof(m_rgvtAddNewMenuItems) / sizeof(m_rgvtAddNewMenuItems[0]),
    m_rgvtAddNewMenuItems
};


VARTYPE CExtensionSnapIn::m_rgvtAddTaskMenuItems[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiAddTaskMenuItems =
{
    DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASK_MENU_ITEMS,
    sizeof(m_rgvtAddTaskMenuItems) / sizeof(m_rgvtAddTaskMenuItems[0]),
    m_rgvtAddTaskMenuItems
};


VARTYPE CExtensionSnapIn::m_rgvtCreatePropertyPages[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiCreatePropertyPages =
{
    DISPID_EXTENSIONSNAPIN_EVENT_CREATE_PROPERTY_PAGES,
    sizeof(m_rgvtCreatePropertyPages) / sizeof(m_rgvtCreatePropertyPages[0]),
    m_rgvtCreatePropertyPages
};


VARTYPE CExtensionSnapIn::m_rgvtSetControlbar[1] =
{
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiSetControlbar =
{
    DISPID_EXTENSIONSNAPIN_EVENT_SET_CONTROLBAR,
    sizeof(m_rgvtSetControlbar) / sizeof(m_rgvtSetControlbar[0]),
    m_rgvtSetControlbar
};


VARTYPE CExtensionSnapIn::m_rgvtUpdateControlbar[4] =
{
    VT_BOOL,
    VT_BOOL,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiUpdateControlbar =
{
    DISPID_EXTENSIONSNAPIN_EVENT_UPDATE_CONTROLBAR,
    sizeof(m_rgvtUpdateControlbar) / sizeof(m_rgvtUpdateControlbar[0]),
    m_rgvtUpdateControlbar
};


VARTYPE CExtensionSnapIn::m_rgvtTaskClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiTaskClick =
{
    DISPID_EXTENSIONSNAPIN_EVENT_TASK_CLICK,
    sizeof(m_rgvtTaskClick) / sizeof(m_rgvtTaskClick[0]),
    m_rgvtTaskClick
};


VARTYPE CExtensionSnapIn::m_rgvtAddTasks[3] =
{
    VT_UNKNOWN,
    VT_BSTR,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiAddTasks =
{
    DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASKS,
    sizeof(m_rgvtAddTasks) / sizeof(m_rgvtAddTasks[0]),
    m_rgvtAddTasks
};


VARTYPE CExtensionSnapIn::m_rgvtExpand[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiExpand =
{
    DISPID_EXTENSIONSNAPIN_EVENT_EXPAND,
    sizeof(m_rgvtExpand) / sizeof(m_rgvtExpand[0]),
    m_rgvtExpand
};


VARTYPE CExtensionSnapIn::m_rgvtCollapse[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiCollapse =
{
    DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE,
    sizeof(m_rgvtCollapse) / sizeof(m_rgvtCollapse[0]),
    m_rgvtCollapse
};


VARTYPE CExtensionSnapIn::m_rgvtExpandSync[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CExtensionSnapIn::m_eiExpandSync =
{
    DISPID_EXTENSIONSNAPIN_EVENT_EXPAND_SYNC,
    sizeof(m_rgvtExpandSync) / sizeof(m_rgvtExpandSync[0]),
    m_rgvtExpandSync
};


VARTYPE CExtensionSnapIn::m_rgvtCollapseSync[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CExtensionSnapIn::m_eiCollapseSync =
{
    DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE_SYNC,
    sizeof(m_rgvtCollapseSync) / sizeof(m_rgvtCollapseSync[0]),
    m_rgvtCollapseSync
};



#pragma warning(disable:4355)  // using 'this' in constructor

CExtensionSnapIn::CExtensionSnapIn(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_EXTENSIONSNAPIN,
                           static_cast<IExtensionSnapIn *>(this),
                           static_cast<CExtensionSnapIn *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtensionSnapIn::~CExtensionSnapIn()
{
    InitMemberVariables();
}

void CExtensionSnapIn::InitMemberVariables()
{
    m_pSnapIn = NULL;
}

IUnknown *CExtensionSnapIn::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkExtensionSnapIn = NULL;

    CExtensionSnapIn *pExtensionSnapIn = New CExtensionSnapIn(punkOuter);

    if (NULL == pExtensionSnapIn)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    punkExtensionSnapIn = pExtensionSnapIn->PrivateUnknown();

Error:
    return punkExtensionSnapIn;
}


void CExtensionSnapIn::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}



void CExtensionSnapIn::FireAddNewMenuItems
(
    IMMCDataObjects *piMMCDataObjects,
    IContextMenu    *piContextMenu
)
{
    DebugPrintf("Firing ExtensionSnapIn_AddNewMenuItems\r\n");

    FireEvent(&m_eiAddNewMenuItems, piMMCDataObjects, piContextMenu);

}


void CExtensionSnapIn::FireAddTaskMenuItems
(
    IMMCDataObjects *piMMCDataObjects,
    IContextMenu    *piContextMenu
)
{
    DebugPrintf("Firing ExtensionSnapIn_AddTaskMenuItems\r\n");

    FireEvent(&m_eiAddTaskMenuItems, piMMCDataObjects, piContextMenu);
}


void CExtensionSnapIn::FireCreatePropertyPages
(
    IMMCDataObject    *piMMCDataObject,
    IMMCPropertySheet *piMMCPropertySheet
)
{
    DebugPrintf("Firing ExtensionSnapIn_CreatePropertyPages\r\n");

    FireEvent(&m_eiCreatePropertyPages, piMMCDataObject, piMMCPropertySheet);
}


void CExtensionSnapIn::FireSetControlbar
(
    IMMCControlbar *piControlbar
)
{
    DebugPrintf("Firing ExtensionSnapIn_SetControlbar\r\n");

    FireEvent(&m_eiSetControlbar, piControlbar);

}


void CExtensionSnapIn::FireUpdateControlbar
(
    VARIANT_BOOL     fvarSelectionInScopePane,
    VARIANT_BOOL     fvarSelected,
    IMMCDataObjects *piMMCDataObjects,
    IMMCControlbar  *piMMCControlbar
)
{
    DebugPrintf("Firing ExtensionSnapIn_UpdateControlbar\r\n");

    FireEvent(&m_eiUpdateControlbar, fvarSelectionInScopePane, fvarSelected,
              piMMCDataObjects, piMMCControlbar);
}



void CExtensionSnapIn::FireTaskClick
(
    IMMCDataObject  *piMMCDataObject,
    ITask           *piTask
)
{
    DebugPrintf("Firing ExtensionSnapIn_TaskClick\r\n");

    FireEvent(&m_eiTaskClick, piMMCDataObject, piTask);
}


void CExtensionSnapIn::FireAddTasks
(
    IMMCDataObject *piMMCDataObject,
    BSTR            bstrGroupName,
    ITasks         *piTasks
)
{
    DebugPrintf("Firing ExtensionSnapIn_AddTasks\r\n");

    FireEvent(&m_eiAddTasks, piMMCDataObject, bstrGroupName, piTasks);
}



void CExtensionSnapIn::FireExpand
(
    IMMCDataObject  *piMMCDataObject,
    IScopeNode      *piScopeNode
)
{
    DebugPrintf("Firing ExtensionSnapIn_Expand\r\n");

    FireEvent(&m_eiExpand, piMMCDataObject, piScopeNode);
}


void CExtensionSnapIn::FireCollapse
(
    IMMCDataObject  *piMMCDataObject,
    IScopeNode      *piScopeNode
)
{
    DebugPrintf("Firing ExtensionSnapIn_Collapse\r\n");

    FireEvent(&m_eiCollapse, piMMCDataObject, piScopeNode);
}


void CExtensionSnapIn::FireExpandSync
(
    IMMCDataObject *piMMCDataObject,
    IScopeNode     *piScopeNode,
    BOOL           *pfHandled
)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);

    DebugPrintf("Firing ExtensionSnapIn_ExpandSync\r\n");

    FireEvent(&m_eiExpandSync, piMMCDataObject, piScopeNode, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


void CExtensionSnapIn::FireCollapseSync
(
    IMMCDataObject *piMMCDataObject,
    IScopeNode     *piScopeNode,
    BOOL           *pfHandled
)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);

    DebugPrintf("Firing ExtensionSnapIn_CollapseSync\r\n");

    FireEvent(&m_eiCollapseSync, piMMCDataObject, piScopeNode, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionSnapIn::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IExtensionSnapIn == riid)
    {
        *ppvObjOut = static_cast<IExtensionSnapIn *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extsnap.h ===
//=--------------------------------------------------------------------------=
// extsnap.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionSnapIn class definition - implements ExtensionSnapIn object
//
//=--------------------------------------------------------------------------=

#ifndef _EXTSNAP_DEFINED_
#define _EXTSNAP_DEFINED_

#include "snapin.h"

class CExtensionSnapIn : public CSnapInAutomationObject,
                         public IExtensionSnapIn
{
    private:
        CExtensionSnapIn(IUnknown *punkOuter);
        ~CExtensionSnapIn();
    
    public:
        static IUnknown *Create(IUnknown * punk);
        void SetSnapIn(CSnapIn *pSnapIn);

        void FireAddNewMenuItems(IMMCDataObjects *piMMCDataObjects,
                                 IContextMenu    *piContextMenu);

        void FireAddTaskMenuItems(IMMCDataObjects *piMMCDataObjects,
                                  IContextMenu    *piContextMenu);

        void FireCreatePropertyPages(IMMCDataObject    *piMMCDataObject,
                                     IMMCPropertySheet *piMMCPropertySheet);

        void FireSetControlbar(IMMCControlbar *piControlbar);

        void FireUpdateControlbar(VARIANT_BOOL     fvarSelectionInScopePane,
                                  VARIANT_BOOL     fvarSelected,
                                  IMMCDataObjects *piMMCDataObjects,
                                  IMMCControlbar  *piMMCControlbar);

        void FireAddTasks(IMMCDataObject *piMMCDataObject,
                          BSTR            bstrGroupName,
                          ITasks         *piTasks);

        void FireTaskClick(IMMCDataObject *piMMCDataObject, ITask *piTask);

        void FireExpand(IMMCDataObject *piMMCDataObject, IScopeNode *piScopeNode);
        void FireCollapse(IMMCDataObject *piMMCDataObject, IScopeNode *piScopeNode);
        void FireExpandSync(IMMCDataObject *piMMCDataObject,
                            IScopeNode     *piScopeNode,
                            BOOL           *pfHandled);
        void FireCollapseSync(IMMCDataObject *piMMCDataObject,
                              IScopeNode     *piScopeNode,
                              BOOL           *pfHandled);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CSnapIn *m_pSnapIn; // back pointer to CSnapIn

        // Event parameter definitions

        static VARTYPE   m_rgvtAddNewMenuItems[2];
        static EVENTINFO m_eiAddNewMenuItems;

        static VARTYPE   m_rgvtAddTaskMenuItems[2];
        static EVENTINFO m_eiAddTaskMenuItems;

        static VARTYPE   m_rgvtCreatePropertyPages[2];
        static EVENTINFO m_eiCreatePropertyPages;

        static VARTYPE   m_rgvtSetControlbar[1];
        static EVENTINFO m_eiSetControlbar;

        static VARTYPE   m_rgvtUpdateControlbar[4];
        static EVENTINFO m_eiUpdateControlbar;

        static VARTYPE   m_rgvtAddTasks[3];
        static EVENTINFO m_eiAddTasks;

        static VARTYPE   m_rgvtTaskClick[2];
        static EVENTINFO m_eiTaskClick;

        static VARTYPE   m_rgvtExpand[2];
        static EVENTINFO m_eiExpand;

        static VARTYPE   m_rgvtCollapse[2];
        static EVENTINFO m_eiCollapse;

        static VARTYPE   m_rgvtExpandSync[3];
        static EVENTINFO m_eiExpandSync;

        static VARTYPE   m_rgvtCollapseSync[3];
        static EVENTINFO m_eiCollapseSync;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtensionSnapIn,                // name
                                &CLSID_ExtensionSnapIn,         // clsid
                                "ExtensionSnapIn",              // objname
                                "ExtensionSnapIn",              // lblname
                                &CExtensionSnapIn::Create,      // creation function
                                TLIB_VERSION_MAJOR,             // major version
                                TLIB_VERSION_MINOR,             // minor version
                                &IID_IExtensionSnapIn,          // dispatch IID
                                &DIID_DExtensionSnapInEvents,   // event IID
                                HELP_FILENAME,                  // help file
                                TRUE);                          // thread safe


#endif // _EXTSNAP_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\image.cpp ===
//=--------------------------------------------------------------------------=
// image.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImage class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "image.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImage::CMMCImage(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCIMAGE,
                            static_cast<IMMCImage *>(this),
                            static_cast<CMMCImage *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImage,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImage::~CMMCImage()
{
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piPicture);
    if (NULL != m_hBitmap)
    {
        (void)::DeleteObject(m_hBitmap);
    }
    InitMemberVariables();
}

void CMMCImage::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    ::VariantInit(&m_varTag);
    m_piPicture = NULL;
    m_hBitmap = NULL;
}

IUnknown *CMMCImage::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;
    CMMCImage *pMMCImage = New CMMCImage(punkOuter);
    if (NULL == pMMCImage)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        // Start out with an empty bitmap so that the VB code will always
        // run even if the picture hasn't been set.
        hr = ::CreateEmptyBitmapPicture(&pMMCImage->m_piPicture);
    }
Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCImage)
        {
            delete pMMCImage;
        }
        return NULL;
    }
    else
    {
        return pMMCImage->PrivateUnknown();
    }
}


HRESULT CMMCImage::GetPictureHandle(short TypeNeeded, OLE_HANDLE *phPicture)
{
    HRESULT hr = S_OK;

    // If a bitmap is requested and we have already cached it then return it

    if ( (PICTYPE_BITMAP == TypeNeeded) && (NULL != m_hBitmap) )
    {
        *phPicture = reinterpret_cast<OLE_HANDLE>(m_hBitmap);
    }
    else
    {
        // Get the handle from the picture object

        IfFailGo(::GetPictureHandle(m_piPicture, TypeNeeded, phPicture));

        // If it's not a bitmap then we're done

        IfFalseGo(PICTYPE_BITMAP == TypeNeeded, S_OK);

        // It is a bitmap. Make a copy and cache it. We do the copying in 
        // order to upgrade the color table of bitmaps that use a lesser
        // number of colors than the screen. For example, a 16 color bitmap
        // on a 256 color string will display as a black box. The CopyBitmap()
        // function (rtutil.cpp) uses the Win32 APIs CreateCompatibleDC() and
        // CreateCompatibleBitmap() to create a new bitmap that is compatible
        // with the screen.

        IfFailGo(::CopyBitmap(reinterpret_cast<HBITMAP>(*phPicture), &m_hBitmap));

        *phPicture = reinterpret_cast<OLE_HANDLE>(m_hBitmap);
    }
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImage::Persist()
{
    HRESULT         hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistPicture(&m_piPicture, OLESTR("Picture")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImage::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCImage == riid)
    {
        *ppvObjOut = static_cast<IMMCImage *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\image.h ===
//=--------------------------------------------------------------------------=
// image.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImage class definition - implements MMCImage object
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGE_DEFINED_
#define _IMAGE_DEFINED_


class CMMCImage : public CSnapInAutomationObject,
                  public CPersistence,
                  public IMMCImage
{
    private:
        CMMCImage(IUnknown *punkOuter);
        ~CMMCImage();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCImage

        SIMPLE_PROPERTY_RW(CMMCImage,     Index, long, DISPID_IMAGE_INDEX);
        BSTR_PROPERTY_RW(CMMCImage,       Key, DISPID_IMAGE_KEY);
        VARIANTREF_PROPERTY_RW(CMMCImage, Tag, DISPID_IMAGE_TAG);
        OBJECT_PROPERTY_RW(CMMCImage,     Picture, IPictureDisp, DISPID_IMAGE_PICTURE);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // Public utility functions
    public:
        BSTR GetKeyPtr() { return m_bstrKey; }
        IPictureDisp *GetPicture() { return m_piPicture; }
        HRESULT GetPictureHandle(short TypeNeeded, OLE_HANDLE *phPicture);

    private:

        void InitMemberVariables();
        HBITMAP m_hBitmap; // for bitmaps, bitmap is cached here to improve
                           // performance of multiple fetches
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImage,           // name
                                &CLSID_MMCImage,    // clsid
                                "MMCImage",         // objname
                                "MMCImage",         // lblname
                                &CMMCImage::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_IMMCImage,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _IMAGE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\images.cpp ===
//=--------------------------------------------------------------------------=
// images.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImages class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "images.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImages::CMMCImages(IUnknown *punkOuter) :
    CSnapInCollection<IMMCImage, MMCImage, IMMCImages>(
                                             punkOuter,
                                             OBJECT_TYPE_MMCIMAGES,
                                             static_cast<IMMCImages *>(this),
                                             static_cast<CMMCImages *>(this),
                                             CLSID_MMCImage,
                                             OBJECT_TYPE_MMCIMAGE,
                                             IID_IMMCImage,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImages,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImages::~CMMCImages()
{
}

IUnknown *CMMCImages::Create(IUnknown * punkOuter)
{
    CMMCImages *pMMCImages = New CMMCImages(punkOuter);
    if (NULL == pMMCImages)
    {
        return NULL;
    }
    else
    {
        return pMMCImages->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IMMCImages Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCImages::Add
(
    VARIANT    Index,
    VARIANT    Key, 
    VARIANT    Picture,
    MMCImage **ppMMCImage
)
{
    HRESULT       hr = S_OK;
    IMMCImage    *piMMCImage = NULL;
    IPictureDisp *piPictureDisp = NULL;

    hr = CSnapInCollection<IMMCImage, MMCImage, IMMCImages>::Add(Index, Key, &piMMCImage);
    IfFailGo(hr);

    if (ISPRESENT(Picture))
    {
        if (VT_UNKNOWN == Picture.vt)
        {
            if (NULL == Picture.punkVal)
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            else
            {
                hr = Picture.punkVal->QueryInterface(IID_IPictureDisp, reinterpret_cast<void **>(&piPictureDisp));
                if (FAILEDHR(hr))
                {
                    hr = SID_E_INVALIDARG;
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else if (VT_DISPATCH == Picture.vt)
        {
            if (NULL == Picture.pdispVal)
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            else
            {
                hr = Picture.pdispVal->QueryInterface(IID_IPictureDisp, reinterpret_cast<void **>(&piPictureDisp));
                if (FAILEDHR(hr))
                {
                    hr = SID_E_INVALIDARG;
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(piMMCImage->putref_Picture(piPictureDisp));
    }

    *ppMMCImage = reinterpret_cast<MMCImage *>(piMMCImage);

Error:
    QUICK_RELEASE(piPictureDisp);
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCImage);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImages::Persist()
{
    HRESULT           hr = S_OK;
    IMMCImage  *piMMCImage = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCImage, MMCImage, IMMCImages>::Persist(piMMCImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImages::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCImages == riid)
    {
        *ppvObjOut = static_cast<IMMCImages *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCImage, MMCImage, IMMCImages>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\images.h ===
//=--------------------------------------------------------------------------=
// images.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImages class definition - implements MMCImages collection
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGES_DEFINED_
#define _IMAGES_DEFINED_

#include "collect.h"

class CMMCImages : public CSnapInCollection<IMMCImage, MMCImage, IMMCImages>,
                   public CPersistence
{
    protected:
        CMMCImages(IUnknown *punkOuter);
        ~CMMCImages();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCImages
        STDMETHOD(Add)(VARIANT    Index,
                       VARIANT    Key, 
                       VARIANT    Picture,
                       MMCImage **ppMMCImage);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImages,           // name
                                &CLSID_MMCImages,    // clsid
                                "MMCImages",         // objname
                                "MMCImages",         // lblname
                                &CMMCImages::Create, // creation function
                                TLIB_VERSION_MAJOR,  // major version
                                TLIB_VERSION_MINOR,  // minor version
                                &IID_IMMCImages,     // dispatch IID
                                NULL,                // no events IID
                                HELP_FILENAME,       // help file
                                TRUE);               // thread safe


#endif // _IMAGES_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglist.cpp ===
//=--------------------------------------------------------------------------=
// imglist.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageList class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "imglist.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CMMCImageList::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_MMCImageListImagesPP,
    &CLSID_StockColorPage
};


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImageList::CMMCImageList(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCIMAGELIST,
                            static_cast<IMMCImageList *>(this),
                            static_cast<CMMCImageList *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImageList,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImageList::~CMMCImageList()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    RELEASE(m_piListImages);
    InitMemberVariables();
}

void CMMCImageList::InitMemberVariables()
{
    m_Index = 0;
    m_bstrName = NULL;
    m_bstrKey = NULL;
    m_MaskColor = 0;
    m_piListImages = NULL;
}

IUnknown *CMMCImageList::Create(IUnknown * punkOuter)
{
    CMMCImageList *pMMCImageList = New CMMCImageList(punkOuter);
    if (NULL == pMMCImageList)
    {
        return NULL;
    }
    else
    {
        return pMMCImageList->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageList::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistSimpleType(&m_MaskColor, (OLE_COLOR)0, OLESTR("MaskColor")));

    IfFailRet(PersistObject(&m_piListImages, CLSID_MMCImages,
                            OBJECT_TYPE_MMCIMAGES, IID_IMMCImages,
                            OLESTR("ListImages")));

    IfFailRet(PersistDISPID());

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageList::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCImageList == riid)
    {
        *ppvObjOut = static_cast<IMMCImageList *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglists.h ===
//=--------------------------------------------------------------------------=
// imglists.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageLists class definition - implements MMCImageLists collection
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGELISTS_DEFINED_
#define _IMAGELISTS_DEFINED_

#include "collect.h"

class CMMCImageLists : public CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>,
                       public CPersistence
{
    protected:
        CMMCImageLists(IUnknown *punkOuter);
        ~CMMCImageLists();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImageLists,           // name
                                &CLSID_MMCImageLists,    // clsid
                                "MMCImageLists",         // objname
                                "MMCImageLists",         // lblname
                                &CMMCImageLists::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IMMCImageLists,     // dispatch IID
                                NULL,                    // no events IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _IMAGELISTS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglists.cpp ===
//=--------------------------------------------------------------------------=
// imglists.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageLists class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "imglists.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImageLists::CMMCImageLists(IUnknown *punkOuter) :
    CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>(
                                                     punkOuter,
                                                     OBJECT_TYPE_MMCIMAGELISTS,
                                                     static_cast<IMMCImageLists *>(this),
                                                     static_cast<CMMCImageLists *>(this),
                                                     CLSID_MMCImageList,
                                                     OBJECT_TYPE_MMCIMAGELIST,
                                                     IID_IMMCImageList,
                                                     static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImageLists,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImageLists::~CMMCImageLists()
{
}

IUnknown *CMMCImageLists::Create(IUnknown * punkOuter)
{
    CMMCImageLists *pMMCImageLists = New CMMCImageLists(punkOuter);
    if (NULL == pMMCImageLists)
    {
        return NULL;
    }
    else
    {
        return pMMCImageLists->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageLists::Persist()
{
    HRESULT           hr = S_OK;
    IMMCImageList  *piMMCImageList = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>::Persist(piMMCImageList);

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageLists::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCImageLists == riid)
    {
        *ppvObjOut = static_cast<IMMCImageLists *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitem.cpp ===
//=--------------------------------------------------------------------------=
// listitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "listitem.h"
#include "lsubitms.h"
#include "lsubitem.h"
#include "xtensons.h"


// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListItem::CMMCListItem(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCLISTITEM,
                            static_cast<IMMCListItem *>(this),
                            static_cast<CMMCListItem *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCListItem,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListItem::~CMMCListItem()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrID);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    (void)::VariantClear(&m_varIcon);
    RELEASE(m_piListSubItems);
    RELEASE(m_piDynamicExtensions);
    RELEASE(m_punkData);
    FREESTRING(m_bstrItemTypeGUID);
    FREESTRING(m_bstrDefaultDataFormat);
    RELEASE(m_piDynamicExtensions);
    (void)::VariantClear(&m_varHint);
    InitMemberVariables();
}



void CMMCListItem::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrID = NULL;

    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
    
    ::VariantInit(&m_varIcon);

    m_Pasted = VARIANT_FALSE;
    m_piListSubItems = NULL;
    m_piDynamicExtensions = NULL;
    m_punkData = NULL;
    m_bstrItemTypeGUID = NULL;
    m_bstrDefaultDataFormat = NULL;
    m_hri = NULL;
    m_fHaveHri = FALSE;
    m_pMMCListItems = NULL;
    m_pData = NULL;
    m_pSnapIn = NULL;
    m_piDynamicExtensions = NULL;
    m_fVirtual = VARIANT_FALSE;

    ::VariantInit(&m_varHint);
}



IUnknown *CMMCListItem::Create(IUnknown * punkOuter)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkMMCListSubItems = NULL;
    CMMCListItem   *pMMCListItem = New CMMCListItem(punkOuter);

    if (NULL == pMMCListItem)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Create all contained objects

    punkMMCListSubItems = CMMCListSubItems::Create(NULL);
    if (NULL == punkMMCListSubItems)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCListSubItems->QueryInterface(IID_IMMCListSubItems,
                    reinterpret_cast<void **>(&pMMCListItem->m_piListSubItems)));

    // Create the data object and aggregate it. This allows clients to hold
    // onto the list item or the data object and avoid a circular ref count
    // where each object would have to hold a ref on the other.
    
    pMMCListItem->m_punkData = CMMCDataObject::Create(pMMCListItem->PrivateUnknown());
    if (NULL == pMMCListItem->m_punkData)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(pMMCListItem->SetData());


Error:
    QUICK_RELEASE(punkMMCListSubItems);
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCListItem)
        {
            delete pMMCListItem;
        }
        return NULL;
    }
    else
    {
        return pMMCListItem->PrivateUnknown();
    }
}



void CMMCListItem::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    if (NULL != m_pData)
    {
        m_pData->SetSnapIn(pSnapIn);
    }
}



HRESULT CMMCListItem::SetData()
{
    HRESULT         hr = S_OK;
    IMMCDataObject *piMMCDataObject = NULL;
    
    if (NULL != m_punkData)
    {
        IfFailGo(m_punkData->QueryInterface(IID_IMMCDataObject,
                                  reinterpret_cast<void **>(&piMMCDataObject)));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCDataObject, &m_pData));
        m_pData->SetType(CMMCDataObject::ListItem);
        m_pData->SetListItem(this);
        m_pData->SetSnapIn(m_pSnapIn);
    }

Error:
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}



HRESULT CMMCListItem::GetItemState(UINT uiState, VARIANT_BOOL *pfvarOn)
{
    HRESULT          hr = S_OK;
    IResultData     *piResultData = NULL; // not AddRef()ed

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    IfFalseGo(NULL != pfvarOn, SID_E_INVALIDARG);

    *pfvarOn = VARIANT_FALSE;

    IfFailGo(GetIResultData(&piResultData, NULL));

    rdi.mask = RDI_STATE;

    if (m_fVirtual)
    {
        rdi.nIndex = static_cast<int>(m_Index - 1L);
    }
    else
    {
        rdi.itemID = m_hri;
    }

    IfFailGo(piResultData->GetItem(&rdi));

    if ( (rdi.nState & uiState) != 0 )
    {
        *pfvarOn = VARIANT_TRUE;
    }

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



HRESULT CMMCListItem::SetItemState(UINT uiState, VARIANT_BOOL fvarOn)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    IfFailGo(GetIResultData(&piResultData, NULL));

    // Get the current selection state of the item

    rdi.mask = RDI_STATE;

    if (m_fVirtual)
    {
        rdi.nIndex = static_cast<int>(m_Index - 1L);
    }
    else
    {
        rdi.itemID = m_hri;
    }

    IfFailGo(piResultData->GetItem(&rdi));

    // If the state is currently on

    if ( (rdi.nState & uiState) != 0 )
    {
        // If the user asked to turn it off

        if (VARIANT_FALSE == fvarOn)
        {
            // Turn it off
            IfFailGo(piResultData->ModifyItemState(rdi.nIndex, rdi.itemID,
                                                   0,         // add nothing
                                                   uiState)); // remove
                                                              // specified state
        }
    }
    else // the state is currently off
    {
        // If the user asked to turn it on

        if (VARIANT_TRUE == fvarOn)
        {
            // Turn it on
            IfFailGo(piResultData->ModifyItemState(rdi.nIndex, rdi.itemID,
                                                   uiState,// add specified state
                                                   0));    // remove nothing
        }
    }

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CMMCListItem::GetIResultData
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IResultData **ppiResultData [out] IResultData returned here if non-NULL
//   CView       **ppView        [out] CView returned here if non-NULL
//
// Output:
//    None
//
// Notes:
//
// An MMCListItem object has a back-pointer to its owning MMCListItems
// collection. That collection has a back-pointer to its owning MMCListView.
// The back-pointers continue up the object hierarchy to the View object that
// has the IResultData pointer. Although it would be simple to follow the chain
// and check for NULLs along the way, it would not handle the situation of an
// orphaned list item. A list item is orphaned when the list view that contains
// it is destroyed. This can happen easily if a user opens a property page for
// a list item and then selects a different node in the scope pane. The owning
// list view is destroyed but the property page is still running in the other
// thread and has a reference to the MMCListItem object in SelectedControls().
// The property page could call MMCListItem.Update in response to an Apply.
// Unforuntately, the MMCListItem object has a back-pointer and it has no way
// of knowing whether it is still good.
//
// To handle that situation, this function examines every existing list view
// in the snap-in, and checks for two conditions:
//
// 1) ListView.ListItems is the same pointer as this MMCListItem's back pointer
// 2) ListVIew.ListItems.ID is the same as this MMCListItem's ID.
//
// Each MMCListItems has a unique ID (see CMMCListItems ctor in listitms.cpp)
// and each MMCListItem in its collection receives the same ID. (The ID is not
// an exposed property to the VB code).
//
// The code below essentially does this (in VB syntax)
//
// For Each View In SnapIn.Views
//      For Each ScopePaneItem in View.ScopePaneItems
//          For Each ResultView in ScopePaneItem.ResultViews
//              If ResultView.ListView.ListItems = MMCListItem.ListItems And
//                 ResultView.ListView.ListItems.ID = MMCListItem.ID Then
//                      This is match and we can use the View's IResultData
// 
//
HRESULT CMMCListItem::GetIResultData
(
    IResultData **ppiResultData,
    CView       **ppView
)
{
    HRESULT         hr = SID_E_DETACHED_OBJECT;
    CMMCListView   *pMMCListView = NULL;
    CMMCListItems  *pMMCListItems = NULL;

    CViews          *pViews = NULL;
    CView           *pView = NULL;
    long             cViews = 0;

    CScopePaneItems *pScopePaneItems = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    long             cScopePaneItems = 0;

    CResultViews    *pResultViews = NULL;
    CResultView     *pResultView = NULL;
    long             cResultViews = 0;

    long i, j, k = 0;

    if (NULL != ppiResultData)
    {
        *ppiResultData = NULL;
    }
    if (NULL != ppView)
    {
        *ppView = NULL;
    }

    IfFalseGo(NULL != m_pSnapIn, SID_E_DETACHED_OBJECT);
    IfFalseGo(NULL != m_pMMCListItems, SID_E_DETACHED_OBJECT);

    pViews = m_pSnapIn->GetViews();
    IfFalseGo(NULL != pViews, SID_E_DETACHED_OBJECT);

    cViews = pViews->GetCount();
    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(pViews->GetItemByIndex(i),
                                                       &pView));
        
        pScopePaneItems = pView->GetScopePaneItems();
        if (NULL == pScopePaneItems)
        {
            continue;
        }

        cScopePaneItems = pScopePaneItems->GetCount();
        for (j = 0; j < cScopePaneItems; j++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                             pScopePaneItems->GetItemByIndex(j),
                                             &pScopePaneItem));
            if (!pScopePaneItem->Active())
            {
                continue;
            }

            pResultViews = pScopePaneItem->GetResultViews();
            if (NULL == pResultViews)
            {
                continue;
            }

            cResultViews = pResultViews->GetCount();
            for (k = 0; k < cResultViews; k++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                pResultViews->GetItemByIndex(k),
                                                &pResultView));
                pMMCListView = pResultView->GetListView();
                if (NULL == pMMCListView)
                {
                    continue;
                }
                
                pMMCListItems = pMMCListView->GetMMCListItems();

                if (NULL == pMMCListItems)
                {
                    continue;
                }

                if ( (pMMCListItems == m_pMMCListItems) &&
                     (pMMCListItems->GetID() == m_pMMCListItems->GetID()) )
                {
                    if (NULL != ppiResultData)
                    {
                        *ppiResultData = pView->GetIResultData();
                    }

                    if (NULL != ppView)
                    {
                        *ppView = pView;
                    }
                    goto Cleanup;
                }
            }
        }
    }


Cleanup:
Error:
    if (S_OK == hr)
    {
        hr = SID_E_DETACHED_OBJECT;
    }

    if (NULL != ppiResultData)
    {
        if (NULL != *ppiResultData)
        {
            hr = S_OK;
        }
    }

    if (NULL != ppView)
    {
        if (NULL != *ppView)
        {
            hr = S_OK;
        }
    }

    if (SID_E_DETACHED_OBJECT == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IMMCListItem Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CMMCListItem::get_Data(MMCDataObject **ppMMCDataObject)
{
    HRESULT hr = S_OK;

    *ppMMCDataObject = NULL;

    if (NULL == m_punkData)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_punkData->QueryInterface(IID_IMMCDataObject,
                                   reinterpret_cast<void **>(ppMMCDataObject)));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::get_Text(BSTR *pbstrText)
{
    RRETURN(GetBstr(pbstrText, m_bstrText));
}



STDMETHODIMP CMMCListItem::put_Text(BSTR bstrText)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    CView       *pView = NULL;

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    // Set the property

    IfFailGo(SetBstr(bstrText, &m_bstrText, DISPID_LISTITEM_TEXT));

    // If we are in a live, non-virtual listview then change it in MMC too

    IfFalseGo(!m_fVirtual, S_OK);
    IfFalseGo(m_fHaveHri, S_OK);
    IfFalseGo(NULL != m_pMMCListItems, S_OK);
    IfFailGo(GetIResultData(&piResultData, &pView));

    // Get the current selection state of the item

    rdi.mask = RDI_STR;
    rdi.str = MMC_CALLBACK;
    rdi.itemID = m_hri;

    IfFailGo(piResultData->SetItem(&rdi));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::get_Icon(VARIANT *pvarIcon)
{
    RRETURN(GetVariant(pvarIcon, m_varIcon));
}


STDMETHODIMP CMMCListItem::put_Icon(VARIANT varIcon)
{
    HRESULT      hr = S_OK;
    int          nImage = 0;
    IResultData *piResultData = NULL; // not AddRef()ed
    CView       *pView = NULL;

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    // Check for a good VT

    if ( (!IS_VALID_INDEX_TYPE(varIcon)) && (!ISEMPTY(varIcon)) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the new value is an empty string or a NULL string then change that to
    // VT_EMPTY as they mean the same thing.

    if (VT_BSTR == varIcon.vt)
    {
        if (NULL == varIcon.bstrVal)
        {
            varIcon.vt = VT_EMPTY;
        }
        else if (0 == ::wcslen(varIcon.bstrVal))
        {
            varIcon.vt = VT_EMPTY;
        }
    }

    IfFailGo(SetVariant(varIcon, &m_varIcon, DISPID_LISTITEM_ICON));

    // If being set to Empty then nothing else to do.

    IfFalseGo(!ISEMPTY(varIcon), S_OK);

    // If we are in a live, non-virtual listview then change it in MMC too

    IfFalseGo(!m_fVirtual, S_OK);
    IfFalseGo(m_fHaveHri, S_OK);
    IfFalseGo(NULL != m_pMMCListItems, S_OK);
    IfFailGo(GetIResultData(&piResultData, &pView));

    // Get the numerical index of the image from MMCListView.Icons.ListImages

    hr = ::GetImageIndex(m_pMMCListItems->GetListView(), varIcon, &nImage);

    // If it is a bad index then return invalid arg.

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Check for other possible errors

    IfFailGo(hr);

    // Index is good. Change it in the console.

    rdi.nImage = nImage;
    rdi.mask = RDI_IMAGE;
    rdi.itemID = m_hri;

    hr = piResultData->SetItem(&rdi);
    EXCEPTION_CHECK_GO(hr);
    
Error:
    RRETURN(hr);
}




STDMETHODIMP CMMCListItem::get_Selected(VARIANT_BOOL *pfvarSelected)
{
    RRETURN(GetItemState(LVIS_SELECTED, pfvarSelected));
}

STDMETHODIMP CMMCListItem::put_Selected(VARIANT_BOOL fvarSelected)
{
    RRETURN(SetItemState(LVIS_SELECTED, fvarSelected));
}




STDMETHODIMP CMMCListItem::get_Focused(VARIANT_BOOL *pfvarFocused)
{
    RRETURN(GetItemState(LVIS_FOCUSED, pfvarFocused));
}

STDMETHODIMP CMMCListItem::put_Focused(VARIANT_BOOL fvarFocused)
{
    RRETURN(SetItemState(LVIS_FOCUSED, fvarFocused));
}




STDMETHODIMP CMMCListItem::get_DropHilited(VARIANT_BOOL *pfvarDropHilited)
{
    RRETURN(GetItemState(LVIS_DROPHILITED, pfvarDropHilited));
}

STDMETHODIMP CMMCListItem::put_DropHilited(VARIANT_BOOL fvarDropHilited)
{
    RRETURN(SetItemState(LVIS_DROPHILITED, fvarDropHilited));
}




STDMETHODIMP CMMCListItem::get_Cut(VARIANT_BOOL *pfvarCut)
{
    RRETURN(GetItemState(LVIS_CUT, pfvarCut));
}

STDMETHODIMP CMMCListItem::put_Cut(VARIANT_BOOL fvarCut)
{
    RRETURN(SetItemState(LVIS_CUT, fvarCut));
}




STDMETHODIMP CMMCListItem::get_SubItems
(
    short Index,
    BSTR *pbstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex,
                                        reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->get_Text(pbstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}

STDMETHODIMP CMMCListItem::put_SubItems
(
    short Index,
    BSTR  bstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex,
                                        reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->put_Text(bstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::Update()
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    HRESULTITEM  hri = 0;
    CView       *pView = NULL;

    IfFalseGo(NULL != m_pMMCListItems, SID_E_DETACHED_OBJECT);
    IfFailGo(GetIResultData(&piResultData, &pView));

    if (m_fVirtual)
    {
        hri = static_cast<HRESULTITEM>(m_Index - 1L);

        // Tell the owning view about the update so it can check whether it
        // needs to invalidate its cache.
        pView->ListItemUpdate(this);
    }
    else
    {
        hri = m_hri;
    }

    IfFailGo(piResultData->UpdateItem(hri));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



STDMETHODIMP CMMCListItem::UpdateAllViews
(
    VARIANT Hint
)
{
    HRESULT  hr = S_OK;
    CView   *pView = NULL;

    IfFalseGo(NULL != m_pMMCListItems, SID_E_DETACHED_OBJECT);
    IfFailGo(GetIResultData(NULL, &pView));

    // Copy the VARIANT (if it was passed) so it can be retrieved by the
    // receiving views. VariantCopy() will first call VariantClear() on the
    // destination so any old hint will be released.

    if (ISPRESENT(Hint))
    {
        IfFailGo(::VariantCopy(&m_varHint, &Hint));
    }
    else
    {
        // Snap-in didn't pass Hint, set our hint holder to an empty VARIANT
        // so when it is passed to ResultViews_ItemViewChange it will have been
        // initialized to VT_EMPTY.

        IfFailGo(::VariantClear(&m_varHint));
    }

    // Call MMC and use data to hold the index of the MMCListItem

    IfFailGo(pView->GetIConsole2()->UpdateAllViews(
                               static_cast<IDataObject *>(m_pData), m_Index, 0));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::PropertyChanged(VARIANT Data)
{
    HRESULT       hr = S_OK;
    CResultView  *pResultView = NULL;
    IResultData  *piResultData = NULL;

    IfFalseGo(NULL != m_pSnapIn, SID_E_DETACHED_OBJECT);

    if (SUCCEEDED(GetIResultData(&piResultData, NULL)))
    {
        pResultView = m_pMMCListItems->GetListView()->GetResultView();
    }
    
    // The snap-in has the hidden global ResultViews collection where events
    // are fired. Fire ResultViews_PropertyChanged for this list item passing the
    // specified data.

    m_pSnapIn->GetResultViews()->FirePropertyChanged(
                                        static_cast<IResultView *>(pResultView),
                                        static_cast<IMMCListItem *>(this),
                                        Data);
    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CMMCListItem::get_DynamicExtensions                          [IMMCListItem]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IExtensions **ppiExtenions [out] dynamic extensions collection
//
// Output:
//      HRESULT
//
// Notes:
//
// CONSIDER: potential perf improvement by caching dynamic extension
// collections for item type GUIDs.
//

STDMETHODIMP CMMCListItem::get_DynamicExtensions(Extensions **ppExtensions)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkExtensions = NULL;
    CExtensions  *pExtensions = NULL;
    IExtension   *piExtension = NULL;
    VARIANT_BOOL  fvarExtensible = VARIANT_FALSE;

    // If we already built the collection then just return it.

    IfFalseGo(NULL == m_piDynamicExtensions, S_OK);

    // This is the first GET on this property so we need to build the collection
    // by examining the registry for all extensions of this snap-in.

    punkExtensions = CExtensions::Create(NULL);
    if (NULL == punkExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkExtensions, &pExtensions));
    IfFailGo(pExtensions->Populate(m_bstrItemTypeGUID, CExtensions::Dynamic));
    IfFailGo(punkExtensions->QueryInterface(IID_IExtensions,
                             reinterpret_cast<void **>(&m_piDynamicExtensions)));

Error:

    if (SUCCEEDED(hr))
    {
        m_piDynamicExtensions->AddRef();
        *ppExtensions = reinterpret_cast<Extensions *>(m_piDynamicExtensions);
    }

    QUICK_RELEASE(punkExtensions);
    RRETURN(hr);
}


HRESULT CMMCListItem::GetColumnTextPtr(long lColumn, OLECHAR **ppwszText)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    CMMCListSubItem *pMMCListSubItem = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);


    *ppwszText = NULL;

    varIndex.vt = VT_I4;
    varIndex.lVal = lColumn;
    IfFailGo(m_piListSubItems->get_Item(varIndex,
                                        reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListSubItem,
                                                   &pMMCListSubItem));
    *ppwszText = pMMCListSubItem->GetTextPtr();

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListItem::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrID, L"", OLESTR("ID")));

    // We don't persist the tag because it may contain a non-persistable
    // object. Any runtime code that needs to clone a listitem using
    // persistence must copy the tag.

    if (InitNewing())
    {
        IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));
    }
    
    IfFailGo(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailGo(PersistVariant(&m_varIcon, varDefault, OLESTR("Icon")));

    IfFailGo(PersistSimpleType(&m_Pasted, VARIANT_FALSE, OLESTR("Pasted")));

    IfFailGo(PersistObject(&m_piListSubItems, CLSID_MMCListSubItems,
                           OBJECT_TYPE_MMCLISTSUBITEMS, IID_IMMCListSubItems,
                           OLESTR("ListSubItems")));

    // This serialization is no longer used and the DynamicExtensions property is not
    // always created so this line is left disabled. If serialization is every needed
    // for a listitem then the DynamicExtensions collection will need to be created
    // when the listitem is created.
    
    // IfFailGo(PersistObject(&m_piDynamicExtensions, CLSID_Extensions, OBJECT_TYPE_EXTENSIONS, IID_IExtensions, OLESTR("DynamicExtensions")));

    // NOTE: we don't persist data because there is no way to guarantee that
    // all objects in there are persistable. Any runtime code that needs to
    // clone a listitem using persistence must copy the tag.

    IfFailGo(PersistBstr(&m_bstrItemTypeGUID, L"", OLESTR("ItemTypeGUID")));

    IfFailGo(PersistBstr(&m_bstrDefaultDataFormat, L"", OLESTR("DefaultDataFormat")));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCListItem == riid)
    {
        *ppvObjOut = static_cast<IMMCListItem *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if ( ( (IID_IDataObject == riid) || (IID_IMMCDataObject == riid) ) &&
              (NULL != m_punkData)
            )
    {
        return m_punkData->QueryInterface(riid, ppvObjOut);
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglist.h ===
//=--------------------------------------------------------------------------=
// imglist.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageList class definition - implements MMCImageList
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGELIST_DEFINED_
#define _IMAGELIST_DEFINED_


class CMMCImageList : public CSnapInAutomationObject,
                      public CPersistence,
                      public IMMCImageList
{
    private:
        CMMCImageList(IUnknown *punkOuter);
        ~CMMCImageList();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCImageList

        BSTR_PROPERTY_RW(CMMCImageList,         Name, DISPID_VALUE);
        SIMPLE_PROPERTY_RW(CMMCImageList,       Index, long, DISPID_IMAGELIST_INDEX);
        BSTR_PROPERTY_RW(CMMCImageList,         Key, DISPID_IMAGELIST_KEY);
        VARIANTREF_PROPERTY_RW(CMMCImageList,   Tag, DISPID_IMAGELIST_TAG);
        SIMPLE_PROPERTY_RW(CMMCImageList,       MaskColor, OLE_COLOR, DISPID_IMAGELIST_MASK_COLOR);
        COCLASS_PROPERTY_RW(CMMCImageList,      ListImages, MMCImages, IMMCImages, DISPID_IMAGELIST_LIST_IMAGES);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // Property page CLSIDs for ISpecifyPropertyPages support
        
        static const GUID *m_rgpPropertyPageCLSIDs[2];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImageList,           // name
                                &CLSID_MMCImageList,    // clsid
                                "MMCImageList",         // objname
                                "MMCImageList",         // lblname
                                &CMMCImageList::Create, // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCImageList,     // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _IMAGELIST_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitem.h ===
//=--------------------------------------------------------------------------=
// listitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItem class definition - implements MMCListItem object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTITEM_DEFINED_
#define _LISTITEM_DEFINED_

#include "listitms.h"
#include "dataobj.h"

class CMMCListItems;
class CMMCDataObject;

class CMMCListItem : public CSnapInAutomationObject,
                     public CPersistence,
                     public IMMCListItem
{
    private:
        CMMCListItem(IUnknown *punkOuter);
        ~CMMCListItem();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListItem

        SIMPLE_PROPERTY_RW(CMMCListItem,        Index, long, DISPID_LISTITEM_INDEX);
        BSTR_PROPERTY_RW(CMMCListItem,          Key, DISPID_LISTITEM_KEY);
        BSTR_PROPERTY_RW(CMMCListItem,          ID, DISPID_LISTITEM_ID);
        VARIANTREF_PROPERTY_RW(CMMCListItem,    Tag, DISPID_LISTITEM_TAG);

        STDMETHOD(get_Text)(BSTR *pbstrText);
        STDMETHOD(put_Text)(BSTR bstrText);

        STDMETHOD(put_Icon)(VARIANT varIcon);
        STDMETHOD(get_Icon)(VARIANT *pvarIcon);

        STDMETHOD(get_Selected)(VARIANT_BOOL *pfvarSelected);
        STDMETHOD(put_Selected)(VARIANT_BOOL fvarSelected);

        STDMETHOD(get_Focused)(VARIANT_BOOL *pfvarFocused);
        STDMETHOD(put_Focused)(VARIANT_BOOL fvarFocused);

        STDMETHOD(get_DropHilited)(VARIANT_BOOL *pfvarDropHilited);
        STDMETHOD(put_DropHilited)(VARIANT_BOOL fvarDropHilited);

        STDMETHOD(get_Cut)(VARIANT_BOOL *pfvarCut);
        STDMETHOD(put_Cut)(VARIANT_BOOL fvarCut);

        SIMPLE_PROPERTY_RW(CMMCListItem,        Pasted, VARIANT_BOOL, DISPID_LISTITEM_PASTED);

        STDMETHOD(get_SubItems)(short Index, BSTR *pbstrItem);
        STDMETHOD(put_SubItems)(short Index, BSTR bstrItem);

        COCLASS_PROPERTY_RW(CMMCListItem,       ListSubItems, MMCListSubItems, IMMCListSubItems, DISPID_LISTITEM_LIST_SUBITEMS);

        STDMETHOD(get_DynamicExtensions)(Extensions **ppExtensions);
        STDMETHOD(get_Data)(MMCDataObject **ppMMCDataObject);

        BSTR_PROPERTY_RW(CMMCListItem,          ItemTypeGUID, DISPID_LISTITEM_ITEM_TYPE_GUID);
        BSTR_PROPERTY_RW(CMMCListItem,          DefaultDataFormat, DISPID_LISTITEM_DEFAULT_DATA_FORMAT);

        STDMETHOD(Update)();
        STDMETHOD(UpdateAllViews)(VARIANT Hint);
        STDMETHOD(PropertyChanged)(VARIANT Data);

    // Public utility methods

        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        CMMCDataObject *GetData() { return m_pData; }
        void SetHRESULTITEM(HRESULTITEM hri) { m_hri = hri; m_fHaveHri = TRUE; }
        void RemoveHRESULTITEM() { m_hri = NULL; m_fHaveHri = FALSE; }
        HRESULTITEM GetHRESULTITEM() { return m_hri; }
        void SetListItems(CMMCListItems *pMMCListItems) { m_pMMCListItems = pMMCListItems; }
        CMMCListItems *GetListItems() { return m_pMMCListItems; }
        LPOLESTR GetTextPtr() { return static_cast<LPOLESTR>(m_bstrText); }
        HRESULT GetColumnTextPtr(long lColumn, OLECHAR **ppwszText);
        BSTR GetNodeTypeGUID() { return m_bstrItemTypeGUID; }
        BSTR GetKey() { return m_bstrKey; }
        long GetIndex() { return m_Index; }
        void SetIndex(long lIndex) { m_Index = lIndex; }
        IExtensions *GetDynamicExtensions() { return m_piDynamicExtensions; }
        VARIANT GetHint() { return m_varHint; }
        void ClearHint() { (void)::VariantClear(&m_varHint); }
        void SetVirtual() { m_fVirtual = TRUE; }
        BOOL IsVirtual() { return m_fVirtual; }
        BSTR GetID() { return m_bstrID; }
        
    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT GetItemState(UINT uiState, VARIANT_BOOL *pfvarOn);
        HRESULT SetItemState(UINT uiState, VARIANT_BOOL fvarOn);
        HRESULT SetData();
        HRESULT GetIResultData(IResultData **ppiResultData, CView **ppView);

        HRESULTITEM     m_hri;          // item ID when in result pane
        BOOL            m_fHaveHri;     // TRUE=we have an item ID
        CMMCListItems  *m_pMMCListItems;// owning collection
        CMMCDataObject *m_pData;        // data associated with listitem
        IUnknown       *m_punkData;     // associated data obj's inner IUnknown
        CSnapIn        *m_pSnapIn;      // back pointer to owning snap-in
        VARIANT         m_varHint;      // holds UpdateAllViews() Hint param
        BSTR            m_bstrText;     // holds Text property
        VARIANT         m_varIcon;      // holds Icon property
        BOOL            m_fVirtual;     // TRUE-virtual list item

        IExtensions    *m_piDynamicExtensions; // dynamic extension collection
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListItem,           // name
                                &CLSID_MMCListItem,    // clsid
                                "MMCListItem",         // objname
                                "MMCListItem",         // lblname
                                &CMMCListItem::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IMMCListItem,     // dispatch IID
                                NULL,                  // event IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _LISTITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitms.cpp ===
//=--------------------------------------------------------------------------=
// listitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "listitms.h"
#include "listitem.h"

// for ASSERT and FAIL
//
SZTHISFILE

LONG CMMCListItems::m_NextID = 0;

#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListItems::CMMCListItems(IUnknown *punkOuter) :
    CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>(
                                                   punkOuter,
                                                   OBJECT_TYPE_MMCLISTITEMS,
                                                   static_cast<IMMCListItems *>(this),
                                                   static_cast<CMMCListItems *>(this),
                                                   CLSID_MMCListItem,
                                                   OBJECT_TYPE_MMCLISTITEM,
                                                   IID_IMMCListItem,
                                                   NULL)
{
    InitMemberVariables();

    // Get a unique ID for this colleciton. We use InterlockedExchangeAdd()
    // because InterlockedIncrement() does not have a guranateed return value
    // under Win95.
    
    m_ID = ::InterlockedExchangeAdd(&m_NextID, 1L) + 1L;
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListItems::~CMMCListItems()
{
    // We need to call our own clear (rather than waiting for the
    // CSnapInCollection destructor because we have our own processing to
    // do when a list item is removed from the collection.
    Clear();
    InitMemberVariables();
}

void CMMCListItems::InitMemberVariables()
{
    m_pMMCListView = NULL;
    m_lCount = 0;
    m_ID = 0;
}


IUnknown *CMMCListItems::Create(IUnknown * punkOuter)
{
    CMMCListItems *pMMCListItems = New CMMCListItems(punkOuter);
    if (NULL == pMMCListItems)
    {
        return NULL;
    }
    else
    {
        return pMMCListItems->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
// CMMCListItems::GetIResultData
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IResultData **ppiResultData [out] if non-NULL IResultData returned here
//                                        NOT AddRef()ed
//                                        DO NOT call Release on the returned
//                                        interface pointer
//      CView       **ppView        [out] if non-NULL owning CView returned here
//
// Output:
//      HRESULT
//
// Notes:
//
// As we are only a lowly list item collection and the IResultData pointer
// is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated listitems collection
// created  by the user or if any object up the hierarchy is isolated then we
// will return SID_E_DETACHED_OBJECT
//

HRESULT CMMCListItems::GetIResultData
(
    IResultData **ppiResultData,
    CView       **ppView
)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pMMCListView, hr);

    pResultView = m_pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, hr);

    pScopePaneItem = pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);
    IfFalseGo(pScopePaneItem->Active(), hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    if (NULL != ppiResultData)
    {
        *ppiResultData = pView->GetIResultData();
        IfFalseGo(NULL != *ppiResultData, hr);
    }

    if (NULL != ppView)
    {
        *ppView = pView;
    }

    hr = S_OK;

Error:
    RRETURN(hr);
}



HRESULT CMMCListItems::InitializeListItem(CMMCListItem *pMMCListItem)
{
    HRESULT      hr = S_OK;
    CResultView *pResultView = NULL;

    if (NULL != m_pMMCListView)
    {
        pResultView = m_pMMCListView->GetResultView();
        if (NULL != pResultView)
        {
            IfFailGo(pMMCListItem->put_ItemTypeGUID(pResultView->GetDefaultItemTypeGUID()));
            pMMCListItem->SetSnapIn(pResultView->GetSnapIn());
        }
    }
    pMMCListItem->SetListItems(this);

    IfFailGo(pMMCListItem->put_ID(pMMCListItem->GetKey()));

Error:
    RRETURN(hr);
}

HRESULT CMMCListItems::InternalRemove(VARIANT Index, RemovalOption Option)
{
    HRESULT          hr = S_OK;
    IMMCListItem    *piMMCListItem = NULL;
    CMMCListItem    *pMMCListItem = NULL;
    IResultData     *piResultData = NULL; // Not AddRef()ed
    BOOL             fVirtual = FALSE;
    long             lIndex = 0;
    HRESULTITEM      hri = 0;

    // Check whether the collection is read-only. This is possible when the
    // collection is part of a clipboard.

    if (ReadOnly())
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    if (NULL != m_pMMCListView)
    {
        fVirtual = m_pMMCListView->IsVirtual();
    }

    if (!fVirtual)
    {
        // First get the listitem so we can get its HRESULTITEM if needed

        IfFailGo(get_Item(Index, reinterpret_cast<MMCListItem **>(&piMMCListItem)));

        // Remove it from the collection if requested (we still have a ref)

        if (RemoveFromCollection == Option)
        {
            hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::Remove(Index);
            IfFailGo(hr);
        }

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                       &pMMCListItem));

        hri = pMMCListItem->GetHRESULTITEM();
    }
    else
    {
        // For virtual list items the index must be numerical and must be within
        // the range specified by a prior call to SetItemCount

        if FAILED(::ConvertToLong(Index, &lIndex))
        {
            hr = SID_E_NO_KEY_ON_VIRTUAL_ITEMS;
            EXCEPTION_CHECK_GO(hr);
        }

        if (lIndex > m_lCount)
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            EXCEPTION_CHECK_GO(hr);
        }

        hri = static_cast<HRESULTITEM>(lIndex - 1L);
    }

    // If we are connected to a live listview then remove it from there. Need to
    // crawl up the food chain to the view because it has the IResultData.

    IfFalseGo(SUCCEEDED(GetIResultData(&piResultData, NULL)), S_OK);

    hr = piResultData->DeleteItem(hri, 0);
    EXCEPTION_CHECK_GO(hr);

    // If it succeeded and this list item is not virtual then we need to release
    // the reference that we held for presence in the MMC listview. (See
    // CView::InsertListItem()). Also tell the list item it no longer has
    // a valid HRESULTITEM.

    if (!fVirtual)
    {
        piMMCListItem->Release();
        pMMCListItem->RemoveHRESULTITEM();
    }

Error:

    QUICK_RELEASE(piMMCListItem);
    RRETURN(hr);
}


HRESULT CMMCListItems::SetListView(CMMCListView *pMMCListView)
{
    HRESULT        hr = S_OK;
    long           cListItems = GetCount();
    long           i = 0;
    CMMCListItems *pMMCListItems = NULL;
    CMMCListItem  *pMMCListItem = NULL;

    m_pMMCListView = pMMCListView;

    // If the ListView is orphaning this collection then we need to orphan
    // the list items. If not, then we need to give the list items their
    // back pointer.

    if (NULL != pMMCListView)
    {
        pMMCListItems = this;
    }
    
    for (i = 0; i < cListItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pMMCListItem));
        pMMCListItem->SetListItems(pMMCListItems);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IMMCListItems Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CMMCListItems::get_Item                                     [IMMCListItems]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   VARIANT Index [in] Numerical index or string key of item to retrieve
//                      For virtual lists this must be numerical and within
//                      range specified by a previous call to SetItemCount
//
//   IMMCListItem **ppiMMCListItem [out] item returned here. Caller must Release.
//
// Output:
//      HRESULT
//
// Notes:
//
// For virtual lists a detached MMCListItem is created and initialized. For
// non-virtual lists this is a normal collection get_Item
//


STDMETHODIMP CMMCListItems::get_Item
(
    VARIANT       Index,
    MMCListItem **ppMMCListItem
)
{
    HRESULT       hr = S_OK;
    long          lIndex = 0;
    BOOL          fVirtual = FALSE;
    IUnknown     *punkMMCListItem = NULL;
    IMMCListItem *piMMCListItem = NULL;
    CMMCListItem *pMMCListItem = NULL;

    VARIANT varStringIndex;
    ::VariantInit(&varStringIndex);

    if (NULL != m_pMMCListView)
    {
        fVirtual = m_pMMCListView->IsVirtual();
    }

    if (!fVirtual)
    {
        hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::get_Item(Index, ppMMCListItem);
        IfFailGo(hr);
    }
    else
    {
        // Make sure we received a numerical index. Can't use a key on a virtual
        // list item because the collection doesn't actually contain the item.
        // It is only used as an access mechanism to the console and to contain
        // properties needed for the console (text, icon, etc.)

        if FAILED(::ConvertToLong(Index, &lIndex))
        {
            hr = SID_E_NO_KEY_ON_VIRTUAL_ITEMS;
            EXCEPTION_CHECK_GO(hr);
        }

        // Check that the index is within the range specified by a prior call
        // to SetItemCount.

        if (lIndex > m_lCount)
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            EXCEPTION_CHECK_GO(hr);
        }

        punkMMCListItem = CMMCListItem::Create(NULL);
        if (NULL == punkMMCListItem)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCListItem,
                                                       &pMMCListItem));
        IfFailGo(InitializeListItem(pMMCListItem));

        // Set MMCListItem.ID to the index as a string

        IfFailGo(::VariantChangeType(&varStringIndex, &Index, 0, VT_BSTR));
        IfFailGo(pMMCListItem->put_ID(varStringIndex.bstrVal));

        IfFailGo(punkMMCListItem->QueryInterface(IID_IMMCListItem,
                                    reinterpret_cast<void **>(&piMMCListItem)));

        // Set the list item's index  mark it as virtual
        pMMCListItem->SetIndex(lIndex);
        pMMCListItem->SetVirtual();

        *ppMMCListItem = reinterpret_cast<MMCListItem *>(piMMCListItem);
    }


Error:
    QUICK_RELEASE(punkMMCListItem);
    (void)::VariantClear(&varStringIndex);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CMMCListItems::SetItemCount                                 [IMMCListItems]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long    lCount  [in]           new count for virtual list
//   VARIANT Repaint [in, optional] False sets MMCLV_UPDATE_NOINVALIDATEALL
//                                  default is True
//   VARIANT Scroll  [in, optional] False sets MMCLV_UPDATE_NOSCROLL
//                                  default is True
//
// Output:
//      HRESULT
//
// Notes:
//
// Calls IResultData::SetItemCount()
//

STDMETHODIMP CMMCListItems::SetItemCount(long Count, VARIANT Repaint, VARIANT Scroll)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL;
    DWORD        dwOptions = 0;

    hr = GetIResultData(&piResultData, NULL);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Repaint))
    {
        if (VT_BOOL != Repaint.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        else if (VARIANT_FALSE == Repaint.boolVal)
        {
            dwOptions |= MMCLV_UPDATE_NOINVALIDATEALL;
        }
    }

    if (ISPRESENT(Scroll))
    {
        if (VT_BOOL != Scroll.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        else if (VARIANT_FALSE == Scroll.boolVal)
        {
            dwOptions |= MMCLV_UPDATE_NOSCROLL;
        }
    }

    hr = piResultData->SetItemCount(static_cast<int>(Count), dwOptions);
    EXCEPTION_CHECK_GO(hr);

    // Record count so we can check against it in get_Item()
    m_lCount = Count;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListItems::Add
( 
    VARIANT       Index,
    VARIANT       Key, 
    VARIANT       Text,
    VARIANT       Icon,
    MMCListItem **ppMMCListItem
)
{
    HRESULT       hr = S_OK;
    IMMCListItem *piMMCListItem = NULL;
    CMMCListItem *pMMCListItem = NULL;
    CResultView  *pResultView = NULL;
    IResultData  *piResultData = NULL; // Not AddRef()ed
    CView        *pView = NULL;

    VARIANT varText;
    ::VariantInit(&varText);

    if (NULL != m_pMMCListView)
    {
        if (m_pMMCListView->IsVirtual())
        {
            hr = SID_E_UNSUPPORTED_ON_VIRTUAL_LIST;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::Add(Index, Key, &piMMCListItem);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varText, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCListItem->put_Text(varText.bstrVal));
    }
    if (ISPRESENT(Icon))
    {
        IfFailGo(piMMCListItem->put_Icon(Icon));
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem, &pMMCListItem));

    IfFailGo(InitializeListItem(pMMCListItem));

    // If we are attached to a live listview, and we are not in the middle of
    // ResultViews_Initialize or ResultViews_Activate then add it there as well

    IfFalseGo(SUCCEEDED(GetIResultData(&piResultData, &pView)), S_OK);
    IfFalseGo(!m_pMMCListView->GetResultView()->InInitialize(), S_OK);
    IfFalseGo(!m_pMMCListView->GetResultView()->InActivate(), S_OK);

    IfFailGo(pView->InsertListItem(pMMCListItem));


Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCListItem);
    }
    else
    {
        *ppMMCListItem = reinterpret_cast<MMCListItem *>(piMMCListItem);
    }
    (void)::VariantClear(&varText);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItems::Remove(VARIANT Index)
{
    RRETURN(InternalRemove(Index, RemoveFromCollection));
}


STDMETHODIMP CMMCListItems::Clear()
{
    HRESULT hr = S_OK;
    long    cListItems = GetCount();

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Iterate and call InternalRemove because that function knows how to
    // remove a list item from MMC

    varIndex.vt = VT_I4;

    for (varIndex.lVal = 1L; varIndex.lVal <= cListItems; varIndex.lVal++)
    {
        IfFailGo(InternalRemove(varIndex, DontRemoveFromCollection));
    }

    // Now call CSnapInCollection::Clear() to release the refs on all the
    // list items.

    hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::Clear();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IMMCListItems == riid)
    {
        *ppvObjOut = static_cast<IMMCListItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\localobj.h ===
//=--------------------------------------------------------------------------=
// localobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// This file is used by automation servers to delcare things that their objects
// need other parts of the server to see.
//
#ifndef _LOCALOBJECTS_H_

//=--------------------------------------------------------------------------=
// these constants are used in conjunction with the g_ObjectInfo table that
// each inproc server defines.  they are used to identify a given  object
// within the server.
//
// **** ADD ALL NEW OBJECTS TO THIS LIST ****
//

#define _LOCALOBJECTS_H_

#define OBJECT_TYPE_SNAPIN                  0
#define OBJECT_TYPE_SCOPEITEMS              1
#define OBJECT_TYPE_SNAPINDESIGNERDEF       2
#define OBJECT_TYPE_SNAPINDEF               3
#define OBJECT_TYPE_MMCMENU                 4
#define OBJECT_TYPE_MMCMENUDEFS             5
#define OBJECT_TYPE_EXTENSIONDEFS           6
#define OBJECT_TYPE_EXTENDEDSNAPINS         7
#define OBJECT_TYPE_EXTENDEDSNAPIN          8
#define OBJECT_TYPE_SCOPEITEMDEFS           9 
#define OBJECT_TYPE_SCOPEITEMDEF            10
#define OBJECT_TYPE_VIEWDEFS                11
#define OBJECT_TYPE_LISTVIEWDEFS            12
#define OBJECT_TYPE_LISTVIEWDEF             13
#define OBJECT_TYPE_MMCLISTVIEW             14
#define OBJECT_TYPE_MMCLISTITEMS            15
#define OBJECT_TYPE_MMCLISTITEM             16
#define OBJECT_TYPE_MMCLISTSUBITEMS         17
#define OBJECT_TYPE_MMCLISTSUBITEM          18
#define OBJECT_TYPE_MMCCOLUMNHEADERS        19
#define OBJECT_TYPE_MMCCOLUMNHEADER         20
#define OBJECT_TYPE_MMCIMAGELISTS           21
#define OBJECT_TYPE_MMCIMAGELIST            22
#define OBJECT_TYPE_MMCIMAGES               23
#define OBJECT_TYPE_MMCIMAGE                24
#define OBJECT_TYPE_MMCTOOLBARS             25
#define OBJECT_TYPE_MMCTOOLBAR              26
#define OBJECT_TYPE_OCXVIEWDEFS             27
#define OBJECT_TYPE_OCXVIEWDEF              28
#define OBJECT_TYPE_URLVIEWDEFS             29
#define OBJECT_TYPE_URLVIEWDEF              30
#define OBJECT_TYPE_TASKPADVIEWDEFS         31
#define OBJECT_TYPE_TASKPADVIEWDEF          32
#define OBJECT_TYPE_MMCBUTTONS              33
#define OBJECT_TYPE_MMCBUTTON               34
#define OBJECT_TYPE_MMCBUTTONMENUS          35
#define OBJECT_TYPE_MMCBUTTONMENU           36
#define OBJECT_TYPE_TASKPAD                 37
#define OBJECT_TYPE_TASKS                   38
#define OBJECT_TYPE_TASK                    39
#define OBJECT_TYPE_MMCDATAOBJECT           40
#define OBJECT_TYPE_NODETYPES               41
#define OBJECT_TYPE_NODETYPE                42
#define OBJECT_TYPE_REGINFO                 43
#define OBJECT_TYPE_VIEWS                   44
#define OBJECT_TYPE_VIEW                    45
#define OBJECT_TYPE_SCOPEITEM               46
#define OBJECT_TYPE_SCOPENODE               47
#define OBJECT_TYPE_SCOPEPANEITEMS          48
#define OBJECT_TYPE_SCOPEPANEITEM           49
#define OBJECT_TYPE_RESULTVIEWS             50
#define OBJECT_TYPE_RESULTVIEW              51
#define OBJECT_TYPE_EXTENSIONSNAPIN         52
#define OBJECT_TYPE_MMCCLIPBOARD            53
#define OBJECT_TYPE_MMCDATAOBJECTS          54
#define OBJECT_TYPE_MMCMENUDEF              55
#define OBJECT_TYPE_CONTEXTMENU             56
#define OBJECT_TYPE_DATAFORMAT              57
#define OBJECT_TYPE_DATAFORMATS             58
#define OBJECT_TYPE_MMCCONSOLEVERB          59
#define OBJECT_TYPE_MMCCONSOLEVERBS         60
#define OBJECT_TYPE_PROPERTYSHEET           61
#define OBJECT_TYPE_PROPERTYPAGEWRAPPER     62
#define OBJECT_TYPE_ENUM_TASK               63
#define OBJECT_TYPE_CONTROLBAR              64
#define OBJECT_TYPE_EXTENSIONS              65
#define OBJECT_TYPE_EXTENSION               66
#define OBJECT_TYPE_STRINGTABLE             67
#define OBJECT_TYPE_ENUMSTRINGTABLE         68
#define OBJECT_TYPE_CONTEXTMENUPROVIDER     69
#define OBJECT_TYPE_PROPERTYSHEETPROVIDER   70
#define OBJECT_TYPE_MMCMENUS                71
#define OBJECT_TYPE_MESSAGEVIEW             72
#define OBJECT_TYPE_COLUMNSETTINGS          73
#define OBJECT_TYPE_COLUMNSETTING           74
#define OBJECT_TYPE_SORTKEYS                75
#define OBJECT_TYPE_SORTKEY                 76
#define OBJECT_TYPE_SNAPINDATA              77
#endif // _LOCALOBJECTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listview.h ===
//=--------------------------------------------------------------------------=
// listview.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListView class definition - implements MMCListView object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTVIEW_DEFINED_
#define _LISTVIEW_DEFINED_

#include "resview.h"
#include "view.h"
#include "colhdrs.h"

class CResultView;
class CView;
class CMMCColumnHeaders;

class CMMCListView : public CSnapInAutomationObject,
                     public CPersistence,
                     public IMMCListView
{
    private:
        CMMCListView(IUnknown *punkOuter);
        ~CMMCListView();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListView

        COCLASS_PROPERTY_RW(CMMCListView, ColumnHeaders, MMCColumnHeaders, IMMCColumnHeaders, DISPID_LISTVIEW_COLUMN_HEADERS);

        STDMETHOD(get_Icons)(MMCImageList **ppMMCImageList);
        STDMETHOD(putref_Icons)(MMCImageList *pMMCImageList);

        STDMETHOD(get_SmallIcons)(MMCImageList **ppMMCImageList);
        STDMETHOD(putref_SmallIcons)(MMCImageList *pMMCImageList);

        COCLASS_PROPERTY_RO(CMMCListView, ListItems, MMCListItems, IMMCListItems, DISPID_LISTVIEW_LIST_ITEMS);

        STDMETHOD(get_SelectedItems)(MMCClipboard **ppMMCClipboard);

        STDMETHOD(get_Sorted)(VARIANT_BOOL *pfvarSorted);
        STDMETHOD(put_Sorted)(VARIANT_BOOL fvarSorted);
        
        STDMETHOD(get_SortKey)(short *psSortKey);
        STDMETHOD(put_SortKey)(short sSortKey);

        STDMETHOD(get_SortIcon)(VARIANT_BOOL *pfvarSortIcon);
        STDMETHOD(put_SortIcon)(VARIANT_BOOL fvarSortIcon);

        STDMETHOD(get_SortOrder)(SnapInSortOrderConstants *pSortOrder);
        STDMETHOD(put_SortOrder)(SnapInSortOrderConstants SortOrder);

        STDMETHOD(get_View)(SnapInViewModeConstants *pView);
        STDMETHOD(put_View)(SnapInViewModeConstants View);

        SIMPLE_PROPERTY_RW(CMMCListView, Virtual, VARIANT_BOOL, DISPID_LISTVIEW_VIRTUAL);
        SIMPLE_PROPERTY_RW(CMMCListView, UseFontLinking, VARIANT_BOOL, DISPID_LISTVIEW_USE_FONT_LINKING);
        SIMPLE_PROPERTY_RW(CMMCListView, MultiSelect, VARIANT_BOOL, DISPID_LISTVIEW_MULTI_SELECT);
        SIMPLE_PROPERTY_RW(CMMCListView, HideSelection, VARIANT_BOOL, DISPID_LISTVIEW_HIDE_SELECTION);
        SIMPLE_PROPERTY_RW(CMMCListView, SortHeader, VARIANT_BOOL, DISPID_LISTVIEW_SORT_HEADER);
        SIMPLE_PROPERTY_RW(CMMCListView, ShowChildScopeItems, VARIANT_BOOL, DISPID_LISTVIEW_SHOW_CHILD_SCOPEITEMS);
        SIMPLE_PROPERTY_RW(CMMCListView, LexicalSort, VARIANT_BOOL, DISPID_LISTVIEW_LEXICAL_SORT);

        STDMETHOD(put_FilterChangeTimeOut)(long lTimeout);
        STDMETHOD(get_FilterChangeTimeOut)(long *plTimeout);

        VARIANTREF_PROPERTY_RW(CMMCListView, Tag, DISPID_LISTVIEW_TAG);

        STDMETHOD(SetScopeItemState)(ScopeItem                    *ScopeItem, 
                                     SnapInListItemStateConstants  State,
                                     VARIANT_BOOL                  Value);


    // Public utility methods

        void SetResultView(CResultView *pResultView) { m_pResultView = pResultView; }
        CResultView *GetResultView() { return m_pResultView; }
        BOOL IsVirtual() { return VARIANTBOOL_TO_BOOL(m_Virtual); }
        void SetVirtual(BOOL fVirtual) { m_Virtual = BOOL_TO_VARIANTBOOL(fVirtual); }
        BOOL UseFontLinking() { return VARIANTBOOL_TO_BOOL(m_UseFontLinking); }
        void SetMultiSelect(BOOL fMultiSelect) { m_MultiSelect = BOOL_TO_VARIANTBOOL(fMultiSelect); }
        IMMCListItems *GetListItems() { return m_piListItems; }
        CMMCListItems *GetMMCListItems() { return m_pListItems; }
        SnapInViewModeConstants GetView() { return m_View; }
        BOOL MultiSelect() { return VARIANTBOOL_TO_BOOL(m_MultiSelect); }
        BOOL HideSelection() { return VARIANTBOOL_TO_BOOL(m_HideSelection); }
        BOOL SortHeader() { return VARIANTBOOL_TO_BOOL(m_SortHeader); }
        BOOL SortIcon() { return VARIANTBOOL_TO_BOOL(m_SortIcon); }
        BOOL ShowChildScopeItems() { return VARIANTBOOL_TO_BOOL(m_ShowChildScopeItems); }
        BOOL LexicalSort() { return VARIANTBOOL_TO_BOOL(m_LexicalSort); }
        BOOL Sorted() { return VARIANTBOOL_TO_BOOL(m_fvarSorted); }
        SnapInSortOrderConstants GetSortOrder() { return m_SortOrder; }
        short GetSortKey() { return m_sSortKey; }
        CMMCColumnHeaders *GetColumnHeaders() { return m_pMMCColumnHeaders; }
        long GetFilterChangeTimeout() { return m_lFilterChangeTimeout; }

    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        HRESULT GetIResultData(IResultData **ppiResultData, CView **ppView);

        // Variables that hold values of properties that have customer get/put
        // functions
        
        IMMCImageList           *m_piIcons;
        IMMCImageList           *m_piSmallIcons;
        IMMCListItems           *m_piSelectedItems;
        CMMCListItems           *m_pListItems;
        VARIANT_BOOL             m_fvarSorted;
        SnapInViewModeConstants  m_View;
        BSTR                     m_bstrIconsKey;
        BSTR                     m_bstrSmallIconsKey;
        CResultView             *m_pResultView;
        CMMCColumnHeaders       *m_pMMCColumnHeaders;
        short                    m_sSortKey;
        long                     m_lFilterChangeTimeout;
        BOOL                     m_fHaveFilterChangeTimeout;
        SnapInSortOrderConstants m_SortOrder;
        VARIANT_BOOL             m_SortIcon;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListView,           // name
                                &CLSID_MMCListView,    // clsid
                                "MMCListView",         // objname
                                "MMCListView",         // lblname
                                &CMMCListView::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IMMCListView,     // dispatch IID
                                NULL,                  // event IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _LISTVIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitms.h ===
//=--------------------------------------------------------------------------=
// listitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItems class definition - implements MMCListItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _LISTITEMS_DEFINED_
#define _LISTITEMS_DEFINED_

#include "collect.h"
#include "listview.h"
#include "view.h"

class CView;
class CMMCListView;

class CMMCListItems : public CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>
{
    protected:
        CMMCListItems(IUnknown *punkOuter);
        ~CMMCListItems();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListItems
        STDMETHOD(SetItemCount)(long Count, VARIANT Repaint, VARIANT Scroll);
        STDMETHOD(Add)(VARIANT       Index,
                       VARIANT       Key, 
                       VARIANT       Text,
                       VARIANT       Icon,
                       MMCListItem **ppMMCListItem);
        STDMETHOD(get_Item)(VARIANT Index, MMCListItem **ppMMCListItem);
        STDMETHOD(Remove)(VARIANT Index);
        STDMETHOD(Clear)();


    // Public utility methods

    public:

        HRESULT SetListView(CMMCListView *pMMCListView);
        CMMCListView *GetListView() { return m_pMMCListView; }
        LONG GetID() { return m_ID; }

        HRESULT GetIResultData(IResultData **ppiResultData, CView **ppView);

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT InitializeListItem(CMMCListItem *pMMCListItem);

        enum RemovalOption { RemoveFromCollection, DontRemoveFromCollection };
        HRESULT InternalRemove(VARIANT Index, RemovalOption Option);

        long          m_lCount;       // Count of items in virtual lists only

        LONG          m_ID;           // Unique number assigned to every
                                      // CMMCListItems object. Used by orphaned
                                      // list items to identify their parent
                                      // collections. See
                                      // CMMCListItem::GetIResultData in
                                      // listitem.cpp

        static LONG   m_NextID;       // Unique numbers generated from here.

        CMMCListView *m_pMMCListView; // Back pointer to owning list view

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListItems,           // name
                                &CLSID_MMCListItems,    // clsid
                                "MMCListItems",         // objname
                                "MMCListItems",         // lblname
                                &CMMCListItems::Create, // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCListItems,     // dispatch IID
                                NULL,                   // no events IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _LISTITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listview.cpp ===
//=--------------------------------------------------------------------------=
// listview.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListView class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "listview.h"
#include "colhdrs.h"
#include "colhdr.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListView::CMMCListView(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCLISTVIEW,
                            static_cast<IMMCListView *>(this),
                            static_cast<CMMCListView *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCListView,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListView::~CMMCListView()
{
    RELEASE(m_piColumnHeaders);
    RELEASE(m_piIcons);
    RELEASE(m_piSmallIcons);
    if (NULL != m_pListItems)
    {
        (void)m_pListItems->SetListView(NULL);
    }
    RELEASE(m_piListItems);
    RELEASE(m_piSelectedItems);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrIconsKey);
    FREESTRING(m_bstrSmallIconsKey);
    InitMemberVariables();
    m_pMMCColumnHeaders = NULL;
}

void CMMCListView::InitMemberVariables()
{
    m_piColumnHeaders = NULL;
    m_piIcons = NULL;
    m_piSmallIcons = NULL;
    m_piListItems = NULL;
    m_pListItems = NULL;
    m_piSelectedItems = NULL;
    m_fvarSorted = VARIANT_FALSE;
    m_sSortKey = 1;
    m_SortOrder = siAscending;
    m_View = siIcon;
    m_Virtual = VARIANT_FALSE;
    m_UseFontLinking = VARIANT_FALSE;
    m_MultiSelect = VARIANT_FALSE;
    m_HideSelection = VARIANT_FALSE;
    m_SortHeader = VARIANT_TRUE;
    m_SortIcon = VARIANT_TRUE;
    m_ShowChildScopeItems = VARIANT_TRUE;
    m_LexicalSort = VARIANT_FALSE;
    m_lFilterChangeTimeout = DEFAULT_FILTER_CHANGE_TIMEOUT;

    ::VariantInit(&m_varTag);

    m_bstrIconsKey = NULL;
    m_bstrSmallIconsKey = NULL;
    m_pResultView = NULL;
}

IUnknown *CMMCListView::Create(IUnknown * punkOuter)
{
    HRESULT            hr = S_OK;
    CMMCListView      *pMMCListView = New CMMCListView(punkOuter);

    if (NULL == pMMCListView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Create all non-persisted objects that are not created during InitNew

    IfFailGo(CreateObject(OBJECT_TYPE_MMCLISTITEMS,
                          IID_IMMCListItems, &pMMCListView->m_piListItems));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pMMCListView->m_piListItems,
                                                 &pMMCListView->m_pListItems));
    IfFailGo(pMMCListView->m_pListItems->SetListView(pMMCListView));

    IfFailGo(CreateObject(OBJECT_TYPE_MMCLISTITEMS,
                          IID_IMMCListItems, &pMMCListView->m_piSelectedItems));

    // Need to create column headers even though it is persisted because
    // a new MMCListView created at runtime will not have InitNew called.
    // If InitNew is later called then the column headers collection created
    // here will be released.

    IfFailGo(CreateObject(OBJECT_TYPE_MMCCOLUMNHEADERS,
                      IID_IMMCColumnHeaders, &pMMCListView->m_piColumnHeaders));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pMMCListView->m_piColumnHeaders,
                                                   &pMMCListView->m_pMMCColumnHeaders));
    pMMCListView->m_pMMCColumnHeaders->SetListView(pMMCListView);

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCListView)
        {
            delete pMMCListView;
        }
        return NULL;
    }
    else
    {
        return pMMCListView->PrivateUnknown();
    }
}




//=--------------------------------------------------------------------------=
// CMMCListView::GetIResultData
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IResultData **ppiResultData [out] Owning View's IResultData returned here
//   IDataObject **ppiDataObject [out] Owning View returned here if non-NULL
//
// Output:
//
// Notes:
//
// As we are only a lowly listview and the IResultData pointer we need
// to set our selection state is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated listview created
// by the user or if any object up the hierarchy is isolated then we
// will return an error. Returned IResultData pointer is NOT AddRef()ed.


HRESULT CMMCListView::GetIResultData
(
     IResultData **ppiResultData,
     CView       **ppView
)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pResultView, hr);

    pScopePaneItem = m_pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    *ppiResultData = pView->GetIResultData();
    IfFalseGo(NULL != *ppiResultData, hr);

    if (NULL != ppView)
    {
        *ppView = pView;
    }

    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                       IMMCListView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCListView::get_Icons(MMCImageList **ppMMCImageList)
{
    RRETURN(GetImages(reinterpret_cast<IMMCImageList **>(ppMMCImageList),
                      m_bstrIconsKey, &m_piIcons));
}


STDMETHODIMP CMMCListView::putref_Icons(MMCImageList *pMMCImageList)
{
    RRETURN(SetImages(reinterpret_cast<IMMCImageList *>(pMMCImageList),
                      &m_bstrIconsKey, &m_piIcons));
}



STDMETHODIMP CMMCListView::get_SmallIcons(MMCImageList **ppMMCImageList)
{
    RRETURN(GetImages(reinterpret_cast<IMMCImageList **>(ppMMCImageList),
                      m_bstrSmallIconsKey, &m_piSmallIcons));
}


STDMETHODIMP CMMCListView::putref_SmallIcons(MMCImageList *pMMCImageList)
{
    RRETURN(SetImages(reinterpret_cast<IMMCImageList *>(pMMCImageList),
                      &m_bstrSmallIconsKey, &m_piSmallIcons));
}


STDMETHODIMP CMMCListView::get_SelectedItems(MMCClipboard **ppMMCClipboard)
{
    HRESULT      hr = S_OK;
    CView       *pView = NULL;
    IResultData *piResultData = NULL; // Not AddRef()ed

    if (NULL == ppMMCClipboard)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetIResultData(&piResultData, &pView);

    if (SUCCEEDED(hr))
    {
        // If we are in the middle of ResultViews_Activate then there are no
        // selected items yet so return an empty collection.

        IfFalseGo(!m_pResultView->InActivate(), S_OK);
    }
    else
    {
        // If this is a detached object then just return an empty collection
        IfFalseGo(SID_E_DETACHED_OBJECT != hr, S_OK);

        // Otherwise return the error
        IfFailGo(hr);
    }

    // OK, this is a live listview and we can examine it in MMC.

    IfFailGo(pView->GetCurrentListViewSelection(
                     reinterpret_cast<IMMCClipboard **>(ppMMCClipboard), NULL));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::get_Sorted(VARIANT_BOOL *pfvarSorted)
{
    HRESULT            hr = S_OK;

    if (NULL == pfvarSorted)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarSorted = m_fvarSorted;


Error:
    RRETURN(hr);
}

STDMETHODIMP CMMCListView::put_Sorted(VARIANT_BOOL fvarSorted)
{
    HRESULT            hr = S_OK;
    IResultData       *piResultData = NULL; // not AddRef()ed
    DWORD              dwSortOptions = 0;

    m_fvarSorted = fvarSorted;

    // If we are not sorting then there is nothing to do.
    IfFalseGo(VARIANT_TRUE == fvarSorted, S_OK);

    IfFailGo(GetIResultData(&piResultData, NULL));

    // If we are attached to a live result view and not currently in the middle
    // of a ResultViews_Activate event then ask MMC to sort.
    // If we are in ResultViews_Activate then our local property value will
    // be set and MMC's will be asked to sort after
    // the event completes. See CView::OnShow() and CView::PopulateListView()
    // in view.cpp.

    IfFalseGo(NULL != piResultData, S_OK);

    IfFalseGo(!m_pResultView->InActivate(), S_OK);

    if (siDescending == m_SortOrder)
    {
        dwSortOptions = RSI_DESCENDING;
    }

    if (VARIANT_FALSE == m_SortIcon)
    {
        dwSortOptions |= RSI_NOSORTICON;
    }

    // Ask MMC to sort. Pass zero as user param because we don't
    // need it.
    // Adjust the sort key to zero based

    hr = piResultData->Sort(static_cast<int>(m_sSortKey - 1),
                            dwSortOptions, 0);
    if (FAILED(hr))
    {
        m_fvarSorted = VARIANT_FALSE;
    }
    EXCEPTION_CHECK_GO(hr);

Error:

    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::put_SortKey(short sSortKey)
{
    RRETURN(SetSimpleType(sSortKey, &m_sSortKey, DISPID_LISTVIEW_SORT_KEY));
}


STDMETHODIMP CMMCListView::get_SortKey(short *psSortKey)
{
    HRESULT            hr = S_OK;

    if (NULL == psSortKey)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *psSortKey = m_sSortKey;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::put_SortOrder(SnapInSortOrderConstants SortOrder)
{
    RRETURN(SetSimpleType(SortOrder, &m_SortOrder, DISPID_LISTVIEW_SORT_ORDER));
}


STDMETHODIMP CMMCListView::get_SortOrder(SnapInSortOrderConstants *pSortOrder)
{
    HRESULT            hr = S_OK;

    if (NULL == pSortOrder)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pSortOrder = m_SortOrder;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::put_SortIcon(VARIANT_BOOL fvarSortIcon)
{
    RRETURN(SetSimpleType(fvarSortIcon, &m_SortIcon, DISPID_LISTVIEW_SORT_ICON));
}


STDMETHODIMP CMMCListView::get_SortIcon(VARIANT_BOOL *pfvarSortIcon)
{
    HRESULT            hr = S_OK;

    if (NULL == pfvarSortIcon)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarSortIcon = m_SortIcon;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::get_View(SnapInViewModeConstants *pView)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    long         MMCViewMode = MMCLV_VIEWSTYLE_ICON;

    *pView = m_View;

    // If we are attached to a live result view and not currently in the middle
    // of a ResultViews_Activate event then ask MMC for the view mode.

    hr = GetIResultData(&piResultData, NULL);

    if (SUCCEEDED(hr))
    {
        if ( (!m_pResultView->InInitialize()) && (!m_pResultView->InActivate()) )
        {
            hr = piResultData->GetViewMode(&MMCViewMode);
            EXCEPTION_CHECK_GO(hr);

            // Convert and record the view mode from MMC. Return it to caller.

            ::MMCViewModeToVBViewMode(MMCViewMode, &m_View);

            *pView = m_View;
        }
    }
    else if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    else
    {
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}

STDMETHODIMP CMMCListView::put_View(SnapInViewModeConstants View)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    long         MMCViewMode = MMCLV_VIEWSTYLE_ICON;

    // Convert to an MMC view mode contant

    ::VBViewModeToMMCViewMode(View, &MMCViewMode);

    // If we are attached to a live result view and not currently in the middle
    // of a ResultViews_Activate event then ask MMC to change the view mode.
    // If we are in ResultViews_Activate then our local property value will
    // be set and MMC's view mode will be changed using this value after
    // the event completes. See CView::OnShow() and CView::PopulateListView()
    // in view.cpp.

    hr = GetIResultData(&piResultData, NULL);

    if (SUCCEEDED(hr))
    {
        // If MMC >= 1.2 then we can use a filtered view, otherwise return an
        // error. This long gnarly statement will work because GetIResultData
        // succeeded meaning that everyone has backpointers all the way up
        // the hierarchy to the owning view.

        if ( (siFiltered == View) &&
             (NULL == m_pResultView->GetScopePaneItem()->GetParent()->GetParentView()->GetIColumnData())
           )
        {
            hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
            EXCEPTION_CHECK_GO(hr);
        }

        if ( (!m_pResultView->InInitialize()) && (!m_pResultView->InActivate()) )
        {
            hr = piResultData->SetViewMode(MMCViewMode);
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    else
    {
        IfFailGo(hr);
    }

    // Change was successful. Record the new view mode so a get on
    // MMCListView.View will return correct information.
    
    m_View = View;

Error:
    RRETURN(hr);
}




STDMETHODIMP CMMCListView::put_FilterChangeTimeOut(long lTimeout)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed

    // Set the property value.

    IfFailGo(SetSimpleType(lTimeout, &m_lFilterChangeTimeout, DISPID_LISTVIEW_FILTER_CHANGE_TIMEOUT));

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    hr = piHeaderCtrl2->SetChangeTimeOut(lTimeout);
    EXCEPTION_CHECK_GO(hr);
    
Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

STDMETHODIMP CMMCListView::get_FilterChangeTimeOut(long *plTimeout)
{
    *plTimeout = m_lFilterChangeTimeout;

    return S_OK;
}

STDMETHODIMP CMMCListView::SetScopeItemState
(
    ScopeItem                    *ScopeItem, 
    SnapInListItemStateConstants  State,
    VARIANT_BOOL                  Value
)
{
    HRESULT      hr = S_OK;
    CScopeItem  *pScopeItem = NULL;
    BOOL         fFound = FALSE;
    int          nState = 0;
    IResultData *piResultData = NULL; // Not AddRef()ed

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    if (NULL == ScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If this is a virtual list view then there are no child scope items

    if (VARIANT_TRUE == m_Virtual)
    {
        hr = SID_E_NO_SCOPEITEMS_IN_VIRTUAL_LIST;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are not connected to a live list view then return an error

    if (FAILED(GetIResultData(&piResultData, NULL)))
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Find the scope item in the list view

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                      reinterpret_cast<IScopeItem *>(ScopeItem),
                                      &pScopeItem));

    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;

    hr = piResultData->GetNextItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    while ( (-1 != rdi.nIndex) && (!fFound) )
    {
        if ( (rdi.bScopeItem) &&
             (rdi.lParam == reinterpret_cast<LPARAM>(pScopeItem)) )
        {
            fFound = TRUE;
        }
        else
        {
            hr = piResultData->GetNextItem(&rdi);
            EXCEPTION_CHECK_GO(hr);
        }
    }

    if (!fFound)
    {
        hr = SID_E_ELEMENT_NOT_FOUND;
        EXCEPTION_CHECK_GO(hr);
    }

    switch (State)
    {
        case siSelected:
            nState = LVIS_SELECTED;
            break;

        case siDropHilited:
            nState = LVIS_DROPHILITED;
            break;

        case siFocused:
            nState = LVIS_FOCUSED;
            break;

        case siCutHilited:
            nState = LVIS_CUT;
            break;

    }

    if (VARIANT_TRUE == Value)
    {
        rdi.nState |= nState;
    }
    else
    {
        rdi.nState &= ~nState;
    }
    
    hr = piResultData->SetItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListView::Persist()
{
    HRESULT            hr = S_OK;

    VARIANT varDefault;
    VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistObject(&m_piColumnHeaders, CLSID_MMCColumnHeaders,
                           OBJECT_TYPE_MMCCOLUMNHEADERS, IID_IMMCColumnHeaders,
                           OLESTR("ColumnHeaders")));

    // If this is an InitNew or load operation then the ColumnHeaders collection
    // was just created so set its back pointer to us.
    
    if ( InitNewing() || Loading() )
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piColumnHeaders,
                                                       &m_pMMCColumnHeaders));
        m_pMMCColumnHeaders->SetListView(this);
    }

    IfFailGo(PersistBstr(&m_bstrIconsKey, L"", OLESTR("Icons")));
    IfFailGo(PersistBstr(&m_bstrSmallIconsKey, L"", OLESTR("SmallIcons")));

    if (InitNewing())
    {
        RELEASE(m_piIcons);
        RELEASE(m_piSmallIcons);
    }

    IfFailGo(PersistSimpleType(&m_fvarSorted, VARIANT_FALSE, OLESTR("Sorted")));

    IfFailGo(PersistSimpleType(&m_sSortKey, (short)0, OLESTR("SortKey")));

    IfFailGo(PersistSimpleType(&m_SortOrder, siAscending, OLESTR("SortOrder")));

    IfFailGo(PersistSimpleType(&m_View, siIcon, OLESTR("View")));

    IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailGo(PersistSimpleType(&m_Virtual, VARIANT_FALSE, OLESTR("Virtual")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 7) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_UseFontLinking, VARIANT_FALSE, OLESTR("UseFontLinking")));
    }

    IfFailGo(PersistSimpleType(&m_MultiSelect, VARIANT_FALSE, OLESTR("MultiSelect")));

    IfFailGo(PersistSimpleType(&m_HideSelection, VARIANT_FALSE, OLESTR("HideSelection")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 10) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_SortHeader, VARIANT_TRUE, OLESTR("SortHeader")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 11) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_SortIcon, VARIANT_TRUE, OLESTR("SortIcon")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 5) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_lFilterChangeTimeout, DEFAULT_FILTER_CHANGE_TIMEOUT, OLESTR("FilterChangeTimeout")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 9) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_ShowChildScopeItems, VARIANT_TRUE, OLESTR("ShowChildScopeItems")));
        IfFailGo(PersistSimpleType(&m_LexicalSort, VARIANT_FALSE, OLESTR("LexicalSort")));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCListView == riid)
    {
        *ppvObjOut = static_cast<IMMCListView *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitms.h ===
//=--------------------------------------------------------------------------=
// lsubitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItems class definition - implements MMCListSubItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _LISTSUBITEMS_DEFINED_
#define _LISTSUBITEMS_DEFINED_

#include "collect.h"

class CMMCListSubItems :
    public CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>,
    public CPersistence
{
    protected:
        CMMCListSubItems(IUnknown *punkOuter);
        ~CMMCListSubItems();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListSubItems
        STDMETHOD(Add)(VARIANT         Index,
                       VARIANT         Key, 
                       VARIANT         Text,
                       MMCListSubItem **ppMMCListSubItem);


    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListSubItems,           // name
                                &CLSID_MMCListSubItems,    // clsid
                                "MMCListSubItems",         // objname
                                "MMCListSubItems",         // lblname
                                &CMMCListSubItems::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IMMCListSubItems,     // dispatch IID
                                NULL,                      // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _LISTSUBITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitem.cpp ===
//=--------------------------------------------------------------------------=
// lsubitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lsubitem.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListSubItem::CMMCListSubItem(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCLISTSUBITEM,
                            static_cast<IMMCListSubItem *>(this),
                            static_cast<CMMCListSubItem *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_MMCListSubItem,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListSubItem::~CMMCListSubItem()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    InitMemberVariables();
}

void CMMCListSubItem::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
}

IUnknown *CMMCListSubItem::Create(IUnknown * punkOuter)
{
    CMMCListSubItem *pMMCListSubItem = New CMMCListSubItem(punkOuter);
    if (NULL == pMMCListSubItem)
    {
        return NULL;
    }
    else
    {
        return pMMCListSubItem->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItem::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailGo(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCListSubItem == riid)
    {
        *ppvObjOut = static_cast<IMMCListSubItem *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitms.cpp ===
//=--------------------------------------------------------------------------=
// lsubitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lsubitms.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListSubItems::CMMCListSubItems(IUnknown *punkOuter) :
    CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>(
                      punkOuter,
                      OBJECT_TYPE_MMCLISTSUBITEMS,
                      static_cast<IMMCListSubItems *>(this),
                      static_cast<CMMCListSubItems *>(this),
                      CLSID_MMCListSubItem,
                      OBJECT_TYPE_MMCLISTSUBITEM,
                      IID_IMMCListSubItem,
                      static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_MMCListSubItems,
                g_dwVerMajor,
                g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListSubItems::~CMMCListSubItems()
{
}

IUnknown *CMMCListSubItems::Create(IUnknown * punkOuter)
{
    CMMCListSubItems *pMMCListSubItems = New CMMCListSubItems(punkOuter);
    if (NULL == pMMCListSubItems)
    {
        return NULL;
    }
    else
    {
        return pMMCListSubItems->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      IMMCListSubItems Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCListSubItems::Add
(
    VARIANT          Index,
    VARIANT          Key, 
    VARIANT          Text,
    MMCListSubItem **ppMMCListSubItem
)
{
    HRESULT hr = S_OK;
    VARIANT varText;
    ::VariantInit(&varText);
    IMMCListSubItem *piMMCListSubItem = NULL;

    hr = CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>::Add(Index, Key, &piMMCListSubItem);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varText, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCListSubItem->put_Text(varText.bstrVal));
    }

    *ppMMCListSubItem = reinterpret_cast<MMCListSubItem *>(piMMCListSubItem);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCListSubItem);
    }
    (void)::VariantClear(&varText);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItems::Persist()
{
    HRESULT         hr = S_OK;
    IMMCListSubItem  *piMMCListSubItem = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>::Persist(piMMCListSubItem);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCListSubItems == riid)
    {
        *ppvObjOut = static_cast<IMMCListSubItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitem.h ===
//=--------------------------------------------------------------------------=
// lsubitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItem class definition - implements MMCListSubItem object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTSUBITEM_DEFINED_
#define _LISTSUBITEM_DEFINED_


class CMMCListSubItem : public CSnapInAutomationObject,
                        public CPersistence,
                        public IMMCListSubItem
{
    private:
        CMMCListSubItem(IUnknown *punkOuter);
        ~CMMCListSubItem();
    
    public:
        static IUnknown *Create(IUnknown * punk);
        LPOLESTR GetTextPtr() { return static_cast<LPOLESTR>(m_bstrText); }

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListSubItem

        SIMPLE_PROPERTY_RW(CMMCListSubItem,     Index, long, DISPID_LISTSUBITEM_INDEX);
        BSTR_PROPERTY_RW(CMMCListSubItem,       Key, DISPID_LISTSUBITEM_KEY);
        VARIANTREF_PROPERTY_RW(CMMCListSubItem, Tag, DISPID_LISTSUBITEM_TAG);
        BSTR_PROPERTY_RW(CMMCListSubItem,       Text, DISPID_LISTSUBITEM_TEXT);
      
    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListSubItem,           // name
                                &CLSID_MMCListSubItem,    // clsid
                                "MMCListSubItem",         // objname
                                "MMCListSubItem",         // lblname
                                &CMMCListSubItem::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCListSubItem,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _LISTSUBITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdef.h ===
//=--------------------------------------------------------------------------=
// lvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTVIEWDEF_DEFINED_
#define _LISTVIEWDEF_DEFINED_


class CListViewDef : public CSnapInAutomationObject,
                     public CPersistence,
                     public IListViewDef,
                     public IPropertyNotifySink
{
    private:
        CListViewDef(IUnknown *punkOuter);
        ~CListViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IListViewDef

    // This object uses the X_PROPERTY_RW macros to expose properties of its
    // contained ListViewDef.ListView object as its own properties. That allows
    // the user to change ListViewDef.ListView properties in the list view 
    // property pages. The final argumentto the X_PROPERTY_RW macro is the contained
    // object that really exposes the property. In this case that is ListView.
    // See siautobj.h for the definition of X_PROPERTY_RW.

        BSTR_PROPERTY_RW(CListViewDef,   Name,  DISPID_LISTVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(CListViewDef, Index, long, DISPID_LISTVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(CListViewDef,   Key, DISPID_LISTVIEWDEF_KEY);
        X_PROPERTY_RW(CListViewDef,      Tag, VARIANT, DISPID_LISTVIEWDEF_TAG, ListView);
        SIMPLE_PROPERTY_RW(CListViewDef, AddToViewMenu, VARIANT_BOOL, DISPID_LISTVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CListViewDef,   ViewMenuText, DISPID_LISTVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(CListViewDef,   ViewMenuStatusBarText, DISPID_LISTVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        BSTR_PROPERTY_RW(CListViewDef,   DefaultItemTypeGUID, DISPID_LISTVIEWDEF_DEFAULT_ITEM_TYPE_GUID);
        SIMPLE_PROPERTY_RW(CListViewDef, Extensible,  VARIANT_BOOL, DISPID_LISTVIEWDEF_EXTENSIBLE);
        X_PROPERTY_RW(CListViewDef,      MultiSelect, VARIANT_BOOL, DISPID_LISTVIEWDEF_MULTI_SELECT, ListView);
        X_PROPERTY_RW(CListViewDef,      HideSelection, VARIANT_BOOL, DISPID_LISTVIEWDEF_HIDE_SELECTION, ListView);
        X_PROPERTY_RW(CListViewDef,      SortHeader, VARIANT_BOOL, DISPID_LISTVIEWDEF_SORT_HEADER, ListView);
        X_PROPERTY_RW(CListViewDef,      SortIcon, VARIANT_BOOL, DISPID_LISTVIEWDEF_SORT_ICON, ListView);
        X_PROPERTY_RW(CListViewDef,      Sorted, VARIANT_BOOL, DISPID_LISTVIEWDEF_SORTED, ListView);
        X_PROPERTY_RW(CListViewDef,      SortKey, short, DISPID_LISTVIEWDEF_SORT_KEY, ListView);
        X_PROPERTY_RW(CListViewDef,      SortOrder, SnapInSortOrderConstants, DISPID_LISTVIEWDEF_SORT_ORDER, ListView);
        X_PROPERTY_RW(CListViewDef,      View, SnapInViewModeConstants, DISPID_LISTVIEWDEF_VIEW, ListView);
        X_PROPERTY_RW(CListViewDef,      Virtual, VARIANT_BOOL, DISPID_LISTVIEWDEF_VIRTUAL, ListView);
        X_PROPERTY_RW(CListViewDef,      UseFontLinking, VARIANT_BOOL, DISPID_LISTVIEWDEF_USE_FONT_LINKING, ListView);
        X_PROPERTY_RW(CListViewDef,      FilterChangeTimeOut, long, DISPID_LISTVIEWDEF_FILTER_CHANGE_TIMEOUT, ListView);
        X_PROPERTY_RW(CListViewDef,      ShowChildScopeItems, VARIANT_BOOL, DISPID_LISTVIEWDEF_SHOW_CHILD_SCOPEITEMS, ListView);
        X_PROPERTY_RW(CListViewDef,      LexicalSort, VARIANT_BOOL, DISPID_LISTVIEWDEF_LEXICAL_SORT, ListView);
        OBJECT_PROPERTY_RO(CListViewDef, ListView, IMMCListView, DISPID_LISTVIEWDEF_LISTVIEW);

    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        BOOL Extensible() { return VARIANTBOOL_TO_BOOL(m_Extensible); }
        BSTR GetItemTypeGUID() { return m_bstrDefaultItemTypeGUID; }

    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

    // IPropertyNotifySink methods
        STDMETHOD(OnChanged)(DISPID dispID);
        STDMETHOD(OnRequestEdit)(DISPID dispID);

        void InitMemberVariables();
        HRESULT SetSink();
        HRESULT RemoveSink();

        DWORD    m_dwCookie;   // IConnectionPoint advise cookie
        BOOL     m_fHaveSink;  // TRUE=have IConnectionPoint advise

        // Proeprty page CLSIDs for ISpecifyPropertyPages

        static const GUID *m_rgpPropertyPageCLSIDs[4];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ListViewDef,           // name
                                &CLSID_ListViewDef,    // clsid
                                "ListViewDef",         // objname
                                "ListViewDef",         // lblname
                                &CListViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IListViewDef,     // dispatch IID
                                NULL,                  // event IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _LISTVIEWDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdefs.cpp ===
//=--------------------------------------------------------------------------=
// lvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CListViewDefs::CListViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>(
                                             punkOuter,
                                             OBJECT_TYPE_LISTVIEWDEFS,
                                             static_cast<IListViewDefs *>(this),
                                             static_cast<CListViewDefs *>(this),
                                             CLSID_ListViewDef,
                                             OBJECT_TYPE_LISTVIEWDEF,
                                             IID_IListViewDef,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ListViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CListViewDefs::~CListViewDefs()
{
}

IUnknown *CListViewDefs::Create(IUnknown * punkOuter)
{
    CListViewDefs *pListViewDefs = New CListViewDefs(punkOuter);
    if (NULL == pListViewDefs)
    {
        return NULL;
    }
    else
    {
        return pListViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDefs::Persist()
{
    HRESULT   hr = S_OK;
    IListViewDef *piListViewDef = NULL;

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>::Persist(piListViewDef);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IListViewDefs == riid)
    {
        *ppvObjOut = static_cast<IListViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>::GetMaster(IListViewDefs **ppiMasterListViewDefs)
{
    RRETURN(GetListViewDefs(ppiMasterListViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdefs.h ===
//=--------------------------------------------------------------------------=
// lvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTVIEWDEFS_DEFINED_
#define _LISTVIEWDEFS_DEFINED_

#define MASTER_COLLECTION
#include "collect.h"

class CListViewDefs : public CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>,
                      public CPersistence
{
    protected:
        CListViewDefs(IUnknown *punkOuter);
        ~CListViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT GetMaster(IListViewDefs **ppiMasterListViewDefs);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ListViewDefs,           // name
                                &CLSID_ListViewDefs,    // clsid
                                "ListViewDefs",         // objname
                                "ListViewDefs",         // lblname
                                &CListViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IListViewDefs,     // dispatch IID
                                NULL,                   // no events IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _LISTVIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdef.cpp ===
//=--------------------------------------------------------------------------=
// lvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CListViewDef::m_rgpPropertyPageCLSIDs[4] =
{ &CLSID_ListViewDefGeneralPP,
  &CLSID_ListViewDefImgLstsPP,
  &CLSID_ListViewDefSortingPP,
  &CLSID_ListViewDefColHdrsPP
};


#pragma warning(disable:4355)  // using 'this' in constructor

CListViewDef::CListViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_LISTVIEWDEF,
                            static_cast<IListViewDef *>(this),
                            static_cast<CListViewDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ListViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CListViewDef::~CListViewDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    FREESTRING(m_bstrDefaultItemTypeGUID);
    (void)RemoveSink();
    RELEASE(m_piListView);
    InitMemberVariables();
}

void CListViewDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrName = NULL;
    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_bstrDefaultItemTypeGUID = NULL;
    m_Extensible = VARIANT_TRUE;
    m_piListView = NULL;
    m_dwCookie = 0;
    m_fHaveSink = FALSE;
}

IUnknown *CListViewDef::Create(IUnknown * punkOuter)
{
    HRESULT       hr = S_OK;
    CListViewDef *pListViewDef = New CListViewDef(punkOuter);

    if (NULL == pListViewDef)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pListViewDef)
        {
            delete pListViewDef;
        }
        return NULL;
    }
    else
    {
        return pListViewDef->PrivateUnknown();
    }
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDef::Persist()
{
    HRESULT  hr = S_OK;
    BSTR     bstrNewGUID = NULL;
    WCHAR    wszNewGUID[64] = L"";
    GUID     guidNew = GUID_NULL;

    if (InitNewing())
    {
        hr = ::CoCreateGuid(&guidNew);
        EXCEPTION_CHECK_GO(hr);

        if (0 == ::StringFromGUID2(guidNew, wszNewGUID,
                                   sizeof(wszNewGUID) / sizeof(wszNewGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailGo(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailGo(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailGo(PersistBstr(&m_bstrDefaultItemTypeGUID, wszNewGUID, OLESTR("DefaultItemTypeGUID")));

    IfFailGo(PersistSimpleType(&m_Extensible, VARIANT_TRUE, OLESTR("Extensible")));

    IfFailGo(PersistObject(&m_piListView, CLSID_MMCListView,
                           OBJECT_TYPE_MMCLISTVIEW, IID_IMMCListView,
                           OLESTR("ListView")));

    // If InitNew then set advise on IPropertyNotifySink connection point so we
    // know when the listview's properties have been changed through its
    // property pages. Need to do
    // this to keep duplicate properties in sync.

    if (InitNewing())
    {
        IfFailGo(SetSink());
    }

Error:
    RRETURN(hr);
}


HRESULT CListViewDef::SetSink()
{
    HRESULT                    hr = S_OK;
    IConnectionPoint          *pCP = NULL;
    IConnectionPointContainer *pCPC = NULL;

    IfFailGo(RemoveSink());
    IfFailGo(m_piListView->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void**>(&pCPC)));
    IfFailGo(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
    IfFailGo(pCP->Advise(static_cast<IUnknown *>(static_cast<IPropertyNotifySink *>(this)), &m_dwCookie));
    m_fHaveSink = TRUE;

Error:
    QUICK_RELEASE(pCP);
    QUICK_RELEASE(pCPC);
    RRETURN(hr);
}

HRESULT CListViewDef::RemoveSink()
{
    HRESULT                    hr = S_OK;
    IConnectionPoint          *pCP = NULL;
    IConnectionPointContainer *pCPC = NULL;

    IfFalseGo(m_fHaveSink, S_OK);

    IfFailGo(m_piListView->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void**>(&pCPC)));
    IfFailGo(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
    IfFailGo(pCP->Unadvise(m_dwCookie));
    m_fHaveSink = FALSE;
    m_dwCookie = 0;

Error:
    QUICK_RELEASE(pCP);
    QUICK_RELEASE(pCPC);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IPropertyNotifySink Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CListViewDef::OnChanged(DISPID dispid)
{
    HRESULT hr = S_OK;

    // This method is called from the list view object when the user has
    // changed its properties by clicking Apply in the list view property
    // pages in the designer.
    //
    // For a given ListViewDef.ListView property that has changed, generate
    // a corresponding IPropertyNotifySink::OnChanged for this object. That
    // will cause the VB property browser to do a get on the property and
    // update its listbox.

    switch (dispid)
    {
        case DISPID_LISTVIEW_TAG:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_TAG);
            break;

        case DISPID_LISTVIEW_MULTI_SELECT:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_MULTI_SELECT);
            break;

        case DISPID_LISTVIEW_HIDE_SELECTION:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_HIDE_SELECTION);
            break;

        case DISPID_LISTVIEW_SORT_HEADER:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_HEADER);
            break;

        case DISPID_LISTVIEW_SORT_ICON:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_ICON);
            break;

        case DISPID_LISTVIEW_SORTED:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORTED);
            break;

        case DISPID_LISTVIEW_SORT_KEY:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_KEY);
            break;

        case DISPID_LISTVIEW_SORT_ORDER:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_ORDER);
            break;

        case DISPID_LISTVIEW_VIEW:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_VIEW);
            break;

        case DISPID_LISTVIEW_VIRTUAL:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_VIRTUAL);
            break;

        case DISPID_LISTVIEW_USE_FONT_LINKING:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_USE_FONT_LINKING);
            break;

        case DISPID_LISTVIEW_FILTER_CHANGE_TIMEOUT:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_FILTER_CHANGE_TIMEOUT);
            break;

        case DISPID_LISTVIEW_SHOW_CHILD_SCOPEITEMS:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SHOW_CHILD_SCOPEITEMS);
            break;

        case DISPID_LISTVIEW_LEXICAL_SORT:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_LEXICAL_SORT);
            break;
    }

    RRETURN(hr);
}

STDMETHODIMP CListViewDef::OnRequestEdit(DISPID dispid)
{
    return S_OK;
}



//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CListViewDef::OnSetHost                  [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
//
//

//=--------------------------------------------------------------------------=
// CListViewDef::OnSetHost                  [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// If the host is being removed the removes the IPropertyNotifySink on the
// contained listview. We do this here because otherwise our ref count would
// never hit zero. This will occur when we are about to be destroyed.
//
//

HRESULT CListViewDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piListView));
    if (NULL == GetHost())
    {
        hr = RemoveSink();
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPropertyNotifySink == riid)
    {
        *ppvObjOut = static_cast<IPropertyNotifySink *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IListViewDef == riid)
    {
        *ppvObjOut = static_cast<IListViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbutton.h ===
//=--------------------------------------------------------------------------=
// mbutton.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenu class definition - implements MMCButtonMenu object
//
//=--------------------------------------------------------------------------=

#ifndef _MBUTTON_DEFINED_
#define _MBUTTON_DEFINED_

#include "toolbar.h"

class CMMCButtonMenu : public CSnapInAutomationObject,
                       public CPersistence,
                       public IMMCButtonMenu
{
    private:
        CMMCButtonMenu(IUnknown *punkOuter);
        ~CMMCButtonMenu();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButtonMenu
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Enabled, VARIANT_BOOL, DISPID_BUTTONMENU_ENABLED);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Index, long, DISPID_BUTTONMENU_INDEX);
        BSTR_PROPERTY_RW(CMMCButtonMenu,       Key, DISPID_BUTTONMENU_KEY);
        COCLASS_PROPERTY_RO(CMMCButtonMenu,    Parent, MMCButton, IMMCButton, DISPID_BUTTONMENU_PARENT);
        OBJECT_PROPERTY_WO(CMMCButtonMenu,     Parent, IMMCButton, DISPID_BUTTONMENU_PARENT);
        VARIANTREF_PROPERTY_RW(CMMCButtonMenu, Tag, DISPID_BUTTONMENU_TAG);
        BSTR_PROPERTY_RW(CMMCButtonMenu,       Text, DISPID_BUTTONMENU_TEXT);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Visible, VARIANT_BOOL, DISPID_BUTTONMENU_VISIBLE);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Checked, VARIANT_BOOL, DISPID_BUTTONMENU_CHECKED);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Grayed, VARIANT_BOOL, DISPID_BUTTONMENU_GRAYED);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Separator, VARIANT_BOOL, DISPID_BUTTONMENU_SEPARATOR);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     MenuBreak, VARIANT_BOOL, DISPID_BUTTONMENU_MENU_BREAK);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     MenuBarBreak, VARIANT_BOOL, DISPID_BUTTONMENU_MENU_BAR_BREAK);
        
    // Public utility methods

    public:
        void SetToolbar(CMMCToolbar *pMMCToolbar) { m_pMMCToolbar = pMMCToolbar; }
        CMMCToolbar *GetToolbar() { return m_pMMCToolbar; }
        BSTR GetText() { return m_bstrText; }
        BOOL GetEnabled() { return VARIANTBOOL_TO_BOOL(m_Enabled); }
        BOOL GetVisible() { return VARIANTBOOL_TO_BOOL(m_Visible); }
        BOOL GetChecked() { return VARIANTBOOL_TO_BOOL(m_Checked); }
        BOOL GetGrayed() { return VARIANTBOOL_TO_BOOL(m_Grayed); }
        BOOL GetSeparator() { return VARIANTBOOL_TO_BOOL(m_Separator); }
        BOOL GetMenuBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBreak); }
        BOOL GetMenuBarBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBarBreak); }

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CMMCToolbar *m_pMMCToolbar; // Back pointer to owning toolbar

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButtonMenu,                   // name
                                &CLSID_MMCButtonMenu,            // clsid
                                "MMCButtonMenu",                 // objname
                                "MMCButtonMenu",                 // lblname
                                &CMMCButtonMenu::Create,         // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCButtonMenu,             // dispatch IID
                                NULL,                        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _MBUTTON_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbuttons.cpp ===
//=--------------------------------------------------------------------------=
// mbuttons.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenus class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "mbuttons.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButtonMenus::CMMCButtonMenus(IUnknown *punkOuter) :
    CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>(
                      punkOuter,
                      OBJECT_TYPE_MMCBUTTONMENUS,
                      static_cast<IMMCButtonMenus *>(this),
                      static_cast<CMMCButtonMenus *>(this),
                      CLSID_MMCButtonMenu,
                      OBJECT_TYPE_MMCBUTTONMENU,
                      IID_IMMCButtonMenu,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButtonMenus,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButtonMenus::~CMMCButtonMenus()
{
    RELEASE(m_piParentButton);
    InitMemberVariables();
}


void CMMCButtonMenus::InitMemberVariables()
{
    m_piParentButton = NULL;
}

IUnknown *CMMCButtonMenus::Create(IUnknown * punkOuter)
{
    CMMCButtonMenus *pMMCButtonMenus = New CMMCButtonMenus(punkOuter);
    if (NULL == pMMCButtonMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCButtonMenus->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IMMCButtonMenus Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCButtonMenus::putref_Parent(IMMCButton *piParentButton)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    IMMCButtonMenu *piMMCButtonMenu = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // UNDONE: This must be causing a circular ref count because the button has
    // a ref on this collection. The same problem must also be occurring between
    // the ButtonMenu objects and this collection. Need to use C++ back pointers.

    RELEASE(m_piParentButton);
    if (NULL != piParentButton)
    {
        piParentButton->AddRef();
        m_piParentButton = piParentButton;
    }

    IfFailGo(get_Count(&lCount));
    IfFalseGo(lCount > 0, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= lCount)
    {
        IfFailGo(get_Item(varIndex, &piMMCButtonMenu));
        IfFailGo(piMMCButtonMenu->putref_Parent(m_piParentButton));
        RELEASE(piMMCButtonMenu);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piMMCButtonMenu);
    RRETURN(hr);
}



STDMETHODIMP CMMCButtonMenus::Add
(
    VARIANT         Index,
    VARIANT         Key, 
    VARIANT         Text,
    MMCButtonMenu **ppMMCButtonMenu
)
{
    HRESULT         hr = S_OK;
    IMMCButtonMenu *piMMCButtonMenu = NULL;
    VARIANT         varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>::Add(Index, Key, &piMMCButtonMenu);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varCoerced, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButtonMenu->put_Text(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    IfFailGo(piMMCButtonMenu->putref_Parent(m_piParentButton));

    *ppMMCButtonMenu = reinterpret_cast<MMCButtonMenu *>(piMMCButtonMenu);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCButtonMenu);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenus::Persist()
{
    HRESULT         hr = S_OK;
    IMMCButtonMenu *piMMCButtonMenu = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>::Persist(piMMCButtonMenu);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenus::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCButtonMenus == riid)
    {
        *ppvObjOut = static_cast<IMMCButtonMenus *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\main.cpp ===
//=--------------------------------------------------------------------------=
// main.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//      Implements DLL initialization and exported registration functions
//


#include "pch.h"

#include <initguid.h>              // define all the guids.
#define INITOBJECTS                // define AUTOMATIONOBJECTINFO structs
#include "common.h"

#include "button.h"
#include "buttons.h"
#include "clipbord.h"
#include "colhdr.h"
#include "colhdrs.h"
#include "colsets.h"
#include "colset.h"
#include "converb.h"
#include "converbs.h"
#include "ctlbar.h"
#include "ctxtmenu.h"
#include "ctxtprov.h"
#include "datafmt.h"
#include "datafmts.h"
#include "dataobj.h"
#include "dataobjs.h"
#include "enumtask.h"
#include "extdefs.h"
#include "extsnap.h"
#include "image.h"
#include "images.h"
#include "imglist.h"
#include "imglists.h"
#include "listitem.h"
#include "listitms.h"
#include "listview.h"
#include "lsubitem.h"
#include "lsubitms.h"
#include "lvdef.h"
#include "lvdefs.h"
#include "mbutton.h"
#include "mbuttons.h"
#include "menu.h"
#include "menus.h"
#include "menudef.h"
#include "menudefs.h"
#include "msgview.h"
#include "nodetype.h"
#include "nodtypes.h"
#include "ocxvdef.h"
#include "ocxvdefs.h"
#include "ppgwrap.h"
#include "prpsheet.h"
#include "pshtprov.h"
#include "reginfo.h"
#include "resview.h"
#include "resviews.h"
#include "scitdef.h"
#include "scitdefs.h"
#include "scopitem.h"
#include "scopitms.h"
#include "scopnode.h"
#include "sidesdef.h"
#include "snapin.h"
//#include "snapdata.h"
#include "snapindef.h"
#include "sortkeys.h"
#include "sortkey.h"
#include "spanitem.h"
#include "spanitms.h"
#include "strtable.h"
#include "task.h"
#include "taskpad.h"
#include "tasks.h"
#include "tls.h"
#include "toolbar.h"
#include "toolbars.h"
#include "tpdvdef.h"
#include "tpdvdefs.h"
#include "urlvdef.h"
#include "urlvdefs.h"
#include "view.h"
#include "viewdefs.h"
#include "views.h"
#include "xtdsnap.h"
#include "xtdsnaps.h"
#include "xtenson.h"
#include "xtensons.h"

// for ASSERT and FAIL
//
SZTHISFILE

const char g_szLibName[] = "SnapInDesignerRuntime";
const CLSID *g_pLibid = &LIBID_SnapInLib;

extern const CATID *g_rgCATIDImplemented[] = {NULL};
extern const int    g_ctCATIDImplemented   = 0;

extern const CATID *g_rgCATIDRequired[]    = {NULL};
extern const int    g_ctCATIDRequired      = 0;

HINSTANCE g_hInstanceDoc = NULL;
LCID g_lcidDoc = 0;
CRITICAL_SECTION g_DllGetDocCritSection;

OBJECTINFO g_ObjectInfo[] =
{
    AUTOMATIONOBJECT(SnapIn),
    AUTOMATIONOBJECT(ScopeItems),
    AUTOMATIONOBJECT(SnapInDesignerDef),
    AUTOMATIONOBJECT(SnapInDef),
    AUTOMATIONOBJECT(MMCMenu),
    AUTOMATIONOBJECT(MMCMenuDefs),
    AUTOMATIONOBJECT(ExtensionDefs),
    AUTOMATIONOBJECT(ExtendedSnapIns),
    AUTOMATIONOBJECT(ExtendedSnapIn),
    AUTOMATIONOBJECT(ScopeItemDefs),
    AUTOMATIONOBJECT(ScopeItemDef),
    AUTOMATIONOBJECT(ViewDefs),
    AUTOMATIONOBJECT(ListViewDefs),
    AUTOMATIONOBJECT(ListViewDef),
    AUTOMATIONOBJECT(MMCListView),
    AUTOMATIONOBJECT(MMCListItems),
    AUTOMATIONOBJECT(MMCListItem),
    AUTOMATIONOBJECT(MMCListSubItems),
    AUTOMATIONOBJECT(MMCListSubItem),
    AUTOMATIONOBJECT(MMCColumnHeaders),
    AUTOMATIONOBJECT(MMCColumnHeader),
    AUTOMATIONOBJECT(MMCImageLists),
    AUTOMATIONOBJECT(MMCImageList),
    AUTOMATIONOBJECT(MMCImages),
    AUTOMATIONOBJECT(MMCImage),
    AUTOMATIONOBJECT(MMCToolbars),
    AUTOMATIONOBJECT(MMCToolbar),
    AUTOMATIONOBJECT(OCXViewDefs),
    AUTOMATIONOBJECT(OCXViewDef),
    AUTOMATIONOBJECT(URLViewDefs),
    AUTOMATIONOBJECT(URLViewDef),
    AUTOMATIONOBJECT(TaskpadViewDefs),
    AUTOMATIONOBJECT(TaskpadViewDef),
    AUTOMATIONOBJECT(MMCButtons),
    AUTOMATIONOBJECT(MMCButton),
    AUTOMATIONOBJECT(MMCButtonMenus),
    AUTOMATIONOBJECT(MMCButtonMenu),
    AUTOMATIONOBJECT(Taskpad),
    AUTOMATIONOBJECT(Tasks),
    AUTOMATIONOBJECT(Task),
    AUTOMATIONOBJECT(MMCDataObject),
    AUTOMATIONOBJECT(NodeTypes),
    AUTOMATIONOBJECT(NodeType),
    AUTOMATIONOBJECT(RegInfo),
    AUTOMATIONOBJECT(Views),
    AUTOMATIONOBJECT(View),
    AUTOMATIONOBJECT(ScopeItem),
    AUTOMATIONOBJECT(ScopeNode),
    AUTOMATIONOBJECT(ScopePaneItems),
    AUTOMATIONOBJECT(ScopePaneItem),
    AUTOMATIONOBJECT(ResultViews),
    AUTOMATIONOBJECT(ResultView),
    AUTOMATIONOBJECT(ExtensionSnapIn),
    AUTOMATIONOBJECT(MMCClipboard),
    AUTOMATIONOBJECT(MMCDataObjects),
    AUTOMATIONOBJECT(MMCMenuDef),
    AUTOMATIONOBJECT(ContextMenu),
    AUTOMATIONOBJECT(DataFormat),
    AUTOMATIONOBJECT(DataFormats),
    AUTOMATIONOBJECT(MMCConsoleVerb),
    AUTOMATIONOBJECT(MMCConsoleVerbs),
    AUTOMATIONOBJECT(PropertySheet),
    AUTOMATIONOBJECT(PropertyPageWrapper),
    AUTOMATIONOBJECT(EnumTask),
    AUTOMATIONOBJECT(Controlbar),
    AUTOMATIONOBJECT(Extensions),
    AUTOMATIONOBJECT(Extension),
    AUTOMATIONOBJECT(StringTable),
    AUTOMATIONOBJECT(EnumStringTable),
    AUTOMATIONOBJECT(MMCContextMenuProvider),
    AUTOMATIONOBJECT(MMCPropertySheetProvider),
    AUTOMATIONOBJECT(MMCMenus),
    AUTOMATIONOBJECT(MessageView),
    AUTOMATIONOBJECT(ColumnSettings),
    AUTOMATIONOBJECT(ColumnSetting),
    AUTOMATIONOBJECT(SortKeys),
    AUTOMATIONOBJECT(SortKey),
//    AUTOMATIONOBJECT(SnapInData),
    EMPTYOBJECT
};


// Need this to satisfy framework references

WNDPROC g_ParkingWindowProc = NULL;

//=--------------------------------------------------------------------------=
// Localization Information
//
// We need the following two pieces of information:
//    a. whether or not this DLL uses satellite DLLs for localization.  if
//       not, then the lcidLocale is ignored, and we just always get resources
//       from the server module file.
//    b. the ambient LocaleID for this in-proc server.  Controls calling
//       GetResourceHandle() will set this up automatically, but anybody
//       else will need to be sure that it's set up properly.
//
extern const VARIANT_BOOL g_fSatelliteLocalization =  TRUE;
LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

//=--------------------------------------------------------------------------=
// TODO: 
//
// Setting this flag to TRUE will cause your control to be created using
// its runtime license key even if it's created as part of a composite
// control (ie: a VB5-built UserControl) in a design environment.  A user
// of the composite control does not need to acquire or purchase your design-time
// license in order to use the composite control.
//
// The current setting of FALSE means that in order for your control to 
// load as part of a composite control (in a design-time environment), 
// the composite control user will need to acquire or purchase your 
// control's design-time license.  This setting is more restrictive 
// in terms of control distribution and licensing when compared to 
// setting this to TRUE. 
//
extern const BOOL g_fUseRuntimeLicInCompositeCtl = FALSE;






void InitializeLibrary
(
    void
)
{
    ::InitializeCriticalSection(&g_DllGetDocCritSection);
    CTls::Initialize();
}

void UninitializeLibrary
(
    void
)
{
    ::DeleteCriticalSection(&g_DllGetDocCritSection);
    CTls::Destroy();
}

//=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL RegisterData(void)
{

    // TODO: register any additional data here that you might wish to.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterData
//=--------------------------------------------------------------------------=
// inproc server writers should unregister anything they registered in
// RegisterData() here.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL UnregisterData
(
    void
)
{
    // TODO: any additional registry cleanup that you might wish to do.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CheckForLicense
//=--------------------------------------------------------------------------=
// users can implement this if they wish to support Licensing.  otherwise,
// they can just return TRUE all the time.
//
// Parameters:
//    none
//
// Output:
//    BOOL            - TRUE means the license exists, and we can proceed
//                      FALSE means we're not licensed and cannot proceed
//
// Notes:
//    - implementers should use g_wszLicenseKey and g_wszLicenseLocation
//      from the top of this file to define their licensing [the former
//      is necessary, the latter is recommended]
//
BOOL CheckForLicense
(
    void
)
{
    // TODO: decide whether or not your server is licensed in this function.
    // people who don't want to bother with licensing should just return
    // true here always.  g_wszLicenseKey and g_wszLicenseLocation are
    // used by IClassFactory2 to do some of the licensing work.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CheckLicenseKey
//=--------------------------------------------------------------------------=
// when IClassFactory2::CreateInstanceLic is called, a license key is passed
// in, and then passed on to this routine.  users should return a boolean 
// indicating whether it is a valid license key or not
//
// Parameters:
//    LPWSTR          - [in] the key to check
//
// Output:
//    BOOL            - false means it's not valid, true otherwise
//
// Notes:
//
BOOL CheckLicenseKey
(
    LPWSTR pwszKey
)
{
        // Check for the unique license key (key2) or VB4 compatible key (Key1)
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// GetLicenseKey
//=--------------------------------------------------------------------------=
// returns our current license key that should be saved out, and then passed
// back to us in IClassFactory2::CreateInstanceLic
//
// Parameters:
//    none
//
// Output:
//    BSTR                 - key or NULL if Out of memory
//
// Notes:
//
BSTR GetLicenseKey
(
    void
)
{
    // Return our control unique license key
    //
    return SysAllocString(L"");
}


extern "C" HRESULT DLLGetDocumentation
(
    ITypeLib  *ptlib,
    ITypeInfo *ptinfo,
    LCID	   lcid,
    DWORD	   dwHelpStringContextId,
    BSTR*	   pbstrHelpString
)
{
    HRESULT hr = S_OK;
    char szBuffer[512];
    int	cBytes;
    BSTR bstrHelpString = NULL;

    *pbstrHelpString = NULL;

    // Do this in a critical section to protect global data
    //
    EnterCriticalSection(&g_DllGetDocCritSection);
    {
        // Reuse cached module handle if possible. Otherwise, free old handle
        //
        if ( (lcid != g_lcidDoc) || (g_hInstanceDoc == NULL) )
        {
            if ( (NULL != g_hInstanceDoc)                &&
                 (g_hInstanceDoc != GetResourceHandle()) &&
                 (g_hInstanceDoc != g_hInstance)
               )
            {
                ::FreeLibrary(g_hInstanceDoc);
                g_hInstanceDoc = NULL;
            }

            // Load new module containing localized resource strings
            //
            g_hInstanceDoc = GetResourceHandle(lcid);
            g_lcidDoc      = lcid;
        }

        IfFalseGo(g_hInstanceDoc != NULL, SID_E_INTERNAL);
    }
    LeaveCriticalSection(&g_DllGetDocCritSection);

    // Load the string. Note that the build process masks help context ids
    // in the satellite DLL to 16 bits, so we must do the same here.
    //
    cBytes = ::LoadString(g_hInstanceDoc,
                          dwHelpStringContextId & 0xffff,
                          szBuffer, sizeof (szBuffer));

    IfFalseGo(cBytes > 0, SID_E_INTERNAL);
    IfFailGo(BSTRFromANSI(szBuffer, &bstrHelpString));
    *pbstrHelpString = bstrHelpString;

Error:
    RRETURN(hr);
}


#if defined(DEBUG)

extern "C" DWORD RetLastError() { return ::GetLastError(); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbutton.cpp ===
//=--------------------------------------------------------------------------=
// mbutton.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenu class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "mbutton.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButtonMenu::CMMCButtonMenu(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCBUTTONMENU,
                            static_cast<IMMCButtonMenu *>(this),
                            static_cast<CMMCButtonMenu *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButtonMenu,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButtonMenu::~CMMCButtonMenu()
{
    FREESTRING(m_bstrKey);
    RELEASE(m_piParent);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    InitMemberVariables();
}

void CMMCButtonMenu::InitMemberVariables()
{
    m_Enabled = VARIANT_TRUE;
    m_Index = 0;
    m_bstrKey = NULL;
    m_piParent = NULL;
 
    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
    m_Visible = VARIANT_TRUE;
    m_Checked = VARIANT_FALSE;
    m_Grayed = VARIANT_FALSE;
    m_Separator = VARIANT_FALSE;
    m_MenuBreak = VARIANT_FALSE;
    m_MenuBarBreak = VARIANT_FALSE;

    m_pMMCToolbar = NULL;
}

IUnknown *CMMCButtonMenu::Create(IUnknown * punkOuter)
{
    CMMCButtonMenu *pMMCButtonMenu = New CMMCButtonMenu(punkOuter);
    if (NULL == pMMCButtonMenu)
    {
        return NULL;
    }
    else
    {
        return pMMCButtonMenu->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenu::Persist()
{
    HRESULT hr = S_OK;
    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Enabled, VARIANT_TRUE, OLESTR("Enabled")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailRet(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailRet(PersistSimpleType(&m_Visible, VARIANT_TRUE, OLESTR("Visible")));

    IfFailRet(PersistSimpleType(&m_Checked, VARIANT_FALSE, OLESTR("Checked")));

    IfFailRet(PersistSimpleType(&m_Grayed, VARIANT_FALSE, OLESTR("Grayed")));

    IfFailRet(PersistSimpleType(&m_Separator, VARIANT_FALSE, OLESTR("Separator")));

    IfFailRet(PersistSimpleType(&m_MenuBreak, VARIANT_FALSE, OLESTR("MenuBreak")));

    IfFailRet(PersistSimpleType(&m_MenuBarBreak, VARIANT_FALSE, OLESTR("MenuBarBreak")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenu::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCButtonMenu == riid)
    {
        *ppvObjOut = static_cast<IMMCButtonMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menu.cpp ===
//=--------------------------------------------------------------------------=
// menu.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenu class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menu.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CMMCMenu::m_rgvtClick[2] = { VT_I4, VT_UNKNOWN };

EVENTINFO CMMCMenu::m_eiClick =
{
    DISPID_MENU_EVENT_CLICK,
    sizeof(m_rgvtClick) / sizeof(m_rgvtClick[0]),
    m_rgvtClick
};

#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenu::CMMCMenu(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCMENU,
                            static_cast<IMMCMenu *>(this),
                            static_cast<CMMCMenu *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenu,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCMenu::~CMMCMenu()
{
    FREESTRING(m_bstrCaption);
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrStatusBarText);
    FREESTRING(m_bstrResultViewDisplayString);
    RELEASE(m_piChildren);
    (void)::VariantClear(&m_varTag);
    InitMemberVariables();
}

void CMMCMenu::InitMemberVariables()
{
    m_Index = 0;
    m_bstrName = NULL;
    m_bstrKey = NULL;
    m_bstrCaption = NULL;
    m_Visible = VARIANT_TRUE;
    m_Checked = VARIANT_FALSE;
    m_Enabled = VARIANT_TRUE;
    m_Grayed = VARIANT_FALSE;
    m_MenuBreak = VARIANT_FALSE;
    m_MenuBarBreak = VARIANT_FALSE;
    m_Default = VARIANT_FALSE;

    ::VariantInit(&m_varTag);

    m_bstrStatusBarText = NULL;
    m_piChildren = NULL;
    m_pMMCMenus = NULL;
    m_fAutoViewMenuItem = FALSE;
    m_bstrResultViewDisplayString = NULL;
    m_fAutoViewMenuItem = FALSE;
}

IUnknown *CMMCMenu::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;
    CMMCMenu  *pMMCMenu = New CMMCMenu(punkOuter);
    CMMCMenus *pMMCChildrenMenus = NULL;

    if (NULL == pMMCMenu)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Create the children menu collection. If this menu object is being
    // created during deserialization, then this collection will be released
    // and recreated in our Persist() method below but there is now way of
    // knowing that here. If the dev does Dim MyMenu As New MMCMenu then
    // they might call MyMenu.Children.Add so the collection must exist.

    IfFailGo(CreateObject(OBJECT_TYPE_MMCMENUS,
                          IID_IMMCMenus, &pMMCMenu->m_piChildren));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pMMCMenu->m_piChildren,
                                                   &pMMCChildrenMenus));
    pMMCChildrenMenus->SetParent(pMMCMenu);

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCMenu)
        {
            delete pMMCMenu;
        }
        return NULL;
    }
    else
    {
        return pMMCMenu->PrivateUnknown();
    }
}


void CMMCMenu::FireClick(long lIndex, IMMCClipboard *piSelection)
{
    DebugPrintf("Firing Menu%ls_Click(%ld)\r\n", m_bstrName, lIndex);

    FireEvent(&m_eiClick, lIndex, piSelection);
}



HRESULT CMMCMenu::SetResultViewDisplayString(BSTR bstrDisplayString)
{
    HRESULT hr = S_OK;
    
    FREESTRING(m_bstrResultViewDisplayString);
    if (NULL != bstrDisplayString)
    {
        m_bstrResultViewDisplayString = ::SysAllocString(bstrDisplayString);
        if (NULL == m_bstrResultViewDisplayString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenu::Persist()
{
    HRESULT    hr = S_OK;
    CMMCMenus *pMMCChildrenMenus = NULL;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrCaption, L"", OLESTR("Caption")));

    IfFailGo(PersistSimpleType(&m_Visible, VARIANT_TRUE, OLESTR("Visible")));

    IfFailGo(PersistSimpleType(&m_Checked, VARIANT_FALSE, OLESTR("Checked")));

    IfFailGo(PersistSimpleType(&m_Enabled, VARIANT_TRUE, OLESTR("Enabled")));

    IfFailGo(PersistSimpleType(&m_Grayed, VARIANT_FALSE, OLESTR("Grayed")));

    IfFailGo(PersistSimpleType(&m_MenuBreak, VARIANT_FALSE, OLESTR("MenuBreak")));

    IfFailGo(PersistSimpleType(&m_MenuBarBreak, VARIANT_FALSE, OLESTR("MenuBarBreak")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 12) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_Default, VARIANT_FALSE, OLESTR("Default")));
    }

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistBstr(&m_bstrStatusBarText, L"", OLESTR("StatusBarText")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 8) )
    {
    }
    else
    {
        IfFailGo(PersistObject(&m_piChildren, CLSID_MMCMenus,
                               OBJECT_TYPE_MMCMENUS, IID_IMMCMenus,
                               OLESTR("Children")));

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piChildren,
                                                       &pMMCChildrenMenus));
        pMMCChildrenMenus->SetParent(this);

        IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));
    }
    IfFailGo(PersistDISPID());

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenu::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenu == riid)
    {
        *ppvObjOut = static_cast<IMMCMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenu::OnSetHost()
{
    RRETURN(SetObjectHost(m_piChildren));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbuttons.h ===
//=--------------------------------------------------------------------------=
// mbuttons.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenus class definition - implements MMCButtonMenus collection
//
//=--------------------------------------------------------------------------=

#ifndef _MBUTTONS_DEFINED_
#define _MBUTTONS_DEFINED_

#include "collect.h"

class CMMCButtonMenus : public CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>,
                        public CPersistence
{
    protected:
        CMMCButtonMenus(IUnknown *punkOuter);
        ~CMMCButtonMenus();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButtonMenus
        STDMETHOD(putref_Parent)(IMMCButton *piParentButton);
        STDMETHOD(Add)(VARIANT         Index,
                       VARIANT         Key, 
                       VARIANT         Text,
                       MMCButtonMenu **ppMMCButtonMenu);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        IMMCButton *m_piParentButton;

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButtonMenus,             // name
                                &CLSID_MMCButtonMenus,      // clsid
                                "MMCButtonMenus",           // objname
                                "MMCButtonMenus",           // lblname
                                &CMMCButtonMenus::Create,   // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCButtonMenus,       // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _MBUTTONS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudef.cpp ===
//=--------------------------------------------------------------------------=
// menudef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menudef.h"
#include "menu.h"
#include "menudefs.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenuDef::CMMCMenuDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCMENUDEF,
                            static_cast<IMMCMenuDef *>(this),
                            static_cast<CMMCMenuDef *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenuDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCMenuDef::~CMMCMenuDef()
{
    FREESTRING(m_bstrKey);
    RELEASE(m_piMenu);
    RELEASE(m_piChildren);
    InitMemberVariables();
}

void CMMCMenuDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_piMenu = NULL;
    m_piChildren = NULL;
    m_pMMCMenuDefs = NULL;
}

IUnknown *CMMCMenuDef::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMMCMenuDef = NULL;

    CMMCMenuDef *pMMCMenuDef = New CMMCMenuDef(punkOuter);

    IfFalseGo(NULL != pMMCMenuDef, SID_E_OUTOFMEMORY);
    punkMMCMenuDef = pMMCMenuDef->PrivateUnknown();

Error:
    return punkMMCMenuDef;
}


void CMMCMenuDef::SetMenu(IMMCMenu *piMMCMenu)
{
    RELEASE(m_piMenu);
    if (NULL != piMMCMenu)
    {
        piMMCMenu->AddRef();
    }
    m_piMenu = piMMCMenu;
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDef::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistObject(&m_piMenu, CLSID_MMCMenu,
                           OBJECT_TYPE_MMCMENU, IID_IMMCMenu,
                           OLESTR("Menu")));

    IfFailGo(PersistObject(&m_piChildren, CLSID_MMCMenuDefs,
                           OBJECT_TYPE_MMCMENUDEFS, IID_IMMCMenuDefs,
                           OLESTR("Children")));
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenuDef == riid)
    {
        *ppvObjOut = static_cast<IMMCMenuDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piMenu));

    IfFailRet(SetObjectHost(m_piChildren));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menu.h ===
//=--------------------------------------------------------------------------=
// menu.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenu class definition - implements MMCMenu object
//
//=--------------------------------------------------------------------------=

#ifndef _MENU_DEFINED_
#define _MENU_DEFINED_

#include "menus.h"

class CMMCMenus;

class CMMCMenu : public CSnapInAutomationObject,
                 public CPersistence,
                 public IMMCMenu
{
    private:
        CMMCMenu(IUnknown *punkOuter);
        ~CMMCMenu();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenu

        BSTR_PROPERTY_RW(CMMCMenu,          Name,                           DISPID_MENU_NAME);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Index,          long,           DISPID_MENU_INDEX);
        BSTR_PROPERTY_RW(CMMCMenu,          Key,                            DISPID_MENU_KEY);
        BSTR_PROPERTY_RW(CMMCMenu,          Caption,                        DISPID_MENU_CAPTION);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Visible,        VARIANT_BOOL,   DISPID_MENU_VISIBLE);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Checked,        VARIANT_BOOL,   DISPID_MENU_CHECKED);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Enabled,        VARIANT_BOOL,   DISPID_MENU_ENABLED);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Grayed,         VARIANT_BOOL,   DISPID_MENU_GRAYED);
        SIMPLE_PROPERTY_RW(CMMCMenu,        MenuBreak,      VARIANT_BOOL,   DISPID_MENU_MENU_BREAK);
        SIMPLE_PROPERTY_RW(CMMCMenu,        MenuBarBreak,   VARIANT_BOOL,   DISPID_MENU_MENU_BAR_BREAK);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Default,        VARIANT_BOOL,   DISPID_MENU_DEFAULT);
        VARIANTREF_PROPERTY_RW(CMMCMenu,    Tag,                            DISPID_MENU_TAG);
        BSTR_PROPERTY_RW(CMMCMenu,          StatusBarText,                  DISPID_MENU_STATUS_BAR_TEXT);
        COCLASS_PROPERTY_RO(CMMCMenu,       Children, MMCMenus, IMMCMenus,  DISPID_MENU_CHILDREN);
        
    // Public utility methods
    public:

        void FireClick(long lIndex, IMMCClipboard *piSelection);
        
        void SetCollection(CMMCMenus *pMMCMenus) { m_pMMCMenus = pMMCMenus; }
        CMMCMenus *GetCollection() { return m_pMMCMenus; };

        BSTR GetName() { return m_bstrName; }
        LPWSTR GetCaption() { return static_cast<LPWSTR>(m_bstrCaption); }
        BOOL GetVisible() { return VARIANTBOOL_TO_BOOL(m_Visible); }
        BOOL GetChecked() { return VARIANTBOOL_TO_BOOL(m_Checked); }
        BOOL GetEnabled() { return VARIANTBOOL_TO_BOOL(m_Enabled); }
        BOOL GetGrayed() { return VARIANTBOOL_TO_BOOL(m_Grayed); }
        BOOL GetMenuBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBreak); }
        BOOL GetMenuBarBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBarBreak); }
        BOOL GetDefault() { return VARIANTBOOL_TO_BOOL(m_Default); }
        VARIANT GetTag() { return m_varTag; }
        long GetIndex() { return m_Index; }
        void SetIndex(long lIndex) { m_Index = lIndex; }
        LPWSTR GetStatusBarText() { return static_cast<LPWSTR>(m_bstrStatusBarText); }
        BOOL IsAutoViewMenuItem() { return m_fAutoViewMenuItem; }
        void SetAutoViewMenuItem() { m_fAutoViewMenuItem = TRUE; }
        BSTR GetResultViewDisplayString() { return m_bstrResultViewDisplayString; }
        HRESULT SetResultViewDisplayString(BSTR bstrDisplayString);
        
    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CMMCMenus *m_pMMCMenus;   // back ptr to collection containing menu

        // When an MMCMenu object is used to hold an automatically added
        // view menu item this variable holds the display string.
        
        BSTR m_bstrResultViewDisplayString;

        // This flag determines whether the MMCMenu object is being used
        // for an automatically added view menu item.
        
        BOOL m_fAutoViewMenuItem;

        // Click event parameters definition

        static VARTYPE   m_rgvtClick[2];
        static EVENTINFO m_eiClick;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenu,                     // name
                                &CLSID_MMCMenu,              // clsid
                                "MMCMenu",                   // objname
                                "MMCMenu",                   // lblname
                                &CMMCMenu::Create,           // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCMenu,               // dispatch IID
                                &DIID_DMMCMenuEvents,        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _MENU_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudefs.h ===
//=--------------------------------------------------------------------------=
// menudefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _MENUDEFS_DEFINED_
#define _MENUDEFS_DEFINED_

#include "collect.h"

class CMMCMenuDefs : public CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>,
                     public CPersistence
{
    protected:
        CMMCMenuDefs(IUnknown *punkOuter);
        ~CMMCMenuDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenuDefs
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, IMMCMenuDef **ppiMMCMenuDef);
        STDMETHOD(AddExisting)(IMMCMenuDef *piMMCMenuDef, VARIANT Index);

    // CPersistence overrides
    protected:
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        HRESULT SetBackPointers(IMMCMenuDef *piMMCMenuDef);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenuDefs,              // name
                                &CLSID_MMCMenuDefs,       // clsid
                                "MMCMenuDefs",            // objname
                                "MMCMenuDefs",            // lblname
                                &CMMCMenuDefs::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCMenuDefs,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _MENUDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudef.h ===
//=--------------------------------------------------------------------------=
// menudef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _MENUDEF_DEFINED_
#define _MENUDEF_DEFINED_

#include "menudefs.h"


class CMMCMenuDef : public CSnapInAutomationObject,
                    public CPersistence,
                    public IMMCMenuDef
{
    private:
        CMMCMenuDef(IUnknown *punkOuter);
        ~CMMCMenuDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenuDef
        SIMPLE_PROPERTY_RW(CMMCMenuDef,  Index,    long,            DISPID_MMCMENUDEF_INDEX);
        BSTR_PROPERTY_RW(CMMCMenuDef,    Key,                       DISPID_MMCMENUDEF_KEY);
        OBJECT_PROPERTY_RO(CMMCMenuDef,  Menu,     IMMCMenu,        DISPID_MMCMENUDEF_MENU);
        OBJECT_PROPERTY_RO(CMMCMenuDef,  Children, IMMCMenuDefs,    DISPID_MMCMENUDEF_CHILDREN);

    // Public utility methods
    public:
        void SetParent(CMMCMenuDefs *pMMCMenuDefs) { m_pMMCMenuDefs = pMMCMenuDefs; }
        CMMCMenuDefs *GetParent() { return m_pMMCMenuDefs; };

        void SetMenu(IMMCMenu *piMMCMenu);

        long GetIndex() { return m_Index; }
        BSTR GetKey() { return m_bstrKey; }
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CMMCMenuDefs *m_pMMCMenuDefs; //owning object
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenuDef,                  // name
                                &CLSID_MMCMenuDef,           // clsid
                                "MMCMenuDef",                // objname
                                "MMCMenuDef",                // lblname
                                &CMMCMenuDef::Create,        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCMenuDef,            // dispatch IID
                                NULL,                        // no event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _MENUDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudefs.cpp ===
//=--------------------------------------------------------------------------=
// menudefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menudefs.h"
#include "menudef.h"
#include "menu.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenuDefs::CMMCMenuDefs(IUnknown *punkOuter) :
    CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>(
                                           punkOuter,
                                           OBJECT_TYPE_MMCMENUDEFS,
                                           static_cast<IMMCMenuDefs *>(this),
                                           static_cast<CMMCMenuDefs *>(this),
                                           CLSID_MMCMenuDef,
                                           OBJECT_TYPE_MMCMENUDEF,
                                           IID_IMMCMenuDef,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenuDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCMenuDefs::~CMMCMenuDefs()
{
}

IUnknown *CMMCMenuDefs::Create(IUnknown * punkOuter)
{
    CMMCMenuDefs *pMMCMenus = New CMMCMenuDefs(punkOuter);
    if (NULL == pMMCMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCMenus->PrivateUnknown();
    }
}


HRESULT CMMCMenuDefs::SetBackPointers(IMMCMenuDef *piMMCMenuDef)
{
    HRESULT      hr = S_OK;
    CMMCMenuDef *pMMCMenuDef = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuDef, &pMMCMenuDef));
    pMMCMenuDef->SetParent(this);
    
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IMMCMenuDefs Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCMenuDefs::Add
(
    VARIANT       Index,
    VARIANT       Key,
    IMMCMenuDef **ppiMMCMenuDef
)
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    // Add the item to the collection. Do not specify an index.

    hr = CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::Add(
                                                                 Index,
                                                                 Key,
                                                                 ppiMMCMenuDef);
    IfFailGo(hr);

    // Set the back pointer on the MMCMenu and on the MMCMenuDef

    IfFailGo(SetBackPointers(*ppiMMCMenuDef));
    
Error:
    QUICK_RELEASE(piMMCMenu);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}



STDMETHODIMP CMMCMenuDefs::AddExisting(IMMCMenuDef *piMMCMenuDef, VARIANT Index)
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Use the menu's name as the key for the item in this collection.

    IfFailGo(piMMCMenuDef->get_Menu(&piMMCMenu));
    IfFailGo(piMMCMenu->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    // Add the item to the collection at the specified index.
    
    hr = CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::AddExisting(
                                                                  Index,
                                                                  varKey,
                                                                  piMMCMenuDef);
    IfFailGo(hr);

    // Set the back pointer on the MMCMenu and on the MMCMenuDef

    IfFailGo(SetBackPointers(piMMCMenuDef));

Error:
    QUICK_RELEASE(piMMCMenu);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDefs::Persist()
{
    HRESULT      hr = S_OK;
    IMMCMenuDef *piMMCMenuDef = NULL;
    long         cMenuDefs = 0;
    long         i = 0;

    // Do persistence operation

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::Persist(piMMCMenuDef);

    // If this is a load then set back pointers on each collection member

    if (Loading())
    {
        cMenuDefs = GetCount();
        for (i = 0; i < cMenuDefs; i++)
        {
            IfFailGo(SetBackPointers(GetItemByIndex(i)));
        }
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenuDefs == riid)
    {
        *ppvObjOut = static_cast<IMMCMenuDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menus.cpp ===
//=--------------------------------------------------------------------------=
// menus.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenus class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menus.h"
#include "menudef.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenus::CMMCMenus(IUnknown *punkOuter) :
    CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>(
                                           punkOuter,
                                           OBJECT_TYPE_MMCMENUS,
                                           static_cast<IMMCMenus *>(this),
                                           static_cast<CMMCMenus *>(this),
                                           CLSID_MMCMenu,
                                           OBJECT_TYPE_MMCMENU,
                                           IID_IMMCMenu,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenus,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CMMCMenus::InitMemberVariables()
{
    m_pMMCMenu = NULL;
}


CMMCMenus::~CMMCMenus()
{
    InitMemberVariables();
}

IUnknown *CMMCMenus::Create(IUnknown * punkOuter)
{
    CMMCMenus *pMMCMenus = New CMMCMenus(punkOuter);
    if (NULL == pMMCMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCMenus->PrivateUnknown();
    }
}


HRESULT CMMCMenus::SetBackPointers(IMMCMenu *piMMCMenu)
{
    HRESULT   hr = S_OK;
    CMMCMenu *pMMCMenu = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));
    pMMCMenu->SetCollection(this);
    
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CMMCMenus::Convert
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IMMCMenuDefs *piMMCMenuDefs [in] Old MenuDefs collection
//      IMMCMenus    *piMMCMenus    [out] new Menus collection populated from
//                                        from MenuDefs
//
// Output:
//      HRESULT
//
// Notes:
//
// This function takes an MMCMenuDefs collection and populates an MMCMenus
// collection from it. This is done to enable loading old snap-in projects
// before serialization version 0.8 where an object model change was made that
// made MMCMenuDefs obsolete.
//
// This function will call itself recursively to populate the children
// of menu items in the specified collections.

HRESULT CMMCMenus::Convert
(
    IMMCMenuDefs *piMMCMenuDefs,
    IMMCMenus    *piMMCMenus
)
{
    HRESULT       hr = S_OK;
    CMMCMenuDefs *pMMCMenuDefs = NULL;
    IMMCMenuDef  *piMMCMenuDef = NULL; // Not AddRef()ed
    CMMCMenuDef  *pMMCMenuDef = NULL;
    IMMCMenu     *piMMCNewMenu = NULL;
    IMMCMenu     *piMMCOldMenu = NULL;
    CMMCMenu     *pMMCOldMenu = NULL;
    IMMCMenuDefs *piMMCMenuDefChildren = NULL;
    IMMCMenus    *piMMCNewMenuChildren = NULL;
    long          cMMCMenuDefs = 0;
    long          i = 0;
    IObjectModel *piObjectModel = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuDefs, &pMMCMenuDefs));

    cMMCMenuDefs = pMMCMenuDefs->GetCount();

    for (i = 0; i < cMMCMenuDefs; i++)
    {
        // Get the next MMCMenuDef

        piMMCMenuDef = pMMCMenuDefs->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuDef, &pMMCMenuDef));

        // Create a new MMCMenu in the caller's collection. Use the old key but
        // not the index because they will be added in the order we find them.
        
        varKey.bstrVal = pMMCMenuDef->GetKey();
        IfFailGo(piMMCMenus->Add(varUnspecifiedIndex, varKey, &piMMCNewMenu));

        // Get the contained MMCMenu object from the old MMCMenuDef and copy
        // its properties to the new MMCMenu
        
        IfFailGo(piMMCMenuDef->get_Menu(&piMMCOldMenu));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCOldMenu, &pMMCOldMenu));

        IfFailGo(piMMCNewMenu->put_Name(pMMCOldMenu->GetName()));
        IfFailGo(piMMCNewMenu->put_Caption(pMMCOldMenu->GetCaption()));
        IfFailGo(piMMCNewMenu->put_Visible(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetVisible())));
        IfFailGo(piMMCNewMenu->put_Checked(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetChecked())));
        IfFailGo(piMMCNewMenu->put_Enabled(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetEnabled())));
        IfFailGo(piMMCNewMenu->put_Grayed(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetGrayed())));
        IfFailGo(piMMCNewMenu->put_MenuBreak(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetMenuBreak())));
        IfFailGo(piMMCNewMenu->put_MenuBarBreak(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetMenuBarBreak())));
        IfFailGo(piMMCNewMenu->put_Tag(pMMCOldMenu->GetTag()));
        IfFailGo(piMMCNewMenu->put_StatusBarText(pMMCOldMenu->GetStatusBarText()));

        IfFailGo(piMMCNewMenu->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));
        IfFailGo(piObjectModel->SetDISPID(pMMCOldMenu->GetDispid()));

        // Get the children of the old MMCMenuDef and the new MMCMenu and call
        // this function recursively to populate them.
        
        IfFailGo(piMMCMenuDef->get_Children(&piMMCMenuDefChildren));
        IfFailGo(piMMCNewMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCNewMenuChildren)));
        IfFailGo(Convert(piMMCMenuDefChildren, piMMCNewMenuChildren));

        RELEASE(piMMCMenuDefChildren);
        RELEASE(piMMCNewMenuChildren);
        RELEASE(piMMCNewMenu);
        RELEASE(piMMCOldMenu);
        RELEASE(piObjectModel);
    }

Error:
    QUICK_RELEASE(piMMCMenuDefChildren);
    QUICK_RELEASE(piMMCNewMenuChildren);
    QUICK_RELEASE(piMMCNewMenu);
    QUICK_RELEASE(piMMCOldMenu);
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IMMCMenus Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCMenus::Add
(
    VARIANT    Index,
    VARIANT    Key,
    IMMCMenu **ppiMMCMenu
)
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;

    // Add the item to the collection. Do not specify an index.

    hr = CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::Add(Index,
                                                              Key,
                                                              ppiMMCMenu);
    IfFailGo(hr);

    // Set the back pointer to this collection on the new MMCMenu

    IfFailGo(SetBackPointers(*ppiMMCMenu));
    
Error:
    QUICK_RELEASE(piMMCMenu);
    RRETURN(hr);
}



STDMETHODIMP CMMCMenus::AddExisting(IMMCMenu *piMMCMenu, VARIANT Index)
{
    HRESULT   hr = S_OK;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Use the menu's name as the key for the item in this collection.

    IfFailGo(piMMCMenu->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    // Add the item to the collection at the specified index.
    
    hr = CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::AddExisting(Index,
                                                                      varKey,
                                                                      piMMCMenu);
    IfFailGo(hr);

    // Set the back pointer to this collection on the MMCMenu

    IfFailGo(SetBackPointers(piMMCMenu));

Error:
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenus::Persist()
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;
    long      cMenus = 0;
    long      i = 0;

    // Do persistence operation

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::Persist(piMMCMenu);

    // If this is a load then set back pointers on each collection member

    if (Loading())
    {
        cMenus = GetCount();
        for (i = 0; i < cMenus; i++)
        {
            IfFailGo(SetBackPointers(GetItemByIndex(i)));
        }
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenus::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenus == riid)
    {
        *ppvObjOut = static_cast<IMMCMenus *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mssnapr_i_wrap.c ===
#include "mssnapr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\msgview.cpp ===
//=--------------------------------------------------------------------------=
// msgview.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtension class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "msgview.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMessageView::CMessageView(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MESSAGEVIEW,
                            static_cast<IMMCMessageView *>(this),
                            static_cast<CMessageView *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence

{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMessageView::~CMessageView()
{
    FREESTRING(m_bstrTitleText);
    FREESTRING(m_bstrBodyText);
    InitMemberVariables();
}

void CMessageView::InitMemberVariables()
{
    m_bstrTitleText = NULL;
    m_bstrBodyText = NULL;
    m_IconType = siIconNone;
    m_pResultView = NULL;
}

IUnknown *CMessageView::Create(IUnknown *punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMessageView = NULL;

    CMessageView *pMessageView = New CMessageView(punkOuter);

    IfFalseGo(NULL != pMessageView, SID_E_OUTOFMEMORY);
    punkMessageView = pMessageView->PrivateUnknown();

Error:
    return punkMessageView;
}

IMessageView *CMessageView::GetMessageView()
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;
    IConsole2       *piConsole2 = NULL; // NotAddRef()ed
    IUnknown        *punkResultView = NULL;
    IMessageView    *piMessageView = NULL;

    IfFalseGo(NULL != m_pResultView, hr);

    pScopePaneItem = m_pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    piConsole2 = pView->GetIConsole2();
    IfFalseGo(NULL != piConsole2, hr);

    IfFailGo(piConsole2->QueryResultView(&punkResultView));
    IfFailGo(punkResultView->QueryInterface(IID_IMessageView,
                                   reinterpret_cast<void **>(&piMessageView)));

Error:
    QUICK_RELEASE(punkResultView);
    return piMessageView;
}


HRESULT CMessageView::Populate()
{
    HRESULT hr = S_OK;

    IfFailGo(SetTitle());
    IfFailGo(SetBody());
    IfFailGo(SetIcon());

Error:
    RRETURN(hr);
}


HRESULT CMessageView::SetTitle()
{
    HRESULT       hr = S_OK;
    IMessageView *piMessageView = GetMessageView();

    IfFalseGo(NULL != m_pResultView, S_OK);
    IfFalseGo(!m_pResultView->InActivate(), S_OK);
    IfFalseGo(NULL != piMessageView, S_OK);

    hr = piMessageView->SetTitleText(static_cast<LPCOLESTR>(m_bstrTitleText));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}

HRESULT CMessageView::SetBody()
{
    HRESULT       hr = S_OK;
    IMessageView *piMessageView = GetMessageView();

    IfFalseGo(NULL != m_pResultView, S_OK);
    IfFalseGo(!m_pResultView->InActivate(), S_OK);
    IfFalseGo(NULL != piMessageView, S_OK);

    hr = piMessageView->SetBodyText(static_cast<LPCOLESTR>(m_bstrBodyText));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}


HRESULT CMessageView::SetIcon()
{
    HRESULT        hr = S_OK;
    IMessageView  *piMessageView = GetMessageView();
    IconIdentifier IconID = Icon_None;

    IfFalseGo(NULL != m_pResultView, S_OK);
    IfFalseGo(!m_pResultView->InActivate(), S_OK);
    IfFalseGo(NULL != piMessageView, S_OK);

    switch (m_IconType)
    {
        case siIconNone:
            IconID = Icon_None;
            break;

        case siIconError:
            IconID = Icon_Error;
            break;

        case siIconQuestion:
            IconID = Icon_Question;
            break;

        case siIconWarning:
            IconID = Icon_Warning;
            break;

        case siIconInformation:
            IconID = Icon_Information;
            break;

        default:
            break;
    }
    hr = piMessageView->SetIcon(IconID);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IMessageView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMessageView::put_TitleText(BSTR bstrText)
{
    HRESULT hr = S_OK;

    IfFailGo(SetBstr(bstrText, &m_bstrTitleText, DISPID_MESSAGEVIEW_TITLE_TEXT));
    IfFailGo(SetTitle());

Error:
    RRETURN(hr);
}

STDMETHODIMP CMessageView::put_BodyText(BSTR bstrText)
{
    HRESULT hr = S_OK;

    IfFailGo(SetBstr(bstrText, &m_bstrBodyText, DISPID_MESSAGEVIEW_BODY_TEXT));
    IfFailGo(SetBody());

Error:
    RRETURN(hr);
}

STDMETHODIMP CMessageView::put_IconType(SnapInMessageViewIconTypeConstants Type)
{
    HRESULT hr = S_OK;

    IfFailGo(SetSimpleType(Type, &m_IconType, DISPID_MESSAGEVIEW_ICON_TYPE));
    IfFailGo(SetIcon());

Error:
    RRETURN(hr);
}


STDMETHODIMP CMessageView::Clear()
{
    HRESULT       hr = S_OK;
    IMessageView *piMessageView = GetMessageView();

    // Clear out our properties

    IfFailGo(SetBstr(NULL, &m_bstrTitleText, DISPID_MESSAGEVIEW_TITLE_TEXT));
    IfFailGo(SetBstr(NULL, &m_bstrBodyText, DISPID_MESSAGEVIEW_BODY_TEXT));
    IfFailGo(SetSimpleType(siIconNone, &m_IconType, DISPID_MESSAGEVIEW_ICON_TYPE));

    // Ask MMC to clear out the message view
    
    IfFalseGo(NULL != piMessageView, S_OK);
    hr = piMessageView->Clear();
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMessageView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCMessageView == riid)
    {
        *ppvObjOut = static_cast<IMMCMessageView *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mmcapi.cpp ===
//=--------------------------------------------------------------------------=
// mmcapi.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Exported functions that pass through calls to MMC API functions.
// VB code cannot call MMC API functions because they are in a static lib.
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"

// for ASSERT and FAIL
//
SZTHISFILE



extern "C" WINAPI MMCPropertyHelpPassThru(char *pszTopic)
{
    HRESULT  hr = S_OK;
    LPOLESTR pwszTopic = NULL;

    IfFailGo(::WideStrFromANSI(pszTopic, &pwszTopic));
    IfFailGo(::MMCPropertyHelp(pwszTopic));

Error:
    if (NULL != pwszTopic)
    {
        CtlFree(pwszTopic);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menus.h ===
//=--------------------------------------------------------------------------=
// menus.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenus class definition - implements MMCMenus collection
//
//=--------------------------------------------------------------------------=

#ifndef _MENUS_DEFINED_
#define _MENUS_DEFINED_

#include "collect.h"
#include "menu.h"

class CMMCMenu;

class CMMCMenus : public CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>,
                  public CPersistence
{
    protected:
        CMMCMenus(IUnknown *punkOuter);
        ~CMMCMenus();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenus
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, IMMCMenu **ppiMMCMenu);
        STDMETHOD(AddExisting)(IMMCMenu *piMMCMenu, VARIANT Index);

    // Public utility methods
        CMMCMenu *GetParent() { return m_pMMCMenu; }
        void SetParent(CMMCMenu *pMMCMenu) { m_pMMCMenu = pMMCMenu; }

        // Used for upgrades from pre-beta code to convert MMCMenuDefs
        // collection to MMCMenus

        static HRESULT Convert(IMMCMenuDefs *piMMCMenuDefs, IMMCMenus *piMMCMenus);

    // CPersistence overrides
    protected:
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        HRESULT SetBackPointers(IMMCMenu *piMMCMenu);

        CMMCMenu *m_pMMCMenu; //owning menu object
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenus,              // name
                                &CLSID_MMCMenus,       // clsid
                                "MMCMenus",            // objname
                                "MMCMenus",            // lblname
                                &CMMCMenus::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCMenus,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _MENUS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\msgview.h ===
//=--------------------------------------------------------------------------=
// msgview.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMessageView class definition - implements MMCMessageView object
//
//=--------------------------------------------------------------------------=

#ifndef _MESSAGEVIEW_DEFINED_
#define _MESSAGEVIEW_DEFINED_

#include "resview.h"

class CResultView;

class CMessageView : public CSnapInAutomationObject,
                     public IMMCMessageView
{
    private:
        CMessageView(IUnknown *punkOuter);
        ~CMessageView();
    
    public:
        static IUnknown *Create(IUnknown *punk);

        void SetResultView(CResultView *pResultView) { m_pResultView = pResultView; }

        // Sets MMC message view properties from this object's properties
        
        HRESULT Populate();

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMessageView
        BSTR_PROPERTY_RO(CMessageView, TitleText, DISPID_MESSAGEVIEW_TITLE_TEXT);
        STDMETHOD(put_TitleText)(BSTR bstrText);

        BSTR_PROPERTY_RO(CMessageView, BodyText, DISPID_MESSAGEVIEW_BODY_TEXT);
        STDMETHOD(put_BodyText)(BSTR bstrText);

        SIMPLE_PROPERTY_RO(CMessageView, IconType, SnapInMessageViewIconTypeConstants, DISPID_MESSAGEVIEW_ICON_TYPE);
        STDMETHOD(put_IconType)(SnapInMessageViewIconTypeConstants Type);
      
        STDMETHOD(Clear)();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        IMessageView *GetMessageView();
        HRESULT SetTitle();
        HRESULT SetBody();
        HRESULT SetIcon();

        CResultView *m_pResultView; // back pointer to owning result view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MessageView,            // name
                                &CLSID_MMCMessageView,  // clsid
                                "MessageView",          // objname
                                "MessageView",          // lblname
                                &CMessageView::Create,  // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMessageView,      // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _MESSAGEVIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodtypes.cpp ===
//=--------------------------------------------------------------------------=
// nodtypes.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeTypes class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "nodtypes.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CNodeTypes::CNodeTypes(IUnknown *punkOuter) :
    CSnapInCollection<INodeType, NodeType, INodeTypes>(
                      punkOuter,
                      OBJECT_TYPE_NODETYPES,
                      static_cast<INodeTypes *>(this),
                      static_cast<CNodeTypes *>(this),
                      CLSID_NodeType,
                      OBJECT_TYPE_NODETYPE,
                      IID_INodeType,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_NodeTypes,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CNodeTypes::~CNodeTypes()
{
}

IUnknown *CNodeTypes::Create(IUnknown * punkOuter)
{
    CNodeTypes *pNodeTypes = New CNodeTypes(punkOuter);
    if (NULL == pNodeTypes)
    {
        return NULL;
    }
    else
    {
        return pNodeTypes->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeTypes::Persist()
{
    HRESULT     hr = S_OK;
    INodeType  *piNodeType = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<INodeType, NodeType, INodeTypes>::Persist(piNodeType);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeTypes::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_INodeTypes == riid)
    {
        *ppvObjOut = static_cast<INodeTypes *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<INodeType, NodeType, INodeTypes>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodetype.h ===
//=--------------------------------------------------------------------------=
// nodetype.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeType class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _NODETYPE_DEFINED_
#define _NODETYPE_DEFINED_


class CNodeType : public CSnapInAutomationObject,
                  public CPersistence,
                  public INodeType
{
    private:
        CNodeType(IUnknown *punkOuter);
        ~CNodeType();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // INodeType

        SIMPLE_PROPERTY_RW(CNodeType, Index, long, DISPID_NODETYPE_INDEX);
        BSTR_PROPERTY_RW(CNodeType,   Key, DISPID_NODETYPE_KEY);
        BSTR_PROPERTY_RW(CNodeType,   Name,  DISPID_NODETYPE_NAME);
        BSTR_PROPERTY_RW(CNodeType,   GUID,  DISPID_NODETYPE_GUID);

      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(NodeType,           // name
                                &CLSID_NodeType,    // clsid
                                "NodeType",         // objname
                                "NodeType",         // lblname
                                &CNodeType::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_INodeType,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _NODETYPE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodetype.cpp ===
//=--------------------------------------------------------------------------=
// nodetype.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeType class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "nodetype.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CNodeType::CNodeType(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_NODETYPE,
                            static_cast<INodeType *>(this),
                            static_cast<CNodeType *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_NodeType,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CNodeType::~CNodeType()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrGUID);
    FREESTRING(m_bstrName);
    InitMemberVariables();
}

void CNodeType::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrGUID = NULL;
    m_bstrName = NULL;
}

IUnknown *CNodeType::Create(IUnknown * punkOuter)
{
    CNodeType *pNodeType = New CNodeType(punkOuter);
    if (NULL == pNodeType)
    {
        return NULL;
    }
    else
    {
        return pNodeType->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeType::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistBstr(&m_bstrGUID, L"", OLESTR("GUID")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeType::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_INodeType == riid)
    {
        *ppvObjOut = static_cast<INodeType *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodtypes.h ===
//=--------------------------------------------------------------------------=
// nodtype.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeTypes class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _NODETYPES_DEFINED_
#define _NODETYPES_DEFINED_

#include "collect.h"

class CNodeTypes : public CSnapInCollection<INodeType, NodeType, INodeTypes>,
                   public CPersistence
{
    protected:
        CNodeTypes(IUnknown *punkOuter);
        ~CNodeTypes();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(NodeTypes,           // name
                                &CLSID_NodeTypes,    // clsid
                                "NodeTypes",         // objname
                                "NodeTypes",         // lblname
                                &CNodeTypes::Create, // creation function
                                TLIB_VERSION_MAJOR,  // major version
                                TLIB_VERSION_MINOR,  // minor version
                                &IID_INodeTypes,     // dispatch IID
                                NULL,                // no events IID
                                HELP_FILENAME,       // help file
                                TRUE);               // thread safe


#endif // _NODETYPES_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\pch.h ===
//=--------------------------------------------------------------------------------------
// pch.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Precompiled header files for mssnapr
//=-------------------------------------------------------------------------------------=

#include <ipserver.h>
#include <macros.h>
#include <MSStkPPg.h>
#include <comcat.h>
#include <util.h>
#include <commctrl.h>

#include <stdio.h>
#include <stdarg.h>

#include "localobj.h"
#define IID_IMMCListView My_IID_IMMCListView
#define IID_INodeType    My_IID_INodeType
#include "mssnapr.h"
#include "mmc.h"
#include "dispid.h"
#include "help.h"
#include "tlver.h"
#include "rtconst.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdefs.h ===
//=--------------------------------------------------------------------------=
// ocxvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _OCXVIEWDEFS_DEFINED_
#define _OCXVIEWDEFS_DEFINED_

#define MASTER_COLLECTION
#include "collect.h"

class COCXViewDefs : public CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>,
                     public CPersistence
{
    protected:
        COCXViewDefs(IUnknown *punkOuter);
        ~COCXViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(OCXViewDefs,           // name
                                &CLSID_OCXViewDefs,    // clsid
                                "OCXViewDefs",         // objname
                                "OCXViewDefs",         // lblname
                                &COCXViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IOCXViewDefs,     // dispatch IID
                                NULL,                  // no events IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _OCXVIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdef.h ===
//=--------------------------------------------------------------------------=
// ocxvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _OCXVIEWDEF_DEFINED_
#define _OCXVIEWDEF_DEFINED_


class COCXViewDef : public CSnapInAutomationObject,
                    public CPersistence,
                    public IOCXViewDef
{
    private:
        COCXViewDef(IUnknown *punkOuter);
        ~COCXViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IOCXViewDef

        BSTR_PROPERTY_RW(COCXViewDef,       Name,  DISPID_OCXVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(COCXViewDef,     Index, long, DISPID_OCXVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(COCXViewDef,       Key, DISPID_OCXVIEWDEF_KEY);
        VARIANTREF_PROPERTY_RW(COCXViewDef, Tag, DISPID_OCXVIEWDEF_TAG);
        SIMPLE_PROPERTY_RW(COCXViewDef,     AddToViewMenu, VARIANT_BOOL, DISPID_OCXVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(COCXViewDef,       ViewMenuText, DISPID_OCXVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(COCXViewDef,       ViewMenuStatusBarText, DISPID_OCXVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        BSTR_PROPERTY_RW(COCXViewDef,       ProgID, DISPID_OCXVIEWDEF_PROGID);
        SIMPLE_PROPERTY_RW(COCXViewDef,     AlwaysCreateNewOCX, VARIANT_BOOL, DISPID_OCXVIEWDEF_ALWAYS_CREATE_NEW_OCX);
      
    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        HRESULT SetActualDisplayString(OLECHAR *pwszString);
        OLECHAR *GetActualDisplayString() { return m_pwszActualDisplayString; }

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        OLECHAR *m_pwszActualDisplayString; // At runtime this will contain the
                                            // actual display string returned
                                            // to MMC for this result view.

        // Property pages CLSID for ISpecifyPropertyPages

        static const GUID *m_rgpPropertyPageCLSIDs[1];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(OCXViewDef,           // name
                                &CLSID_OCXViewDef,    // clsid
                                "OCXViewDef",         // objname
                                "OCXViewDef",         // lblname
                                &COCXViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,   // major version
                                TLIB_VERSION_MINOR,   // minor version
                                &IID_IOCXViewDef,     // dispatch IID
                                NULL,                 // event IID
                                HELP_FILENAME,        // help file
                                TRUE);                // thread safe


#endif // _OCXVIEWDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdef.cpp ===
//=--------------------------------------------------------------------------=
// ocxvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ocxvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *COCXViewDef::m_rgpPropertyPageCLSIDs[1] = { &CLSID_OCXViewDefGeneralPP };


#pragma warning(disable:4355)  // using 'this' in constructor

COCXViewDef::COCXViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_OCXVIEWDEF,
                            static_cast<IOCXViewDef *>(this),
                            static_cast<COCXViewDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_OCXViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


COCXViewDef::~COCXViewDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    FREESTRING(m_bstrProgID);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    InitMemberVariables();
}

void COCXViewDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrName = NULL;

    ::VariantInit(&m_varTag);

    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_bstrProgID = NULL;
    m_AlwaysCreateNewOCX = VARIANT_FALSE;
    m_pwszActualDisplayString = NULL;
}

IUnknown *COCXViewDef::Create(IUnknown * punkOuter)
{
    COCXViewDef *pOCXViewDef = New COCXViewDef(punkOuter);
    if (NULL == pOCXViewDef)
    {
        return NULL;
    }
    else
    {
        return pOCXViewDef->PrivateUnknown();
    }
}



HRESULT COCXViewDef::SetActualDisplayString(OLECHAR *pwszString)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszString,
                                   &m_pwszActualDisplayString));
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDef::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailRet(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailRet(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailRet(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailRet(PersistBstr(&m_bstrProgID, L"", OLESTR("ProgID")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 7) )
    {
    }
    else
    {
        IfFailRet(PersistSimpleType(&m_AlwaysCreateNewOCX, VARIANT_FALSE, OLESTR("AlwaysCreateNewOCX")));
    }
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IOCXViewDef == riid)
    {
        *ppvObjOut = static_cast<IOCXViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\persobj.cpp ===
//=--------------------------------------------------------------------------=
// persobj.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPersistence class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "error.h"

// for ASSERT and FAIL
//
SZTHISFILE


CPersistence::CPersistence
(
    const CLSID *pClsid,
          DWORD  dwVerMajor,
          DWORD  dwVerMinor
)
{
    InitMemberVariables();
    m_dwVerMajor = dwVerMajor;
    m_dwVerMinor = dwVerMinor;
    m_Clsid = *pClsid;
}

CPersistence::~CPersistence()
{
    InitMemberVariables();
}

void CPersistence::InitMemberVariables()
{
    m_fDirty = FALSE;
    m_fClearDirty = FALSE;
    m_fLoading = FALSE;
    m_fSaving = FALSE;
    m_fInitNew = FALSE;
    m_fStream = FALSE;
    m_fPropertyBag = FALSE;
    m_piStream = NULL;
    m_piPropertyBag = NULL;
    m_piErrorLog = NULL;
    m_Clsid = GUID_NULL;
}



HRESULT CPersistence::QueryPersistenceInterface
(
    REFIID   riid,
    void   **ppvInterface
)
{
    HRESULT hr = S_OK;

    if (IID_IPersistStreamInit == riid)
    {
        *ppvInterface = static_cast<IPersistStreamInit *>(this);
    }
    else if (IID_IPersistStream == riid)
    {
        *ppvInterface = static_cast<IPersistStream *>(this);
    }
    else if (IID_IPersistPropertyBag == riid)
    {
        *ppvInterface = static_cast<IPersistPropertyBag *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}


HRESULT CPersistence::Persist()
{
    DWORD   dwVerMajor = 0;
    DWORD   dwVerMinor = 0;
    HRESULT hr         = S_OK;

    static LPCOLESTR pszMajorVersion = OLESTR("Persistence.MajorVersion");
    static LPCOLESTR pszMinorVersion = OLESTR("Persistence.MinorVersion");

    // When loading do a version check. The major versions must be equal. The
    // minor version must be lower or equal. This means that we maintain
    // backward compatibility with prior minor versions only (e.g. a 1.1
    // designer can read the 1.0 format but not vice-versa). Objects that need
    // to load a prior version must check the version when loading and load only
    // the appropriate properties. To see examples of objects that do this grep
    // the source code for "GetMinorVersion()".

    if (m_fLoading)
    {
        IfFailGo(PersistSimpleType(&dwVerMajor, m_dwVerMajor, pszMajorVersion));

        IfFailGo(PersistSimpleType(&dwVerMinor, m_dwVerMinor, pszMinorVersion));

        IfFalseGo(dwVerMajor == m_dwVerMajor, SID_E_UNKNOWNFORMAT);
        m_dwVerMajor = dwVerMajor;

        IfFalseGo(dwVerMinor <= m_dwVerMinor, SID_E_UNKNOWNFORMAT);
        m_dwVerMinor = dwVerMinor;
    }
    else if (m_fSaving)
    {
        // Always save using the version numbers we compiled with (in persobj.h).
        // This means that loading an older project and then saving it
        // automatically upgrades it to the current version. Objects should
        // always save their state using the current version of their properties.

        dwVerMajor = g_dwVerMajor;
        dwVerMinor = g_dwVerMinor;
        
        IfFailGo(PersistSimpleType(&dwVerMajor, g_dwVerMajor, pszMajorVersion));

        IfFailGo(PersistSimpleType(&dwVerMinor, g_dwVerMinor, pszMinorVersion));
    }

Error:
    if (SID_E_UNKNOWNFORMAT == hr)
    {
        GLOBAL_EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


HRESULT CPersistence::PersistBstr
(
    BSTR      *pbstrValue,
    WCHAR     *pwszDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrValue = NULL;
    BSTR     bstrEmpty = NULL;
    WCHAR   *pwszBstr = NULL;
    ULONG    cbBstr = 0;
    VARIANT  varBstr;
    ::VariantInit(&varBstr);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            if (NULL != *pbstrValue)
            {
                // Get the byte length excluding the terminating null
                cbBstr = (ULONG)::SysStringByteLen(*pbstrValue);
            }
            else
            {
                cbBstr = 0;
            }
            IfFailRet(WriteToStream(&cbBstr, sizeof(cbBstr)));
            if (0 != cbBstr)
            {
                IfFailRet(WriteToStream(*pbstrValue, cbBstr));
            }
        }
        else if (m_fPropertyBag)
        {
            varBstr.vt = VT_BSTR;
            if (NULL == *pbstrValue)
            {
                bstrEmpty = ::SysAllocString(L"");
                if (NULL == bstrEmpty)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
                varBstr.bstrVal = bstrEmpty;
            }
            else
            {
                varBstr.bstrVal = *pbstrValue;
            }
            hr = m_piPropertyBag->Write(pwszName, &varBstr);
            IfFailGo(hr);
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailRet(ReadFromStream(&cbBstr, sizeof(cbBstr)));
            if (0 == cbBstr)
            {
                bstrValue = ::SysAllocString(L"");
                if (NULL == bstrValue)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
            }
            else
            {
                // Allocate the total byte length + room for a null character
                pwszBstr = (WCHAR *)::CtlAllocZero(cbBstr + sizeof(*pwszBstr));
                if (NULL == pwszBstr)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
                IfFailGo(ReadFromStream(pwszBstr, cbBstr));

                // We create the null terminated string in the buffer and
                // then use SysAllocString() rather than using SysAllocStringLen()
                // so that SysStringLen() will return the number of characters
                // not including the terminating null. After allocating with
                // SysAllocStringLen() the value returned by SysStringLen() will
                // include the terminating null.

                bstrValue = ::SysAllocString(pwszBstr);
                if (NULL == bstrValue)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
            }
            FREESTRING(*pbstrValue);
            *pbstrValue = bstrValue;
        }
        else if (m_fPropertyBag)
        {
            hr = m_piPropertyBag->Read(pwszName, &varBstr, m_piErrorLog);
            IfFailGo(hr);
            if ( (VT_BSTR != varBstr.vt) || (NULL == varBstr.bstrVal) )
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            FREESTRING(*pbstrValue);
            *pbstrValue = varBstr.bstrVal;
        }
    }
    else if (m_fInitNew)
    {

        bstrValue = ::SysAllocString(pwszDefaultValue);
        if (NULL == bstrValue)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        FREESTRING(*pbstrValue);
        *pbstrValue = bstrValue;
    }

Error:
    if (FAILED(hr))
    {
        (void)::VariantClear(&varBstr);
    }
    FREESTRING(bstrEmpty);
    if (NULL != pwszBstr)
    {
        ::CtlFree(pwszBstr);
    }
    RRETURN(hr);
}

HRESULT CPersistence::PersistDouble
(
    DOUBLE    *pdblValue,
    DOUBLE     dblDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;

    VARIANT var;
    ::VariantInit(&var);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(WriteToStream(pdblValue, sizeof(*pdblValue)));
        }
        else if (m_fPropertyBag)
        {
            var.vt = VT_R8;
            var.dblVal = *pdblValue;
            IfFailGo(m_piPropertyBag->Write(pwszName, &var));
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailGo(ReadFromStream(pdblValue, sizeof(*pdblValue)));
        }
        else if (m_fPropertyBag)
        {
            IfFailGo(m_piPropertyBag->Read(pwszName, &var, m_piErrorLog));
            if (VT_R8 != var.vt)
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            *pdblValue = var.dblVal;
        }
    }
    else if (m_fInitNew)
    {
        *pdblValue = dblDefaultValue;
    }

Error:
    RRETURN(hr);
}



HRESULT CPersistence::PersistDate
(
    DATE      *pdtValue,
    DATE       dtDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;

    VARIANT var;
    ::VariantInit(&var);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(WriteToStream(pdtValue, sizeof(*pdtValue)));
        }
        else if (m_fPropertyBag)
        {
            var.vt = VT_DATE;
            var.date = *pdtValue;
            IfFailGo(m_piPropertyBag->Write(pwszName, &var));
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailGo(ReadFromStream(pdtValue, sizeof(*pdtValue)));
        }
        else if (m_fPropertyBag)
        {
            IfFailGo(m_piPropertyBag->Read(pwszName, &var, m_piErrorLog));
            if (VT_DATE != var.vt)
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            *pdtValue = var.date;
        }
    }
    else if (m_fInitNew)
    {
        *pdtValue = dtDefaultValue;
    }

Error:
    RRETURN(hr);
}


HRESULT CPersistence::PersistCurrency
(
    CURRENCY  *pcyValue,
    CURRENCY   cyDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;

    VARIANT var;
    ::VariantInit(&var);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(WriteToStream(pcyValue, sizeof(*pcyValue)));
        }
        else if (m_fPropertyBag)
        {
            var.vt = VT_DATE;
            var.cyVal = *pcyValue;
            IfFailGo(m_piPropertyBag->Write(pwszName, &var));
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailGo(ReadFromStream(pcyValue, sizeof(*pcyValue)));
        }
        else if (m_fPropertyBag)
        {
            IfFailGo(m_piPropertyBag->Read(pwszName, &var, m_piErrorLog));
            if (VT_DATE != var.vt)
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            *pcyValue = var.cyVal;
        }
    }
    else if (m_fInitNew)
    {
        *pcyValue = cyDefaultValue;
    }

Error:
    RRETURN(hr);
}


HRESULT CPersistence::WriteToStream
(
    void *pvBuffer,
    ULONG cbToWrite
)
{
    ULONG cbWritten = 0;
    HRESULT hr = m_piStream->Write(pvBuffer, cbToWrite, &cbWritten);
    GLOBAL_EXCEPTION_CHECK_GO(hr);
    if (cbWritten != cbToWrite)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK(hr);
    }
Error:
    RRETURN(hr);
}

HRESULT CPersistence::ReadFromStream
(
    void *pvBuffer,
    ULONG cbToRead
)
{
    ULONG cbRead = 0;
    HRESULT hr = m_piStream->Read(pvBuffer, cbToRead, &cbRead);
    GLOBAL_EXCEPTION_CHECK_GO(hr);
    if (cbRead != cbToRead)
    {
        hr = SID_E_INCOMPLETE_READ;
        GLOBAL_EXCEPTION_CHECK(hr);
    }
Error:
    RRETURN(hr);
}

HRESULT CPersistence::PersistVariant
(
    VARIANT   *pvarValue,
    VARIANT    varDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;
    VARTYPE  vt = VT_EMPTY;

    VARIANT varNew;
    ::VariantInit(&varNew);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(PersistSimpleType(&pvarValue->vt, vt, NULL));

            // If the VARIANT is empty then don't write its value to the stream
            IfFalseGo(VT_EMPTY != pvarValue->vt, S_OK);
            hr = StreamVariant(pvarValue->vt, pvarValue, varDefaultValue);
        }
        else if (m_fPropertyBag)
        {
            // If the VARIANT is empty then don't write it to the property bag
            IfFalseGo(VT_EMPTY != pvarValue->vt, S_OK);
            hr = m_piPropertyBag->Write(pwszName, pvarValue);
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailRet(PersistSimpleType(&vt, vt, NULL));

            // If the VARIANT is empty then don't read its value from the stream
            if (VT_EMPTY != vt)
            {
                IfFailRet(StreamVariant(vt, pvarValue, varDefaultValue));
            }
            pvarValue->vt = vt;
        }
        else if (m_fPropertyBag)
        {
            // If the property is not there then it is an empty VARIANT

            hr = m_piPropertyBag->Read(pwszName, &varNew, m_piErrorLog);
            if (E_INVALIDARG == hr)
            {
                // Property was not found, VARIANT must be empty. This could
                // also happen if the user hand edited the property in .DSR
                // file, deleted the .DCA file, and loaded the project.
                // varNew was already initialized to VT_EMPTY so the
                // VariantCopy() below will set the caller's VARIANT correctly.
                hr = S_OK;
            }
            IfFailGo(hr);
            hr = ::VariantCopy(pvarValue, &varNew);
            GLOBAL_EXCEPTION_CHECK(hr);
        }
    }
    else if (m_fInitNew)
    {
        hr = ::VariantCopy(pvarValue, &varDefaultValue);
        GLOBAL_EXCEPTION_CHECK(hr);
    }

Error:
    (void)::VariantClear(&varNew);
    RRETURN(hr);
}



HRESULT CPersistence::StreamVariant
(
    VARTYPE  vt,
    VARIANT *pvarValue,
    VARIANT  varDefaultValue
)
{
    HRESULT hr = S_OK;

    switch (vt)
    {
        case VT_I4:
            hr = PersistSimpleType(&pvarValue->lVal, varDefaultValue.lVal, NULL);
            break;

        case VT_UI1:
            hr = PersistSimpleType(&pvarValue->bVal, varDefaultValue.bVal, NULL);
            break;

        case VT_I2:
            hr = PersistSimpleType(&pvarValue->iVal, varDefaultValue.iVal, NULL);
            break;

        case VT_R4:
            hr = PersistSimpleType(&pvarValue->fltVal, varDefaultValue.fltVal, NULL);
            break;

        case VT_R8:
            hr = PersistDouble(&pvarValue->dblVal, varDefaultValue.dblVal, NULL);
            break;

        case VT_BOOL:
            hr = PersistSimpleType(&pvarValue->boolVal, varDefaultValue.boolVal, NULL);
            break;

        case VT_ERROR:
            hr = PersistSimpleType(&pvarValue->scode, varDefaultValue.scode, NULL);
            break;

        case VT_DATE:
            hr = PersistDate(&pvarValue->date, varDefaultValue.date, NULL);
            break;

        case VT_CY:
            hr = PersistCurrency(&pvarValue->cyVal, varDefaultValue.cyVal, NULL);
            break;

        case VT_BSTR:

            // If we are loading, there is no guarantee that the passed
            // VARIANT actually contains a BSTR. PersistBstr() will call
            // ::SysFreeString() on the current value of the property if
            // it is non-NULL. For a VARIANT initialized with ::VariantInit()
            // there could be junk in the bstrVal. So, we need to clear out
            // the VARIANT and set it to a VT_BSTR with a NULL bstrVal.

            if ( m_fLoading && (VT_BSTR != pvarValue->vt) )
            {
                hr = ::VariantClear(pvarValue);
                GLOBAL_EXCEPTION_CHECK_GO(hr);
                pvarValue->vt = VT_BSTR;
                pvarValue->bstrVal = NULL;
            }

            hr = PersistBstr(&pvarValue->bstrVal, varDefaultValue.bstrVal, NULL);
            break;

        case VT_UNKNOWN:
            hr = StreamObjectInVariant(&pvarValue->punkVal, IID_IUnknown);
            break;

        case VT_DISPATCH:
            hr = StreamObjectInVariant(
                            reinterpret_cast<IUnknown **>(&pvarValue->pdispVal),
                            IID_IDispatch);
            break;

        default:
            // We don't support any other types for VARIANT properties but this
            // is an internal programming error as the object should not have
            // allowed the property to be set to the unsupported type. Don't
            // return SID_E_INVALIDARG as it is not a user error.
            hr = SID_E_INTERNAL;
            GLOBAL_EXCEPTION_CHECK(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CPersistence::StreamObjectInVariant
(
    IUnknown **ppunkObject,
    REFIID     iidInterface
)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;
    IUnknown           *punkNewObject = NULL;
    CLSID               clsidObject = CLSID_NULL;

    if (m_fSaving)
    {
        if (NULL == *ppunkObject)
        {
            hr = SID_E_INVALID_VARIANT;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        hr = (*ppunkObject)->QueryInterface(IID_IPersistStreamInit,
                              reinterpret_cast<void **>(&piPersistStreamInit));
        if (FAILED(hr))
        {
            // If the object doesn't support IPersistStreamInit then change to
            // one of our errors that suggests checking the Persistable
            // property on VB implemented objects that might appear in a Tag
            // property.

            if (E_NOINTERFACE == hr)
            {
                hr = SID_E_OBJECT_NOT_PERSISTABLE;
            }
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        // Get the object's CLSID

        IfFailGo(piPersistStreamInit->GetClassID(&clsidObject));

        // We don't use OleSaveToStream() because it does not allow passing
        // the clear dirty flag

        hr = ::WriteClassStm(m_piStream, clsidObject);
        GLOBAL_EXCEPTION_CHECK_GO(hr);

        IfFailGo(piPersistStreamInit->Save(m_piStream, m_fClearDirty));
    }
    else if (m_fLoading)
    {
        // We can't use OleLoadFromStream() because we need some extra error
        // checking in case the object is not creatable. This would happen when
        // an object in a Tag property is VB implemented but not public and
        // creatable.

        // Load the CLSID

        hr = ::ReadClassStm(m_piStream, &clsidObject);
        GLOBAL_EXCEPTION_CHECK_GO(hr);

        // Create the object.
        
        hr = ::CoCreateInstance(clsidObject,
                                NULL, // no aggregation
                                CLSCTX_SERVER,
                                iidInterface,
                                reinterpret_cast<void **>(&punkNewObject));
        if (FAILED(hr))
        {
            // Translate "not registred" error to our own that suggests checking
            // the Instancing property on VB implemented objects.
            
            if (REGDB_E_CLASSNOTREG == hr)
            {
                hr = SID_E_OBJECT_NOT_PUBLIC_CREATABLE;
            }
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        // Attempt to load it from the stream.

        hr = punkNewObject->QueryInterface(IID_IPersistStreamInit,
                               reinterpret_cast<void **>(&piPersistStreamInit));
        if (FAILED(hr))
        {
            if (E_NOINTERFACE == hr)
            {
                hr = SID_E_OBJECT_NOT_PERSISTABLE;
            }
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(piPersistStreamInit->Load(m_piStream));

        QUICK_RELEASE(*ppunkObject);
        punkNewObject->AddRef();  // clean up below will call Release so add one
        *ppunkObject = punkNewObject;
    }
    else if (m_fInitNew)
    {
        *ppunkObject = NULL;
    }

Error:
    QUICK_RELEASE(piPersistStreamInit);
    QUICK_RELEASE(punkNewObject);
    RRETURN(hr);
}



HRESULT CPersistence::InternalPersistObject
(
    IUnknown  **ppunkObject,
    REFCLSID    clsidObject,
    UINT        idObject,
    REFIID      iidInterface,
    LPCOLESTR   pwszName
)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;

    VARIANT varObject;
    ::VariantInit(&varObject);


    if ( m_fSaving && (NULL != *ppunkObject) )
    {
        if (m_fStream)
        {
            hr = (*ppunkObject)->QueryInterface(IID_IPersistStreamInit,
                               reinterpret_cast<void **>(&piPersistStreamInit));
            IfFailGo(hr);

            hr = piPersistStreamInit->Save(m_piStream, m_fClearDirty);
            IfFailGo(hr);
        }
        else if (m_fPropertyBag)
        {
            varObject.vt = VT_UNKNOWN;
            varObject.punkVal = *ppunkObject;
            hr = m_piPropertyBag->Write(pwszName, &varObject);
            IfFailGo(hr);
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            // Create the object and get IPersistStreamInit on it

            IfFailGo(CreateObject(idObject,
                                  IID_IPersistStreamInit,
                                  &piPersistStreamInit));
            // Load the object
            
            IfFailGo(piPersistStreamInit->Load(m_piStream));

            // Get the requested interface to return to the caller

            QUICK_RELEASE(*ppunkObject);
            IfFailGo(piPersistStreamInit->QueryInterface(iidInterface,
                                        reinterpret_cast<void **>(ppunkObject)));
        }
        else if (m_fPropertyBag)
        {
            hr = m_piPropertyBag->Read(pwszName, &varObject, m_piErrorLog);
            IfFailGo(hr);
            if ( ((VT_UNKNOWN != varObject.vt) && (VT_DISPATCH != varObject.vt)) ||
                  (NULL == varObject.punkVal) )
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            QUICK_RELEASE(*ppunkObject);
            hr = varObject.punkVal->QueryInterface(iidInterface,
                                        reinterpret_cast<void **>(ppunkObject));
            varObject.punkVal->Release();
            IfFailGo(hr);
        }
    }
    else if (m_fInitNew)
    {
        // Create the object and get IPersistStreamInit on it

        IfFailGo(CreateObject(idObject,
                              IID_IPersistStreamInit,
                              &piPersistStreamInit));

        // Initialize the object
        
        hr = piPersistStreamInit->InitNew();
        IfFailGo(hr);

        QUICK_RELEASE(*ppunkObject);

        // Get the requested interface to return to the caller

        IfFailGo(piPersistStreamInit->QueryInterface(iidInterface,
                                        reinterpret_cast<void **>(ppunkObject)));
    }

Error:
    QUICK_RELEASE(piPersistStreamInit);
    RRETURN(hr);
}



HRESULT CPersistence::PersistPicture
(
    IPictureDisp **ppiPictureDisp,
    LPCOLESTR      pwszName
)
{
    HRESULT hr = S_OK;
    IPersistStream *piPersistStream = NULL;


    // The picture is not one of our objects and it is not co-creatable
    // so we can't use PersistObject(). If we are saving to
    // or loading from a property bag then PersistObject() can handle it. For
    // a stream we need to use IPersistStream::Save() and OleLoadPicture(). For
    // InitNew we create an empty bitmap so that the VB code will still run even
    // if the picture hasn't been set.

    if (InitNewing())
    {
        IfFailGo(::CreateEmptyBitmapPicture(ppiPictureDisp));
    }
    else
    {
        if (UsingPropertyBag())
        {
            hr = PersistObject(ppiPictureDisp, CLSID_NULL, 0, IID_IPictureDisp, pwszName);
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        else if (UsingStream())
        {
            if (Saving())
            {
                IfFailGo((*ppiPictureDisp)->QueryInterface(IID_IPersistStream,
                                  reinterpret_cast<void **>(&piPersistStream)));
                hr = piPersistStream->Save(GetStream(), GetClearDirty());
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            else
            {
                if (NULL != *ppiPictureDisp)
                {
                    (*ppiPictureDisp)->Release();
                    *ppiPictureDisp = NULL;
                }
                hr = ::OleLoadPicture(GetStream(), 0L, FALSE, IID_IPictureDisp, reinterpret_cast<void **>(ppiPictureDisp));
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
        }
    }

Error:
    QUICK_RELEASE(piPersistStream);
    RRETURN(hr);
}




BOOL CPersistence::Loading()
{
    return m_fLoading;
}

BOOL CPersistence::Saving()
{
    return m_fSaving;
}

BOOL CPersistence::InitNewing()
{
    return m_fInitNew;
}

BOOL CPersistence::UsingPropertyBag()
{
    return m_fPropertyBag;
}

BOOL CPersistence::UsingStream()
{
    return m_fStream;
}

IStream *CPersistence::GetStream()
{
    return m_piStream;
}

BOOL CPersistence::GetClearDirty()
{
    return m_fClearDirty;
}

void CPersistence::SetDirty()
{
    m_fDirty = TRUE;
}

void CPersistence::ClearDirty()
{
    m_fDirty = FALSE;
}

void CPersistence::SetMajorVersion(DWORD dwVerMajor)
{
    m_dwVerMajor = dwVerMajor;
    m_fDirty = TRUE;
}

DWORD CPersistence::GetMajorVersion()
{
    return m_dwVerMajor;
}

void CPersistence::SetMinorVersion(DWORD dwVerMinor)
{
    m_dwVerMinor = dwVerMinor;
    m_fDirty = TRUE;
}

DWORD CPersistence::GetMinorVersion()
{
    return m_dwVerMinor;
}


void CPersistence::SetStream(IStream *piStream)
{
    RELEASE(m_piPropertyBag);
    RELEASE(m_piErrorLog);
    m_fPropertyBag = FALSE;

    RELEASE(m_piStream);
    if (NULL != piStream)
    {
        piStream->AddRef();
    }
    m_piStream = piStream;
    m_fStream = TRUE;
    m_fClearDirty = TRUE;
}

void CPersistence::SetSaving()
{
    m_fInitNew = FALSE;
    m_fLoading = FALSE;
    m_fSaving = TRUE;
}



//=--------------------------------------------------------------------------=
//                      IPersistStreamInit Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CPersistence::GetClassID(CLSID *pClsid)
{
    *pClsid = m_Clsid;
    return S_OK;
}


STDMETHODIMP CPersistence::InitNew()
{
    HRESULT hr = S_OK;

    m_fInitNew = TRUE;
    hr = Persist();
    m_fInitNew = FALSE;

    RRETURN(hr);
}

STDMETHODIMP CPersistence::Load(IStream *piStream)
{
    HRESULT hr = S_OK;

    m_fLoading = TRUE;
    m_fStream = TRUE;
    m_piStream = piStream;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        m_fDirty = FALSE;
    }
    m_fLoading = FALSE;
    m_fStream = FALSE;
    m_piStream = NULL;

    RRETURN(hr);
}



STDMETHODIMP CPersistence::Save(IStream *piStream, BOOL fClearDirty)
{
    HRESULT hr = S_OK;

    m_fSaving = TRUE;
    m_fStream = TRUE;
    m_fClearDirty = fClearDirty;
    m_piStream = piStream;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        if (fClearDirty)
        {
            m_fDirty = FALSE;
        }
    }
    m_fSaving = FALSE;
    m_fStream = FALSE;
    m_fClearDirty = FALSE;
    m_piStream = NULL;

    RRETURN(hr);
}



STDMETHODIMP CPersistence::IsDirty()
{
    return m_fDirty;
}

STDMETHODIMP CPersistence::GetSizeMax(ULARGE_INTEGER* puliSize)
{
    puliSize->LowPart = 0xFFFFFFFF;
    puliSize->HighPart = 0xFFFFFFFF;
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      IPersistPropertyBag Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CPersistence::Load
(
    IPropertyBag *piPropertyBag,
    IErrorLog    *piErrorLog
)
{
    HRESULT hr = S_OK;

    m_fLoading = TRUE;
    m_fPropertyBag = TRUE;
    m_piPropertyBag = piPropertyBag;
    m_piErrorLog = piErrorLog;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        m_fDirty = FALSE;
    }
    m_fLoading = FALSE;
    m_fPropertyBag = FALSE;
    m_piPropertyBag = NULL;
    m_piErrorLog = NULL;

    RRETURN(hr);
}


STDMETHODIMP CPersistence::Save
(
    IPropertyBag *piPropertyBag,
    BOOL          fClearDirty,
    BOOL          fSaveAll
)
{
    HRESULT hr = S_OK;

    m_fSaving = TRUE;
    m_fPropertyBag = TRUE;
    m_piPropertyBag = piPropertyBag;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        m_fDirty = FALSE;
    }
    m_fSaving = FALSE;
    m_fPropertyBag = FALSE;
    m_piPropertyBag = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdefs.cpp ===
//=--------------------------------------------------------------------------=
// ocxvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ocxvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

COCXViewDefs::COCXViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>(
                                                 punkOuter,
                                                 OBJECT_TYPE_OCXVIEWDEFS,
                                                 static_cast<IOCXViewDefs *>(this),
                                                 static_cast<COCXViewDefs *>(this),
                                                 CLSID_OCXViewDef,
                                                 OBJECT_TYPE_OCXVIEWDEF,
                                                 IID_IOCXViewDef,
                                                 static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_OCXViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


COCXViewDefs::~COCXViewDefs()
{
}

IUnknown *COCXViewDefs::Create(IUnknown * punkOuter)
{
    COCXViewDefs *pOCXViewDefs = New COCXViewDefs(punkOuter);
    if (NULL == pOCXViewDefs)
    {
        return NULL;
    }
    else
    {
        return pOCXViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDefs::Persist()
{
    HRESULT      hr = S_OK;
    IOCXViewDef *piOCXViewDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>::Persist(piOCXViewDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IOCXViewDefs == riid)
    {
        *ppvObjOut = static_cast<IOCXViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>::GetMaster(IOCXViewDefs **ppiMasterOCXViewDefs)
{
    H_RRETURN(GetOCXViewDefs(ppiMasterOCXViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\persobj.h ===
//=--------------------------------------------------------------------------=
// persobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPersistence class definition - implements persistence on behalf of all
// objects.
//
//=--------------------------------------------------------------------------=

#ifndef _PERSOBJ_DEFINED_
#define _PERSOBJ_DEFINED_

#include <ipserver.h>
#include "errors.h"
#include "error.h"

// These are the persistence version numbers written into the .DSR and into
// the runtime state. When changing the object model, these numbers must be
// incremented and persistence code that uses the changes must check the
// version number before attempting to read new properties.

const DWORD g_dwVerMajor = 0;
const DWORD g_dwVerMinor = 12;

// Need to disable the following warning:
//
// warning C4275: non dll-interface struct 'IPersistStreamInit' used as base
// for dll-interface class 'CPersistence'
//
// This occurs because the exported class CPersistence derives from a COM
// interface that is not exported. As a COM interface is a virtual base class
// that has no implementation this will not matter.

#pragma warning(disable:4275) 

class CPersistence : public IPersistStreamInit,
                     public IPersistStream,
                     public IPersistPropertyBag
{
    protected:

        CPersistence(const CLSID *pClsid,
                           DWORD  dwVerMajor,
                           DWORD  dwVerMinor);

        ~CPersistence();

        // Derived classes can use this utility function to test for
        // persistence interfaces requests in their QI methods.

        HRESULT QueryPersistenceInterface(REFIID riid, void **ppvInterface);

        // Derived classes must override this and make the appropriate
        // Persist() calls (see below)

        virtual HRESULT Persist();

        // Persistence helpers. These are called regardless of whether the
        // operation is InitNew, save, or load.

    public:

        HRESULT PersistBstr(BSTR *pbstrValue, WCHAR *pwszDefaultValue, LPCOLESTR pwszName);

        HRESULT PersistDouble(DOUBLE *pdblValue, DOUBLE dblDefaultValue, LPCOLESTR pwszName);

        HRESULT PersistDate(DATE *pdtValue, DATE dtDefaultValue,
                            LPCOLESTR  pwszName);

        HRESULT PersistCurrency(CURRENCY *pcyValue, CURRENCY cyDefaultValue,
                                LPCOLESTR  pwszName);

        HRESULT PersistVariant(VARIANT *pvarValue, VARIANT varDefaultValue, LPCOLESTR pwszName);

        HRESULT PersistPicture(IPictureDisp **ppiPictureDisp, LPCOLESTR pwszName);

        template <class SimpleType>
        HRESULT PersistSimpleType(SimpleType *pValue,
                                  SimpleType  DefaultValue,
                                  LPCOLESTR   pwszName)
        {
            HRESULT       hr = S_OK;
            unsigned long ulValue = 0;
            VARIANT       var;
            ::VariantInit(&var);

            if (sizeof(*pValue) > sizeof(long))
            {
                hr = SID_E_INTERNAL;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }

            if (m_fSaving)
            {
                if (m_fStream)
                {
                    hr = WriteToStream(pValue, sizeof(*pValue));
                }
                else if (m_fPropertyBag)
                {
                    var.vt = VT_I4;
                    ulValue = static_cast<unsigned long>(*pValue);
                    var.lVal = static_cast<long>(ulValue);
                    hr = m_piPropertyBag->Write(pwszName, &var);
                }
            }
            else if (m_fLoading)
            {
                if (m_fStream)
                {
                    hr = ReadFromStream(pValue, sizeof(*pValue));
                }
                else if (m_fPropertyBag)
                {
                    // Read the property from the bag

                    hr = m_piPropertyBag->Read(pwszName, &var, m_piErrorLog);
                    H_IfFailGo(hr);

                    // Coerce the type received into VT_I4. This is needed
                    // because the property bag will read the number from the
                    // text and convert it to a VT that fits. For example, "0"
                    // could be converted to VT_I2.

                    H_IfFailGo(::VariantChangeType(&var, &var, 0, VT_I4));

                    ulValue = static_cast<long>(var.lVal);
                    *pValue = static_cast<SimpleType>(ulValue);
                }
            }
            else if (m_fInitNew)
            {
                *pValue = DefaultValue;
            }

        Error:
            ::VariantClear(&var);
            H_RRETURN(hr);
        }
                
        template <class InterfaceType>
        HRESULT PersistObject(InterfaceType **ppiInterface,
                              REFCLSID        clsidObject,
                              UINT            idObject,
                              REFIID          iidInterface,
                              LPCOLESTR       pwszName)
        {
            return
            InternalPersistObject(reinterpret_cast<IUnknown **>(ppiInterface),
                                  clsidObject, idObject, iidInterface, pwszName);
        }


        // If the derived class needs to hand code part of the persistence
        // operation it can use these methods
        
        BOOL Loading();
        BOOL Saving();
        BOOL InitNewing();
        BOOL UsingPropertyBag();
        BOOL UsingStream();
        IStream *GetStream();
        BOOL GetClearDirty();


        // These methods are meant to be used by CStreamer (see below) users to
        // set up the base CPersistence class to save to a specified stream
        // outside of an actual persistence scenario.
        
        void SetStream(IStream *piStream);
        void SetSaving();

        // Use StreamVariant to write the VARIANT's data without prepending the
        // type. Use PersistVariant() to write the type followed by the data.
        
        HRESULT StreamVariant(VARTYPE vt, VARIANT *pvarValue, VARIANT varDefaultValue);

        // Version property access
        void SetMajorVersion(DWORD dwVerMajor);
        DWORD GetMajorVersion();
        void SetMinorVersion(DWORD dwVerMinor);
        DWORD GetMinorVersion();

    // Methods to manipulate the dirty flag.

        void SetDirty();
        void ClearDirty();


    // IPersistStream && IPersistStreamInit
    //
    protected:
        STDMETHOD(GetClassID)(CLSID *pCLSID);
        STDMETHOD(InitNew)();
        STDMETHOD(Load)(IStream *piStream);
        STDMETHOD(Save)(IStream *piStream, BOOL fClearDirty);
        STDMETHOD(IsDirty)();
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *puliSize);

    // IPersistPropertyBag
    //
        STDMETHOD(Load)(IPropertyBag *piPropertyBag, IErrorLog *piErrorLog);
        STDMETHOD(Save)(IPropertyBag *piPropertyBag, BOOL fClearDirty, BOOL fSaveAll);

    private:

        void InitMemberVariables();
        HRESULT InternalPersistObject(IUnknown **ppunkObject,
                                      REFCLSID   clsidObject,
                                      UINT       idObject,
                                      REFIID     iidInterface,
                                      LPCOLESTR  pwszName);
        HRESULT WriteToStream(void *pvBuffer, ULONG cbToWrite);
        HRESULT ReadFromStream(void *pvBuffer, ULONG cbToRead);
        HRESULT StreamObjectInVariant(IUnknown **ppunkObject,
                                      REFIID     iidInterface);

        DWORD            m_dwVerMajor;    // major persistence version of object
        DWORD            m_dwVerMinor;    // minor persistence version of object
        CLSID            m_Clsid;         // CLSID of object
        BOOL             m_fDirty;        // TRUE=object needs to be saved
        BOOL             m_fClearDirty;   // TRUE=in IPersistStreamIni::Save
                                          // with clear diry requested
        BOOL             m_fLoading;      // TRUE=in IPersistXxx::Load
        BOOL             m_fSaving;       // TRUE=in IPersistXxx::Save
        BOOL             m_fInitNew;      // TRUE=in IPersistXxx::InitNew
        BOOL             m_fStream;       // TRUE=doing IPersistStreamInit i/o
        BOOL             m_fPropertyBag;  // TRUE=doing IPersistPropertyBag i/o
        IStream         *m_piStream;      // Used for IPersistStreamInit i/o
        IPropertyBag    *m_piPropertyBag; // Used for IPersistPropertyBag i/o
        IErrorLog       *m_piErrorLog;    // Used for IPersistPropertyBag i/o
};

#pragma warning(default:4275) 

//=--------------------------------------------------------------------------=
// class CStreamer
// 
// This class is a simple derivation of CPersistence that allows using it
// as a utility for its ability to write all sorts of data types to a stream
// To use CStreamer, call New, and then SetStream() (a CPersistence method)
// passing your stream. You can then call all the CPersistence::PersistXxxx
// helper methods without being in an actual persistence scenario.
//
//=--------------------------------------------------------------------------=

class CStreamer : public CPersistence,
                  public CtlNewDelete
{
    public:
        CStreamer() : CPersistence(&CLSID_NULL, 0, 0) { SetSaving(); }
        virtual ~CStreamer() {}

    private:
       STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { return E_NOTIMPL; }
       STDMETHOD_(ULONG, AddRef)(void) { return 0; }
       STDMETHOD_(ULONG, Release)(void) { return 0; }
};

#endif // _PERSOBJ_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ppgwrap.cpp ===
//=--------------------------------------------------------------------------=
// ppgwrap.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertyPageWrapper class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ppgwrap.h"
#include "tls.h"

// for ASSERT and FAIL
//
SZTHISFILE

const UINT CPropertyPageWrapper::m_RedrawMsg = ::RegisterWindowMessage("Microsoft Visual Basic Snap-in Designer Property Page Redraw Message");
const UINT CPropertyPageWrapper::m_InitMsg = ::RegisterWindowMessage("Microsoft Visual Basic Snap-in Designer Property Page Init Message");
   
DLGTEMPLATE CPropertyPageWrapper::m_BaseDlgTemplate =
{
    WS_TABSTOP | WS_CHILD | DS_CONTROL, // DWORD style;
    WS_EX_CONTROLPARENT,                // DWORD dwExtendedStyle;
    0,          // WORD cdit; - no controls in this dialog box
    0,          // short x; dimensions are set per IPropertyPage::GetPageInfo()
    0,          // short y;
    0,          // short cx;
    0           // short cy;
};

#define MAX_DLGS 128

// Definition of data stored in TLS for each thread that displays property pages

typedef struct
{
    HHOOK                 hHook;        // HHOOK for this thread
    UINT                  cPages;       // number of existing property pages
    CPropertyPageWrapper *ppgActive;    // ptr to the currently active page
} TLSDATA;


// These resource IDs are taken from \nt\private\shell\comctl32\rcids.h.
// We need to know the IDs of the Back, Next and Finish buttons on a wizard
// or else we can't make tabbing work. This is a nasty dependency but there is
// no other way to handle this.

#define IDD_BACK		0x3023
#define IDD_NEXT		0x3024
#define IDD_FINISH		0x3025


//***************************************************************************
// CPropertyPageMarshalHelper
// 
//
// PURPOSE: Keeps pointers to all interfaces to be marshaled. This is because
//          They must be unmarshaled *immediately* before use - CoMarshalInterThreadInterfaceInStream
//          has a timeout of 5-6 minutes, after which the pointer is invalidated.
//
// NOTE:    All methods on this object must be called on the same thread.
//
//****************************************************************************
class CPropertyPageMarshalHelper
{
    enum {WM_MARSHAL = WM_USER + 1};

public:
    CPropertyPageMarshalHelper() : 
        m_pSnapIn(NULL),
        m_pMMCPropertySheet(NULL),
        m_pUnknown(NULL),
        m_pDispatch(NULL),
        m_cObjects(0), 
        m_rgpObjects(NULL),
        m_hDataWindow(NULL)
    {
    }

    ~CPropertyPageMarshalHelper()
    {
        ReleaseAll();
    }

    // just caches, the actual marshaling happens during Unmarshal
    HRESULT Initialize( ISnapIn         *piSnapIn, 
                        CPropertySheet  *pPropertySheet,
                        ULONG            cObjects,
                        IUnknown       **apunkObjects,
                        IUnknown        *pUnknown,                    
                        IDispatch       *pDispatch
                        )
    {
        HRESULT hr = S_OK;

        // create the hidden window
        IfFailGo(CreateHiddenWindow());

        // only one of pUnknown and pDispatch can be non-NULL.
        if( (pUnknown != NULL)  && (pDispatch != NULL))
            return E_FAIL;

        if(piSnapIn)
        {
            m_pSnapIn = piSnapIn;
            m_pSnapIn->AddRef();
        }

        if(pPropertySheet)
        {
            m_pMMCPropertySheet = static_cast<IMMCPropertySheet *>(pPropertySheet);
            m_pMMCPropertySheet->AddRef();
        }

        // We check for NULL because the object may have come from an
        // IPropertySheet:AddWizardPage() which allows the VB dev to specify the
        // object.

        IfFalseGo(NULL != apunkObjects, S_OK);

        m_cObjects = 0;

        m_rgpObjects = new LPUNKNOWN[cObjects];
        if(!m_rgpObjects)
            return E_FAIL;

        for(ULONG i = 0; i< cObjects; ++i)
        {
            m_rgpObjects[i] = apunkObjects[i];
            m_rgpObjects[i]->AddRef();
        }

        // if we succeeded, update the count.
        m_cObjects = cObjects;

        if(pUnknown)
        {
            m_pUnknown = pUnknown;
            m_pUnknown->AddRef();
        }

        else if(pDispatch)
        {
            m_pDispatch = pDispatch;
            m_pDispatch->AddRef();
        }

    Error:

        RRETURN(hr);
    }

    HRESULT Marshal(CPropertyPageWrapper &wrapper)
    {
        if(!m_hDataWindow)
            return E_FAIL;

        ::SendMessage(m_hDataWindow, WM_MARSHAL, (WPARAM) this, (LPARAM)&wrapper);
        return S_OK;
    }

private:
   // marshals all the pointers into the wrapper object
    HRESULT _Marshal(CPropertyPageWrapper &wrapper)
    {
        HRESULT hr = S_OK;
        // If this is a wizard then we have the ISnapIn so we can fire
        // ConfigurationComplete. Marshal the interface into a stream
        // and save the stream so that we can unmarshal it when the page is
        // created in MMC's property sheet thread. The returned IStream is free
        // threaded and can be kept in a member variable.

        if (NULL != m_pSnapIn)
        {
            hr = ::CoMarshalInterThreadInterfaceInStream(IID_ISnapIn,
                                                         m_pSnapIn,
                                                         &wrapper.m_piSnapInStream);
            IfFailGo(hr);
        }

        // Also need to marhshal the IMMCPropertySheet pointer that will be
        // passed to IMMCPropertyPage::Initialize as that call will occur during
        // WM_INITDIALOG which happens in MMC's property sheet thread.

        if (NULL != m_pMMCPropertySheet)
        {
            hr = ::CoMarshalInterThreadInterfaceInStream(IID_IMMCPropertySheet,
                                                         m_pMMCPropertySheet,
                                                         &wrapper.m_piMMCPropertySheetStream);
            IfFailGo(hr);
        }

        // Marshal the objects' IUnknown pointers into streams. The returned
        // IStreams are free threaded and can be kept in a member variable.
        //
        // When the dialog is created, each IUnknown will be unmarshalled and passed
        // to the property page in IPropertyPage::SetObjects().
        //

        wrapper.m_apiObjectStreams = (IStream **)CtlAllocZero(m_cObjects * sizeof(IStream *));
        if (NULL == wrapper.m_apiObjectStreams)
        {
            hr = SID_E_OUTOFMEMORY;
            IfFailGo(hr);
        }
        wrapper.m_cObjects = m_cObjects;

        for (ULONG i = 0; i < m_cObjects; i++)
        {
            hr = ::CoMarshalInterThreadInterfaceInStream(IID_IUnknown,
                                                         m_rgpObjects[i],
                                                         &wrapper.m_apiObjectStreams[i]);
            IfFailGo(hr);
        }

        // If there is an object in InitData then it also needs to be marshaled.

        if (NULL != m_pUnknown)
        {
            wrapper.m_varInitData.vt = VT_UNKNOWN;
            wrapper.m_varInitData.punkVal = NULL;

            hr = ::CoMarshalInterThreadInterfaceInStream(IID_IUnknown,
                                                         m_pUnknown,
                                                         &wrapper.m_piInitDataStream);
            IfFailGo(hr);
        }
        else if (NULL != m_pDispatch)
        {
            wrapper.m_varInitData.vt = VT_DISPATCH;
            wrapper.m_varInitData.punkVal = NULL;

            hr = ::CoMarshalInterThreadInterfaceInStream(IID_IDispatch,
                                                         m_pDispatch,
                                                         &wrapper.m_piInitDataStream);
            IfFailGo(hr);
        }

    Error:
        ReleaseAll();
        RRETURN(hr);

    }

private:
    void ReleaseAll()
    {
        if(m_pSnapIn)
        {
            m_pSnapIn->Release();
            m_pSnapIn = NULL;
        }

        if(m_pMMCPropertySheet)
        {
            m_pMMCPropertySheet->Release();
            m_pMMCPropertySheet = NULL;
        }

        if(m_pUnknown)
        {
            m_pUnknown->Release();
            m_pUnknown = NULL;
        }

        if(m_pDispatch)
        {
            m_pDispatch->Release();
            m_pDispatch = NULL;
        }

        if(m_rgpObjects)
        {
            for(ULONG i = 0; i<m_cObjects; i++)
            {
                if(m_rgpObjects[i])
                    m_rgpObjects[i]->Release();
            }
            delete[] m_rgpObjects;
            m_rgpObjects = NULL;
            m_cObjects = 0;
        }

        if(m_hDataWindow)
        {
            ::DestroyWindow(m_hDataWindow);
            m_hDataWindow = NULL;

            // MUST unregister the window class
            TCHAR szModuleName[MAX_PATH] = {0};

            DWORD dw = GetModuleFileName(NULL, szModuleName, MAX_PATH);
            if(!dw)
                return; // ignore errors

            HINSTANCE hInstance = GetModuleHandle(szModuleName);
            LPCTSTR DATAWINDOW_CLASS_NAME = TEXT("VBDesignerHiddenWindow");
            if(!UnregisterClass(DATAWINDOW_CLASS_NAME, hInstance))
            {
                // ignore errors.
            }


        }
    }


    HRESULT CreateHiddenWindow()
    {
        WNDCLASS wndClass;
        TCHAR szModuleName[MAX_PATH] = {0};

        DWORD dw = GetModuleFileName(NULL, szModuleName, MAX_PATH);
        if(!dw)
            return E_FAIL;

        HINSTANCE hInstance = GetModuleHandle(szModuleName);
        LPCTSTR DATAWINDOW_CLASS_NAME = TEXT("VBDesignerHiddenWindow");


        if (!GetClassInfo(hInstance, DATAWINDOW_CLASS_NAME, &wndClass))
        {
            ZeroMemory(&wndClass, sizeof(wndClass));
            wndClass.lpfnWndProc   = DataWndProc;

            wndClass.cbWndExtra    = 0;
            wndClass.hInstance     = hInstance;
            wndClass.lpszClassName = DATAWINDOW_CLASS_NAME;

            if (!RegisterClass(&wndClass))
                return E_FAIL;
        }

        m_hDataWindow = CreateWindowEx (WS_EX_APPWINDOW, DATAWINDOW_CLASS_NAME,
                                        NULL, WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                        CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL,
                                        hInstance, NULL);

        if(!m_hDataWindow)
            return E_FAIL;

        return S_OK;
    }

    static LRESULT CALLBACK DataWndProc(HWND hWnd, UINT nMsg, WPARAM  wParam, LPARAM  lParam)
    {
        if(nMsg == WM_MARSHAL)
        {
            CPropertyPageMarshalHelper *pHelper = (CPropertyPageMarshalHelper *) wParam;
            CPropertyPageWrapper* pWrapper      = (CPropertyPageWrapper *) lParam;

            pHelper->_Marshal(*pWrapper);
        }
        return DefWindowProc(hWnd, nMsg, wParam, lParam);
    }
        



private:
    ISnapIn*                m_pSnapIn;
    IMMCPropertySheet*      m_pMMCPropertySheet;
    IUnknown*               m_pUnknown;
    IDispatch*              m_pDispatch;

    ULONG                   m_cObjects;
    IUnknown* *             m_rgpObjects; // the count of this array is m_cObjects

    HWND                    m_hDataWindow; // the message window
};



#pragma warning(disable:4355)  // using 'this' in constructor

CPropertyPageWrapper::CPropertyPageWrapper(IUnknown *punkOuter) :
   m_pHelper(NULL),
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_PROPERTYPAGEWRAPPER,
                           static_cast<IPropertyPageSite *>(this),
                           static_cast<CPropertyPageWrapper *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CPropertyPageWrapper::Create(IUnknown *punkOuter)
{
    HRESULT        hr = S_OK;
    CPropertyPageWrapper *pPropertyPage = New CPropertyPageWrapper(punkOuter);

    if (NULL == pPropertyPage)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if ( (0 == m_RedrawMsg) || (0 == m_InitMsg) )
    {
        hr = SID_E_SYSTEM_ERROR;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pPropertyPage)
        {
            delete pPropertyPage;
        }
        return NULL;
    }
    else
    {
        return pPropertyPage->PrivateUnknown();
    }
}

CPropertyPageWrapper::~CPropertyPageWrapper()
{
    ULONG     i = 0;
    IUnknown *punkObject = NULL; // Don't Release

    if(m_pHelper)
    {
        delete m_pHelper;
        m_pHelper = NULL;
    }

    // Remove this dialog from the message hook TLS data. If there are
    // no more dialogs remaining then remove the hook. This should have happened
    // in OnDestroy during WM_DESTROY processing but just in case we double
    // check here.

    (void)RemoveMsgFilterHook();

    if (NULL != m_pPropertySheet)
    {
        m_pPropertySheet->Release();
    }

    if (NULL != m_pTemplate)
    {
        ::CtlFree(m_pTemplate);
    }

    // If the marshaling streams are still alive then we need to release
    // the marshal data. The easiest way to do this is to simply unmarshal
    // the interface pointer. We do this before releasing the held pointers
    // below. This case is actually not that rare because it can easily occur
    // if the user displays a multi-page property sheet and doesn't click
    // on all the tabs. In that case, the streams were created before the
    // pages were created but as no WM_INITDIALOG was received, they were
    // never unmarshaled. This can also occur in a wizard where the user
    // clicks cancel before visiting all of the pages in the wizard.

    if (NULL != m_apiObjectStreams)
    {
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != m_apiObjectStreams[i])
            {
                (void)::CoGetInterfaceAndReleaseStream(
                                        m_apiObjectStreams[i],
                                        IID_IUnknown,
                                        reinterpret_cast<void **>(&punkObject));
                m_apiObjectStreams[i] = NULL;
                RELEASE(punkObject);
            }
        }
        CtlFree(m_apiObjectStreams);
    }
    
    if (NULL != m_piSnapInStream)
    {
        (void)::CoGetInterfaceAndReleaseStream(m_piSnapInStream,
                                               IID_ISnapIn,
                                        reinterpret_cast<void **>(&m_piSnapIn));
        m_piSnapInStream = NULL;
    }

    if ( ISPRESENT(m_varInitData) && (NULL != m_piInitDataStream) )
    {
        if (VT_UNKNOWN == m_varInitData.vt)
        {
            m_varInitData.punkVal = NULL;
            (void)::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                                                   IID_IUnknown,
                             reinterpret_cast<void **>(&m_varInitData.punkVal));
        }
        else if (VT_DISPATCH == m_varInitData.vt)
        {
            m_varInitData.pdispVal = NULL;
            (void)::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                                                   IID_IDispatch,
                            reinterpret_cast<void **>(&m_varInitData.pdispVal));
        }
        m_piInitDataStream = NULL;
    }

    if (NULL != m_piMMCPropertySheetStream)
    {
        (void)::CoGetInterfaceAndReleaseStream(m_piMMCPropertySheetStream,
                                               IID_IMMCPropertySheet,
                              reinterpret_cast<void **>(&m_piMMCPropertySheet));
        m_piMMCPropertySheetStream = NULL;
    }

    RELEASE(m_piSnapIn);
    RELEASE(m_pdispConfigObject);
    RELEASE(m_piPropertyPage);
    RELEASE(m_piMMCPropertyPage);
    RELEASE(m_piMMCPropertySheet);
    RELEASE(m_piWizardPage);

    (void)::VariantClear(&m_varInitData);

    InitMemberVariables();
}



void CPropertyPageWrapper::InitMemberVariables()
{
    m_pPropertySheet = NULL;
    m_piPropertyPage = NULL;
    m_piMMCPropertyPage = NULL;
    m_piMMCPropertySheet = NULL;
    m_piWizardPage = NULL;
    m_fWizard = FALSE;
    m_cObjects = 0;
    m_apiObjectStreams = NULL;
    m_piSnapInStream = NULL;
    m_piInitDataStream = NULL;
    m_piMMCPropertySheetStream = NULL;
    m_piSnapIn = NULL;
    m_pdispConfigObject = NULL;
    m_pTemplate = NULL;
    m_hwndDlg = NULL;
    m_hwndSheet = NULL;
    m_clsidPage = CLSID_NULL;
    ::VariantInit(&m_varInitData);
    m_fIsRemote = FALSE;
    m_fNeedToRemoveHook = FALSE;
}


HRESULT CPropertyPageWrapper::CreatePage
(
    CPropertySheet  *pPropertySheet,
    CLSID            clsidPage,
    BOOL             fWizard,
    BOOL             fConfigWizard,
    ULONG            cObjects,
    IUnknown       **apunkObjects,
    ISnapIn         *piSnapIn,
    short            cxPage,
    short            cyPage,
    VARIANT          varInitData,
    BOOL             fIsRemote,
    DLGTEMPLATE    **ppTemplate
)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;

    // AddRef and store the owning property sheet pointer

    if (NULL != m_pPropertySheet)
    {
        m_pPropertySheet->Release();
    }
    if (NULL == pPropertySheet)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    pPropertySheet->AddRef();
    m_pPropertySheet = pPropertySheet;

    m_fWizard = fWizard;
    m_fConfigWizard = fConfigWizard;
    m_fIsRemote = fIsRemote;

    // Store the page's CLSID so that OnInitDialog() will have access to it
    // to create the real instance of the page. We cannot create the real
    // instance here because we are not running in the thread that will be used
    // for the property sheet. MMC will run the property sheet in a new thread
    // that it will create in order to keep it modeless and so that it will not
    // affect the console.

    m_clsidPage = clsidPage;

    // Create the dialog template and initialize it with common values

    m_pTemplate = (DLGTEMPLATE *)::CtlAllocZero(sizeof(m_BaseDlgTemplate) +
                                 (3 * sizeof(int))); // for menu, class, title

    if (NULL == m_pTemplate)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(m_pTemplate, &m_BaseDlgTemplate, sizeof(*m_pTemplate));

    m_pTemplate->cx = cxPage;
    m_pTemplate->cy = cyPage;

    IUnknown  *pUnknown  = NULL;
    IDispatch *pDispatch = NULL;

    // If there is an object in InitData then it also needs to be marshaled.
    if (VT_UNKNOWN == varInitData.vt)
    {
        pUnknown = varInitData.punkVal;
    }
    else if (VT_DISPATCH == varInitData.vt)
    {
        pDispatch = varInitData.pdispVal;
    }

    m_pHelper = new CPropertyPageMarshalHelper;
    if(!m_pHelper)
        IfFailGo(hr = E_OUTOFMEMORY);

    hr = m_pHelper->Initialize(piSnapIn, 
                       pPropertySheet, 
                       cObjects, 
                       apunkObjects, 
                       pUnknown,
                       pDispatch);
    if(FAILED(hr))
        goto Error;

    // Add a ref to ourselves. We need to do this because otherwise no one
    // else can be depended on to keep this object alive until the Win32
    // property page is created by MMC's PropertSheet() call.

    ExternalAddRef();

    // save the (unmarshaled) data. If the data needed marshaling, it has
    // been taken care of by the helper.
    if( (VT_UNKNOWN != varInitData.vt) && (VT_DISPATCH != varInitData.vt) )
    {
        hr = ::VariantCopy(&m_varInitData, &varInitData);
        EXCEPTION_CHECK_GO(hr);
    }

Error:

    // We return the DLGTEMPLATE pointer to the caller even though we own it.
    // The caller must only use it as long as we are alive.
    
    *ppTemplate = m_pTemplate;

    RRETURN(hr);
}




BOOL CALLBACK CPropertyPageWrapper::DialogProc
(
    HWND   hwndDlg,
    UINT   uiMsg,
    WPARAM wParam,
    LPARAM lParam
)
{

    HRESULT               hr = S_OK;
    BOOL                  fDlgProcRet = FALSE;
    CPropertyPageWrapper *pPropertyPageWrapper = NULL;
    NMHDR                *pnmhdr = NULL;
    LRESULT               lresult = 0;

    if (WM_INITDIALOG == uiMsg)
    {
        if (NULL != hwndDlg)
        {
            fDlgProcRet = FALSE; // System should not set focus to any control

            // Get this pointer of CPropertyPageWrapper instance managing this
            // dialog. For property pages, lParam is a pointer to the
            // PROPSHEETPAGE used to define this page. The code in
            // CPropertySheet::AddPage put our this pointer into
            // PROPSHEETPAGE.lParam.

            PROPSHEETPAGE *pPropSheetPage =
                                       reinterpret_cast<PROPSHEETPAGE *>(lParam);
            pPropertyPageWrapper =
                reinterpret_cast<CPropertyPageWrapper *>(pPropSheetPage->lParam);

            IfFailGo(pPropertyPageWrapper->OnInitDialog(hwndDlg));

            // Post ourselves a message so that we can initialize the page
            // after the dialog creation has completed.
            
            (void)::PostMessage(hwndDlg, m_InitMsg, 0, 0);
        }
    }
    else if (m_RedrawMsg == uiMsg)
    {
        // See comment for WM_ERASEBKGND below. We don't really have access to
        // the property page's HWND because IPropertyPage does not allow that.
        // We do know that our dialog window contains no controls and we set it
        // as the parent of the property page so it must be our only child.
        // Generate an immediate redraw for the entire area of our child and all
        // of its children. Cancel any pending WM_ERASEBKGND messages by
        // specifying RDW_NOERASE.

        fDlgProcRet = TRUE;
        ::RedrawWindow(::GetWindow(hwndDlg, GW_CHILD), NULL, NULL,
                 RDW_INVALIDATE | RDW_NOERASE | RDW_UPDATENOW | RDW_ALLCHILDREN);
    }
    else
    {
        pPropertyPageWrapper = reinterpret_cast<CPropertyPageWrapper *>(
                                             ::GetWindowLong(hwndDlg, DWL_USER));
        IfFalseGo(NULL != pPropertyPageWrapper, SID_E_INTERNAL);

        if (m_InitMsg == uiMsg)
        {
            IfFailGo(pPropertyPageWrapper->OnInitMsg());
            goto Cleanup;
        }

        switch (uiMsg)
        {
            case WM_ERASEBKGND:
            {
                // Under a debug session property pages are erased and never
                // redrawn for some unknown reason. After much hair-pulling it
                // was determined that the work-around is to post ourselves a
                // message and force a redraw when that message is processed.

                (void)::PostMessage(hwndDlg, m_RedrawMsg, 0, 0);
            }
            break;

            case WM_SIZE:
            {
                fDlgProcRet = TRUE;
                IfFailGo(pPropertyPageWrapper->OnSize());
            }
            break;
            
            case WM_DESTROY:
            {
                fDlgProcRet = TRUE;
                IfFailGo(pPropertyPageWrapper->OnDestroy());
            }
            break;

            // Pass all CTLCOLOR messages to parent. This is what
            // OLE property frame does.

            case WM_CTLCOLORMSGBOX:
            case WM_CTLCOLOREDIT:
            case WM_CTLCOLORLISTBOX:
            case WM_CTLCOLORBTN:
            case WM_CTLCOLORDLG:
            case WM_CTLCOLORSCROLLBAR:
            case WM_CTLCOLORSTATIC:
            {
                fDlgProcRet = TRUE;
                ::SendMessage(::GetParent(hwndDlg), uiMsg, wParam, lParam);
            }
            break;

            case WM_NOTIFY:
            {
                pnmhdr = reinterpret_cast<NMHDR *>(lParam);
                IfFalseGo(NULL != pnmhdr, SID_E_SYSTEM_ERROR);

                // Check that the message is from the property sheet

                IfFalseGo(pnmhdr->hwndFrom == pPropertyPageWrapper->m_hwndSheet, S_OK);

                // Branch out to the appropriate handler

                switch (pnmhdr->code)
                {
                    case PSN_APPLY:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnApply(&lresult));
                        break;

                    case PSN_SETACTIVE:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnSetActive(
                                       ((PSHNOTIFY *)lParam)->hdr.hwndFrom, &lresult));
                        break;

                    case PSN_KILLACTIVE:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnKillActive(&lresult));
                        break;

                    case PSN_WIZBACK:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnWizBack(&lresult));
                        break;

                    case PSN_WIZNEXT:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnWizNext(&lresult));
                        break;

                    case PSN_WIZFINISH:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnWizFinish(&lresult));
                        break;

                    case PSN_QUERYCANCEL:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnQueryCancel(&lresult));
                        break;

                    case PSN_RESET:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnReset((BOOL)(((PSHNOTIFY *)lParam)->lParam)));
                        break;

                    case PSN_HELP:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnHelp());
                        break;

                } // switch (pnmhdr->code)

            } // WM_NOTIFY
            break;

        } // switch(uiMsg)

    } // not WM_INITDIALOG

Cleanup:
Error:
    (void)::SetWindowLong(hwndDlg, DWL_MSGRESULT, static_cast<LONG>(lresult));
    return fDlgProcRet;
}


UINT CALLBACK CPropertyPageWrapper::PropSheetPageProc
(
    HWND hwnd,
    UINT uMsg,
    PROPSHEETPAGE *pPropSheetPage
)
{
    UINT uiRc = 0;

    if (PSPCB_CREATE == uMsg)
    {
        uiRc = 1; // allow the page to be created
    }
    else if (PSPCB_RELEASE == uMsg)
    {
        CPropertyPageWrapper *pPropertyPageWrapper =
               reinterpret_cast<CPropertyPageWrapper *>(pPropSheetPage->lParam);

        if (NULL != pPropertyPageWrapper)
        {
            // Release the ref on ourselves. This should result in this object
            // being destrotyed so do not reference any member variables after
            // this call

            pPropertyPageWrapper->ExternalRelease();
        }
    }
    return uiRc;
}



HRESULT CPropertyPageWrapper::OnInitDialog(HWND hwndDlg)
{
    HRESULT     hr = S_OK;
    IUnknown  **apunkObjects = NULL;
    ULONG       i = 0;
    IDispatch  *pdisp = NULL;

    if(!m_pHelper)
        IfFailGo(hr = E_FAIL);

    IfFailGo(m_pHelper->Marshal(*this));

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Store the hwnd and store our this pointer in the window words

    m_hwndDlg = hwndDlg;

    ::SetWindowLong(hwndDlg, DWL_USER, reinterpret_cast<LONG>(this));

    // Store the property sheet HWND. For now assume it is the parent of
    // the dialog. When we get PSN_SETACTIVE we'll update it with that value.
    // Technically we should not make this assumption but there is a ton of
    // Win32 code that does and we have no choice because we need the HWND
    // before PSN_SETACTIVE

    m_hwndSheet = ::GetParent(hwndDlg);

    // Give it to our owning CPropertySheet

    m_pPropertySheet->SetHWNDSheet(m_hwndSheet);

    // Create the page

    RELEASE(m_piPropertyPage); // should never be necessary, but just in case

    hr = ::CoCreateInstance(m_clsidPage,
                            NULL, // no aggregation,
                            CLSCTX_INPROC_SERVER,
                            IID_IPropertyPage,
                            reinterpret_cast<void **>(&m_piPropertyPage));
    EXCEPTION_CHECK_GO(hr);

    // Unmarshall the IMMCPropertySheet so we can pass it to 
    // IMMCPropertyPage::Initialize

    if (NULL != m_piMMCPropertySheetStream)
    {
        hr = ::CoGetInterfaceAndReleaseStream(m_piMMCPropertySheetStream,
                                              IID_IMMCPropertySheet,
                                              reinterpret_cast<void **>(&m_piMMCPropertySheet));
        m_piMMCPropertySheetStream = NULL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set this CPropertyPageWrapper object as the page site

    IfFailGo(m_piPropertyPage->SetPageSite(static_cast<IPropertyPageSite *>(this)));

    // Unmarshal the IUnknowns on the objects for which the page will be
    // displaying properties. This will also release the streams regardless of
    // whether it succeeds.

    if (NULL != m_apiObjectStreams)
    {
        apunkObjects = (IUnknown **)CtlAllocZero(m_cObjects * sizeof(IUnknown *));
        if (NULL == apunkObjects)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL == m_apiObjectStreams[i])
            {
                continue;
            }
            hr = ::CoGetInterfaceAndReleaseStream(
                m_apiObjectStreams[i],
                IID_IUnknown,
                reinterpret_cast<void **>(&apunkObjects[i]));
            m_apiObjectStreams[i] = NULL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // If this is a wizard then unmarshal the ISnapIn so we can fire
    // ConfigurationComplete.

    if (NULL != m_piSnapInStream)
    {
        hr = ::CoGetInterfaceAndReleaseStream(m_piSnapInStream,
                                              IID_ISnapIn,
                                              reinterpret_cast<void **>(&m_piSnapIn));
        m_piSnapInStream = NULL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Give the object to the page. Check for NULL because the snap-in
    // could have called PropertySheet.AddWizardPage passing Nothing
    // for its configuration object.

    if (NULL != apunkObjects)
    {
        IfFailGo(m_piPropertyPage->SetObjects(m_cObjects, apunkObjects));
    }

    // If this is a wizard then check whether the page supports our IWizardPage
    // interface. If it does not, that is not considered an error and it simply
    // won't get the next/back/finish etc. notifications.

    hr = m_piPropertyPage->QueryInterface(IID_IWizardPage,
                                    reinterpret_cast<void **>(&m_piWizardPage));
    if (FAILED(hr))
    {
        // Just to be extra sure, NULL our IWizardPage pointer
        m_piWizardPage = NULL;

        // If the error was anything other than E_NOINTERFACE then consider it
        // a real error.

        if (E_NOINTERFACE == hr)
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }
    else
    {
        // It should be a wizard. Store the object so we can pass it to the
        // snap-in when the Finish button is pressed (see OnWizFinish).
        if (NULL != apunkObjects)
        {
            if (NULL != apunkObjects[0])
            {
                IfFailGo(apunkObjects[0]->QueryInterface(IID_IDispatch,
                    reinterpret_cast<void **>(&m_pdispConfigObject)));
            }
        }
        else
        {
            m_pdispConfigObject = NULL;
        }
    }

    // Add the MSGFILTER hook so that we can call
    // IPropertyPage::TranslateAccelerator when the user hits a key in a control
    // on the page.

    IfFailGo(AddMsgFilterHook());

    // Activate the page and show it

    IfFailGo(ActivatePage());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    if (NULL != apunkObjects)
    {
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != apunkObjects[i])
            {
                apunkObjects[i]->Release();
            }
        }
        CtlFree(apunkObjects);
    }
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnInitMsg()
{
    HRESULT     hr = S_OK;

    // If the snap-in supports IMMCPropertyPage then call Initialize

    if (SUCCEEDED(m_piPropertyPage->QueryInterface(IID_IMMCPropertyPage,
                              reinterpret_cast<void **>(&m_piMMCPropertyPage))))
    {
        IfFailGo(InitPage());
    }
Error:
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::InitPage()
{
    HRESULT    hr = S_OK;

    VARIANT varProvider;
    ::VariantInit(&varProvider);

    // If the snap-in passed an object in the InitData parameter of
    // MMCPropertySheet.AddPage then unmarshal it.

    if (ISPRESENT(m_varInitData))
    {
        // If there is an object in InitData then it needs to be unmarshaled.

        if (VT_UNKNOWN == m_varInitData.vt)
        {
            m_varInitData.punkVal = NULL;
            hr = ::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                            IID_IUnknown,
                            reinterpret_cast<void **>(&m_varInitData.punkVal));
            m_piInitDataStream = NULL;
            EXCEPTION_CHECK_GO(hr);
        }
        else if (VT_DISPATCH == m_varInitData.vt)
        {
            m_varInitData.pdispVal = NULL;
            hr = ::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                            IID_IDispatch,
                            reinterpret_cast<void **>(&m_varInitData.pdispVal));
            m_piInitDataStream = NULL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Call IMMCPropertyPage::Initialize
    
    IfFailGo(m_piMMCPropertyPage->Initialize(m_varInitData,
                   reinterpret_cast<MMCPropertySheet *>(m_piMMCPropertySheet)));

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::AddMsgFilterHook()
{
    HRESULT  hr = S_OK;
    TLSDATA *pTlsData = NULL;

    // If we are remote then don't install the hook. It doesn't work correctly
    // and there is no need to handle tabbing under the debugger.
    
    IfFalseGo(!m_fIsRemote, S_OK);

    // Check if TLS data is already there for this thread. If not there
    // then create it, add the hook, and set the TLS data. If it is there
    // then increment the ref count on the HHOOK.

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));

    if (NULL == pTlsData)
    {
        pTlsData = (TLSDATA *)CtlAllocZero(sizeof(TLSDATA));
        if (NULL == pTlsData)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        pTlsData->hHook = ::SetWindowsHookEx(WH_MSGFILTER,
                                             &MessageProc,
                                             GetResourceHandle(),
                                             ::GetCurrentThreadId());
        if (NULL == pTlsData->hHook)
        {
            CtlFree(pTlsData);
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (FAILED(CTls::Set(TLS_SLOT_PPGWRAP, pTlsData)))
        {
            (void)::UnhookWindowsHookEx(pTlsData->hHook);
            CtlFree(pTlsData);
        }
    }

    // Increment the existing page count
    pTlsData->cPages++;

    m_fNeedToRemoveHook = TRUE;

Error:
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::RemoveMsgFilterHook()
{
    HRESULT  hr = S_OK;
    TLSDATA *pTlsData = NULL;
    UINT     i = 0;

    // If we already removed the hook then nothing to do

    IfFalseGo(m_fNeedToRemoveHook, S_OK);

    // Check if TLS data is already there for this thread. If it is,
    // then remove this dialog's hwnd from the TLS.

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));
    IfFalseGo(NULL != pTlsData, S_OK);

    pTlsData->cPages--;

    m_fNeedToRemoveHook = FALSE;

    // If there are no more existing pages then remove the hook and free the TLS

    if (0 == pTlsData->cPages)
    {
        if (NULL != pTlsData->hHook)
        {
            (void)::UnhookWindowsHookEx(pTlsData->hHook);
            pTlsData->hHook = NULL;
        }
        IfFailGo(CTls::Set(TLS_SLOT_PPGWRAP, NULL));
        CtlFree(pTlsData);
    }

Error:
    RRETURN(hr);
}


LRESULT CALLBACK CPropertyPageWrapper::MessageProc
(
    int code,       // hook code
    WPARAM wParam,  // not used
    LPARAM lParam   // message data
)
{
    HRESULT  hr = S_OK;
    LRESULT  lResult = 0; // default ret value is pass msg to wndproc
    MSG     *pMsg = reinterpret_cast<MSG *>(lParam);
    TLSDATA *pTlsData = NULL;
    HWND     hwndTab = NULL;
    HWND     hwndSheet = NULL;
    HWND     hwndBack = NULL;
    HWND     hwndNext = NULL;
    HWND     hwndFinish = NULL;
    HWND     hwndCancel = NULL;
    HWND     hwndHelp = NULL;
    BOOL     fTargetIsOnPage = FALSE;
    BOOL     fPassToPropertyPage = FALSE;

    // Get the TLS data in all cases because the HHOOK is in there and we need
    // that for CallNextHookEx.

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));

    // If input event did not occur in a dialog box then pass to CallNextHookEx

    IfFalseGo(code >= 0, S_OK);

    // If this is not a key down message then just pass to CallNextHookEx

    IfFalseGo( ((WM_KEYFIRST <= pMsg->message) && (WM_KEYLAST >= pMsg->message)), S_OK);

    // If there is no pointer to the active page in TLS then just pass to
    // CallNextHookeEx

    IfFalseGo(NULL != pTlsData, S_OK);
    IfFalseGo(NULL != pTlsData->ppgActive, S_OK);

    // Get the HWND of the tab control

    hwndSheet = pTlsData->ppgActive->m_hwndSheet;
    if (NULL != hwndSheet)
    {
        hwndTab = (HWND)::SendMessage(hwndSheet, PSM_GETTABCONTROL, 0, 0);
    }

    // Check if the target of the message is a decendant of the wrapper dialog
    // window. If so then it is a control on the VB property page.
    
    fTargetIsOnPage = ::IsChild(pTlsData->ppgActive->m_hwndDlg, pMsg->hwnd);

    // If a tab was hit outside of the page then in some cases we need to
    // let the page handle it.

    if ( (VK_TAB == pMsg->wParam) && (!fTargetIsOnPage) )
    {
        // If this is a back-tab
        if (::GetKeyState(VK_SHIFT) < 0)
        {
            // If the focus is on the OK button, let page handle shift-tab
            if (pMsg->hwnd == ::GetDlgItem(hwndSheet, IDOK))
            {
                fPassToPropertyPage = TRUE;
            }
            else if (pTlsData->ppgActive->m_fWizard)
            {
                // Determine which wizard buttons are enabled and handle
                // back tabs from the left-most enabled button.
                // Wizard buttons can be:
                // Back  | Next | Finish | Cancel | Help
                // The left-most enabled button could be Back, Next, Finish, or
                // Cancel
                // TODO: does this work on RTL locales such as Hebrew and Arabic?

                hwndBack = ::GetDlgItem(hwndSheet, IDD_BACK);
                hwndNext = ::GetDlgItem(hwndSheet, IDD_NEXT);
                hwndFinish = ::GetDlgItem(hwndSheet, IDD_FINISH);
                hwndCancel = ::GetDlgItem(hwndSheet, IDCANCEL);

                if (pMsg->hwnd == hwndBack)
                {
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndNext) &&
                          (!::IsWindowEnabled(hwndBack)) )
                {
                    // Back-tab is for Next button and Back button is disabled
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndFinish) &&
                          (!::IsWindowEnabled(hwndBack)) &&
                          (!::IsWindowEnabled(hwndNext)) )
                {
                    // Back-tab is for Finish button and Next and Back buttons
                    // are disabled
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndFinish) &&
                          (!::IsWindowEnabled(hwndBack)) &&
                          (!::IsWindowEnabled(hwndNext)) )
                {
                    // Back-tab is for Finish button and Next and Back buttons
                    // are disabled
                    fPassToPropertyPage = TRUE;
                }
            }
        }
        else // forward tab
        {
            // If the focus is on the tab control, let page handle tab
            if (hwndTab == pMsg->hwnd)
            {
                fPassToPropertyPage = TRUE;
            }
            else if (pTlsData->ppgActive->m_fWizard)
            {
                // Determine which wizard buttons are enabled and handle
                // back tabs from the right-most enabled button.
                // Wizard buttons can be:
                // Back  | Next | Finish | Cancel | Help
                // The right-most enabled button could be Cancel or Help
                // TODO: does this work on RTL locales such as Hebrew and Arabic?

                hwndCancel = ::GetDlgItem(hwndSheet, IDCANCEL);
                hwndHelp = ::GetDlgItem(hwndSheet, IDHELP);

                if (pMsg->hwnd == hwndHelp)
                {
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndCancel) &&
                          ( (!::IsWindowEnabled(hwndHelp)) ||
                            (!::IsWindowVisible(hwndHelp)) )
                        )
                {
                    // Tab is for Cancel button and Help button is disabled
                    fPassToPropertyPage = TRUE;
                }
            }
        }
    }
    else if ( ( (VK_LEFT == pMsg->wParam) || (VK_RIGHT == pMsg->wParam) ||
                (VK_UP == pMsg->wParam)   || (VK_DOWN == pMsg->wParam)
              ) &&
              (!fTargetIsOnPage)
            )
    {
        fPassToPropertyPage = FALSE;
    }
    else // Not a tab, back-tab, or arrow key. Pass it to the page.
    {
        fPassToPropertyPage = TRUE;
    }

    if (fPassToPropertyPage)
    {
        if (S_OK == pTlsData->ppgActive->m_piPropertyPage->TranslateAccelerator(pMsg))
        {
            // Property page handled the key. Don't pass msg to wndproc
            // and to other hooks.
            lResult = (LRESULT)1;
        }
    }

Error:

    if ( (0 == lResult) && (NULL != pTlsData) )
    {
        // Pass the message to other hooks

        if (NULL != pTlsData->hHook)
        {
            lResult = ::CallNextHookEx(pTlsData->hHook, code, wParam, lParam);
        }
    }

    return lResult;
}


HRESULT CPropertyPageWrapper::ActivatePage()
{
    HRESULT  hr = S_OK;
    HWND     hwndPage = NULL;
    TLSDATA *pTlsData = NULL;
    HWND     hwndTab = NULL;
    HWND     hwndSheet = NULL;

    MSG msg;
    ::ZeroMemory(&msg, sizeof(msg));

    RECT rect;
    ::ZeroMemory(&rect, sizeof(rect));

    BYTE rgbKeys[256];
    ::ZeroMemory(rgbKeys, sizeof(rgbKeys));

    // Activate the property page.
    //
    // Use the dialog's hwnd as the parent.
    //
    // Set the rect to the dialog window's size
    //
    // Pass TRUE to indicate that the dialog box frame is modal. This is the
    // same way OleCreatePropertyFrame() and and OleCreatePropertyFrameIndirect()
    // work.

    GetClientRect(m_hwndDlg, &rect);

    IfFailGo(m_piPropertyPage->Activate(m_hwndDlg, &rect, TRUE));

    hwndPage = ::GetTopWindow(m_hwndDlg);
    if (NULL != hwndPage)
    {
        ::SetWindowLong(hwndPage, GWL_STYLE,
             ::GetWindowLong(hwndPage, GWL_STYLE) & ~(DS_CONTROL | WS_TABSTOP));
        ::SetWindowLong(hwndPage, GWL_EXSTYLE,
                 ::GetWindowLong(hwndPage, GWL_EXSTYLE) & ~WS_EX_CONTROLPARENT);
    }

    // Tell the page to show itself and set focus to the first property in its
    // tab order.

    IfFailGo(m_piPropertyPage->Show(SW_SHOW));

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));
    IfFalseGo(NULL != pTlsData, S_OK);

    pTlsData->ppgActive = this;

    // Fake a tab key to the property page so that the focus will move to
    // the first control in the page's tabbing order.

    // Ignore all return codes because if this doesn't work then it is not a
    // show-stopper. The user would simply have to tab to or click on the first
    // control.

    hwndTab = (HWND)::SendMessage(m_hwndSheet, PSM_GETTABCONTROL, 0, 0);
    IfFalseGo(NULL != hwndTab, S_OK);

    msg.hwnd = hwndTab;            // message intended for focused control
    msg.message = WM_KEYDOWN;      // key pressed
    msg.wParam = VK_TAB;           // tab key
    msg.lParam = 0x000F0001;       // tab key scan code with repeat count=1
    msg.time = ::GetTickCount();   // use current time
    (void)::GetCursorPos(&msg.pt); // use current cursor position

    // Make sure shift/ctrl/alt keys are not set, since property
    // pages will interpret the key wrong.

    (void)::GetKeyboardState(rgbKeys);
    rgbKeys[VK_SHIFT] &= 0x7F;      // remove hi bit (key down)
    rgbKeys[VK_CONTROL] &= 0x7F;    // remove hi bit (key down)
    rgbKeys[VK_MENU] &= 0x7F;       // remove hi bit (key down)
    (void)::SetKeyboardState(rgbKeys);

    (void)m_piPropertyPage->TranslateAccelerator(&msg);

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnSize()
{
    HRESULT   hr = S_OK;

    RECT rect;
    ::ZeroMemory(&rect, sizeof(rect));

    GetClientRect(m_hwndDlg, &rect);

    IfFailGo(m_piPropertyPage->Move(&rect));

Error:
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnDestroy()
{
    HRESULT   hr = S_OK;
    IUnknown *punkThisObject = PrivateUnknown();

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Remove the selected objects. We should pass NULL here but in a debugging
    // session the proxy will return an error if we do. To get around this we
    // pass a pointer to our own IUnknown. VB will not do anything with it
    // because the object count is zero.

    IfFailGo(m_piPropertyPage->SetObjects(0, &punkThisObject));

    // Deactivate the property page.

    IfFailGo(m_piPropertyPage->Deactivate());

    // Set the site to NULL so it will remove its ref on us.

    IfFailGo(m_piPropertyPage->SetPageSite(NULL));

    // Release the property page

    RELEASE(m_piPropertyPage);

    // Remove this dialog from the message hook TLS data. If there are
    // no more dialogs remaining then remove the hook.
    
    IfFailGo(RemoveMsgFilterHook());
            
    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnApply(LRESULT *plresult)
{
    HRESULT hr = S_OK;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Tell the property page to apply its current values to the underlying
    // object.

    IfFailGo(m_piPropertyPage->Apply());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    if (FAILED(hr))
    {
        *plresult = PSNRET_INVALID_NOCHANGEPAGE;
    }
    else
    {
        *plresult = PSNRET_NOERROR;
    }
    RRETURN(hr);
}




HRESULT CPropertyPageWrapper::OnSetActive(HWND hwndSheet, LRESULT *plresult)
{
    HRESULT                    hr = S_OK;
    long                       lNextPage = 0;
    WizardPageButtonConstants  NextOrFinish = EnabledNextButton;
    VARIANT_BOOL               fvarEnableBack = VARIANT_TRUE;
    BSTR                       bstrFinishText = NULL;
    DWORD                      dwFlags = 0;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Store the property sheet's HWND and give it to our owning CPropertySheet

    m_hwndSheet = hwndSheet;
    m_pPropertySheet->SetHWNDSheet(m_hwndSheet);

    // If the page is in a wizard then set the wizard buttons

    if (m_fWizard && (NULL != m_piWizardPage))
    {
        IfFailGo(m_piWizardPage->Activate(&fvarEnableBack,
                                          &NextOrFinish,
                                          &bstrFinishText));

        IfFailGo(m_pPropertySheet->SetWizardButtons(fvarEnableBack,
                                                    NextOrFinish));
        if (NULL != bstrFinishText)
        {
            IfFailGo(m_pPropertySheet->SetFinishButtonText(bstrFinishText));
        }
    }

    // Activate the page and show it

    IfFailGo(ActivatePage());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    FREESTRING(bstrFinishText);

    if (FAILED(hr))
    {
        // If anything failed then don't allow the operation.
        lNextPage = -1L;
    }

    *plresult = static_cast<LRESULT>(lNextPage);

    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnKillActive(LRESULT *plresult)
{
    HRESULT  hr = S_OK;
    TLSDATA *pTlsData = NULL;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));
    if (NULL != pTlsData)
    {
        pTlsData->ppgActive = NULL;
    }

    // Tell the property page to apply its current values to the underlying
    // object.

    IfFailGo(m_piPropertyPage->Apply());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    if (FAILED(hr))
    {
        // Apply failed. Tell the property sheet to keep the page active

        *plresult = static_cast<LRESULT>(TRUE);
    }
    else
    {
        // Apply succeeded. Tell the property sheet it is OK to leave the page

        *plresult = static_cast<LRESULT>(FALSE);
    }
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnWizBack(LRESULT *plresult)
{
    HRESULT hr = S_OK;
    long    lNextPage = 0;

    // If the page doesn't support IWizardPage then allow the Back operation.

    IfFalseGo(NULL != m_piWizardPage, S_OK);

    IfFailGo(m_piWizardPage->Back(&lNextPage));

    if (0 < lNextPage)
    {
        // Page requested to move to another page. Get its DLGTEMPLATE pointer.
        IfFailGo(GetNextPage(&lNextPage));
    }

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Back operation.
        lNextPage = -1L;
    }

    *plresult = static_cast<LRESULT>(lNextPage);

    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnWizNext(LRESULT *plresult)
{
    HRESULT hr = S_OK;
    long    lNextPage = 0;

    // If the page doesn't support IWizardPage then allow the Next operation.

    IfFalseGo(NULL != m_piWizardPage, S_OK);

    IfFailGo(m_piWizardPage->Next(&lNextPage));

    if (0 < lNextPage)
    {
        // Page requested to move to another page. Get its DLGTEMPLATE pointer.
        IfFailGo(GetNextPage(&lNextPage));
    }

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Next operation.
        lNextPage = -1L;
    }

    *plresult = static_cast<LRESULT>(lNextPage);

    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnWizFinish(LRESULT *plresult)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarAllow = VARIANT_TRUE;

    // If the page doesn't support IWizardPage then allow the Finish operation.

    IfFalseGo(NULL != m_piWizardPage, S_OK);

    IfFailGo(m_piWizardPage->Finish(&fvarAllow));

    // If the finish is allowed and this is a configuration wizard then fire
    // SnapIn_ConfigurationComplete

    if ( (VARIANT_TRUE == fvarAllow) && (NULL != m_piSnapIn) && m_fConfigWizard)
    {
        IfFailGo(m_piSnapIn->FireConfigComplete(m_pdispConfigObject));
    }

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Finish operation.
        fvarAllow = VARIANT_FALSE;
    }
    else
    {
        if (VARIANT_TRUE == fvarAllow)
        {
            *plresult = 0; // Allow the property sheet to be destroyed
        }
        else
        {
            // Do not allow the property sheet to be destroyed
            *plresult = static_cast<LRESULT>(1);
        }
    }

    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnQueryCancel(LRESULT *plresult)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarAllow = VARIANT_TRUE;

    // If the page doesn't support IMMCPropertyPage then allow the Cancel
    // operation.

    IfFalseGo(NULL != m_piMMCPropertyPage, S_OK);

    IfFailGo(m_piMMCPropertyPage->QueryCancel(&fvarAllow));

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Cancel operation.
        fvarAllow = VARIANT_FALSE;
    }
    else
    {
        if (VARIANT_TRUE == fvarAllow)
        {
             // Allow the cancel operation
            *plresult = static_cast<LRESULT>(FALSE);
        }
        else
        {
            // Do not allow the cancel operation
            *plresult = static_cast<LRESULT>(TRUE);
        }
    }

    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnReset(BOOL fClickedXButton)
{
    HRESULT hr = S_OK;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // If the page doesn't support IMMCPropertyPage then ignore this notification

    IfFalseGo(NULL != m_piMMCPropertyPage, S_OK);

    if (fClickedXButton)
    {
        IfFailGo(m_piMMCPropertyPage->Close());
    }
    else
    {
        IfFailGo(m_piMMCPropertyPage->Cancel());
    }

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnHelp()
{
    HRESULT hr = S_OK;
    
    // If the property page implements IMMCPropertyPage then call the Help
    // method otherwise call IPropertyPage::Help()

    if (NULL != m_piMMCPropertyPage)
    {
        hr = m_piMMCPropertyPage->Help();
    }
    else
    {
        // Call IPropertyPage::Help() on the page. We don't pass the help dir
        // because VB doesn't register it and it doesn't use it. See the VB
        // source in vbdev\ruby\deskpage.cpp, DESKPAGE::Help().
    
        hr = m_piPropertyPage->Help(NULL);
    }
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::GetNextPage(long *lNextPage)
{
    HRESULT      hr = S_OK;
    DLGTEMPLATE *pDlgTemplate = NULL;

    IfFalseGo(NULL != m_pPropertySheet, SID_E_INTERNAL);

    // The property sheet has the array of DLGTEMPLATE pointers. Ask it
    // for the one corresponding to the requested page.

    IfFailGo(m_pPropertySheet->GetTemplate(*lNextPage, &pDlgTemplate));
    *lNextPage = reinterpret_cast<long>(pDlgTemplate);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      IPropertyPageSite Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CPropertyPageWrapper::OnStatusChange(DWORD dwFlags)
{
    if ( PROPPAGESTATUS_DIRTY == (dwFlags & PROPPAGESTATUS_DIRTY) )
    {
        // Enables the apply button

        ::SendMessage(m_hwndSheet, PSM_CHANGED, (WPARAM)m_hwndDlg, 0);
    }
    else
    {
        // Disables the apply button. Occurs when page has returned to original
        // state. In a VB page, would set Changed = False.

        ::SendMessage(m_hwndSheet, PSM_UNCHANGED, (WPARAM)m_hwndDlg, 0);
    }
    return S_OK;
}

STDMETHODIMP CPropertyPageWrapper::GetLocaleID(LCID *pLocaleID)
{
    *pLocaleID = GetSystemDefaultLCID();
    RRETURN((0 == *pLocaleID) ? E_FAIL : S_OK);
}


STDMETHODIMP CPropertyPageWrapper::GetPageContainer(IUnknown **ppunkContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyPageWrapper::TranslateAccelerator(MSG *pMsg)
{
    return S_FALSE;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CPropertyPageWrapper::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IPropertyPageSite == riid)
    {
        *ppvObjOut = static_cast<IPropertyPageSite *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpchars.h ===
//=--------------------------------------------------------------------------=
// prpchars.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Header for exported function GetPropSheetCharSizes() used by both
// design tiem and runtime when converting dialog units to pixels.
//
//=--------------------------------------------------------------------------=

#if defined(MSSNAPR_BUILD)
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT __declspec(dllimport)
#endif

// Returns the average width and height of a character in the font used by
// Win32 property sheets.

HRESULT DLLEXPORT GetPropSheetCharSizes
(
    UINT *pcxPropSheetChar,
    UINT *pcyPropSheetChar
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpsheet.cpp ===
//=--------------------------------------------------------------------------=
// prpsheet.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertySheet class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "prpsheet.h"
#include "ppgwrap.h"
#include "scopitms.h"
#include "listitms.h"
#include "dataobjs.h"
#include "prpchars.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


UINT CPropertySheet::m_cxPropSheetChar = 0;
UINT CPropertySheet::m_cyPropSheetChar = 0;
BOOL CPropertySheet::m_fHavePropSheetCharSizes = FALSE;

CPropertySheet::CPropertySheet(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                         OBJECT_TYPE_PROPERTYSHEET,
                                         static_cast<IMMCPropertySheet *>(this),
                                         static_cast<CPropertySheet *>(this),
                                         0,    // no property pages
                                         NULL, // no property pages
                                         NULL) // no persistence



{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CPropertySheet::Create(IUnknown *punkOuter)
{
    HRESULT        hr = S_OK;
    CPropertySheet *pPropertySheet = New CPropertySheet(punkOuter);

    if (NULL == pPropertySheet)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pPropertySheet)
        {
            delete pPropertySheet;
        }
        return NULL;
    }
    else
    {
        return pPropertySheet->PrivateUnknown();
    }
}

CPropertySheet::~CPropertySheet()
{
    ULONG              i = 0;

    RELEASE(m_piPropertySheetCallback);
    if (NULL != m_ppDlgTemplates)
    {
        ::CtlFree(m_ppDlgTemplates);
    }

    if (NULL != m_paPageInfo)
    {
        for (i = 0; i < m_cPageInfos; i++)
        {
            if (NULL != m_paPageInfo[i].pwszTitle)
            {
                ::CoTaskMemFree(m_paPageInfo[i].pwszTitle);
            }
            if (NULL != m_paPageInfo[i].pwszProgID)
            {
                CtlFree(m_paPageInfo[i].pwszProgID);
            }
        }
        CtlFree(m_paPageInfo);
    }

    if (NULL != m_pwszProgIDStart)
    {
        ::CoTaskMemFree(m_pwszProgIDStart);
    }

    ReleaseObjects();
    RELEASE(m_piSnapIn);
    InitMemberVariables();
}

void CPropertySheet::ReleaseObjects()
{
    ULONG              i = 0;
    ULONG              j = 0;
    WIRE_PROPERTYPAGE *pPage = NULL;

    // Release the objects associated with the property pages

    if (NULL != m_apunkObjects)
    {
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != m_apunkObjects[i])
            {
                m_apunkObjects[i]->Release();
            }
        }
        CtlFree(m_apunkObjects);
        m_apunkObjects = NULL;
        m_cObjects = 0;
    }

    // Free the WIRE_PROPERTYPAGES and all of its contents.

    if (NULL == m_pWirePages)
    {
        return;
    }

    for (i = 0, pPage = &m_pWirePages->aPages[0];
         i < m_pWirePages->cPages;
         i++, pPage++)
    {
        if (NULL != pPage->apunkObjects)
        {
            for (j = 0; j < pPage->cObjects; j++)
            {
                if (NULL != pPage->apunkObjects[j])
                {
                    pPage->apunkObjects[j]->Release();
                }
            }
            ::CoTaskMemFree(pPage->apunkObjects);
        }

        if (NULL != pPage->pwszTitle)
        {
            ::CoTaskMemFree(pPage->pwszTitle);
        }
    }

    if (NULL != m_pWirePages->punkExtra)
    {
        m_pWirePages->punkExtra->Release();
    }

    if (NULL != m_pWirePages->pwszProgIDStart)
    {
        ::CoTaskMemFree(m_pWirePages->pwszProgIDStart);
    }

    if (NULL != m_pWirePages->pPageInfos)
    {
        for (i = 0; i < m_pWirePages->pPageInfos->cPages; i++)
        {
            if (NULL != m_pWirePages->pPageInfos->aPageInfo[i].pwszTitle)
            {
                ::CoTaskMemFree(m_pWirePages->pPageInfos->aPageInfo[i].pwszTitle);
            }
            if (NULL != m_pWirePages->pPageInfos->aPageInfo[i].pwszProgID)
            {
                ::CoTaskMemFree(m_pWirePages->pPageInfos->aPageInfo[i].pwszProgID);
            }
        }
        ::CoTaskMemFree(m_pWirePages->pPageInfos);
    }

    // Free all of the objects associated with the sheet

    if (NULL != m_pWirePages->apunkObjects)
    {
        for (i = 0; i < m_pWirePages->cObjects; i++)
        {
            if (NULL != m_pWirePages->apunkObjects[i])
            {
                m_pWirePages->apunkObjects[i]->Release();
            }
        }
        CoTaskMemFree(m_pWirePages->apunkObjects);
    }


    ::CoTaskMemFree(m_pWirePages);
    m_pWirePages = NULL;

}


void CPropertySheet::InitMemberVariables()
{
    m_piPropertySheetCallback = NULL;
    m_handle = NULL;
    m_apunkObjects = NULL;
    m_cObjects = 0;
    m_piSnapIn = NULL;
    m_cPages = 0;
    m_ppDlgTemplates = NULL;
    m_pwszProgIDStart = NULL;
    m_paPageInfo = NULL;
    m_cPageInfos = NULL;
    m_fHavePageCLSIDs = FALSE;
    m_fWizard = FALSE;
    m_fConfigWizard = FALSE;
    m_fWeAreRemote = FALSE;
    m_pWirePages = NULL;
    m_hwndSheet = NULL;
    m_fOKToAlterPageCount = TRUE;
}



HRESULT CPropertySheet::SetCallback
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    LPOLESTR                pwszProgIDStart,
    IMMCClipboard          *piMMCClipboard,
    ISnapIn                *piSnapIn,
    BOOL                    fConfigWizard
)
{
    HRESULT          hr = S_OK;
    CMMCClipboard   *pMMCClipboard = NULL;
    CScopeItems     *pScopeItems;
    CMMCListItems   *pListItems;
    CMMCDataObjects *pDataObjects;
    long             cObjects = 0;
    long             i = 0;
    long             iNext = 0;

    RELEASE(m_piPropertySheetCallback);
    if (NULL != piPropertySheetCallback)
    {
        piPropertySheetCallback->AddRef();
    }
    m_piPropertySheetCallback = piPropertySheetCallback;

    m_handle = handle;
    m_fWizard = fConfigWizard;
    m_fConfigWizard = fConfigWizard;

    if (NULL != m_pwszProgIDStart)
    {
        ::CoTaskMemFree(m_pwszProgIDStart);
        m_pwszProgIDStart = NULL;
    }

    if (NULL != pwszProgIDStart)
    {
        IfFailGo(::CoTaskMemAllocString(pwszProgIDStart, &m_pwszProgIDStart));
    }

    RELEASE(m_piSnapIn);
    if (NULL != piSnapIn)
    {
        piSnapIn->AddRef();
    }
    m_piSnapIn = piSnapIn;

    IfFalseGo(NULL != piMMCClipboard, S_OK);

    // Release any currently held objects

    ReleaseObjects();

    // Create an array of IUnknown * with an element for each scope item, list
    // item and dataobject contained in the clipboard

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCClipboard,
                                                   &pMMCClipboard));

    pScopeItems = pMMCClipboard->GetScopeItems();
    pListItems = pMMCClipboard->GetListItems();
    pDataObjects = pMMCClipboard->GetDataObjects();

    m_cObjects = pScopeItems->GetCount() +
                 pListItems->GetCount() +
                 pDataObjects->GetCount();

    IfFalseGo(0 != m_cObjects, S_OK);

    m_apunkObjects = (IUnknown **)CtlAllocZero(m_cObjects * sizeof(IUnknown *));
    if (NULL == m_apunkObjects)
    {
        m_cObjects = 0;
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    iNext = 0;

    cObjects = pScopeItems->GetCount();
    for (i = 0; i < cObjects; i++)
    {
        IfFailGo(pScopeItems->GetItemByIndex(i)->QueryInterface(IID_IUnknown,
                             reinterpret_cast<void **>(&m_apunkObjects[iNext])));
        iNext++;
    }

    cObjects = pListItems->GetCount();
    for (i = 0; i < cObjects; i++)
    {
        IfFailGo(pListItems->GetItemByIndex(i)->QueryInterface(IID_IUnknown,
                             reinterpret_cast<void **>(&m_apunkObjects[iNext])));
        iNext++;
    }

    cObjects = pDataObjects->GetCount();
    for (i = 0; i < cObjects; i++)
    {
        IfFailGo(pDataObjects->GetItemByIndex(i)->QueryInterface(IID_IUnknown,
                             reinterpret_cast<void **>(&m_apunkObjects[iNext])));
        iNext++;
    }

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::GetTemplate
(
    long          lNextPage,
    DLGTEMPLATE **ppDlgTemplate
)
{
    HRESULT hr = S_OK;

    if ( (lNextPage < 1) || (lNextPage > m_cPages) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if (NULL == m_ppDlgTemplates)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppDlgTemplate = m_ppDlgTemplates[lNextPage - 1L];

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CPropertySheet::TakeWirePages
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//  WIRE_PROPERTYPAGES * - pointer to property page info accumulated from
//                         VB calls to AddPage and AddWizardPage. Caller takes
//                         ownership of this memory and must free its contents
//                         with CoTaskMemFree().
//
// Notes:
//
// This function is called from CSnapIn's and CView's
// IExtendPropertySheet2::CreatePropertyPages implementation when the snap-in
// is running remotely in a source debugging session. It returns this memory
// block to the stub so that it can be transmitted to the proxy where the
// real property pages will be created based on this information.
//

WIRE_PROPERTYPAGES *CPropertySheet::TakeWirePages()
{
    WIRE_PROPERTYPAGES *pPages = m_pWirePages;
    m_pWirePages = NULL;
    return pPages;
}



HRESULT CPropertySheet::GetPageCLSIDs()
{
    HRESULT                hr = S_OK;
    ISpecifyPropertyPages *piSpecifyPropertyPages = NULL;
    LPOLESTR               pwszCtlProgID = NULL;
    static WCHAR           wszSnapInControl[] = L"SnapInControl";
    CLSID                  clsidCtl = CLSID_NULL;
    DWORD                  cbSnapInControlProgID = 0;
    size_t                 cchProgIDStart = 0;
    size_t                 cbProgIDStart = 0;
    ULONG                  i = 0;
    WCHAR                  wszKey[64] = L"ClsID\\";
    char                  *pszKey = NULL;
    char                   szProgID[128] = "";
    char                  *pszProgIDAfterDot = NULL;
    HKEY                   hkey = NULL;
    DWORD                  dwType = REG_SZ;
    DWORD                  cbProgID = 0;
    long                   lRc = 0;

    CAUUID cauuid;
    ::ZeroMemory(&cauuid, sizeof(cauuid));

    // Concatenate the project's prog ID start (part before the dot) with
    // "SnapInControl" to form the control's prog ID.

    cchProgIDStart = ::wcslen(m_pwszProgIDStart);
    cbProgIDStart = cchProgIDStart * sizeof(WCHAR);
    cbSnapInControlProgID = (DWORD)(cbProgIDStart +
                                    sizeof(WCHAR) + // for the dot
                                    sizeof(wszSnapInControl));

    pwszCtlProgID = (LPOLESTR)::CtlAlloc(cbSnapInControlProgID);
    if (NULL == pwszCtlProgID)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Copy the part before the dot.

    ::memcpy(pwszCtlProgID, m_pwszProgIDStart, cbProgIDStart);

    // Add the dot

    pwszCtlProgID[cchProgIDStart] = L'.';

    // Add "SnapInControl"

    ::memcpy( &pwszCtlProgID[cchProgIDStart + 1],
              wszSnapInControl,
              sizeof(wszSnapInControl) );


    // Now we have the full progid of the SnapInControl. Get its CLSID,
    // create an instance of it, and get an ISpecifyPropertyPages on it.

    hr = ::CLSIDFromProgID(pwszCtlProgID, &clsidCtl);
    EXCEPTION_CHECK_GO(hr);

    hr = ::CoCreateInstance(clsidCtl,
                            NULL, // no aggregation,
                            CLSCTX_INPROC_SERVER,
                            IID_ISpecifyPropertyPages,
                            reinterpret_cast<void **>(&piSpecifyPropertyPages));
    EXCEPTION_CHECK_GO(hr);

    // Ask the control for the array of all of its property pages

    IfFailGo(piSpecifyPropertyPages->GetPages(&cauuid));

    // Make sure the control actually returned some CLSIDs. The most likely
    // cause of this error is that the user forgot to associate the property
    // page with SnapInControl.

    if ( (0 == cauuid.cElems) || (NULL == cauuid.pElems) )
    {
        hr = SID_E_INVALID_PROPERTY_PAGE_NAME;
        EXCEPTION_CHECK_GO(hr);
    }

    // Allocate the array of PAGEINFO structs

    m_paPageInfo = (PAGEINFO *)::CtlAllocZero(cauuid.cElems * sizeof(PAGEINFO));
    if (NULL == m_paPageInfo)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    m_cPageInfos = cauuid.cElems;

    // Look up the clsids in the registry under \HKEY_CLASSES_ROOT\ClsID
    // and get the default value for each one which is its prog id. Store the
    // right half (after the dot) of the prog IDs in the array so that
    // AddPage() can look them up.

    for (i = 0; i < cauuid.cElems; i++)
    {
        // Copy the page's CLSID

        m_paPageInfo[i].clsid = cauuid.pElems[i];

        // Create the key name by concatenting "ClsID\" with the CLSID

        if (0 == ::StringFromGUID2(cauuid.pElems[i], &wszKey[6], 40))
        {
            hr = SID_E_INTERNAL; // buffer is not long enough
            EXCEPTION_CHECK_GO(hr);
        }

        // Convert that to ANSI

        IfFailGo(::ANSIFromWideStr(wszKey, &pszKey));

        // Open the property page's CLSID key

        lRc = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, pszKey, 0, KEY_READ, &hkey);
        if (ERROR_SUCCESS != lRc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        ::CtlFree(pszKey);
        pszKey = NULL;

        // Read its default value which is the ProgID

        cbProgID = sizeof(szProgID);

        lRc = ::RegQueryValueEx(hkey,
                                NULL,       // get default value
                                NULL,       // reserved
                                &dwType,    // type returned here
                                reinterpret_cast<LPBYTE>(szProgID),
                                &cbProgID); // [in, out] buf size, actual size

        if (ERROR_SUCCESS != lRc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if ( (REG_SZ != dwType) || (cbProgID < 4) ) // at least X.X + null byte
        {
            hr = SID_E_INTERNAL; // registration error
            EXCEPTION_CHECK_GO(hr);
        }

        // Store the right half of the ProgID as a UNICODE string in our array

        pszProgIDAfterDot = ::strchr(szProgID, '.');
        if (NULL == pszProgIDAfterDot)
        {
            hr = SID_E_INTERNAL; // registration error
        }
        pszProgIDAfterDot++;

        if ('\0' == pszProgIDAfterDot)
        {
            hr = SID_E_INTERNAL; // registration error
        }
        EXCEPTION_CHECK_GO(hr);

        IfFailGo(::WideStrFromANSI(pszProgIDAfterDot, &m_paPageInfo[i].pwszProgID));

        lRc = ::RegCloseKey(hkey);
        if (ERROR_SUCCESS != lRc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        hkey = NULL;
    }

    m_fHavePageCLSIDs = TRUE;

Error:
    if (NULL != hkey)
    {
        (void)::RegCloseKey(hkey);
    }

    if (NULL != pwszCtlProgID)
    {
        ::CtlFree(pwszCtlProgID);
    }

    if (NULL != pszKey)
    {
        ::CtlFree(pszKey);
    }

    if ( (0 != cauuid.cElems) || (NULL != cauuid.pElems) )
    {
        ::CoTaskMemFree(cauuid.pElems);
    }

    QUICK_RELEASE(piSpecifyPropertyPages);
    RRETURN(hr);
}


HRESULT CPropertySheet::GetCLSIDForPage(BSTR PageName, CLSID *clsidPage)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;
    BOOL    fFound = FALSE;

    // If we don't yet have SnapInControl's array of property page CLSIDs
    // then get it.

    if (!m_fHavePageCLSIDs)
    {
        IfFailGo(GetPageCLSIDs());
    }

    // Look for a page name in the array created by GetPageCLSIDs() and
    // return the corresponding CLSID.

    for (i = 0; (i < m_cPageInfos) && (!fFound); i++)
    {
        if (0 == ::wcscmp(PageName, m_paPageInfo[i].pwszProgID))
        {
            *clsidPage = m_paPageInfo[i].clsid;
            fFound = TRUE;
        }
    }

    if (!fFound)
    {
        hr = SID_E_INVALID_PROPERTY_PAGE_NAME;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CPropertySheet::InternalAddPage
(
    BSTR       PageName,
    ULONG      cObjects,
    IUnknown **apunkObjects,
    VARIANT    Caption,
    VARIANT    UseHelpButton,
    VARIANT    RightToLeft,
    VARIANT    InitData,
    BOOL       fIsInsert,
    short      sPosition
)
{
    HRESULT  hr = S_OK;
    CLSID    clsidPage = CLSID_NULL;
    DWORD    dwFlags = 0;
    short    cxPage = 0;
    short    cyPage = 0;
    LPOLESTR pwszTitle = NULL;
    BOOL     fReceivedCaption = FALSE;

    if (NULL == PageName)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are not remote or the property sheet is currentyl being displayed
    // then we are in the middle of an
    // IExtendPropertySheet2::CreatePropertyPages call and we must have the
    // IPropertySheetCallback pointer.

    if ( (!m_fWeAreRemote) && (NULL == m_hwndSheet) )
    {
        IfFalseGo(NULL != m_piPropertySheetCallback, SID_E_DETACHED_OBJECT);
    }

    // If the property sheet is currently being displayed then we need to
    // check whether it is OK to add pages at this time. See calls to
    // SetOKToAlterPageCount() in ppgwrap.cpp for when this happens.

    if ( (NULL != m_hwndSheet) && (!m_fOKToAlterPageCount) )
    {
        hr = SID_E_CANT_ALTER_PAGE_COUNT;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(GetCLSIDForPage(PageName, &clsidPage));

    // Determine flags for PROPSHEETPAGE from arguments

    if (ISPRESENT(UseHelpButton))
    {
        if (VT_BOOL != UseHelpButton.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        if (VARIANT_TRUE == UseHelpButton.boolVal)
        {
            dwFlags |= PSP_HASHELP;
        }
    }


    if (ISPRESENT(RightToLeft))
    {
        if (VT_BOOL != RightToLeft.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        if (VARIANT_TRUE == RightToLeft.boolVal)
        {
            dwFlags |= PSP_RTLREADING;
        }
    }

    if (ISPRESENT(InitData))
    {
        IfFailGo(CheckVariantForCrossThreadUsage(&InitData));
    }

    if (ISPRESENT(Caption))
    {
        if (VT_BSTR != Caption.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        pwszTitle = Caption.bstrVal;
        fReceivedCaption = TRUE;
    }

    // Get the page's preferred size. Get title string (for tab caption) if
    // none was passed as a parameter.

    IfFailGo(GetPageInfo(clsidPage, &cxPage, &cyPage,
                         fReceivedCaption ? NULL : &pwszTitle));

    // If we are a remote snap-in (will happen during source debugging) then
    // just accumulate the page data for now. CView::CreatePropertyPages or
    // CSnapIn::CreatePropertyPages will ask for it all when the VB code has
    // finished adding its pages.

    if (m_fWeAreRemote)
    {
        IfFailGo(AddRemotePage(clsidPage, dwFlags, cxPage, cyPage, pwszTitle,
                               cObjects, apunkObjects, InitData));
    }
    else
    {
        IfFailGo(AddLocalPage(clsidPage, dwFlags, cxPage, cyPage, pwszTitle,
                              cObjects, apunkObjects, InitData, FALSE,
                              fIsInsert, sPosition));
    }

Error:
    RRETURN(hr);
}




HRESULT CPropertySheet::AddLocalPage
(
    CLSID      clsidPage,
    DWORD      dwFlags,
    short      cxPage,
    short      cyPage,
    LPOLESTR   pwszTitle,
    ULONG      cObjects,
    IUnknown **apunkObjects,
    VARIANT    InitData,
    BOOL       fIsRemote,
    BOOL       fIsInsert,
    short      sPosition
)
{
    HRESULT                hr = S_OK;
    IUnknown              *punkPropertyPageWrapper = CPropertyPageWrapper::Create(NULL);
    CPropertyPageWrapper  *pPropertyPageWrapper = NULL;
    DLGTEMPLATE           *pDlgTemplate = NULL;
    DLGTEMPLATE          **ppDlgTemplates = NULL;
    HPROPSHEETPAGE         hPropSheetPage = NULL;
    char                  *pszTitle = NULL;

    PROPSHEETPAGE PropSheetPage;
    ::ZeroMemory(&PropSheetPage, sizeof(PropSheetPage));

    IfFalseGo(NULL != punkPropertyPageWrapper, SID_E_OUTOFMEMORY);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkPropertyPageWrapper,
                                                   &pPropertyPageWrapper));

    // CPropertyPage will get the COM property page parameters and return its
    // DLGTEMPLATE pointer.

    IfFailGo(pPropertyPageWrapper->CreatePage(this, clsidPage,
                                              m_fWizard,
                                              m_fConfigWizard,
                                              cObjects, apunkObjects,
                                              m_piSnapIn,
                                              cxPage, cyPage,
                                              InitData,
                                              fIsRemote,
                                              &pDlgTemplate));

    // Add the LPDLGTEMPLATE to our array.

    ppDlgTemplates =
          (DLGTEMPLATE **)::CtlAllocZero((m_cPages + 1) * sizeof(DLGTEMPLATE *));

    IfFalseGo(NULL != ppDlgTemplates, SID_E_OUTOFMEMORY);

    if (NULL != m_ppDlgTemplates)
    {
        ::memcpy(ppDlgTemplates, m_ppDlgTemplates,
                 m_cPages * sizeof(DLGTEMPLATE *));
        ::CtlFree(m_ppDlgTemplates);
    }
    m_ppDlgTemplates = ppDlgTemplates;
    m_ppDlgTemplates[m_cPages] = pDlgTemplate;
    m_cPages++;

    // Create the Win32 property page

    PropSheetPage.dwSize = sizeof(PropSheetPage);
    PropSheetPage.dwFlags = dwFlags;

    // Set additional flags
    // PSP_DLGINDIRECT: use DLGTEMPLATE in memory
    // PSP_USECALLBACK: use callback function (release ref when page is destroyed)

    PropSheetPage.dwFlags |= PSP_DLGINDIRECT | PSP_USECALLBACK;

    if (NULL != pwszTitle)
    {
        PropSheetPage.dwFlags |= PSP_USETITLE;
        IfFailGo(::ANSIFromWideStr(pwszTitle, &pszTitle));
        PropSheetPage.pszTitle = pszTitle;
    }

    if (m_fWizard)
    {
        PropSheetPage.dwFlags |= PSP_HIDEHEADER;
    }

    PropSheetPage.pResource = pDlgTemplate;

    PropSheetPage.pfnDlgProc =
                     CPropertyPageWrapper::DialogProc;

    PropSheetPage.pfnCallback =
    reinterpret_cast<LPFNPSPCALLBACK >(CPropertyPageWrapper::PropSheetPageProc);

    PropSheetPage.lParam = reinterpret_cast<LPARAM>(pPropertyPageWrapper);

    hPropSheetPage = ::CreatePropertySheetPage(&PropSheetPage);
    if (NULL == hPropSheetPage)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    // Add the property page to MMC's property sheet or to the running property
    // sheet

    if (NULL != m_hwndSheet)
    {
        if (fIsInsert)
        {
            // Clear last error because we don't know if prop sheet will set it
            ::SetLastError(0);

            if (!::SendMessage(m_hwndSheet, PSM_INSERTPAGE,
                               static_cast<WPARAM>(sPosition - 1),
                               (LPARAM)hPropSheetPage))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                if (S_OK == hr) // didn't set last error
                {
                    hr = E_FAIL;
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else
        {
            ::SendMessage(m_hwndSheet, PSM_ADDPAGE, 0, (LPARAM)hPropSheetPage);
        }
    }
    else
    {
        hr = m_piPropertySheetCallback->AddPage(hPropSheetPage);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    // We release the property page wrapper here. It stays alive because
    // CPropertyPage::CreatePage AddRef()s itself. It removes that ref
    // when the dialog box is destroyed.

    QUICK_RELEASE(punkPropertyPageWrapper);

    if (NULL != pszTitle)
    {
        ::CtlFree(pszTitle);
    }

    if ( FAILED(hr) && (NULL != hPropSheetPage) )
    {
        (void)::DestroyPropertySheetPage(hPropSheetPage);
    }

    if ( (SID_E_DETACHED_OBJECT == hr) || (SID_E_OUTOFMEMORY == hr) )
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}




HRESULT CPropertySheet::AddRemotePage
(
    CLSID      clsidPage,
    DWORD      dwFlags,
    short      cxPage,
    short      cyPage,
    LPOLESTR   pwszTitle,
    ULONG      cObjects,
    IUnknown **apunkObjects,
    VARIANT    InitData
)
{
    HRESULT             hr = S_OK;
    ULONG               i = 0;
    ULONG               cPages = 0;
    ULONG               cbPages = 0;
    BOOL                fFirstRemotePage = FALSE;
    WIRE_PROPERTYPAGES *pPages = NULL;
    WIRE_PROPERTYPAGE  *pPage = NULL;

    // These variables allow us to determine the actual size of a single page
    // including any alignment padding.

    static WIRE_PROPERTYPAGE aSizingPages[2];
    static ULONG             cbOnePage = (ULONG)(sizeof(aSizingPages) / 2);

    if (NULL != m_pWirePages)
    {
        fFirstRemotePage = FALSE;
        cPages = m_pWirePages->cPages + 1L;
    }
    else
    {
        fFirstRemotePage = TRUE;
        cPages = 1L;
    }

    // Determine the new amount of memory needed and allocate a new block

    cbPages = sizeof(WIRE_PROPERTYPAGES) + (cPages * cbOnePage);

    pPages = (WIRE_PROPERTYPAGES *)::CoTaskMemRealloc(m_pWirePages, cbPages);

    if (NULL == pPages)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set our pages pointer to the newly (re)allocated block.

    m_pWirePages = pPages;

    // If this is the first one then fill in the common info

    if (fFirstRemotePage)
    {
        IfFailGo(InitializeRemotePages(pPages));
    }
    else
    {
        // Not the first time. Just increment the page count.
        pPages->cPages++;
    }

    // Fill in the new page's info

    pPage = &pPages->aPages[cPages - 1L];

    pPage->clsidPage = clsidPage;

    pPage->apunkObjects = (IUnknown **)::CoTaskMemAlloc(cObjects * sizeof(IUnknown));
    if (NULL == pPage->apunkObjects)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(pPage->apunkObjects, apunkObjects, cObjects * sizeof(IUnknown));

    for (i = 0; i < cObjects; i++)
    {
        if (NULL != pPage->apunkObjects[i])
        {
            pPage->apunkObjects[i]->AddRef();
        }
    }

    pPage->cObjects = cObjects;

    ::VariantInit(&pPage->varInitData);
    hr = ::VariantCopy(&pPage->varInitData, &InitData);
    EXCEPTION_CHECK_GO(hr);

    pPage->dwFlags = dwFlags;

    pPage->cx = cxPage;
    pPage->cy = cyPage;
    IfFailGo(::CoTaskMemAllocString(pwszTitle, &pPage->pwszTitle));

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::InitializeRemotePages(WIRE_PROPERTYPAGES *pPages)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;

    pPages->clsidRemotePropertySheetManager = CLSID_MMCPropertySheet;
    pPages->fWizard = m_fWizard;
    pPages->fConfigWizard = m_fConfigWizard;

    IfFailGo(::CoTaskMemAllocString(m_pwszProgIDStart,
                                    &pPages->pwszProgIDStart));
    pPages->cPages = 1L;

    // If this is a configuration wizard then pass the ISnapIn to the
    // remote side so it can fire SnapIn_ConfigurationComplete

    if ( (NULL != m_piSnapIn) && m_fConfigWizard )
    {
        IfFailGo(m_piSnapIn->QueryInterface(IID_IUnknown,
                                  reinterpret_cast<void **>(&pPages->punkExtra)));
    }
    else
    {
        pPages->punkExtra = NULL;
    }

    pPages->apunkObjects = (IUnknown **)::CoTaskMemAlloc(m_cObjects *
                                                         sizeof(IUnknown));
    if (NULL == pPages->apunkObjects)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(pPages->apunkObjects, m_apunkObjects, m_cObjects * sizeof(IUnknown));

    for (i = 0; i < m_cObjects; i++)
    {
        if (NULL != pPages->apunkObjects[i])
        {
            pPages->apunkObjects[i]->AddRef();
        }
    }
    pPages->cObjects = m_cObjects;

    IfFailGo(CopyPageInfosToWire(pPages));

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::CopyPageInfosToWire(WIRE_PROPERTYPAGES *pPages)
{
    HRESULT  hr = S_OK;
    ULONG    i = 0;
    ULONG    cb = 0;
    short    cx = 0;
    short    cy = 0;

    // Make sure we have full page info for all of the snap-in's property pages

    if (!m_fHavePageCLSIDs)
    {
        IfFailGo(GetPageCLSIDs());
    }

    for (i = 0; i < m_cPageInfos; i++)
    {
        IfFailGo(GetPageInfo(m_paPageInfo[i].clsid, &cx, &cy, NULL));
    }

    // Allocate the PAGEINFOs memory

    cb = sizeof(PAGEINFOS) + (sizeof(PAGEINFO) * (m_cPageInfos - 1));

    pPages->pPageInfos = (PAGEINFOS *)::CoTaskMemAlloc(cb);

    if (NULL == pPages->pPageInfos)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::ZeroMemory(pPages->pPageInfos, cb);
    pPages->pPageInfos->cPages = m_cPageInfos;


    // Copy each element from m_paPageInfo to the wire version

    for (i = 0; i < m_cPageInfos; i++)
    {
        // First do do a block copy

        ::memcpy(&pPages->pPageInfos->aPageInfo[i], &m_paPageInfo[i], sizeof(PAGEINFO));

        // NULL out the string pointers in case memory allocation fails so we'll
        // know what needs to be freed

        pPages->pPageInfos->aPageInfo[i].pwszProgID = NULL;
        pPages->pPageInfos->aPageInfo[i].pwszTitle = NULL;

        // Allocate memeory for the strings and copy them

        IfFailGo(::CoTaskMemAllocString(m_paPageInfo[i].pwszProgID,
                              &(pPages->pPageInfos->aPageInfo[i].pwszProgID)));

        IfFailGo(::CoTaskMemAllocString(m_paPageInfo[i].pwszTitle,
                                &(pPages->pPageInfos->aPageInfo[i].pwszTitle)));
    }

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::CopyPageInfosFromWire(WIRE_PROPERTYPAGES *pPages)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;
    ULONG   cb = pPages->pPageInfos->cPages * sizeof(PAGEINFO);

    // Allocate memory for PAGEINFO array

    m_paPageInfo = (PAGEINFO *)::CtlAllocZero(cb);
    if (NULL == m_paPageInfo)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    m_cPageInfos = pPages->pPageInfos->cPages;

    // Cope each element

    for (i = 0; i < m_cPageInfos; i++)
    {
        // First do do a block copy

        ::memcpy(&m_paPageInfo[i], &pPages->pPageInfos->aPageInfo[i],
                 sizeof(PAGEINFO));

        // NULL out the string pointers in case memory allocation fails so we'll
        // know what needs to be freed

        m_paPageInfo[i].pwszProgID = NULL;
        m_paPageInfo[i].pwszTitle = NULL;

        // Allocate memeory for the strings and copy them. Use CoTaskMemAlloc
        // for title as in the non-remote case we would have received that
        // string from the property page and the destructor code uses
        // CoTaskMemFree.

        IfFailGo(::CoTaskMemAllocString(pPages->pPageInfos->aPageInfo[i].pwszTitle,
                                        &(m_paPageInfo[i].pwszTitle)));

        cb = (::wcslen(pPages->pPageInfos->aPageInfo[i].pwszProgID) + 1) * sizeof(WCHAR);
        m_paPageInfo[i].pwszProgID = (LPOLESTR)::CtlAllocZero(cb);
        if (NULL == m_paPageInfo[i].pwszProgID)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        ::memcpy(m_paPageInfo[i].pwszProgID,
                 pPages->pPageInfos->aPageInfo[i].pwszProgID, cb);

    }

Error:
    m_fHavePageCLSIDs = TRUE;
    RRETURN(hr);
}

HRESULT CPropertySheet::GetPageInfo
(
    CLSID     clsidPage,
    short    *pcx,
    short    *pcy,
    LPOLESTR *ppwszTitle
)
{
    HRESULT           hr = S_OK;
    IPropertyPage    *piPropertyPage = NULL;
    IMMCPropertyPage *piMMCPropertyPage = NULL;
    BOOL              fDlgUnitsSpecified = FALSE;
    ULONG             i = 0;
    BOOL              fFound = FALSE;
    PAGEINFO         *pPageInfo = NULL;

    VARIANT varX;
    ::VariantInit(&varX);

    VARIANT varY;
    ::VariantInit(&varY);

    PROPPAGEINFO PropPageInfo;
    ::ZeroMemory(&PropPageInfo, sizeof(PropPageInfo));

    // Search the PAGEINFO array and check if we already have the info for
    // this page.

    for (i = 0; (i < m_cPageInfos) & (!fFound); i++)
    {
        if (clsidPage == m_paPageInfo[i].clsid)
        {
            fFound = TRUE;
            pPageInfo = &m_paPageInfo[i];
        }
    }

    if (!fFound)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we already have the complete page info then we're done

    IfFalseGo(!pPageInfo->fHaveFullInfo, S_OK);

    // Create an instance of the page so we can get its page info

    hr = ::CoCreateInstance(clsidPage,
                            NULL, // no aggregation,
                            CLSCTX_INPROC_SERVER,
                            IID_IPropertyPage,
                            reinterpret_cast<void **>(&piPropertyPage));
    EXCEPTION_CHECK_GO(hr);


    // Get the page size and put it into the template. Need to set cb otherwise
    // VB will return E_UNEXPECTED.

    PropPageInfo.cb = sizeof(PropPageInfo);

    hr = piPropertyPage->GetPageInfo(&PropPageInfo);
    EXCEPTION_CHECK_GO(hr);

    pPageInfo->pwszTitle = PropPageInfo.pszTitle;

    // First check whether the property page would like to specify its size in
    // dialog units. If not then convert the size from GetPageInfo to dialog
    // units based on the font used by the PropertySheet API

    if (SUCCEEDED(piPropertyPage->QueryInterface(IID_IMMCPropertyPage,
                                reinterpret_cast<void **>(&piMMCPropertyPage))))
    {
        if (SUCCEEDED(piMMCPropertyPage->GetDialogUnitSize(&varY, &varX)))
        {
            if ( (!ISEMPTY(varX)) && (!ISEMPTY(varY)) )
            {
                if ( (SUCCEEDED(::VariantChangeType(&varX, &varX, 0, VT_I2))) &&
                     (SUCCEEDED(::VariantChangeType(&varY, &varY, 0, VT_I2))) )
                {
                    pPageInfo->cx = varX.iVal;
                    pPageInfo->cy = varY.iVal;
                    fDlgUnitsSpecified = TRUE;
                }
            }
        }
    }

    if (!fDlgUnitsSpecified)
    {
        IfFailGo(ConvertToDialogUnits(PropPageInfo.size.cx,
                                      PropPageInfo.size.cy,
                                      &pPageInfo->cx,
                                      &pPageInfo->cy));
    }

    pPageInfo->fHaveFullInfo = TRUE;

Error:
    if (SUCCEEDED(hr))
    {
        *pcx = pPageInfo->cx;
        *pcy = pPageInfo->cy;
        if (NULL != ppwszTitle)
        {
            *ppwszTitle = pPageInfo->pwszTitle;
        }
    }

    // Free any callee allocated memory from IPropertyPage::GetPageInfo() other
    // than the title which is freed by our caller (IPropertySheet::AddPage())

    if (NULL != PropPageInfo.pszDocString)
    {
        ::CoTaskMemFree(PropPageInfo.pszDocString);
    }
    if (NULL != PropPageInfo.pszHelpFile)
    {
        ::CoTaskMemFree(PropPageInfo.pszHelpFile);
    }

    QUICK_RELEASE(piPropertyPage);
    QUICK_RELEASE(piMMCPropertyPage);
    ::VariantClear(&varX);
    ::VariantClear(&varY);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CPropertySheet::ConvertToDialogUnits
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long   xPixels        [in] page width in pixels
//    long   yPixels        [in] page height in pixels
//    short *pxDlgUnits     [out] page width in Win32 PropertySheet dialog units
//    short *pyDlgUnits     [out] page heigth in Win32 PropertySheet dialog units
//
// Output:
//
// Notes:
//
// The size of the page returned from IPropertyPage::GetPageInfo() is in
// pixels. The size passed to the Win32 API CreatePropertySheetPage() must
// be in dialog units. Dialog units are based on the font used in the dialog
// and we have no way of knowing what the property page will be using. The only
// font we can be sure of is the one used by Win32 in the PropertySheet() API.
// This code gets the average character height and width of the Win32 property
// sheet font to do its calculations.

HRESULT CPropertySheet::ConvertToDialogUnits
(
    long   xPixels,
    long   yPixels,
    short *pxDlgUnits,
    short *pyDlgUnits
)
{
    HRESULT      hr = S_OK;

    IfFalseGo(!m_fHavePropSheetCharSizes, S_OK);
    IfFailGo(::GetPropSheetCharSizes(&m_cxPropSheetChar, &m_cyPropSheetChar));
    m_fHavePropSheetCharSizes = TRUE;

Error:

    // Translate pixels to dialog units.
    // After the 1st time this function runs execution should fall through to
    // here every time.

    // Add 1 character to each dimension to account for rounding in the text metric
    // calculations above.

    *pxDlgUnits = static_cast<short>(::MulDiv(xPixels, 4, m_cxPropSheetChar)) + 4;
    *pyDlgUnits = static_cast<short>(::MulDiv(yPixels, 8, m_cyPropSheetChar)) + 8;

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                        IMMCPropertySheet Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CPropertySheet::AddPage
(
    BSTR    PageName,
    VARIANT Caption,
    VARIANT UseHelpButton,
    VARIANT RightToLeft,
    VARIANT InitData
)
{
    HRESULT hr = InternalAddPage(PageName, m_cObjects, m_apunkObjects,
                                 Caption, UseHelpButton, RightToLeft, InitData,
                                 FALSE, // append (don't insert)
                                 0);    // insertion position (not used))
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::AddWizardPage
(
    BSTR       PageName,
    IDispatch *ConfigurationObject,
    VARIANT    UseHelpButton,
    VARIANT    RightToLeft,
    VARIANT    InitData,
    VARIANT    Caption
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkConfigObject = static_cast<IUnknown *>(ConfigurationObject);

    m_fWizard = TRUE;

    hr = InternalAddPage(PageName, 1L, &punkConfigObject,
                         Caption, UseHelpButton, RightToLeft, InitData,
                         FALSE, // append (don't insert)
                         0);    // insertion position (not used))
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::AddPageProvider
(
    BSTR        CLSIDPageProvider,
    long       *hwndSheet,
    IDispatch **PageProvider
)
{
    HRESULT    hr = S_OK;
    BSTR       bstrCLSIDPageProvider = NULL; // Don't SysFreeString this
    CLSID      clsidPageProvider = CLSID_NULL;
    IDispatch *pdispPageProvider = NULL;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ::CLSIDFromString(CLSIDPageProvider, &clsidPageProvider);
    EXCEPTION_CHECK_GO(hr);

    hr = ::CoCreateInstance(clsidPageProvider,
                            NULL, // no aggregation
                            CLSCTX_SERVER,
                            IID_IDispatch,
                            reinterpret_cast<void **>(&pdispPageProvider));
    EXCEPTION_CHECK_GO(hr);

    *hwndSheet = (long)m_hwndSheet;
    pdispPageProvider->AddRef();
    *PageProvider = pdispPageProvider;

Error:
    QUICK_RELEASE(pdispPageProvider);
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::ChangeCancelToClose()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!::PostMessage(m_hwndSheet, PSM_CANCELTOCLOSE, 0, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::InsertPage
(
    short   Position,
    BSTR    PageName,
    VARIANT Caption,
    VARIANT UseHelpButton,
    VARIANT RightToLeft,
    VARIANT InitData
)
{
    HRESULT hr = InternalAddPage(PageName, m_cObjects, m_apunkObjects,
                                 Caption, UseHelpButton, RightToLeft, InitData,
                                 TRUE, // insert (don't append)
                                 Position);
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::PressButton
(
    SnapInPropertySheetButtonConstants Button
)
{
    HRESULT hr = S_OK;
    WPARAM wpButton = PSBTN_BACK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    switch (Button)
    {
        case siApplyButton:
            wpButton = PSBTN_APPLYNOW;
            break;

        case siBackButton:
            wpButton = PSBTN_BACK;
            break;

        case siCancelButton:
            wpButton = PSBTN_CANCEL;
            break;

        case siFinishButton:
            wpButton = PSBTN_FINISH;
            break;

        case siHelpButton:
            wpButton = PSBTN_HELP;
            break;

        case siNextButton:
            wpButton = PSBTN_NEXT;
            break;

        case siOKButton:
            wpButton = PSBTN_OK;
            break;

        default:
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
            break;
    }

    if (!::PostMessage(m_hwndSheet, PSM_PRESSBUTTON, wpButton, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RecalcPageSizes()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Clear last error because we don't know if prop sheet will set it
    ::SetLastError(0);

    if (!::SendMessage(m_hwndSheet, PSM_RECALCPAGESIZES, 0, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (S_OK == hr) // didn't set last error
        {
            hr = E_FAIL;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RemovePage(short Position)
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the property sheet is currently being displayed then we need to
    // check whether it is OK to remove pages at this time. See calls to
    // SetOKToAlterPageCount() in ppgwrap.cpp for when this happens.

    if (m_fOKToAlterPageCount)
    {
        hr = SID_E_CANT_ALTER_PAGE_COUNT;
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndSheet, PSM_REMOVEPAGE,
                  static_cast<WPARAM>(Position - 1), 0);

Error:
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::ActivatePage(short Position)
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!::SendMessage(m_hwndSheet, PSM_SETCURSEL,
                       static_cast<WPARAM>(Position - 1), 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (S_OK == hr) // didn't set last error
        {
            hr = E_FAIL;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::SetFinishButtonText(BSTR Text)
{
    HRESULT  hr = S_OK;
    char    *pszText = NULL;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::ANSIFromWideStr(Text, &pszText));

    ::SendMessage(m_hwndSheet, PSM_SETFINISHTEXT, 0, (LPARAM)pszText);

Error:
    if (NULL != pszText)
    {
        CtlFree(pszText);
    }
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::SetTitle
(
    BSTR         Text,
    VARIANT_BOOL UsePropertiesForInTitle
)
{
    HRESULT  hr = S_OK;
    char    *pszText = NULL;
    WPARAM   wParam = 0;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::ANSIFromWideStr(Text, &pszText));

    if (VARIANT_TRUE == UsePropertiesForInTitle)
    {
        wParam = PSH_PROPTITLE;
    }

    ::SendMessage(m_hwndSheet, PSM_SETTITLE, wParam, (LPARAM)pszText);

Error:
    if (NULL != pszText)
    {
        CtlFree(pszText);
    }
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::SetWizardButtons
(
    VARIANT_BOOL              EnableBack,
    WizardPageButtonConstants NextOrFinish
)
{
    HRESULT hr = S_OK;
    LPARAM  lParam = 0;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (VARIANT_TRUE == EnableBack)
    {
        lParam |= PSWIZB_BACK;
    }

    switch (NextOrFinish)
    {
        case EnabledNextButton:
            lParam |= PSWIZB_NEXT;
            break;

        case EnabledFinishButton:
            lParam |= PSWIZB_FINISH;
            break;

        case DisabledFinishButton:
            lParam |= PSWIZB_DISABLEDFINISH;
            break;
    }

    if (!::PostMessage(m_hwndSheet, PSM_SETWIZBUTTONS, 0, (LPARAM)lParam))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::GetPagePosition(long hwndPage, short *psPosition)
{
    HRESULT hr = S_OK;
    LRESULT lrIndex = 0;

    *psPosition = 0;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Clear last error because we don't know if prop sheet will set it
    ::SetLastError(0);

    lrIndex = ::SendMessage(m_hwndSheet, PSM_HWNDTOINDEX,
                            (WPARAM)::GetParent((HWND)hwndPage), 0);
    if ((LRESULT)-1 == lrIndex)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (S_OK == hr) // didn't set last error
        {
            hr = E_INVALIDARG; // most likely reason for failure
        }
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        *psPosition = (short)lrIndex + 1;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RestartWindows()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndSheet, PSM_RESTARTWINDOWS, 0, 0);

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RebootSystem()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndSheet, PSM_REBOOTSYSTEM, 0, 0);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                  IRemotePropertySheetManager Methods
//=--------------------------------------------------------------------------=



//=--------------------------------------------------------------------------=
// CPropertySheet::CreateRemotePages             [IRemotePropertySheetManager]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IPropertySheetCallback *piPropertySheetCallback [in] These 3 params are
//   LONG_PTR                handle,                 [in] all from MMC's
//   IDataObject            *piDataObject,           [in] CreatePropertyPages
//                                                        call to the proxy
//
//   WIRE_PROPERTYPAGES     *pPages                  [in] This is returned
//                                                        from the remote snap-in
//
// Output:
//
// Notes:
//
// This class does double duty. When not running under source debugging, it
// implements our IMMCPropertSheet interface. When under source debugging it also
// serves as the remote property sheet manager required by the proxy. The proxy
// receives the CLSID of an object that implements this interface and it will
// CoCreateInstance that object. It makes this call passing the accumulated
// page descriptors that the remote snap-in collected from all of the VB code's
// PropertySheet.AddPage (or PropertySheet.AddWizardPage) calls. In this case
// this class will be running as an in=proc standalone object without the rest
// of the runtime. This method will make the AddPage (or AddWizardPage) calls
// on the proxy side (in the MMC process) so that the IPropertySheetCallback
// calls will be made in the right place. The objects passed to
// IPropertPage::SetObjects (see ppgwrap.cpp) will be remoted as well. When
// CPropertyPageWrapper::CreatePage CoCreateInstances the VB property page
// that will be handled by the class factory registered by VB in the IDE.
//
//

STDMETHODIMP CPropertySheet::CreateRemotePages
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    IDataObject            *piDataObject,
    WIRE_PROPERTYPAGES     *pPages
)
{
    HRESULT            hr = S_OK;
    ULONG              i = 0;
    ULONG              cb = 0;
    WIRE_PROPERTYPAGE *pPage = NULL;

    // Check for NULL as the snap-in may not have added any pages.

    IfFalseGo(NULL != pPages, S_FALSE);

    // Copy the ProgIDStart which will be used to find the CLSID of any
    // pages added while the sheet is displayed if the property page
    // calls MMCPropertySheet.AddPage or MMCPropertySheet.InsertPage.

    if (NULL != pPages->pwszProgIDStart)
    {
        IfFailGo(::CoTaskMemAllocString(pPages->pwszProgIDStart,
                                        &m_pwszProgIDStart));
    }

    // Copy the objects for which the sheet is being displayed

    if (NULL != pPages->apunkObjects)
    {
        cb = pPages->cObjects * sizeof(IUnknown);
        m_apunkObjects = (IUnknown **)CtlAllocZero(cb);
        if (NULL == m_apunkObjects)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        m_cObjects = pPages->cObjects;

        ::memcpy(m_apunkObjects, pPages->apunkObjects, cb);

        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != m_apunkObjects[i])
            {
                m_apunkObjects[i]->AddRef();
            }
        }
    }

    // Copy the CLSIDs and ProgIDs of all of the snap-in's property pages.
    // These will be used to find the the CLSID of any
    // pages added while the sheet is displayed if the property page
    // calls MMCPropertySheet.AddPage or MMCPropertySheet.InsertPage.

    IfFailGo(CopyPageInfosFromWire(pPages));

    // Get ISnapIn on the remote snap-in if available. If this is not a wizard
    // then it won't be there.

    if (NULL != pPages->punkExtra)
    {
        IfFailGo(pPages->punkExtra->QueryInterface(IID_ISnapIn,
                                         reinterpret_cast<void**>(&m_piSnapIn)));
    }

    // Store the callback for now. We'll release it at the end of this function

    RELEASE(m_piPropertySheetCallback);
    piPropertySheetCallback->AddRef();
    m_piPropertySheetCallback = piPropertySheetCallback;

    // Store the handle

    m_handle = handle;

    // Determine whether we are managing a wizard and whether is ia
    // configuration wizard (as opposed to a wizard invoked programmtically
    // by the snap-in using View.PropertySheetProvider

    m_fWizard = pPages->fWizard;
    m_fConfigWizard = pPages->fConfigWizard;

    // Create all of the pages and add them to MMC's property sheet

    for (i = 0, pPage = &pPages->aPages[0]; i < pPages->cPages; i++, pPage++)
    {
        IfFailGo(AddLocalPage(pPage->clsidPage,
                              pPage->dwFlags,
                              pPage->cx,
                              pPage->cy,
                              pPage->pwszTitle,
                              pPage->cObjects,
                              pPage->apunkObjects,
                              pPage->varInitData,
                              TRUE,  // remote
                              FALSE, // append (don't insert)
                              0));   // insertion position (not used)
    }

Error:
    RELEASE(m_piPropertySheetCallback);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CPropertySheet::InternalQueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IID_IMMCPropertySheet == riid)
    {
        *ppvObjOut = static_cast<IMMCPropertySheet *>(this);
        ExternalAddRef();
        return S_OK;
    }
    if (IID_IRemotePropertySheetManager == riid)
    {
        *ppvObjOut = static_cast<IRemotePropertySheetManager *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpchars.cpp ===
//=--------------------------------------------------------------------------=
// prpchars.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// GetPropSheetCharSizes() implementation 
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "prpchars.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Extended dialog templates (new in Win95). This is not defined in any
// header but we need it below in GetPropSheetFont()

#pragma pack(push, 1)
struct DLGTEMPLATEEX 
{
    WORD  dlgVer;
    WORD  signature;
    DWORD helpID;
    DWORD exStyle;
    DWORD style;
    WORD  cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
};
#pragma pack(pop)



//=--------------------------------------------------------------------------=
// GetPropSheetFont(HFONT *phFont)
//=--------------------------------------------------------------------------=
//
// Parameters:
//    HFONT *phFont  [out] HFONT of Win32 property sheet dialog font or
//                         reasonable equivalent. Can be NULL if font
//                         creation failed and function still returns S_OK.
//
// Output:
//
// Notes:
//
// This code is stolen from oleaut32.dll. The source is in
// e:\oa\src\stdtypes\oleframe.cpp. The routine is GetPropSheetFont().
//

static HRESULT GetPropSheetFont(HFONT *phFont)
{
    HRESULT      hr = S_OK;
    HINSTANCE    hInstComCtl32 = NULL;
    HRSRC        hResource = NULL;
    HGLOBAL      hTemplate = NULL;
    DLGTEMPLATE *pTemplate = NULL;
    BOOL         fDialogEx = NULL;
    WORD        *pWord = NULL;
    HDC          hdc = NULL;
    char        *pszFaceName = NULL;

    LOGFONT logfont;
    ::ZeroMemory(&logfont, sizeof(logfont));

    hInstComCtl32 = ::LoadLibrary("COMCTL32");
    IfFalseGo(NULL != hInstComCtl32, HRESULT_FROM_WIN32(::GetLastError()));

    // Find the dialog resource. The ID is hardcoded because as it is in
    // hte original code in oleaut32.dll. There is no Win32 header file that
    // contains this information.

    hResource = ::FindResource(hInstComCtl32, MAKEINTRESOURCE(1006), RT_DIALOG);
    IfFalseGo(NULL != hResource, HRESULT_FROM_WIN32(::GetLastError()));

    hTemplate = ::LoadResource(hInstComCtl32, hResource);
    IfFalseGo(NULL != hTemplate, HRESULT_FROM_WIN32(::GetLastError()));

    pTemplate = (DLGTEMPLATE *)::LockResource(hTemplate);
    IfFalseGo(NULL != pTemplate, HRESULT_FROM_WIN32(::GetLastError()));

    // Check that the style includes DS_SETFONT. This should be there but
    // if it is ever changed then there would not be any font info following
    // the template.

    IfFalseGo(DS_SETFONT == (pTemplate->style & DS_SETFONT), E_FAIL);

    // Now determine whether it is actually a DLGTEMPLATE or DLGTEMPLATEX and
    // get a pointer to the first word following the template.

    fDialogEx = ((pTemplate->style & 0xFFFF0000) == 0xFFFF0000);

    if (fDialogEx)
        pWord = (WORD *)((DLGTEMPLATEEX *)pTemplate + 1);
    else
        pWord = (WORD *)(pTemplate + 1);

    // At the end of the template we have the menu name, the window class name,
    // and the caption. Each of these is indicated by a WORD array as follows:
    // If the 1st WORD is 0 then the item is not present (e.g. there is
    // no class name).
    //
    // For the menu, if the 1st WORD is 0xFFFF then the 2nd WORD is an
    // identifier for a menu resource. If it is anything else then the 1st WORD
    // contains the 1st character of a null-terminated UNICODE string containing
    // the name of the menu resource.
    //
    // For the window class, if the 1st WORD is 0xFFFF then the 2nd WORD
    // contains a predefined system window class identifier. If the 1st
    // WORD is anything else then it is the first character of a null-terminated
    // UNICODE string containing the window class name.
    //
    // For the caption if the 1st WORD is not zero then it is the first
    // character in a null-terminated UNICODE string containing the window
    // class name.

    // Skip menu resource string or ID
    if (*pWord == (WORD)-1)
    {
        pWord += 2; // advance 2 WORDs
    }
    else
    {
        while (0 == *pWord)
        {
            pWord++;
        }
    }

    // Skip class name string or ID
    if (*pWord == (WORD)-1)
    {
        pWord += 2; // advance 2 WORDs
    }
    else
    {
        while (0 == *pWord)
        {
            pWord++;
        }
    }

    // Skip caption string
    while (0 == *pWord)
    {
        pWord++;
    }

    // At this point pWord points to the dialog font's point size. We need to
    // convert this value to logical units in order to create the font. The
    // formula is (DialogPointSize x VerticalPixelsPerInch) / PointsPerInch.
    //
    // LOGPIXELSY returns the number of pixels per inch along the screen
    // height. A point is 1/72 of an inch. We use the negation of the
    // calculation in order to tell the CreateFontIndirect() API that we want
    // the font mapper to convert it to device units and match the absolute
    // value against character height of available fonts. See the documentation
    // for LOGFONT in the Platform SDK for more info.

    // Get a screen DC
    hdc = ::GetDC(NULL);
    IfFalseGo(NULL != hdc, HRESULT_FROM_WIN32(::GetLastError()));

    logfont.lfHeight = -::MulDiv(*pWord, ::GetDeviceCaps(hdc, LOGPIXELSY), 72);

    // If this is a DLGTEMPLATEEX then the next 2 WORDs contain the weight and
    // italic flag.

    pWord += (fDialogEx ? 3 : 1);

    // At this point pWord points to a null-terminated UNICODE string containing
    // the font face name.

    IfFailGo(::ANSIFromWideStr((WCHAR *)pWord, &pszFaceName));
    ::strcpy(logfont.lfFaceName, pszFaceName);

Error:

    // If anything failed above then use a default font and height. This will
    // produce a reasonable result and allow the property page to be
    // displayed.

    if (FAILED(hr))
    {
        logfont.lfHeight = 8;
        ::strcpy(logfont.lfFaceName, "MS Sans Serif");
        hr = S_OK;
    }

    // Attempt to create the font and return the handle

    logfont.lfWeight = FW_NORMAL;
    logfont.lfCharSet = DEFAULT_CHARSET;

    *phFont = ::CreateFontIndirect(&logfont);

    if (NULL != hInstComCtl32)
    {
        ::FreeLibrary(hInstComCtl32);
    }
    if (NULL != pszFaceName)
    {
        CtlFree(pszFaceName);
    }
    if (NULL != hdc)
    {
        (void)::ReleaseDC(NULL, hdc);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// GetPropSheetCharSizes
//=--------------------------------------------------------------------------=
//
// Parameters:
//  UINT *pcxPropSheetChar  [out] average char width in a Win32 property sheet
//  UINT *pcyPropSheetChar  [out] average char height in a Win32 property sheet
//
// Output:
//
// Notes:
//
// This code is stolen from oleaut32.dll. The source is in
// e:\oa\src\stdtypes\oleframe.cpp. The main routine is
// CPageHolderTemplate::SetSize() and it calls one other function
// GetPropSheetFont().
//
// The size of the page returned from IPropertyPage::GetPageInfo() is in
// pixels. The size passed to the Win32 API CreatePropertySheetPage() must
// be in dialog units. Dialog units are based on the font used in the dialog
// and we have no way of knowing what the property page will be using. The only
// font we can be sure of is the one used by Win32 in the PropertySheet() API.
// This code loads comctl32.dll and loads the dialog resource used by Win32
// for the property sheet frame. It then interprets the DLGTEMLATE and related
// data to extract the font used. If any error occurs then it uses 8 point
// "MS Sans Serif" normal.

HRESULT DLLEXPORT GetPropSheetCharSizes
(
    UINT *pcxPropSheetChar,
    UINT *pcyPropSheetChar
)
{
    HRESULT      hr = S_OK;
    HDC          hdc = NULL;
    HFONT        hFont = NULL;
    HFONT        hfontOld = NULL;
    LONG         lSizes = 0;
    BOOL         fOK = FALSE;

    static BOOL fHaveCharSizes = FALSE;
    static UINT cxPropSheetChar = 0;
    static UINT cyPropSheetChar = 0;

    SIZE size;
    ::ZeroMemory(&size, sizeof(size));

    TEXTMETRIC tm;
    ::ZeroMemory(&tm, sizeof(tm));

    IfFalseGo(!fHaveCharSizes, S_OK);

    // Create the font and determine the average character height and width.
    // If font creation fails then use GetDialogBaseUnits() which will return
    // the average width and height of the system font.

    IfFailGo(GetPropSheetFont(&hFont));
    if (NULL != hFont)
    {
        // Get a screen DC
        hdc = ::CreateCompatibleDC(NULL);
        IfFalseGo(NULL != hdc, S_OK);

        hfontOld = (HFONT)::SelectObject(hdc, hFont);
        IfFalseGo(::GetTextMetrics(hdc, &tm), S_OK);
        fOK = ::GetTextExtentPointA(hdc,
                                    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
                                    52, &size);
        IfFalseGo(fOK, S_OK);

        // The cx calculation is done differently in OleCreatePropertyFrame()
        // and in MapDialogRect(). MapDialogRect() calls the internal
        // utility function GdiGetCharDimensions() in
        // nt\private\ntos\w32\ntgdi\client\cfont.c and that code does it
        // this way.
        
        cxPropSheetChar = ((size.cx / 26) + 1) / 2; // round up
        cyPropSheetChar = tm.tmHeight + tm.tmExternalLeading;
        fHaveCharSizes = TRUE;

        (void)::SelectObject(hdc, hfontOld);
    }

Error:

    if (!fHaveCharSizes)
    {
        // Could not create the font or some other failure above so just use
        // the system's values

        lSizes = ::GetDialogBaseUnits();
        cxPropSheetChar = LOWORD(lSizes);
        cyPropSheetChar = HIWORD(lSizes);
        fHaveCharSizes = TRUE;
    }

    *pcxPropSheetChar = cxPropSheetChar;
    *pcyPropSheetChar = cyPropSheetChar;

    if (NULL != hdc)
    {
        (void)::DeleteDC(hdc);
    }
    if (NULL != hFont)
    {
        (void)::DeleteObject((HGDIOBJ)hFont);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\pshtprov.cpp ===
//=--------------------------------------------------------------------------=
// pshtprov.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCPropertySheetProvider class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "pshtprov.h"
#include "scopitem.h"
#include "listitem.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CMMCPropertySheetProvider::CMMCPropertySheetProvider(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                  OBJECT_TYPE_PROPERTYSHEETPROVIDER,
                                  static_cast<IMMCPropertySheetProvider *>(this),
                                  static_cast<CMMCPropertySheetProvider *>(this),
                                  0,    // no property pages
                                  NULL, // no property pages
                                  NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


IUnknown *CMMCPropertySheetProvider::Create(IUnknown *punkOuter)
{
    CMMCPropertySheetProvider *pPropertySheetProvider =
                                        New CMMCPropertySheetProvider(punkOuter);

    if (NULL == pPropertySheetProvider)
    {
        GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
        return NULL;
    }
    else
    {
        return pPropertySheetProvider->PrivateUnknown();
    }
}

CMMCPropertySheetProvider::~CMMCPropertySheetProvider()
{
    RELEASE(m_piPropertySheetProvider);
    RELEASE(m_punkView);
    RELEASE(m_piDataObject);
    RELEASE(m_piComponent);
    InitMemberVariables();
}

void CMMCPropertySheetProvider::InitMemberVariables()
{
    m_piPropertySheetProvider = NULL;
    m_pView = NULL;
    m_punkView = NULL;
    m_piDataObject = NULL;
    m_piComponent = NULL;
    m_fHaveSheet = FALSE;
    m_fWizard = FALSE;
}


HRESULT CMMCPropertySheetProvider::SetProvider
(
    IPropertySheetProvider *piPropertySheetProvider,
    CView                  *pView
)
{
    HRESULT hr = S_OK;

    RELEASE(m_piPropertySheetProvider);
    if (NULL != piPropertySheetProvider)
    {
        piPropertySheetProvider->AddRef();
    }
    m_piPropertySheetProvider = piPropertySheetProvider;

    m_pView = pView;
    RELEASE(m_punkView);
    RELEASE(m_piComponent);

    IfFalseGo(NULL != pView, S_OK);

    IfFailGo(pView->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&m_punkView)));
    
    IfFailGo(pView->QueryInterface(IID_IComponent,
                                   reinterpret_cast<void **>(&m_piComponent)));
Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IMMCPropertySheetProvider Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCPropertySheetProvider::CreatePropertySheet
(
    BSTR                              Title, 
    SnapInPropertySheetTypeConstants  Type,
    VARIANT                           Objects,
    VARIANT                           UsePropertiesForInTitle,
    VARIANT                           UseApplyButton
)
{
    HRESULT       hr = S_OK;
    IDataObject  *piDataObject = NULL;
    boolean       fIsPropertySheet = FALSE;
    DWORD         dwOptions = 0;
    MMC_COOKIE    cookie = 0;
    CScopeItem   *pScopeItem = NULL;
    IScopeItem   *piScopeItem = NULL;
    CMMCListItem *pMMCListItem = NULL;
    IMMCListItem *piMMCListItem = NULL;

    // Make sure this MMPropertySheetProvider object is connected to MMC.

    if (NULL == m_piPropertySheetProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the IDataObject and cookie for the specified object(s)

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    // Determine whether it is a property sheet or a wizard

    if (siPropertySheet == Type)
    {
        fIsPropertySheet = TRUE; // create a property sheet
        m_fWizard = FALSE;
    }
    else
    {
        fIsPropertySheet = FALSE; // create a wizard
        m_fWizard = TRUE;
    }

    // If it is a wizard and it is Wizard87 style then set that option bit

    if (siWizard97 == Type)
    {
        dwOptions |= MMC_PSO_NEWWIZARDTYPE;
    }

    // If it's a property sheet then determine whether to prepend
    // "Properties for" to the title bar

    if (fIsPropertySheet)
    {
        if (ISPRESENT(UsePropertiesForInTitle))
        {
            if (VT_BOOL != UsePropertiesForInTitle.vt)
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }

            if (VARIANT_FALSE == UsePropertiesForInTitle.boolVal)
            {
                dwOptions |= MMC_PSO_NO_PROPTITLE;
            }
        }
    }

    // Determine whether there should be an "Apply" button

    if (ISPRESENT(UseApplyButton))
    {
        if (VT_BOOL != UseApplyButton.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        if (VARIANT_FALSE == UseApplyButton.boolVal)
        {
            dwOptions |= MMC_PSO_NOAPPLYNOW;
        }
    }

    // Release any previously used sheet. MMC normally requires doing this
    // if a property sheet is created but never shown. We did it here just in
    // case that occurred previously.

    IfFailGo(Clear());

    // We need to add an extra ref to the data object here
    // because of NTBUGS 318357. MMC does not AddRef the data object. This should
    // be fixed in 1.2 but 1.1 was released with the bug.
    
    piDataObject->AddRef();
    m_piDataObject = piDataObject;

    // Create the new sheet.

    hr = m_piPropertySheetProvider->CreatePropertySheet(Title,  fIsPropertySheet,
                                                        cookie, piDataObject,
                                                        dwOptions);
    if (FAILED(hr))
    {
        RELEASE(m_piDataObject);
    }
    EXCEPTION_CHECK_GO(hr);

    m_fHaveSheet = TRUE;

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::AddPrimaryPages(VARIANT_BOOL InScopePane)
{
    HRESULT hr = S_OK;

    if ( (NULL == m_piPropertySheetProvider) || (NULL == m_punkView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piPropertySheetProvider->AddPrimaryPages(
                                               m_punkView,
                                               FALSE, // don't create handle
                                               NULL,
                                               VARIANTBOOL_TO_BOOL(InScopePane));

    // If the call failed then we need to tell MMC to release allocated resources
    
    if (FAILED(hr))
    {
        Clear();
    }
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::AddExtensionPages()
{
    HRESULT hr = S_OK;

    if (NULL == m_piPropertySheetProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piPropertySheetProvider->AddExtensionPages();

    // If the call failed then we need to tell MMC to release allocated resources

    if (FAILED(hr))
    {
        Clear();
    }

    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::Show
(
    int     Page,
    VARIANT hwnd
)
{
    HRESULT         hr = S_OK;
    long            lHwnd = NULL;
    BOOL            fRegisteredOurFilter = FALSE;
    IMessageFilter *piOldMessageFilter = NULL;
    IMessageFilter *piOurMessageFilter = NULL;

    if ( (NULL == m_piPropertySheetProvider) || (NULL == m_pView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    if (ISPRESENT(hwnd))
    {
        lHwnd = hwnd.lVal;
    }
    else
    {
        hr = m_pView->GetIConsole2()->GetMainWindow(
                                               reinterpret_cast<HWND *>(&lHwnd));
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are remote and running a wizard then install our message filter for
    // IPropertySheetProvider->Show because VB's message filter will throw out
    // mouse and keyboard messages. This would not allow the developer to
    // enter input into a property page while debugging. OLE calls the message
    // filter because VB is in a pending remote call for the duration of the
    // wizard and clicking on a control in a property page generates a message
    // in VB's queue.

    if (m_fWizard && m_pView->GetSnapIn()->WeAreRemote())
    {
        hr = ::CoRegisterMessageFilter(static_cast<IMessageFilter *>(this),
                                       &piOldMessageFilter);
        EXCEPTION_CHECK_GO(hr);
        fRegisteredOurFilter = TRUE;
    }

    // We get the page number one-based so subtract one

    hr = m_piPropertySheetProvider->Show(lHwnd, Page - 1);

    // If the call failed then we need to tell MMC to release allocated resources

    if (FAILED(hr))
    {
        Clear();
    }

    // If this is a wizard then we can release the extra ref on the data object
    // because wizards are synchronous. (See CreatePropertySheet for why we need
    // this ref). If it is not a wizard, then we are going to leak.

    if (m_fWizard)
    {
        RELEASE(m_piDataObject);
    }

    // Either way, following Show MMC considers the sheet gone. Reset our flag
    // so any subsequent calls to MMCPropertySheetProvider.Clear() will not call
    // into MMC (such a call would fail after a succesful call to
    // IPropertySheetProvider::Show()).
    
    m_fHaveSheet = FALSE;

    EXCEPTION_CHECK_GO(hr);

Error:

    // If we registered a message filter then remove it here.
    
    if (fRegisteredOurFilter)
    {
        if (SUCCEEDED(::CoRegisterMessageFilter(piOldMessageFilter,
                                                &piOurMessageFilter)))
        {
            // If we got back a message filter then release it
            if (NULL != piOurMessageFilter)
            {
                piOurMessageFilter->Release();
            }
        }
        
        // If we got back a message filter before the Show call then release it
        if (NULL != piOldMessageFilter)
        {
            piOldMessageFilter->Release();
        }
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::FindPropertySheet
(
    VARIANT       Objects,
    VARIANT_BOOL *pfvarFound
)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    IDataObject *piDataObject = NULL;

    if (NULL == pfvarFound)
    {
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    *pfvarFound = VARIANT_FALSE;

    if ( (NULL == m_piPropertySheetProvider) || (NULL == m_piComponent) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the IDataObject and cookie for the specified object(s)

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    // Use IComponent in the FindPropertySheet call to MMC so that our
    // IComponent::CompareObjects()  will be called. This is necessary because
    // in the case of a multiselection CompareObjects() must manually compare
    // the elements in the data object's scope item and list item collections.
    // A simple cookie comparison cannot be used because all multi-select
    // property pages use MMC_MULTI_SELECT_COOKIE.

    hr = m_piPropertySheetProvider->FindPropertySheet(cookie,
                                                      m_piComponent,
                                                      piDataObject);

    // If the call failed then we need to tell MMC to release allocated resources

    if (FAILED(hr))
    {
        Clear();
    }

    EXCEPTION_CHECK_GO(hr);
    if (S_OK == hr)
    {
        *pfvarFound = VARIANT_TRUE;
    }

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::Clear()
{
    HRESULT hr = S_OK;

    RELEASE(m_piDataObject);

    if (NULL == m_piPropertySheetProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }
    if (m_fHaveSheet)
    {
        (void)m_piPropertySheetProvider->Show(-1, 0);
    }
    m_fHaveSheet = FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IMessageFilter Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP_(DWORD) CMMCPropertySheetProvider::HandleInComingCall
( 
    DWORD dwCallType,
    HTASK htaskCaller,
    DWORD dwTickCount,
    LPINTERFACEINFO lpInterfaceInfo
)
{
    // this should never be called as it is for servers and this filter is here
    // for handling a client side situation
    return SERVERCALL_ISHANDLED;
}

STDMETHODIMP_(DWORD) CMMCPropertySheetProvider::RetryRejectedCall( 
    HTASK htaskCallee,
    DWORD dwTickCount,
    DWORD dwRejectType)
{
    return (DWORD)1; // retry call immediately
}

STDMETHODIMP_(DWORD) CMMCPropertySheetProvider::MessagePending
( 
    HTASK htaskCallee,
    DWORD dwTickCount,
    DWORD dwPendingType
)
{

    BOOL fGotQuitMessage = FALSE;

    MSG msg;
    ::ZeroMemory(&msg, sizeof(msg));

    // Pump messages until queue is empty or we get a WM_QUIT. This will ensure
    // that mouse clicks and keys get to the property page.

    while ( (!fGotQuitMessage) && ::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
    {
        if (WM_QUIT == msg.message)
        {
            ::PostQuitMessage((int) msg.wParam);
            fGotQuitMessage = TRUE;
        }
        else
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }

    return PENDINGMSG_WAITNOPROCESS; // Tell OLE to keep the call alive
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCPropertySheetProvider::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCPropertySheetProvider == riid)
    {
        *ppvObjOut = static_cast<IMMCPropertySheetProvider *>(this);
        ExternalAddRef();
        return S_OK;
    }
    if (IID_IMessageFilter == riid)
    {
        *ppvObjOut = static_cast<IMMCPropertySheetProvider *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpsheet.h ===
//=--------------------------------------------------------------------------=
// prpsheet.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertySheet class definition - implements MMCPropertySheet object and
// IRemotePropertySheetManager used during debugging
//
//=--------------------------------------------------------------------------=

#ifndef _PRPSHEET_DEFINED_
#define _PRPSHEET_DEFINED_


class CPropertySheet : public CSnapInAutomationObject,
                       public IMMCPropertySheet,
                       public IRemotePropertySheetManager
{
    protected:
        CPropertySheet(IUnknown *punkOuter);
        ~CPropertySheet();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        void SetWizard() { m_fWizard = TRUE; }
        HRESULT SetCallback(IPropertySheetCallback *piPropertySheetCallback,
                            LONG_PTR                handle,
                            LPOLESTR                pwszProgIDStart,
                            IMMCClipboard          *piMMCClipboard,
                            ISnapIn                *piSnapIn,
                            BOOL                    fConfigWizard);

        HRESULT GetTemplate(long lNextPage, DLGTEMPLATE **ppDlgTemplate);

        void YouAreRemote() { m_fWeAreRemote = TRUE; }

        void SetHWNDSheet(HWND hwndSheet) { m_hwndSheet = hwndSheet; }

        // Set from CPropertyPageWrapper as it enters and leaves message
        // handlers during which property pages cannot call AddPage, InsertPage
        // RemovePage

        void SetOKToAlterPageCount(BOOL fOK) { m_fOKToAlterPageCount = fOK; }

        // Called during debugging to return property page definitions to proxy

        WIRE_PROPERTYPAGES *TakeWirePages();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IMMCPropertySheet
    public:
        STDMETHOD(AddPage)(BSTR    PageName,
                           VARIANT Caption,
                           VARIANT UseHelpButton,
                           VARIANT RightToLeft,
                           VARIANT InitData);
        STDMETHOD(AddWizardPage)(BSTR       PageName,
                                 IDispatch *ConfigurationObject,
                                 VARIANT    UseHelpButton,
                                 VARIANT    RightToLeft,
                                 VARIANT    InitData,
                                 VARIANT    Caption);
        STDMETHOD(AddPageProvider)(BSTR               CLSIDPageProvider,
                                   long              *hwndSheet,
                                   IDispatch        **PageProvider);
        STDMETHOD(ChangeCancelToClose)();
        STDMETHOD(InsertPage)(short   Position,
                              BSTR    PageName,
                              VARIANT Caption,
                              VARIANT UseHelpButton,
                              VARIANT RightToLeft,
                              VARIANT InitData);
        STDMETHOD(PressButton)(SnapInPropertySheetButtonConstants Button);
        STDMETHOD(RecalcPageSizes)();
        STDMETHOD(RemovePage)(short Position);
        STDMETHOD(ActivatePage)(short Position);
        STDMETHOD(SetFinishButtonText)(BSTR Text);
        STDMETHOD(SetTitle)(BSTR Text, VARIANT_BOOL UsePropertiesForInTitle);
        STDMETHOD(SetWizardButtons)(VARIANT_BOOL              EnableBack,
                                    WizardPageButtonConstants NextOrFinish);
        STDMETHOD(GetPagePosition)(long hwndPage, short *psPosition);
        STDMETHOD(RestartWindows)();
        STDMETHOD(RebootSystem)();

    // IRemotePropertySheetManager
    private:
        STDMETHOD(CreateRemotePages)(IPropertySheetCallback *piPropertySheetCallback,
                                     LONG_PTR                handle,
                                     IDataObject            *piDataObject,
                                     WIRE_PROPERTYPAGES     *pPages);

        void InitMemberVariables();
        void ReleaseObjects();
        HRESULT GetPageCLSIDs();
        HRESULT InitializeRemotePages(WIRE_PROPERTYPAGES *pPages);
        HRESULT CopyPageInfosToWire(WIRE_PROPERTYPAGES *pPages);
        HRESULT CopyPageInfosFromWire(WIRE_PROPERTYPAGES *pPages);
        HRESULT GetCLSIDForPage(BSTR PageName, CLSID *clsidPage);
        HRESULT InternalAddPage(BSTR      PageName,
                                ULONG      cObjects,
                                IUnknown **apunkObjects,
                                VARIANT    Caption,
                                VARIANT    UseHelpButton,
                                VARIANT    RightToLeft,
                                VARIANT    InitData,
                                BOOL       fIsInsert,
                                short      sPosition);

        HRESULT AddLocalPage(CLSID      clsidPage,
                             DWORD      dwFlags,
                             short      cxPage,
                             short      cyPage,
                             LPOLESTR   pwszTitle,
                             ULONG      cObjects,
                             IUnknown **apunkObjects,
                             VARIANT    InitData,
                             BOOL       fIsRemote,
                             BOOL       fIsInsert,
                             short      sPosition);

        HRESULT AddRemotePage(CLSID      clsidPage,
                              DWORD      dwFlags,
                              short      cxPage,
                              short      cyPage,
                              LPOLESTR   pwszTitle,
                              ULONG      cObjects,
                              IUnknown **apunkObjects,
                              VARIANT    InitData);

        HRESULT GetPageInfo(CLSID     clsidPage,
                            short    *pcx,
                            short    *pcy,
                            LPOLESTR *ppwszTitle);

        HRESULT ConvertToDialogUnits(long   xPixels,
                                     long   yPixels,
                                     short *pxDlgUnits,
                                     short *pyDlgUnits);

        IPropertySheetCallback  *m_piPropertySheetCallback; // MMC interface

        LONG_PTR                 m_handle;          // MMC proppage handle
        long                     m_cPages;          // # of pages in sheet
        DLGTEMPLATE            **m_ppDlgTemplates;  // dlg templates for pages
        LPOLESTR                 m_pwszProgIDStart; // Left hand side of snap-in's
                                                    // ProgID (project name)
        IUnknown               **m_apunkObjects;    // objects for which props
                                                    // are being displayed
        ULONG                    m_cObjects;        // no. of those objects
        ISnapIn                 *m_piSnapIn;        // pointer to owning snap-in
        PAGEINFO                *m_paPageInfo;      // From IPropertyPage::GetPageInfo
        ULONG                    m_cPageInfos;      // # of PAGEINFOs in array
        BOOL                     m_fHavePageCLSIDs; // TRUE=ISpecifyPropertyPages
                                                    // called for all pages
        BOOL                     m_fWizard;         // TRUE=this is a wizard
        BOOL                     m_fConfigWizard;   // TRUE=this is config wizard
        WIRE_PROPERTYPAGES      *m_pWirePages;      // ptr to page defs for proxy
        HWND                     m_hwndSheet;       // Property sheet's hwnd
        BOOL                     m_fOKToAlterPageCount; // TRUE=prop pages can
                                                        // call AddPage, InsertPage
                                                        // RemovePage

        // Store the Win32 PropertSheet() font dimensions here. We only
        // get these for the first property sheet displayed for any snap-in
        // once the runtime is loaded into MMC.EXE.
        
        static UINT              m_cxPropSheetChar;
        static UINT              m_cyPropSheetChar;
        static BOOL              m_fHavePropSheetCharSizes;

        BOOL                     m_fWeAreRemote;    // indicates whether
                                                    // the snap-in is being
                                                    // run remotely (in an F5
                                                    // for source debugging)
};


DEFINE_AUTOMATIONOBJECTWEVENTS2(PropertySheet,                    // name
                                &CLSID_MMCPropertySheet,          // clsid
                                "PropertySheet",                  // objname
                                "PropertySheet",                  // lblname
                                &CPropertySheet::Create,          // creation function
                                TLIB_VERSION_MAJOR,               // major version
                                TLIB_VERSION_MINOR,               // minor version
                                &IID_IMMCPropertySheet,           // dispatch IID
                                NULL,                             // event IID
                                HELP_FILENAME,                    // help file
                                TRUE);                            // thread safe


#endif _PRPSHEET_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ppgwrap.h ===
//=--------------------------------------------------------------------------=
// ppgwrap.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertyPageWrapper class definition
//
// This class implements a dialog box wrapper around a COM property page. It
// parents the page within an empty dialog box and implements
// IPropertyPageSite for the page. WM_NOITFY messages with PSN_XXXX
// notifications are translated into IPropertyPage calls and passed on to
// the property page. If the page implements the IWizardPage interface (defined
// by us in mssnapr.idl) then it will also receive PSN_WIZXXX notifications.
//=--------------------------------------------------------------------------=

#ifndef _PPGWRAP_DEFINED_
#define _PPGWRAP_DEFINED_

#include "prpsheet.h"

class CPropertyPageMarshalHelper;

class CPropertyPageWrapper : public CSnapInAutomationObject,
                             public IPropertyPageSite
{
private:
    friend class CPropertyPageMarshalHelper;
    CPropertyPageMarshalHelper * m_pHelper;

    protected:
        CPropertyPageWrapper(IUnknown *punkOuter);
        ~CPropertyPageWrapper();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT CreatePage(CPropertySheet  *pPropertySheet,
                           CLSID            clsidPage,
                           BOOL             fWizard,
                           BOOL             fConfigWizard,
                           ULONG            cObjects,
                           IUnknown       **apunkObjects,
                           ISnapIn         *piSnapIn,
                           short            cxPage,
                           short            cyPage,
                           VARIANT          varInitData,
                           BOOL             fIsRemote,
                           DLGTEMPLATE    **ppTemplate);

        HWND GetSheetHWND() { return m_hwndSheet; }

        static BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg,
                                        WPARAM wParam, LPARAM lParam);

        static UINT CALLBACK PropSheetPageProc(HWND hwnd, UINT uMsg,
                                               PROPSHEETPAGE *pPropSheetPage);

    protected:

        // Dialog Message Handlers
        
        HRESULT OnInitDialog(HWND hwndDlg);
        HRESULT OnInitMsg();
        HRESULT OnApply(LRESULT *plresult);
        HRESULT OnSetActive(HWND hwndSheet, LRESULT *plresult);
        HRESULT OnKillActive(LRESULT *plresult);
        HRESULT OnWizBack(LRESULT *plresult);
        HRESULT OnWizNext(LRESULT *plresult);
        HRESULT OnWizFinish(LRESULT *plresult);
        HRESULT OnQueryCancel(LRESULT *plresult);
        HRESULT OnReset(BOOL fClickedXButton);
        HRESULT OnHelp();
        HRESULT OnSize();
        HRESULT OnDestroy();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

    // IPropertyPageSite
        STDMETHOD(OnStatusChange)(DWORD dwFlags);
        STDMETHOD(GetLocaleID)(LCID *pLocaleID);
        STDMETHOD(GetPageContainer)(IUnknown **ppunkContainer);
        STDMETHOD(TranslateAccelerator)(MSG *pMsg);

        void InitMemberVariables();
        HRESULT InitPage();
        HRESULT GetNextPage(long *lNextPage);
        HRESULT ActivatePage();
        HRESULT AddMsgFilterHook();
        HRESULT RemoveMsgFilterHook();
        static LRESULT CALLBACK MessageProc(int code,
                                            WPARAM wParam, LPARAM lParam);

        CPropertySheet     *m_pPropertySheet;     // cross-thread C++ pointer
        IMMCPropertySheet  *m_piMMCPropertySheet; // marshaled across threads
        IPropertyPage      *m_piPropertyPage;     // interface on VB prop page
        IMMCPropertyPage   *m_piMMCPropertyPage;  // interface on VB prop page
        IWizardPage        *m_piWizardPage;       // interface on VB prop page
        BOOL                m_fWizard;            // TRUE=this page is in a wizard
        BOOL                m_fConfigWizard;      // TRUE=this page is in a config wizard
        DLGTEMPLATE        *m_pTemplate;          // template for wrapper dialog
        HWND                m_hwndDlg;            // HWND of wrapper dialog
        HWND                m_hwndSheet;          // HWND of property sheet
        CLSID               m_clsidPage;          // CLSID of VB prop page
        ULONG               m_cObjects;           // no. of object for which props are being displayed
        IStream           **m_apiObjectStreams;   // stream for mashaling each object to MMC's property sheet thread
        IStream            *m_piSnapInStream;     // stream for mashaling ISnapIn to MMC's property sheet thread
        IStream            *m_piInitDataStream;   // stream for mashaling an object in MMCPropertySheet::AddPage's InitData param to MMC's property sheet thread
        IStream            *m_piMMCPropertySheetStream; // stream for mashaling IMMCPropertySheet to MMC's property sheet thread
        ISnapIn            *m_piSnapIn;           // back pointer to snap-in, marshaled across threads and processes
        IDispatch          *m_pdispConfigObject;  // Config object passed to MMCPropertySheet.AddWizardPage, marshaled across threads and processes
        VARIANT             m_varInitData;        // MMCPropertySheet::AddPage's InitData param
        BOOL                m_fNeedToRemoveHook;  // TRUE=MSGFILTER hook is installed
        BOOL                m_fIsRemote;          // TRUE=running in MMC remotely from VB during debugging session

        static const UINT CPropertyPageWrapper::m_RedrawMsg; // Message posted during WM_PAINT to generate a repaint when running under the debugger

        static const UINT CPropertyPageWrapper::m_InitMsg; // Message posted during WM_INITDIALOG so that IMMCPropertyPage_Initialize can be called

        static DLGTEMPLATE m_BaseDlgTemplate;     // Template used to create all dialog templates
};


DEFINE_AUTOMATIONOBJECTWEVENTS2(PropertyPageWrapper,    // name
                                NULL,                   // clsid
                                NULL,                   // objname
                                NULL,                   // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IUnknown,          // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe



#endif _PPGWRAP_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\pshtprov.h ===
//=--------------------------------------------------------------------------=
// pshtprov.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCPropertySheetProvider class definition - implements
// MMCPropertySheetProvider object
//
//=--------------------------------------------------------------------------=

#ifndef _PSHTPROV_DEFINED_
#define _PSHTPROV_DEFINED_

#include "view.h"

class CMMCPropertySheetProvider : public CSnapInAutomationObject,
                                  public IMMCPropertySheetProvider,
                                  public IMessageFilter
{
    protected:
        CMMCPropertySheetProvider(IUnknown *punkOuter);
        ~CMMCPropertySheetProvider();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT SetProvider(IPropertySheetProvider *piPropertySheetProvider,
                            CView                  *pView);

    // IMMCPropertySheetProvider
    protected:
        STDMETHOD(CreatePropertySheet)(
                           BSTR                              Title, 
                           SnapInPropertySheetTypeConstants  Type,
                           VARIANT                           Objects,
                           VARIANT                           UsePropertiesForInTitle,
                           VARIANT                           UseApplyButton);

        STDMETHOD(AddPrimaryPages)(VARIANT_BOOL InScopePane);
        STDMETHOD(AddExtensionPages)();
        STDMETHOD(FindPropertySheet)(VARIANT       Objects,
                                     VARIANT_BOOL *pfvarFound);
        STDMETHOD(Show)(int     Page,
                        VARIANT hwnd);
        STDMETHOD(Clear)();

    // IMessageFilter
    // An OLE message filter is used during debugging in order to allow keys
    // and mouse clicks to pass between processes. See pshtprov.cpp for more info.
        
        STDMETHOD_(DWORD, HandleInComingCall)( 
            /* [in] */ DWORD dwCallType,
            /* [in] */ HTASK htaskCaller,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ LPINTERFACEINFO lpInterfaceInfo);

        STDMETHOD_(DWORD, RetryRejectedCall)( 
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwRejectType);

        STDMETHOD_(DWORD, MessagePending)( 
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwPendingType);

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IPropertySheet
    private:

        void InitMemberVariables();

        IPropertySheetProvider *m_piPropertySheetProvider; // MMC interface

        IUnknown               *m_punkView;     // IUnknown of CView
        IDataObject            *m_piDataObject; // IDataObject of objects for
                                                // which sheet is displayed
        IComponent             *m_piComponent;  // IComponent of CView
        CView                  *m_pView;        // ptr to CView
        BOOL                    m_fHaveSheet;   // TRUE=CreatePropertySheet was
                                                // called and succeeded
        BOOL                    m_fWizard;      // TRUE=this is a wizard
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCPropertySheetProvider,       // name
                                NULL,                           // clsid
                                NULL,                           // objname
                                NULL,                           // lblname
                                NULL,                           // creation function
                                TLIB_VERSION_MAJOR,             // major version
                                TLIB_VERSION_MINOR,             // minor version
                                &IID_IMMCPropertySheetProvider, // dispatch IID
                                NULL,                           // event IID
                                HELP_FILENAME,                  // help file
                                TRUE);                          // thread safe


#endif _PSHTPROV_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\reginfo.cpp ===
//=--------------------------------------------------------------------------=
// reginfo.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CRegInfo class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "reginfo.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CRegInfo::CRegInfo(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_REGINFO,
                            static_cast<IRegInfo *>(this),
                            static_cast<CRegInfo *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_RegInfo,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CRegInfo::~CRegInfo()
{
    FREESTRING(m_bstrDisplayName);
    FREESTRING(m_bstrStaticNodeTypeGUID);
    RELEASE(m_piNodeTypes);
    RELEASE(m_piExtendedSnapIns);
    InitMemberVariables();
}

void CRegInfo::InitMemberVariables()
{
    m_bstrDisplayName = NULL;
    m_bstrStaticNodeTypeGUID = NULL;
    m_StandAlone = VARIANT_FALSE;
    m_piNodeTypes = NULL;
    m_piExtendedSnapIns = NULL;
}

IUnknown *CRegInfo::Create(IUnknown * punkOuter)
{
    CRegInfo *pRegInfo = New CRegInfo(punkOuter);
    if (NULL == pRegInfo)
    {
        return NULL;
    }
    else
    {
        return pRegInfo->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CRegInfo::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    IfFailRet(PersistBstr(&m_bstrStaticNodeTypeGUID, L"", OLESTR("StaticNodeTypeGUID")));

    IfFailRet(PersistSimpleType(&m_StandAlone, VARIANT_FALSE, OLESTR("StandAlone")));

    IfFailRet(PersistObject(&m_piNodeTypes, CLSID_NodeTypes,
                            OBJECT_TYPE_NODETYPES, IID_INodeTypes,
                            OLESTR("NodeTypes")));

    IfFailRet(PersistObject(&m_piExtendedSnapIns, CLSID_ExtendedSnapIns,
                            OBJECT_TYPE_EXTENDEDSNAPINS, IID_IExtendedSnapIns,
                            OLESTR("ExtendedSnapIns")));
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CRegInfo::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IRegInfo == riid)
    {
        *ppvObjOut = static_cast<IRegInfo *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resource.h ===
//=--------------------------------------------------------------------------=
// resource.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//      Snap-in designer runtime resource IDs
//


#define IDS_EXTENSIONDEFS_NAME 1
#define IDS_GENERIC_ERROR_MSG  2



// This is defined for all inproc servers that use satellite localization. It
// must be 1001
//
#define IDS_SERVERBASENAME              1001

#define IDB_BITMAP_LARGE_OPEN_FOLDER    1

#define IDI_ICON_DEFAULT                1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\reginfo.h ===
//=--------------------------------------------------------------------------=
// reginfo.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CRegInfo class definition - used to hold registry info gathered at design
// time and passed to DllRegisterDesigner (see dlregdes.cpp)
//
//=--------------------------------------------------------------------------=

#ifndef _REGINFO_DEFINED_
#define _REGINFO_DEFINED_


class CRegInfo : public CSnapInAutomationObject,
                 public CPersistence,
                 public IRegInfo
{
    private:
        CRegInfo(IUnknown *punkOuter);
        ~CRegInfo();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IRegInfo

        BSTR_PROPERTY_RW  (CRegInfo,   DisplayName,                           DISPID_REGINFO_DISPLAY_NAME);
        BSTR_PROPERTY_RW  (CRegInfo,   StaticNodeTypeGUID,                    DISPID_REGINFO_STATIC_NODE_TYPE_GUID);
        SIMPLE_PROPERTY_RW(CRegInfo,   StandAlone,        VARIANT_BOOL,       DISPID_REGINFO_STANDALONE);
        OBJECT_PROPERTY_RO(CRegInfo,   NodeTypes,         INodeTypes,         DISPID_REGINFO_NODETYPES);
        OBJECT_PROPERTY_RW(CRegInfo,   ExtendedSnapIns,   IExtendedSnapIns,   DISPID_REGINFO_EXTENDED_SNAPINS);

      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(RegInfo,           // name
                                &CLSID_RegInfo,    // clsid
                                "RegInfo",         // objname
                                "RegInfo",         // lblname
                                &CRegInfo::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_IRegInfo,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _REGINFO_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resview.h ===
//=--------------------------------------------------------------------------=
// resview.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultView class definition - implements ResultView object
//
//=--------------------------------------------------------------------------=

#ifndef _RESVIEW_DEFINED_
#define _RESVIEW_DEFINED_

#include "dataobj.h"
#include "spanitem.h"
#include "listview.h"
#include "msgview.h"

class CScopePaneItem;
class CMMCListView;
class CMessageView;

class CResultView : public CSnapInAutomationObject,
                    public IResultView
{
    private:
        CResultView(IUnknown *punkOuter);
        ~CResultView();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IResultView
        BSTR_PROPERTY_RW(CResultView,        Name,                       DISPID_RESULTVIEW_NAME);
        SIMPLE_PROPERTY_RW(CResultView,      Index,                      long, DISPID_RESULTVIEW_INDEX);
        BSTR_PROPERTY_RW(CResultView,        Key,                        DISPID_RESULTVIEW_KEY);
        COCLASS_PROPERTY_RO(CResultView,     ScopePaneItem,              ScopePaneItem, IScopePaneItem, DISPID_RESULTVIEW_SCOPEPANEITEM);

        STDMETHOD(get_Control)(IDispatch **ppiDispatch);

        SIMPLE_PROPERTY_RW(CResultView,      AddToViewMenu,              VARIANT_BOOL, DISPID_RESULTVIEW_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CResultView,        ViewMenuText,               DISPID_RESULTVIEW_VIEW_MENU_TEXT);
        SIMPLE_PROPERTY_RW(CResultView,      Type,                       SnapInResultViewTypeConstants, DISPID_RESULTVIEW_TYPE);
        BSTR_PROPERTY_RW(CResultView,        DisplayString,              DISPID_RESULTVIEW_DISPLAY_STRING);
        COCLASS_PROPERTY_RO(CResultView,     ListView,                   MMCListView, IMMCListView, DISPID_RESULTVIEW_LISTVIEW);
        COCLASS_PROPERTY_RO(CResultView,     Taskpad,                    Taskpad, ITaskpad, DISPID_RESULTVIEW_TASKPAD);
        COCLASS_PROPERTY_RO(CResultView,     MessageView,                MMCMessageView, IMMCMessageView, DISPID_RESULTVIEW_MESSAGEVIEW);
        VARIANTREF_PROPERTY_RW(CResultView,  Tag,                        DISPID_RESULTVIEW_TAG);
        BSTR_PROPERTY_RW(CResultView,        DefaultItemTypeGUID,        DISPID_RESULTVIEW_DEFAULT_ITEM_TYPE_GUID);
        BSTR_PROPERTY_RW(CResultView,        DefaultDataFormat,          DISPID_RESULTVIEW_DEFAULT_DATA_FORMAT);
        SIMPLE_PROPERTY_RW(CResultView,      AlwaysCreateNewOCX,         VARIANT_BOOL, DISPID_RESULTVIEW_ALWAYS_CREATE_NEW_OCX);
        STDMETHOD(SetDescBarText)(BSTR Text);

    // Public utility methods
        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        void SetScopePaneItem(CScopePaneItem *pScopePaneItem);
        CScopePaneItem *GetScopePaneItem() { return m_pScopePaneItem; }
        CMMCListView *GetListView() { return m_pMMCListView; }
        CMessageView *GetMessageView() { return m_pMessageView; }
        HRESULT SetControl(IUnknown *punkControl);

        void SetInActivate(BOOL fInActivate) { m_fInActivate = fInActivate; }
        BOOL InActivate() { return m_fInActivate; }

        void SetInInitialize(BOOL fInInitialize) { m_fInInitialize = fInInitialize; }
        BOOL InInitialize() { return m_fInInitialize; }

        LPOLESTR GetActualDisplayString() { return m_pwszActualDisplayString; }
        HRESULT SetActualDisplayString(LPOLESTR pwszDisplayString);

        SnapInResultViewTypeConstants GetActualType() { return m_ActualResultViewType; }
        void SetActualType(SnapInResultViewTypeConstants Type) { m_ActualResultViewType = Type; }

        BSTR GetDisplayString() { return m_bstrDisplayString; }
        BSTR GetDefaultItemTypeGUID() { return m_bstrDefaultItemTypeGUID; }

        BOOL AlwaysCreateNewOCX() { return VARIANTBOOL_TO_BOOL(m_AlwaysCreateNewOCX); }
        void SetAlwaysCreateNewOCX(VARIANT_BOOL fCreate) { m_AlwaysCreateNewOCX = fCreate; }

    // CSnapInAutomationObject overrides
        HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        CSnapIn                       *m_pSnapIn;        // Owning snap-in
        CScopePaneItem                *m_pScopePaneItem; // ResultView.ScopePaneItem
        CMMCListView                  *m_pMMCListView;   // ResultView.ListView
        CMessageView                  *m_pMessageView;   // ResultView.MessageView
        BOOL                           m_fInActivate;    // TRUE=this object in the middle of a ResultViews_Activate event
        BOOL                           m_fInInitialize;  // TRUE=this object in the middle of a ResultViews_Initialize event

        // This variable holds the real result view type. When using a predefined
        // result view (ResultView.Type = siPredefined) this says what it really
        // is (e.g. siURLView, siListView etc.)

        SnapInResultViewTypeConstants  m_ActualResultViewType;

        // Same deal for display string
        
        LPOLESTR                       m_pwszActualDisplayString;

        // For OCX views, control's IDispatch is cached here
        
        IDispatch                     *m_pdispControl;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ResultView,                // name
                                &CLSID_ResultView,         // clsid
                                "ResultView",              // objname
                                "ResultView",              // lblname
                                &CResultView::Create,      // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IResultView,          // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _RESVIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\rtconst.h ===
//=--------------------------------------------------------------------------=
// rtconst.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Designer Runtime Constants
//
//=--------------------------------------------------------------------------=

#ifndef _RTCONST_DEFINED_
#define _RTCONST_DEFINED_

// MMC Registry Key Names

#define MMCKEY_SNAPINS              "Software\\Microsoft\\MMC\\SnapIns\\"
#define MMCKEY_SNAPINS_LEN          (sizeof(MMCKEY_SNAPINS) - 1)

#define MMCKEY_NAMESTRING           "NameString"

#define MMCKEY_ABOUT                "About"

#define MMCKEY_STANDALONE           "StandAlone"

#define MMCKEY_NODETYPES            "Software\\Microsoft\\MMC\\NodeTypes\\"
#define MMCKEY_NODETYPES_LEN        (sizeof(MMCKEY_NODETYPES) - 1)

#define MMCKEY_SNAPIN_NODETYPES     "NodeTypes"
#define MMCKEY_SNAPIN_NODETYPES_LEN (sizeof(MMCKEY_SNAPIN_NODETYPES) - 1)

#define MMCKEY_EXTENSIONS           "Extensions"
#define MMCKEY_EXTENSIONS_LEN       (sizeof(MMCKEY_EXTENSIONS_LEN) - 1)

#define MMCKEY_NAMESPACE            "NameSpace"
#define MMCKEY_NAMESPACE_LEN        (sizeof(MMCKEY_NAMESPACE) - 1)

#define MMCKEY_CONTEXTMENU          "ContextMenu"
#define MMCKEY_CONTEXTMENU_LEN      (sizeof(MMCKEY_CONTEXTMENU) - 1)

#define MMCKEY_TOOLBAR              "Toolbar"
#define MMCKEY_TOOLBAR_LEN          (sizeof(MMCKEY_TOOLBAR) - 1)

#define MMCKEY_PROPERTYSHEET        "PropertySheet"
#define MMCKEY_PROPERTYSHEET_LEN    (sizeof(MMCKEY_PROPERTYSHEET) - 1)

#define MMCKEY_TASK                 "Task"
#define MMCKEY_TASK_LEN             (sizeof(MMCKEY_TASK) - 1)

#define MMCKEY_DYNAMIC_EXTENSIONS     "Dynamic Extensions"
#define MMCKEY_DYNAMIC_EXTENSIONS_LEN (sizeof(MMCKEY_DYNAMIC_EXTENSIONS) - 1)

// Same keys with leading backslash

#define MMCKEY_S_EXTENSIONS           "\\Extensions"
#define MMCKEY_S_EXTENSIONS_LEN       (sizeof(MMCKEY_S_EXTENSIONS) - 1)

#define MMCKEY_S_NAMESPACE            "\\NameSpace"
#define MMCKEY_S_NAMESPACE_LEN        (sizeof(MMCKEY_S_NAMESPACE) - 1)

#define MMCKEY_S_CONTEXTMENU          "\\ContextMenu"
#define MMCKEY_S_CONTEXTMENU_LEN      (sizeof(MMCKEY_S_CONTEXTMENU) - 1)

#define MMCKEY_S_TOOLBAR              "\\Toolbar"
#define MMCKEY_S_TOOLBAR_LEN          (sizeof(MMCKEY_S_TOOLBAR) - 1)

#define MMCKEY_S_PROPERTYSHEET        "\\PropertySheet"
#define MMCKEY_S_PROPERTYSHEET_LEN    (sizeof(MMCKEY_S_PROPERTYSHEET) - 1)

#define MMCKEY_S_TASK                 "\\Task"
#define MMCKEY_S_TASK_LEN             (sizeof(MMCKEY_S_TASK) - 1)

#define MMCKEY_S_DYNAMIC_EXTENSIONS     "\\Dynamic Extensions"
#define MMCKEY_S_DYNAMIC_EXTENSIONS_LEN (sizeof(MMCKEY_S_DYNAMIC_EXTENSIONS) - 1)

// Private Registry Keys

#define KEY_SNAPIN_CLSID            "Software\\Microsoft\\Visual Basic\\6.0\\SnapIns\\"
#define KEY_SNAPIN_CLSID_LEN        (sizeof(KEY_SNAPIN_CLSID) - 1)

// Key of static node in scope item collection

#define STATIC_NODE_KEY             L"Static Node"

// res:// URL prefix

#define RESURL                      L"res://"
#define CCH_RESURL                  ((sizeof(RESURL) / sizeof(WCHAR)) - 1)

// default taskpad names

#define DEFAULT_TASKPAD             L"/default.htm"
#define CCH_DEFAULT_TASKPAD         ((sizeof(DEFAULT_TASKPAD) / sizeof(WCHAR)) - 1)

#define LISTPAD                     L"/listpad.htm"
#define CCH_LISTPAD                 ((sizeof(LISTPAD) / sizeof(WCHAR)) - 1)

#define LISTPAD_HORIZ               L"/horizontal.htm"
#define CCH_LISTPAD_HORIZ           ((sizeof(LISTPAD_HORIZ) / sizeof(WCHAR)) - 1)

// Default taskpad names that may appear in an MMCN_RESTORE_VIEW notification

#define DEFAULT_TASKPAD2            L"/reload.htm"
#define CCH_DEFAULT_TASKPAD2        ((sizeof(DEFAULT_TASKPAD2) / sizeof(WCHAR)) - 1)

#define LISTPAD2                    L"/reload2.htm"
#define CCH_LISTPAD2                ((sizeof(LISTPAD2) / sizeof(WCHAR)) - 1)

#define LISTPAD3                    L"/reload3.htm"
#define CCH_LISTPAD3                ((sizeof(LISTPAD3) / sizeof(WCHAR)) - 1)


// Default value for filter change timeout in a filtered listview

#define DEFAULT_FILTER_CHANGE_TIMEOUT   1000L

#endif // _RTCONST_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resviews.h ===
//=--------------------------------------------------------------------------=
// resviews.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultViews class definition - implements ResultViews collection
//
//=--------------------------------------------------------------------------=

#ifndef _RESULTVIEWS_DEFINED_
#define _RESULTVIEWS_DEFINED_

#include "collect.h"
#include "spanitem.h"
#include "snapin.h"

class CSnapIn;
class CScopePaneItem;

class CResultViews : public CSnapInCollection<IResultView, ResultView, IResultViews>
{
    protected:
        CResultViews(IUnknown *punkOuter);
        ~CResultViews();

    public:
        static IUnknown *Create(IUnknown * punk);

        void SetSnapIn(CSnapIn *pSnapIn);
        void SetScopePaneItem(CScopePaneItem *pScopePaneItem);
        void FireInitialize(IResultView *piResultView);
        void FireTerminate(IResultView *piResultView);
        void FireInitializeControl(IResultView *piResultView);
        void FireActivate(IResultView *piResultView);
        void FireDeactivate(IResultView *piResultView, BOOL *pfKeep);
        void FireColumnClick(IResultView              *piResultView,
                             long                      lColumn,
                             SnapInSortOrderConstants  SortOption);
        void FireListItemDblClick(IResultView  *piResultView,
                                  IMMCListItem *piMMCListItem,
                                  BOOL         *pfDoDefault);
        void FireScopeItemDblClick(IResultView *piResultView,
                                   IScopeItem  *piScopeItem,
                                   BOOL        *pfDoDefault);
        void FirePropertyChanged(IResultView    *piResultView,
                                 IMMCListItem   *piMMCListItem,
                                 VARIANT         Data);
        void FireTaskClick(IResultView *piResultView, ITask *piTask);
        void FireListpadButtonClick(IResultView *piResultView);
        void FireTaskNotify(IResultView *piResultView,
                            VARIANT Arg, VARIANT Param);
        void FireHelp(IResultView *piResultView, IMMCListItem *piMMCListItem);
        void FireItemRename(IResultView *piResultView,
                            IMMCListItem *piMMCListItem, BSTR bstrNewName);
        void FireItemViewChange(IResultView *piResultView,
                                IMMCListItem *piMMCListItem, VARIANT varHint);
        void FireFindItem(IResultView *piResultView,
                          BSTR         bstrName,
                          long         lStart,
                          VARIANT_BOOL fvarPartial,
                          VARIANT_BOOL fvarWrap,
                          VARIANT_BOOL *pfvarFound,
                          long         *plIndex);
        void FireCacheHint(IResultView *piResultView,
                           long         lStart,
                           long         lEnd);
        void FireSortItems(IResultView              *piResultView,
                           long                      lColumn,
                           SnapInSortOrderConstants  Order);
        void FireDeselectAll(IResultView      *piResultView,
                             IMMCConsoleVerbs *piMMCConsoleVerbs,
                             IMMCControlbar   *piMMCControlbar);
        void FireCompareItems(IResultView  *piResultView,
                              IDispatch    *piObject1,
                              IDispatch    *piObject2,
                              long          lColumn,
                              VARIANT      *pvarResult);
        void FireGetVirtualItemData(IResultView  *piResultView,
                                    IMMCListItem *piMMCListItem);
        void FireGetVirtualItemDisplayInfo(IResultView  *piResultView,
                                           IMMCListItem *piMMCListItem);
        void FireColumnsChanged(IResultView *piResultView,
                                VARIANT      Columns,
                                VARIANT_BOOL *pfvarPersist);
        void FireFilterChange(IResultView                     *piResultView, 
                              IMMCColumnHeader                *piMMCColumnHeader,
                              SnapInFilterChangeTypeConstants  Type);
        void FireFilterButtonClick(IResultView      *piResultView,
                                   IMMCColumnHeader *piMMCColumnHeader,
                                   long              Left,
                                   long              Top,
                                   long              Height,
                                   long              Width);


        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        CSnapIn        *m_pSnapIn;          // owning snap-in
        CScopePaneItem *m_pScopePaneItem;   // owning ScopePaneItem

        // Event parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtInitializeControl[1];
        static EVENTINFO m_eiInitializeControl;

        static VARTYPE   m_rgvtActivate[1];
        static EVENTINFO m_eiActivate;

        static VARTYPE   m_rgvtDeactivate[2];
        static EVENTINFO m_eiDeactivate;

        static VARTYPE   m_rgvtColumnClick[3];
        static EVENTINFO m_eiColumnClick;

        static VARTYPE   m_rgvtListItemDblClick[3];
        static EVENTINFO m_eiListItemDblClick;

        static VARTYPE   m_rgvtScopeItemDblClick[3];
        static EVENTINFO m_eiScopeItemDblClick;

        static VARTYPE   m_rgvtPropertyChanged[3];
        static EVENTINFO m_eiPropertyChanged;

        static VARTYPE   m_rgvtTaskClick[2];
        static EVENTINFO m_eiTaskClick;

        static VARTYPE   m_rgvtListpadButtonClick[1];
        static EVENTINFO m_eiListpadButtonClick;

        static VARTYPE   m_rgvtTaskNotify[3];
        static EVENTINFO m_eiTaskNotify;

        static VARTYPE   m_rgvtHelp[2];
        static EVENTINFO m_eiHelp;

        static VARTYPE   m_rgvtItemRename[3];
        static EVENTINFO m_eiItemRename;

        static VARTYPE   m_rgvtItemViewChange[3];
        static EVENTINFO m_eiItemViewChange;

        static VARTYPE   m_rgvtFindItem[7];
        static EVENTINFO m_eiFindItem;

        static VARTYPE   m_rgvtCacheHint[3];
        static EVENTINFO m_eiCacheHint;

        static VARTYPE   m_rgvtSortItems[3];
        static EVENTINFO m_eiSortItems;

        static VARTYPE   m_rgvtDeselectAll[3];
        static EVENTINFO m_eiDeselectAll;

        static VARTYPE   m_rgvtCompareItems[5];
        static EVENTINFO m_eiCompareItems;

        static VARTYPE   m_rgvtGetVirtualItemDisplayInfo[2];
        static EVENTINFO m_eiGetVirtualItemDisplayInfo;

        static VARTYPE   m_rgvtGetVirtualItemData[2];
        static EVENTINFO m_eiGetVirtualItemData;

        static VARTYPE   m_rgvtColumnsChanged[3];
        static EVENTINFO m_eiColumnsChanged;

        static VARTYPE   m_rgvtColumnsSet[1];
        static EVENTINFO m_eiColumnsSet;

        static VARTYPE   m_rgvtFilterChange[3];
        static EVENTINFO m_eiFilterChange;

        static VARTYPE   m_rgvtFilterButtonClick[6];
        static EVENTINFO m_eiFilterButtonClick;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ResultViews,                // name
                                &CLSID_ResultViews,         // clsid
                                "ResultViews",              // objname
                                "ResultViews",              // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IResultViews,          // dispatch IID
                                &DIID_DResultViewsEvents,   // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _RESULTVIEWS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resview.cpp ===
//=--------------------------------------------------------------------------=
// resview.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultView class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "resview.h"
#include "snapin.h"
#include "views.h"
#include "dataobj.h"
#include "taskpad.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CResultView::CResultView(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_RESULTVIEW,
                           static_cast<IResultView *>(this),
                           static_cast<CResultView *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CResultView::~CResultView()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_pdispControl);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrDisplayString);
    RELEASE(m_piListView);
    RELEASE(m_piTaskpad);
    RELEASE(m_piMessageView);
    FREESTRING(m_bstrDefaultItemTypeGUID);
    FREESTRING(m_bstrDefaultDataFormat);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    
    InitMemberVariables();
}

void CResultView::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_piScopePaneItem = NULL;
    m_pdispControl = NULL;
    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_Type = siUnknown;
    m_bstrDisplayString = NULL;
    m_piListView = NULL;
    m_piTaskpad = NULL;
    m_piMessageView = NULL;

    ::VariantInit(&m_varTag);

    m_bstrDefaultItemTypeGUID = NULL;
    m_bstrDefaultDataFormat = NULL;
    m_AlwaysCreateNewOCX = VARIANT_FALSE;
    m_pSnapIn = NULL;
    m_pScopePaneItem = NULL;
    m_pMMCListView = NULL;
    m_pMessageView = NULL;
    m_fInActivate = FALSE;
    m_fInInitialize = FALSE;
    m_ActualResultViewType = siUnknown;
    m_pwszActualDisplayString = NULL;
}

IUnknown *CResultView::Create(IUnknown * punkOuter)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkResultView = NULL;
    IUnknown     *punkListView = NULL;
    IUnknown     *punkTaskpad = NULL;
    IUnknown     *punkMessageView = NULL;

    CResultView *pResultView = New CResultView(punkOuter);

    if (NULL == pResultView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    punkResultView = pResultView->PrivateUnknown();

    // Create contained objects

    punkListView = CMMCListView::Create(NULL);
    if (NULL == punkListView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkListView->QueryInterface(IID_IMMCListView,
                        reinterpret_cast<void **>(&pResultView->m_piListView)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pResultView->m_piListView, &pResultView->m_pMMCListView));
    pResultView->m_pMMCListView->SetResultView(pResultView);

    punkTaskpad = CTaskpad::Create(NULL);
    if (NULL == punkTaskpad)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkTaskpad->QueryInterface(IID_ITaskpad,
                         reinterpret_cast<void **>(&pResultView->m_piTaskpad)));

    punkMessageView = CMessageView::Create(NULL);
    if (NULL == punkMessageView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMessageView->QueryInterface(IID_IMMCMessageView,
                    reinterpret_cast<void **>(&pResultView->m_piMessageView)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pResultView->m_piMessageView,
                                                   &pResultView->m_pMessageView));
    pResultView->m_pMessageView->SetResultView(pResultView);

Error:
    QUICK_RELEASE(punkListView);
    QUICK_RELEASE(punkTaskpad);
    QUICK_RELEASE(punkMessageView);
    if (FAILED(hr))
    {
        RELEASE(punkResultView);
    }
    return punkResultView;
}


void CResultView::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}

void CResultView::SetScopePaneItem(CScopePaneItem *pScopePaneItem)
{
    m_pScopePaneItem = pScopePaneItem;
    m_piScopePaneItem = static_cast<IScopePaneItem *>(pScopePaneItem);
}


HRESULT CResultView::SetControl(IUnknown *punkControl)
{
    HRESULT hr = S_OK;
    
    RELEASE(m_pdispControl);
    IfFailGo(punkControl->QueryInterface(IID_IDispatch,
                                         reinterpret_cast<void **>(&m_pdispControl)));
    m_pSnapIn->GetResultViews()->FireInitializeControl(static_cast<IResultView *>(this));

Error:
    RRETURN(hr);
}

HRESULT CResultView::SetActualDisplayString
(
    LPOLESTR pwszDisplayString
)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszDisplayString,
                                   &m_pwszActualDisplayString));
}

//=--------------------------------------------------------------------------=
//                          IResultView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CResultView::get_Control(IDispatch **ppiDispatch)
{
    HRESULT          hr = S_OK;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;
    IUnknown        *punkControl = NULL;
    IConsole2       *piConsole2 = NULL; // Not AddRef()ed

    if (NULL == m_pdispControl)
    {
        // Control is not cached. This could happen if the snap-in is requesting
        // it too early, in a non-OCX ResultView, or because MMC did not send
        // MMCN_INITOCX because it has cached the control so CView never called
        // CResultView::SetControl() to pass us the IUnknown. In this case we
        // need to ask MMC for the control's IUnknown.

        hr = SID_E_INTERNAL; // Assume error getting IConsole2 from owning CView

        IfFalseGo(NULL != m_pScopePaneItem, hr);
        pScopePaneItems = m_pScopePaneItem->GetParent();
        IfFalseGo(NULL != pScopePaneItems, hr);
        pView = pScopePaneItems->GetParentView();
        IfFalseGo(NULL != pView, hr);
        piConsole2 = pView->GetIConsole2();
        IfFalseGo(NULL != piConsole2, hr);

        IfFailGo(piConsole2->QueryResultView(&punkControl));
        IfFailGo(punkControl->QueryInterface(IID_IDispatch,
                                   reinterpret_cast<void **>(&m_pdispControl)));
    }

    m_pdispControl->AddRef();
    *ppiDispatch = m_pdispControl;
    
Error:
    EXCEPTION_CHECK(hr);
    QUICK_RELEASE(punkControl);
    RRETURN(hr);
}


STDMETHODIMP CResultView::SetDescBarText(BSTR Text)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;
    IResultData     *piResultData = NULL; // Not AddRef()ed

    IfFalseGo(NULL != m_pScopePaneItem, hr);
    pScopePaneItems = m_pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);
    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);
    piResultData = pView->GetIResultData();
    IfFalseGo(NULL != piResultData, hr);

    if (NULL == Text)
    {
        Text = L"";
    }

    hr = piResultData->SetDescBarText(static_cast<LPOLESTR>(Text));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CResultView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IResultView == riid)
    {
        *ppvObjOut = static_cast<IResultView *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CResultView::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piListView));
    IfFailRet(SetObjectHost(m_piTaskpad));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resviews.cpp ===
//=--------------------------------------------------------------------------=
// resviews.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultViews class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "resviews.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CResultViews::m_rgvtInitialize[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiInitialize =
{
    DISPID_RESULTVIEWS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};

VARTYPE CResultViews::m_rgvtTerminate[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiTerminate =
{
    DISPID_RESULTVIEWS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};

VARTYPE CResultViews::m_rgvtInitializeControl[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiInitializeControl =
{
    DISPID_RESULTVIEWS_EVENT_INITIALIZE_CONTROL,
    sizeof(m_rgvtInitializeControl) / sizeof(m_rgvtInitializeControl[0]),
    m_rgvtInitializeControl
};


VARTYPE CResultViews::m_rgvtActivate[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiActivate =
{
    DISPID_RESULTVIEWS_EVENT_ACTIVATE,
    sizeof(m_rgvtActivate) / sizeof(m_rgvtActivate[0]),
    m_rgvtActivate
};

VARTYPE CResultViews::m_rgvtDeactivate[2] =
{
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CResultViews::m_eiDeactivate =
{
    DISPID_RESULTVIEWS_EVENT_DEACTIVATE,
    sizeof(m_rgvtDeactivate) / sizeof(m_rgvtDeactivate[0]),
    m_rgvtDeactivate
};



VARTYPE CResultViews::m_rgvtColumnClick[3] =
{
    VT_UNKNOWN,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiColumnClick =
{
    DISPID_RESULTVIEWS_EVENT_COLUMN_CLICK,
    sizeof(m_rgvtColumnClick) / sizeof(m_rgvtColumnClick[0]),
    m_rgvtColumnClick
};


VARTYPE CResultViews::m_rgvtListItemDblClick[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CResultViews::m_eiListItemDblClick =
{
    DISPID_RESULTVIEWS_EVENT_LISTITEM_DBLCLICK,
    sizeof(m_rgvtListItemDblClick) / sizeof(m_rgvtListItemDblClick[0]),
    m_rgvtListItemDblClick
};


VARTYPE CResultViews::m_rgvtScopeItemDblClick[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CResultViews::m_eiScopeItemDblClick =
{
    DISPID_RESULTVIEWS_EVENT_SCOPEITEM_DBLCLICK,
    sizeof(m_rgvtScopeItemDblClick) / sizeof(m_rgvtScopeItemDblClick[0]),
    m_rgvtScopeItemDblClick
};


VARTYPE CResultViews::m_rgvtPropertyChanged[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_VARIANT
};

EVENTINFO CResultViews::m_eiPropertyChanged =
{
    DISPID_RESULTVIEWS_EVENT_PROPERTY_CHANGED,
    sizeof(m_rgvtPropertyChanged) / sizeof(m_rgvtPropertyChanged[0]),
    m_rgvtPropertyChanged
};


VARTYPE CResultViews::m_rgvtTaskClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiTaskClick =
{
    DISPID_RESULTVIEWS_EVENT_TASK_CLICK,
    sizeof(m_rgvtTaskClick) / sizeof(m_rgvtTaskClick[0]),
    m_rgvtTaskClick
};


VARTYPE CResultViews::m_rgvtListpadButtonClick[1] =
{
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiListpadButtonClick =
{
    DISPID_RESULTVIEWS_EVENT_LISTPAD_BUTTON_CLICK,
    sizeof(m_rgvtListpadButtonClick) / sizeof(m_rgvtListpadButtonClick[0]),
    m_rgvtListpadButtonClick
};


VARTYPE CResultViews::m_rgvtTaskNotify[3] =
{
    VT_UNKNOWN,
    VT_VARIANT,
    VT_VARIANT
};

EVENTINFO CResultViews::m_eiTaskNotify =
{
    DISPID_RESULTVIEWS_EVENT_TASK_NOTIFY,
    sizeof(m_rgvtTaskNotify) / sizeof(m_rgvtTaskNotify[0]),
    m_rgvtTaskNotify
};


VARTYPE CResultViews::m_rgvtHelp[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiHelp =
{
    DISPID_RESULTVIEWS_EVENT_HELP,
    sizeof(m_rgvtHelp) / sizeof(m_rgvtHelp[0]),
    m_rgvtHelp
};


VARTYPE CResultViews::m_rgvtItemRename[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BSTR
};

EVENTINFO CResultViews::m_eiItemRename =
{
    DISPID_RESULTVIEWS_EVENT_ITEM_RENAME,
    sizeof(m_rgvtItemRename) / sizeof(m_rgvtItemRename[0]),
    m_rgvtItemRename
};


VARTYPE CResultViews::m_rgvtItemViewChange[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_VARIANT
};

EVENTINFO CResultViews::m_eiItemViewChange =
{
    DISPID_RESULTVIEWS_EVENT_ITEM_VIEW_CHANGE,
    sizeof(m_rgvtItemViewChange) / sizeof(m_rgvtItemViewChange[0]),
    m_rgvtItemViewChange
};


VARTYPE CResultViews::m_rgvtFindItem[7] =
{
    VT_UNKNOWN,
    VT_BSTR,
    VT_I4,
    VT_BOOL,
    VT_BOOL,
    VT_BYREF | VT_BOOL,
    VT_BYREF | VT_I4
};

EVENTINFO CResultViews::m_eiFindItem =
{
    DISPID_RESULTVIEWS_EVENT_FIND_ITEM,
    sizeof(m_rgvtFindItem) / sizeof(m_rgvtFindItem[0]),
    m_rgvtFindItem
};


VARTYPE CResultViews::m_rgvtCacheHint[3] =
{
    VT_UNKNOWN,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiCacheHint =
{
    DISPID_RESULTVIEWS_EVENT_CACHE_HINT,
    sizeof(m_rgvtCacheHint) / sizeof(m_rgvtCacheHint[0]),
    m_rgvtCacheHint
};


VARTYPE CResultViews::m_rgvtSortItems[3] =
{
    VT_UNKNOWN,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiSortItems =
{
    DISPID_RESULTVIEWS_EVENT_SORT_ITEMS,
    sizeof(m_rgvtSortItems) / sizeof(m_rgvtSortItems[0]),
    m_rgvtSortItems
};


VARTYPE CResultViews::m_rgvtDeselectAll[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiDeselectAll =
{
    DISPID_RESULTVIEWS_EVENT_DESELECT_ALL,
    sizeof(m_rgvtDeselectAll) / sizeof(m_rgvtDeselectAll[0]),
    m_rgvtDeselectAll
};


VARTYPE CResultViews::m_rgvtCompareItems[5] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_I4,
    VT_BYREF | VT_VARIANT
};

EVENTINFO CResultViews::m_eiCompareItems =
{
    DISPID_RESULTVIEWS_EVENT_COMPARE_ITEMS,
    sizeof(m_rgvtCompareItems) / sizeof(m_rgvtCompareItems[0]),
    m_rgvtCompareItems
};


VARTYPE CResultViews::m_rgvtGetVirtualItemData[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiGetVirtualItemData =
{
    DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DATA,
    sizeof(m_rgvtGetVirtualItemData) / sizeof(m_rgvtGetVirtualItemData[0]),
    m_rgvtGetVirtualItemData
};


VARTYPE CResultViews::m_rgvtGetVirtualItemDisplayInfo[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiGetVirtualItemDisplayInfo =
{
    DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DISPLAY_INFO,
    sizeof(m_rgvtGetVirtualItemDisplayInfo) / sizeof(m_rgvtGetVirtualItemDisplayInfo[0]),
    m_rgvtGetVirtualItemDisplayInfo
};



VARTYPE CResultViews::m_rgvtColumnsChanged[3] =
{
    VT_UNKNOWN,
    VT_VARIANT,
    VT_BOOL | VT_BYREF
};

EVENTINFO CResultViews::m_eiColumnsChanged =
{
    DISPID_RESULTVIEWS_EVENT_COLUMNS_CHANGED,
    sizeof(m_rgvtColumnsChanged) / sizeof(m_rgvtColumnsChanged[0]),
    m_rgvtColumnsChanged
};



VARTYPE CResultViews::m_rgvtFilterChange[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_I4
};

EVENTINFO CResultViews::m_eiFilterChange =
{
    DISPID_RESULTVIEWS_EVENT_FILTER_CHANGE,
    sizeof(m_rgvtFilterChange) / sizeof(m_rgvtFilterChange[0]),
    m_rgvtFilterChange
};



VARTYPE CResultViews::m_rgvtFilterButtonClick[6] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_I4,
    VT_I4,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiFilterButtonClick =
{
    DISPID_RESULTVIEWS_EVENT_FILTER_BUTTON_CLICK,
    sizeof(m_rgvtFilterButtonClick) / sizeof(m_rgvtFilterButtonClick[0]),
    m_rgvtFilterButtonClick
};




#pragma warning(disable:4355)  // using 'this' in constructor

CResultViews::CResultViews(IUnknown *punkOuter) :
   CSnapInCollection<IResultView, ResultView, IResultViews>(
                     punkOuter,
                     OBJECT_TYPE_RESULTVIEWS,
                     static_cast<IResultViews *>(this),
                     static_cast<CResultViews *>(this),
                     CLSID_ResultView,
                     OBJECT_TYPE_RESULTVIEW,
                     IID_IResultView,
                     NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CResultViews::InitMemberVariables()
{
    m_pSnapIn = NULL;
    m_pScopePaneItem = NULL;
}

CResultViews::~CResultViews()
{
    InitMemberVariables();
}

IUnknown *CResultViews::Create(IUnknown * punkOuter)
{
    CResultViews *pResultViews = New CResultViews(punkOuter);
    if (NULL == pResultViews)
    {
        return NULL;
    }
    else
    {
        return pResultViews->PrivateUnknown();
    }
}


void CResultViews::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}

void CResultViews::SetScopePaneItem(CScopePaneItem *pScopePaneItem)
{
    m_pScopePaneItem = pScopePaneItem;
}

void CResultViews::FireInitialize(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_Initialize\r\n");

    FireEvent(&m_eiInitialize, piResultView);
}

void CResultViews::FireTerminate(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_Terminate\r\n");

    FireEvent(&m_eiTerminate, piResultView);
}

void CResultViews::FireInitializeControl(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_InitializeControl\r\n");

    FireEvent(&m_eiInitializeControl, piResultView);
}

void CResultViews::FireActivate(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_Activate\r\n");

    FireEvent(&m_eiActivate, piResultView);
}

void CResultViews::FireDeactivate(IResultView *piResultView, BOOL *pfKeep)
{
    VARIANT_BOOL fvarKeep = VARIANT_FALSE;

    DebugPrintf("Firing ResultViews_Deactivate\r\n");

    FireEvent(&m_eiDeactivate, piResultView, &fvarKeep);

    if (VARIANT_TRUE == fvarKeep)
    {
        *pfKeep = TRUE;
    }
    else
    {
        *pfKeep = FALSE;
    }
}



void CResultViews::FireColumnClick(IResultView              *piResultView,
                                   long                      lColumn,
                                   SnapInSortOrderConstants  SortOption)
{
    DebugPrintf("Firing ResultViews_ColumnClick\r\n");

    FireEvent(&m_eiColumnClick, piResultView, lColumn, SortOption);
}


void CResultViews::FireListItemDblClick(IResultView  *piResultView,
                                        IMMCListItem *piMMCListItem,
                                        BOOL         *pfDoDefault)
{
    VARIANT_BOOL varfDoDefault = (*pfDoDefault) ? VARIANT_TRUE : VARIANT_FALSE;

    DebugPrintf("Firing ResultViews_ListItemDblClick\r\n");

    FireEvent(&m_eiListItemDblClick, piResultView, piMMCListItem, &varfDoDefault);

    *pfDoDefault = (VARIANT_TRUE == varfDoDefault) ? TRUE : FALSE;
}


void CResultViews::FireScopeItemDblClick(IResultView *piResultView,
                                         IScopeItem  *piScopeItem,
                                         BOOL        *pfDoDefault)
{
    VARIANT_BOOL varfDoDefault = (*pfDoDefault) ? VARIANT_TRUE : VARIANT_FALSE;

    DebugPrintf("Firing ResultViews_ScopeItemDblClick\r\n");

    FireEvent(&m_eiScopeItemDblClick, piResultView, piScopeItem, &varfDoDefault);

    *pfDoDefault = (VARIANT_TRUE == varfDoDefault) ? TRUE : FALSE;
}


void CResultViews::FirePropertyChanged
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem,
    VARIANT       Data
)
{
    DebugPrintf("Firing ResultViews_PropertyChanged\r\n");

    FireEvent(&m_eiPropertyChanged, piResultView, piMMCListItem, Data);
}


void CResultViews::FireTaskClick
(
    IResultView  *piResultView,
    ITask        *piTask
)
{
    DebugPrintf("Firing ResultViews_TaskClicked\r\n");

    FireEvent(&m_eiTaskClick, piResultView, piTask);
}


void CResultViews::FireListpadButtonClick
(
    IResultView  *piResultView
)
{
    DebugPrintf("Firing ResultViews_FireListpadButtonClick\r\n");

    FireEvent(&m_eiListpadButtonClick, piResultView);
}


void CResultViews::FireTaskNotify
(
    IResultView  *piResultView,
    VARIANT       arg,
    VARIANT       param
)
{
    DebugPrintf("Firing ResultViews_TaskNotify\r\n");

    FireEvent(&m_eiTaskNotify, piResultView, arg, param);
}



void CResultViews::FireHelp
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem
)
{
    DebugPrintf("Firing ResultViews_Help\r\n");

    FireEvent(&m_eiHelp, piResultView, piMMCListItem);
}


void CResultViews::FireItemRename
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem,
    BSTR          bstrNewName
)
{
    DebugPrintf("Firing ResultViews_ItemRename\r\n");

    FireEvent(&m_eiItemRename, piResultView, piMMCListItem, bstrNewName);
}


void CResultViews::FireItemViewChange
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem,
    VARIANT       varHint
)
{
    DebugPrintf("Firing ResultViews_ItemViewChange\r\n");

    FireEvent(&m_eiItemViewChange, piResultView, piMMCListItem, varHint);
}



void CResultViews::FireFindItem
(
    IResultView *piResultView,
    BSTR         bstrName,
    long         lStart,
    VARIANT_BOOL fvarPartial,
    VARIANT_BOOL fvarWrap,
    VARIANT_BOOL *pfvarFound,
    long         *plIndex
)
{
    DebugPrintf("Firing ResultViews_FindItem: Name=%ls Start=%ld Partial=%s Wrap=%s\r\n", bstrName, lStart, (VARIANT_TRUE == fvarPartial) ? "True" : "Not True", (VARIANT_TRUE == fvarWrap) ? "True" : "Not True");

    FireEvent(&m_eiFindItem, piResultView, bstrName, lStart, fvarPartial,
             fvarWrap, pfvarFound, plIndex);

    DebugPrintf("ResultViews_FindItem Complete Found=%s Index=%ld\r\n", (VARIANT_TRUE == *pfvarFound) ? "True" : "Not True", *plIndex);
}



void CResultViews::FireCacheHint
(
    IResultView *piResultView,
    long         lStart,
    long         lEnd
)
{
    DebugPrintf("Firing ResultViews_CacheHint\r\n");

    FireEvent(&m_eiCacheHint, piResultView, lStart, lEnd);
}


void CResultViews::FireSortItems
(
    IResultView              *piResultView,
    long                      lColumn,
    SnapInSortOrderConstants  Order
)
{
    DebugPrintf("Firing ResultViews_SortItems\r\n");

    FireEvent(&m_eiSortItems, piResultView, lColumn, Order);
}



void CResultViews::FireDeselectAll
(
    IResultView      *piResultView,
    IMMCConsoleVerbs *piMMCConsoleVerbs,
    IMMCControlbar   *piMMCControlbar
)
{
    DebugPrintf("Firing ResultViews_DeselectAll\r\n");

    FireEvent(&m_eiDeselectAll, piResultView, piMMCConsoleVerbs, piMMCControlbar);
}


void CResultViews::FireCompareItems
(
    IResultView  *piResultView,
    IDispatch    *piObject1,
    IDispatch    *piObject2,
    long          lColumn,
    VARIANT      *pvarResult
)
{
    DebugPrintf("Firing ResultViews_CompareItems\r\n");

    FireEvent(&m_eiCompareItems, piResultView, piObject1, piObject2,
              lColumn, pvarResult);
}


void CResultViews::FireGetVirtualItemData
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem
)
{
    DebugPrintf("Firing ResultViews_GetVirtualItemData\r\n");

    FireEvent(&m_eiGetVirtualItemData, piResultView, piMMCListItem);
}


void CResultViews::FireGetVirtualItemDisplayInfo
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem
)
{
    DebugPrintf("Firing ResultViews_GetVirtualItemDisplayInfo\r\n");

    FireEvent(&m_eiGetVirtualItemDisplayInfo, piResultView, piMMCListItem);
}


void CResultViews::FireColumnsChanged
(
    IResultView  *piResultView,
    VARIANT       Columns,
    VARIANT_BOOL *pfvarPersist
)
{
    DebugPrintf("Firing ResultViews_ColumnsChanged\r\n");

    FireEvent(&m_eiColumnsChanged, piResultView, Columns, pfvarPersist);
}


void CResultViews::FireFilterChange
(
    IResultView                     *piResultView, 
    IMMCColumnHeader                *piMMCColumnHeader,
    SnapInFilterChangeTypeConstants  Type
)
{
    DebugPrintf("Firing ResultViews_FilterChange\r\n");

    FireEvent(&m_eiFilterChange, piResultView, piMMCColumnHeader, Type);
}


void CResultViews::FireFilterButtonClick
(
    IResultView      *piResultView,
    IMMCColumnHeader *piMMCColumnHeader,
    long              Left,
    long              Top,
    long              Height,
    long              Width
)
{
    DebugPrintf("Firing ResultViews_FilterButtonClick\r\n");

    FireEvent(&m_eiFilterButtonClick, piResultView, piMMCColumnHeader, Left, Top, Height, Width);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CResultViews::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IResultViews == riid)
    {
        *ppvObjOut = static_cast<IResultViews *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInCollection<IResultView, ResultView, IResultViews>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\rtutil.cpp ===
//=--------------------------------------------------------------------------=
// rtutil.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Runtime Utility Functions
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "errors.h"
#include "images.h"
#include "listitem.h"
#include "clipbord.h"
#include "scopitms.h"
#include "listitms.h"
#include "image.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// IsString
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT   var       [in] Variant to check
//      BSTR     *pbstr     [out] BSTR contained in VARIANT
//
// Output:
//      BOOL TRUE - VARIANT contains an string
//           FALSE - VARIANT does not contain a string
//
// Notes:
//
// The returned BSTR should NOT be passed to SysFreeString()
//

BOOL IsString(VARIANT var, BSTR *pbstr)
{
    BOOL fIsString = TRUE;

    if (VT_BSTR == var.vt)
    {
        *pbstr = var.bstrVal;
    }
    else if ( (VT_BSTR | VT_BYREF) == var.vt )
    {
        *pbstr = *var.pbstrVal;
    }
    else if ( ((VT_BYREF | VT_VARIANT) == var.vt) &&
              (VT_BSTR == var.pvarVal->vt))
    {
        *pbstr = var.pvarVal->bstrVal;
    }
    else
    {
        fIsString = FALSE;
    }
    return fIsString;
}


//=--------------------------------------------------------------------------=
// IsObject
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  var        [in] Variant to check
//
// Output:
//      BOOL TRUE - VARIANT contains an object
//           FALSE - VARIANT does not contain an object
//
// Notes:
//
//

BOOL IsObject(VARIANT var)
{
    VARIANT *pvar = &var;
    VARTYPE  vt = VT_EMPTY;

    if (pvar->vt == (VT_BYREF | VT_VARIANT)) 
    {
        // Handle case like  x As Variant : Set x = Obj : Ctl.Add(x, ...)
        pvar = pvar->pvarVal;
    }

    vt = pvar->vt;
    vt &= VT_TYPEMASK;

    return ( (vt == VT_DISPATCH) || (vt == VT_UNKNOWN) );
}



//=--------------------------------------------------------------------------=
// ConvertToLong
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  var        [in] Variant to convert
//      long    *plNewIndex [out] converted value
//
// Output:
//      HRESULT S_OK - converted successfully
//              S_FALSE - cannot be converted
//
// Notes:
//
// Objects will not be converted. They could be converted by getting the default
// property (DISPID_VALUE) and attempting a conversion but this could be
// confusing to the VB developer when passing an object as a collection index.
// It will be clearer to refuse an object as an index.
//

HRESULT ConvertToLong(VARIANT var, long *pl)
{
    HRESULT hr = S_OK;
    VARIANT varLong;
    ::VariantInit(&varLong);

    IfFalseRet(!IsObject(var), S_FALSE);

    // VariantChangeType() will return successfully when asking it to convert
    // VT_EMPTY to VT_I4. It sets lval=0. For our purposes, an empty VARIANT
    // does not have meaning as a long.
    
    IfFalseRet(VT_EMPTY != var.vt, S_FALSE);

    IfFailRet(::VariantChangeType(&varLong, &var, 0, VT_I4));
    *pl = varLong.lVal;

    return S_OK;
}


HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
{
    HRESULT hr = S_OK;
    int     cchWideStr = 0;
    int     cchConverted = 0;
    int     cchAnsi = 0;

    *ppszAnsi = NULL;

    if (NULL != pwszWideStr)
    {
        cchWideStr = (int)::wcslen(pwszWideStr);
    }

    // If string is not zero length then get required buffer length

    if (0 != cchWideStr)
    {
        cchAnsi = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                        0,           // performance and mapping flags 
                                        pwszWideStr, // address of wide-character string 
                                        cchWideStr,  // number of characters in string 
                                        NULL,        // address of buffer for new string 
                                        0,           // size of buffer 
                                        NULL,        // address of default for unmappable characters
                                        NULL         // address of flag set when default char. used
                                       );
        if (cchAnsi == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<char *>(::CtlAlloc(cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // now convert the string and copy it to the buffer
    if (0 != cchWideStr)
    {
        cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                             0,                    // performance and mapping flags 
                                             pwszWideStr,          // address of wide-character string 
                                             cchWideStr,           // number of characters in string 
                                             *ppszAnsi,             // address of buffer for new string 
                                             cchAnsi,              // size of buffer 
                                             NULL,                 // address of default for unmappable characters 
                                             NULL                  // address of flag set when default char. used 
                                            );
        if (cchConverted != cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null byte

    *((*ppszAnsi) + cchAnsi) = '\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            ::CtlFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    RRETURN(hr);
}


HRESULT WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr)
{
    HRESULT    hr = S_OK;
    int        cchANSI = 0;
    int        cchConverted = 0;
    int        cchWideStr = 0;

    *ppwszWideStr = NULL;

    if (NULL != pszAnsi)
    {
        cchANSI = ::strlen(pszAnsi);
    }

    // If string is not zero length then get required buffer length

    if (0 != cchANSI)
    {
        cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           cchANSI,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
        if (0 == cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the WCHAR *
    *ppwszWideStr = static_cast<WCHAR *>(::CtlAlloc(sizeof(WCHAR) * (cchWideStr + 1)));
    if (ppwszWideStr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // now convert the string and copy it to the buffer
    if (0 != cchANSI)
    {
        cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                             0,                    // performance and mapping flags 
                                             pszAnsi,              // address of multibyte string 
                                             cchANSI,              // number of characters in string 
                                             *ppwszWideStr,         // address of buffer for new string 
                                             cchWideStr            // size of buffer 
                                            );
        if (cchConverted != cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null character
    *((*ppwszWideStr) + cchWideStr) = L'\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            ::CtlFree(*ppwszWideStr);
            *ppwszWideStr = NULL;
        }
    }

    RRETURN(hr);
}


HRESULT BSTRFromANSI(char *pszAnsi, BSTR *pbstr)
{
    HRESULT  hr = S_OK;
    WCHAR   *pwszWideStr = NULL;

    // convert to a wide string first
    hr = ::WideStrFromANSI(pszAnsi, &pwszWideStr);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // allocate a BSTR and copy it
    *pbstr = ::SysAllocStringLen(pwszWideStr, ::wcslen(pwszWideStr));
    if (*pbstr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pwszWideStr)
    {
        ::CtlFree(pwszWideStr);
    }
    if (FAILED(hr))
    {
        if (NULL != *pbstr)
        {
            ::SysFreeString(*pbstr);
            *pbstr = NULL;
        }
    }

    RRETURN(hr);
}


HRESULT CoTaskMemAllocString(WCHAR *pwszString, LPOLESTR *ppwszOut)
{
    HRESULT   hr = S_OK;
    size_t    cbString = 0;
    LPOLESTR  pwszOut = NULL;

    if (NULL != pwszString)
    {
        cbString = ::wcslen(pwszString) * sizeof(OLECHAR);
    }

    pwszOut = (LPOLESTR)(::CoTaskMemAlloc(cbString + sizeof(OLECHAR)));

    if (NULL == pwszOut)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (cbString > 0)
    {
        ::memcpy(pwszOut, pwszString, cbString);
    }
    *(OLECHAR *)(((char *)pwszOut) + cbString) = L'\0';
    
Error:
    if (SUCCEEDED(hr))
    {
        *ppwszOut = pwszOut;
    }
    else
    {
        *ppwszOut = NULL;
    }
    RRETURN(hr);
}




HRESULT CreateKeyName
(
    char    *pszPrefix,
    size_t   cbPrefix,
    char    *pszSuffix,
    size_t   cbSuffix,
    char   **ppszKeyName
)
{
    HRESULT  hr = S_OK;
    char    *pszKeyName = (char *)::CtlAlloc(cbPrefix + cbSuffix + 1);

    IfFalseGo(NULL != pszKeyName, SID_E_OUTOFMEMORY);

    ::memcpy(pszKeyName, pszPrefix, cbPrefix);
    ::memcpy(&pszKeyName[cbPrefix], pszSuffix, cbSuffix);
    pszKeyName[cbPrefix + cbSuffix] = '\0';
    *ppszKeyName = pszKeyName;

Error:
    if (FAILED(hr))
    {
        *ppszKeyName = NULL;
    }
    RRETURN(hr);
}




HRESULT CreateKeyNameW
(
    char   *pszPrefix,
    size_t  cbPrefix,
    WCHAR  *pwszSuffix,
    char  **ppszKeyName
)
{
    HRESULT  hr = S_OK;
    char    *pszSuffix = NULL;

    IfFailGo(::ANSIFromWideStr(pwszSuffix, &pszSuffix));
    hr = CreateKeyName(pszPrefix, cbPrefix,
                       pszSuffix, ::strlen(pszSuffix), ppszKeyName);

Error:

    if (NULL != pszSuffix)
    {
        ::CtlFree(pszSuffix);
    }
    RRETURN(hr);
}


HRESULT GetPicture
(
    IMMCImages *piMMCImages,
    VARIANT     varIndex,
    short       TypeNeeded,
    OLE_HANDLE *phPicture
)
{
    HRESULT    hr = S_OK;
    IMMCImage *piMMCImage = NULL;
    CMMCImage *pMMCImage = NULL;

    *phPicture = NULL;

    IfFailGo(piMMCImages->get_Item(varIndex, reinterpret_cast<MMCImage **>(&piMMCImage)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImage, &pMMCImage));
    IfFailGo(pMMCImage->GetPictureHandle(TypeNeeded, phPicture));

Error:
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


HRESULT GetPictureHandle
(
    IPictureDisp *piPictureDisp,
    short         TypeNeeded,
    OLE_HANDLE   *phPicture
)
{
    HRESULT       hr = S_OK;
    IPicture     *piPicture = NULL;
    short         ActualType = PICTYPE_UNINITIALIZED;

    IfFailGo(piPictureDisp->QueryInterface(IID_IPicture,
                                           reinterpret_cast<void **>(&piPicture)));

    IfFailGo(piPicture->get_Type(&ActualType));
    if (TypeNeeded != ActualType)
    {
        hr = SID_E_INVALID_IMAGE_TYPE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(piPicture->get_Handle(phPicture));

Error:
    QUICK_RELEASE(piPicture);
    RRETURN(hr);
}


HRESULT CreateEmptyBitmapPicture(IPictureDisp **ppiPictureDisp)
{
    HRESULT  hr = S_OK;
    WORD     bits = 0;
    PICTDESC desc;
    ::ZeroMemory(&desc, sizeof(desc));

    if (NULL != *ppiPictureDisp)
    {
        (*ppiPictureDisp)->Release();
        *ppiPictureDisp = NULL;
    }

    // Create a 1x1 bitmap with 1 plane and 1 bit per pixel

    desc.cbSizeofstruct = sizeof(desc);
    desc.picType = PICTYPE_BITMAP;
    desc.bmp.hbitmap = ::CreateBitmap(1,1,1,1, &bits);
    if (NULL == desc.bmp.hbitmap)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::CreatePicture(ppiPictureDisp, &desc));

Error:
    RRETURN(hr);
}

HRESULT CreateIconPicture(IPictureDisp **ppiPictureDisp, HICON hicon)
{
    HRESULT  hr = S_OK;

    PICTDESC desc;
    ::ZeroMemory(&desc, sizeof(desc));

    if (NULL != *ppiPictureDisp)
    {
        (*ppiPictureDisp)->Release();
        *ppiPictureDisp = NULL;
    }

    desc.cbSizeofstruct = sizeof(desc);
    desc.picType = PICTYPE_ICON;
    desc.icon.hicon = hicon;

    IfFailGo(::CreatePicture(ppiPictureDisp, &desc));

Error:
    RRETURN(hr);
}

HRESULT CreatePicture(IPictureDisp **ppiPictureDisp, PICTDESC *pDesc)
{
    HRESULT  hr = S_OK;

    if (NULL != *ppiPictureDisp)
    {
        (*ppiPictureDisp)->Release();
        *ppiPictureDisp = NULL;
    }

    hr = ::OleCreatePictureIndirect(pDesc,
                                    IID_IPictureDisp,
                                    TRUE,                  // Picture owns handle
                                    reinterpret_cast<void **>(ppiPictureDisp));
    GLOBAL_EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


HRESULT CopyBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy)
{
    HRESULT hr = S_OK;
    BOOL	fBltOK = FALSE;;
    HBITMAP	hbmCopy = NULL;
    HBITMAP	hbmOldSrc = NULL;
    HBITMAP	hbmOldDst = NULL;
    HDC     hdcSrc = NULL;
    HDC     hdcDst = NULL;
    HDC     hdcScreen = NULL;
    int     cBytes = 0;

    BITMAP bm;
    ::ZeroMemory(&bm, sizeof(bm));

    *phbmCopy = NULL;

    // Base the DC and bitmaps on the screen so that any low fidelity bitmaps
    // will be upgraded to the screen's color depth. For example, a 16 bit color
    // bitmap copied for a 24 bit color screen will upgrade the bitmap to 24
    // bit color.

    hdcScreen = GetDC(NULL);
    IfFalseGo(NULL != hdcScreen, E_FAIL);

    // Need a memory DC for the source bitmap

    hdcSrc = CreateCompatibleDC(hdcScreen);
    IfFalseGo(NULL != hdcSrc, HRESULT_FROM_WIN32(::GetLastError()));

    // Use a memory DC to generate the copy bitmap

    hdcDst = CreateCompatibleDC(hdcScreen);
    IfFalseGo(NULL != hdcDst, HRESULT_FROM_WIN32(::GetLastError()));

    // Get the BITMAP structure for the source to determine its height and width
    
    cBytes = ::GetObject (hbmSrc, sizeof(BITMAP), &bm);
    IfFalseGo(0 != cBytes, HRESULT_FROM_WIN32(::GetLastError()));

    // Create an empty bitmap in the destination DC

    hbmCopy = ::CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
    IfFalseGo(NULL != hbmCopy, HRESULT_FROM_WIN32(::GetLastError()));

    // Select the source bitmap into the source DC

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmSrc));
    IfFalseGo(NULL != hbmOldSrc, HRESULT_FROM_WIN32(::GetLastError()));

    // Select the empty bitmap into the destination DC

    hbmOldDst = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmCopy));
    IfFalseGo(NULL != hbmOldDst, HRESULT_FROM_WIN32(::GetLastError()));

    // Blt from the source bitmap into the new destination bitmap

    fBltOK = ::StretchBlt(hdcDst, 0, 0, bm.bmWidth, bm.bmHeight, hdcSrc, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
    IfFalseGo(fBltOK, HRESULT_FROM_WIN32(::GetLastError()));

    // Restore the original bitmap into the source DC

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmOldSrc));
    IfFalseGo(NULL != hbmOldSrc, HRESULT_FROM_WIN32(::GetLastError()));

    // Restore the original bitmap into the destination DC and get the completed
    // copy

    hbmCopy = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmOldDst));
    IfFalseGo(NULL != hbmCopy, HRESULT_FROM_WIN32(::GetLastError()));

    *phbmCopy = hbmCopy;

Error:
    if (FAILED(hr) && (NULL != hbmCopy))
    {
        (void)::DeleteObject(hbmCopy);
    }

    if (NULL != hdcScreen)
    {
        (void)::ReleaseDC(NULL, hdcScreen);
    }

    if (NULL != hdcSrc)
    {
        (void)::DeleteDC(hdcSrc);
    }

    if (NULL != hdcDst)
    {
        (void)::DeleteDC(hdcDst);
    }

    RRETURN(hr);
}



HRESULT CloneObject(IUnknown *punkSrc, IUnknown *punkDest)
{
    HRESULT hr = S_OK;

    IPersistStreamInit *piPersistStreamInitSrc = NULL;
    IPersistStreamInit *piPersistStreamInitDest = NULL;
    IStream            *piStream = NULL;
    LARGE_INTEGER       li;
    ::ZeroMemory(&li, sizeof(li));

    // Save the source object to a stream

    IfFailGo(punkSrc->QueryInterface(IID_IPersistStreamInit,
                           reinterpret_cast<void **>(&piPersistStreamInitSrc)));

    hr = ::CreateStreamOnHGlobal(NULL, // stream should allocate buffer
                                 TRUE, // stream should free buffer on release
                                 &piStream);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    IfFailGo(piPersistStreamInitSrc->Save(piStream, FALSE)); // don't clear dirty

    // Rewind the stream

    hr = piStream->Seek(li, STREAM_SEEK_SET, NULL);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Load the destination object from that stream

    IfFailGo(punkDest->QueryInterface(IID_IPersistStreamInit,
                          reinterpret_cast<void **>(&piPersistStreamInitDest)));

    IfFailGo(piPersistStreamInitDest->Load(piStream));
    
Error:
    QUICK_RELEASE(piPersistStreamInitSrc);
    QUICK_RELEASE(piPersistStreamInitDest);
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}






void VBViewModeToMMCViewMode
(
    SnapInViewModeConstants  VBViewMode,
    long                    *pMMCViewMode
)
{
    switch (VBViewMode)
    {
        case siIcon:
            *pMMCViewMode = MMCLV_VIEWSTYLE_ICON;;
            break;

        case siSmallIcon:
            *pMMCViewMode = MMCLV_VIEWSTYLE_SMALLICON;
            break;

        case siList:
            *pMMCViewMode = MMCLV_VIEWSTYLE_LIST;
            break;

        case siReport:
            *pMMCViewMode = MMCLV_VIEWSTYLE_REPORT;
            break;

        case siFiltered:
            *pMMCViewMode = MMCLV_VIEWSTYLE_FILTERED;
            break;

        default:
            ASSERT(FALSE, "SnapInViewModeConstants param has bad value");
            *pMMCViewMode = MMCLV_VIEWSTYLE_ICON;;
            break;
    }
}


void MMCViewModeToVBViewMode
(
    long                     MMCViewMode,
    SnapInViewModeConstants *pVBViewMode
)
{
    switch (MMCViewMode)
    {
        case MMCLV_VIEWSTYLE_ICON:
            *pVBViewMode = siIcon;
            break;

        case MMCLV_VIEWSTYLE_SMALLICON:
            *pVBViewMode = siSmallIcon;
            break;

        case MMCLV_VIEWSTYLE_LIST:
            *pVBViewMode = siList;
            break;

        case MMCLV_VIEWSTYLE_REPORT:
            *pVBViewMode = siReport;
            break;

        case MMCLV_VIEWSTYLE_FILTERED:
            *pVBViewMode = siFiltered;
            break;

        default:
            ASSERT(FALSE, "MMCViewMode param has bad value");
            *pVBViewMode = siIcon;
            break;
    }
}



//=--------------------------------------------------------------------------=
// CreateSelection
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject    [in]  data object from MMC representing
//                                            current selection. This is pane
//                                            independent.
//      IMMCClipboard **ppiMMCClipboard [out] MMCClipboard object containing
//                                            the selected items
//      CSnapIn        *pSnapIn         [in]  pointer to owning snap-in
//
//      SnapInSelectionTypeConstants *pSelectionType [out] clipboard selection
//                                                         type returned here
//
// Output:
//    