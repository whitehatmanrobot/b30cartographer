       ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmpHandleResourceTransition: resource notification from quorum resource "
                "during phase processing. Sleep and retry\n");
            RELEASE_LOCK(gQuoChangeLock);
            Sleep(500);
            if (dwRetryCount--)
                goto ChkFMState;
            else
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpHandleResourceTransition: waited for too long\n");
                //terminate the process                    
                CL_ASSERT(FALSE);
                CsInconsistencyHalt(ERROR_CLUSTER_NODE_DOWN);
            }
        }
        //this can only come from the quorum resource
        CL_ASSERT(Resource->QuorumResource);
    }

    // if this is from the quorum resource, we need to do some special handling
    // protect the check for quorum resource by acquiring the shared lock

    if (Resource->QuorumResource) 
    {
        //
        //  Chittur Subbaraman (chitturs) - 6/25/99
        //
        //  Handle the sync notifications for the quorum resource. This is
        //  done here instead of in FmpRmDoInterlockedDecrement since we
        //  need to hold the gQuoChangeLock for this to synchronize with
        //  other threads such as the FmCheckQuorumState called by the DM
        //  node down handler. Note that FmpRmDoInterLockedDecrement needs
        //  to be done with NO LOCKS held since it easily runs into deadlock
        //  situations in which the quorum resource offline is waiting to
        //  have the blocking resources count go to 0 and FmpRmDoInterLockedDecrement
        //  which alone can make this count to 0 could be stuck waiting for
        //  the lock.
        //
        DWORD dwBlockingFlag = InterlockedExchange( &Resource->BlockingQuorum, 0 );

        CL_ASSERT( dwBlockingFlag == FALSE );

        FmpCallResourceNotifyCb( Resource, NewState );
        
        ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
        
    } 
    else 
    {
        FmpAcquireLocalResourceLock(Resource);
    }

    ClRtlLogPrint(
        NewState == ClusterResourceFailed ? LOG_UNUSUAL : LOG_NOISE,
        "[FM] FmpHandleResourceTransition: Resource Name = %1!ws! [%2!ws!] old state=%3!u! new state=%4!u!\n",
        OmObjectId(Resource),
        OmObjectName(Resource),
        Resource->State,
        NewState
        );

    if ( Resource->State == NewState ) 
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpHandleResourceTransition: Resource %1!ws! already in state=%2!u!\n",
            OmObjectId(Resource),
            NewState );
        goto FnExit;
    }

    //
    //  Chittur Subbaraman (chitturs) - 7/8/2001
    //
    //  A resource which is in waiting state cannot receive a notification from resource monitor. If such
    //  a notification is received, discard it as a stale notification. If not, you take wrong actions
    //  on a resource which is in waiting state (such as restart) and mess up FM's notification processing.
    //
    if ( Resource->Flags & RESOURCE_WAITING )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[FM] FmpHandleResourceTransition: Resource %1!ws! [%2!ws!] is in waiting state, discarding notification as stale\n",
                      OmObjectId(Resource),
                      OmObjectName(Resource));
        goto FnExit;
    }

    switch (Resource->State) {

    case ClusterResourceOnline:
        // if there is a resource failure, then let the worker thread handle it
        // if there is a state change call the resource state change handler
        if (Resource->State != NewState)
            FmpPropagateResourceState( Resource, NewState );
        if (NewState == ClusterResourceFailed) 
        {
            if (Resource->QuorumResource)
            {
                RELEASE_LOCK(gQuoLock);

                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnline);
                ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
                                            
            }                                        
            else
            {
                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnline);
            }
        } 
        else 
        {
            CL_ASSERT( (NewState == ClusterResourceOnline) ||
                       (NewState == ClusterResourceOffline) );
        }
        break;


    case ClusterResourceFailed:
        if (Resource->State != NewState)
            FmpPropagateResourceState( Resource, NewState );
        break;

    case ClusterResourceOfflinePending:
        //SS: a resource cannot go from one pending state to another
        CL_ASSERT( NewState < ClusterResourcePending )
        // fall through
    case ClusterResourceOffline:
        //
        // Because this resource is now unstuck... there may be other
        // pending threads waiting to clear up. If not, they'll just get
        // stuck again, until the next notification.
        //
        switch ( NewState ) {

        case ClusterResourceFailed:
            if ( Resource->State != NewState ) 
                FmpPropagateResourceState( Resource, NewState );
                
            // if it is the quorum resource handle the locking appropriately
            if (Resource->QuorumResource)
            {

                //
                //  Chittur Subbaraman (chitturs) - 9/20/99
                //
                //  Release and reacquire the gQuoLock to maintain
                //  locking order between group lock and gQuoLock.
                //
                RELEASE_LOCK(gQuoLock);

                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOffline);

                ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
            }
            else
            {
                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOffline);
            }                                
            break;                

        case ClusterResourceOffline:
            if ( Resource->Group->OwnerNode == NmLocalNode ) 
            {
                if ( Resource->State != NewState ) 
                {
                    FmpPropagateResourceState( Resource, NewState );
                }
                
                // if it is the quorum resource handle the locking appropriately
                if (Resource->QuorumResource)
                {
                    //
                    //  Chittur Subbaraman (chitturs) - 9/20/99
                    //
                    //  Release and reacquire the gQuoLock to maintain
                    //  locking order between group lock and gQuoLock.
                    //
                    RELEASE_LOCK(gQuoLock);

                    FmpProcessResourceEvents(Resource, ClusterResourceOffline,
                                                ClusterResourceOfflinePending);

                    ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
                }
                else
                {
                    FmpProcessResourceEvents(Resource, ClusterResourceOffline,
                                                ClusterResourceOfflinePending);
                }                                
            } 
            else 
            {
                if ( Resource->State != NewState ) 
                {
                    FmpPropagateResourceState( Resource, NewState );
                }
            }
            break;

        default:
            if ( Resource->State != NewState ) {
                FmpPropagateResourceState( Resource, NewState );
            }
            break;

        }
        break;

    case ClusterResourceOnlinePending:
        //SS: a resource cannot go from one pending state to another
        CL_ASSERT( NewState < ClusterResourcePending )

        //
        // Because this resource is now unstuck... there may be other
        // pending threads waiting to clear up. If not, they'll just get
        // stuck again, until the next notification.
        //

        switch ( NewState ) {

        case ClusterResourceFailed:
            //
            // Make sure we go through full failure recovery.
            //
            //SS: dont know why the state is being set to online
            //it could be online pending
            //Resource->State = ClusterResourceOnline;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[FM] FmpHandleResourceTransition: Resource failed, post a work item\n");
            if (Resource->State != NewState)
                FmpPropagateResourceState( Resource, NewState );

            // since this is the quorum Resource handle locking appropriately
            if (Resource->QuorumResource)
            {

                //
                //  Chittur Subbaraman (chitturs) - 9/20/99
                //
                //  Release and reacquire the gQuoLock to maintain
                //  locking order between group lock and gQuoLock.
                //
                RELEASE_LOCK(gQuoLock);

                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnlinePending);

                ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
            }
            else
            {
                FmpProcessResourceEvents(Resource, ClusterResourceFailed, 
                                            ClusterResourceOnlinePending);
            
            }
            break;

        case ClusterResourceOnline:
            if (Resource->Group->OwnerNode == NmLocalNode) {
                //Call FmpPropagateResourceState without holding the group
                //lock for the quorum resource
                FmpPropagateResourceState( Resource, NewState );

                // since this is the quorum Resource fork another thread
                if (Resource->QuorumResource)
                {
                    //
                    //  Chittur Subbaraman (chitturs) - 9/20/99
                    //
                    //  Release and reacquire the gQuoLock to maintain
                    //  locking order between group lock and gQuoLock.
                    //
                    RELEASE_LOCK(gQuoLock);

                    FmpProcessResourceEvents(Resource, ClusterResourceOnline,
                                                ClusterResourceOnlinePending);

                    ACQUIRE_EXCLUSIVE_LOCK(gQuoLock);
                } 
                else
                {
                    FmpProcessResourceEvents(Resource, ClusterResourceOnline,
                                                ClusterResourceOnlinePending);
                }
            } else {
                FmpPropagateResourceState( Resource, NewState );
            }
            break;
            
        default:
            if (Resource->State != NewState)
                FmpPropagateResourceState( Resource, NewState );
            break;
        }

        break;

    case ClusterResourceInitializing:
    default:
        if (Resource->State != NewState)
            FmpPropagateResourceState( Resource, NewState );
        CL_ASSERT(Resource->State == NewState);
    }

FnExit:

    if (Resource->QuorumResource) {
        RELEASE_LOCK(gQuoLock);
    } else {
        FmpReleaseLocalResourceLock(Resource);
    }

    RELEASE_LOCK(gQuoChangeLock);

    return;
}


/****
@func       DWORD | FmpCreateResNotificationHandler| This creates a new
            thread to handle state change notifications for the given resource.

@parm       IN PFM_RESOURCE | pResource | Pointer to the resource.
@parm       IN CLUSTER_RESOURCE_STATE | OldState | The old state of the
            resource from which it transitioned.
@parm       IN CLUSTER_RESOURCE_STATE | NewState | The new state of the
            resource.

@comm       This routine creates a thread to perform all the pending work
            when the resource changes state that cannot be performed within
            FmpHandleResourceTransition to avoid deadlocks and that cannot
            be deffered to the FmpWorkerThread because of serialization issues.
            In particular, it is used to handle state transition work for the
            quorum resource since other resources depend on the quorum resource
            and cannot come online till the state of the quorum becomes online.
            For instance, the quorum resource may be coming offline as a part
            of move while another resource if in FmpWorkerThread() calling
            FmpOffline/OnlineWaitingTree(). For the quorum resource to come
            online again (that happens by signalling the move pending thread) 
            so that FmpWorkerThread can make progress its events will have 
            to be handled separately.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpHandleResStateChangeProc>

****/
DWORD FmpCreateResStateChangeHandler(
    IN PFM_RESOURCE pResource, 
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState)
{

    HANDLE                  hThread = NULL;
    DWORD                   dwThreadId;
    PRESOURCE_STATE_CHANGE  pResStateContext = NULL;
    DWORD                   dwStatus = ERROR_SUCCESS;
    
    //reference the resource
    //the thread will dereference it, if the thread is successfully
    //created
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateResStateChangeHandler: Entry\r\n");

    OmReferenceObject(pResource);

    pResStateContext = LocalAlloc(LMEM_FIXED, sizeof(RESOURCE_STATE_CHANGE));

    if (!pResStateContext)
    {

        dwStatus = GetLastError();
        CL_UNEXPECTED_ERROR(dwStatus);
        goto FnExit;
    }


    pResStateContext->pResource = pResource;
    pResStateContext->OldState = OldState;
    pResStateContext->NewState = NewState;

                    
    hThread = CreateThread( NULL, 0, FmpHandleResStateChangeProc,
                pResStateContext, 0, &dwThreadId );

    if ( hThread == NULL )
    {
        dwStatus = GetLastError();
        CL_UNEXPECTED_ERROR(dwStatus);
        // if the function failed to create the thread, cleanup the 
        // state that the thread would have cleaned
        //deref the object if the thread is  not created successfully
        OmDereferenceObject(pResource);
        LocalFree(pResStateContext);
        goto FnExit;
    }

FnExit:
    //do general cleanup
    if (hThread)
        CloseHandle(hThread);
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpCreateResStateChangeHandler: Exit, status %1!u!\r\n",
        dwStatus);
    return(dwStatus);
}

/****
@func       DWORD | FmpHandleResStateChangeProc| This thread procedure
            handles all the post processing for the resource transitions
            for the quorum resource.

@parm       IN LPVOID | pContext | A pointer to PRESOURCE_STATE_CHANGE
            structure.

@comm       This thread handles a resource change notification postprocessing.
            Significantly for quorum resource so that quorum resource
            state change notifications are not handled by the single
            FmpWorkThread() [that causes deadlock - if the quorum 
            notification resource is queued behind a notification whose
            handling requires tha quorum resource be online]..

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpCreateResStateChangeHandler)
****/
DWORD
FmpHandleResStateChangeProc(
    IN LPVOID pContext
    )
{
    PRESOURCE_STATE_CHANGE  pResStateChange = pContext;

    CL_ASSERT( pResStateChange );
    
    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpHandleResStateChangeProc: Entry...\r\n");

    FmpHandleResourceTransition( pResStateChange->pResource, 
                                 pResStateChange->NewState );
                                 
    OmDereferenceObject( pResStateChange->pResource );
    
    LocalFree( pResStateChange );

    ClRtlLogPrint(LOG_NOISE,
        "[FM] FmpHandleResStateChangeProc: Exit...\r\n");

    return( ERROR_SUCCESS );
}


DWORD
FmpDelayedStartRes(
    IN PFM_RESOURCE pResource
    )

/*++

Routine Description:

    Starts a timer for the resource. FmpDelayedRestartCb function will be 
    invoked at the expiry of timer..

Arguments:

    pResource   - The resource which has transitioned.


Return Value:
    ERROR_SUCCESS if successful, WIN32 errorcode otherwise.

    Note that no delayed restart attempts are made if the resource is a quorum resource.

--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpDelayedRestartRes:Entry for resource %1!ws!\n",
                OmObjectId(pResource));
    
    if( (pResource->RetryPeriodOnFailure != CLUSTER_RESOURCE_DEFAULT_RETRY_PERIOD_ON_FAILURE ) &&
        !(pResource->QuorumResource) )
    {
        // Check if there is already a timer running for this resource

        if(pResource->hTimer == NULL)                 
        {
            pResource->hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
            if (!(pResource->hTimer))
            {
                // not a fatal error but log it
                ClRtlLogPrint(LOG_UNUSUAL,
                            "[FM] FmpDelayedRestartRes: failed to create the watchdog timer for resource %1!ws!\n",
                            OmObjectId(pResource));
            }
            else{
                ClRtlLogPrint(LOG_NOISE,
                            "[FM] FmpDelayedRestartRes: Adding watchdog timer for resource  %1!ws!, period=%2!u!\n",
                            OmObjectId(pResource), 
                            pResource->RetryPeriodOnFailure);

                // make sure resource struct won't go away if resource is deleted before the timer fires
                OmReferenceObject(pResource); 

                //register the timer with the periodic activity timer thread
                dwStatus = AddTimerActivity(pResource->hTimer, pResource->RetryPeriodOnFailure, 0, FmpDelayedRestartCb, pResource);

                if (dwStatus != ERROR_SUCCESS)
                {
                    ClRtlLogPrint(LOG_CRITICAL,
                                "[FM] FmpDelayedRestartRes: AddTimerActivity failed with error %1!u!\n",
                                dwStatus);
                    CloseHandle(pResource->hTimer);
                    pResource->hTimer = NULL;
                }
            }
        }
    }
    return dwStatus;
}




VOID 
FmpDelayedRestartCb(
    IN HANDLE hTimer, 
    IN PVOID pContext)

/*++

Routine Description

    This is invoked by timer activity thread to attempt a restart on
    a failed resource.  

Arguments
    pContext - a pointer to PFM_RESOURCE 
   
Return Value
     ERROR_SUCCESS on success, a WIN32 error code otherwise.

--*/
    
{
    PFM_RESOURCE    pResource;

    pResource=(PFM_RESOURCE)pContext;
    ClRtlLogPrint(LOG_NOISE,
           "[FM] FmpDelayedRestartCb: Entry for  resource %1!ws! \n",
           OmObjectId(pResource));

    OmReferenceObject(pResource);
    FmpPostWorkItem(FM_EVENT_RES_RETRY_TIMER,
                        pResource,
                        0);    
    OmDereferenceObject(pResource);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\timer.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Cluster FM callback routines to be invoked on a timer

Author:

    Sunita shrivastava (sunitas) 24-Sep-1998


Revision History:


--*/

#include "fmp.h"

#include "ntrtl.h"

#define LOG_MODULE TIMER


/****
@func       DWORD | FmpQueueTimerActivity| This is invoked by gum when fm requests
            a vote for a given context.

@parm       IN DWORD | dwInterval| The time in msec to wait.

@parm       IN PFN_TIMER_CALLBACK | pfnTimerCb | The callback funtion
            to be invoked when the given time elapses.

@parm       IN PVOID | pContext| A  pointer to a context structure that is
            passed back to the callback function.
            
@comm       It is assumed that FM wants to use one shot timers.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f AddTimerActivity>
****/

DWORD
FmpQueueTimerActivity(
    IN DWORD dwInterval,
    IN PFN_TIMER_CALLBACK pfnTimerCb, 
    IN PVOID pContext    
)    
{
    HANDLE  hTimer = NULL;
    DWORD   dwStatus;
    
    hTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!hTimer)
    {
        dwStatus = GetLastError();
    	CL_LOGFAILURE(dwStatus);
    	goto FnExit;
    }

    //register the timer for this log with the activity timer thread
    dwStatus = AddTimerActivity(hTimer, dwInterval, 0, pfnTimerCb, pContext);

    if (dwStatus != ERROR_SUCCESS)
    {
        CloseHandle(hTimer);
        goto FnExit;
    }

FnExit:
    return(dwStatus);

} // FmpQueueTimerActivity


/****
@func       DWORD | FmpReslistOnlineRetryCb| This is invoked by timer
            activity thread to bring a resource list online again.

@parm       IN VOID | pContext| a pointer to PFM_RESLIST_ONLINE_RETRY_INFO
            structure containing information about the group and
            resources to bring online.
            
@comm       We dont do the work here since the timer lock is held and we
            want to avoid acquiring the group lock while the timer lock 
            is held.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f FmpWorkerThread> <f FmpOnlineResourceList>
****/

void
WINAPI
FmpReslistOnlineRetryCb(
    IN HANDLE hTimer,
    IN PVOID  pContext
)
{
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpResListOnlineRetryCb: Called to retry bringing the  group online\r\n");

    //post a work item, since we dont wont to acquire group locks
    //while the timer lock is acquired
    //pass hTimer as second Context value to be used by RemoveTimerActivity
    FmpPostWorkItem(FM_EVENT_INTERNAL_RETRY_ONLINE, pContext, 
        (ULONG_PTR)hTimer);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\worker.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    worker.c

Abstract:

    Failover Manager worker thread.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/

#define UNICODE 1

#include "fmp.h"

#define LOG_MODULE WORKER


CL_QUEUE FmpWorkQueue;


//
// Local Data
//
HANDLE             FmpWorkerThreadHandle = NULL;

//
// Forward routines
//
BOOL
FmpAddNodeGroupCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


//
// Local routines
//

DWORD
FmpWorkerThread(
    IN LPVOID Ignored
    )
{
    DWORD        status;
    PLIST_ENTRY  entry;
    PWORK_ITEM   workItem;
    DWORD        running = TRUE;
    PFM_RESOURCE resource;
    PFMP_POSSIBLE_NODE possibleNode;
    DWORD           i;

    ClRtlLogPrint(LOG_NOISE,"[FM] Worker thread running\n");

    while ( running ) {

        //
        // Check the FM work queue for work items
        //
        entry = ClRtlRemoveHeadQueue(&FmpWorkQueue);
        if ( entry == NULL ) {
            return(ERROR_SUCCESS);
        }

        workItem = CONTAINING_RECORD(entry,
                                     WORK_ITEM,
                                     ListEntry);

        //
        // FM no longer cares about node up events, make sure
        // we aren't getting any queued.
        //
        switch ( workItem->Event ) {

            case FM_EVENT_SHUTDOWN:
                ClRtlLogPrint(LOG_NOISE,"[FM] WorkerThread terminating...\n");
                running = FALSE;
                break;

            case FM_EVENT_RESOURCE_ADDED:
                resource = workItem->Context1;
                if ( resource->Monitor == NULL ) {
                    FmpAcquireLocalResourceLock( resource );
                    //
                    //  Chittur Subbaraman (chitturs) - 8/12/99
                    //
                    //  Make sure the resource is not marked for delete.
                    //
                    if ( IS_VALID_FM_RESOURCE( resource ) )
                    {
                        FmpInitializeResource( resource, TRUE );
                    }
                    FmpReleaseLocalResourceLock( resource );
                }               
                OmDereferenceObject( resource );
                break;

            case FM_EVENT_RESOURCE_DELETED:
                //
                // Tell the resource monitor to cleanup the resource.
                //
                resource = workItem->Context1;

                FmpAcquireLocalResourceLock( resource );

                // Now that no remaining resource depends on this resource and
                // this resource does not depend on any other resources, we can
                // terminate it in the resource monitor if the resource is not
                // already offline or failed
                //
                if ( (resource->Group->OwnerNode == NmLocalNode) &&
                     ((resource->State != ClusterResourceOffline) &&
                      (resource->State != ClusterResourceFailed))) {
                    FmpRmTerminateResource(resource);
                }


                status = FmpRmCloseResource(resource);
                ClRtlLogPrint( LOG_NOISE,
                            "[FM] WorkItem, delete resource <%1!ws!> status %2!u!\n",
                            OmObjectName(resource),
                            status );
                FmpReleaseLocalResourceLock( resource );
                OmDereferenceObject(resource);
                break;

            case FM_EVENT_GROUP_FAILED:
                FmpHandleGroupFailure( workItem->Context1, NULL );
                OmDereferenceObject( workItem->Context1 );
                break;

            case FM_EVENT_NODE_ADDED:
                //
                // We need to add this node to every resource's possible owners
                // list and to each group's preferred owners list.
                //
                OmEnumObjects( ObjectTypeGroup,
                               FmpAddNodeGroupCallback,
                               workItem->Context1,
                               NULL );
                break;

            case FM_EVENT_NODE_EVICTED:
                //
                // Enumerate all the resources types to remove any PossibleNode references.
                //
                OmEnumObjects(ObjectTypeResType,
                              FmpEnumResTypeNodeEvict,
                              workItem->Context1,
                              NULL);
            
                //
                // Enumerate all the resources to remove any PossibleNode references.
                //
                OmEnumObjects(ObjectTypeResource,
                              FmpEnumResourceNodeEvict,
                              workItem->Context1,
                              NULL);

                //
                // Enumerate all the groups to remove any PreferredNode references
                //
                OmEnumObjects(ObjectTypeGroup,
                              FmpEnumGroupNodeEvict,
                              workItem->Context1,
                              NULL);
                //Now dereference the object
                OmDereferenceObject( workItem->Context1 );
                break;

#if 0
            case FM_EVENT_CLUSTER_PROPERTY_CHANGE:
                //this is for the cluster name change
                FmpClusterEventPropHandler((PFM_RESOURCE)workItem->Context1);

                //Now dereference the object
                OmDereferenceObject( workItem->Context1 );
                break;
#endif                 

            case FM_EVENT_RESOURCE_CHANGE:
                // this is for a Add/Remove possible node request
                possibleNode = workItem->Context1;
                if ( possibleNode == NULL ) {
                    break;
                }
                FmpRmResourceControl( possibleNode->Resource,
                                      possibleNode->ControlCode,
                                      (PUCHAR)OmObjectName(possibleNode->Node),
                                      ((lstrlenW(OmObjectName(possibleNode->Node)) + 1) * sizeof(WCHAR)),
                                      NULL,
                                      0,
                                      NULL,
                                      NULL );
                    // ignore status                                      
                OmDereferenceObject( possibleNode->Resource );
                OmDereferenceObject( possibleNode->Node );
                LocalFree( possibleNode );
                break;
                
            case FM_EVENT_RESOURCE_PROPERTY_CHANGE:
                //
                // Generate a cluster wide event notification for this event.
                //
                ClusterWideEvent(
                    CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                    workItem->Context1 // Resource
                    );
                OmDereferenceObject( workItem->Context1 );
                break;

            case FM_EVENT_RES_RESOURCE_TRANSITION:
                FmpHandleResourceTransition(workItem->Context1, workItem->Context2);
                OmDereferenceObject(workItem->Context1);
                break;

            case FM_EVENT_RES_RESOURCE_FAILED:
                FmpProcessResourceEvents(workItem->Context1, ClusterResourceFailed,
                        workItem->Context2);
                OmDereferenceObject( workItem->Context1 );
                break;
                
            case FM_EVENT_RES_RETRY_TIMER:

                resource= (PFM_RESOURCE)workItem->Context1;
                //Remove any pending watchdog timer
                if (resource->hTimer)
                {   
                    RemoveTimerActivity(resource->hTimer);
                    resource->hTimer = NULL;
                }    
                
                FmpAcquireLocalResourceLock(resource);

                // Check if this resource was deleted in the meanwhile, 
                // or is not in failed state
                if( ( IS_VALID_FM_RESOURCE( resource ) ) &&
                    ( resource->State == ClusterResourceFailed ) &&
                    ( resource->PersistentState == ClusterResourceOnline ) )
                {        
                    // Check if we are the owner, if not ignore it
                    if ( resource->Group->OwnerNode == NmLocalNode ) 
                    {
                        FmpProcessResourceEvents(resource,
                                        ClusterResourceFailed,
                                        ClusterResourceOnline);                                            
                    }
                }

                FmpReleaseLocalResourceLock(resource);
                OmDereferenceObject( workItem->Context1 );
                break;                                  


            case FM_EVENT_INTERNAL_PROP_GROUP_STATE:
                FmpPropagateGroupState(workItem->Context1);
                OmDereferenceObject( workItem->Context1 );
                break;


            case FM_EVENT_INTERNAL_RETRY_ONLINE:
            {
                PFM_RESLIST_ONLINE_RETRY_INFO   pFmOnlineRetryInfo;  
                            
                RemoveTimerActivity((HANDLE)workItem->Context2);
                pFmOnlineRetryInfo= workItem->Context1;
                CL_ASSERT(pFmOnlineRetryInfo);
                
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpWorkerThread, retrying to online resourcelist\r\n");
                FmpOnlineResourceFromList(&(pFmOnlineRetryInfo->ResourceEnum), 
                    pFmOnlineRetryInfo->pGroup);
                
                //Free memory 
                for (i =0; i< pFmOnlineRetryInfo->ResourceEnum.EntryCount; i++)
                    LocalFree( pFmOnlineRetryInfo->ResourceEnum.Entry[i].Id ); 
                if (pFmOnlineRetryInfo->pGroup) 
                    OmDereferenceObject(pFmOnlineRetryInfo->pGroup);                    
                LocalFree(pFmOnlineRetryInfo);                    
                break;
            }

            case FM_EVENT_INTERNAL_RESOURCE_CHANGE_PARAMS:
            {
                BOOL    bIsValidRes = TRUE;
                
                //
                // Now tell the resource monitor about the changes.
                //
                status = ERROR_SUCCESS;
                resource = (PFM_RESOURCE)workItem->Context1;
                FmpAcquireLocalResourceLock( resource );
                //
                //  Chittur Subbaraman (chitturs) - 8/12/99
                //
                //  Check whether the resource is marked for delete.
                //
                if ( !IS_VALID_FM_RESOURCE( resource ) )
                {
                    bIsValidRes = FALSE;
                } 

                FmpReleaseLocalResourceLock( resource );

                if( bIsValidRes ) 
                {
                    status = FmpRmChangeResourceParams( resource );
                }
                
                if ( status != ERROR_SUCCESS ) 
                {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[FM] FmpWorkerThread, failed to change resource "
                                "parameters for %1!ws!, error %2!u!.\n",
                               OmObjectId(resource),
                               status );
                }
                OmDereferenceObject(resource);
                break;
            }

            case FM_EVENT_INTERNAL_ONLINE_GROUPLIST:
            {
                PGROUP_ENUM pGroupList = NULL;

                ClRtlLogPrint(LOG_NOISE, 
                    "[FM] FmpWorkerThread : Processing Node Down Group List\n");
                pGroupList = workItem->Context1;
                FmpOnlineGroupList(pGroupList, TRUE);
                FmpDeleteEnum(pGroupList);
                break;

            }

            case FM_EVENT_RESOURCE_NAME_CHANGE:
            {
                //
                //  Chittur Subbaraman (chitturs) - 6/29/99
                //
                //  Added this new event to handle resource name change
                //  notifications to resource DLLs.
                //
                PFM_RES_CHANGE_NAME pResChangeName = NULL;
                DWORD   dwStatus = ERROR_SUCCESS;
                
                pResChangeName = ( PFM_RES_CHANGE_NAME ) workItem->Context1;

                dwStatus = FmpRmResourceControl( pResChangeName->pResource,
                                   CLUSCTL_RESOURCE_SET_NAME,
                                   (PUCHAR) pResChangeName->szNewResourceName,
                                   ((lstrlenW(pResChangeName->szNewResourceName) + 1) * sizeof(WCHAR)),
                                   NULL,
                                   0,
                                   NULL,
                                   NULL );

                ClRtlLogPrint(LOG_NOISE,
                        "[FM] Worker thread handling FM_EVENT_RESOURCE_NAME_CHANGE event - FmpRmResourceControl returns %1!u! for resource %2!ws!\n",
                        dwStatus,
                        OmObjectId(pResChangeName->pResource));

                OmDereferenceObject( pResChangeName->pResource );
                LocalFree( pResChangeName );                      
                break;
            }
            
            default:
                ClRtlLogPrint(LOG_NOISE,
                           "[FM] WorkerThread, unrecognized event %1!u!\n",
                           workItem->Event);
        }

        //
        // Free the work item.
        //

        LocalFree( workItem );

    }

    return(ERROR_SUCCESS);

} // FmpWorkerThread


VOID
FmpProcessResourceEvents(
    IN PFM_RESOURCE pResource,
    IN CLUSTER_RESOURCE_STATE NewState,
    IN CLUSTER_RESOURCE_STATE OldState
    )

/*++

Routine Description:

Arguments:

Return Value:

Comments:  This should not call PropagateResourceState().  FmpProcessResourceEvents
acquires the group lock.  The quorum resource state must be propagated without holding
the group lock.  FmpPropagateResourceState() must be called by FmpHandleResourceTransition.
There is a slight window between when the event is received in FmpHandleResourceTransition()
and when the actions corresponding to those are carried out in FmpProcessResourceEvents().
In this window, another opposing action like offline/online might occur.  But we dont
worry about it since if there are waiting resources on this resource, those actions
are not carried out.

--*/

{
    DWORD                   Status;
    BOOL                    bQuoChangeLockHeld = FALSE;
    
    
    CL_ASSERT(pResource != NULL);
    
ChkFMState:
    if (!FmpFMGroupsInited)
    {
        DWORD   dwRetryCount = 50;
        
        ACQUIRE_SHARED_LOCK(gQuoChangeLock);

        //FmFormNewClusterPhaseProcessing is in progress
        if (FmpFMFormPhaseProcessing)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[FM] FmpProcessResourceEvents, resource notification from quorum resource during phase processing,sleep and retry\n");
            RELEASE_LOCK(gQuoChangeLock);
            Sleep(500);
            if (dwRetryCount--)
                goto ChkFMState;
            else
            {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[FM] FmpProcessResourceEvents, waited for too long\n");
                //terminate the process                    
                CL_ASSERT(FALSE);
            }
        }
        else
        {
            bQuoChangeLockHeld = TRUE;
        }
        //this can only come from the quorum resource
        CL_ASSERT(pResource->QuorumResource);
    }


    FmpAcquireLocalResourceLock( pResource );

    //
    //  Chittur Subbaraman (chitturs) - 8/12/99
    //
    //  First check whether the resource has been marked for deletion. If
    //  so, don't do anything. Note that this function is called from
    //  the worker thread AFTER FmpHandleResourceTransition has propagated
    //  the failed state of the resource. Now, after the propagation has
    //  occurred, a client is free to delete the resource. So, when the
    //  worker thread makes this function call, we need to check whether
    //  the resource is deleted and reject the call. Note that this function
    //  holds the resource lock on the owner node of the resource and so 
    //  is serialized with the FmDeleteResource call which is also executed
    //  on the owner node of the resource with the lock held. So, the 
    //  following check will give us a consistent result.
    //
    if ( !IS_VALID_FM_RESOURCE( pResource ) )
    {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpProcessResourceEvents: Resource %1!ws! has already been deleted, returning...\n",
            OmObjectId(pResource));
        goto FnExit;
    }

    switch(NewState){
        case ClusterResourceFailed:
            //check the old resource state
            if (OldState == ClusterResourceOnline)
            {
                FmpHandleResourceFailure(pResource);
            }
            else if ((OldState == ClusterResourceOffline) ||
                    (OldState == ClusterResourceOfflinePending))
            {
                FmpTerminateResource(pResource);
                if ( pResource->Group->OwnerNode == NmLocalNode ) 
                {
                    Status = FmpOfflineWaitingTree(pResource);
                    if ( Status != ERROR_IO_PENDING) 
                    {
                        FmpCheckForGroupCompletionEvent(pResource->Group);
                        FmpSignalGroupWaiters( pResource->Group );
                    }
                }
            }
            else if (OldState == ClusterResourceOnlinePending)
            {
                FmpHandleResourceFailure(pResource);
                FmpCheckForGroupCompletionEvent(pResource->Group);
                FmpSignalGroupWaiters( pResource->Group );

            }
            break;

        case ClusterResourceOnline:
            if (OldState == ClusterResourceOnlinePending)
            {
                Status = FmpOnlineWaitingTree( pResource );
                if (Status != ERROR_IO_PENDING) {
                    FmpCheckForGroupCompletionEvent(pResource->Group);
                    FmpSignalGroupWaiters( pResource->Group );
                }
            }
            break;
            
        case ClusterResourceOffline:
            if ((OldState == ClusterResourceOfflinePending) ||
                (OldState == ClusterResourceOffline))
            {
                Status = FmpOfflineWaitingTree(pResource);
                if ( Status != ERROR_IO_PENDING) 
                {
                    FmpCheckForGroupCompletionEvent(pResource->Group);
                    FmpSignalGroupWaiters( pResource->Group );
                }
            }
            break;
    }

FnExit:
    FmpReleaseLocalResourceLock( pResource );
    
    if (bQuoChangeLockHeld)   RELEASE_LOCK(gQuoChangeLock);

    return;

}


VOID
FmpPostWorkItem(
    IN CLUSTER_EVENT Event,
    IN PVOID         Context1,
    IN ULONG_PTR     Context2
    )

/*++

Routine Description:

    Posts a work item event to the FM work queue.

Arguments:

    Event - The event to post.
    Context1 - A pointer to some context.  This context should be permanent
            in memory - i.e. it should not be deallocated when this call
            returns.
    Context2 - A pointer to additional context.  This context should be
            permanent in memory - i.e. it should not be deallocated when this
            call returns.

Returns:

    None.

--*/

{
    PWORK_ITEM workItem;

    workItem = LocalAlloc(LMEM_FIXED, sizeof(WORK_ITEM));

    if ( workItem == NULL ) {
        CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
    } else {
        workItem->Event = Event;
        workItem->Context1 = Context1;
        workItem->Context2 = Context2;

        //
        // Insert work item on queue and wake up the worker thread.
        //
        ClRtlInsertTailQueue(&FmpWorkQueue, &workItem->ListEntry);
    }

} // FmpPostEvent



DWORD
FmpStartWorkerThread(
    VOID
    )
{
    DWORD       threadId;
    DWORD       Status;

    //
    // Start up our worker thread
    //
    ClRtlLogPrint(LOG_NOISE,"[FM] Starting worker thread...\n");

    FmpWorkerThreadHandle = CreateThread(
                                NULL,
                                0,
                                FmpWorkerThread,
                                NULL,
                                0,
                                &threadId
                                );

    if (FmpWorkerThreadHandle == NULL) {
        ClRtlLogPrint(LOG_NOISE,
            "[FM] Failed to start worker thread %1!u!\n",
            GetLastError()
            );
        return(GetLastError());
    }

    return(ERROR_SUCCESS);

} // FmpStartWorkerThread



BOOL
FmpAddNodeGroupCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Enumeration callback for each group in the system when a new
    node is added to the cluster.

    The algorithm used here is to enumerate all the resources in
    this group.  For each resource in the group that does not
    have an explicit "PreferredOwners" setting in the registry,
    the node is added as a PossibleNode.  Finally, if the node
    was added as a possiblenode for each resource in the group,
    the node is added to the end of the preferredowners list for
    the group.

Arguments:

    Context1 - Supplies the PNM_NODE of the new node.

    Context2 - Not used.

    Object - Supplies the group object.

    Name - Supplies the name of the group object.

Return Value:

    TRUE

--*/

{
    PFM_RESOURCE Resource;
    PFM_GROUP Group;
    PNM_NODE Node;
    HDMKEY hKey;
    DWORD Status;
    PPREFERRED_ENTRY preferredEntry;
    PRESOURCE_ENUM ResourceEnum;
    DWORD  i;

    Group = (PFM_GROUP)Object;
    Node = (PNM_NODE)Context1;

    FmpAcquireLocalGroupLock( Group );
    Status = FmpGetResourceList( &ResourceEnum,
                                 Group );
    FmpReleaseLocalGroupLock( Group );
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] AddNodeGroup, failed to get resource list for group %1!ws!, status %2!u!.\n",
                   Name,
                   Status );
        return(TRUE);
    }

    //
    // First fix up the resource info.
    //
    for ( i = 0; i < ResourceEnum->EntryCount; i++ ) {
        Resource = OmReferenceObjectById( ObjectTypeResource,
                                          ResourceEnum->Entry[i].Id );
        if ( Resource != NULL ) {
            FmpAcquireLocalResourceLock( Resource );
            //ss: we need to hold the resource lock as well
            //since that is the one that the update (FmpUpdateChangeResourceNode)
            // to remove and add nodes obtains and we must synchronize with it
            FmpAcquireResourceLock();
            Status = FmpFixupResourceInfo( Resource );
            FmpReleaseResourceLock();
            FmpReleaseLocalResourceLock( Resource );
            if ( Status == ERROR_SUCCESS ) {
                FmpRmResourceControl( Resource,
                                      CLUSCTL_RESOURCE_INSTALL_NODE,
                                      (PUCHAR)OmObjectName(Node),
                                      ((lstrlenW(OmObjectName(Node)) + 1) * sizeof(WCHAR)),
                                      NULL,
                                      0,
                                      NULL,
                                      NULL );
                // Ignore status return

                ClusterEvent( CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE,
                              Resource );
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[FM] AddNodeGroup, failed to fixup info for resource %1!ws! when node was added!\n",
                           OmObjectName( Resource ) );
            }
            OmDereferenceObject( Resource );
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] AddNodeGroup, failed to find resource %1!ws! in group %2!ws!.\n",
                       ResourceEnum->Entry[i].Id,
                       Name );
        }
    }

    FmpDeleteResourceEnum( ResourceEnum );

    //
    // Now fix up the group information.
    //
    FmpAcquireLocalGroupLock( Group );
    Status = FmpFixupGroupInfo( Group );
    FmpReleaseLocalGroupLock( Group );
    if ( Status == ERROR_SUCCESS ) {
        ClusterEvent( CLUSTER_EVENT_GROUP_PROPERTY_CHANGE, Group );
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[FM] AddNodeGroup, failed to fixup info for group %1!ws! when node was added, status %2!u!.\n",
                   OmObjectName( Group ),
                   Status );
    }

    return(TRUE);

} // FmpAddNodeGroupCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\rpcbind.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    RPC binding table managment routines

Author:

    John Vert (jvert) 6/10/1996

Revision History:

--*/

#include "fmp.h"

//
// Private RPC binding table
//
RPC_BINDING_HANDLE  FmpRpcBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];
RPC_BINDING_HANDLE  FmpRpcQuorumBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];


DWORD
FmCreateRpcBindings(
    PNM_NODE  Node
    )
/*++

Routine Description:

    Creates FM's private RPC bindings for a joining node.
    Called by the Node Manager.

Arguments:

    Node - A pointer to the node for which to create RPC bindings

Return Value:

    A Win32 status code.

--*/
{
    DWORD               Status;
    RPC_BINDING_HANDLE  BindingHandle;
    CL_NODE_ID          NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[FM] Creating RPC bindings for node %1!u!.\n",
        NodeId
        );

    //
    // Main binding
    //
    if (FmpRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(FmpRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[FM] Failed to verify main RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(FmpRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[FM] Failed to create main RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    //
    // Quorum binding
    //
    if (FmpRpcQuorumBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(FmpRpcQuorumBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[FM] Failed to verify quorum RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            // presumably we will shutdown at this point
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(FmpRpcQuorumBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[FM] Failed to create quorum RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    return(ERROR_SUCCESS);

} // FmpCreateRpcBindings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\config.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Reads cluster configuration from file

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

extern void debug_init();

void
msg_set_mode(int mode);

void
msg_set_uport(int uport);

void
msg_set_mport(int mport);

void
msg_set_subnet(char *addr);

void
msg_set_mipaddr(char *addr);

void
msg_set_bufcount(int count);

void
msg_set_bufsize(int count);


#define stricmp(a,b)	strcmp(a,b)

static char qfile[256];
static char vname[256];
static char crsname[256];
static int crssz = 128*1024;

char *
WINAPI
config_get_volume()
{
    return vname;
}

char *
WINAPI
config_get_crsfile()
{
    return crsname;
}

int
WINAPI
config_get_crssz()
{
    return crssz;
}

char *
WINAPI
config_get_qfile()
{
  return qfile;
}

static void
parse_node(char *buf)
{
    char *s, *p, *q;
    int WINAPI msg_addnode(int id, char *n, char *a);
    int id;

    p = strchr(buf, ':');
    if (p == NULL)
      return;

    *p = '\0'; p++;

    id = atoi(buf);

    s = p;
    p = strchr(s, ':');
    if (p == NULL)
      return;

    p++;
    q = strchr(p, '\n');
    if (q) {
      *q = '\0'; q += 2;
    }
    msg_addnode(id, s, p);
}

static void
parse_vol(char *buf)
{
    char *s, *p, *q;

    s = (char *)buf;
#if 0
    p = strchr(s, ':');
    if (p == NULL)
      return;

    *p = '\0'; p++;
#else
    p = s;
#endif
    q = strchr(p, '\n');
    if (q) {
      *q = '\0'; q += 2;
    }
    // add volume
    strcpy(vname, s);
}
    
static void
parse(char *buf, ULONG len)
{
    char *s, *p, *q;
    void WINAPI debug_log_file(char*);
    void WINAPI debug_level(ULONG);


    s = (char *)buf;
    s[len] = '\0';

    p = strchr(s, ':');
    if (p == NULL)
      return;

    *p = '\0'; p++;
    q = strchr(p, '\n');
    if (q) {
      *q = '\0'; q += 2;
    }

    if (!stricmp(s, "quorm")) {
      strcpy(qfile, p);
    } else if (!stricmp(s, "log_file")) {
      debug_log_file(p);
    } else if (!stricmp(s, "log_level")) {
      ULONG x = (ULONG) atoi(p);
      debug_level(x);
    } else if (!stricmp(s, "crs_file")) {
      strcpy(crsname, p);
    } else if (!stricmp(s, "crs_size")) {
      crssz = atoi(p);
      if (crssz == 0) {
	  crssz = 128;
      }
    } else if (!stricmp(s, "mcast")) {
      msg_set_mode(atoi(p));
    } else if (!stricmp(s, "mcast_ipaddr")) {
      msg_set_mipaddr(p);
    } else if (!stricmp(s, "mcast_port")) {
      int x = atoi(p);
      msg_set_mport(x);
    } else if (!stricmp(s, "subnet")) {
      msg_set_subnet(p);
    } else if (!stricmp(s, "ucast_port")) {
      int x = atoi(p);
      msg_set_uport(x);
    } else if (!stricmp(s, "buffers")) {
      int x = atoi(p);
      msg_set_bufcount(x);
    } else if (!stricmp(s, "bufsize")) {
      int x = atoi(p);
      msg_set_bufsize(x);
    } else if (!stricmp(s, "node")) {
      parse_node(p);
    } else if (!stricmp(s, "volume")) {
      parse_vol(p);
    } else {
      fprintf(stderr,"Unknown tag '%s'\n", s);
    }
}

void
ConfigInit()
{
  char buf[256];
  FILE *fp;
  char *s = getenv("RfsFile");

  if (s == NULL)
    s = "rfs.conf";

  debug_init();

  // Open cluster
  fp = fopen(s, "r");
  if (fp == NULL) {
    fprintf(stderr,"Unable to open configuration file '%s'\n", s);
    exit(0);
  }

  // init stuff
  strcpy(crsname, "c:\\crs.log");

  while (fgets(buf, sizeof(buf), fp)) {
    if (strlen(buf) > 2) {
      parse(buf, strlen(buf));
    }
  }

  fclose(fp);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\cm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cm.c

Abstract:

    Connection Manager

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include "msg.h"

extern BOOLEAN QuormAcquire();
extern void QuormInit();
extern void QuormRelease();

#include <stdio.h>

#define	GS_MAX_NODEID	16
#define	GS_REGROUP_PHASES	3

#define	CmStateJoin	0
#define	CmStateNormal	1
#define	CmStateUp	2
#define	CmStateDown	3

gs_nid_t	GsLocalNodeId;

gs_nid_t	QuormOwnerId;

int		GsMaxNodeId = GS_MAX_NODEID;
int		GsMinNodeId = 1;

long	Regroup;	// number of down nodes

ULONG 	Node_Mask;		// current active node mask
ULONG	JoinNode_Mask;	// current joining node mask
ULONG	Sync_Valid;		// which barrier points are valid

ULONG	Sync_Mask[GS_REGROUP_PHASES];
// Cluster connectivity matrix
ULONG	ClusterNode_Mask[GS_MAX_NODEID+1];

gs_lock_t	MmLock;
gs_event_t	Start_Event, Regroup_Event;

extern void NsSetOwner(gs_nid_t);

void
cm_node_up()
{
    ULONG mask;

    if (Node_Mask == JoinNode_Mask) {
	return;
    }

    // get the difference
    mask = Node_Mask ^ JoinNode_Mask;

    Node_Mask = JoinNode_Mask;

    cm_log(("Node UPUPUP mask %x: upset %x\n", Node_Mask, mask));
	
    // inform new node of resources that it we own
	
    // If we have a registered node up event, call it now
}

void
cm_node_down()
{
    ULONG mask;

    if (Node_Mask == JoinNode_Mask) {
	return;
    }

    // get the difference
    mask = Node_Mask ^ JoinNode_Mask;

    Node_Mask = JoinNode_Mask;

    cm_log(("Node DNDNDN mask %x: dnset %x\n", Node_Mask, mask));

    NsSetOwner(QuormOwnerId);

    GspPhase2NodeDown(mask);
}

static int
cm_full_connectivity()
{
    int i, j;

    for (i = 1; i < GS_MAX_NODEID; i++) {

	// if node is not up, ignore it
	if ((JoinNode_Mask & (1 << i)) == 0)
	    continue;

	// check node's i mask with others
	for (j = i+1; j <= GS_MAX_NODEID; j++) {

	    // if node is not up, ignore it
	    if ((JoinNode_Mask & (1 << j)) == 0)
		continue;

	    if (ClusterNode_Mask[i] ^ ClusterNode_Mask[j]) {
		cm_log(("FC: node %d mask 0x%x node %d mask 0x%x\n",
		       i,
		       ClusterNode_Mask[i],
		       j,
		       ClusterNode_Mask[j]));
		return 0;
	    }
	}
    }
    return 1;
}

void
GspMmMsgHandler(gs_msg_t *msg)
{
    int nodeid = msg->m_hdr.h_sid;
    ULONG old;

    // Update node's up mask
    GsLockEnter(MmLock);

    old = ClusterNode_Mask[GsLocalNodeId];

    ClusterNode_Mask[nodeid] |= msg->m_hdr.h_bnum;
    ClusterNode_Mask[GsLocalNodeId] |= (1 << nodeid);
	
    if (msg->m_hdr.h_flags != 0) {
	QuormOwnerId = msg->m_hdr.h_flags;
	cm_log(("Learn new quorm owner %d\n", QuormOwnerId));
    }

    cm_log(("MM qowner %d mask %x node %d, j %x n %x\n",QuormOwnerId,
	   msg->m_hdr.h_bnum, nodeid,
	   JoinNode_Mask, Node_Mask));

    if (old != ClusterNode_Mask[GsLocalNodeId]) {

	msg->m_hdr.h_type = GS_MSG_TYPE_MM;
	msg->m_hdr.h_len = 0;
	msg->m_hdr.h_flags = QuormOwnerId;
	msg->m_hdr.h_sid = GsLocalNodeId;
	msg->m_hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];

	msg_smcast(JoinNode_Mask, &msg->m_hdr, NULL, 0);
    }

    // If the matrix is full connected, we are done
    if (cm_full_connectivity() != 0) {
	switch(Regroup) {
	case CmStateJoin:
	    cm_node_up();
	    GsEventSignal(Start_Event);
	    break;
	case CmStateUp:
	    cm_node_up();
	    break;
	case CmStateDown:
	    cm_node_down();
	    break;
	default:
	    err_log(("Invalid cm state %d\n", Regroup));
	    exit(1);
	}
	Regroup = CmStateUp;
#if 0
	cm_node_up();
	if (Regroup < 0) {
	    GsEventSignal(Start_Event);
	}
#endif
    } 

    GsLockExit(MmLock);

    msg_free(msg);
}

void
GspInfoMsgHandler(gs_msg_t *msg)
{
    int nodeid = msg->m_hdr.h_sid;

    // make sure we send our info to the sender
//    cm_node_join(nodeid);

    // lock membership state
    GsLockEnter(MmLock);

    if (msg->m_hdr.h_flags != 0) {
	QuormOwnerId = msg->m_hdr.h_flags;
	NsSetOwner(QuormOwnerId);
    }

    cm_log(("Info Node %d mask %x quorm %d\n", nodeid, msg->m_hdr.h_bnum,
	   QuormOwnerId));

    // Foward message to all other members
    cm_log(("Info Mcast %x node %d mask %x\n",
	   ClusterNode_Mask[GsLocalNodeId], nodeid, JoinNode_Mask));

    msg->m_hdr.h_type = GS_MSG_TYPE_MM;
    msg->m_hdr.h_len = 0;
    msg->m_hdr.h_sid = GsLocalNodeId;
    msg->m_hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];

    msg_smcast(JoinNode_Mask, &msg->m_hdr, NULL, 0);

    GsLockExit(MmLock);

    msg_free(msg);
}

void
gs_nodeup_handler(int nodeid)
{
    gs_msg_hdr_t hdr;

    cm_log(("Node up %d\n", nodeid));
    GsLockEnter(MmLock);
    if (JoinNode_Mask & (1 << nodeid)) {
	printf("Node is already up %d 0x%x\n", nodeid, JoinNode_Mask);
	GsLockExit(MmLock);
	return;
    }

    JoinNode_Mask |= (1 << nodeid);

    if (1 || Regroup != CmStateJoin) {
    cm_log(("Node %d is alive, j %x n %x, sending info\n", nodeid,
	       JoinNode_Mask, Node_Mask));


    hdr.h_type = GS_MSG_TYPE_INFO;
    hdr.h_sid = GsLocalNodeId;
    hdr.h_flags = QuormOwnerId;
    hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];
    hdr.h_len = 0;

    msg_send((gs_memberid_t) nodeid, &hdr, NULL, 0);
    }
    GsLockExit(MmLock);
}

void
gs_nodedown_handler(int nodeid)
{
    int i;
    gs_msg_hdr_t hdr;

    GsLockEnter(MmLock);

    if (!(JoinNode_Mask & (1 << nodeid))) {
	err_log(("Node %d is already down\n", nodeid));
	GsLockExit(MmLock);
	return;
    }

    if (Regroup == CmStateJoin) {
	err_log(("Node down during join, aborting...\n"));
	GsLockExit(MmLock);
	exit(1);
    }

    Regroup = CmStateDown;

    // Assume all nodes see this event and no messaging is required
    for (i = 0; i <= GS_MAX_NODEID; i++) {
	ClusterNode_Mask[i] = (1 << GsLocalNodeId);
    }

    JoinNode_Mask &= ~(1 << nodeid);

    if (!(JoinNode_Mask & (1 << QuormOwnerId))) {
	cm_log(("Lost quorm owner %d\n", QuormOwnerId));
	QuormOwnerId = 0;
    }

    // Acquire Quorum file
    if (QuormOwnerId != GsLocalNodeId && QuormAcquire() == TRUE) {
	cm_log(("I own quorm now\n"));
	QuormOwnerId = GsLocalNodeId;
    }
    cm_log(("Node %d down upset %x -> %x mask %x\n", nodeid,
	   Node_Mask, JoinNode_Mask, Node_Mask ^ JoinNode_Mask));

    // Generate phase 1 node down
    GspPhase1NodeDown(Node_Mask ^ JoinNode_Mask);

    // handle case when I am only node in cluster, otherwise enter regroup again
    if (JoinNode_Mask == (ULONG)(1 << GsLocalNodeId)) { //cm_full_connectivity() != 0) {
	while (QuormOwnerId != GsLocalNodeId) {
	    if (QuormAcquire() == TRUE) {
		QuormOwnerId = GsLocalNodeId;
		break;
	    }
	    Sleep(100);
	}
	cm_node_down();
	Regroup = CmStateUp;
    } else {
	hdr.h_type = GS_MSG_TYPE_MM;
	hdr.h_sid = GsLocalNodeId;
	hdr.h_flags = QuormOwnerId;
	hdr.h_bnum = ClusterNode_Mask[GsLocalNodeId];
	hdr.h_len = 0;

	msg_smcast(JoinNode_Mask, &hdr, NULL, 0);
    }

    GsLockExit(MmLock);
}


void
gs_nodejoin_handler(int nodeid)
{
    cm_log(("Node is alive %d\n", nodeid));
}

void
gs_nodeid_handler(int nodeid)
{
    GsLocalNodeId = (gs_nid_t) nodeid;
//    cm_log(("Node id %d\n", nodeid));
}
	
gs_node_handler_t gs_node_handler[] = {
    gs_nodeid_handler,
    gs_nodejoin_handler,
    gs_nodeup_handler,
    gs_nodedown_handler
};

void
cm_init()
{
    GsLocalNodeId = 0;
    QuormOwnerId = 0;
    Regroup = CmStateJoin;
    Node_Mask = 0;
    JoinNode_Mask = 0;
    Sync_Valid = 0;
    memset(Sync_Mask, 0, sizeof(Sync_Mask));
    memset(ClusterNode_Mask, 0, sizeof(ClusterNode_Mask));
 
    GsLockInit(MmLock);
    GsEventInit(Start_Event);
    GsEventInit(Regroup_Event);

    QuormInit();
    msg_init();
}

cm_start()
{
	int i;
	static int started = 0;

	i = InterlockedIncrement(&started);
	if (i != 1)
	    return 0;

	for (i = 0; i <= GS_MAX_NODEID; i++) {
	    ClusterNode_Mask[i] = (1 << GsLocalNodeId);
	}
	Node_Mask = 1 << GsLocalNodeId;
	JoinNode_Mask = 1 << GsLocalNodeId;

	// wait for join, 
	do {
	    LARGE_INTEGER delta;

	    GsLockEnter(MmLock);

	    if (QuormAcquire() == TRUE) {
		QuormOwnerId = GsLocalNodeId;
		NsSetOwner(QuormOwnerId);
		Regroup = CmStateUp;
		GsLockExit(MmLock);
		break;
	    }

	    GsLockExit(MmLock);

	    msg_start(JoinNode_Mask);
	    cm_log(("Waiting to join %x %x\n", JoinNode_Mask, Node_Mask));

	    delta.QuadPart = 0;
	    delta.LowPart = 5 * 1000; // retry every 5 second
	    if (GsEventWaitTimeout(Start_Event, &delta)) { 
		cm_log(("j %x n %x\n", JoinNode_Mask, Node_Mask));
	    }
	} while (JoinNode_Mask == (ULONG)(1 << GsLocalNodeId) || JoinNode_Mask != Node_Mask);

//	InterlockedIncrement(&Regroup);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\fm\tree.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tree.c

Abstract:

    Cluster resource tree management routines.

Author:

    Rod Gamache (rodga) 17-Apr-1996


Notes:

    WARNING: All of the routines in this file assume that the resource
             lock is held when they are called.

Revision History:


--*/

#include "fmp.h"


#define LOG_MODULE TREE
//
// Global Data
//


//
// Local function prototypes
//
BOOL
FmpAddResourceToDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    );

BOOL
FmpIsResourceInDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    );

DWORD
FmpOfflineWaitingResourceTree(
    IN PFM_RESOURCE  Resource,
    IN BOOL BringQuorumOffline
    );




DWORD
FmpRestartResourceTree(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine brings back part of a dependency tree, starting from the
    point of the last failure.

Arguments:

    Resource - A pointer to the resource object that last failed and is
            restarting.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

--*/

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;


    FmpAcquireLocalResourceLock( Resource );

    //
    // Tell the resource monitor to restart this resource if needed.
    //

    //
    // If the current state is not online and we want it to be online, then
    // bring it online.
    //

    if ( (Resource->State != ClusterResourceOnline)  &&
         ((Resource->PersistentState == ClusterResourceOnline)) ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RestartResourceTree, Restart resource %1!ws!\n",
                   OmObjectId(Resource));
        status = FmpOnlineResource(Resource, FALSE);
    }

  
    
    //
    // If this resource has any dependents, start them if needed.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively restart the dependent resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] RestartResourceTree, %1!ws! depends on %2!ws!. Restart first\n",
                   OmObjectId(dependency->DependentResource),
                   OmObjectId(Resource));

        status = FmpRestartResourceTree(dependency->DependentResource);
    }

    FmpReleaseLocalResourceLock( Resource );

    return(ERROR_SUCCESS);

}  // FmpRestartResourceTree



DWORD
FmpOnlineWaitingTree(
    IN PFM_RESOURCE  Resource
    )

/*++

Routine Description:

    This routine brings back part of a dependency tree, starting from the
    point of the last waiting resource.

Arguments:

    Resource - A pointer to the resource object that is now online.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

Notes:

    This routine is only called when the given resource is online.

--*/

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;


    FmpAcquireLocalResourceLock( Resource );

    //if shutdown is in progress, dont bring resources online
    if (FmpShutdown)
    {
        //
        // If this resource has any dependents, and they are in online pending state
        // mark them as offline.
        //
        for ( entry = Resource->ProvidesFor.Flink;
              entry != &(Resource->ProvidesFor);
              entry = entry->Flink
            )
        {
            dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

            if ((dependency->DependentResource->State == ClusterResourceOnlinePending) &&
                (dependency->DependentResource->Flags & RESOURCE_WAITING))
            {
                //set the state of the all dependent resources to be offline again
                FmpPropagateResourceState(dependency->DependentResource, ClusterResourceOffline);
                //set the resource to be not waiting                
                dependency->DependentResource->Flags &= ~RESOURCE_WAITING;

                //
                // Recursively set the state of all dependent resources to offline
                //
                ClRtlLogPrint(LOG_NOISE,
                       "[FM] OnlineWaitingTree, %1!ws! (%2!u!) depends on %3!ws! (%4!u!). Shutdown others\n",
                       OmObjectId(dependency->DependentResource),
                       dependency->DependentResource->State,
                       OmObjectId(Resource),
                       Resource->State);

                status = FmpOnlineWaitingTree(dependency->DependentResource);

            }
        }

        //
        //  Chittur Subbaraman (chitturs) - 11/5/1999
        //
        //  Ensure that the resource state itself is made 
        //  ClusterResourceOffline if FM is asked to shutdown. Note that
        //  this function is recursively called from below, not just from 
        //  the FM worker thread. So, if FM happened to be shutdown
        //  while executing this function called from below, then we
        //  offline all the dependent resources above, but not the 
        //  resource itself. This is done here.
        //
        if ( ( Resource->State == ClusterResourceOnlinePending ) &&
             ( Resource->Flags & RESOURCE_WAITING ) )
        {
            FmpPropagateResourceState( Resource, ClusterResourceOffline );

            Resource->Flags &= ~RESOURCE_WAITING;

            ClRtlLogPrint( LOG_NOISE,
                        "[FM] OnlineWaitingTree, Resource <%1!ws!> forcibly brought offline...\n",
                        OmObjectId( Resource ) );
        }                    

        FmpReleaseLocalResourceLock( Resource );
        return(ERROR_SUCCESS);
    }
        
    //for normal-non shutdown case
    //
    // Tell the resource monitor to restart this resource if needed.
    //

    //
    // If the current state is not online and it is waiting, then it probably
    // needs to be brought online now.
    //

    if ( (Resource->State == ClusterResourceOnlinePending)  &&
         (Resource->Flags & RESOURCE_WAITING) ) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] FmpOnlineWaitingTree, Start resource %1!ws!\n",
                   OmObjectId(Resource));
        Resource->State = ClusterResourceOffline;
        status = FmpOnlineResource(Resource, FALSE);
        if ( status == ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOnlineWaitingTree, online for resource %1!ws! succeeded, online the dependents\r\n",
               OmObjectId(Resource));
        } 
        else if (status == ERROR_QUORUM_RESOURCE_ONLINE_FAILED)
        {
            PRESOURCE_ENUM  pResourceEnum;
            LPWSTR          pszNewId;
            
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineWaitingTree, online for resource %1!ws!, status = %2!u!.\n",
                       OmObjectId(Resource),
                       status);

            pResourceEnum = (PRESOURCE_ENUM)LocalAlloc(LMEM_FIXED,
                                sizeof(RESOURCE_ENUM));
            if (!pResourceEnum)
            {
                CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
            }
            pResourceEnum->EntryCount = 1;
            pResourceEnum->ContainsQuorum = (Resource == gpQuoResource);
            pszNewId = LocalAlloc(LMEM_FIXED, (lstrlenW(OmObjectId(Resource))+1) * sizeof(WCHAR));
            if ( pszNewId == NULL ) 
            {
                CsInconsistencyHalt(ERROR_NOT_ENOUGH_MEMORY);
            }

            lstrcpyW(pszNewId, OmObjectId(Resource));
            pResourceEnum->Entry[0].Id = pszNewId;
            pResourceEnum->Entry[0].State = Resource->PersistentState;
            FmpSubmitRetryOnline(pResourceEnum, NULL);                       
            FmpReleaseLocalResourceLock(Resource);

            LocalFree(pszNewId);
            LocalFree(pResourceEnum);
            return(status);
        }
        else
        {
            FmpReleaseLocalResourceLock( Resource );
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] FmpOnlineWaitingTree, online for resource %1!ws! returned = %2!u!.\n",
                       OmObjectId(Resource),
                       status);
            return(status);                       

        }
    }

    //
    // If this resource has any dependents, start them if needed.
    //
    for ( entry = Resource->ProvidesFor.Flink;
          entry != &(Resource->ProvidesFor);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, ProviderLinkage);

        //
        // Recursively restart the dependent resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OnlineWaitingTree, %1!ws! (%2!u!) depends on %3!ws! (%4!u!). Start now\n",
                   OmObjectId(dependency->DependentResource),
                   dependency->DependentResource->State,
                   OmObjectId(Resource),
                   Resource->State);

        status = FmpOnlineWaitingTree(dependency->DependentResource);

    }

    FmpReleaseLocalResourceLock( Resource );

    return(ERROR_SUCCESS);

}  // FmpOnlineWaitingTree


DWORD
FmpOfflineWaitingTree(
    IN PFM_RESOURCE  Resource
    )

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status;
    
    FmpAcquireLocalResourceLock( Resource );
    
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOfflineWaitingTree: Entry for <%1!ws!>.\n",
               OmObjectName( Resource ) );

    //
    // Tell the resource monitor to stop this resource if needed.
    // Make sure that the quorum resource is the last one brought offline
    //
    status = FmpOfflineWaitingResourceTree(Resource, FALSE);

    //the quorum resource might still need to come offline, if it is in this group
    if ((status == ERROR_SUCCESS) && (Resource->Group == gpQuoResource->Group))
    {

        ClRtlLogPrint(LOG_NOISE,
            "[FM] FmpOfflineWaitingTree: Quorum resource is in the same group,Moving list=0x%1!08lx!\n",
                Resource->Group->MovingList);

        
        //if a move is pending bring the quorum resource offline if all resources
        // in the group are offline
        // else dont bring the quorum resource offline
        // this is because we dont bring the quorum resource offline on group offlines
        if (Resource->Group->MovingList)
        {
            PLIST_ENTRY listEntry;
            DWORD       BringQuorumOffline = TRUE;
            PFM_RESOURCE pGroupResource;

        
            for ( listEntry = Resource->Group->Contains.Flink;
              listEntry != &(Resource->Group->Contains);
              listEntry = listEntry->Flink ) 
            {
                pGroupResource = CONTAINING_RECORD(listEntry,
                                             FM_RESOURCE,
                                             ContainsLinkage );

                // if this is the quorum resource continue
                if (pGroupResource->QuorumResource)
                    continue;
                //if the state is not offline or failed, dont try
                //and bring the quorum resource offline
                if ((pGroupResource->State != ClusterResourceOffline) && 
                   (pGroupResource->State != ClusterResourceFailed)) 
                {                
                    ClRtlLogPrint(LOG_NOISE,
                        "[FM] FmpOfflineWaitingTree: Quorum cannot be brought offline now for <%1!ws!>, state=%2!u!\n",
                        OmObjectName(pGroupResource), pGroupResource->State);

                    BringQuorumOffline = FALSE;
                    break;
                }
            }
            if (BringQuorumOffline)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[FM] FmpOfflineWaitingTree: bring quorum resource offline\n");
                status = FmpOfflineResource(gpQuoResource, FALSE);
            }            

        }

    }

    FmpReleaseLocalResourceLock( Resource );
    ClRtlLogPrint(LOG_NOISE,
               "[FM] FmpOfflineWaitingTree: returned status %1!u! for <%2!ws!>.\n",
               status, OmObjectName( Resource ) );
    return(status);

}

DWORD
FmpOfflineWaitingResourceTree(
    IN PFM_RESOURCE  Resource,
    IN BOOL BringQuorumOffline
    )

/*++

Routine Description:

    This routine offlines a dependency tree, starting from the
    point of the last waiting resource.

Arguments:

    Resource - A pointer to the resource object that is now offline.

Returns:

    ERROR_SUCCESS - if the request is successful.
    A Win32 error if the request fails.

Notes:

    This routine is only called when the given resource is offline.

--*/

{
    PLIST_ENTRY   entry;
    PDEPENDENCY   dependency;
    DWORD         status = ERROR_SUCCESS;


    FmpAcquireLocalResourceLock( Resource );

    //
    // Tell the resource monitor to stop this resource if needed.
    //

    //
    // If the current state is not offline and it is waiting, then it probably
    // needs to be brought offline now.
    //

    if ((Resource->State == ClusterResourceOfflinePending) &&
         (Resource->Flags & RESOURCE_WAITING)) {
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OfflineWaitingResourceTree, Offline resource %1!ws!\n",
                   OmObjectId(Resource));
        Resource->State = ClusterResourceOnline;
        status = FmpOfflineResource(Resource, FALSE);
        if ( status == ERROR_IO_PENDING ) {
            FmpReleaseLocalResourceLock( Resource );
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OfflineWaitingResourceTree, offline for resource %1!ws! returned pending.\n",
                       OmObjectId(Resource));
            return(status);
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[FM] OfflineWaitingResourceTree, offline for resource %1!ws!, status = %2!u!.\n",
                       OmObjectId(Resource),
                       status);
        }
    }

    //
    // If this resource has any providers, stop them if needed.
    //
    for ( entry = Resource->DependsOn.Flink;
          entry != &(Resource->DependsOn);
          entry = entry->Flink
        )
    {
        dependency = CONTAINING_RECORD(entry, DEPENDENCY, DependentLinkage);

        if (dependency->ProviderResource->QuorumResource && !BringQuorumOffline)
        {
            continue;
        }
        //
        // Recursively offline the provider resource.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[FM] OfflineWaitingResourceTree, %1!ws! provides for %2!ws!. Offline next.\n",
                   OmObjectId(dependency->ProviderResource),
                   OmObjectId(Resource));

        //dependency->ProviderResource->Flags |= RESOURCE_WAITING;
        status = FmpOfflineWaitingResourceTree(dependency->ProviderResource, BringQuorumOffline);

    }

    FmpReleaseLocalResourceLock( Resource );

    ClRtlLogPrint(LOG_NOISE,
               "[FM] OfflineWaitingResourceTree: Exit, status=%1!u! for <%2!ws!>.\n",
               status, OmObjectName( Resource ) );
    return(status);

}  // FmpOfflineWaitingResourceTree


PFM_DEPENDENCY_TREE
FmCreateFullDependencyTree(
    IN PFM_RESOURCE Resource
    )
/*++

Routine Description:

    Creates a full dependency tree containing all the resources
    that either depend on or provide for the supplied resource.

Arguments:

    Resource - Supplies the resource

Return Value:

    Pointer to the dependency tree.

    NULL if out of memory.

--*/

{
    PFM_DEPENDENCY_TREE Tree;
    BOOL Success;

    Tree = LocalAlloc(LMEM_FIXED, sizeof(FM_DEPENDENCY_TREE));
    if (Tree == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    InitializeListHead(&Tree->ListHead);

    //
    // Add the resources that the specified resource depends on.
    //
    Success = FmpAddResourceToDependencyTree(Resource, Tree);
    if (!Success) {
        LocalFree(Tree);
        return(NULL);
    } else {
        return(Tree);
    }

}


BOOL
FmpIsResourceInDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    )
/*++

Routine Description:

    Determines whether the specified resource is already in the
    dependency tree.

Arguments:

    Resource - Supplies the resource to check for

    Tree - Supplies the dependency tree.

Return Value:

    TRUE if the resource is in the dependency tree

    FALSE if the resource is not in the dependency tree

--*/

{
    PLIST_ENTRY   ListEntry;
    PFM_DEPENDTREE_ENTRY Node;

    ListEntry = Tree->ListHead.Flink;
    while (ListEntry != &Tree->ListHead) {
        Node = CONTAINING_RECORD(ListEntry,
                                 FM_DEPENDTREE_ENTRY,
                                 ListEntry);
        if (Node->Resource == Resource) {
            return(TRUE);
        }
        ListEntry = ListEntry->Flink;
    }

    return(FALSE);
}


BOOL
FmpAddResourceToDependencyTree(
    IN PFM_RESOURCE Resource,
    IN PFM_DEPENDENCY_TREE Tree
    )
/*++

Routine Description:

    Recursive worker for adding a resource and all resources that
    it depends on or provides for into the dependency tree.

Arguments:

    Resource - Supplies the resource to add.

    Tree - Supplies the tree the resource should be added to.

Return Value:

    TRUE - Successfully completed

    FALSE - out of memory

--*/

{
    PLIST_ENTRY   ListEntry;
    PDEPENDENCY   Dependency;
    PFM_DEPENDTREE_ENTRY Node;

    //
    // First check to see if we are already in the tree.
    // If so, we are done.
    //
    if (FmpIsResourceInDependencyTree(Resource, Tree)) {
        return(TRUE);
    }


    //
    // Recursively call ourselves for each entry we depend on.
    //
    ListEntry = Resource->DependsOn.Flink;
    while (ListEntry != &Resource->DependsOn) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       DependentLinkage);
        ListEntry = ListEntry->Flink;
        //
        // Recursively add this resource to the tree
        //
        if (!FmpAddResourceToDependencyTree(Dependency->ProviderResource, Tree)) {
            return(FALSE);
        }
    }

    //
    // Add ourselves to the list now if we are not already in it.
    //
    if (!FmpIsResourceInDependencyTree(Resource, Tree)) {
        //
        // Add ourselves to the end of the list.
        //
        Node = LocalAlloc(LMEM_FIXED, sizeof(FM_DEPENDTREE_ENTRY));
        if (Node == NULL) {
            return(FALSE);
        }
        OmReferenceObject(Resource);
        Node->Resource = Resource;
        InsertTailList(&Tree->ListHead, &Node->ListEntry);
    }


    //
    // Now add the resources that this resource provides for to the list.
    //
    ListEntry = Resource->ProvidesFor.Flink;
    while (ListEntry != &Resource->ProvidesFor) {
        Dependency = CONTAINING_RECORD(ListEntry,
                                       DEPENDENCY,
                                       ProviderLinkage);
        ListEntry = ListEntry->Flink;
        //
        // Recursively add this resource to the tree
        //
        if (!FmpAddResourceToDependencyTree(Dependency->DependentResource, Tree)) {
            return(FALSE);
        }
    }
    return(TRUE);
}

VOID
FmDestroyFullDependencyTree(
    IN PFM_DEPENDENCY_TREE Tree
    )
/*++

Routine Description:

    Destroys a dependency tree

Arguments:

    Tree - Supplies the dependency tree

Return Value:

    None

--*/

{
    PFM_DEPENDTREE_ENTRY Entry;
    PLIST_ENTRY   ListEntry;

    while (!IsListEmpty(&Tree->ListHead)) {
        ListEntry = RemoveHeadList(&Tree->ListHead);
        Entry = CONTAINING_RECORD(ListEntry,
                                  FM_DEPENDTREE_ENTRY,
                                  ListEntry);
        OmDereferenceObject(Entry->Resource);
        LocalFree(Entry);
    }
    LocalFree(Tree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\debug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug routines

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#ifndef _DEBUG_H
#define _DEBUG_H

void 
WINAPI 
debug_log(char*format, ...);

void
WINAPI
debug_init();

void
WINAPI
debug_log_file(char *logfile);

extern ULONG debugLevel;

#define GS_DEBUG_ERR	0x1
#define	GS_DEBUG_CM	0x2
#define	GS_DEBUG_MM	0x4
#define	GS_DEBUG_FAIL	0x8

#define	GS_DEBUG_NS	0x10
#define	GS_DEBUG_MSG	0x20
#define	GS_DEBUG_DATA	0x40
#define	GS_DEBUG_STATE	0x80
#define GS_DEBUG_CRS	0x100

#define	gsprint(_x_)	debug_log _x_


#define	print_log(LEVEL, STRING) { \
            if (debugLevel & LEVEL) { \
                gsprint(STRING); \
            } \
}

#define msg_log(_x_)	print_log(GS_DEBUG_MSG, _x_)
#define err_log(_x_)	print_log(GS_DEBUG_ERR, _x_)
#define cm_log(_x_)	print_log(GS_DEBUG_CM, _x_)
#define recovery_log(_x_)	print_log(GS_DEBUG_FAIL, _x_)
#define ns_log(_x_)	print_log(GS_DEBUG_NS, _x_)
#define gs_log(_x_)	print_log(GS_DEBUG_DATA, _x_)
#define state_log(_x_)	print_log(GS_DEBUG_STATE, _x_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Log messages

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "type.h"

gs_lock_t prlock;

ULONG debugLevel = 0xff;

FILE *debugfp = NULL;


void
halt(int status)
{
    char *p = NULL;

    *p = 1;
}

void
WINAPI
debug_log_file(char *logfile)
{
  FILE *fp;

    if (logfile != NULL) {
      fp = fopen(logfile, "w");
      if (fp == NULL) {
	printf("Unable to open log file %s\n", logfile);
      } else {
	debugfp = fp;
      }
    }
}

void
WINAPI
debug_level(ULONG level)
{
    debugLevel = level;
}

void
WINAPI
debug_log(char *format, ...)
{
    static int cnt = 0;
    va_list marker;

    va_start(marker, format);

    GsLockEnter(prlock);


    if (debugfp != NULL) {
	fprintf(debugfp, "%d:%x:",GetTickCount(), GetCurrentThreadId());
	vfprintf(debugfp, format, marker);
	fflush(debugfp);
    } else {
	fprintf(stderr, "%d:%x:",GetTickCount(), GetCurrentThreadId());
	vfprintf(stderr, format, marker);
	fflush(stderr);
    }
#if 0
    cnt++;
    if (cnt > 100000) {
	cnt = 0;
	fseek(debugfp, 0, SEEK_SET);
    }
#endif
    GsLockExit(prlock);

    va_end(marker);
}

void
WINAPI
debug_init()
{
    char	*s = getenv("GsDebugLevel");

    debugfp = stdout;
    GsLockInit(prlock);
    if (s != NULL) {
	debugLevel = atoi(s);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\gs.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gs.c

Abstract:

    Creation and deletion of groups

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include <stdio.h>

extern void ConfigInit();

extern gs_nid_t	GsLocalNodeId;
extern int	GsMaxNodeId;
extern int	GsMinNodeId;

void cm_init();
void cm_start();

gs_group_t	GsGroupTable[GsGroupTableSize];

HANDLE ns_gd;

HANDLE
WINAPI
GsGetGroupHandle(HANDLE msgd)
{
    gs_msg_t *msg = (gs_msg_t *)msgd;

    return (HANDLE) &GsGroupTable[msg->m_hdr.h_gid];
}

int
WINAPI
GsGetSourceMemberid(HANDLE msgd)
{
    gs_msg_t *msg = (gs_msg_t *)msgd;

    return (int) msg->m_hdr.h_sid;
}

void
GspInitGroup(gs_group_t *gd, int wsz);


// Internal routines

gs_group_t *
GspLookupGroup(gs_gid_t gid)
{
    gs_group_t	*gd;

    if (gid >= GsGroupTableSize) {
	return NULL;
    }
    gd = &GsGroupTable[gid];
    assert(gd->g_id == gid);
    if (gd->g_state == GS_GROUP_STATE_FREE ||
	gd->g_state == GS_GROUP_STATE_NEW) {
	return NULL;
    }

    assert(gd->g_state != GS_GROUP_STATE_FREE);
    return gd;
}

gs_group_t *
GspLookupGroupByName(char *name, int len)
{
    gs_group_t	*gd;
    int i;

    for (i = 0; i < GsGroupTableSize; i++) {
	gd = &GsGroupTable[i];
	if (gd->g_state != GS_GROUP_STATE_FREE && 
	    len == gd->g_namelen && !strcmp(gd->g_name, name)) {
	    return gd;
	}
    }

    return NULL;
}

gs_group_t *
GspAllocateGroup(char *name, int len)
{
    int i;

    for (i = 0; i < GsGroupTableSize; i++) {
	gs_group_t	*gd;

	gd = &GsGroupTable[i];
	if (gd->g_state == GS_GROUP_STATE_FREE) {
	    // set everything to zero
	    memset(gd, 0, sizeof(*gd));

	    gd->g_id = i;
	    gd->g_nid = GsLocalNodeId;

	    GsLockInit(gd->g_lock);

	    gd->g_name = name;
	    gd->g_namelen = len;
	    gd->g_state = GS_GROUP_STATE_NEW;

	    return gd;
	}
    }

    return NULL;
}

void
GspDeleteGroup(gs_group_t *gd)
{

    // xxx: grab lock in write mode
    assert(gd->g_state != GS_GROUP_STATE_FREE);

    if (gd->g_name) {
	free(gd->g_name);
    }
    gd->g_name = NULL;
    gd->g_namelen = 0;

    gd->g_mset = 0;
    gd->g_state = GS_GROUP_STATE_FREE;

    if (gd->g_mlist) {
	free((char *) gd->g_mlist);
    }
    if (gd->g_send.s_ctxpool) {
	free((char *) gd->g_send.s_ctxpool);
    }
    // xxx: drop lock
}

void
GspAddMember(gs_group_t *gd, gs_memberid_t mid, int wsz)
{
    gs_member_t *p;

    ns_log(("Add member gid %d sz %d mid %d\n",
	      gd->g_id, gd->g_sz, mid));

    p = (gs_member_t *) malloc(sizeof(gs_member_t) * (gd->g_sz+1));
    if (p == NULL) {
	err_log(("Unable to extend member table\n"));
	exit(1);
    }

    if (gd->g_mlist) {
	memcpy(p, gd->g_mlist, sizeof(gs_member_t) * (gd->g_sz));
	free((char *)gd->g_mlist);
    }
    gd->g_mlist = p;
    gd->g_mset |= (1 << mid);
    p += gd->g_sz;
    gd->g_sz++;
    gd->g_curview++;

    // init member state
    p->m_id = gd->g_sz;
    p->m_expected_seq = 0;
    p->m_wsz = (UINT16) wsz;
    p->m_msz = (UINT16) GS_DEFAULT_MAX_MSG_SZ;

}

void
GspSetMaster(gs_group_t *gd, gs_memberid_t mid)
{
    gd->g_mid = mid;
}

void
GspInitGroup(gs_group_t *gd, int wsz)
{
    int i;

    // init send state

    GsSemaInit(gd->g_send.s_sema, wsz);
    gd->g_send.s_wsz = (UINT16) wsz;

    // allocate window size contexts
    gd->g_send.s_ctxpool = (gs_context_t *) malloc(sizeof(gs_context_t) * wsz);
    if (gd->g_send.s_ctxpool == NULL) {
	assert(0);
    }

    for (i = 0; i < wsz; i++) {
	gs_context_t *p = &gd->g_send.s_ctxpool[i];

	p->ctx_id = GS_CONTEXT_INVALID_ID;
	p->ctx_gid = gd->g_id;
	p->ctx_buf = 0;
	p->ctx_rbuf = 0;
	p->ctx_msg = 0;
	p->ctx_event = 0;
	GsEventInit(p->ctx_syncevent);
    }
    
    // init receive state
    gd->g_recv.r_next = &gd->g_recv.r_head;
}


void
WINAPI
GsInit()
{
    int i;
    void NsForm();
    void NsJoin();

    timeBeginPeriod(50);

    ConfigInit();

    // Initialize global data structure
    for (i = 0; i < GsGroupTableSize; i++) {
	gs_group_t *gd;

	gd = &GsGroupTable[i];
	gd->g_state = GS_GROUP_STATE_FREE;
	gd->g_mset = 0;
    }

    // init and start connection manager
    cm_init();

    NsForm();

    cm_start();

    NsJoin();
}

void
WINAPI
GsExit()
{
    int i;

    // stop messaging
    msg_exit();

    // free context pool and membership list for each group in group table
    for (i = 0; i < GsGroupTableSize; i++) {
	gs_group_t	*gd;

	gd = &GsGroupTable[i];
	GspDeleteGroup(gd);
    }

    timeEndPeriod(50);
}

#define NS_TABLE_READ	0
#define	NS_TABLE_ADD	1

HANDLE
WINAPI
GsCreateGroup(gs_callback_t func, char *name, int len, int wsz,
    int disposition, HANDLE *join_ctx)

{
    gs_group_t	*gd;
    PVOID	io[GS_MAX_GROUP_SZ];
    int		result[GS_MAX_GROUP_SZ];
    int		i;
    NTSTATUS	err;
    IO_STATUS_BLOCK status[GS_MAX_GROUP_SZ];
    gs_ns_info_t info;
    int GspJoin(HANDLE group, gs_event_t event, PVOID io[], IO_STATUS_BLOCK status[],
		 int wsz, HANDLE *context);
    gs_event_t event;
    union {
	int	cmd;
	gs_tag_t	tag;
    }tag;

    if (name == NULL || len > GS_MAX_NAME_SZ) {
	return NULL;
    }

    ns_log(("Create group %s\n", name));

    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	status[i].Information = 0;	
	io[i] = (PVOID)&result[i];
	result[i] = TRUE;
    }

    // Based on disposition we either form or join
    info.owner = (USHORT) ((gs_group_t *)ns_gd)->g_nid;
    info.wsz = (UINT16) wsz;
    strcpy(info.name, name);
    GsEventInit(event);

 retry:
    tag.cmd = NS_TABLE_ADD;
    err = GsSendDeliveredRequest(ns_gd, event,
				 tag.tag, (PVOID) &info, sizeof(info),
				 io, sizeof(result[0]), 
				 status,
				 NULL);

    if (err != ERROR_SUCCESS) {
	GsEventFree(event);
	err_log(("Create group failed %d\n", err));
	return NULL;
    }
    // xxx: make sure result is true
    gd = GspLookupGroupByName(name, len);
    if (gd != NULL) {
	int err;

	ns_log(("Init group %x\n", gd));
	GspInitGroup(gd, wsz);
	GsRegisterHandler((HANDLE)gd, func);
	err = GspJoin((HANDLE) gd, event, io, status, wsz, join_ctx);
	if (err) {
	    ns_log(("Init group gspjoin failed, need to retry\n"));
	    goto retry;
	}
    }
    ns_log(("Created group %x\n", gd));
    GsEventFree(event);
    return (HANDLE) gd;
}

NTSTATUS
GsCloseGroup(HANDLE group)
{
    gs_group_t	*gd = (gs_group_t *)group;

    GspDeleteGroup(gd);
    return ERROR_SUCCESS;
}

void
GsRegisterHandler(HANDLE group, gs_callback_t func)
{
    gs_group_t *gd = (gs_group_t *) group;

    gd->g_callback = func;
}

NTSTATUS
GsQueryGroup(HANDLE group, gs_info_t *info)
{
    gs_group_t *gd;
    
    if (group == NULL) {
	group = ns_gd;
    }

    gd = (gs_group_t *) group;
    if (!gd || !info) {
	return ERROR_INVALID_PARAMETER;
    }
    
    info->lid = gd->g_nid;
    info->mid = gd->g_mid;
    info->group_size = gd->g_sz;
    info->cluster_size = msg_getsize();
    info->mset = gd->g_mset;

    return ERROR_SUCCESS;
}


// Name server

NTSTATUS
ns_callback(HANDLE group, gs_tag_t mtag, PVOID buf, IO_STATUS_BLOCK *ios)
{

    gs_ns_info_t table[GS_MAX_GROUPS];
    int i, j, result;
    gs_group_t *gd = (gs_group_t *) group;
    NTSTATUS err;
    gs_ns_info_t *info;
    int tag = *((int *)mtag);

    switch(ios->Status) {
    case GsEventData:
	ns_log(("NsCallback Disposition %d\n", tag));
	switch(tag) {
	case NS_TABLE_READ:

	    // only group table master reponse to reads
	    if (GsGroupTable[0].g_mid == GsGroupTable[0].g_nid) {
		j = 0;
		for (i = 1; i < GsGroupTableSize; i++) {
		    gd = &GsGroupTable[i];
		    if (gd->g_state != GS_GROUP_STATE_FREE) {
			table[j].owner = gd->g_mid;
			table[j].id = (USHORT) i;
			strcpy(table[j].name, gd->g_name);
			j++;
		    }
		}

		ns_log(("Sending table size %d\n", j));
		err = GsSendReply(group, (PVOID) table, sizeof(table[0]) * j, STATUS_SUCCESS);
		if (err != ERROR_SUCCESS) {
		    printf("Failed to respond to table read ns\n");
		}
	    }

	    break;

	case NS_TABLE_ADD:

	    info = (gs_ns_info_t *)buf;
	    assert(ios->Information == sizeof(*info));
	    // xxx: lock table
	    gd = GspLookupGroupByName(info->name, strlen(info->name));
	    if (gd == NULL) {
		char * strsave(char *s);

		gd = GspAllocateGroup(strsave(info->name), strlen(info->name)); 

		if (gd != NULL) {
		    GspSetMaster(gd, info->owner);
		}
		ns_log(("Ns Created group %s id %d owner %d\n",
			  info->name, gd->g_id, gd->g_mid));
	    }
	    // xxx: unlock table
	    if (gd != NULL) {
		result = TRUE;
	    } else {
		result = FALSE;
	    }
	    err = GsSendReply(group, (PVOID) &result, sizeof(result), STATUS_SUCCESS);
	    if (err != ERROR_SUCCESS) {
		err_log(("Failed to respond to add ns\n"));
	    }
	    break;

	default:
	    err_log(("Invalid ns opcode, %d\n", tag));
	    exit(1);
	}
	break;

    case GsEventMemberJoin:
	ns_log(("NsCallback member join %d\n", tag));
	break;
    case GsEventMemberUp:
	ns_log(("NsCallback member up %d\n",  tag));
	break;
    case GsEventMemberDown:
	ns_log(("NsCallback member down %d\n",  tag));
	break;
    default:
	ns_log(("Ns invalid event %d\n",  ios->Status));
    }

    return ERROR_SUCCESS;
}



void
NsForm()
{
    char *name = "Name server";

    ns_gd = (HANDLE) GspAllocateGroup(name, strlen(name));
    if (ns_gd == NULL) {
	err_log(("Unable to create name server group!\n"));
	exit(1);
    }
    GspInitGroup((gs_group_t *)ns_gd, 1);
    GsRegisterHandler(ns_gd, ns_callback);
}

void
NsSetOwner(gs_nid_t nid)
{
    gs_group_t *gd = (gs_group_t *) ns_gd;

    ns_log(("Name server: master %d\n", nid));

    GsLockEnter(gd->g_lock);

    GspSetMaster(gd, (gs_memberid_t)nid);
    if (gd->g_rs != NULL && gd->g_mid != gd->g_nid) {
	gd->g_rs->rs_mset = (1 << gd->g_nid) | (1 << gd->g_mid);
    }

    GsLockExit(gd->g_lock);
}

int
GspJoin(HANDLE group, gs_event_t event, PVOID io[], IO_STATUS_BLOCK status[],
	int wsz, HANDLE *context)
{

    // if we don't master the name server, we simply send a
    // join request to this group and receive a table of
    // group names and owners
    gs_join_info_t	info;
    int table[GS_MAX_GROUP_SZ];
    gs_group_t *gd = (gs_group_t *) group;
    gs_context_t	*ctx;
    gs_memberid_t	mid;
    union {
	int	mid;
	gs_tag_t	tag;
    }tag;

    if (context) *context = NULL;

    while (TRUE) {
	int err, i;
	UINT32 sz, flags;
	gs_msg_hdr_t hdr;

	GsLockEnter(gd->g_lock);
	ns_log(("join group %s mid %d\n", gd->g_name, gd->g_mid));
	if ((mid = gd->g_mid) == gd->g_nid) {
	    gs_msg_t msg;

	    memset(&msg, 0, sizeof(msg));
	    msg.m_hdr.h_type = GS_MSG_TYPE_UP;
	    msg.m_buf = (char *) &wsz;
	    *((gs_memberid_t *)msg.m_hdr.h_tag) = mid;
	    msg.m_hdr.h_len = sizeof(wsz);
	    msg.m_hdr.h_flags = GS_FLAGS_REPLY;
	    msg.m_hdr.h_gid = gd->g_id;
	    GspDeliverMsg(gd, &msg);
	    gd->g_state = GS_GROUP_STATE_FORM;
	    GsLockExit(gd->g_lock);
	    break;
	}

	gd->g_state = GS_GROUP_STATE_JOIN;

	GsLockExit(gd->g_lock);

	GspOpenContext(gd, &ctx);

	io[0] = (PVOID) &info;
	status[0].Information = 0;
	tag.mid = gd->g_nid,
	err = GspSendDirectedRequest(gd, ctx, event, mid,
				     tag.tag, NULL, 0, 
				     &io[0], sizeof(info),
				     &status[0],
				     GS_FLAGS_DELIVERED, 
				     GS_MSG_TYPE_JOIN_REQUEST);


	GsLockEnter(gd->g_lock);
	if (gd->g_mid != mid) {
	    GsLockExit(gd->g_lock);
	    GspCloseContext(gd, ctx);
	    continue;
	}

	if (err != ERROR_SUCCESS) {
	    err_log(("Join failed %d\n", err));
	    return 1;
	}
	
	if (status[0].Information != sizeof(info)) {
	    err_log(("GspJoin: invalid returned size %d\n",
		     status[0].Information));
	    halt(1);
	}

	ns_log(("GspJoin: group %s mastered by %d curset %x\n",
		  gd->g_name, mid, info.mset));

	ns_log(("GspJoin: Mseq %d Curview %d Gsz %d mset %x\n",
	       info.mseq, info.viewnum, info.sz, info.mset));

	// init some state
	gd->g_curview = info.viewnum;
	gd->g_startview = info.viewnum;
	gd->g_mset = info.mset;
	gd->g_recv.r_mseq = info.mseq;
	gd->g_recv.r_bnum = 1; // set starting point
	gd->g_send.s_lseq = info.mseq;
	gd->g_sz = info.sz;

	GsLockExit(gd->g_lock);
	sz = sizeof(table);
	for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	    status[i].Information = 0;
	    io[i] = (PVOID) &table[i];
	    table[i] = TRUE;
	}
	tag.mid = gd->g_nid;
	err = GspSendRequest(gd, ctx, event, GS_MSG_TYPE_JOIN, mid,
			     tag.tag,
			     (PVOID)&wsz, sizeof(wsz), 
			     io, sizeof(table[0]),
			     status,
			     GS_FLAGS_DELIVERED | GS_FLAGS_CONTINUED | GS_FLAGS_LAST,
			     &info);

	if (err != ERROR_SUCCESS) {
	    err_log(("Join failed %d\n", err));
	    halt(1);
	}
	{
	    int i;

	    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
		if (table[i] != TRUE) {
		    err_log(("GsJoin: Failed was rejected by member %d\n", i));
		    halt(1);
		}
	    }
	}

	if (context == NULL) {
	    flags = GS_FLAGS_DELIVERED | GS_FLAGS_CLOSE | GS_FLAGS_LAST;
	} else {
	    flags = GS_FLAGS_DELIVERED | GS_FLAGS_CONTINUED | GS_FLAGS_LAST;
	}

	// add ourself to membership set
	info.sz++;
	info.mset |= (1 << gd->g_nid);
	sz = 0;
	tag.mid = gd->g_nid;
	err = GspSendRequest(gd, ctx, event, GS_MSG_TYPE_UP, mid, 
			     tag.tag,
			     (PVOID) &wsz, sizeof(wsz), NULL, 0, status, flags, &info);


	// advance our startview
	gd->g_startview++;
	gd->g_state = GS_GROUP_STATE_FORM;

	if (context != NULL) {
	    *context = (HANDLE) ctx;
	} else {
	    GspCloseContext(gd, ctx);
	}
	return 0;
    }

    return 0;
}


void
NsJoin()

{
    HANDLE ctx;
    gs_ns_info_t	table[GS_MAX_GROUPS];
    UINT32 i, sz;
    PVOID io[GS_MAX_GROUP_SZ];
    IO_STATUS_BLOCK status[GS_MAX_GROUP_SZ];
    NTSTATUS err;
    gs_event_t event;
    union {
	int	cmd;
	gs_tag_t	tag;
    }tag;

    GsEventInit(event);

    GspJoin(ns_gd, event, io, status, 1, &ctx);
    if (ctx == NULL) {
	GsEventFree(event);
	return;
    }

    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	status[i].Information = 0;
	io[i] = (PVOID)table;
    }
    tag.cmd = NS_TABLE_READ;
    err = GsSendContinuedRequest(ctx, event, 
				 tag.tag, NULL, 0, 
				 io, sizeof(table),
				 status,
				 TRUE);

    if (err != ERROR_SUCCESS) {
	err_log(("Table read failed %x\n", err));
	halt(1);
    }

    sz = 0;
    for (i = 0; i < GS_MAX_GROUP_SZ; i++) {
	if (status[i].Information != 0) {
	    sz = ((UINT32)status[i].Information) / sizeof(table[0]);
	    break;
	}
    }
    assert(i != GS_MAX_GROUP_SZ);
    ns_log(("NsJoin: Got table %x from master %d sz %d\n", table, i,
	    status[i].Information));

    for (i = 0; i < sz; i++) {
	gs_group_t *gd;
		
	ns_log(("NsJoin: Table%d: %s owner %d\n",
		  table[i].id,
		  table[i].name, table[i].owner));

	gd = GspLookupGroupByName(table[i].name, strlen(table[i].name));
	if (gd == NULL) {
	    gd = GspAllocateGroup(strsave(table[i].name), strlen(table[i].name));
	    if (gd == NULL) {
		err_log(("unable to alloc group %s, exiting..\n",
			  table[i].name));
		halt(1);
	    }
	    GspSetMaster(gd, table[i].owner);
	} else {
	    err_log(("found group %s already, exiting..\n", table[i].name));
	    halt(1);
	}
    }

    GsEventFree(event);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\gsp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gsp.h

Abstract:

    Private gs definitions

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#ifndef _GS_P_H
#define _GS_P_H

#include "type.h"
#include "msg.h"

#include <Mmsystem.h>

#define	GS_DEFAULT_WINDOW_SZ		8
#define	GS_DEFAULT_MAX_MSG_SZ		GS_MAX_MSG_SZ

extern int GS_MAX_MSG_SZ;

#define	GsGroupTableSize		16

#define GS_FLAGS_CLOSE		0x01
#define GS_FLAGS_CONTINUED	0x02
#define GS_FLAGS_DELIVERED	0x04
#define GS_FLAGS_QUEUED		0x08	// in receive queue

#define GS_FLAGS_LAST		0x10
#define GS_FLAGS_REPLAY		0x20
#define GS_FLAGS_REPLY		0x40
#define GS_FLAGS_PTP		0x80
#define	GS_FLAGS_MASK		0x07

#define	GS_GROUP_STATE_FREE	0x0
#define	GS_GROUP_STATE_NEW	0x01
#define	GS_GROUP_STATE_FORM	0x02
#define	GS_GROUP_STATE_JOIN	0x04
#define	GS_GROUP_STATE_EVICT	0x08

#define	GS_GROUP_FLAGS_RECOVERY	0x10
#define	GS_GROUP_FLAGS_NEWMASTER 0x20

#define	GS_CONTEXT_INVALID_ID	((gs_cookie_t) -1)

typedef struct gs_member {
    gs_memberid_t 	m_id;
    gs_sequence_t	m_expected_seq;	// next expected 1-to-1 sequence
    gs_msg_t		*m_queue;	// list of queued 1-to-1 msgs
//    gs_addr_t		m_uaddr;	// ip addr
    UINT16		m_wsz;		// max. window sz
    UINT16		m_msz;		// max. msg sz
}gs_member_t;

typedef struct gs_ctx {
    gs_gid_t		ctx_gid;
    gs_cookie_t		ctx_id;
    PVOID		ctx_buf;
    gs_sequence_t	ctx_mseq;
    gs_sequence_t	ctx_bnum;
    UINT16		ctx_flags;
    gs_msg_t		*ctx_msg;
    PVOID		*ctx_rbuf;
    IO_STATUS_BLOCK	*ctx_ios;
    ULONG		ctx_mask;
    gs_event_t		ctx_syncevent;
    gs_event_t		ctx_event;
    MMRESULT		ctx_timer;
}gs_context_t;

typedef struct {
    gs_semaphore_t	s_sema;		// how many concurrent sends are allowed
    gs_context_t	*s_ctxpool;	// send contexts pool
    UINT16		s_wsz;		// max. window sz
    gs_msg_t		*s_waitqueue;	// list of msgs waiting for global sequence
    gs_sequence_t	s_lseq;	// last completed mseq
    gs_sequence_t	s_mseq;	// last allocated global sequence
    gs_sequence_t	s_bnum;	// next 1-to-1 sequence for a given mseq
}gs_send_state_t;

typedef struct {
    gs_sequence_t	r_mseq;		// next expected global sequence
    gs_sequence_t	r_bnum; 	// next expected batch sequence

    gs_msg_t		**r_next;	// next message to deliver to app
    gs_msg_t		*r_head;	// head of receive queue
}gs_recv_state_t;    

typedef struct gs_rblk {
    struct gs_rblk	*next;
    gs_sequence_t	mseq;
    ULONG		have;
}gs_rblk_t;

typedef struct {
    gs_event_t		rs_event;
    ULONG		rs_dset;	// down member set
    ULONG		rs_mset;	// member set to hear from
    UINT16		rs_epoch;
    UINT16		rs_sz;
    gs_rblk_t		*rs_list;
}gs_recovery_state_t;

typedef struct gs_group {
    gs_lock_t	g_lock;

    gs_gid_t	g_id;	// cluster wide group id
    gs_nid_t	g_nid;	// local cluster node id

//    int	g_port;	// group port number
//    gs_addr_t	g_maddr;	// multicast ip addr

    UINT8	g_state;
    UINT8	g_pending;

    UINT16	g_curview;	// increment on every member down/up
    UINT16	g_startview;	// set to curview on member down

    // member information
    UINT16	g_sz;
    gs_member_t *g_mlist;
    gs_memberid_t g_mid;	// master id
    gs_mset_t	g_mset;		// current member set
    
    // master/send/receive states
    gs_sequence_t	g_global_seq;	// next global sequence number

    gs_send_state_t		g_send;
    gs_recv_state_t		g_recv;

    // event handler
    gs_callback_t		g_callback;

    // recovery state
    gs_recovery_state_t		*g_rs;

    int		g_namelen;
    char	*g_name;
}gs_group_t;

#define GspLookupContext(gd, cid)	&gd->g_send.s_ctxpool[cid]

gs_group_t *
GspLookupGroup(gs_gid_t gid);

void
GspProcessReply(gs_group_t *gd, gs_context_t *ctx, 
		int sid, char *buf, int rlen,
		NTSTATUS status);

void
GspDispatch(gs_group_t *gd);

void
GspOpenContext(gs_group_t *gd, gs_context_t **context);

void
GspCloseContext(gs_group_t *gd, gs_context_t *ctx);

void
GspOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t bnum);

void
GspUOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t lseq);

void
GspDeliverMsg(gs_group_t *gd, gs_msg_t *msg);

void
GspSendAck(gs_group_t *gd, gs_msg_t *msg, NTSTATUS status);

void
GspRemoveMsg(gs_group_t *gd, gs_msg_t *msg);

NTSTATUS
GspSendDirectedRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t ev,
		       int memberid, gs_tag_t tag,
		       PVOID buf, UINT32 len, 
		       PVOID rbuf, UINT32 rlen, 
		       IO_STATUS_BLOCK *status,
		       UINT32 flags, UINT32 type);

// Response of name server during phase 1 of join
typedef struct {
    union {
	USHORT	id;
	USHORT	wsz;
    };
    USHORT	owner;
    char	name[GS_MAX_NAME_SZ];
}gs_ns_info_t;

// Response of current master to a join request
typedef struct {
    UINT16		sz;
    UINT16		viewnum;
    gs_sequence_t	mseq;
    gs_mset_t		mset;	// current member set
}gs_join_info_t;

// Response of current master to a sequence allocation request
typedef struct {
    gs_sequence_t	mseq;
    UINT16		viewnum;
}gs_seq_info_t;

typedef struct {
    gs_sequence_t	cur_mseq, last_mseq;
    UINT16		have_sz;
    gs_sequence_t	have_set[];
}gs_recovery_info_t;

typedef struct {
    gs_sequence_t	down_mseq;
    UINT16		view;
    UINT16		sz;
    struct {
	gs_sequence_t	mseq;
    }skip_set[];
}gs_sync_info_t;

#ifndef min
#define min(a, b)	((a) < (b) ? (a) : (b))
#endif

#define GspValidateView(gd, vn)	((vn) >= (gd)->g_startview && (vn) <= (gd)->g_curview)

NTSTATUS
GspSendRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t ev,
	       int type, gs_sequence_t mid, gs_tag_t tag,
	       PVOID buf, UINT32 len, 
	       PVOID rbuf[], UINT32 rlen,
	       IO_STATUS_BLOCK status[],
	       UINT32 flags, gs_join_info_t *);

void
GspProcessWaitQueue(gs_group_t *gd, gs_seq_info_t *);

void
GspAllocateSequence(gs_group_t *gd);

void
GspCleanQueue(gs_group_t *gd, gs_sequence_t mseq);

void
GspAddMember(gs_group_t *, gs_memberid_t, int);

void
GspPhase1NodeDown(ULONG mask);

void
GspPhase2NodeDown(ULONG mask);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\msg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msg.h

Abstract:

    msg definition

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/


#ifndef GS_MSG_H
#define GS_MSG_H

#include "type.h"

#define	GS_MSG_TYPE_SEQALLOC	0
#define	GS_MSG_TYPE_SEQREPLY	1
#define	GS_MSG_TYPE_MCAST	2
#define	GS_MSG_TYPE_REPLY	3
#define	GS_MSG_TYPE_UCAST	4
#define	GS_MSG_TYPE_ACK		5

#define	GS_MSG_TYPE_INFO	6
#define	GS_MSG_TYPE_MM		7
	
#define	GS_MSG_TYPE_JOIN_REQUEST	8
#define	GS_MSG_TYPE_JOIN	9
#define	GS_MSG_TYPE_UP		10
#define	GS_MSG_TYPE_EVICT_REQUEST	11
#define	GS_MSG_TYPE_EVICT	12

#define	GS_MSG_TYPE_RECOVERY	13
#define	GS_MSG_TYPE_SYNC	14

#define	GS_MSG_TYPE_ABORT      	244
#define	GS_MSG_TYPE_SKIP	255

#define GS_MSG_STATE_FREE	0
#define GS_MSG_STATE_NEW	1
#define GS_MSG_STATE_READY	2
#define GS_MSG_STATE_DELIVERED	3
#define GS_MSG_STATE_DONE	4


typedef struct gs_msg_hdr {
    UINT16	h_len;		// payload size
    UINT16	h_type;		// msg type
    UINT16	h_flags;	// msg flags
    UINT16	h_viewnum;	// generation number, drop this msg if no match
    UINT16	h_rlen;		// for delivered msgs, how big can sender accept reply
    gs_cookie_t		h_cid;	// sender cookie for reply packets
    gs_gid_t		h_gid;	// group id
    gs_sequence_t	h_mseq;	// global sequence
    gs_sequence_t	h_bnum;	// this msg batch number
    gs_sequence_t	h_lseq;	// sender sequence number
    gs_memberid_t	h_mid;	// master member id
    gs_memberid_t	h_sid;	// sender member id
    char		h_tag[64];
}gs_msg_hdr_t;
    
#define MSG_TYPE_HDR	1
#define	MSG_TYPE_DATA	2

typedef struct gs_msg {
    struct gs_msg	*m_next;	// next msg in queue
    UINT8		m_type;		// type
    UINT8		m_refcnt;	// refcnt
    UINT16		m_buflen;	// length of buffer
    gs_msg_hdr_t	m_hdr;		// msg header
    char		*m_buf;
}gs_msg_t;

int
WINAPI
msg_addnode(int id, char *n, char *a);

gs_msg_t * msg_alloc(const char *buf, int len);

int msg_send(gs_memberid_t, gs_msg_hdr_t *, const char *, int);

void msg_mcast(ULONG, gs_msg_hdr_t *, const char *, int);

void msg_smcast(ULONG, gs_msg_hdr_t *, const char *, int);

void msg_free(gs_msg_t *);

int msg_init();

void msg_exit();

int msg_getsize();

typedef void(*gs_msg_handler_t)(gs_msg_t *);

typedef enum {
    MSG_NODE_ID,
    MSG_NODE_JOIN,
    MSG_NODE_UP,
    MSG_NODE_DOWN
}gs_node_event_t;

typedef void(*gs_node_handler_t)(int);

void
msg_set_uport(int uport);


void
msg_set_mport(int mport);


void
msg_set_uipaddr(char *addr);


void
msg_set_mipaddr(char *addr);


void
msg_set_bufcount(int count);

void
msg_set_bufsize(int size);

void
msg_start(ULONG mask);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\quorm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    quorum.c

Abstract:

    Implements quorum for cm, uses UNC file for now

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
//#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>


// Quorum stuff
static HANDLE DlmQhd = 0;
static char *default_qfile="\\DosDevices\\UNC\\ahmedm\\tmp\\gs.qrm";

extern char *WINAPI config_get_qfile();

BOOLEAN
QuormAcquire()
{
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;
    WCHAR	buf[128];
    int		n;
    char    *qfile;

    if (DlmQhd)
	return TRUE;

    qfile = config_get_qfile();
    if (!qfile) {
        qfile = default_qfile;
    }
    // no-quorum is specified
    if (qfile[0] == '\0')
	return TRUE;

    // convert to unicode
    n = MultiByteToWideChar(CP_ACP, 0, qfile, strlen(qfile), buf, sizeof(buf));
    buf[n] = buf[n+1] = '\0';
    RtlInitUnicodeString(&cwspath, buf);

    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);

    status = NtCreateFile(&DlmQhd,
			  SYNCHRONIZE | DELETE,
			  &objattrs,
			  &iostatus,
			  0,
			  FILE_ATTRIBUTE_NORMAL,
			  0,
			  FILE_CREATE,
			  FILE_DELETE_ON_CLOSE |  FILE_NON_DIRECTORY_FILE,
			  NULL,
			  0);

    if (status != STATUS_SUCCESS) {
	if (status != STATUS_OBJECT_NAME_COLLISION) {
	    printf("Quorm '%s' failed %x\n", qfile, status);
	}
        return FALSE;
    }

    return TRUE;
}

void
QuormInit()
{
    DlmQhd = 0;
}

void
QuormRelease()
{
    if (DlmQhd) {
	NtClose(DlmQhd);
	DlmQhd = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\gs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gs.h

Abstract:

    Public gs definitions

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/


#ifndef	_GS_H
#define	_GS_H

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <assert.h>

#define	GS_MAX_GROUPS		64
#define	GS_MAX_GROUP_SZ		8
#define	GS_MAX_NAME_SZ		28

typedef enum {
    GsEventData,
    GsEventSingleData,
    GsEventMemberJoin,
    GsEventMemberUp,
    GsEventMemberDown,
    GsEventMemberEvicted,
    GsEventAbort,
    GsEventInvalid
}gs_eventid_t;

typedef struct {
    int	lid;
    int mid;
    int	group_size;
    int cluster_size;
    UINT32 mset;
}gs_info_t;

typedef  char    gs_tag_t[64];

typedef NTSTATUS (WINAPI *gs_callback_t)(HANDLE cookie, gs_tag_t tag, PVOID buf, 
				  IO_STATUS_BLOCK *ios);

char *
WINAPI
config_get_volume();

char *
WINAPI
config_get_crsfile();

int
WINAPI
config_get_crssz();

void
WINAPI
GsInit();

void
WINAPI
GsExit();

NTSTATUS
WINAPI
GsSendDeliveredRequest(HANDLE group, HANDLE event OPTIONAL,
		       gs_tag_t tag, PVOID buf, UINT32 len,
		       PVOID rbuf[], UINT32 elmsz,
		       IO_STATUS_BLOCK iostatus[],
		       HANDLE *context);

NTSTATUS
WINAPI
GsSendContinuedRequest(HANDLE context, HANDLE event OPTIONAL,
		       gs_tag_t tag, PVOID bruf, UINT32 len,
		       PVOID rbuf[], UINT32 elmsz,
		       IO_STATUS_BLOCK iostatus[],
		       BOOLEAN close);

NTSTATUS
WINAPI
GsSendQueuedRequest(HANDLE group, HANDLE event OPTIONAL,
		    gs_tag_t tag, PVOID buf, UINT32 len,
		    PVOID rbuf[], UINT32 elmsz,
		    IO_STATUS_BLOCK iostatus[]);

NTSTATUS		    
WINAPI
GsSendDirectedRequest(HANDLE group, HANDLE event OPTIONAL,
		      int memberid,
		      gs_tag_t tag, PVOID buf, UINT32 len,
		      PVOID rbuf, UINT32 elmsz,
		      IO_STATUS_BLOCK *iostatus,
		      HANDLE *context);

NTSTATUS
WINAPI
GsSendReply(HANDLE gd, PVOID buf, int len, NTSTATUS status);

NTSTATUS
WINAPI
GsReceiveRequest(HANDLE gd, PVOID buf, int len);

void
WINAPI
GsRegisterHandler(HANDLE gd, gs_callback_t func);

HANDLE
WINAPI
GsCreateGroup(gs_callback_t func, char *name, int len, int windowsz,
     int disposition, HANDLE *ctx);

NTSTATUS
WINAPI
GsEvictMember(HANDLE gd, int memberid);

NTSTATUS
WINAPI
GsQueryGroup(HANDLE gd, gs_info_t *info);

NTSTATUS
WINAPI
GsCloseGroup(HANDLE gd);


HANDLE
WINAPI
GsGetGroupHandle(HANDLE msgd);

int
WINAPI
GsGetSourceMemberid(HANDLE msgd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\receive.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    Receive handler and sends reply packets

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/
#include "gs.h"
#include "gsp.h"
#include <stdio.h>
#include <assert.h>

void
GspDumpQueue(gs_group_t *gd)
{

	gs_msg_t *q;
	int i = 0;

	for (q = gd->g_recv.r_head; q != NULL; q = q->m_next) {
	    state_log(("Msg %x: nid %d gid %d type %d mseq %d bnum %d flags %x cnt %d\n",
		      q, q->m_hdr.h_sid, q->m_hdr.h_gid, q->m_hdr.h_type,
		      q->m_hdr.h_mseq, q->m_hdr.h_bnum, q->m_hdr.h_flags, q->m_refcnt));
	    
	    i++;
	    if (i > 100) {
		err_log(("Infinite loop\n"));
		halt(1);
	    }
	}
	state_log(("Head %x Next %x expecting <%d, %d.\n",
		  gd->g_recv.r_head,
		  gd->g_recv.r_next,
		  gd->g_recv.r_mseq,
		  gd->g_recv.r_bnum));


}

void
GspRemoveMsg(gs_group_t *gd, gs_msg_t *msg)
{

    gs_msg_t **p;
    gs_msg_t *q;

    gs_log(("Remove gid %d seq %d msg %x\n", gd->g_id,
	      msg->m_hdr.h_mseq, msg));

    GspDumpQueue(gd);

    if (msg->m_hdr.h_flags & GS_FLAGS_QUEUED) {
	while ((q = gd->g_recv.r_head) != msg) {
	    if (q == NULL) {
		err_log(("Internal error: null head during remove %x\n", msg));
		GspDumpQueue(gd);
		halt(1);
		break;
	    }
	    q->m_hdr.h_flags &= ~GS_FLAGS_QUEUED;
	    gd->g_recv.r_head = q->m_next;
	    msg_free(q);
	}
	// delay the freeing of continued messages to simplify recovery
	if (!(msg->m_hdr.h_flags & GS_FLAGS_CONTINUED)) {
	    msg->m_refcnt--;
	    msg->m_hdr.h_flags &= ~GS_FLAGS_QUEUED;
	    gd->g_recv.r_head = msg->m_next;
	    if (&msg->m_next == gd->g_recv.r_next)
		gd->g_recv.r_next = &gd->g_recv.r_head;
	}
    }

    msg_free(msg);

    GspDumpQueue(gd);
}

void
GspCleanQueue(gs_group_t *gd, gs_sequence_t mseq)
{
    gs_msg_t *q, *msg;

    gs_log(("Clean gid %d seq %d\n",  gd->g_id, mseq));

    GspDumpQueue(gd);

    while ((q = gd->g_recv.r_head) != NULL && q->m_hdr.h_mseq < mseq) {
	if (&q->m_next == gd->g_recv.r_next) {
	    gd->g_recv.r_next = &gd->g_recv.r_head;
	}
	q->m_hdr.h_flags &= ~GS_FLAGS_QUEUED;
	gd->g_recv.r_head = q->m_next;
	msg_free(q);
    }

    GspDumpQueue(gd);
}

void
GspUOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t bnum)
{
    gs_msg_t **p;

    // insert msg into proper order in receive queue
    // this routine needs to check for duplicates

    gs_log(("Add ucast gid %d mseq %d,%d head %x tail %x @ next %x\n", 
	      gd->g_id, mseq, bnum,
	      head, tail, gd->g_recv.r_next));

    p = gd->g_recv.r_next;
    while (*p) {
	if ((*p)->m_hdr.h_mseq > mseq) {
	    tail->m_next = *p;
	    *p = head;
	    return;
	}

	p = &(*p)->m_next;
    }

    // add at tail of history queue
    tail->m_next = *p;
    *p = head;

    GspDumpQueue(gd);
}

void
GspOrderInsert(gs_group_t *gd, gs_msg_t *head, gs_msg_t *tail,
	       gs_sequence_t mseq, gs_sequence_t bnum)
{
    gs_msg_t **p;

    // check if we have already processed this sequence
    if (mseq < gd->g_recv.r_mseq || (mseq == gd->g_recv.r_mseq && 
	bnum < gd->g_recv.r_bnum)) {
	gs_log(("Droping msg %d,%d @ %d,%d\n", mseq, bnum, 
		gd->g_recv.r_mseq, gd->g_recv.r_bnum));
	msg_free(head);
	return;
    }

    if (head->m_hdr.h_flags & GS_FLAGS_REPLAY) {
	p = &gd->g_recv.r_head;
	while (p != gd->g_recv.r_next && *p != NULL) {
	    if ((*p)->m_hdr.h_mseq == mseq && (*p)->m_hdr.h_bnum == bnum) {
		gs_log(("duplicate pending type %d mseq %d bnum %d\n", 
			head->m_hdr.h_type, mseq, bnum));
		msg_free(head);
		return;
	    }
	}
    }

    // insert msg into proper order in receive queue
    // this routine needs to check for duplicates

    gs_log(("Add gid %d mseq %d,%d head %x tail %x @ next %x\n", 
	      gd->g_id, mseq, bnum,
	      head, tail, gd->g_recv.r_next));

    p = gd->g_recv.r_next;
    while (*p) {
	if ((*p)->m_hdr.h_mseq > mseq ||
	    ((*p)->m_hdr.h_mseq == mseq && (*p)->m_hdr.h_bnum > bnum)) {
	    tail->m_next = *p;
	    *p = head;
	    return;
	} else if ((*p)->m_hdr.h_mseq == mseq && (*p)->m_hdr.h_bnum == bnum) {
	    assert(head->m_hdr.h_flags & GS_FLAGS_REPLAY);
	    assert(head == tail);
	    gs_log(("duplicate type %d mseq %d bnum %d\n", head->m_hdr.h_type,mseq, bnum));
	    msg_free(head);
	    return;
	}

	p = &(*p)->m_next;
    }

    // add at tail of history queue
    tail->m_next = *p;
    *p = head;

    GspDumpQueue(gd);
}

void
GspReplyMsgHandler(gs_msg_t *msg)
{   
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    gs_context_t *ctx;

    hdr = &msg->m_hdr;

   // find group using group internal identifier
    gd = GspLookupGroup(hdr->h_gid);

    GsLockEnter(gd->g_lock);
   // find context in waiting queue
   ctx = GspLookupContext(gd, hdr->h_cid);
   assert(ctx != NULL);
   if (ctx->ctx_msg == NULL) {
       err_log(("Internal error gid %d ctx %d mseq %d bnum %d flags %x mask %x\n",
		ctx->ctx_gid, ctx->ctx_id, ctx->ctx_mseq, ctx->ctx_bnum,
		ctx->ctx_flags, ctx->ctx_mask));
       err_log(("Internal error msg sid %d mid %d gid %d ctx %d mseq %d bnum %d flags %x\n",
		hdr->h_sid, hdr->h_mid,
		hdr->h_gid, hdr->h_cid, hdr->h_mseq, hdr->h_bnum, hdr->h_flags));
       halt(1);
   }
   assert(ctx->ctx_msg != NULL);
   if (ctx->ctx_msg->m_hdr.h_mseq != hdr->h_mseq) {
       err_log(("Internal error ctx %d %d reply %d mismatch %d\n", 
		ctx->ctx_id, hdr->h_cid,
		hdr->h_mseq,
		ctx->ctx_msg->m_hdr.h_mseq));
       halt(1);
   }
   GspProcessReply(gd, ctx, msg->m_hdr.h_sid, msg->m_buf, msg->m_hdr.h_len,
		   *((NTSTATUS *)msg->m_hdr.h_tag));

   GsLockExit(gd->g_lock);

   msg_free(msg);
}

void
GspSendAck(gs_group_t *gd, gs_msg_t *msg, NTSTATUS status)
{
    gs_msg_hdr_t *hdr;

    hdr = &msg->m_hdr;
    if (hdr->h_cid == (gs_cookie_t) -1)
	return;

    gs_log(("Ack nid %d msg %x flags %x\n",hdr->h_sid, msg,
	    msg->m_hdr.h_flags));
    if (hdr->h_sid != gd->g_nid) {
	gs_msg_hdr_t	rhdr;

	memcpy(&rhdr, hdr, sizeof(rhdr));
	rhdr.h_sid = (gs_memberid_t) gd->g_nid;
	rhdr.h_mid = hdr->h_sid;
	rhdr.h_type = GS_MSG_TYPE_ACK;
	rhdr.h_len = 0;
	*((NTSTATUS *)rhdr.h_tag) = status;
	msg_send(hdr->h_sid, &rhdr, NULL, 0);
    } else {
	gs_context_t	*ctx;

	ctx = GspLookupContext(gd, hdr->h_cid);
	GspProcessReply(gd, ctx, gd->g_nid, NULL, 0, status);
    }
}

NTSTATUS
WINAPI
GsSendReply(HANDLE cookie, PVOID buf, int len, NTSTATUS status)
{
    gs_group_t	*gd;
    gs_msg_t *msg = (gs_msg_t *)cookie;
    NTSTATUS err = ERROR_SUCCESS;

    if (msg == NULL || msg->m_hdr.h_rlen < len) 
	return ERROR_INVALID_PARAMETER;

    // find group
    gd = GspLookupGroup(msg->m_hdr.h_gid);

    GsLockEnter(gd->g_lock);
    if (!(msg->m_hdr.h_flags & GS_FLAGS_REPLY) && 
	msg->m_hdr.h_rlen >= len) {
	// mark msg state
	msg->m_hdr.h_flags |= GS_FLAGS_REPLY;
	gs_log(("Reply msg %x flags %x len %x ubuf %x ulen %x\n",msg,
		msg->m_hdr.h_flags, msg->m_hdr.h_rlen, buf, len));
	// local reply
	if (msg->m_hdr.h_sid == gd->g_nid) {
	    gs_context_t *ctx;
	    // find context in waiting queue
	    ctx = GspLookupContext(gd, msg->m_hdr.h_cid);
	    assert(ctx != NULL);
	    assert(ctx->ctx_msg->m_hdr.h_mseq == hdr->h_mseq);

	    GspProcessReply(gd, ctx, msg->m_hdr.h_sid, (char *)buf, len, status);
	} else {
	    gs_msg_hdr_t	rhdr;

	    memcpy(&rhdr, &msg->m_hdr, sizeof(rhdr));
	    rhdr.h_sid = gd->g_nid;
	    rhdr.h_mid = msg->m_hdr.h_sid;
	    rhdr.h_type = GS_MSG_TYPE_REPLY;
	    rhdr.h_len = (UINT16) len;
	    *((NTSTATUS *)rhdr.h_tag) = status;
	    msg_send(rhdr.h_mid, &rhdr, (const char *)buf, len);
	}
	// release msg
	msg_free(msg);
    } else {
	gs_log(("Reply failed %x: flags %x len %x ubuf %x ulen %x\n",msg,
		msg->m_hdr.h_flags, msg->m_hdr.h_rlen, buf, len));
		
	err = ERROR_INVALID_OPERATION;
    }
    GsLockExit(gd->g_lock);
    return err;
}

static gs_eventid_t GsTypeToEventId[] = {
    GsEventInvalid,
    GsEventInvalid,
    GsEventData,
    GsEventInvalid,
    GsEventSingleData,
    GsEventInvalid,
    GsEventInvalid,
    GsEventInvalid,
    GsEventInvalid,
    GsEventMemberJoin,
    GsEventMemberUp,
    GsEventInvalid,
    GsEventMemberEvicted,
    GsEventInvalid,
    GsEventMemberDown
};

#define GsMsgTypeToEventId(x)	(x != GS_MSG_TYPE_ABORT ? GsTypeToEventId[x] : GsEventAbort)

void
GspSyncMember(gs_group_t *gd, gs_memberid_t mid, gs_sequence_t mseq)
{
    gs_msg_t *p;

    // forward all messages that we have sent with higher sequence number
    for (p = gd->g_recv.r_head; p != NULL; p = p->m_next) {
	if (p->m_hdr.h_sid == gd->g_nid && p->m_hdr.h_mseq > mseq &&
	    p->m_hdr.h_type != GS_MSG_TYPE_UCAST) {
	    gs_context_t *ctx = &gd->g_send.s_ctxpool[p->m_hdr.h_cid];

	    assert(ctx->ctx_msg == p);
	    if (!(ctx->ctx_mask & (1 << mid))) {
		recovery_log(("sync node %d mseq %d\n", mid, p->m_hdr.h_mseq));
		ctx->ctx_mask |= (1 << mid);
		msg_send(mid, &p->m_hdr, p->m_buf, p->m_hdr.h_len);
	    }
	}
    }
}
    
void
GspDeliverMsg(gs_group_t *gd, gs_msg_t *msg)
{
    IO_STATUS_BLOCK ios;
    NTSTATUS status;
    gs_memberid_t mid;

    switch(msg->m_hdr.h_type) {
    case GS_MSG_TYPE_UP:
	mid = *((gs_memberid_t *)msg->m_hdr.h_tag);
	GspAddMember(gd, mid, *(int *)msg->m_buf);
	GspSyncMember(gd, mid, msg->m_hdr.h_mseq);
	recovery_log(("New membership gid %d view %d,%d sz %d set %x\n", 
		  gd->g_id,
		  gd->g_startview, gd->g_curview, gd->g_sz, gd->g_mset));
	break;
    default:
	break;
    }

    // hold msg
    msg->m_refcnt++;

    GsLockExit(gd->g_lock);

    ios.Status = GsMsgTypeToEventId(msg->m_hdr.h_type);
    ios.Information = msg->m_hdr.h_len;

    status = gd->g_callback((HANDLE)msg, msg->m_hdr.h_tag, msg->m_buf, &ios);

    GsLockEnter(gd->g_lock);

    if (status == STATUS_PENDING) {
	gs_log(("Reply msg pending %x\n", msg));
	return;
    }

    if (!(msg->m_hdr.h_flags & GS_FLAGS_REPLY)) {
	msg->m_hdr.h_flags |= GS_FLAGS_REPLY;
//	*((NTSTATUS *)msg->m_hdr.h_tag) = status;
	// release msg
	msg->m_refcnt--;
	GspSendAck(gd, msg, status);
    }

    if (msg->m_hdr.h_type == GS_MSG_TYPE_UCAST) {
	msg->m_refcnt++;
	msg->m_hdr.h_flags &= ~GS_FLAGS_CONTINUED;
	GspRemoveMsg(gd, msg);
    }

}

void
GspDispatch(gs_group_t *gd)
{
    gs_msg_t	*msg;

    assert(gd->g_recv.r_next != NULL);
    while (gd->g_pending == 0 && (msg = *(gd->g_recv.r_next)) != NULL) {
	int hit = FALSE;
	int flags;

	if (msg->m_hdr.h_type != GS_MSG_TYPE_UCAST) {
	    // compare sequence numbers
	    if (gd->g_recv.r_mseq == msg->m_hdr.h_mseq &&
		gd->g_recv.r_bnum == msg->m_hdr.h_bnum) {
		// got it
		hit = TRUE;
	    }
	} else {
	    // compare sequence numbers
	    if (gd->g_recv.r_mseq >= msg->m_hdr.h_mseq) {
		// got it
		hit = TRUE;
	    }
	}	    

	if (hit == FALSE) {
	    break;
	}
	gd->g_pending = 1;

	msg->m_hdr.h_flags &= ~GS_FLAGS_REPLY;
	flags = msg->m_hdr.h_flags;

	gs_log(("dispatch seq <%d, %d> flags %x msg %x @ next %x\n", 
		msg->m_hdr.h_mseq,
		msg->m_hdr.h_bnum,
		flags, msg, gd->g_recv.r_next));

	// advance next msg to deliver
	gd->g_recv.r_next = &msg->m_next;

	// don't touch msg beyond this point, it may get freed as part of delivery
	if (msg->m_hdr.h_type != GS_MSG_TYPE_SKIP) {
	    GspDeliverMsg(gd, msg);
	}

	// if a continued msg don't advance mseq/bnum
	if (!(flags & GS_FLAGS_CONTINUED)) {
	    if (flags & GS_FLAGS_LAST) {
		gd->g_recv.r_bnum = 0;
		gd->g_recv.r_mseq++;
	    } else if (!(flags & GS_FLAGS_PTP)) {
		gd->g_recv.r_bnum += (1 << 16);
	    }
	} else if (!(flags & GS_FLAGS_PTP)) {
		gd->g_recv.r_bnum++;
	}

	gd->g_pending = 0;
    }
    
    gs_log(("waiting gid %d expect <%d, %d>\n", 
	      gd->g_id, gd->g_recv.r_mseq, gd->g_recv.r_bnum));

    GspDumpQueue(gd);
}

#if 0

WINAPI
GsReceiveRequest(gd, buf, len, ios)
{   
    GsLockEnter(gd->recv_lock);   
    m = gd->recv_last;
    // advance receive window    
    if (m && m->state == MSG_STATE_DELIVERED) {
        if (m->flags & GS_FLAGS_DELIVERED) {
	    msg_send_reply(m->srcid, m->mseq, m->cseq..);
	    m->reply = 1;
	}
	m->state = MSG_STATE_DONE;
	// check if this msg can be freed before moving to next one
	m = m->next;
    }    
    if (m && m->state == MSG_STATE_READY) {
	m->state = MSG_STATE_DELIVERED;
	GsLockExit(gd->recv_lock);
	memcpy(buf, m->data, m->len);
	Ios->status = m->srcid;
	Ios->information = m->len;
	Return SUCCESS;
    }
    // queue request 
    irp->next = gd->recv_pending_queue;
    gd->recv_pending_queue = irp;
    GsLockExit(gd->recv_lock); 
    Return PENDING;
}

#endif


void
GspMcastMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && GspValidateView(gd, msg->m_hdr.h_viewnum)) {
	gs_sequence_t lseq = msg->m_hdr.h_lseq;

	GsLockEnter(gd->g_lock);
	hdr->h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspOrderInsert(gd, msg, msg, hdr->h_mseq, hdr->h_bnum);  
	GspDispatch(gd);
	GspCleanQueue(gd, lseq);
	GsLockExit(gd->g_lock);
    } else {
	msg_free(msg);
    }
}

void
GspUcastMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    if (gd && GspValidateView(gd, msg->m_hdr.h_viewnum)) {
	gs_sequence_t lseq = msg->m_hdr.h_lseq;

	GsLockEnter(gd->g_lock);

	hdr->h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspUOrderInsert(gd, msg, msg, hdr->h_mseq, hdr->h_bnum);  
	GspDispatch(gd);  
	GspCleanQueue(gd, lseq);
	GsLockExit(gd->g_lock);
    } else {
	gs_log(("Dropping ucast: gid %d nid %d mseq %d view %d\n", hdr->h_gid,
		hdr->h_mid, hdr->h_mseq, hdr->h_viewnum));
	msg_free(msg);
    }
}

void
GspSeqAllocMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_seq_info_t info;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    if (gd) {

	GsLockEnter(gd->g_lock);
	info.mseq = gd->g_global_seq++;
	info.viewnum = gd->g_curview;
	GsLockExit(gd->g_lock);


	hdr->h_mid = hdr->h_sid;
	hdr->h_sid = gd->g_nid;
	hdr->h_type = GS_MSG_TYPE_SEQREPLY;
	hdr->h_len = sizeof(info);

	gs_log(("SeqAlloc: nid %d mseq %d view %d\n",
		hdr->h_mid, info.mseq, info.viewnum));

	msg_send(hdr->h_mid, hdr, (char *) &info, sizeof(info));
    }

    msg_free(msg);

}

void
GspSeqReplyMsgHandler(gs_msg_t *msg)
{   
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    gs_context_t *ctx;

    hdr = &msg->m_hdr;

    assert(hdr->h_len == sizeof(gs_seq_info_t));

   // find group using group internal identifier
    gd = GspLookupGroup(hdr->h_gid);
    if (gd != NULL && GspValidateView(gd, hdr->h_viewnum)) {
	gs_seq_info_t *info = (gs_seq_info_t *)msg->m_buf;
	GsLockEnter(gd->g_lock);
	if (GspValidateView(gd, info->viewnum) && hdr->h_sid == gd->g_mid) {
	    GspProcessWaitQueue(gd, info);
	}
	GsLockExit(gd->g_lock);
    }

   msg_free(msg);
}

void
GspJoinRequestMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_join_info_t info;
    gs_group_t	*gd;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    if (gd) {

	GsLockEnter(gd->g_lock);
	info.mseq = gd->g_global_seq++;
	info.viewnum = gd->g_curview;
	info.mset = gd->g_mset;
	info.sz = gd->g_sz;
	GsLockExit(gd->g_lock);


	hdr->h_mid = hdr->h_sid;
	hdr->h_sid = gd->g_nid;
	hdr->h_type = GS_MSG_TYPE_REPLY;
	hdr->h_len = sizeof(info);

	msg_send(hdr->h_mid, hdr, (char *) &info, sizeof(info));
    }

    msg_free(msg);

}

void
GspJoinUpMsgHandler(gs_msg_t *msg)
{
    gs_group_t	*gd;
    gs_msg_hdr_t *hdr;

    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && GspValidateView(gd, msg->m_hdr.h_viewnum)) {
	GsLockEnter(gd->g_lock);
	hdr->h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspOrderInsert(gd, msg, msg, hdr->h_mseq, hdr->h_bnum);  
	GspDispatch(gd);
	GsLockExit(gd->g_lock);
    } else {
	msg_free(msg);
    }
}

void GspInfoMsgHandler(gs_msg_t *);
void GspMmMsgHandler(gs_msg_t *);
void GspRecoveryMsgHandler(gs_msg_t *);
void GspSyncMsgHandler(gs_msg_t *);

gs_msg_handler_t gs_msg_handler[] = {
    GspSeqAllocMsgHandler,
    GspSeqReplyMsgHandler,
    GspMcastMsgHandler,
    GspReplyMsgHandler,
    GspUcastMsgHandler,
    GspReplyMsgHandler,
    GspInfoMsgHandler,
    GspMmMsgHandler,
    GspJoinRequestMsgHandler,
    GspJoinUpMsgHandler, // join
    GspJoinUpMsgHandler, // up
    NULL, // evict request
    NULL, // evict
    GspRecoveryMsgHandler,
    GspSyncMsgHandler
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\msg.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msg.c

Abstract:

    Point to point tcp and ip-multicast

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include <stdio.h>
#include "msg.h"


#include <stdlib.h>
#include <winsock2.h>
#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <time.h>

#define MSG_ATOMIC 1

int GS_MAX_MSG_SZ = (64 * 1024);

#define PROTOCOL_TYPE	SOCK_STREAM

extern gs_node_handler_t gs_node_handler[];

static int max_mcmsg = 0;

static char cl_subnet[16];

#define MAX_NODEID	16

int NodesSize = 0;

static char *nodes[MAX_NODEID] = {0};
static char *ipaddr[MAX_NODEID] = {0};

static int DEFAULT_PORT=6009;

static int mcast_enabled = 0;
static int MSG_POOL_SZ=32;

int MY_NODEID;

static SOCKET	prf_handles[MAX_NODEID];
static SOCKET	rcv_handles[MAX_NODEID];
static SOCKET	send_handles[MAX_NODEID];
static SOCKET	tmp_socks[MAX_NODEID];

static CRITICAL_SECTION msglock;
static HANDLE Msg_Event[MAX_NODEID];

void mcast_init();
DWORD WINAPI srv(LPVOID arg);
DWORD WINAPI mcast_srv(LPVOID arg);
DWORD WINAPI srv_io(LPVOID arg);
DWORD WINAPI cmgr(LPVOID arg);

static gs_msg_t *msg_pool = NULL;
static gs_msg_t *msg_hdrpool = NULL;


void
Msg_AllocPool()
{
    char *p;
    gs_msg_t *prev;
    int sz, elmsz;

    // allocate msg header pool
    sz = sizeof(gs_msg_t) * MSG_POOL_SZ;
    prev = (gs_msg_t *) malloc(sz);
    if (prev == NULL) {
	printf("Unable to allocate message hdr pool\n");
	halt(1);
    }
    msg_hdrpool = NULL;
    for (sz = 0; sz < MSG_POOL_SZ; sz++) {
	prev->m_refcnt = 0;
	prev->m_buflen = 0;
	prev->m_buf = NULL;
	prev->m_next = msg_hdrpool;
	msg_hdrpool = prev;
	prev++;
    }

    // allocate msg pool
    sz = sizeof(gs_msg_t) * MSG_POOL_SZ;
//    prev = (gs_msg_t *) malloc(sz);
    prev = (gs_msg_t *) VirtualAlloc(NULL, sz, MEM_RESERVE|MEM_COMMIT,
		     PAGE_READWRITE);
    if (prev == NULL) {
	printf("Unable to allocate message pool\n");
	halt(1);
    }

    // lock region now
    if (!VirtualLock(prev, sz)) {
	printf("Unable to lock down hdr pages %d\n", GetLastError());
    }

    sz = MSG_POOL_SZ * GS_MAX_MSG_SZ;
    p = VirtualAlloc(NULL, sz, MEM_RESERVE|MEM_COMMIT,
		     PAGE_READWRITE);
    if (p == NULL) {
	printf("Unable to allocate message memory pool\n");
	halt(1);
    }

    if (!VirtualLock(p, sz)) {
	printf("Unable to lock down pages %d err %d\n", sz, GetLastError());
    }

    msg_pool = NULL;
    for (sz = 0; sz < MSG_POOL_SZ; sz++) {
	prev->m_refcnt = 0;
	prev->m_buflen = GS_MAX_MSG_SZ - 1;
	prev->m_buf = p;
	prev->m_next = msg_pool;
	msg_pool = prev;
	prev++;
	*p = 0;	// touch it
	p += GS_MAX_MSG_SZ;
    }

}


gs_msg_t *
msg_hdralloc(const char *buf, int len)
{
    PVOID t;
    gs_msg_t * p;

#ifdef MSG_ATOMIC
    do {
	p = msg_hdrpool;
	if (p == NULL) {
	    break;
	}
	t = InterlockedCompareExchangePointer((PVOID *)&msg_hdrpool, 
					      (PVOID)p->m_next, (PVOID) p);
    } while (t != (PVOID) p);
#else
    GsLockEnter(msglock);
    if (p = msg_hdrpool) {
	msg_hdrpool = p->m_next;
	p->m_next = NULL;
    }
    GsLockExit(msglock);
#endif    

    if (p == NULL) {
	printf("Out of message headers!!!\n");
	halt(1);
    }
    
//    p->m_buflen = 0;
    p->m_refcnt = 1;
    p->m_buf = (char *)buf;
    p->m_type = MSG_TYPE_HDR;

    msg_log(("Alloc hdr msg %x len %d pool %x\n", p, p->m_buflen, msg_hdrpool));
    return p;

}

gs_msg_t *
msg_alloc(const char *buf, int len)
{
    PVOID t;
    gs_msg_t * p;

    if (len > GS_MAX_MSG_SZ) {
	printf("Large msg, can't handle %d\n", len);
	halt(1);
    }

    if (buf != NULL) {
	return msg_hdralloc(buf, len);
    }

#ifdef MSG_ATOMIC
    do {
	p = msg_pool;
	if (p == NULL) {
	    break;
	}
	t = InterlockedCompareExchangePointer((PVOID *)&msg_pool, 
					      (PVOID)p->m_next, (PVOID) p);
    } while (t != (PVOID) p);
#else
    GsLockEnter(msglock);
    if (p = msg_pool) {
	msg_pool = p->m_next;
	p->m_next = NULL;
	msg_log(("Alloc msg %x pool %x\n", p, msg_pool));
    }
    GsLockExit(msglock);
#endif    

    if (p == NULL) {
	printf("Out of messages!!!\n");
	halt(1);
    }
    
//    p->m_buflen = len;
    p->m_refcnt = 1;
    p->m_type = MSG_TYPE_DATA;

    if (buf) {
	memcpy(p->m_buf, buf, len);
    }

    msg_log(("Alloc msg %x buf %x len %d\n", p, p->m_buf, p->m_buflen));

    return p;

}


void
msg_hdrfree(gs_msg_t *msg)
{
    PVOID t, p;
    
    msg_log(("Free hdr msg %x len %d pool %x\n", msg, msg->m_buflen,msg_pool));
#ifdef MSG_ATOMIC
    do {
	msg->m_next = msg_hdrpool;
	t = InterlockedCompareExchangePointer((PVOID *)&msg_hdrpool, (PVOID)msg, 
					      (PVOID)msg->m_next);
    } while (t != (PVOID) msg->m_next);
#else
    GsLockEnter(msglock);
    msg->m_next = msg_hdrpool;
    msg_hdrpool = msg;
    GsLockExit(msglock);
#endif
}

void
msg_free(gs_msg_t *msg)
{
    PVOID t, p;
    
    msg->m_refcnt--;
    if (msg->m_refcnt > 0) {
	msg_log(("msg %x not freed %d flags %x\n", msg, msg->m_refcnt, 
		 msg->m_hdr.h_flags));
	if (msg->m_refcnt > 10) {
	    halt(0);
	}
	return;
    }
    if (msg->m_type == MSG_TYPE_HDR) {
	msg_hdrfree(msg);
	return;
    }
    msg_log(("Free msg %x buf %x pool %x\n", msg, msg->m_buf, msg_pool));
#ifdef MSG_ATOMIC
    do {
	msg->m_next = msg_pool;
	t = InterlockedCompareExchangePointer((PVOID *)&msg_pool, (PVOID)msg, 
					      (PVOID)msg->m_next);
    } while (t != (PVOID) msg->m_next);
#else
    GsLockEnter(msglock);
    msg->m_next = msg_pool;
    msg_pool = msg;
    GsLockExit(msglock);
#endif
}


char *
strsave(char *s)
{
  char *p;

  p = (char*)malloc(strlen(s) + 1);
  assert(p != NULL);
  return strcpy(p, s);
}

int 
Strncasecmp(char *s, char *p, int len)
{
  while (len-- > 0) {
    if (tolower(s[len]) != tolower(p[len]))
      return 1;
  }
  return 0;
}

/********************************************************************/

int
msg_buildaddr(struct sockaddr_in *sin, char *hostname, char *ipaddr)
{
    
    struct hostent *h;
    int i;
    char *p;
    char *tmp;

    h = gethostbyname(hostname);
    if (h == NULL) {
	fprintf(stderr,"cannot get info for host %s\n", hostname);
	return 1;
    }

    p = (char *) h->h_addr_list[0];
    for (i = 0; h->h_addr_list[i]; i++) {
	struct in_addr x;

	memcpy(&x, p, h->h_length);
	tmp = inet_ntoa(x);
	if (!strncmp(cl_subnet, tmp, strlen(cl_subnet))) {
	    break;
	}
	p += h->h_length;
    }
    if (h->h_addr_list[i] == NULL) {
	printf("Unable to find proper subnet %s host %s\n", cl_subnet, hostname);
	if (ipaddr != NULL) {
	    // use this address
	    sin->sin_addr.s_addr = inet_addr(ipaddr);
	    printf("host %s addr %s\n", hostname, ipaddr);
	} else {
	    sin->sin_addr.s_addr = INADDR_ANY;
	    printf("host %s addr %s\n", hostname, "any");
	}
    } else {
	memcpy(&sin->sin_addr.s_addr, h->h_addr_list[i], h->h_length);
	printf("host %s addr %s\n", hostname, tmp);
    }
    return 0;
    
}


#ifndef TEST
int
WINAPI
msg_addnode(int id, char *n, char *a)
{
    char *s;

    s = strchr(n, '.');	
    if (s) {
	*s = '\0';
    }

    printf("nodeid %d node %s ip %s\n", id, n, a);


    nodes[id-1] = strsave(n);
    ipaddr[id-1] = strsave(a);

    if (id > NodesSize)
	NodesSize = id;

    return NodesSize;

}
#endif
/********************************************************************/

int
msg_getsize()
{
    return NodesSize;
}

void
msg_closenode(int nodeid)
{

    GsLockEnter(msglock);
    if (rcv_handles[nodeid]) {
	closesocket(rcv_handles[nodeid]);
	rcv_handles[nodeid] = 0;
    }
    if (send_handles[nodeid]) {
	closesocket(send_handles[nodeid]);
	send_handles[nodeid] = 0;
    }
    prf_handles[nodeid] = 0;
    GsLockExit(msglock);
    return;
}

int
msg_send(gs_memberid_t nodeid, gs_msg_hdr_t *hdr, const char *buf, int len)
{
	int i;
	SOCKET s;
	WSABUF	io[2];
	LPWSAOVERLAPPED ov;

	ov = NULL;

	nodeid--;
	if (nodeid >= NodesSize) {
	    err_log(("send bad node %d\n", nodeid));
	    return 1;
	}

	s = prf_handles[nodeid];
	if (!s) {
	    s = send_handles[nodeid];
	    if (!s) {
		s = rcv_handles[nodeid];
		if (!s) {
		    err_log(("Node %d is dead\n", nodeid+1));
		    return 1;
		}
	    }
	}

	msg_log(("Send msg nid %d type %d seq %d bnum %d view %d\n",
		 nodeid+1, hdr->h_type, hdr->h_mseq,
		 hdr->h_bnum, hdr->h_viewnum));
	io[0].len = sizeof(*hdr);
	io[0].buf = (char *) hdr;
	io[1].len = len;
	io[1].buf = (char *) buf;

	if (WSASend(s, io, 2, &i, 0, ov, 0)) {
	    int err = WSAGetLastError();
	    if (err == WSA_IO_PENDING) {
		printf("Async send\n");
		return 1;
	    }
	    printf("Send nid %d failed %d\n", nodeid+1, err);
	    msg_closenode(nodeid);
	    return 1;
	}
	i -= sizeof(*hdr);
	if (i != len) {
	    printf("Send failed: node %d len %d, %d\n", nodeid+1, len, i);
	    halt(1);
	}
	return 0;
}


void
msg_mcast(ULONG mset, gs_msg_hdr_t *hdr, const char *buf, int len)
{
    gs_memberid_t i;
    void mcast_send(gs_msg_hdr_t *hdr, const char *buf, int len);

    mset = mset & ~(1 << MY_NODEID);
    if (mset == 0)
	return;
//    if (mcast_enabled == 0 || len > max_mcmsg) {
    if (len > max_mcmsg) {
	
	for (i = 1; i <= NodesSize; i++) {
	    if (mset & (1 << i)) {
		msg_send(i, hdr, buf, len);
	    }
	}
    }
    else {
	mcast_send(hdr, buf, len);
    }
}

void
msg_smcast(ULONG mset, gs_msg_hdr_t *hdr, const char *buf, int len)
{
    gs_memberid_t i;

    mset = mset & ~(1 << MY_NODEID);
    if (mset == 0)
	return;
    for (i = 1; i <= NodesSize; i++) {
	if (mset & (1 << i)) {
	    msg_send(i, hdr, buf, len);
	}
    }
}

msg_init()
{
	int i;
	WSADATA wsaData;
	char h_name[64];

	// set our priority to high class
	if (!SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS)) {
	    printf("Unable to set high priority %d\n", GetLastError());
	}

	if (WSAStartup(0x202,&wsaData) == SOCKET_ERROR) {
		fprintf(stderr,"WSAStartup failed with error %d\n",
			WSAGetLastError());
		WSACleanup();
		return -1;
	}

	i = gethostname(h_name, 64);


	// increase our working set
	if (!SetProcessWorkingSetSize(GetCurrentProcess(),
				      32*1024*1024, 64*1024*1024)) {
	    printf("Unable to set working size %d\n", GetLastError());
	}

	InitializeCriticalSection(&msglock);

	Msg_AllocPool();


	for (i = 0; i < NodesSize; i++) {
	    Msg_Event[i] = CreateEvent(NULL, TRUE, FALSE, NULL);
	    prf_handles[i] = 0;
	    send_handles[i] = 0;
	    rcv_handles[i] = 0;
	    if (!Strncasecmp(h_name, nodes[i], strlen(h_name))) {
		MY_NODEID = i+1;
		gs_node_handler[MSG_NODE_ID](MY_NODEID);
	    } else {
		LPVOID arg = (LPVOID) ((ULONGLONG) i);
		CreateThread(NULL, 2*64*1024, cmgr, arg, 0, NULL);
	    }
	}
	cm_log(("Local host %d %s\n", MY_NODEID, h_name));

	if (mcast_enabled) {
	    mcast_init();
	}

	if (NodesSize > 1) {
	    LPVOID arg = (LPVOID) ((ULONGLONG) DEFAULT_PORT);
	    // create srv thread
	    CreateThread(NULL, 4*1024, srv, arg, 0,NULL);
	    // create mcast thread
	    if (mcast_enabled) {
		for (i = 0; i < 8; i++)
		    CreateThread(NULL, 2*64*1024, mcast_srv, 0, 0,NULL);
	    }
	}

	return 0;
}

void
msg_exit()
{
    // xxx: Stop all threads before during this
    WSACleanup();
}

void
msg_start(ULONG mask)
{
    int i;

    mask = mask >> 1;
    for (i = 0; i < NodesSize; i++) {
	GsLockEnter(msglock);
	if (!(mask & (1 << i)) && !send_handles[i]) {
	    SetEvent(Msg_Event[i]);
	}
	GsLockExit(msglock);
    }
}
    
DWORD
srv_msg(SOCKET msgsock, int nodeid)
{
  gs_msg_t *msg;
  int retval;
  char *buf;
  int len;

  while (1) {
      extern gs_msg_handler_t gs_msg_handler[];
      int type;

      msg = msg_alloc(NULL, GS_MAX_MSG_SZ);

      // read hdr info first
      buf = (char *) &msg->m_hdr;
      len = sizeof(msg->m_hdr);

      do {
	  retval = recv(msgsock, buf, len, 0);
	  if (retval < 0) {
	      err_log(("recv failed %d, %d\n",
		       retval,
		       WSAGetLastError()));
	      msg_free(msg);
	      return 0;
	  }

	  len -= retval;
	  buf += retval;
      } while (len > 0);

      // read rest of message
      buf = msg->m_buf;
      len = msg->m_hdr.h_len;

      while (len > 0) {

	  retval = recv(msgsock, buf, len, 0);
	  if (retval < 0) {
	      err_log(("recv failed %d, %d\n",retval,
		       WSAGetLastError()));	
	      msg_free(msg);
	      return 0;
	  }
	  len -= retval;
	  buf += retval;
      }

      // set preferred socket to use
      prf_handles[nodeid] = msgsock;

      msg_log(("rec nid %d gid %d type %d seq %d view %d len %d\n",
	       msg->m_hdr.h_sid,msg->m_hdr.h_gid, type = msg->m_hdr.h_type,
	       msg->m_hdr.h_mseq, msg->m_hdr.h_viewnum, msg->m_hdr.h_len));

      gs_msg_handler[msg->m_hdr.h_type](msg);

      msg_log(("Done Type %d\n", type));
  }

  return 0;
}
    
DWORD WINAPI
srv_io(LPVOID arg)
{
  int retval;
  char *buf;
  int len;
  ULONGLONG tmp = (ULONGLONG) arg;
  int nodeid = (int) tmp;
  SOCKET msgsock = tmp_socks[nodeid];


  GsLockEnter(msglock);

  gs_node_handler[MSG_NODE_JOIN](nodeid+1);
  rcv_handles[nodeid] = msgsock;

  // issue join callback
  if (!send_handles[nodeid]) {
      gs_node_handler[MSG_NODE_UP](nodeid+1);
      SetEvent(Msg_Event[nodeid]);
  }
  GsLockExit(msglock);

  srv_msg(msgsock, nodeid);

  cm_log(("Terminating connection with node %d\n", nodeid));

  msg_closenode(nodeid);
  gs_node_handler[MSG_NODE_DOWN](nodeid+1);
  return (0);
}

void
msg_setopt(SOCKET s)
{
    // set option keepalive
    BOOLEAN val = TRUE;
    if (setsockopt(s, IPPROTO_TCP, SO_KEEPALIVE, (char *)&val,
		   sizeof(val)) == SOCKET_ERROR) {
	fprintf(stderr,"Keepalive %d\n", WSAGetLastError());
    }

    // set option nodelay
    val = TRUE;
    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *)&val,
		   sizeof(val)) == SOCKET_ERROR) {
	fprintf(stderr,"No delay %d\n", WSAGetLastError());
    }

    // set option nolinger
    val = TRUE;
    if (setsockopt(s, SOL_SOCKET, SO_DONTLINGER, (char *)&val,
		   sizeof(val)) == SOCKET_ERROR) {
	fprintf(stderr,"No delay %d\n", WSAGetLastError());
    }
}


DWORD WINAPI
srv(LPVOID arg)
{
	char *nic= NULL;
	int fromlen;
	int i;
	struct sockaddr_in local, from;
	SOCKET listen_socket, msgsock;
	ULONGLONG tmp = (ULONGLONG) arg;
	short port = (short) tmp;
#if 0
	nic = ipaddr[MY_NODEID-1];

	local.sin_addr.s_addr = (!nic)?INADDR_ANY:inet_addr(nic); 
#else
	if (msg_buildaddr(&local, nodes[MY_NODEID-1], ipaddr[MY_NODEID-1])) {
	    fprintf(stderr,"Unable to get my own address\n");
	    return -1;
	}
#endif
	local.sin_family = AF_INET;

	/* 
	 * Port MUST be in Network Byte Order
	 */
	local.sin_port = htons(port);

	// TCP socket
	listen_socket = WSASocket(AF_INET, PROTOCOL_TYPE, 0, NULL, 0,
				  WSA_FLAG_OVERLAPPED);
	
	if (listen_socket == INVALID_SOCKET){
		fprintf(stderr,"socket() failed with error %d\n",WSAGetLastError());
		return -1;
	}

	//
	// bind() associates a local address and port combination with the
	// socket just created. This is most useful when the application is a 
	// server that has a well-known port that clients know about in advance.
	//

	if (bind(listen_socket,(struct sockaddr*)&local,sizeof(local) ) 
		== SOCKET_ERROR) {
		fprintf(stderr,"bind() failed with error %d\n",WSAGetLastError());
		return -1;
	}

	msg_setopt(listen_socket);

	if (listen(listen_socket,5) == SOCKET_ERROR) {
	  fprintf(stderr,"listen() failed with error %d\n",WSAGetLastError());
	  return -1;
	}

	while(1) {
		char *name;
		struct hostent *p;

		cm_log(("Accepting connections\n"));

		fromlen =sizeof(from);
		msgsock = accept(listen_socket,(struct sockaddr*)&from, &fromlen);
		if (msgsock == INVALID_SOCKET) {
		  fprintf(stderr,"accept() error %d\n",WSAGetLastError());
		  return -1;
		}

		name = inet_ntoa(from.sin_addr);
		p = gethostbyaddr((char *)&from.sin_addr, 4, AF_INET);
		if (p == NULL) {
			printf("can't find host name %s %d\n", name, GetLastError());
			closesocket(msgsock);
			continue;
		}
		name = p->h_name;
		if (strchr(name, '~')) {
		    name = strchr(name, '~') + 1;
		}
		// find node id
		for (i = 0; i < NodesSize; i++) {
			int j;
			j = Strncasecmp(nodes[i], name, strlen(name));
			if (j == 0)
				break;
		}

		if (i < NodesSize) {
		    cm_log(("Accepted node : %d\n", i));

		    msg_setopt(msgsock);

		    tmp_socks[i] = msgsock;
		    CreateThread(NULL, 2*64*1024, srv_io,
				 (LPVOID) ((ULONGLONG)i), 0, NULL);
		} else {
			printf("bad node name: %d %s\n", i, name);
			closesocket(msgsock);
		}
	}
	return (0);
}

DWORD WINAPI
cmgr(LPVOID arg)
{
	int retval;
	struct sockaddr_in server;
	SOCKET  conn_socket;
	unsigned short port = (unsigned short) DEFAULT_PORT;
	int nodeid = (int) ((ULONGLONG)arg);
	char *server_name = nodes[nodeid];

	if (send_handles[nodeid] != 0 || (nodeid+1 == MY_NODEID))
	    return 0;

	memset(&server,0,sizeof(server));
	if (msg_buildaddr(&server, server_name, ipaddr[nodeid])) {
	    fprintf(stderr,"Client: cann't resolve name %s\n", server_name);
	    return 0;
	}

	//
	// Copy the resolved information into the sockaddr_in structure
	//
	server.sin_family = AF_INET; //hp->h_addrtype;
	server.sin_port = htons(port);

 again:	

	ResetEvent(Msg_Event[nodeid]);

	/* Open a socket */
	conn_socket = WSASocket(AF_INET, PROTOCOL_TYPE, 0, NULL, 0,
				WSA_FLAG_OVERLAPPED);
	if (conn_socket  != 0 ) {
		cm_log(("Client connecting to: %s\n", nodes[nodeid]));

		msg_setopt(conn_socket);

		if (connect(conn_socket,(struct sockaddr*)&server,sizeof(server))
		    != SOCKET_ERROR) {

		    cm_log(("Client connected to: %s\n", nodes[nodeid]));
		    GsLockEnter(msglock);
		    gs_node_handler[MSG_NODE_JOIN](nodeid+1);
		    send_handles[nodeid] = conn_socket;
		    if (!rcv_handles[nodeid]) {
			gs_node_handler[MSG_NODE_UP](nodeid+1);
		    }
		    GsLockExit(msglock);
		    srv_msg(conn_socket, nodeid);
		    msg_closenode(nodeid);
		    gs_node_handler[MSG_NODE_DOWN](nodeid+1);
		} else {
		    int err = WSAGetLastError();
		    cm_log(("connect() failed: %d\n", err));
		    closesocket(conn_socket);
		}
	} else {
	    int err = WSAGetLastError();
	    printf("Client: Error Opening socket: Error %d\n", err);
	}

	cm_log(("Cmgr %d sleeping\n", nodeid));
	WaitForSingleObject(Msg_Event[nodeid], INFINITE); //5 * 1000);
	cm_log(("Cmgr %d wokeup\n", nodeid));


	goto again;

    return (0);

}



static char *MCAST_IPADDR="224.0.20.65";
static int MPORT_NUM=9100;

int
OpenSocket(SOCKET *rs, struct sockaddr_in *sin, ULONG mipaddr, u_short port)
{
	struct hostent *h;
	int size, msgsize, len, n;
	struct sockaddr_in mysin;
	SOCKET s;
	char hostname[128];
	BOOLEAN bFlag = TRUE;

	s = WSASocket(AF_INET, SOCK_DGRAM, 0, (LPWSAPROTOCOL_INFO)NULL, 0, 
		  WSA_FLAG_OVERLAPPED | WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF);

	if (s == INVALID_SOCKET) {
	  fprintf(stderr, "Unable to create socket %d\n", GetLastError());
	  return 1;
	}
#if 1	
	if (msg_buildaddr(&mysin, nodes[MY_NODEID-1], ipaddr[MY_NODEID-1])) {
	    fprintf(stderr, "Unable to get my own address\n");
	    return 1;
	}
#if 0
	gethostname(hostname, sizeof(hostname));
	h = gethostbyname(hostname);
	if (h == NULL) {
		fprintf(stderr,"cannot get my own address\n");
		return 1;
	}
	printf("host %s addr cnt = %d\n", hostname, h->h_length);
	{
	    int i;
	    char *p;
	    p = (char *) h->h_addr_list[0];
	    for (i = 0; h->h_addr_list[i]; i++) {
		struct in_addr x;
		char *tmp;

		memcpy(&x, p, h->h_length);
		tmp = inet_ntoa(x);
		printf("Slot %d ip %s\n", i, tmp);
		p += h->h_length;
	    }
	}
	memcpy(&mysin.sin_addr.s_addr, h->h_addr_list[0], 4);
#endif
#else
	if (ipaddr[MY_NODEID-1] != NULL) {
	    mysin.sin_addr.s_addr = inet_addr(ipaddr[MY_NODEID-1]);
	} else {
	    mysin.sin_addr.s_addr = INADDR_ANY;
	}
#endif
	mysin.sin_family = PF_INET;
	port = htons (port);
	mysin.sin_port = (u_short) port;

	if (bind (s, (struct sockaddr *)&mysin, sizeof(mysin)) <0) {
	  fprintf(stderr, "Bind failed %d\n", GetLastError());
	  return 1;
	}

	len = sizeof(max_mcmsg);
	/* get max. message size */
	if (getsockopt(s, SOL_SOCKET, SO_MAX_MSG_SIZE, (PVOID) &max_mcmsg,
		       &len)) {
	    fprintf(stderr,"getsockopt SO_MAX_MSG_SIZE failed %d\n",
		    WSAGetLastError());
	    closesocket(s);
	    return 1;
	}
	max_mcmsg -= sizeof(gs_msg_hdr_t);
	printf("Max mcast message %d\n", max_mcmsg);

	/* make sure we can run multiple copies */
	if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &bFlag, sizeof(bFlag))< 0) {
	  fprintf(stderr, "setsockopt SO_REUSEADDR failed %d\n", GetLastError());
	  closesocket(s);
	  return 1;
	}

	/* disable loopback on send */
	bFlag = FALSE;
	if (WSAIoctl(s, SIO_MULTIPOINT_LOOPBACK, (char *) &bFlag, sizeof(bFlag), NULL, 0, &n, NULL, NULL)< 0) {
	  fprintf(stderr, "ioctl loopback failed %d\n", GetLastError());
	  closesocket(s);
	  return 1;
	}

	sin->sin_family      = PF_INET;
	sin->sin_port        = (u_short) (ntohs(port));
	sin->sin_addr.s_addr = mipaddr; //inet_addr(MCAST_IPADDR);

	/* join the multicast address */
	s = WSAJoinLeaf (s, (struct sockaddr *)sin, sizeof (*sin),
		NULL, NULL, NULL, NULL,  JL_BOTH); 

	/* dead in the water */
	if (s == INVALID_SOCKET) {
		fprintf(stderr, "Join failed %d\n", GetLastError());
		return 1;
	}

	*rs = s;
	return 0;
}


SOCKET msock;
struct sockaddr_in msin;

void
mcast_send(gs_msg_hdr_t *hdr, const char *buf, int len)
{
	int i;
	WSABUF	io[2];

	msg_log(("Send msg mcast type %d seq %d len %d\n",
		 hdr->h_type, hdr->h_mseq, len));

	io[0].buf = (char *) hdr;
	io[0].len = sizeof(*hdr);
	io[1].buf = (char *) buf;
	io[1].len = len;

	if (WSASendTo(msock, io, 2, &i, 0, 
		    (struct sockaddr *)&msin, sizeof(msin), 0, 0)) {
	    int err = WSAGetLastError();
	    if (err == WSA_IO_PENDING) {
		printf("Async send\n");
		return;
	    }
	    printf("Send failed %d\n", WSAGetLastError());
	    halt(1);
	}
	i -= sizeof(*hdr);
	if (i != len) {
	    printf("Send failed: mcast len %d, %d\n", len, i);
	    halt(1);
	}
	msg_log(("Send done mcast type %d seq %d\n",
		 hdr->h_type, hdr->h_mseq));
	return;
}

void
mcast_init()
{
  u_short port = (u_short) MPORT_NUM;
  ULONG	ipaddr = inet_addr(MCAST_IPADDR);

  if (OpenSocket(&msock, &msin, ipaddr, port) == 1) {
      err_log(("Unable to create mcast socket\n"));
      mcast_enabled = 0;
      max_mcmsg = 0;
  }

  printf("Mcast %d\n", mcast_enabled);



}

DWORD WINAPI
mcast_srv(LPVOID arg)
{
  SOCKET msgsock;
  gs_msg_t *msg;
  int retval;
  char *buf;
  int len, flags;

  msgsock = msock;
  while (1) {
      extern gs_msg_handler_t gs_msg_handler[];
      int type;
      WSABUF	io[2];

      msg = msg_alloc(NULL, GS_MAX_MSG_SZ);
      assert(msg);
      assert(msg->m_buflen != 0);

      io[0].buf = (char *)&msg->m_hdr;
      io[0].len = sizeof(msg->m_hdr);
      io[1].buf = msg->m_buf;
      io[1].len = msg->m_buflen;

      flags = 0;
      retval = WSARecv(msgsock, io, 2, &len, &flags, 0, 0);
      if (retval == SOCKET_ERROR) {
	  err_log(("mcast recv failed %d, %d, len %d\n",
		   retval,
		   WSAGetLastError(), msg->m_buflen));
	  msg_free(msg);
	  halt(1);
	  return 0;
      }

      if (len != (int)(msg->m_hdr.h_len + sizeof(msg->m_hdr))) {
	  err_log(("Bad mcast recv got %d, expected %d\n", len, msg->m_hdr.h_len));
	  halt(1);
      }
      msg_log(("rec mcast nid %d gid %d type %d seq %d view %d len %d\n",
	       msg->m_hdr.h_sid,msg->m_hdr.h_gid, type = msg->m_hdr.h_type,
	       msg->m_hdr.h_mseq, msg->m_hdr.h_viewnum, msg->m_hdr.h_len));

      gs_msg_handler[msg->m_hdr.h_type](msg);

      msg_log(("Done Type %d\n", type));
  }
}

void
msg_set_uport(int uport)
{
    DEFAULT_PORT = uport;
}

void
msg_set_mport(int mport)
{
    MPORT_NUM = mport;
}

void
msg_set_subnet(char *addr)
{
    strcpy(cl_subnet, addr);
}

void
msg_set_mipaddr(char *addr)
{
}

void
msg_set_bufcount(int count)
{
    MSG_POOL_SZ = count;
}

void
msg_set_bufsize(int size)
{
    if (size > GS_MAX_MSG_SZ) {
	fprintf(stderr,"You are exceeding the 64K msg size limit\n");
    } else {
	GS_MAX_MSG_SZ = size;
    }
}

void
msg_set_mode(int mode)
{
    mcast_enabled = mode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\recovery.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    recovery.c

Abstract:

    Handles node down events

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include <stdio.h>

extern gs_nid_t	GsLocalNodeId;
extern int	GsMaxNodeId;
extern int	GsMinNodeId;
extern gs_group_t	GsGroupTable[];

// Node down event
void
GspRsFree(gs_recovery_state_t *rs)
{
    // free recovery state
    gs_rblk_t	*p;

    while (p = rs->rs_list) {
	rs->rs_list = p->next;
	free((char *)p);
    }

    GsEventFree(rs->rs_event);
    free((char *)rs);
}

void
GspPhase1NodeDown(ULONG	set)
{
    gs_group_t	*gd;
    int i, j;

    for (i = 0; i < GsGroupTableSize; i++) {
	gd = &GsGroupTable[i];
	if (gd->g_state == GS_GROUP_STATE_FREE) {
	    continue;
	}
	GsLockEnter(gd->g_lock);
	if (gd->g_mset & set) {
	    gd->g_mset &= ~set;
	    gd->g_curview++;
	    gd->g_state |= GS_GROUP_FLAGS_RECOVERY;
	    gd->g_sz = 0;
	    for (j = gd->g_mset; j > 0; j = j >> 1) {
		if (j & 0x1)
		    gd->g_sz++;
	    }
	    if (set & (1 << gd->g_mid)) {

		for (j = GsMinNodeId; j != GsMaxNodeId; j++) {
		    if (gd->g_mset & (1 << j)) {
			break;
		    }
		}
		// elect a new master
		gd->g_mid = (gs_memberid_t) j;
		gd->g_state |= GS_GROUP_FLAGS_NEWMASTER;
	    }

	    recovery_log(("Phase1 mask %x gid %d mid %d mset %x sz %d\n",
		      set, gd->g_id, gd->g_mid, gd->g_mset,
		      gd->g_sz));

	    if (gd->g_rs != NULL) {
		set |= gd->g_rs->rs_dset;
		GsEventSignal(gd->g_rs->rs_event);
		GspRsFree(gd->g_rs);
	    }
	    gd->g_rs = (gs_recovery_state_t *) malloc(sizeof(*gd->g_rs));
	    assert(gd->g_rs != NULL);
	    GsManualEventInit(gd->g_rs->rs_event);
	    gd->g_rs->rs_sz = 0;
	    gd->g_rs->rs_list = NULL;
	    gd->g_rs->rs_epoch = gd->g_curview;
	    gd->g_rs->rs_dset = set;
	    gd->g_rs->rs_mset = gd->g_mset;
	    if (gd->g_mid != gd->g_nid) {
		// we are not master, reset our mset to self and master only
		gd->g_rs->rs_mset = (1 << gd->g_nid) | (1 << gd->g_mid);
	    }
	} else if (gd->g_mset == 0 && (set & (1 << gd->g_mid))) {
	    // no one is participating in this group and the sole owner dead
	    // remove the group and free it
	    GsCloseGroup(gd);
	}

	GsLockExit(gd->g_lock);
    }

}

void
GspRsAddSequence(gs_recovery_state_t *rs, gs_sequence_t mseq, int delta)
{
    gs_rblk_t *p, **q;

    for (p = rs->rs_list; p != NULL; p = p->next) {
	if (p->mseq == mseq) {
	    p->have += delta;
	    recovery_log(("Found seq %d cnt %d\n", mseq, p->have));
	    return;
	}
    }
    // if we get here that means the sequence is missing
    p = (gs_rblk_t *) malloc(sizeof(*p));
    if (p == NULL) {
	err_log(("GspRsAddSeq: unable to allocate memory!\n"));
	exit(1);
    }

    p->mseq = mseq;
    p->have = delta;

    recovery_log(("Add seq %d cnt %d\n", mseq, p->have));

    rs->rs_sz++;
    q = &rs->rs_list;
    while (*q != NULL) {
	if ((*q)->mseq > mseq) {
	    p->next = *q;
	    *q = p;
	    return;
	}
	q = &(*q)->next;
    }

    p->next = *q;
    *q = p;
}

void
GspPhase2NodeDown(ULONG set)
{

    gs_group_t	*gd;
    int i, j;

    for (i = 0; i < GsGroupTableSize; i++) {
	gd = &GsGroupTable[i];
	if (!(gd->g_state & GS_GROUP_FLAGS_RECOVERY)) {
	    continue;
	}
	GsLockEnter(gd->g_lock);
	if (gd->g_state & GS_GROUP_FLAGS_RECOVERY) {
	    gs_msg_t *p;
	    extern void GspDumpQueue(gs_group_t*);

	    recovery_log(("Phase2 queue\n"));
	    GspDumpQueue(gd);
	    recovery_log(("Expect gid %d <%d, %d>\n", 
			  gd->g_id, gd->g_recv.r_mseq, gd->g_recv.r_bnum));

	    // walk recv queue and replay messages from dead members
	    for (p = gd->g_recv.r_head; p != NULL; p = p->m_next) {
		if (set & (1 << p->m_hdr.h_sid)) { 
		    // tag message as if we got a reply
		    p->m_hdr.h_flags |= GS_FLAGS_REPLY;
		    if (p->m_hdr.h_type != GS_MSG_TYPE_UCAST){
			p->m_hdr.h_flags |= GS_FLAGS_REPLAY;
			msg_mcast(gd->g_mset, &p->m_hdr, 
				  p->m_buf, p->m_hdr.h_len);
		    }
		    // check of unclosed continued sends
		    if (p->m_hdr.h_flags & GS_FLAGS_CONTINUED) {
			gs_msg_t *q;
			
			q = p->m_next;
			if (q == NULL || 
			    q->m_hdr.h_mseq != p->m_hdr.h_mseq ||
			    q->m_hdr.h_bnum != p->m_hdr.h_bnum+1) {

			    q = msg_alloc(NULL, 0);
			    if (q == NULL) {
				err_log(("Unable to allocate memory!\n"));
				halt(1);
			    }
			    memcpy(&q->m_hdr, &p->m_hdr, sizeof(p->m_hdr));
			    q->m_hdr.h_type = GS_MSG_TYPE_ABORT;
			    q->m_hdr.h_len = 0;
			    q->m_hdr.h_bnum++;
			    q->m_hdr.h_flags = GS_FLAGS_LAST;

			    // insert abort msg
			    q->m_next = p->m_next;
			    p->m_next = q;
			}
		    }
		}
	    }
			    
	    // walk recv queue and build msg of sequences we have
	    for (p = gd->g_recv.r_head; p != NULL; p = p->m_next) {
		if (p->m_hdr.h_mseq != GS_MSG_TYPE_UCAST)
		    GspRsAddSequence(gd->g_rs, p->m_hdr.h_mseq, 1);
	    }

	    // send msg of sequences to master
	    if (gd->g_mid != gd->g_nid) {
		gs_rblk_t *p;
		gs_sequence_t *list;
		int k;
		gs_msg_hdr_t hdr;

		recovery_log(("Sending sequence state to master %d\n", gd->g_mid));

		list = (gs_sequence_t *) malloc(sizeof(*list) * gd->g_rs->rs_sz);
		if (list == NULL) {
		    err_log(("Unable to allocate memory during recovery\n"));
		    exit(1);
		}
		k = 0;
		for (p = gd->g_rs->rs_list; p != NULL; p = p->next) {
		    list[k] = p->mseq;
		    k++;
		}
		assert(k == gd->g_rs->rs_sz);
		k = k * sizeof(*list);

		hdr.h_len = (UINT16) k;
		hdr.h_type = GS_MSG_TYPE_RECOVERY;
		hdr.h_sid = (gs_memberid_t)gd->g_nid;
		hdr.h_mid = (gs_memberid_t) gd->g_mid;
		hdr.h_gid = gd->g_id;
		hdr.h_viewnum = gd->g_curview;
		hdr.h_mseq = gd->g_recv.r_mseq;
		hdr.h_lseq = gd->g_send.s_mseq;
		
		msg_send(gd->g_mid, &hdr, (const char *) list, k);
		free((char *)list);
	    } else {
		// add current sequence to dispatch
		GspRsAddSequence(gd->g_rs, gd->g_recv.r_mseq, 0);
	    }

	    // handle send path
	    for (j = 0; j < gd->g_send.s_wsz; j++) {
		gs_context_t *ctx = &gd->g_send.s_ctxpool[j];
		
		if (ctx->ctx_id != GS_CONTEXT_INVALID_ID && ctx->ctx_msg != NULL){
		    recovery_log(("phase2 gid %d ctx %d mask %x\n",
			      gd->g_id, ctx->ctx_id, ctx->ctx_mask));
		    if (set & ctx->ctx_mask) {
			int k, n;

			recovery_log(("phase2 complete gid %d ctx %d\n",
				  gd->g_id, ctx->ctx_id));
			for (n = 0, k = set; k != 0; k = k >> 1, n++) {
			    if (k & 0x1) {
				GspProcessReply(gd, ctx, n, NULL, 0, 
						STATUS_HOST_UNREACHABLE);
			    }
			}
		    }
		}
	    }
	    
	    // clear this node bit
	    gd->g_rs->rs_mset &= ~(1 << gd->g_nid);
	    if (gd->g_rs->rs_mset == 0) {
		void GspComputeState(gs_group_t *gd);

		GspComputeState(gd);
	    }
		
	}
	GsLockExit(gd->g_lock);
    }
    
}

void GspSyncState(gs_group_t *gd, gs_msg_t *msg, gs_sequence_t *list, int sz);

void
GspComputeState(gs_group_t *gd)
{

    int k;
    gs_sequence_t *list;
    gs_rblk_t *p, *last = NULL;
    gs_msg_t *msg;


    recovery_log(("Compute missing sequences gid %d\n", gd->g_id));

		// compute missing sequences
    list = (gs_sequence_t *) malloc(sizeof(*list) * gd->g_rs->rs_sz);
    if (list == NULL) {
	err_log(("Unable to allocate memory during computestate\n"));
	exit(1);
    }
    k = 0;
    for (p = gd->g_rs->rs_list; p != NULL; p = p->next) {
	recovery_log(("rs list sequence %d\n", p->mseq));
	if (p->have == 0) {
	    recovery_log(("Skip sequence %d\n", p->mseq));
	    list[k] = p->mseq;
	    k++;
	}
	last = p;
    }
    // compute next starting mseq
    gd->g_global_seq = last != NULL ? last->mseq+1 : gd->g_recv.r_mseq;

    k = k * sizeof(*list);

    msg = msg_alloc((char *)list, k);
    assert(msg != NULL);

    msg->m_hdr.h_len = (UINT16) k;
    msg->m_hdr.h_type = GS_MSG_TYPE_SYNC;
    msg->m_hdr.h_flags = GS_FLAGS_LAST;
    msg->m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
    msg->m_hdr.h_mid = (gs_memberid_t) gd->g_mid;
    msg->m_hdr.h_cid = (gs_cookie_t) -1;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_viewnum = gd->g_curview;
    msg->m_hdr.h_mseq = gd->g_global_seq++;
    msg->m_hdr.h_lseq = gd->g_send.s_lseq;
    msg->m_hdr.h_bnum = 0;
    *((ULONG *)msg->m_hdr.h_tag) = gd->g_rs->rs_dset;

		// send missing sequence list to other nodes
    msg_mcast(gd->g_mset, &msg->m_hdr, (const char *) list, k);

    recovery_log(("Next starting sequence is %d\n", gd->g_global_seq));

		// handle self
    GspSyncState(gd, msg, list, k / sizeof(*list));

    free((char *)list);

}

void
GspRecoveryMsgHandler(gs_msg_t *rmsg)

{
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    
    hdr = &rmsg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && rmsg->m_hdr.h_viewnum == gd->g_curview) {
	gs_sequence_t *list;
	int sz, k;

	list = (gs_sequence_t *) rmsg->m_buf;
	sz = rmsg->m_hdr.h_len / sizeof(*list);

	GsLockEnter(gd->g_lock);

	// make sure group is in recovery mode
	assert(gd->g_state & GS_GROUP_FLAGS_RECOVERY);
	assert(gd->g_mid == gd->g_nid);

	// add current sequence to dispatch
	GspRsAddSequence(gd->g_rs, hdr->h_mseq, 0);
	// insert sequences into have list
	for (k = 0; k < sz; k++) {
	    GspRsAddSequence(gd->g_rs, list[k], 1);
	}

	// clear this node bit
	gd->g_rs->rs_mset &= ~(1 << hdr->h_sid);
	if (gd->g_rs->rs_mset == 0) {
	    GspComputeState(gd);
	}	

	GsLockExit(gd->g_lock);
    }

    msg_free(rmsg);

}

void
GspSyncState(gs_group_t *gd, gs_msg_t *msg, gs_sequence_t *list, int sz)

{
    int  k;

    // make sure group is in recovery mode
    assert(gd->g_state & GS_GROUP_FLAGS_RECOVERY);
    assert(gd->g_mid != gd->g_nid);
    assert(gd->g_mid == hdr->h_sid);

    // mark missing sequences
    for (k = 0; k < sz; k++) {
	gs_msg_t *p;

	recovery_log(("Missing sequence %d\n", list[k]));

	p = msg_alloc(NULL, 0);
	if (p == NULL) {
	    err_log(("Unable to allocate memory during syncstate!\n"));
	    halt(1);
	}

	p->m_hdr.h_sid = gd->g_nid;
	p->m_hdr.h_gid = gd->g_id;
	p->m_hdr.h_cid = (gs_cookie_t) -1;
	p->m_hdr.h_type = GS_MSG_TYPE_SKIP;
	p->m_hdr.h_mseq = list[k];
	p->m_hdr.h_lseq = gd->g_send.s_lseq;
	p->m_hdr.h_bnum = 0;
	p->m_hdr.h_flags = GS_FLAGS_LAST;

	GspOrderInsert(gd, p, p, p->m_hdr.h_mseq, 0);
    }

    // set startview to curview
    gd->g_startview = gd->g_curview;
    // clear recovery state
    gd->g_state &= ~GS_GROUP_FLAGS_RECOVERY;
    // free recovery state
    GsEventSignal(gd->g_rs->rs_event);
    GspRsFree(gd->g_rs);
    gd->g_rs = NULL;

    // insert msg into dispatch queue at proper order  
    GspOrderInsert(gd, msg, msg, msg->m_hdr.h_mseq, 0);
    GspDispatch(gd);
#if 0
    // xxx: need to understand this again
    if (gd->g_recv.r_last != NULL) {
	GspCleanQueue(gd, last_mseq);
    }
#endif
    // restart any pending sends
    if (gd->g_send.s_waitqueue != NULL && (gd->g_state & GS_GROUP_FLAGS_NEWMASTER)) {
	recovery_log(("resend: gs %x s %x\n", gd, gd->g_send.s_waitqueue));
	GspAllocateSequence(gd);
    }
    gd->g_state &= ~GS_GROUP_FLAGS_NEWMASTER;
}


void
GspSyncMsgHandler(gs_msg_t *msg)
{
    gs_msg_hdr_t *hdr;
    gs_group_t *gd;
    
    hdr = &msg->m_hdr;

    gd = GspLookupGroup(hdr->h_gid);
    // accept messages only if in a valid view
    if (gd && msg->m_hdr.h_viewnum == gd->g_curview) {
	gs_sequence_t *list;
	int sz;

	list = (gs_sequence_t *) msg->m_buf;
	sz = msg->m_hdr.h_len / sizeof(*list);

	GsLockEnter(gd->g_lock);

	// clear this node bit
	gd->g_rs->rs_mset &= ~(1 << hdr->h_sid);
	assert(gd->g_rs->rs_mset == 0);

	GspSyncState(gd, msg, list, sz);

	GsLockExit(gd->g_lock);
    } else {
	msg_free(msg);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\send.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    send.c

Abstract:

    Send packets

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#include "gs.h"
#include "gsp.h"
#include <stdio.h>


void
GspOpenContext(gs_group_t *gd, gs_context_t **context)
{    
    gs_context_t *ctx;
    int i;

    gs_log(("wait on free ctx gid %d\n", gd->g_id));

    GsSemaAcquire(gd->g_send.s_sema);    
    //xxx: this can be done using atomic instruction
    GsLockEnter(gd->g_lock);
    for (i = 0; i < gd->g_send.s_wsz; i++) {
	ctx = &gd->g_send.s_ctxpool[i];
	if (ctx->ctx_id == GS_CONTEXT_INVALID_ID) {
	    break;
	}
    }
    assert(i != gd->g_send.s_wsz);
    
    ctx->ctx_id = (gs_cookie_t) i;
    ctx->ctx_bnum = 0;

    GsLockExit(gd->g_lock);

    gs_log(("got free ctx %d gid %d\n", i, gd->g_id));
    *context = ctx;
}

void
GspCloseContext(gs_group_t *gd, gs_context_t *ctx)
{

    gs_msg_t *msg;

    assert(gd->g_id == ctx->ctx_gid);

    gs_log(("release ctx %d gid %d\n", ctx->ctx_id, gd->g_id));

    // free/invalidate context
    ctx->ctx_id = GS_CONTEXT_INVALID_ID;

    GsSemaRelease(gd->g_send.s_sema);
}

void CALLBACK timercallback(UINT id, UINT xxmsg, DWORD_PTR data, DWORD dw1, DWORD dw2)
{
    gs_context_t *ctx = (gs_context_t *) data;
    gs_group_t *gd;
    gs_msg_t *msg;

    msg = ctx->ctx_msg;
    if (msg == NULL) {
	return;
    }
    gd = GspLookupGroup(ctx->ctx_gid);
    assert(gd != NULL);
    // resend msg
    GsLockEnter(gd->g_lock);
    msg = ctx->ctx_msg;
    if (msg != NULL) {
	ULONG mask = ctx->ctx_mask;
	gs_memberid_t id;

	// send a reliable point-to-point to non-response nodes
	gs_log(("Timercallback mset %x\n", mask));
	msg->m_hdr.h_flags |= GS_FLAGS_REPLAY;
	for (id = 1; mask; id++, mask = mask >> 1) {
	    if (mask & 0x2) {
		msg_mcast(id, &msg->m_hdr, ctx->ctx_buf, msg->m_hdr.h_len);
	    }
	}
    }
    GsLockExit(gd->g_lock);

}

void
GspProcessReply(gs_group_t *gd, gs_context_t *ctx, int sid, char *buf, int rlen,
		NTSTATUS status)
{
    gs_msg_t	*msg;
    int		ctx_rlen;
    IO_STATUS_BLOCK *ios = ctx->ctx_ios;

    msg = ctx->ctx_msg;
    if (msg == NULL) {
	err_log(("Error invalid msg in ctx %d, gid %d\n", ctx->ctx_id, gd->g_id));
	GsEventSignal(ctx->ctx_event);
	//xxx: for debugging
	halt(0);
	return;
    }

   if (rlen > 0) {
       PVOID *p = ctx->ctx_rbuf;
 
       rlen = min(rlen , msg->m_hdr.h_rlen);
       if (p != NULL) {
	   if (msg->m_hdr.h_type == GS_MSG_TYPE_MCAST) {
	       p += (sid - 1);
	       ios += (sid - 1);
	   }

	   memcpy(*p, buf, rlen);
       }

   } else if (msg->m_hdr.h_type == GS_MSG_TYPE_MCAST) {
       ios += (sid - 1);
   }
   ios->Status = status;
   ios->Information = rlen;

   ctx->ctx_mask &= ~(1 << sid);

   gs_log(("process reply len %d gid %d cid %d nid %d mseq %d sz %d mask %x ios %x\n", 
	     rlen, gd->g_id, ctx->ctx_id,
	     sid, msg->m_hdr.h_mseq, msg->m_hdr.h_rlen, ctx->ctx_mask, ios));

   if (ctx->ctx_mask == 0) {
       gs_event_t ev = ctx->ctx_event;

       if (ctx->ctx_timer) {
	   timeKillEvent(ctx->ctx_timer);
	   ctx->ctx_timer = 0;
       }

       ctx->ctx_msg = NULL;
       gd->g_send.s_lseq = msg->m_hdr.h_mseq;
       // free msg and signal waiter
       GspRemoveMsg(gd, msg);
#if 0
       if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	   GspCloseContext(gd, ctx);
       }
#endif
       if (ev) {
	   gs_log(("Signal ctx %d\n", ctx->ctx_id));
	   GsEventSignal(ev);
       }
   } else {
       gs_log(("Waiting for more replies %x\n", ctx->ctx_mask));
       // place ctx into timer queue if we haven't already done so
       if (sid == (int)gd->g_nid) {
	   ctx->ctx_timer = timeSetEvent(500, 0, (LPTIMECALLBACK)timercallback,
					 (DWORD_PTR)ctx, TIME_ONESHOT);
	   if (ctx->ctx_timer == 0) {
	       printf("Unable to create timer %d\n", GetLastError());
	   }
       }
   }
}

void
GspProcessWaitQueue(gs_group_t *gd, gs_seq_info_t *info)
{
    int i;
    gs_msg_t	*last, *cur;
    gs_send_state_t *ss;

    gs_log(("Process wait queue mid %d mseq %d view %d\n", 
	    gd->g_mid, info->mseq, info->viewnum));

    ss = &gd->g_send;
    
    // sequence all ready requests
    cur = ss->s_waitqueue;
    if (cur == NULL) {
	err_log(("Gid %d Empty wait queue!\n", gd->g_id));
	halt(1);
    }

    for (i = 0;  cur != NULL; i++) {
	cur->m_hdr.h_mseq = info->mseq;
	cur->m_hdr.h_bnum = i * (1 << 16);
	cur->m_hdr.h_mid = gd->g_mid;
	cur->m_hdr.h_viewnum = info->viewnum;
	// piggyback our receive state
	cur->m_hdr.h_lseq = gd->g_send.s_lseq;
	if (cur->m_next == NULL) {
	    cur->m_hdr.h_flags |= GS_FLAGS_LAST;
	}
	msg_mcast(gd->g_mset, &cur->m_hdr, cur->m_buf, cur->m_hdr.h_len);

	{
	    gs_context_t *sc;

	    sc = &ss->s_ctxpool[cur->m_hdr.h_cid];
	    sc->ctx_mseq = cur->m_hdr.h_mseq;
	    sc->ctx_bnum = cur->m_hdr.h_bnum + 1;
	    sc->ctx_flags = cur->m_hdr.h_flags;
	}


	last = cur;
	cur = cur->m_next;
    }
    // Insert waitqueue into receive side queue
    cur = ss->s_waitqueue;
    ss->s_waitqueue = NULL;  
    ss->s_mseq = info->mseq+1;
    ss->s_bnum = 0;

    GspOrderInsert(gd, cur, last, info->mseq, 0);

    GspDispatch(gd);

}

void
GspAllocateSequence(gs_group_t *gd)
{

    gs_seq_info_t info;
    gs_msg_t msg;

    assert(gd->g_send.s_waitqueue != NULL);

    if (gd->g_mid == gd->g_nid) {
	info.mseq = gd->g_global_seq++;
	info.viewnum = gd->g_curview;
	GspProcessWaitQueue(gd, &info);
    } else {
	// remote case

	gs_log(("Allocate a seq from mid %x view %d,%d\n", gd->g_mid,
		gd->g_startview, gd->g_curview));

	msg.m_hdr.h_len = 0;
	msg.m_hdr.h_type = GS_MSG_TYPE_SEQALLOC;
	msg.m_hdr.h_flags = GS_FLAGS_PTP;
	msg.m_hdr.h_viewnum = gd->g_curview;
	msg.m_hdr.h_rlen = sizeof(info);
	msg.m_hdr.h_cid = 0;
	msg.m_hdr.h_gid = gd->g_id;
	msg.m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
	msg.m_hdr.h_mid = gd->g_mid;

	msg.m_hdr.h_mseq = gd->g_send.s_mseq;
	msg.m_hdr.h_lseq = gd->g_send.s_lseq;
	msg.m_hdr.h_bnum = 0;
	memset(msg.m_hdr.h_tag, 0, sizeof(msg.m_hdr.h_tag));

	msg_send(gd->g_mid, &msg.m_hdr, NULL, 0);
    }

}
	
NTSTATUS
WINAPI
GsSendDeliveredRequest(HANDLE group, gs_event_t event OPTIONAL,
		       gs_tag_t tag, PVOID buf, UINT32 len, 
		       PVOID rbuf[], UINT32 rlen,
		       IO_STATUS_BLOCK ios[],
		       HANDLE *context)
{
    gs_context_t *ctx;
    gs_group_t *gd = (gs_group_t *)group;
    gs_send_state_t *ss;
    BOOLEAN flag;
    gs_msg_t *msg;

    if (gd == NULL || ios == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    GspOpenContext(gd, &ctx);
    ctx->ctx_flags = GS_FLAGS_DELIVERED;
    if (context != NULL) {
	ctx->ctx_flags |= GS_FLAGS_CONTINUED;
	*context = ctx;
    } else {
	ctx->ctx_flags |= GS_FLAGS_CLOSE;
    }
    ctx->ctx_buf = buf; 
    ctx->ctx_rbuf = rbuf; 
    ctx->ctx_ios = ios;
    if (event == NULL)
	event = ctx->ctx_syncevent;
    ctx->ctx_event = event;
    
    msg = msg_alloc(buf, len);

    assert(msg != NULL);

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = GS_MSG_TYPE_MCAST;
    msg->m_hdr.h_flags = ctx->ctx_flags | GS_FLAGS_QUEUED;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));

    ss = &gd->g_send;

    // place context into readylist
    GsLockEnter(gd->g_lock);
    flag = ss->s_waitqueue == NULL ? TRUE : FALSE; 
    msg->m_next = ss->s_waitqueue;
    ss->s_waitqueue = msg;

    ctx->ctx_mask = gd->g_mset;
    ctx->ctx_msg = msg;
    msg->m_refcnt++;

    // check if we have already asked for a global sequence number
    if (flag == TRUE)  {
	GspAllocateSequence(gd);
    }
    
    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (event) {
	gs_log(("Wait on event %x\n", event));
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }

    return ERROR_SUCCESS;
}

NTSTATUS
GsSendContinuedRequest(HANDLE context, gs_event_t event OPTIONAL,
		       gs_tag_t tag, PVOID buf, UINT32 len, 
		       PVOID rbuf[], UINT32 rlen,
		       IO_STATUS_BLOCK ios[],
		       BOOLEAN close)
{
    gs_context_t *ctx = (gs_context_t *) context;
    gs_group_t *gd;
    gs_send_state_t *ss;
    BOOLEAN flag;
    gs_msg_t *msg;

    if (ctx == NULL || ios == NULL) {
	return ERROR_INVALID_PARAMETER;
    }

    if (rbuf == NULL && rlen > 0) {
	return ERROR_INVALID_PARAMETER;
    }
    if (buf == NULL && len > 0) {
	return ERROR_INVALID_PARAMETER;
    }

    gd = GspLookupGroup(ctx->ctx_gid);
    assert(gd != NULL);

    msg = msg_alloc(buf, len);
    assert(msg != NULL);

    if (close == TRUE) {
	ctx->ctx_flags &= ~GS_FLAGS_CONTINUED;
	ctx->ctx_flags |= GS_FLAGS_CLOSE;
    }
    if (event == NULL)
	event = ctx->ctx_syncevent;
    ctx->ctx_event = event;

    ctx->ctx_buf = buf; 
    ctx->ctx_rbuf = rbuf; 
    ctx->ctx_ios = ios;
    ctx->ctx_msg = msg;

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = GS_MSG_TYPE_MCAST;
    msg->m_hdr.h_flags = ctx->ctx_flags | GS_FLAGS_QUEUED;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = gd->g_nid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));
    msg->m_hdr.h_mseq = ctx->ctx_mseq;
    msg->m_hdr.h_bnum = ctx->ctx_bnum++;

    GsLockEnter(gd->g_lock);

    msg->m_hdr.h_lseq = gd->g_send.s_lseq;

    msg->m_hdr.h_mid = gd->g_mid;
    msg->m_hdr.h_viewnum = gd->g_curview;

    ctx->ctx_mask = gd->g_mset;
    msg->m_refcnt++;

    msg_mcast(gd->g_mset, &msg->m_hdr, buf, len);

    GspOrderInsert(gd, msg, msg, ctx->ctx_mseq, ctx->ctx_bnum);

    GspDispatch(gd);

    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (event != NULL) {
	gs_log(("Wait on event %x\n", event));
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }

    return ERROR_SUCCESS;
}

NTSTATUS
GspSendDirectedRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t event,
		       int memberid, gs_tag_t tag,
		       PVOID buf, UINT32 len, 
		       PVOID rbuf, UINT32 rlen,
		       IO_STATUS_BLOCK *ios,
		       UINT32 flags, UINT32 type)
{
    gs_send_state_t *ss;
    gs_nid_t mid;
    gs_msg_t *msg;
    int err = ERROR_SUCCESS;

    if (rlen > (UINT32)GS_DEFAULT_MAX_MSG_SZ) {
	return ERROR_INVALID_PARAMETER;
    }

    assert(gd != NULL);
    msg = msg_alloc(buf, len);

    assert(msg != NULL);

    if (event == NULL)
	event = ctx->ctx_syncevent;

    ctx->ctx_flags = (UINT16) flags;
    ctx->ctx_event = event;
    ctx->ctx_buf = buf;
    ctx->ctx_rbuf = rbuf;
    ctx->ctx_ios = ios;

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = (UINT16) type;
    msg->m_hdr.h_flags = ctx->ctx_flags | GS_FLAGS_PTP;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = gd->g_nid;
    msg->m_hdr.h_mid = (gs_memberid_t) memberid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));

    GsLockEnter(gd->g_lock);

    ctx->ctx_msg = msg;
    ctx->ctx_mask = 1 << memberid;

    ss = &gd->g_send;

    msg->m_hdr.h_lseq = ss->s_lseq;
    msg->m_hdr.h_mseq = ss->s_mseq;
    msg->m_hdr.h_bnum = ss->s_bnum++;
    msg->m_hdr.h_viewnum = gd->g_curview;

    if (gd->g_nid == (gs_memberid_t )memberid) {
	// insert into receive queue
	msg->m_refcnt++;
	msg->m_hdr.h_flags |= GS_FLAGS_QUEUED;
	// insert msg into dispatch queue at proper order  
	GspUOrderInsert(gd, msg, msg, msg->m_hdr.h_mseq, msg->m_hdr.h_bnum);
	GspDispatch(gd);  
    } else {
	err = msg_send((gs_memberid_t) memberid, &msg->m_hdr, buf, len);
    }

    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (!err && event != NULL) {
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }

    return err;
}


NTSTATUS
WINAPI
GsSendDirectedRequest(HANDLE group, gs_event_t event OPTIONAL,
		      int memberid, gs_tag_t tag,
		      PVOID buf, UINT32 len, 
		      PVOID rbuf, UINT32 rlen,
		      IO_STATUS_BLOCK *ios,
		      HANDLE *context)
{
    gs_group_t *gd = (gs_group_t *)group;
    gs_context_t *ctx;
    NTSTATUS err;

    if (gd == NULL) { 
	return ERROR_INVALID_HANDLE;
    }

    GspOpenContext(gd, &ctx);

    ctx->ctx_flags = GS_FLAGS_DELIVERED | GS_FLAGS_CONTINUED;
    if (context != NULL) {
	ctx->ctx_flags |= GS_FLAGS_CONTINUED;
	*context = ctx;
    } else {
	ctx->ctx_flags |= GS_FLAGS_CLOSE;
    }

    err = GspSendDirectedRequest(gd, ctx, event, 
				 memberid, tag, buf, len, rbuf, rlen, 
				 ios,
				 ctx->ctx_flags, GS_MSG_TYPE_UCAST);

    if (err != ERROR_SUCCESS) {
	GspCloseContext(gd, ctx);
    }

    return err;
}


NTSTATUS
GspSendRequest(gs_group_t *gd, gs_context_t *ctx, gs_event_t event,
	       int type, gs_sequence_t mid, gs_tag_t tag, 
	       PVOID buf, UINT32 len, 
	       PVOID rbuf[], UINT32 rlen,
	       IO_STATUS_BLOCK ios[],
	       UINT32 flags, gs_join_info_t *info)
{
    gs_send_state_t *ss;
    BOOLEAN flag;
    gs_msg_t *msg;

    assert(gd != NULL);
    msg = msg_alloc(buf, len);

    assert(msg != NULL);

    msg->m_hdr.h_len = (UINT16) len;
    msg->m_hdr.h_type = (UINT16) type;
    msg->m_hdr.h_flags = (UINT16) flags;
    msg->m_hdr.h_rlen = (UINT16) rlen;
    msg->m_hdr.h_cid = ctx->ctx_id;
    msg->m_hdr.h_gid = gd->g_id;
    msg->m_hdr.h_sid = (gs_memberid_t) gd->g_nid;
    memcpy(msg->m_hdr.h_tag, tag, sizeof(gs_tag_t));
    msg->m_hdr.h_mseq = info->mseq;
    msg->m_hdr.h_lseq = info->mseq;
    msg->m_hdr.h_bnum = ctx->ctx_bnum++;
    msg->m_hdr.h_mid = (gs_memberid_t) mid;
    msg->m_hdr.h_viewnum = info->viewnum;

    if (event == NULL)
	event = ctx->ctx_syncevent;
    ctx->ctx_buf = buf; 
    ctx->ctx_rbuf = rbuf; 
    ctx->ctx_ios = ios;
    ctx->ctx_event = event;
    ctx->ctx_msg = msg;
    ctx->ctx_mask = info->mset;
    ctx->ctx_mseq = info->mseq;
    ctx->ctx_flags = (UINT16) flags;

    GsLockEnter(gd->g_lock);

    gd->g_send.s_mseq = info->mseq+1;
    gd->g_send.s_bnum = 0;

    msg_mcast(info->mset, &msg->m_hdr, buf, len);

    if (info->mset & (1 << gd->g_nid)) {
	msg->m_hdr.h_flags |= GS_FLAGS_QUEUED;
	msg->m_refcnt++;
	GspOrderInsert(gd, msg, msg, info->mseq, msg->m_hdr.h_bnum);
	GspDispatch(gd);
    } else {
	msg->m_hdr.h_flags |= GS_FLAGS_PTP;
	ctx->ctx_timer = timeSetEvent(500, 0, (LPTIMECALLBACK)timercallback,
				      (DWORD_PTR)ctx, TIME_PERIODIC);
	if (ctx->ctx_timer == 0) {
	    printf("Unable to create timer %d\n", GetLastError());
	}
    }

    GsLockExit(gd->g_lock);

    // wait for replies or acks
    if (event != NULL) {
	GsEventWait(event);
    }

    if (ctx->ctx_flags & GS_FLAGS_CLOSE) {
	GspCloseContext(gd, ctx);
    }


    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gs\type.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    type.h

Abstract:

    GS types

Author:

    Ahmed Mohamed (ahmedm) 12, 01, 2000

Revision History:

--*/

#ifndef GS_TYPE_H
#define GS_TYPE_H

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <Windows.h>
#include <stdlib.h>

typedef UINT32		gs_sequence_t;
typedef CRITICAL_SECTION	gs_lock_t;
typedef HANDLE		gs_semaphore_t;
typedef	ULONG		gs_addr_t;
typedef UINT16		gs_nid_t;
typedef UINT32		gs_gid_t;
typedef HANDLE		gs_event_t;
typedef ULONG		gs_mset_t;
typedef unsigned short UINT16;
typedef UINT16		gs_cookie_t;
typedef UINT16		gs_memberid_t;
typedef unsigned char	UINT8;

#define GsLockInit(x)	InitializeCriticalSection(&x)
#define	GsLockEnter(x)	EnterCriticalSection(&x)
#define	GsLockExit(x)	LeaveCriticalSection(&x)

#define	GsSemaInit(x, cnt)	((x) = CreateSemaphore(NULL, cnt,cnt, NULL))
#define	GsSemaAcquire(x)	WaitForSingleObject(x, INFINITE)
#define	GsSemaRelease(x)	ReleaseSemaphore(x, 1, NULL);
#define	GsSemaFree(x)		CloseHandle(x)

#define	GsManualEventInit(x)	((x) = CreateEvent(NULL, TRUE, FALSE, NULL))
#define	GsEventInit(x)		((x) = CreateEvent(NULL, FALSE, FALSE, NULL))
#define	GsEventWait(x)		WaitForSingleObject(x, INFINITE)
//#define	GsEventWait(x)		WaitForSingleObject(x, 1000*60) != WAIT_OBJECT_0 ? printf("Timed out\n"), halt(0) : 0
#define	GsEventSignal(x)	SetEvent(x)
#define	GsEventClear(x)		ResetEvent(x)
#define	GsEventFree(x)		CloseHandle(x)

#define	GsEventWaitTimeout(a,t) \
(WaitForSingleObject(a, (t)->LowPart) == WAIT_OBJECT_0)

#define	GspAtomicDecrement(x)	InterlockedDecrement((PLONG) &x)

#define	GspAtomicRemoveHead(head, x)	for(x=head; InterlockedCompareExchange((LONG *)&head, (LONG)x, (LONG)x->ctx_next) == (LONG) x;);

#define	GspAtomicInsertHead(head, x)	for(x->ctx_next = head; InterlockedCompareExchange((LONG *)&head, (LONG) x->ctx_next, (LONG)x) != (LONG) x; );

extern void halt(int);

#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\join.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    join.c

Abstract:

    GUM routines to implement the special join updates.

Author:

    John Vert (jvert) 6/10/1996

Revision History:

--*/
#include "gump.h"

//
// Define structure used to pass arguments to node enumeration callback
//
typedef struct _GUMP_JOIN_INFO {
    GUM_UPDATE_TYPE UpdateType;
    DWORD Status;
    DWORD Sequence;
    DWORD LockerNode;
} GUMP_JOIN_INFO, *PGUMP_JOIN_INFO;

//
// Local function prototypes
//
BOOL
GumpNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


DWORD
GumBeginJoinUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    OUT DWORD *Sequence
    )
/*++

Routine Description:

    Begins the special join update for a joining node. This
    function gets the current GUM sequence number for the
    specified update type from another node in the cluster.
    It also gets the list of nodes currently participating
    in the updates.

Arguments:

    UpdateType - Supplies the GUM_UPDATE_TYPE.

    Sequence - Returns the sequence number that should be
        passed to GumEndJoinUpdate.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    GUMP_JOIN_INFO JoinInfo;

    //
    // Enumerate the list of nodes. The callback routine will attempt
    // to obtain the required information from each node that is online.
    //
    JoinInfo.Status = ERROR_GEN_FAILURE;
    JoinInfo.UpdateType = UpdateType;
    OmEnumObjects(ObjectTypeNode,
                  GumpNodeCallback,
                  &JoinInfo,
                  NULL);
    if (JoinInfo.Status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
                      "[GUM] GumBeginJoinUpdate succeeded with sequence %1!d! for type %2!u!\n",
                      JoinInfo.Sequence,
                      UpdateType);
        *Sequence = JoinInfo.Sequence;
    }

    return(JoinInfo.Status);
}

DWORD
WINAPI
GumEndJoinUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Conditionally sends a join update to all active nodes in the
    cluster. If the clusterwise sequence number matches the supplied
    sequence number, all registered update handlers for the specified
    UpdateType are called on each node. Any registered update handlers
    for the current node will be called on the same thread. This is
    useful for correct synchronization of the data structures to be updated.

    As each node receives the join update, the sending node will be
    added to the list of nodes registered to receive any future updates
    of this type.

    The normal usage of this routine is as follows:
         joining node gets current sequence number from GumBeginJoinUpdate
         joining node gets current cluster state from another cluster node
         joining node issues GumEndJoinUpdate to add itself to every node's
          update list.
         If GumEndJoinUpdate fails, try again

Arguments:

    Sequence - Supplies the sequence number obtained from GumGetCurrentSequence.

    UpdateType - Supplies the type of update. This determines which update handlers
        will be called

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to be passed to the
        update handlers

    Buffer - Supplies a pointer to the update buffer to be passed to the update
        handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/
{
    DWORD       Status=RPC_S_OK;
    DWORD       i;
    PGUM_INFO   GumInfo;
    DWORD       MyNodeId;
    DWORD       LockerNode=(DWORD)-1;
    DWORD       dwGenerationNum; //the generation number at which the joiner gets the lock
    BOOL        AssumeLockerWhistler;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    LockerNode = GumpLockerNode;

    //SS: bug can we be the locker node at this point in time?
    //CL_ASSERT(LockerNode != MyNodeId);
    //
    // Verify that the locker node allows us to finish the join update
    //
    if (LockerNode != MyNodeId)
    {

        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumEndJoinUpdate: attempting update\ttype %1!u! context %2!u! sequence %3!u!\n",
                   UpdateType,
                   Context,
                   Sequence);
        //SS: what if the joiner node acquires the lock but dies after
        //will the remaining cluster continue to function ??
        //We need to make sure that node down events are generated
        //for this node as soon as the first gumbeginjoinupdate call
        //is made
        AssumeLockerWhistler = TRUE;
RetryJoinUpdateForRollingUpgrade:        
        NmStartRpc(LockerNode);
        if (AssumeLockerWhistler)
        {
            Status = GumAttemptJoinUpdate2(GumpRpcBindings[LockerNode],
                                      NmGetNodeId(NmLocalNode),
                                      UpdateType,
                                      Context,
                                      Sequence,
                                      BufferLength,
                                      Buffer, 
                                      &dwGenerationNum);
        }
        else
        {
            Status = GumAttemptJoinUpdate(GumpRpcBindings[LockerNode],
                                      NmGetNodeId(NmLocalNode),
                                      UpdateType,
                                      Context,
                                      Sequence,
                                      BufferLength,
                                      Buffer);

        }
        NmEndRpc(LockerNode);
        if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            AssumeLockerWhistler = FALSE;
            goto RetryJoinUpdateForRollingUpgrade;
        }
        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] Join attempt for type %1!d! failed %2!d!\n",
                       UpdateType,
                       Status);
            NmDumpRpcExtErrorInfo(Status);
            return(Status);
        }
        //if the locker node dies, should we retry with the locker node?
        //In this case, the locker node may be different
        //now from when GumBeginJoinUpdate() is called.
        //SS: we fail the join instead and just retry the whole process
        //instead of calling GumpCommFailure() to kill the locker here.
        // This way the existing cluster continues and the joining node
        // takes a hit which is probably a good thing
    }
    else
    {
        //SS: can we select ourselves as the locker while
        //we havent finished the join completely
        //SS: can others?
        //Is that valid
        Status = ERROR_REQUEST_ABORTED;
        return(Status);
    }
    //  If the joining node dies after having acquired the lock,
    //  then a node down event MUST be generated so that the GUM
    //  lock can be released and the rest of the cluster can continue.
    //
    // Now Dispatch the update to all other nodes, except ourself.
    //
    for (i=LockerNode+1; i != LockerNode; i++)
    {
        if (i == (NmMaxNodeId + 1))
        {
            i=ClusterMinNodeId;
            if (i==LockerNode)
            {
                break;
            }
        }

        if (GumInfo->ActiveNode[i])
        {

            //skip yourself
            if (i != MyNodeId)
            {
                CL_ASSERT(GumpRpcBindings[i] != NULL);
                ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumEndJoinUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);

                NmStartRpc(i);
                Status = GumJoinUpdateNode(GumpRpcBindings[i],
                                           NmGetNodeId(NmLocalNode),
                                           UpdateType,
                                           Context,
                                           Sequence,
                                           BufferLength,
                                           Buffer);
                NmEndRpc(i);
                if (Status != ERROR_SUCCESS)
                {
                    //we dont shoot that node, since we are the ones who is joining
                    //However now its tables differ from the locker node's tables
                    //Instead we will release the gum lock and abort
                    //the join process.  This joining node should then
                    //be removed from the locker node's tables for update.
                    //
                    ClRtlLogPrint(LOG_NOISE,
                        "[GUM] GumEndJoinUpdate: GumJoinUpdateNode failed \ttype %1!u! context %2!u! sequence %3!u!\n",
                        UpdateType,
                        Context,
                        Sequence);
                    NmDumpRpcExtErrorInfo(Status);
                    break;
                }
            }
        }
    }

    CL_ASSERT(LockerNode != (DWORD)-1);

    if (Status != ERROR_SUCCESS)
    {
        goto EndJoinUnlock;
    }

    //
    // All nodes have been updated. Update our sequence and send the unlocking update.
    //
    GumTable[UpdateType].Joined = TRUE;
    GumpSequence = Sequence+1;

EndJoinUnlock:
    //SS  what if the locker node has died since then
    //we should make sure somebody unlocks and keeps the cluster going
    //Since we always try the unlock against the locker from whom we 
    //got the lock, we will assume that the AssumeLockerWhistler is correctly
    //set now
    try {
        NmStartRpc(LockerNode);
        if (AssumeLockerWhistler)
        {
            GumUnlockUpdate2(GumpRpcBindings[LockerNode], UpdateType, Sequence, 
                NmGetNodeId(NmLocalNode), dwGenerationNum);
        }            
        else
        {
            GumUnlockUpdate(GumpRpcBindings[LockerNode], UpdateType, Sequence);
        }                        
        NmEndRpc(LockerNode);
    } except (I_RpcExceptionFilter(RpcExceptionCode())) {
        //
        // The locker node has crashed. Notify the NM, it will call our
        // notification routine to select a new locker node. Then retry
        // the unlock on the new locker node.
        // SS: changed to not retry unlocks..the new locker node will
        // unlock after propagating this change in any case.
        //
        NmEndRpc(LockerNode);
        Status = GetExceptionCode();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] GumEndJoinUpdate: Unlocking update to node %1!d! failed with %2!d!\n",
                   LockerNode,
                   Status);
        //instead of killing the locker node in the existing cluster which
        //we are trying to join, return a failure code which will abort the join
        //process. Since this is the locking node, when this node goes down the
        //new locker node should release the lock

        NmDumpRpcExtErrorInfo(Status);
    }


    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumEndJoinUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               UpdateType,
               Context);

    return(Status);
}


BOOL
GumpNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Node enumeration callback routine for GumBeginJoinUpdate. For each
    node that is currently online, it attempts to connect and obtain
    the current GUM information (sequence and nodelist) for the specified
    update type.

Arguments:

    Context1 - Supplies a pointer to the GUMP_JOIN_INFO structure.

    Context2 - not used

    Object - Supplies a pointer to the NM_NODE object

    Name - Supplies the node's name.

Return Value:

    FALSE - if the information was successfully obtained and enumeration
            should stop.

    TRUE - If enumeration should continue.

--*/

{
    DWORD Status;
    DWORD Sequence;
    PGUMP_JOIN_INFO JoinInfo = (PGUMP_JOIN_INFO)Context1;
    PGUM_NODE_LIST NodeList = NULL;
    PNM_NODE Node = (PNM_NODE)Object;
    GUM_UPDATE_TYPE UpdateType;
    DWORD i;
    DWORD LockerNodeId;
    DWORD nodeId;

    if (NmGetNodeState(Node) != ClusterNodeUp &&
        NmGetNodeState(Node) != ClusterNodePaused){
        //
        // This node is not up, so don't try and get any
        // information from it.
        //
        return(TRUE);
    }

    //
    // Get the sequence and nodelist information from this node.
    //
    UpdateType = JoinInfo->UpdateType;
    if (UpdateType != GumUpdateTesting) {
        //
        // Our node should not be marked as ClusterNodeUp yet.
        //
        CL_ASSERT(Node != NmLocalNode);
    }

    nodeId = NmGetNodeId(Node);
    NmStartRpc(nodeId);
    Status = GumGetNodeSequence(GumpRpcBindings[NmGetNodeId(Node)],
                                UpdateType,
                                &Sequence,
                                &LockerNodeId,
                                &NodeList);
    NmEndRpc(nodeId);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumGetNodeSequence from %1!ws! failed %2!d!\n",
                   OmObjectId(Node),
                   Status);
        NmDumpRpcExtErrorInfo(Status);
        return(TRUE);
    }

    JoinInfo->Status = ERROR_SUCCESS;
    JoinInfo->Sequence = Sequence;
    JoinInfo->LockerNode = LockerNodeId;

    //
    // Zero out all the nodes in the active node array.
    //
    ZeroMemory(&GumTable[UpdateType].ActiveNode,
               sizeof(GumTable[UpdateType].ActiveNode));

    //
    // Set all the nodes that are currently active in the
    // active node array.
    //
    for (i=0; i < NodeList->NodeCount; i++) {
        CL_ASSERT(NmIsValidNodeId(NodeList->NodeId[i]));
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpNodeCallback setting node %1!d! active.\n",
                   NodeList->NodeId[i]);
        GumTable[UpdateType].ActiveNode[NodeList->NodeId[i]] = TRUE;;
    }
    MIDL_user_free(NodeList);

    //
    // Add in our own node.
    //
    GumTable[UpdateType].ActiveNode[NmGetNodeId(NmLocalNode)] = TRUE;

    //
    // Set the current locker node
    //
    GumpLockerNode = LockerNodeId;
    return(FALSE);

}


DWORD
GumCreateRpcBindings(
    PNM_NODE  Node
    )
/*++

Routine Description:

    Creates GUM's private RPC bindings for a joining node.
    Called by the Node Manager.

Arguments:

    Node - A pointer to the node for which to create RPC bindings

Return Value:

    A Win32 status code.

--*/
{
    DWORD               Status;
    RPC_BINDING_HANDLE  BindingHandle;
    CL_NODE_ID          NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Creating RPC bindings for node %1!u!.\n",
        NodeId
        );

    //
    // Main binding
    //
    if (GumpRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(GumpRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to verify 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(GumpRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to create 1st RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    //
    // Replay binding
    //
    if (GumpReplayRpcBindings[NodeId] != NULL) {
        //
        // Reuse the old binding.
        //
        Status = ClMsgVerifyRpcBinding(GumpReplayRpcBindings[NodeId]);

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to verify 2nd RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }
    else {
        //
        // Create a new binding
        //
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &(GumpReplayRpcBindings[NodeId]),
                                0 );

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_ERROR, 
                "[GUM] Failed to create 2nd RPC binding for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
            return(Status);
        }
    }

    return(ERROR_SUCCESS);

} // GumCreateRpcBindings
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\marshal.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    marshal.c

Abstract:

    Implements some common GUM apis for marshalling and unmarshalling
    arguments to GUM update procedures.

Author:

    John Vert (jvert) 8/27/1996

Revision History:

--*/
#include "gump.h"


PVOID
GumpMarshallArgs(
    IN DWORD ArgCount,
    IN va_list ArgList,
    OUT DWORD *pBufferSize
    )
/*++

Routine Description:

    Helper routine for marshalling up a bunch of arguments into
    a single buffer.

Arguments:

    ArgCount - Supplies the number of arguments.

    ArgList - Supplies the variable length arguments. These must come
        in pairs, so there must be 2*ArgCount additional arguments.

    pBufferSize - Returns the length of the allocated buffer.

Return Value:

    A pointer to the allocated buffer. The caller must free this.

    NULL on failure.

--*/

{
    DWORD i;
    DWORD BufSize;
    DWORD Length;
    LPDWORD Buffer;
    PUCHAR Pointer;
    PUCHAR Source;
    va_list OriginalList;


    OriginalList = ArgList;

    //
    // round ArgCount to an even number. This causes the first data area to be
    // quadword aligned
    //
    BufSize = (( ArgCount + 1 ) & ~1 ) * sizeof(DWORD);

    //
    // the va_list is a set of (length, pointer) tuples.
    //
    for (i=0; i < ArgCount; i++) {
        Length = va_arg(ArgList, DWORD);

        //
        // Round up to architecture appropriate boundary.
        //
        Length = (Length + (sizeof(DWORD_PTR) - 1 )) & ~( sizeof(DWORD_PTR) - 1 );
        BufSize += Length;

        va_arg(ArgList, PUCHAR);
    }

    Buffer = LocalAlloc(LMEM_FIXED, BufSize);
    if (Buffer == NULL) {
        return(NULL);
    }
    *pBufferSize = BufSize;

    //
    // Now copy in all the arguments
    //
    // Set Pointer to point after the array of offsets.
    //

    Pointer = (PUCHAR)(Buffer + (( ArgCount + 1 ) & ~1 ));
    for (i=0; i < ArgCount; i++) {

        //
        // Set offset of argument in array
        //
        // Since this is an offset in a buffer where BufSize < 2^32 then it 
        // is reasonable that Pointer - Buffer should be < 2^32
        //

        Buffer[i] = (DWORD)(Pointer - (PUCHAR)Buffer);
        Length = va_arg(OriginalList, DWORD);
        Source = va_arg(OriginalList, PUCHAR);
        CopyMemory(Pointer, Source, Length);

        //
        // Round up to architecture appropriate boundary.
        //
        Length = (Length + (sizeof(DWORD_PTR) - 1 )) & ~( sizeof(DWORD_PTR) - 1 );

        //
        // Adjust pointer for next argument.
        //
        Pointer += Length;
    }

    return(Buffer);

}


DWORD
GumSendUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    )

/*++

Routine Description:

    Sends an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated.

    This is different than GumSendUpdate in that it takes a
    variable number of arguments. The number of variable
    arguments is specified by the ArgCount argument. The format
    is pairs of length/pointer arguments. For example:
    GumSendUpdateEx(UpdateType,
                    MyContext,
                    3,
                    Length1, Pointer1,
                    Length2, Pointer2,
                    Length3, Pointer3);

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    DispatchIndex - Supplies an index into the dispatch table
        for the specified update type. The receiving side will
        unmarshall the arguments and call the update routine
        for this dispatch index.

    ArgCount - Supplies the number of arguments.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/

{
    PVOID Buffer;
    DWORD BufLength;
    DWORD Status;
    va_list arglist;

    //
    // Make sure there is really a handler for this dispatch routine.
    //
    if (GumTable[UpdateType].Receivers != NULL) {
        CL_ASSERT(DispatchIndex < GumTable[UpdateType].Receivers->DispatchCount);
    }

    //
    // Format the arguments into a common buffer.
    //
    va_start(arglist, ArgCount);
    Buffer = GumpMarshallArgs(ArgCount, arglist, &BufLength);
    va_end(arglist);
    if (Buffer == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Status = GumSendUpdate(UpdateType,
                           DispatchIndex,
                           BufLength,
                           Buffer);
    LocalFree(Buffer);

    return(Status);

}

DWORD
GumSendUpdateExReturnInfo(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    OUT PGUM_NODE_UPDATE_HANDLER_STATUS ReturnStatusBuffer,
    IN DWORD ArgCount,
    ...
    )

/*++

Routine Description:

    Sends an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated.

    This is different than GumSendUpdate in that it takes a
    variable number of arguments. The number of variable
    arguments is specified by the ArgCount argument. The format
    is pairs of length/pointer arguments. For example:
    GumSendUpdateExReturnInfo(UpdateType,
                              MyContext,
                              MyReturnStatusBuffer
                              3,
                              Length1, Pointer1,
                              Length2, Pointer2,
                              Length3, Pointer3);

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    DispatchIndex - Supplies an index into the dispatch table
        for the specified update type. The receiving side will
        unmarshall the arguments and call the update routine
        for this dispatch index.
        
    ReturnStatusBuffer - Return buffer recording the execution status of
       the handler invoked on each node during an update.

    ArgCount - Supplies the number of arguments.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.

Remarks:
  
    The code in this function and the code in function GumSendUpdateEx()
    must be in sync.

--*/

{
    PVOID Buffer;
    DWORD BufLength;
    DWORD Status;
    va_list arglist;

    //
    // Make sure there is really a handler for this dispatch routine.
    //
    if (GumTable[UpdateType].Receivers != NULL) {
        CL_ASSERT(DispatchIndex < GumTable[UpdateType].Receivers->DispatchCount);
    }

    //
    // Format the arguments into a common buffer.
    //
    va_start(arglist, ArgCount);
    Buffer = GumpMarshallArgs(ArgCount, arglist, &BufLength);
    va_end(arglist);
    if (Buffer == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Status = GumSendUpdateReturnInfo(UpdateType,
                           DispatchIndex,
                           ReturnStatusBuffer,
                           BufLength,
                           Buffer);
    LocalFree(Buffer);

    return(Status);

}

PVOID GumMarshallArgs(
    OUT LPDWORD lpdwBufLength,
    IN  DWORD   dwArgCount, 
    ...)
{
    PVOID   Buffer=NULL;
    va_list arglist;

    va_start(arglist, dwArgCount);
    Buffer = GumpMarshallArgs(dwArgCount, arglist, lpdwBufLength);
    va_end(arglist);
    return (Buffer);
}
    
#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.

DWORD
GumPostUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    )

/*++

Routine Description:

    Posts an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated.

    This is different than GumPostUpdate in that it takes a
    variable number of arguments. The number of variable
    arguments is specified by the ArgCount argument. The format
    is pairs of length/pointer arguments. For example:
    GumPostUpdateEx(UpdateType,
                    MyContext,
                    3,
                    Length1, Pointer1,
                    Length2, Pointer2,
                    Length3, Pointer3);

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    DispatchIndex - Supplies an index into the dispatch table
        for the specified update type. The receiving side will
        unmarshall the arguments and call the update routine
        for this dispatch index.

    ArgCount - Supplies the number of arguments.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/

{
    PVOID Buffer;
    DWORD BufLength;
    DWORD Status;

    va_list arglist;

    //
    // Format the arguments into a common buffer.
    //
    va_start(arglist, ArgCount);
    Buffer = GumpMarshallArgs(ArgCount, arglist, &BufLength);
    va_end(arglist);
    if (Buffer == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    Status = GumPostUpdate(UpdateType,
                           DispatchIndex,
                           BufLength,
                           Buffer);
    return(Status);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\idl\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\guminit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Initialization and shutdown routines for the GUM component
    of the NT Cluster Service

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "gump.h"

//SS: Adding badly needed comments to this code
//
//Lock descriptions: 
// GumpLock - protects GumTable, GumNodeGeneration, GumpLockerNode, GumReplay, GumUpdatePending
// GumpUpdateLock - protects GumpLockingNode, GumpLockQueue
// GumpSendUpdateLock - makes sure only one update is dispatched at a time
//    and protect GumpLastXXX variables
//
//Lock Hierarchy
// GumpSendUpdateLock - look at s_GumJoinUpdateNode, send lock is acquired first then the gumlock.
//      GumpLock -  in gumpSyncEventHandler,  GumpLock is held first before the gumupdate lock
//          GumpUpdateLock - In s_GumAttemptJoinUpdate(), the send lock is acquired first and than the
//                              update lock
//      
//
//Lock Usage 
// GumpSyncEventHandler - acquires GumpLock and GumpUpdateLock.  Dont want the gumpsynceventhandler
// to wait on gym
// GumSendUpdate - acquires GumSendUpdateLock while dispatching the update to the other nodes.

//
// Global information (used to be per-update)
//
DWORD GumpSequence;
CRITICAL_SECTION GumpUpdateLock;
CRITICAL_SECTION GumpSendUpdateLock;
CRITICAL_SECTION GumpRpcLock;
PVOID GumpLastBuffer;
DWORD GumpLastContext;
DWORD GumpLastBufferLength;
DWORD GumpLastUpdateType;
LIST_ENTRY GumpLockQueue;
DWORD GumpLockingNode;
DWORD GumpLockerNode;
BOOL GumpLastBufferValid;

//
// Table of per-update information
//
GUM_INFO GumTable[GumUpdateMaximum];
CRITICAL_SECTION GumpLock;

//
// Per-node information
//
GUM_NODE_WAIT GumNodeWait[ClusterMinNodeId + ClusterDefaultMaxNodes];
RPC_BINDING_HANDLE GumpRpcBindings[ClusterMinNodeId + ClusterDefaultMaxNodes];
RPC_BINDING_HANDLE GumpReplayRpcBindings[
                              ClusterMinNodeId + ClusterDefaultMaxNodes
                              ];
DWORD GumNodeGeneration[ClusterMinNodeId + ClusterDefaultMaxNodes] = {0};
                              


DWORD
GumInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes the Global Update Manager.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD i;
    DWORD Status;

    //
    // Initialize global data
    //
    InitializeCriticalSection(&GumpLock);
    InitializeCriticalSection(&GumpUpdateLock);
    InitializeCriticalSection(&GumpSendUpdateLock);
    InitializeCriticalSection(&GumpRpcLock);
    GumpSequence = 0;
    InitializeListHead(&GumpLockQueue);
    GumpLockingNode = (DWORD)-1;
    GumpLastBuffer = NULL;
    GumpLastBufferValid = FALSE;
    GumpLastContext = 0;
    GumpLastBufferLength = 0;
    //set it to illegal value;
    GumpLastUpdateType = GumUpdateMaximum;
    //
    // Assume we are the locker node.
    //
    GumpLockerNode = NmGetNodeId(NmLocalNode);

    //
    // Initialize GumTable
    //
    for (i=0; i < GumUpdateMaximum; i++) {
        GumTable[i].Receivers = NULL;
        GumTable[i].Joined = FALSE;
        ZeroMemory(&GumTable[i].ActiveNode,
                   sizeof(GumTable[i].ActiveNode));
        GumTable[i].ActiveNode[NmGetNodeId(NmLocalNode)] = TRUE;
    }

    //
    // Initialize per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        GumpRpcBindings[i] = NULL;
        GumpReplayRpcBindings[i] = NULL;

        GumNodeWait[i].WaiterCount = 0;
        GumNodeWait[i].hSemaphore = CreateSemaphore(NULL,0,100,NULL);
        if (GumNodeWait[i].hSemaphore == NULL) {
            CL_UNEXPECTED_ERROR( GetLastError() );
        }
    }

    Status = EpRegisterEventHandler(CLUSTER_EVENT_NODE_DOWN_EX,
                                    GumpEventHandler);

    if (Status == ERROR_SUCCESS) {
        Status = EpRegisterSyncEventHandler(CLUSTER_EVENT_NODE_DOWN_EX,
                                    GumpSyncEventHandler);
    }

    return(Status);
}


VOID
GumShutdown(
    VOID
    )

/*++

Routine Description:

    Shuts down the Global Update Manager.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD i;
    PGUM_RECEIVER Receiver;
    PGUM_RECEIVER Next;

    //
    // Tear down GumTable
    //
    for (i=0; i < GumUpdateMaximum; i++) {
        Receiver = GumTable[i].Receivers;
        while (Receiver != NULL) {
            Next = Receiver->Next;
            LocalFree(Receiver);
            Receiver = Next;
        }
    }

    //
    // Free per-node information
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumpRpcBindings[i] != NULL) {
            ClMsgDeleteRpcBinding(GumpRpcBindings[i]);
        }

        if (GumpReplayRpcBindings[i] != NULL) {
            ClMsgDeleteRpcBinding(GumpReplayRpcBindings[i]);
        }

        if (GumNodeWait[i].hSemaphore != NULL) {
            CloseHandle(GumNodeWait[i].hSemaphore);
        }
    }

    DeleteCriticalSection(&GumpLock);
    DeleteCriticalSection(&GumpUpdateLock);
    DeleteCriticalSection(&GumpSendUpdateLock);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\gumevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gumevent.c

Abstract:

    Cluster event handling routines for the Global Update Manager

Author:

    John Vert (jvert) 22-Apr-1996

Revision History:

--*/
#include "gump.h"
#include <bitset.h>

//
// Event handling is divided into two parts, sync and async. The sync
// part is executed by all nodes during phase 4 cleanup of the regroup.
// The sync handler must be very fast, since we run in the context of
// of the regroup thread.
//
// The async part is executed as a work thread and we finish handling
// nodes down event.

//
// Flag to denote if we need to replay the last update in the async.
// event handler.
static BOOL GumReplay = FALSE;
//
// Flag to denote if we are in the middle of a dispatch
// 
static BOOL GumUpdatePending = FALSE;


DWORD
GumpGetNodeGenNum(PGUM_INFO GumInfo, DWORD NodeId)
/*++

Routine Description:

    
    Return current generation number for specified node. If node is already dead,
    we return the previous generation number so that furture calls to
    gumwaitnodedown, gumdispatchstart, gumdispatchend fail without checking if
    the node is alive or dead.

Arguments:

    NodeId - Node number

Return Value:

    Node's current generation number

--*/
{
    DWORD dwCur;

    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    dwCur = GumNodeGeneration[NodeId];
    if (GumInfo->ActiveNode[NodeId] == FALSE) {
        //
        // Node is already dead, return previous sequence number
        //
        dwCur--;
    }
    LeaveCriticalSection(&GumpLock);

    return (dwCur);
}

void
GumpWaitNodeDown(DWORD NodeId, DWORD Gennum)
/*++

Routine Description:

    Wait till specified node has transitioned into down event.
    

Arguments:

    NodeId - node id 

    Gennum - node's generation number before down event

Return Value:

    ERROR_SUCCESS

--*/
{
    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    if (Gennum != GumNodeGeneration[NodeId]) {
        LeaveCriticalSection(&GumpLock);
        return;
    }

    //
    // Increment the waiter count, then go wait on the semaphore.
    //
    ++GumNodeWait[NodeId].WaiterCount;
    LeaveCriticalSection(&GumpLock);
    WaitForSingleObject(GumNodeWait[NodeId].hSemaphore, INFINITE);
}

BOOL
GumpDispatchStart(DWORD NodeId, DWORD Gennum)
/*++

Routine Description:

    Mark start of a dispatch. If the generation number supplied is
    old, we fail the dispatch since the node has transitioned.
    

Arguments:

    NodeId - node id 

    Gennum - node's generation number before down event

Return Value:

    TRUE - node state is fine, go ahead with dispatch

    FLASE - node has transitioned, abort dispatch

--*/
{
    //
    // If the sequence number has changed return False, else
    // return true.

    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    if (Gennum != GumNodeGeneration[NodeId]) {
        LeaveCriticalSection(&GumpLock);
        return (FALSE);
    }
    
    //
    // Signal that we are in the middle of an update
    //
    GumUpdatePending = TRUE;
    LeaveCriticalSection(&GumpLock);

    return (TRUE);
}

void
GumpDispatchAbort()
/*++

Routine Description:

    Abort and mark end of current dispatch. Just reset the pending flag.
    This is used when the dispatch routine failed, and we don't need to
    replay it for other nodes.

Arguments:

    none

Return Value:

    none

--*/
{
    EnterCriticalSection(&GumpLock);
    GumUpdatePending = FALSE;
    LeaveCriticalSection(&GumpLock);
}
  
void
GumpDispatchEnd(DWORD NodeId, DWORD Gennum)
/*++

Routine Description:

    Mark end of a dispatch. If the generation number supplied is
    old and we need to reapply update, we replay update for
    other nodes.
    

Arguments:

    NodeId - node id 

    Gennum - node's generation number before down event

Return Value:

    none

--*/
{
    //
    // If the sequence number has changed while the
    // update was happening, we need to replay it

    CL_ASSERT(NodeId < NmMaxNodeId);

    EnterCriticalSection(&GumpLock);
    GumUpdatePending = FALSE;
    if (Gennum != GumNodeGeneration[NodeId] && GumReplay) {
        GumReplay = FALSE;
	    LeaveCriticalSection(&GumpLock);
        GumpReUpdate();
    } else {
        LeaveCriticalSection(&GumpLock);
    }
}

DWORD
WINAPI
GumpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes nodes down cluster events. Replay last update and wake up
    any pending threads.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/

{
    BITSET DownedNodes = (BITSET)((ULONG_PTR)Context);
    DWORD NodeId;


    if (Event != CLUSTER_EVENT_NODE_DOWN_EX) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(BitsetIsNotMember(NmLocalNodeId, DownedNodes));

    EnterCriticalSection(&GumpLock);

    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Nodes down: %1!04X!. Locker=%2!u!, Locking=%3!d!\n",
        DownedNodes,
        GumpLockerNode,
        GumpLockingNode
        );

    //
    //since all gum updates are synchronized and the last buffer
    //and last update type are shared across all updates, we dont have
    //to reissue the update for all types, only for the last update type.
    //SS: note we we use the last GumInfo structure for now since GumInfo
    //structures are still maintained for everygum update type

    if ( GumReplay && GumUpdatePending == FALSE)
    {
        // XXX: These should be if statements and panic this node instead.
        CL_ASSERT(GumpLockerNode == NmLocalNodeId);
        CL_ASSERT(GumpLockingNode == NmLocalNodeId);
	  
        GumReplay = FALSE;
    	LeaveCriticalSection(&GumpLock);
        GumpReUpdate();
    } else {
        LeaveCriticalSection(&GumpLock);
    }

    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Node down processing completed: %1!04X!.\n",
        DownedNodes
        );

    return(ERROR_SUCCESS);
}

DWORD
WINAPI
GumpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    )

/*++

Routine Description:

    Processes nodes down cluster events. Update locker/locking nodes
    state and decide if we need to replay last update in async handler.

Arguments:

    Event - Supplies the type of cluster event.

    Context - Supplies the event-specific context

Return Value:

    ERROR_SUCCESS

--*/

{
    BITSET DownedNodes = (BITSET)((ULONG_PTR)Context);
    DWORD NodeId;


    if (Event != CLUSTER_EVENT_NODE_DOWN_EX) {
        return(ERROR_SUCCESS);
    }

    CL_ASSERT(BitsetIsNotMember(NmLocalNodeId, DownedNodes));

    EnterCriticalSection(&GumpLock);

    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Sync Nodes down: %1!04X!. Locker=%2!u!, Locking=%3!d!\n",
        DownedNodes,
        GumpLockerNode,
        GumpLockingNode
        );

    //
    // remove downed nodes from any further GUM updates
    //
    for(NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) {
       if (BitsetIsMember(NodeId, DownedNodes))
       {
           GUM_UPDATE_TYPE UpdateType;

           for (UpdateType = 0; UpdateType < GumUpdateMaximum; UpdateType++)
           {
               GumTable[UpdateType].ActiveNode[NodeId] = FALSE;
           }

    	   //
    	   // Advance node generation number
    	   //
    	   GumNodeGeneration[NodeId]++;
       }
    }

    //
    // Update LockerNode/LockingNode if necessary
    //
    //since all gum updates are synchronized and the last buffer
    //and last update type are shared across all updates, we dont have
    //to reissue the update for all types, only for the last update type.
    //SS: note we we use the last GumInfo structure for now since GumInfo
    //structures are still maintained for everygum update type

    //SS: Should we be inspecting GumpLockingNode after acquiring the lock
    //Else, s_GumUnlockUpdate can hand over the lock to a node on the waiter list
    //while the gumsync handler hands it to itself(ie selects itself as the LockingNode)
    //Now that we have added the generation number for lock acquisition and also we
    //acquire GumpLock in obtaining a lock that should be prevented.
    //For now,we will leave this as is.
    if ( (GumpLockerNode == NmLocalNodeId) &&
         (BitsetIsMember(GumpLockingNode, DownedNodes)) )
    {
        EnterCriticalSection(&GumpUpdateLock);
        //
        // This node is the locker and the lock is currently held
        // by one of the failed nodes. Take ownership of the lock and
        // reissue the update to all remaining nodes.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpEventHandler taking ownership of the lock from the node %1!d!.\n",
                   GumpLockingNode
                   );
        GumpLockingNode = NmLocalNodeId;
        LeaveCriticalSection(&GumpUpdateLock);

    	//
    	// Reissue update in async phase.
    	//
        GumReplay = TRUE;
    }

    else if ( BitsetIsMember(GumpLockerNode, DownedNodes) )
    {

        //
        // One of the failed nodes was the locker node, so select a new
        // locker node now.
        //
        // Find the node with the next ID after the previous locker node.
        //
        DWORD j;
        for (j=GumpLockerNode+1; j != GumpLockerNode; j++) {
            if (j==(NmMaxNodeId+1)) {
                j = ClusterMinNodeId;
                CL_ASSERT(j != GumpLockerNode);
            }
            if (GumTable[0].ActiveNode[j]) {
                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumpEventHandler New Locker node is node %1!d!\n",
                           j);
                GumpLockerNode = j;
                break;
            }
        }

        //
        // If this node has been promoted to be the new locker node,
        // reissue the last update we saw.
        //
        if (GumpLockerNode == NmLocalNodeId)
        {
            //
            // Manually acquire the lock here. The update has already
            // been issued on this node.
            //
            EnterCriticalSection(&GumpUpdateLock);

            CL_ASSERT(GumpLockingNode == (DWORD)-1);
            GumpLockingNode = NmLocalNodeId;
            LeaveCriticalSection(&GumpUpdateLock);

            //
            // Reissue update in async phase.
            //
            GumReplay = TRUE;
        }
    }

    //
    // Wake any threads waiting for the nodes to transition to down.
    //
    for(NodeId = ClusterMinNodeId; NodeId <= NmMaxNodeId; ++NodeId) {
       if (BitsetIsMember(NodeId, DownedNodes))
       {
           if (GumNodeWait[NodeId].WaiterCount != 0) {
               ReleaseSemaphore(GumNodeWait[NodeId].hSemaphore,
                                GumNodeWait[NodeId].WaiterCount,
                                NULL);
               GumNodeWait[NodeId].WaiterCount = 0;
           }
       }
    }


    ClRtlLogPrint(LOG_NOISE, 
        "[GUM] Sync Nodes down processing completed: %1!04X!.\n",
        DownedNodes
        );

    LeaveCriticalSection(&GumpLock);

    return(ERROR_SUCCESS);
}

VOID
GumpReUpdate(
    VOID
    )
/*++

Routine Description:

    Reissues a GUM update to all nodes. This is used in the event of
    a failure.

Arguments:

    None
    
Return Value:

    None

--*/

{
    DWORD MyId = NmGetNodeId(NmLocalNode);
    DWORD i, seq;
    DWORD Status;
    RPC_ASYNC_STATE AsyncState;


    // This node must be the locker.
    // The lock must be held, and it must be held by this node
    //
    CL_ASSERT(GumpLockerNode == MyId);
    CL_ASSERT(GumpLockingNode == MyId);

    ZeroMemory((PVOID) &AsyncState, sizeof(RPC_ASYNC_STATE));

    AsyncState.u.hEvent = CreateEvent(
                               NULL,  // no attributes
                               TRUE,  // manual reset
                               FALSE, // initial state unsignalled
                               NULL   // no object name
                               );

    if (AsyncState.u.hEvent == NULL) {
        Status = GetLastError();

        ClRtlLogPrint(LOG_CRITICAL,
            "[GUM] GumpReUpdate: Failed to allocate event object for async "
            "RPC call, status %1!u!\n",
            Status
            );
        //    
        // The gum lock still needs to be freed since it is always acquired before this function is called.
        //
        goto ReleaseLock;
    }

    //
    // Grab the sendupdate lock to serialize with a concurrent update on
    // on this node. Note also that it is SAFEST to read all the GumpXXX global
    // variables only after getting the sendupdate lock, else you run into the
    // danger of s_GumUpdateNode changing the values of the variables after you
    // read them.
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    seq = GumpSequence - 1;
    LeaveCriticalSection(&GumpSendUpdateLock);

    //
    // If there is no valid update to be propagated. The gum lock still needs to be freed since it is
    // always acquired before this function is called.
    //
    if (GumpLastUpdateType == GumUpdateMaximum) goto ReleaseLock;

 again:
    ClRtlLogPrint(LOG_UNUSUAL,
           "[GUM] GumpReUpdate reissuing last update for send type %1!d!\n",
        GumpLastUpdateType);

    for (i=MyId+1; i != NmLocalNodeId; i++) {
        if (i == (NmMaxNodeId +1)) {
            i=ClusterMinNodeId;
            if (i == NmLocalNodeId) {
                break;
            }
        }

        if (GumTable[GumpLastUpdateType].ActiveNode[i]) {
            //
            // Dispatch the update to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpReUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                seq,
                GumpLastUpdateType,
                GumpLastContext,
                i);

            
            if (GumpLastBufferValid != FALSE) {
                Status = GumpUpdateRemoteNode(
                             &AsyncState,
                             i,
                             GumpLastUpdateType,
                             GumpLastContext,
                             seq,
                             GumpLastBufferLength,
                             GumpLastBuffer
                             );
            } 
            else {
                // replay end join
                // since we also ignore other updates, we should
                // be calling gumupdatenode for those..however
                // calling gumjoinupdatenode seems to do the job
                // for signalling the other nodes to bump up 
                // their sequence number without processing the update
                try {
                    NmStartRpc(i);

                    Status = GumJoinUpdateNode(GumpReplayRpcBindings[i],
                                 -1, // signal replay
                                 GumpLastUpdateType,
                                 GumpLastContext,
                                 seq,
                                 GumpLastBufferLength,
                                 GumpLastBuffer);

                    NmEndRpc(i);

                } except (I_RpcExceptionFilter(RpcExceptionCode())) {
                    NmEndRpc(i);
                    Status = GetExceptionCode();
                }
            }

            
            //
            // If the update on the other node failed, then the
            // other node must now be out of the cluster since the
            // update has already completed on the locker node.
            //
            if (Status != ERROR_SUCCESS && Status != ERROR_CLUSTER_DATABASE_SEQMISMATCH) {
                ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] GumpReUpdate: Update on node %1!d! failed with %2!d! when it must succeed\n",
                    i,
                    Status);
                        
                NmDumpRpcExtErrorInfo(Status);

                GumpCommFailure(&GumTable[GumpLastUpdateType],
                    i,
                    Status,
                    TRUE);
            }
        }
    }


    //
    // At this point we know that all nodes don't have received our replay
    // and no outstanding sends are in progress. However, a send could have
    // arrived in this node(via s_UpdateNode) and the sender died after that.
    // At that point we are the only node that has it. Since we are the locker 
    // and lockingnode we have to replay again if that happened.
    EnterCriticalSection(&GumpSendUpdateLock);
    if (seq != (GumpSequence - 1)) {
        seq = GumpSequence - 1;
        LeaveCriticalSection(&GumpSendUpdateLock);
        goto again;
    }
    LeaveCriticalSection(&GumpSendUpdateLock);

    if (AsyncState.u.hEvent != NULL) {
        CloseHandle(AsyncState.u.hEvent);
    }

ReleaseLock:
    //
    // The update has been delivered to all nodes. Unlock now.
    //
    GumpDoUnlockingUpdate(GumpLastUpdateType, GumpSequence-1, NmLocalNodeId, 
        GumNodeGeneration[NmLocalNodeId]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\gump.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gump.h

Abstract:

    Private header file for the Global Update Manager (GUM) component
    of the NT Cluster Service

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "service.h"

#define LOG_CURRENT_MODULE LOG_MODULE_GUM

//
//
// Structures and type definitions local to the GUM
//
typedef struct _GUM_RECEIVER {
    struct _GUM_RECEIVER *Next;
    PGUM_UPDATE_ROUTINE UpdateRoutine;
    PGUM_LOG_ROUTINE    LogRoutine;
    DWORD               DispatchCount;
    PGUM_DISPATCH_ENTRY DispatchTable;
    PGUM_VOTE_ROUTINE   VoteRoutine;
} GUM_RECEIVER, *PGUM_RECEIVER;

typedef struct _GUM_INFO {
    PGUM_RECEIVER Receivers;
    BOOL Joined;
    BOOL ActiveNode[ClusterMinNodeId + ClusterDefaultMaxNodes];
} GUM_INFO, *PGUM_INFO;

extern GUM_INFO GumTable[GumUpdateMaximum];
extern CRITICAL_SECTION GumpLock;
extern DWORD GumNodeGeneration[ClusterMinNodeId + ClusterDefaultMaxNodes];

extern DWORD GumpSequence;
extern CRITICAL_SECTION GumpUpdateLock;
extern CRITICAL_SECTION GumpSendUpdateLock;
extern CRITICAL_SECTION GumpRpcLock;
extern PVOID GumpLastBuffer;
extern DWORD GumpLastContext;
extern DWORD GumpLastBufferLength;
extern DWORD GumpLastUpdateType;
extern LIST_ENTRY GumpLockQueue;
extern DWORD GumpLockingNode;
extern DWORD GumpLockerNode;
extern BOOL  GumpLastBufferValid;
extern RPC_BINDING_HANDLE GumpRpcBindings[
                              ClusterMinNodeId + ClusterDefaultMaxNodes
                              ];
extern RPC_BINDING_HANDLE GumpReplayRpcBindings[
                              ClusterMinNodeId + ClusterDefaultMaxNodes
                              ];

//
// structure used to allow GUM clients to wait for
// a node to transition from active to inactive.
// Waited on by GumpCommFailure.
// Set by GumpEventHandler.
// All access to WaiterCount should be serialized by
// GumpLock
//
typedef struct _GUM_NODE_WAIT {
    DWORD WaiterCount;
    HANDLE hSemaphore;
} GUM_NODE_WAIT, *PGUM_NODE_WAIT;

extern GUM_NODE_WAIT GumNodeWait[ClusterMinNodeId + ClusterDefaultMaxNodes];

//
// Define structure used for enqueuing waiters for the GUM lock.
//
#define GUM_WAIT_SYNC   0
#define GUM_WAIT_ASYNC  1

typedef struct _GUM_WAITER {
    LIST_ENTRY ListEntry;
    DWORD WaitType;
    DWORD NodeId;
    DWORD GenerationNum; 
    union {
        struct {
            HANDLE WakeEvent;
        } Sync;
        struct {
            DWORD Context;
            DWORD BufferLength;
            DWORD BufferPtr;
            PUCHAR Buffer;
        } Async;
    };
} GUM_WAITER, *PGUM_WAITER;

//
// Private GUM routines
//
DWORD
WINAPI
GumpSyncEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
WINAPI
GumpEventHandler(
    IN CLUSTER_EVENT Event,
    IN PVOID Context
    );

DWORD
WINAPI
GumpDispatchUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Context,
    IN BOOL IsLocker,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PUCHAR Buffer
    );

DWORD
GumpUpdateRemoteNode(
    IN PRPC_ASYNC_STATE AsyncState,
    IN DWORD RemoteNodeId,
    IN DWORD UpdateType,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    );

//
// Node Generation Numbers
//
DWORD
GumpGetNodeGenNum(PGUM_INFO GumInfo, DWORD NodeId);

void
GumpWaitNodeDown(DWORD NodeId, DWORD gennum);

BOOL
GumpDispatchStart(DWORD NodeId, DWORD gennum);

void
GumpDispatchEnd(DWORD NodeId, DWORD gennum);

void
GumpDispatchAbort();

//
// Macros to serialize usage of RPC handles. We don't use one lock per node
// because a new sender might grap the RPC to new locker and previous sender
// wants handle to send update. But previous sender owns updatelock and we
// will deadlock. So, we just keep things simple for now and use one lock
// to serialize all RPC calls.
//
#define GumpStartRpc(nodeid)	EnterCriticalSection(&GumpRpcLock)
#define	GumpEndRpc(nodeid)	LeaveCriticalSection(&GumpRpcLock)

//
// Locker interface
//

VOID
GumpPromoteToLocker(
    VOID
    );

DWORD
GumpDoLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    OUT LPDWORD Sequence,
    OUT LPDWORD pGeneratioNum
    );

DWORD
GumpDoLockingPost(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    OUT LPDWORD Sequence,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN DWORD BufferPtr,
    IN UCHAR Buffer[]
    );

VOID
GumpDeliverPosts(
    IN DWORD FirstNodeId,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Sequence,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer                 // THIS WILL BE FREED
    );

VOID
GumpDoUnlockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Sequence,
    IN DWORD NodeId,
    IN DWORD GenerationNum
    );

BOOL
GumpTryLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    IN DWORD Sequence, 
    OUT LPDWORD pdwGenerationNum
    );

error_status_t
GumpAttemptLockingUpdate(
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    OUT LPDWORD pdwGenerationNum
);

VOID
GumpReUpdate(
    VOID
    );

VOID
GumpCommFailure(
    IN PGUM_INFO GumInfo,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    );

//internal routines for dispatching collection of votes
DWORD GumpCollectVotes(
    IN PGUM_VOTE_DECISION_CONTEXT   pVoteContext,
    IN  DWORD                       dwVoteBufSize,
    OUT PBYTE                       pVoteBuffer,
    OUT LPDWORD                     pdwNumVotes,
    OUT BOOL                        *pbDidAllActiveNodesVote
);


DWORD
WINAPI
GumpDispatchVote(
    IN  GUM_UPDATE_TYPE  Type,
    IN  DWORD            Context,
    IN  DWORD            dwInputBufLength,
    IN  PUCHAR           pInputBuf,
    IN  DWORD            dwVoteLength,
    OUT PUCHAR           pVoteBuf
);

//join interfaces
error_status_t
GumpAttemptJoinUpdate(
    IN DWORD JoiningId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    IN LPDWORD  pdwGenerationNum
);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\receive.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    Routines for registering for global updates and dispensing
    received global updates to the routines that have registered
    for them.

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "gump.h"


VOID
GumReceiveUpdates(
    IN BOOL                         IsJoining,
    IN GUM_UPDATE_TYPE              UpdateType,
    IN PGUM_UPDATE_ROUTINE          UpdateRoutine,
    IN PGUM_LOG_ROUTINE             LogRoutine,
    IN DWORD                        DispatchCount,
    IN OPTIONAL PGUM_DISPATCH_ENTRY DispatchTable,
    IN OPTIONAL PGUM_VOTE_ROUTINE   VoteRoutine
    )

/*++

Routine Description:

    Registers a handler for a particular global update type.

Arguments:

    IsJoining - TRUE if the current node is joining. If this is true,
        updates will not be delivered until GumEndJoinUpdate has
        completed successfully. If this is FALSE, updates will be
        delivered immediately.

    UpdateType - Supplies the update type to register for.

    UpdateRoutine - Supplies the routine to be called when a global update
        of the specified type occurs.

    LogRoutine - If supplied, it specifies the logging routine that must be called to
        log transaction to the quorum logs.

    DispatchCount - Supplies the number of entries in the dispatch table.
        This can be zero.

    DispatchTable - Supplies a pointer to the dispatch table. If this is
        NULL, no updates of this type will be automatically dispatched.

    VoteRoutine - If supplied, this specifies the routine to be called when
        a vote for this update type is requested.

Return Value:

    None.

--*/

{
    PGUM_RECEIVER Receiver;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    Receiver = LocalAlloc(LMEM_FIXED, sizeof(GUM_RECEIVER));
    if (Receiver == NULL) {
        CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    Receiver->UpdateRoutine = UpdateRoutine;
    Receiver->LogRoutine = LogRoutine;
    Receiver->DispatchCount = DispatchCount;
    Receiver->DispatchTable = DispatchTable;
    Receiver->VoteRoutine = VoteRoutine;
    //
    //    John Vert (jvert) 8/2/1996
    //    remove below debug print if we ever want to support
    //    multiple GUM handlers.
    //
    if (GumTable[UpdateType].Receivers != NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] Multiple GUM handlers registered for UpdateType %1!d!\n",
                   UpdateType);
    }

    EnterCriticalSection(&GumpLock);
    Receiver->Next = GumTable[UpdateType].Receivers;
    GumTable[UpdateType].Receivers = Receiver;
    if (IsJoining) {
        GumTable[UpdateType].Joined = FALSE;
    } else {
        GumTable[UpdateType].Joined = TRUE;
    }
    LeaveCriticalSection(&GumpLock);
}


VOID
GumIgnoreUpdates(
    IN GUM_UPDATE_TYPE UpdateType,
    IN PGUM_UPDATE_ROUTINE UpdateRoutine
    )
/*++

Routine Description:

    Removes an update handler from the GUM table. This is the opposite
    of GumReceiveUpdates

Arguments:

    UpdateType - Supplies the update type to register for.

    UpdateRoutine - Supplies the routine to be called when a global update
        of the specified type occurs.

Return Value:

    None

--*/

{
    PGUM_RECEIVER Receiver;
    PGUM_RECEIVER *Last;

    //
    // We cannot safely de-registr from Gum... ASSERT if anyone calls this
    // function.
    //
    CL_ASSERT(FALSE);

    //
    // Walk the list of receivers until we find the specified UpdateRoutine
    //
    Last = &GumTable[UpdateType].Receivers;
    EnterCriticalSection(&GumpLock);
    while ((Receiver = *Last) != NULL) {
        if (Receiver->UpdateRoutine == UpdateRoutine) {
            *Last = Receiver->Next;
            break;
        }
        Last = &Receiver->Next;
    }
    LeaveCriticalSection(&GumpLock);
    if (Receiver != NULL) {
        LocalFree(Receiver);
    }

}


DWORD
WINAPI
GumpDispatchUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Context,
    IN BOOL IsLocker,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PUCHAR Buffer
    )

/*++

Routine Description:

    Dispatches a GUM update to all the registered handlers on this node

Arguments:

    Sequence - Supplies the GUM sequence number for the update

    Type - Supplies the GUM_UPDATE_TYPE for the update

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

        IsLocker - Specifies if this is a locker node.

    SourceNode - Specifies whether the update originated on this node or not.

    BufferLength - Supplies the length of the update data

    Buffer - Supplies a pointer to the update data

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    PGUM_INFO GumInfo;
    PGUM_RECEIVER Receiver;
    DWORD Status = ERROR_SUCCESS;
    PGUM_DISPATCH_ENTRY Dispatch;

    GumInfo = &GumTable[Type];

    if (GumInfo->Joined) {
        Receiver = GumInfo->Receivers;
        while (Receiver != NULL) {
            if (Receiver->LogRoutine) {
                Status = (*(Receiver->LogRoutine))(PRE_GUM_DISPATCH, GumpSequence,
                    Context, Buffer, BufferLength);
                if (Status != ERROR_SUCCESS)
                {
                    return(Status);
                }
            }

            try {
                if ((Receiver->DispatchTable == NULL) ||
                    (Receiver->DispatchCount < Context) ||
                    (Receiver->DispatchTable[Context].Dispatch1 == NULL)) {
                    Status = (Receiver->UpdateRoutine)(Context,
                                                       SourceNode,
                                                       BufferLength,
                                                       Buffer);
                } else {
                    Dispatch = &Receiver->DispatchTable[Context];
                    //
                    // This update should be unmarshalled and dispatched to the
                    // appropriate dispatch routine. The format generated by
                    // GumpMarshallArgs is an array of offsets into the buffer,
                    // followed by the actual args. The dispatch table is
                    // responsible for recording the number of arguments.
                    //
                    CL_ASSERT(Dispatch->ArgCount <= GUM_MAX_DISPATCH_ARGS);
                    CL_ASSERT(Dispatch->ArgCount != 0);
                    switch (Dispatch->ArgCount) {
                        case 1:
                            Status = (Dispatch->Dispatch1)(SourceNode,
                                                           GET_ARG(Buffer,0));
                            break;
                        case 2:
                            Status = (Dispatch->Dispatch2)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1));
                            break;
                        case 3:
                            Status = (Dispatch->Dispatch3)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1),
                                                           GET_ARG(Buffer,2));
                            break;
                        case 4:
                            Status = (Dispatch->Dispatch4)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1),
                                                           GET_ARG(Buffer,2),
                                                           GET_ARG(Buffer,3));
                            break;
                        case 5:
                            Status = (Dispatch->Dispatch5)(SourceNode,
                                                           GET_ARG(Buffer,0),
                                                           GET_ARG(Buffer,1),
                                                           GET_ARG(Buffer,2),
                                                           GET_ARG(Buffer,3),
                                                           GET_ARG(Buffer,4));
                            break;
                        case 6:
                            Status = (Dispatch->Dispatch6)(SourceNode,
                                                       GET_ARG(Buffer,0),
                                                       GET_ARG(Buffer,1),
                                                       GET_ARG(Buffer,2),
                                                       GET_ARG(Buffer,3),
                                                       GET_ARG(Buffer,4),
                                                       GET_ARG(Buffer,5));
                            break;
                        case 7:
                            Status = (Dispatch->Dispatch7)(SourceNode,
                                                    GET_ARG(Buffer,0),
                                                    GET_ARG(Buffer,1),
                                                    GET_ARG(Buffer,2),
                                                    GET_ARG(Buffer,3),
                                                    GET_ARG(Buffer,4),
                                                    GET_ARG(Buffer,5),
                                                    GET_ARG(Buffer,6));
                            break;
                        case 8:
                            Status = (Dispatch->Dispatch8)(SourceNode,
                                                GET_ARG(Buffer,0),
                                                GET_ARG(Buffer,1),
                                                GET_ARG(Buffer,2),
                                                GET_ARG(Buffer,3),
                                                GET_ARG(Buffer,4),
                                                GET_ARG(Buffer,5),
                                                GET_ARG(Buffer,6),
                                                GET_ARG(Buffer,7));
                            break;
                        default:
                            CL_ASSERT(FALSE);
                    }
                }
            } except (CL_UNEXPECTED_ERROR(GetExceptionCode()),
                      EXCEPTION_EXECUTE_HANDLER
                     )
            {
                Status = GetExceptionCode();
            }
            if (Status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[GUM] Update routine of type %1!u!,  context %2!u! failed with status %3!d!\n",
                           Type,
                           Context,
                           Status);
                break;
            }

            if (Receiver->LogRoutine) {
                if (IsLocker && (Status == ERROR_SUCCESS))
                    (*(Receiver->LogRoutine))(POST_GUM_DISPATCH, GumpSequence,
                        Context, Buffer, BufferLength);
                if (!IsLocker)
                    (*(Receiver->LogRoutine))(POST_GUM_DISPATCH, GumpSequence,
                        Context, Buffer, BufferLength);
            }
            Receiver = Receiver->Next;

        }
    }

    if (Status == ERROR_SUCCESS) {
        GumpSequence += 1;

        // Check if we've received a DM or FM update (other than join) that we care about:
        if (( Type == GumUpdateRegistry && Context != DmUpdateJoin )
            || ( Type == GumUpdateFailoverManager && Context != FmUpdateJoin )) {
            CsDmOrFmHasChanged = TRUE;
        }
    }
    return(Status);
}

//rod wants to call this a mandatory update instead of H...word
//some times reupdates get delivered in different views on different
//nodes causing a problem
//For instance, a locker node might see an update and complete it 
//successfully in one view but when it replays it in another view
//other nodes may not be able to complete it successfully and may be 
//banished.
//in one particular case, the locker node approved of a node join
//because it had finished the node down processing for that node.
//subsequently another node and hence the joiner went down.
//the locker node tried to replay the approval update and banished
//other nodes that were seeing this update after the joiner the joiner
//went down for the second time.
//The correct solution would involve GUM delivering the node down
//message as a gum update and delivering it in the same order with
//respect to other messages on all nodes
//However this will require some restructuring of code which
//cant be done in this time frame(for dtc) hence we are using
//this workaround
//this workaround is safe for gums initiated by the joiner  node during
//the join process
void GumpIgnoreSomeUpdatesOnReupdate(
    IN DWORD Type, 
    IN DWORD Context)
{
    if ((Type == GumUpdateFailoverManager) && 
        (Context == FmUpdateApproveJoin))
        GumpLastBufferValid = FALSE;
}


VOID
GumpCompleteAsyncRpcCall(
    IN PRPC_ASYNC_STATE AsyncState,
    IN DWORD            Status
    )
{
    DWORD  RpcStatus;

        
    RpcStatus = RpcAsyncCompleteCall(AsyncState, &Status);
    
    if ( (RpcStatus != RPC_S_OK) &&
         (RpcStatus != RPC_S_CALL_CANCELLED)
       ) 
    {
        CL_ASSERT(RpcStatus != RPC_S_ASYNC_CALL_PENDING);

        ClRtlLogPrint(LOG_CRITICAL,
            "[GUM] GumpCompleteAsyncRpcCall: Error completing async RPC call, status %1!u!\n",
            RpcStatus
            );

        //
        // This next call will cause the process to exit. We exit here, 
        // rather than have the sender evict us, to avoid the situation
        // where the sender crashes and none of the other surviving nodes 
        // know to evict us.
        //
        CL_UNEXPECTED_ERROR( RpcStatus );
    }

    return;

} // GumpCompleteAsyncRpcCall



error_status_t
s_GumUpdateNode(
    IN PRPC_ASYNC_STATE AsyncState,
    IN handle_t IDL_handle,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Server side routine for GumUpdateNode. This is the side that
    receives the update and dispatches it to the appropriate
    handlers.

Arguments:

    IDL_handle - RPC binding handle, not used

    Type - Supplies the GUM_UPDATE_TYPE

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    Sequence - Supplies the GUM sequence number for the specified update type

    BufferLength - Supplies the length of the update data

    Buffer - Supplies a pointer to the update data.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    ERROR_CLUSTER_DATABASE_SEQMISMATCH if the GUM sequence number is invalid

--*/

{
    DWORD Status;
    PGUM_INFO GumInfo;

    //
    // We need to grap the gumsendupdate lock to serialize send/replay
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    GumInfo = &GumTable[Type];
    //SS: Could s_GumUpdateNode run on a newly elected locker node after a Reupdate() is completed
    //and concurrenly update the GumpLastXXX variables with s_GumQueueLockingUpdate() issued 
    //by another client?   
    
    //Worse yet, if the old client continue to send this update at the same sequence number 
    //as the new client and different might reject different udpates as duplicates.  That could
    //result in a cluster inconsistency.  But THAT CANNOT happen.  If s_Update() call is pending at the
    //new locker, the client is holding the GumpSendUpdateLock().  Reupdate() cannot finish at the
    //locker, since it will issue a dispath via s_updateNode() to that client and get blocked at the
    //lock.  If the client dies, Reupdate() will kill it.  Hence that client could not pollute other
    //members of the cluster with an update of the same sequence number.  

    //This would result in updating those variables non-atomically.  If the new
    //locking node then dies, the reupdate() could pick up incorrect combinations of these variable
    // 

    //SOLN -???
    
    if (Sequence != GumpSequence) {

        MIDL_user_free(Buffer);
        if (Sequence+1 == GumpSequence) {
            //
            // This is a duplicate of a previously seen update, probably due to
            // a node failure during GUM. Return success since we have already done
            // this.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] s_GumUpdateNode: Sequence %1!u! is a duplicate of last sequence for Type %2!u!\n",
                       Sequence,
                       Type);

            GumpCompleteAsyncRpcCall(AsyncState, ERROR_SUCCESS);

            LeaveCriticalSection(&GumpSendUpdateLock);
            return(ERROR_SUCCESS);

        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] s_GumUpdateNode: Sequence %1!u! does not match current %2!u! for Type %3!u!\n",
                       Sequence,
                       GumpSequence,
                       Type);

            GumpCompleteAsyncRpcCall(AsyncState, ERROR_CLUSTER_DATABASE_SEQMISMATCH);

            LeaveCriticalSection(&GumpSendUpdateLock);
            //
            // [GorN] 10/07/1999. The following code will allow the test program
            // to recognize this sitiation and to restart clustering service
            //
            if( NmGetExtendedNodeState( NmLocalNode ) != ClusterNodeUp){
                CsInconsistencyHalt(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
            }
            return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
        }
    }


    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumUpdateNode: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);
        //SS: set IsLocker to FALSE,
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] Cluster state inconsistency check\n");
        ClRtlLogPrint(LOG_CRITICAL,
                   "[GUM] s_GumUpdateNode update routine type %1!u! context %2!d! failed with error %3!d! on non-locker node\n",
                   Type,
                   Context,
                   Status);

        //
        // Complete the call back to the client. This ensures that 
        // the client gets a return value before we exit the process 
        // due to the error in the handler.
        //
        GumpCompleteAsyncRpcCall(AsyncState, Status);

        //
        // This next call will cause the process to exit. We exit here, 
        // rather than have the sender evict us, to avoid the situation
        // where the sender crashes and none of the other surviving nodes 
        // know to evict us.
        //
        CL_UNEXPECTED_ERROR( Status );
        MIDL_user_free(Buffer);
        LeaveCriticalSection(&GumpSendUpdateLock);
        return(Status);

    }
    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumUpdateNode: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);

    GumpCompleteAsyncRpcCall(AsyncState, Status);

    if (GumpLastBuffer != NULL) {
        MIDL_user_free(GumpLastBuffer);
    }
    GumpLastBuffer = Buffer;
    GumpLastContext = Context;
    GumpLastBufferLength = BufferLength;
    GumpLastUpdateType = Type;
    GumpLastBufferValid = TRUE;
    
    GumpIgnoreSomeUpdatesOnReupdate(GumpLastUpdateType, GumpLastContext);
        
    LeaveCriticalSection(&GumpSendUpdateLock);
    return(Status);
}


error_status_t
s_GumGetNodeSequence(
    IN handle_t IDL_handle,
    IN DWORD Type,
    OUT LPDWORD Sequence,
    OUT LPDWORD LockerNodeId,
    OUT PGUM_NODE_LIST *ReturnNodeList
    )

/*++

Routine Description:

    Returns the node's current GUM sequence number for the specified type

Arguments:

    IDL_handle - Supplies the RPC binding handle, not used

    Type - Supplies the GUM_UPDATE_TYPE

    Sequence - Returns the sequence number for the specified GUM_UPDATE_TYPE

    LockerNodeId - Returns the current locker node

    ReturnNodeList - Returns the list of active nodes

Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD i;
    DWORD NodeCount;
    PGUM_INFO GumInfo;
    PGUM_NODE_LIST NodeList;

    CL_ASSERT(Type < GumUpdateMaximum);
    GumInfo = &GumTable[Type];

    NodeCount = 0;
    *Sequence = 0;          // In case of failure set sequence to 0

    EnterCriticalSection(&GumpUpdateLock);

    //
    // Count up the number of nodes in the list.
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i] == TRUE) {
            ++NodeCount;
        }
    }
    CL_ASSERT(NodeCount > 0);       // must be at least us in the list.

    //
    // Allocate node list
    //
    NodeList = MIDL_user_allocate(sizeof(GUM_NODE_LIST) + (NodeCount-1)*sizeof(DWORD));
    if (NodeList == NULL) {
        LeaveCriticalSection(&GumpUpdateLock);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    NodeList->NodeCount = NodeCount;
    NodeCount = 0;

    //
    // Fill in the node id array to be returned.
    //
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i] == TRUE) {
            NodeList->NodeId[NodeCount] = i;
            ++NodeCount;
        }
    }

    *ReturnNodeList = NodeList;
    *Sequence = GumpSequence;
    *LockerNodeId = GumpLockerNode;

    LeaveCriticalSection(&GumpUpdateLock);

    return(ERROR_SUCCESS);
}

/*
// SS:  Anytime the gum lock is assigned to a node, a generation number of the locking node
at the time of assignment wrt to the locker node is returned to the locking node.
The locking node must present this generation number to unlock the update.
If the generation number wrt to the locker at the time of update doesnt match what is 
passed in, the unlock request is failed.

That is a lock is only released if the unlock occurs in the same generation in which it
was acquire.  This ensures that on node down processing the gum lock is handled correctly -
only a single waiter is woken up


//The following description explains the details and how it works
Sync1, Sync2 represent gum sync handlers processing the death of a node holding the gum lock
occuring at different points in time
//This where the current locker acquired its lock on the locker node
s_GumQueueLockingUpdate()
{
}

<------------------------  Sync 1 (Sync handler invoked before the lock has been released

s_UnlockUpdate()
{
}
<------------------------  Sync 2 (Sync handler invoked after the lock has been released

// The waiters for the gum lock may be anywhere within this routine
// Interesting case is for a waiter that is declared dead as well by this sync handler
// E.g node 1 is locker, and sync 1/2 are for node 3 and node 4.  Node 4 was the old locking
// node and s_GumQueulockingUpdate() for node 3 is blocked at the locker.

s_GumQueueLockingUpdate()
{

<-------------------------  Sync 2 #0 
    GetGenNum
<-------------------------  Sync 2 #1    
    GumpDoLockingUpdate
<-------------------------  Sync 2 #2
    DispatchStart
<-------------------------  Sync 2 #3
    if (DeadNode)
    {
        GumpDoUnlockingUpdate()
    }        
    else
    {
        DispatchUpdate
    }        
<------------------------   Sync 2 #4
    DispatchEnd            
<------------------------   Sync 2 #5
}

Sync 1: s_unlockUpdate wont realease the lock, since the sync1 handler will update its 
generation number and the locker will take over the responsibility for unlock after reupdates

Sync2: s_unlockUpdate will release a waiter.  If the waiter is a dead node, the locker will also
usurp the lock. If the waiter is not a dead node, the locker will not usurp the lock and the waiter
must then free it.

We can consider several cases of sync 2.
Sync 2 #0 : This thread is not on the list.  So, the lock is either free or assigned to somebody else.
    If free or if assigned to some other thread, and then subsequently assigned to this thread, 
    DispatchStart() will fail and GumpDoUnlockingUpdate() will succeed.
Sync 2 #1 : This thread is not on the list.  So, the lock is either free or assigned to somebody else.
    If free or if assigned to some other thread and then subsequently assigned to this thread,
    DispatchStart() will fail and GumpDoUnlockingUpdate() will succeed
Sync 2 #2: This thread is woken up by the now dead node. In this case, the locker will usurp.
    If this thread is woken up before the sync handler, locker will still usurp (because the waiter
    is also dead) but the generation number handed out to this thread will be old => 
    Locker node will release the lock after reupdate.
    This thread cannot be woken up after the sync handler by the dead locker, since the s_UnlockUpdate from the 
    dead node will fail with a generation mismatch.
    If it is woken up after the sync handler it must be up the Reupdate, in which case, the generation
    number handed out to this thread is new and it will proceed to unlock.

    DispatchStart() will fail. GumpDoUnlockingUpdate() will  fail to unlock.
    
Sync 2 #3: Locker will usurp, Reupdate will not occur if the async handler runs before DispatchEnd because
    UpdatePending is set to TRUE. Reupdate will not occur if the async handler runs after DispatchEnd() 
    because the GumReplay flag will be set to FALSE.
    This thread will Dispatch and call Reupdate() at the end of DispatchEnd().  Unlock from there
    will succeed since it will pass the generation number not for this thread running on behalf of
    the dead node but the local node.

Sync 2 #4: Locker will usurp, but not reupdate because UpdatePending is set to true by DispatchStart.
    This thread will dispatch and call reupdate at the end of DispatchEnd().  Unlock from there
    will succeed since it will not pass the generation number for the dead node invoking this
    rpc but the local node.

Sync 2 #5: Locker will usurp.  Reupdate will replay this update and then unlock this update. DispatchEnd()
    will not call Reupdate() or unlock.
    
*/

error_status_t
s_GumQueueLockingUpdate(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    OUT LPDWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Queues a locking update. When the lock can be acquired, the update will
    be issued and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    IsLocker - is this is the locker node

    Sequence - Returns the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{

    DWORD   dwLockObtainedAtGenNum;

    return(s_GumQueueLockingUpdate2(IDL_handle, NodeId, Type, Context,
        Sequence, BufferLength, Buffer, &dwLockObtainedAtGenNum));

}


error_status_t
s_GumQueueLockingUpdate2(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    OUT LPDWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[], 
    OUT LPDWORD GenerationNum
    )

/*++

Routine Description:

    Queues a locking update. When the lock can be acquired, the update will
    be issued and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    IsLocker - is this is the locker node

    Sequence - Returns the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

    GenerationNum - Specifies the generation number wrt to the locker in which this node 
    obtains the lock

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;
    PGUM_INFO GumInfo;
    DWORD dwGennum;

    GumInfo = &GumTable[Type];

    // SS: Note we get the generation number before going on the wait
    // queue so that if we are woken up after the node is dead,
    // we will be comparing the old generation number against the new one
    //
    // Get current node generation number
    //
    dwGennum = GumpGetNodeGenNum(GumInfo, NodeId);


    Status = GumpDoLockingUpdate(Type, NodeId, Sequence, GenerationNum);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] s_GumQueueLockingUpdate: GumpDoLockingUpdate failed %1!u!\n",
                   Status);
        MIDL_user_free(Buffer);
        return(Status);
    }


    // 
    // If the node that is granted ownership is no longer a member of the
    // cluster or the remote node went down and came back up again, give it up.
    //
    if (GumpDispatchStart(NodeId, dwGennum) != TRUE)
    {
        //skip the dispatch and unlock the lock
        ClRtlLogPrint(LOG_CRITICAL,
               "[GUM] s_GumQueueLockingUpdate: The new locker %1!u! no longer belongs to the cluster\n",
               NodeId);
        Status = ERROR_CLUSTER_NODE_NOT_READY;

        //
        // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
        // failed and did not increment the sequence number.
        //
        GumpDoUnlockingUpdate(Type, *Sequence - 1, NodeId, *GenerationNum);
        MIDL_user_free(Buffer);
        return(Status);

    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingUpdate: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               *Sequence,
               Type,
               Context);
        //SS: Set IsLocker to TRUE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                TRUE,
                                FALSE,
                                BufferLength,
                                Buffer);

    if (Status != ERROR_SUCCESS) {
        //
        // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
        // failed and did not increment the sequence number.
        //
        GumpDispatchAbort();
        GumpDoUnlockingUpdate(Type, *Sequence - 1, NodeId, *GenerationNum);
    if (Buffer != NULL)
        MIDL_user_free(Buffer);
    } else {
        if (GumpLastBuffer != NULL) {
            MIDL_user_free(GumpLastBuffer);
        }
        GumpLastBuffer = Buffer;
        GumpLastContext = Context;
        GumpLastBufferLength = BufferLength;
        GumpLastUpdateType = Type;
        GumpLastBufferValid = TRUE;
        GumpIgnoreSomeUpdatesOnReupdate(GumpLastUpdateType, GumpLastContext);
        //
        // Just in case our client dies
        //
        // SS: Note that if the client dies after GumpDispatchStart, then Reupdate() 
        // may not be able to send the last known update until we synchronize with
        // this update.  Hence, Reupdate() doesnt send the updates but GumpDispatchEnd()
        // does.
        GumpDispatchEnd(NodeId, dwGennum);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingUpdate: completed update seq %1!u!\ttype %2!u! context %3!u! result %4!u!\n",
               *Sequence,
               Type,
               Context,
               Status);

    return(Status);

}


#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.
    N.B. The below code does not handle locker node failures

error_status_t
s_GumQueueLockingPost(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    OUT LPDWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    IN DWORD ActualBuffer
    )

/*++

Routine Description:

    Queues a post update.

    If the GUM lock can be immediately acquired, this routine
    behaves exactly like GumQueueLockingUpdate and returns
    ERROR_SUCCESS.

    If the GUM lock is held, this routine queues an asynchronous
    wait block onto the GUM queue and returns ERROR_IO_PENDING.
    When the wait block is removed from the GUM queue, the unlocking
    thread will call GumpDeliverPostUpdate on the specified node
    and supply the passed in context. The calling node can then
    deliver the update.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Returns the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

    ActualBuffer - Supplies the value of the pointer to the GUM data on the
        client side. This will be returned to the callback if this update
        is completed asynchronously.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;

    Status = GumpDoLockingPost(Type, NodeId, Sequence, Context, BufferLength,
        ActualBuffer, Buffer);
    if (Status != ERROR_SUCCESS) {
        if (Status != ERROR_IO_PENDING) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[GUM] s_GumQueueLockingPost: GumpDoLockingPost failed %1!u!\n",
                       Status);
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] s_GumQueueLockingPost: GumpDoLockingPost pended update type %1!u! context %2!u!\n",
                       Type,
                       Context);
        }
        return(Status);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingPost: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               *Sequence,
               Type,
               Context);
        //SS: setting IsLocker to FALSE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);
    CL_ASSERT(Status == ERROR_SUCCESS);     // posts must never fail

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumQueueLockingPost: completed update seq %1!u!\ttype %2!u! context %3!u! result %4!u!\n",
               *Sequence,
               Type,
               Context,
               Status);
    MIDL_user_free(Buffer);

    return(Status);

}
#endif


error_status_t
s_GumAttemptLockingUpdate(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Attempts a locking update. If the supplied sequence number
    matches and the update lock is not already held, the update
    will be issued and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD   dwGenerationNum;

    return(GumpAttemptLockingUpdate(NodeId, Type, Context, Sequence, BufferLength,
        Buffer, &dwGenerationNum));

}

error_status_t
s_GumAttemptLockingUpdate2(
    IN handle_t IDL_handle,
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    OUT LPDWORD pdwGenerationNum
    )

/*++

Routine Description:

    Attempts a locking update. If the supplied sequence number
    matches and the update lock is not already held, the update
    will be issued and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    NodeId - Supplies the node id of the issuing node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

    pdwGenerationNum - If successful, it returns the generation number of this 
        node wrt to the locker at the time at which the lock is acquired

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{

    return(GumpAttemptLockingUpdate(NodeId, Type, Context, Sequence, BufferLength, 
        Buffer, pdwGenerationNum));

}

error_status_t
GumpAttemptLockingUpdate(
    IN DWORD NodeId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    OUT LPDWORD pdwGenerationNum
)
{
    DWORD   Status;
    DWORD   dwGenerationNum;
    
    if (!GumpTryLockingUpdate(Type, NodeId, Sequence, &dwGenerationNum)) {
        MIDL_user_free(Buffer);
        return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
    }

    //SS: setting Islocker false
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);
    if (Status != ERROR_SUCCESS) {
        //
        // The update has failed on this node, unlock here
        // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
        // failed and did not increment the sequence number.
        //
        GumpDoUnlockingUpdate(Type, Sequence-1, NodeId, dwGenerationNum);
    }

    MIDL_user_free(Buffer);
    return(Status);

}

error_status_t
s_GumUnlockUpdate(
    IN handle_t IDL_handle,
    IN DWORD Type,
    IN DWORD Sequence
    )

/*++

Routine Description:

    Unlocks a locked update.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Sequence - Supplies the sequence that the GUM update was issued with

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    //SS: If this is executing on behalf of a node that is already been
    //declared dead and on whose behalf a Replay has been queued, can
    //we have two simultaneous unlocks one by this thread and the other
    //by the replay thread
    // SOLN: We could check the generation number and not release a waiter 
    // This should probably be done externally  
    GumpDoUnlockingUpdate(Type, Sequence, ClusterInvalidNodeId, 0);

    return(ERROR_SUCCESS);
}

error_status_t
s_GumUnlockUpdate2(
    IN handle_t IDL_handle,
    IN DWORD Type,
    IN DWORD Sequence,
    IN DWORD NodeId,
    IN DWORD GenerationNum
    )

/*++

Routine Description:

    Unlocks a locked update.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Sequence - Supplies the sequence that the GUM update was issued with

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    //SS: If this is executing on behalf of a node that is already been
    //declared dead and on whose behalf a Replay has been queued, we could
    //have two simultaneous unlocks one by this thread and the other
    //by the replay thread
    //SOLN: We check against the generation number when the lock was granted
    //against the current generation number.
    GumpDoUnlockingUpdate(Type, Sequence, NodeId, GenerationNum);

    return(ERROR_SUCCESS);
}

error_status_t
s_GumJoinUpdateNode(
    IN handle_t IDL_handle,
    IN DWORD JoiningId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Server side routine for GumJoinUpdateNode. This is the side that
    receives the update, adds the node to the update list, and dispatches
    it to the appropriate handlers.

Arguments:

    IDL_handle - RPC binding handle, not used

    JoiningId - Supplies the nodeid of the joining node.

    Type - Supplies the GUM_UPDATE_TYPE

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    Sequence - Supplies the GUM sequence number for the specified update type

    BufferLength - Supplies the length of the update data

    Buffer - Supplies a pointer to the update data.

Return Value:

    ERROR_SUCCESS if the update completed successfully

    ERROR_INVALID_HANDLE if the GUM sequence number is invalid

--*/

{
    DWORD Status;
    PGUM_INFO GumInfo;

    // Buffer is [unique].
    if ( BufferLength == 0 )
        Buffer = NULL;
    else if ( Buffer == NULL )
        BufferLength = 0;

    GumInfo = &GumTable[Type];

    // sync with replay/updates
    EnterCriticalSection(&GumpSendUpdateLock);
    // [ahm] This is an aborted endjoin, we just resync our seq. with master.
    // This should be its own GumUpdateSequence RPC, but for now it ok to
    // to this.
    if (JoiningId == (DWORD) -1) 
    {
        // we must be off by one at the most
        if (Sequence+1 != GumpSequence) 
        {
            CL_ASSERT(Sequence == GumpSequence);
            GumpSequence = Sequence+1;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[GUM] s_GumJoinUpdateNode: pretend we have seen Sequence %1!u!\n",
                Sequence);
        }
        Status = 0;
        goto done;
    }
    
    if (Sequence != GumpSequence) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] s_GumJoinUpdateNode: Sequence %1!u! does not match current %2!u! for Type %3!u!\n",
                   Sequence,
                   GumpSequence,
                   Type);
        LeaveCriticalSection(&GumpSendUpdateLock);
        MIDL_user_free(Buffer);
        return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumJoinUpdateNode: dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);

    CL_ASSERT(NmIsValidNodeId(JoiningId));
    CL_ASSERT(GumpRpcBindings[JoiningId] != NULL);
    CL_ASSERT(GumpReplayRpcBindings[JoiningId] != NULL);

    ClRtlLogPrint(LOG_UNUSUAL,
               "[GUM] s_GumJoinUpdateNode Adding node %1!d! to update list for GUM type %2!d!\n",
               JoiningId,
               Type);

    //SS: setting IsLocker to FALSE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                FALSE,
                                FALSE,
                                BufferLength,
                                Buffer);

    // [ahm]: We need to make sure the node is still up, otherwise ignore
    EnterCriticalSection(&GumpLock);
    if (MMIsNodeUp(JoiningId) == TRUE) {
        GumTable[Type].ActiveNode[JoiningId] = TRUE;
    }
    LeaveCriticalSection(&GumpLock);

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumJoinUpdateNode: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               Type,
               Context);

 done:
    if (GumpLastBuffer != NULL) {
        MIDL_user_free(GumpLastBuffer);
    }

    GumpLastBuffer = NULL;
    GumpLastContext = Context;
    GumpLastBufferLength = 0;
    GumpLastUpdateType = Type;
    GumpLastBufferValid = FALSE;

    LeaveCriticalSection(&GumpSendUpdateLock);

    MIDL_user_free(Buffer);
    return(Status);
}


error_status_t
s_GumAttemptJoinUpdate(
    IN handle_t IDL_handle,
    IN DWORD JoiningId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Attempts a locking join update. If the supplied sequence number
    matches and the update lock is not already held, the join update
    will be issued, the joining node will be added to the update list,
    and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    JoiningId - Supplies the nodeid of the joining node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD dwGenerationNum;

    // Buffer is [unique].
    if ( BufferLength == 0 )
        Buffer = NULL;
    else if ( Buffer == NULL )
        BufferLength = 0;

    return(GumpAttemptJoinUpdate(JoiningId, Type, Context, Sequence, BufferLength, 
        Buffer, &dwGenerationNum));

}


error_status_t
s_GumAttemptJoinUpdate2(
    IN handle_t IDL_handle,
    IN DWORD JoiningId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    IN LPDWORD  pdwGenerationNum
    )

/*++

Routine Description:

    Attempts a locking join update. If the supplied sequence number
    matches and the update lock is not already held, the join update
    will be issued, the joining node will be added to the update list,
    and this routine will return with the lock held.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    JoiningId - Supplies the nodeid of the joining node.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.

    pdwGenerationNum - If successful, then the generation number at which the lock 
        is acquired is returned via this parameter.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    // Buffer is [unique].
    if ( BufferLength == 0 )
        Buffer = NULL;
    else if ( Buffer == NULL )
        BufferLength = 0;

    return(GumpAttemptJoinUpdate(JoiningId, Type, Context, Sequence, BufferLength, 
        Buffer, pdwGenerationNum));
}

error_status_t
GumpAttemptJoinUpdate(
    IN DWORD JoiningId,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[],
    IN LPDWORD  pdwGenerationNum
)
{
    DWORD Status;
    PGUM_INFO GumInfo;

    GumInfo = &GumTable[Type];

    if (!GumpTryLockingUpdate(Type, JoiningId, Sequence, pdwGenerationNum)) {
        MIDL_user_free(Buffer);
        return(ERROR_CLUSTER_DATABASE_SEQMISMATCH);
    }

    // sync with replay/updates
    EnterCriticalSection(&GumpSendUpdateLock);

    //SS: set IsLocker to TRUE
    Status = GumpDispatchUpdate(Type,
                                Context,
                                TRUE,
                                FALSE,
                                BufferLength,
                                Buffer);
    if (Status != ERROR_SUCCESS) {
        //
        // The update has failed on this node, unlock here
        // Note we have to use Sequence-1 for the unlock because
        // GumpDispatchUpdate failed and did not increment the
        // sequence number.
        //
        // SS: The generation number should help, if the joining node is declared
        // dead anytime between the joiner acquiring the lock and releasing it
        GumpDoUnlockingUpdate(Type, Sequence-1, JoiningId, *pdwGenerationNum);
    } else {
        CL_ASSERT(NmIsValidNodeId(JoiningId));
        CL_ASSERT(GumpRpcBindings[JoiningId] != NULL);
        CL_ASSERT(GumpReplayRpcBindings[JoiningId] != NULL);

        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] s_GumAttemptJoinUpdate Adding node %1!d! to update list for GUM type %2!d!\n",
                   JoiningId,
                   Type);

        // [ahm]: We need to make sure the node is still up, otherwise ignore
        EnterCriticalSection(&GumpLock);
        if (MMIsNodeUp(JoiningId) == TRUE) {
            GumTable[Type].ActiveNode[JoiningId] = TRUE;
        }
        LeaveCriticalSection(&GumpLock);
        if (GumpLastBuffer != NULL) {
            MIDL_user_free(GumpLastBuffer);
        }
        GumpLastBuffer = NULL;
        GumpLastContext = Context;
        GumpLastBufferLength = 0;
        GumpLastUpdateType = Type;
        GumpLastBufferValid = FALSE;
    }
    LeaveCriticalSection(&GumpSendUpdateLock);
    MIDL_user_free(Buffer);

    return(Status);

}


/****
@func       DWORD | s_GumCollectVoteFromNode| The is the server side
            routine for GumCollectVoteFromNode.

@parm       IN IDL_handle | RPC binding handle, not used.

@parm       IN GUM_UPDATE_TYPE | Type |  The update type for which this
            vote is requested.

@parn       IN DWORD | dwContext | This specifies the context related to the
            Updatetype for which a vote is being seeked.

@parm       IN DWORD | dwInputBufLength | The length of the input buffer
            passed in via pInputBuffer.

@parm       IN PVOID | pInputBuffer | A pointer to the input buffer via
            which the input data for the vote is supplied.

@parm       IN DWORD | dwVoteLength | The length of the vote.  This is
            also the size of the buffer to which pBuf points to.

@parm       OUT PUCHAR | pVoteBuf|  A pointer to a buffer in which
            this node may cast its vote.  The length of the vote must
            not exceed dwVoteLength.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       A node collecting votes invokes this routine to collect a vote
            from the remote node.  This routine simply invokes GumpDispatchVote().

@xref       <f GumpCollectVote> <f GumpDispatchVote>
****/
DWORD
WINAPI
s_GumCollectVoteFromNode(
    IN handle_t IDL_handle,
    IN  DWORD            UpdateType,
    IN  DWORD            dwContext,
    IN  DWORD            dwInputBufLength,
    IN  PUCHAR           pInputBuf,
    IN  DWORD            dwVoteLength,
    OUT PUCHAR           pVoteBuf
    )
{
    DWORD   dwStatus;

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumCollectVote: collecting vote for type %1!u!\tcontext %2!u!\n",
               UpdateType,
               dwContext);

    dwStatus = GumpDispatchVote(UpdateType,
                   dwContext,
                   dwInputBufLength,
                   pInputBuf,
                   dwVoteLength,
                   pVoteBuf);

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] s_GumCollectVote: completed, VoteStatus=%1!u!\n",
               dwStatus);

    return(dwStatus);
}



#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.


error_status_t
s_GumDeliverPostCallback(
    IN handle_t IDL_handle,
    IN DWORD FirstNode,
    IN DWORD Type,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN DWORD Buffer
    )
/*++

Routine Description:

    Callback function used to deliver a posted update that was
    queued.

Arguments:

    IDL_handle - Supplies the RPC binding context, not used.

    FirstNode - Supplies the node ID where the posts should start.
        This is generally the LockerNode+1.

    Type - Supplies the GUM_UPDATE_TYPE of the update

    Context - Supplies the GUM update context

    Sequence - Supplies the sequence that the GUM update must be issued with

    BufferLength - Supplies the length of the update.

    Buffer - Supplies the update data.


Return Value:

    ERROR_SUCCESS

--*/

{

    GumpDeliverPosts(FirstNode,
                     Type,
                     Sequence,
                     Context,
                     BufferLength,
                     (PVOID)Buffer);
    return(ERROR_SUCCESS);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\locker.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    locker.c

Abstract:

    Routines for managing the locker node of the GUM component.

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/
#include "gump.h"


DWORD
GumpDoLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    OUT LPDWORD Sequence,
    OUT LPDWORD pdwGenerationNum
    )

/*++

Routine Description:

    Waits for the GUM lock, captures the sequence number, and issues
    the update on the current node.

Arguments:

    Type - Supplies the type of update

    NodeId - Supplies the node id of the locking node.

    Sequence - Returns the sequence number the update will be issued with

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PGUM_INFO GumInfo;

    CL_ASSERT(Type < GumUpdateMaximum);

    GumInfo = &GumTable[Type];
    ClRtlLogPrint(LOG_NOISE,"[GUM] Thread 0x%1!x! UpdateLock wait on Type %2!u!\n", GetCurrentThreadId(), Type);

    //
    // Acquire the critical section and see if a GUM update is in progress.
    //
    EnterCriticalSection(&GumpLock);
    EnterCriticalSection(&GumpUpdateLock);
    //SS: instead of protecting this with GumpLock, I could simply protect
    //GumNodeGeneration with GumpUpdateLock and remove GumpLock from here and
    //add it to the sync handler.  Chittur, Comments??
    //SS: Actually, I am not sure why we cant fold GumpLock and GumpUpdate lock 
    //into one lock
    
    //because the session cleanup is not synchronized with regroup
    //and there is no hold-io and release-io
    if (GumpLockerNode != NmLocalNodeId)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[GUM] GumpDoLockingUpdate: I, node id %1!d!, am not the locker any more\r\n",
                NmLocalNodeId);
        LeaveCriticalSection(&GumpLock);                
        LeaveCriticalSection(&GumpUpdateLock);
        return(ERROR_CLUSTER_GUM_NOT_LOCKER);
    }
    if (GumpLockingNode == -1) {

        //
        // Nobody owns the lock, therefore we can acquire it and continue immediately.
        // There should also be no waiters.
        //
        CL_ASSERT(IsListEmpty(&GumpLockQueue));
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpDoLockingUpdate: lock was free, granted to %1!d!\n",
                   NodeId);
        GumpLockingNode = NodeId;
        *pdwGenerationNum = GumNodeGeneration[NodeId];
        LeaveCriticalSection(&GumpLock);
        LeaveCriticalSection(&GumpUpdateLock);
    } else {
        GUM_WAITER WaitBlock;

        //
        // Another node owns the lock. Put ourselves onto the GUM lock queue and
        // release the critical section.
        //
        ClRtlLogPrint(LOG_NOISE,"[GUM] GumpDoLockingUpdate: waiting.\n");
        WaitBlock.WaitType = GUM_WAIT_SYNC;
        WaitBlock.NodeId = NodeId;
        WaitBlock.Sync.WakeEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
        CL_ASSERT(WaitBlock.Sync.WakeEvent != NULL);
        InsertTailList(&GumpLockQueue, &WaitBlock.ListEntry);
        LeaveCriticalSection(&GumpLock);
        LeaveCriticalSection(&GumpUpdateLock);

        //
        // We are on the GUM queue, so just wait for the unlocker to wake
        // us up. When we are woken up, we will have ownership of the GUM
        // lock.
        //
        WaitForSingleObject(WaitBlock.Sync.WakeEvent,INFINITE);
        *pdwGenerationNum = WaitBlock.GenerationNum; //waitblock contains the generation number of this node wrt to locker when it obtains the lock
        CloseHandle(WaitBlock.Sync.WakeEvent);
        CL_ASSERT(GumpLockingNode == NodeId);


        ClRtlLogPrint(LOG_NOISE,
            "[GUM] GumpDoLockingUpdate : waiter awakened, lock granted to %1!d!\n", 
            NodeId);

    }
    *Sequence = GumpSequence;
    ClRtlLogPrint(LOG_NOISE,
        "[GUM] GumpDoLockingUpdate successful, Sequence=%1!u! Generation=%2!u!\n", 
        *Sequence, *pdwGenerationNum);
    return(ERROR_SUCCESS);
}





#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.

DWORD
GumpDoLockingPost(
    IN GUM_UPDATE_TYPE Type,
    IN LONG NodeId,
    OUT LPDWORD Sequence,
    IN DWORD Context,
    IN DWORD LockerNodeId,
    IN DWORD BufferLength,
    IN DWORD BufferPtr,
    IN UCHAR Buffer[]
    )

/*++

Routine Description:

    Posts an update.

    If the GUM lock can be immediately acquired, this routine
    behaves exactly like GumpDoLockingUpdate and returns
    ERROR_SUCCESS.

    If the GUM lock is held, this routine queues an asynchronous
    wait block onto the GUM queue and returns ERROR_IO_PENDING.
    When the wait block is removed from the GUM queue, the unlocking
    thread will call GumpDeliverPostUpdate on the specified node
    and supply the passed in context. The calling node can then
    deliver the update.

Arguments:

    Type - Supplies the type of update

    NodeId - Supplies the node id of the locking node.

    Context - Supplies a DWORD context to be used by the post callback.

    Sequence - Returns the sequence number the update will be issued with.
        This is only valid if ERROR_SUCCESS is returned.

    Context - Supplies a DWORD context to be used by the post callback.

    BufferLength - Supplies the length of the buffer to be used by the post callback

    BufferPtr - Supplies the pointer to the actual data on the originating node.

    Buffer - Supplies a pointer to the buffer to be used by the post callback.

Return Value:

    ERROR_SUCCESS if the lock was immediately acquired.

    ERROR_IO_PENDING if the request was queued and the caller will be called back.

--*/

{
    PGUM_INFO GumInfo;
    PGUM_WAITER WaitBlock;

    CL_ASSERT(Type < GumUpdateMaximum);

    GumInfo = &GumTable[Type];
    ClRtlLogPrint(LOG_NOISE,"[GUM] Thread 0x%1!x! UpdateLock post on Type %2!u!\n", GetCurrentThreadId(), Type);

    //
    // Acquire the critical section and see if a GUM update is in progress.
    //
    EnterCriticalSection(&GumpUpdateLock);
    if (GumpLockingNode == -1) {

        //
        // Nobody owns the lock, therefore we can acquire it and continue immediately.
        // There should also be no waiters.
        //
        CL_ASSERT(IsListEmpty(&GumpLockQueue));
        ClRtlLogPrint(LOG_NOISE,"[GUM] PostLockingUpdate successful.\n");
        GumpLockingNode = NodeId;
        LeaveCriticalSection(&GumpUpdateLock);
        *Sequence = GumpSequence;
        return(ERROR_SUCCESS);
    }

    //
    // Another node owns the lock. Put ourselves onto the GUM lock queue and
    // release the critical section.
    //
    ClRtlLogPrint(LOG_NOISE,"[GUM] PostLockingUpdate posting.\n");
    WaitBlock = LocalAlloc(LMEM_FIXED, sizeof(GUM_WAITER));
    CL_ASSERT(WaitBlock != NULL);
    if (WaitBlock ! = NULL)
    {
        ClRtlLogPrint(LOG_UNUSUAL,"[GUM] GumpDoLockingPost : LocalAlloc failed\r\n");
        CL_UNEXPECTED_ERROR(GetLastError());
    }

    WaitBlock->WaitType = GUM_WAIT_ASYNC;
    WaitBlock->NodeId = NodeId;
    WaitBlock->Async.Context = Context;
    WaitBlock->Async.LockerNodeId = LockerNodeId;
    WaitBlock->Async.BufferLength = BufferLength;
    WaitBlock->Async.BufferPtr = BufferPtr;
    WaitBlock->Async.Buffer = Buffer;

    InsertTailList(&GumpLockQueue, &WaitBlock->ListEntry);

    LeaveCriticalSection(&GumpUpdateLock);

    //
    // We are on the GUM queue, so just return ERROR_IO_PENDING. When the
    // unlocking thread pulls us off the GUM queue, it will call our callback
    // and the update can proceed.
    //
    return(ERROR_IO_PENDING);
}

#endif


BOOL
GumpTryLockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD NodeId,
    IN DWORD Sequence,
    OUT LPDWORD pdwGenerationNum
    )

/*++

Routine Description:

    Trys to acquire the GUM lock (does not wait). If successful, compares the
    passed in sequence number to the current sequence number. If they match,
    the locking update is performed.

Arguments:

    Type - Supplies the type of update

    NodeId - Supplies the node id of the locking node.

    Sequence - Supplies the sequence number the update must be issued with

    pdwGenerationNum - If TRUE is returned, then this contains the generation number of the 
    NodeId when it is granted the lock.

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    PGUM_INFO GumInfo;
    BOOL Success;

    CL_ASSERT(Type < GumUpdateMaximum);

    GumInfo = &GumTable[Type];

    ClRtlLogPrint(LOG_NOISE,
        "[GUM] GumpTryLockingUpdate Thread 0x%1!x! UpdateLock wait on Type %2!u!\n", 
        GetCurrentThreadId(), Type);

    //
    // Acquire the critical section and see if a GUM update is in progress.
    //
    // SS: Acquire the GumpLock to protect the node generation number
    // Or should we just use the GumpUpdateLock to protect the generation number of nodes
    EnterCriticalSection(&GumpLock);
    EnterCriticalSection(&GumpUpdateLock);

    CL_ASSERT(GumpLockerNode == NmLocalNodeId);
    if (GumpSequence != Sequence)
    {

        //
        // The supplied sequence number does not match.
        //
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumpTryLockingUpdate supplied sequence %1!d! doesn't match %2!d!\n",
                   Sequence,
                   GumpSequence);
        Success = FALSE;
        goto FnExit;
    }
    if (GumpLockingNode == -1) {

        //
        // Nobody owns the lock, therefore we can acquire it and continue immediately.
        // There should also be no waiters.
        //
        CL_ASSERT(IsListEmpty(&GumpLockQueue));
        GumpLockingNode = NodeId;
        *pdwGenerationNum = GumNodeGeneration[NodeId];
        ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumpTryLockingUpdate successful. Lock granted to node %1!d! at GenerationNum %2!u!\n",
               NodeId, *pdwGenerationNum);
        Success = TRUE;;
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumpTryLockingUpdate update lock held\n");
        Success = FALSE;
    }

    //release the critical section and return
FnExit:
    LeaveCriticalSection(&GumpLock);
    LeaveCriticalSection(&GumpUpdateLock);
    return(Success);
}



VOID
GumpDoUnlockingUpdate(
    IN GUM_UPDATE_TYPE Type,
    IN DWORD Sequence,
    IN DWORD NodeId,
    IN DWORD GenerationNum
    )

/*++

Routine Description:

    Unlocks an earlier locking update

Arguments:

    Type - Supplies the type of update to unlock

    Sequence - Supplies the sequence number to unlock

Return Value:

    None.

--*/

{
    PGUM_INFO GumInfo;
    PGUM_WAITER Waiter;
    PLIST_ENTRY ListEntry;

    //Dont use the gumupdate type in this function, otherwise
    //know that it may be set to gumupdatemaximum in case the
    //forming node fails immediately after a join and the joiner
    //node becomes the locker node.  The new locker might then
    //call reupdate/unlock with type=gumupdatemaximum
    CL_ASSERT(Type <= GumUpdateMaximum);

    GumInfo = &GumTable[Type];

    //SS: should we remove this assert
    //CL_ASSERT(Sequence == GumpSequence - 1);

    if (Sequence != GumpSequence - 1) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[GUM] GumpDoLockingUpdate: Sequence Mismatch, Type %1!u!, Sequence %2!u!, GumpSequence %3!u!\n", 
            Type, Sequence, GumpSequence);
        return;
    }

    //
    // Acquire the critical section and see if there are any waiters.
    //
    // SS: acquire the GumpLock to protect the Gumnodegeneration array
    EnterCriticalSection(&GumpLock);
    EnterCriticalSection(&GumpUpdateLock);

    // If the unlock is made in a different generation from which the lock was issued in
    // then fail the request.  If the request comes from a win2K node, the node id will 
    // be set to ClusterInvalidNodeId in which case we will simply not perform the check
    // This implies that we dont fix the bug where a dead node can unlock the gumlock 
    // while the locking node has assumed its ownership in a mixed mode cluster
    // Oh well, I dont think that is too bad :-)

    if ((NodeId != ClusterInvalidNodeId) && 
         (GumNodeGeneration[NodeId] != GenerationNum))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[GUM] GumpDoUnlockingUpdate: Generation Mismatch, Type %1!u! Sequence %2!u! NodeId %3!u! GenNum %4!u! CurrentGen %5!u!\n", 
            Type, Sequence, NodeId, GenerationNum, GumNodeGeneration[NodeId]);
        LeaveCriticalSection(&GumpLock);
        LeaveCriticalSection(&GumpUpdateLock);
        return;

    }
    //
    // Pull the next waiter off the queue. If it is an async waiter,
    // issue that update now. If it is a sync waiter, grant ownership
    // of the GUM lock and wake the waiting thread.
    //
    while (!IsListEmpty(&GumpLockQueue)) {
        ListEntry = RemoveHeadList(&GumpLockQueue);
        Waiter = CONTAINING_RECORD(ListEntry,
                                   GUM_WAITER,
                                   ListEntry);

        //
        // Set the new locking node, then process the update
        //

        // The new locker node may not be a part of the cluster any more.
        // We check if the Waiter node has rebooted when we wake up.

        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumpDoUnlockingUpdate granting lock ownership to node %1!d!\n",
                   Waiter->NodeId);
        GumpLockingNode = Waiter->NodeId;

#ifndef GUM_POST_SUPPORT
        CL_ASSERT(Waiter->WaitType == GUM_WAIT_SYNC);
        
        Waiter->GenerationNum = GumNodeGeneration[GumpLockingNode];
        SetEvent(Waiter->Sync.WakeEvent);
        //
        // The waiting thread now has ownership and is responsible
        // for any other items on the queue. Drop the lock and
        // return now.
        //
        LeaveCriticalSection(&GumpLock);
        LeaveCriticalSection(&GumpUpdateLock);
        return;

#else
        if (Waiter->WaitType == GUM_WAIT_SYNC) {
            Waiter.Generation = GumNodeGeneration[GumpLockingNode]
            SetEvent(Waiter->Sync.WakeEvent);

            //
            // The waiting thread now has ownership and is responsible
            // for any other items on the queue. Drop the lock and
            // return now.
            //
            LeaveCriticalSection(&GumpUpdateLock);
            LeaveCriticalSection(GumpLock);
            return;
        } else {

            CL_ASSERT(Waiter->WaitType == GUM_WAIT_ASYNC);
            //
            // If the update originated on this node, go ahead and do the work
            // right here. Otherwise, issue the GUM callback to the originating
            // node to let them complete the post.
            //
            LeaveCriticalSection(&GumpUpdateLock);
            if (Waiter->NodeId == NmGetNodeId(NmLocalNode)) {

                //
                // Deliver the updates to the other nodes.
                //
                //SS:BUG BUG sort the locker details
                GumpDeliverPosts(NmGetNodeId(NmLocalNode)+1,
                                 Type,
                                 GumpSequence,
                                 Waiter->Async.Context,
                                 FALSE,
                                 Waiter->Async.BufferLength,
                                 Waiter->Async.Buffer);
                GumpSequence += 1;     // update ourself to stay in sync.

            } else {

                //
                // Call back to the originating node to deliver the posts.
                // First dispatch the update locally to save a round-trip.
                //
                //SS: sort thelocker details
                GumpDispatchUpdate(Type,
                                   Waiter->Async.Context,
                                   FALSE,
                                   FALSE,
                                   Waiter->Async.BufferLength,
                                   Waiter->Async.Buffer);

                CL_ASSERT(GumpRpcBindings[Waiter->NodeId] != NULL);
                GumDeliverPostCallback(GumpRpcBindings[Waiter->NodeId],
                                       NmGetNodeId(NmLocalNode)+1,
                                       Type,
                                       GumpSequence-1,
                                       Waiter->Async.Context,
                                       Waiter->Async.BufferLength,
                                       Waiter->Async.BufferPtr);
                MIDL_user_free(Waiter->Async.Buffer);
            }

            //
            // Free the wait block and process the next entry on the queue.
            //
            LocalFree(Waiter);

            EnterCriticalSection(&GumpUpdateLock);

        }
#endif
    }
    //
    // No more waiters, just unlock and we are done.
    //
    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumpDoUnlockingUpdate releasing lock ownership\n");
    GumpLockingNode = (DWORD)-1;
    LeaveCriticalSection(&GumpUpdateLock);
    LeaveCriticalSection(&GumpLock);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\send.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    send.c

Abstract:

    Routines for sending global updates to the cluster

Author:

    John Vert (jvert) 17-Apr-1996

Revision History:

--*/

#include "gump.h"


DWORD
WINAPI
GumSendUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Sends an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated.

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/

{
    return(
        GumSendUpdateReturnInfo(
            UpdateType, 
            Context, 
            NULL, 
            BufferLength, 
            Buffer
            )
        );

} // GumSendUpdate


DWORD
GumpUpdateRemoteNode(
    IN PRPC_ASYNC_STATE AsyncState,
    IN DWORD RemoteNodeId,
    IN DWORD UpdateType,
    IN DWORD Context,
    IN DWORD Sequence,
    IN DWORD BufferLength,
    IN UCHAR Buffer[]
    )
/*++

Routine Description:

    Issues an update request to a remote node using async RPC.
    
Arguments:

    AsyncState - A pointer to an RPC async state block. The u.hEvent
        member field must contain a valid event object handle. 
                
    RemoteNodeId - Target of the update.
         
    Type - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers
        
    ReturnStatusArray - Pointer to an array of structures to be filled in 
        with the return value from the update handler on each node. The 
        array is indexed by node ID. 

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.

--*/
{
    DWORD       Status;
    HANDLE      hEventHandle;
    BOOL        result;
    PNM_NODE    Node;
    HANDLE      handleArr[2];
    
    
    CL_ASSERT(AsyncState->u.hEvent != NULL);

    //
    // Initialize the async RPC tracking information
    //
    hEventHandle = AsyncState->u.hEvent;
    AsyncState->u.hEvent = NULL;
    
    
    Status = RpcAsyncInitializeHandle(AsyncState, sizeof(RPC_ASYNC_STATE));
    AsyncState->u.hEvent = hEventHandle;

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[GUM] UpdateRemoteNode: Failed to initialize async RPC status "
            "block, status %1!u!\n",
            Status
            );

        return (Status);
    }

    AsyncState->UserInfo = NULL;
    AsyncState->NotificationType = RpcNotificationTypeEvent;
    

    result = ResetEvent(AsyncState->u.hEvent);
    CL_ASSERT(result != 0);

    // Now hook onto NM node state down event mechanism to detect node downs,
    // instead of NmStartRpc()/NmEndRpc().
    Node = NmReferenceNodeById(RemoteNodeId);
    CL_ASSERT(Node != NULL);
    handleArr[0] = AsyncState->u.hEvent;
    handleArr[1] = NmGetNodeStateDownEvent(Node);
    
    try {

        Status = GumUpdateNode(
                     AsyncState,
                     GumpRpcBindings[RemoteNodeId],
                     UpdateType,
                     Context,
                     Sequence,
                     BufferLength,
                     Buffer
                     );

        if (Status == RPC_S_OK) {
            DWORD RpcStatus;
            DWORD WaitStatus;
            //
            // The call is pending. Wait for completion.
            //
            WaitStatus = WaitForMultipleObjects(
                        2,
                        handleArr,
                        FALSE,
                        INFINITE
                        );

            if (WaitStatus != WAIT_OBJECT_0) {
                //
                // Something went wrong. 
                // Either this is a rpc failure or, the target node went down. In either case
                // the error path is the same, complete the call and evict the target node 
                // (eviction is done by the caller of this function).
                //
                
                ClRtlLogPrint(LOG_CRITICAL,
                    "[GUM] GumUpdateRemoteNode: WaitforMultipleObjects returned %1!u!\n",
                    WaitStatus
                    );
                if  (WaitStatus == WAIT_FAILED) {
                    Status = GetLastError();
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[GUM] GumUpdateRemoteNode: WaitforMultipleObjects returned WAIT_FAILED, status %1!u!\n",
                        Status);
                    //SS: unexpected error - kill yourself                       
                    CsInconsistencyHalt(Status);                        
                }
                else if (WaitStatus != (WAIT_OBJECT_0 + 1)) {
                    Status = GetLastError();
                    //wait objects  abandoned - can that happen with events?
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[GUM] GumUpdateRemoteNode: WaitforMultipleObjects failed, status %1!u!\n",
                        Status);
                    //SS: unexpected error - kill yourself                        
                    CsInconsistencyHalt(Status);                        
                    
                }
                // SS: we only come here if the remote node is signalled to be down
                // make sure that a non-zero status  is returned to the caller
                // so that the gum  eviction occurs  as desirable
                //
                // Cancel the call, just to be safe.
                //
                RpcStatus = RpcAsyncCancelCall(
                                AsyncState, 
                                TRUE         // Abortive cancel
                                );
                if (RpcStatus != RPC_S_OK) {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[GUM] GumUpdateRemoteNode: RpcAsyncCancelCall()= %1!u!\n",
                        RpcStatus
                        );
                    Status = RpcStatus;                        
                }
                else {
                    CL_ASSERT(RpcStatus == RPC_S_OK);

                    //
                    // Wait for the call to complete.
                    //
                    WaitStatus = WaitForSingleObject(
                                 AsyncState->u.hEvent,
                                 INFINITE
                                 );
                    if (WaitStatus != WAIT_OBJECT_0) {
                        ClRtlLogPrint(LOG_CRITICAL,
                            "[GUM] GumUpdateRemoteNode: WaitForSingleObject() returns= %1!u!\n",
                            WaitStatus);
                        ClRtlLogPrint(LOG_CRITICAL,
                            "[GUM] GumUpdateRemoteNode: Mapping Status  to WAIT_FAILED\n");
                            
                        //SS: if this  call doesnt complete,  there is something
                        //strange with RPC - should we kill ourselves or kill the other
                        //node
                        //SS: for now we asssume that the problem is not local
                        Status = WAIT_FAILED;
                        
                    }
                }                
            }

            //
            // The call should now be complete. Get the
            // completion status. Any RPC error will be 
            // returned in 'RpcStatus'. If there was no 
            // RPC error, then any application error will 
            // be returned in 'Status'.
            //
            RpcStatus = RpcAsyncCompleteCall(
                            AsyncState, 
                            &Status
                            );

            if (RpcStatus != RPC_S_OK) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[GUM] GumUpdateRemoteNode: Failed to get "
                    "completion status for async RPC call," 
                    "status %1!u!\n",
                    RpcStatus
                    );
                Status = RpcStatus;
            }
        }
        else {
            // An error was returned synchronously.
            ClRtlLogPrint(LOG_CRITICAL,
                "[GUM] GumUpdateRemoteNode: GumUpdateNode() failed synchronously, status %1!u!\n",
                Status
                );
        }

        OmDereferenceObject(Node);

    } except (I_RpcExceptionFilter(RpcExceptionCode())) { 
        OmDereferenceObject(Node);
        Status = GetExceptionCode();
    }

    return(Status);

} // GumpUpdateRemoteNode


DWORD
WINAPI
GumSendUpdateReturnInfo(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    OUT PGUM_NODE_UPDATE_HANDLER_STATUS ReturnStatusArray,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )
/*++

Routine Description:

    Sends an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. Any registered update handlers
    for the current node will be called on the same thread.
    This is useful for correct synchronization of the data
    structures to be updated. 

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers
        
    ReturnStatusArray - Pointer to an array of structures to be filled in 
        with the return value from the update handler on each node. The 
        array is indexed by node ID. The array must be at least 
        (NmMaxNodeId + 1) entries in length.

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.

--*/
{
    DWORD Sequence;
    DWORD Status=RPC_S_OK;
    DWORD i;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;
    DWORD LockerNode;
    RPC_ASYNC_STATE AsyncState;
    DWORD   GenerationNum; //the generation number wrt to the locker at which the lock is obtained
    BOOL    AssumeLockerWhistler = TRUE; 

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    //
    // Prepare for async RPC. We do this here to avoid hitting a failure 
    // after the update is already in progress.
    //
    ZeroMemory((PVOID) &AsyncState, sizeof(RPC_ASYNC_STATE));

    AsyncState.u.hEvent = CreateEvent(
                               NULL,  // no attributes
                               TRUE,  // manual reset
                               FALSE, // initial state unsignalled
                               NULL   // no object name
                               );

    if (AsyncState.u.hEvent == NULL) {
        Status = GetLastError();

        ClRtlLogPrint(LOG_CRITICAL,
            "[GUM] GumSendUpdate: Failed to allocate event object for async "
            "RPC call, status %1!u!\n",
            Status
            );

        return (Status);
    }

    //
    // Initialize the return status array
    //
    if (ReturnStatusArray != NULL) {
        for (i=ClusterMinNodeId; i<=NmMaxNodeId; i++) {
            ReturnStatusArray[i].UpdateAttempted = FALSE;
            ReturnStatusArray[i].ReturnStatus = ERROR_NODE_NOT_AVAILABLE;
        }
    } 

    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    // Grab an RPC handle
    GumpStartRpc(MyNodeId);

retryLock:
    LockerNode = GumpLockerNode;
    //
    // Send locking update to the locker node.
    //
    if (LockerNode == MyNodeId) {
        //
        // This node is the locker.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumSendUpdate:  Locker waiting\t\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        Status = GumpDoLockingUpdate(UpdateType, MyNodeId, &Sequence, &GenerationNum);
        if (Status == ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumSendUpdate: Locker dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
                       Sequence,
                       UpdateType,
                       Context);
            Status = GumpDispatchUpdate(UpdateType,
                                        Context,
                                        TRUE,
                                        TRUE,
                                        BufferLength,
                                        Buffer);

            if (ReturnStatusArray != NULL) {
                ReturnStatusArray[MyNodeId].UpdateAttempted = TRUE;
                ReturnStatusArray[MyNodeId].ReturnStatus = Status;
            }
                        
            if (Status != ERROR_SUCCESS) {
                //
                // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
                // failed and did not increment the sequence number.
                //
                GumpDoUnlockingUpdate(UpdateType, Sequence-1, MyNodeId, GenerationNum);
            }
        }
    } else {
//        CL_ASSERT(GumpRpcBindings[i] != NULL);
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumSendUpdate: queuing update\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        AssumeLockerWhistler = TRUE;
                  
RetryLockForRollingUpgrade:
        try {
            NmStartRpc(LockerNode);
            if (AssumeLockerWhistler)
            {
                Status = GumQueueLockingUpdate2(GumpRpcBindings[LockerNode],
                                           MyNodeId,
                                           UpdateType,
                                           Context,
                                           &Sequence,
                                           BufferLength,
                                           Buffer,
                                           &GenerationNum);
            }
            else
            {
                //call the win2K version
                Status = GumQueueLockingUpdate(GumpRpcBindings[LockerNode],
                                           MyNodeId,
                                           UpdateType,
                                           Context,
                                           &Sequence,
                                           BufferLength,
                                           Buffer);
            }
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) { 
            //
            // An exception from RPC indicates that the other node is either dead
            // or insane. Kill it and retry with a new locker.
            //

            NmEndRpc(LockerNode);

            Status = GetExceptionCode();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[GUM] GumSendUpdate: GumQueueLocking update to node %1!d! failed with %2!d!\n",
                       LockerNode,
                       Status);
            if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
            {
                //the locker node is win2K, try the old interface
                AssumeLockerWhistler = FALSE; 
                goto RetryLockForRollingUpgrade;
            }
            else 
            {
                GumpCommFailure(GumInfo,
                            LockerNode,
                            GetExceptionCode(),
                            TRUE);
                //
                // The GUM update handler must have been called to select a new locker
                // node.
                //
                CL_ASSERT(LockerNode != GumpLockerNode);

                //
                // Retry the locking update with the new locker node.
                //
                goto retryLock;
            }                
        }

        if (ReturnStatusArray != NULL) {
            ReturnStatusArray[LockerNode].UpdateAttempted = TRUE;
            ReturnStatusArray[LockerNode].ReturnStatus = Status;
        }
        
        if (Status == ERROR_SUCCESS) {
            CL_ASSERT(Sequence == GumpSequence);
        }

        if (Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }

        //because there is no synchronization between join and regroups/gumprocessing
        //the old locker node may die and may come up again and not be the locker
        //anymore. We have to take care of this case.
        if (Status == ERROR_CLUSTER_GUM_NOT_LOCKER)
        {
            goto retryLock;
        }
    }
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] Queued lock attempt for send type %1!d! failed %2!d!\n",
                   UpdateType,
                   Status);
        // signal end of RPC handle
        GumpEndRpc(MyNodeId);
        if (AsyncState.u.hEvent != NULL) {
            CloseHandle(AsyncState.u.hEvent);
        }
        return(Status);
    }

    //
    // Grap the sendupdate lock to serialize with any replays
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    if (LockerNode != GumpLockerNode) {
        //
        // Locker node changed, we need to restart again.
        //
        LeaveCriticalSection(&GumpSendUpdateLock);
        goto retryLock;
    }

    //
    // The update is now committed on the locker node. All remaining nodes
    // must be updated successfully, or they will be killed.
    //
    for (i=LockerNode+1; i != LockerNode; i++) {
        if (i == (NmMaxNodeId + 1)) {
            i=ClusterMinNodeId;
            if (i==LockerNode) {
                break;
            }
        }

        if (GumInfo->ActiveNode[i]) {
            //
            // Dispatch the update to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumSendUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);
            if (i == MyNodeId) {
                Status = GumpDispatchUpdate(UpdateType,
                                   Context,
                                   FALSE,
                                   TRUE,
                                   BufferLength,
                                   Buffer);


                if (ReturnStatusArray != NULL) {
                    ReturnStatusArray[i].UpdateAttempted = TRUE;
                    ReturnStatusArray[i].ReturnStatus = Status;
                }
                
                if (Status != ERROR_SUCCESS){
                    ClRtlLogPrint(LOG_CRITICAL,
                            "[GUM] GumSendUpdate: Update on non-locker node(self) failed with %1!d! when it must succeed\n",
                            Status);
                    //Commit Suicide
                    CsInconsistencyHalt(Status);
                }

            } else {
                DWORD dwStatus;

                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumSendUpdate: Locker updating seq %1!u!\ttype %2!u! context %3!u!\n",
                           Sequence,
                           UpdateType,
                           Context);

                dwStatus = GumpUpdateRemoteNode(
                             &AsyncState,
                             i,
                             UpdateType,
                             Context,
                             Sequence,
                             BufferLength,
                             Buffer
                             );

                if (ReturnStatusArray != NULL) {
                    ReturnStatusArray[i].UpdateAttempted = TRUE;
                    ReturnStatusArray[i].ReturnStatus = dwStatus; 
                }

                //
                // If the update on the other node failed, then the
                // other node must now be out of the cluster since the
                // update has already completed on the locker node.
                //
                if (dwStatus != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[GUM] GumSendUpdate: Update on node %1!d! failed with %2!d! when it must succeed\n",
                                i,
                                dwStatus);

                    NmDumpRpcExtErrorInfo(dwStatus);

                    GumpCommFailure(GumInfo,
                                    i,
                                    dwStatus,
                                    TRUE);
                }  
            }   
        }  
     }  

    //
    // Our update is over
    //
    LeaveCriticalSection(&GumpSendUpdateLock);

    //
    // All nodes have been updated. Send unlocking update.
    //
    if (LockerNode == MyNodeId) {
        GumpDoUnlockingUpdate(UpdateType, Sequence, MyNodeId, GenerationNum);
    } else {
        //SS: We will assume that AssumeLockerWhistler is set appropriately when the lock was acquired
        try {
            NmStartRpc(LockerNode);
            if (AssumeLockerWhistler)
            {
                //SS: the sequence number will protect if the locker has gone down 
                //and come back up since we got the lock and tried to release it
                Status = GumUnlockUpdate2(
                    GumpRpcBindings[LockerNode],
                    UpdateType,
                    Sequence,
                    MyNodeId,
                    GenerationNum
                    );
            }
            else
            {
                Status = GumUnlockUpdate(
                    GumpRpcBindings[LockerNode],
                    UpdateType,
                    Sequence);
            }
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) { 
            //
            // The locker node has crashed. Notify the NM, it will call our
            // notification routine to select a new locker node. Then retry
            // the unlock on the new locker node.
            // SS: changed to not retry unlocks..the new locker node will
            // unlock after propagating this change in any case.
            //
            NmEndRpc(LockerNode);
            Status = GetExceptionCode();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[GUM] GumSendUpdate: Unlocking update to node %1!d! failed with %2!d!\n",
                       LockerNode,
                       Status);
            GumpCommFailure(GumInfo,
                        LockerNode,
                        Status,
                        TRUE);
            CL_ASSERT(LockerNode != GumpLockerNode);
        }

        if(Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               UpdateType,
               Context);

    // signal end of RPC handle
    GumpEndRpc(MyNodeId);

    if (AsyncState.u.hEvent != NULL) {
        CloseHandle(AsyncState.u.hEvent);
    }
    
    return(ERROR_SUCCESS);

} // GumSendUpdateReturnInfo


#ifdef GUM_POST_SUPPORT

    John Vert (jvert) 11/18/1996
    POST is disabled for now since nobody uses it.
    N.B. The below code does not handle locker node failures


DWORD
WINAPI
GumPostUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer                 // THIS WILL BE FREED
    )

/*++

Routine Description:

    Posts an update to all active nodes in the cluster. All
    registered update handlers for the specified UpdateType
    are called on each node. The update will not be reported
    on the current node. The update will not necessarily have
    completed when this function returns, but will complete
    eventually if the current node does not fail.

Arguments:

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers. THIS BUFFER WILL BE FREED ONCE THE
        POST HAS COMPLETED.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/
{
    DWORD Sequence;
    DWORD Status;
    DWORD i;
    BOOL IsLocker = TRUE;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;
    DWORD LockerNode=(DWORD)-1;

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    //
    // Find the lowest active node in the cluster. This is the
    // locker.
    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i]) {
            LockerNode = i;
            break;
        }
    }

    CL_ASSERT(i <= NmMaxNodeId);

    //
    // Post a locking update to the locker node. If this succeeds
    // immediately, we can go do the work directly. If it pends,
    // the locker node will call us back when it is our turn to
    // make the updates.
    //
    if (i == MyNodeId) {
        //
        // This node is the locker.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: Locker waiting\t\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        Status = GumpDoLockingPost(UpdateType,
                                   MyNodeId,
                                   &Sequence,
                                   Context,
                                   BufferLength,
                                   (DWORD)Buffer,
                                   Buffer);
        if (Status == ERROR_SUCCESS) {
            //
            // Update our sequence number so we stay in sync, even though
            // we aren't dispatching the update.
            //
            GumpSequence += 1;
        }
    } else {
        CL_ASSERT(GumpRpcBindings[i] != NULL);
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: queuing update\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        Status = GumQueueLockingPost(GumpRpcBindings[i],
                                     MyNodeId,
                                     UpdateType,
                                     Context,
                                     &Sequence,
                                     BufferLength,
                                     Buffer,
                                     (DWORD)Buffer);
        if (Status == ERROR_SUCCESS) {
            CL_ASSERT(Sequence == GumpSequence);
        }
    }

    if (Status == ERROR_SUCCESS) {
        //
        // The lock was immediately acquired, go ahead and post directly
        // here.
        //
        GumpDeliverPosts(LockerNode+1,
                         UpdateType,
                         Sequence,
                         Context,
                         BufferLength,
                         Buffer);

        //
        // All nodes have been updated. Send unlocking update.
        //
        if (LockerNode == MyNodeId) {
            GumpDoUnlockingUpdate(UpdateType, Sequence);
        } else {
            GumUnlockUpdate(
                GumpRpcBindings[LockerNode],
                UpdateType,
                Sequence
                );
        }

        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
                   Sequence,
                   UpdateType,
                   Context);

        return(ERROR_SUCCESS);
    } else {
        //
        // The lock is currently held. We will get called back when it is released
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumPostUpdate: pending update type %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        return(ERROR_IO_PENDING);
    }

}


VOID
GumpDeliverPosts(
    IN DWORD FirstNodeId,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Sequence,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer                 // THIS WILL BE FREED
    )
/*++

Routine Description:

    Actually delivers the update post to the specified nodes.
    The GUM lock is assumed to be held.

Arguments:

    FirstNodeId - Supplies the node ID where the posts should start.
        This is generally the LockerNode+1.

    UpdateType - Supplies the type of update. This determines
        which update handlers will be called and the sequence
        number to be used.

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to
        be passed to the update handlers

    Buffer - Supplies a pointer to the update buffer to be passed
        to the update handlers. THIS BUFFER WILL BE FREED ONCE THE
        POST HAS COMPLETED.

Return Value:

    None.

--*/

{
    DWORD i;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;


    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    for (i=FirstNodeId; i<=NmMaxNodeId; i++) {
        if (GumInfo->ActiveNode[i]) {
            //
            // Dispatch the update to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumpDeliverPosts: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);
            if (i == MyNodeId) {
                //
                // Update our sequence number so we stay in sync, even though
                // we aren't dispatching the update.
                //
                GumpSequence += 1;
            } else {
                CL_ASSERT(GumpRpcBindings[i] != NULL);
                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumpDeliverPosts: Locker updating seq %1!u!\ttype %2!u! context %3!u!\n",
                           Sequence,
                           UpdateType,
                           Context);



                GumUpdateNode(GumpRpcBindings[i],
                              UpdateType,
                              Context,
                              Sequence,
                              BufferLength,
                              Buffer);
            }
        }
    }

    LocalFree(Buffer);
}

#endif


DWORD
WINAPI
GumAttemptUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Conditionally sends an update to all active nodes in the
    cluster. If the clusterwise sequence number matches the supplied
    sequence number, all registered update handlers for the specified
    UpdateType are called on each node. Any registered update handlers
    for the current node will be called on the same thread. This is
    useful for correct synchronization of the data structures to be updated.

    The normal usage of this routine is as follows:
         obtain current sequence number from GumGetCurrentSequence
         make modification to cluster state
         conditionally update cluster state with GumAttemptUpdate
         If update fails, undo modification, release any locks, try again later

Arguments:

    Sequence - Supplies the sequence number obtained from GumGetCurrentSequence.

    UpdateType - Supplies the type of update. This determines which update handlers
        will be called

    Context - Supplies a DWORD of context to be passed to the
        GUM update handlers

    BufferLength - Supplies the length of the update buffer to be passed to the
        update handlers

    Buffer - Supplies a pointer to the update buffer to be passed to the update
        handlers.

Return Value:

    ERROR_SUCCESS if the request is successful.

    Win32 error code on failure.


--*/
{
    DWORD Status=RPC_S_OK;
    DWORD i;
    PGUM_INFO GumInfo;
    DWORD MyNodeId;
    DWORD LockerNode=(DWORD)-1;
    RPC_ASYNC_STATE AsyncState;
    DWORD   dwGenerationNum; //the generation id of the node at which the lock is acquired

    CL_ASSERT(UpdateType < GumUpdateMaximum);

    ZeroMemory((PVOID) &AsyncState, sizeof(RPC_ASYNC_STATE));

    AsyncState.u.hEvent = CreateEvent(
                               NULL,  // no attributes
                               TRUE,  // manual reset
                               FALSE, // initial state unsignalled
                               NULL   // no object name
                               );

    if (AsyncState.u.hEvent == NULL) {
        Status = GetLastError();

        ClRtlLogPrint(LOG_CRITICAL,
            "[GUM] GumAttemptUpdate: Failed to allocate event object for "
            "async RPC call, status %1!u!\n",
            Status
            );

        return (Status);
    }


    GumInfo = &GumTable[UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

retryLock:
    LockerNode = GumpLockerNode;

    //
    // Send locking update to the locker node.
    //
    if (LockerNode == MyNodeId)
    {
        //
        // This node is the locker.
        //
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumAttemptUpdate: Locker waiting\t\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);

        if (GumpTryLockingUpdate(UpdateType, MyNodeId, Sequence, &dwGenerationNum))
        {
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumAttemptUpdate: Locker dispatching seq %1!u!\ttype %2!u! context %3!u!\n",
                       Sequence,
                       UpdateType,
                       Context);
            Status = GumpDispatchUpdate(UpdateType,
                                        Context,
                                        TRUE,
                                        TRUE,
                                        BufferLength,
                                        Buffer);
            if (Status != ERROR_SUCCESS) {
                //
                // Note we have to use Sequence-1 for the unlock because GumpDispatchUpdate
                // failed and did not increment the sequence number.
                //
                GumpDoUnlockingUpdate(UpdateType, Sequence-1, MyNodeId, dwGenerationNum);
            }
         }
         else
         {
            Status = ERROR_CLUSTER_DATABASE_SEQMISMATCH;
         }
    }
    else
    {
        //
        //send the locking update to the locker node
        ClRtlLogPrint(LOG_NOISE,
                   "[GUM] GumAttemptUpdate: queuing update\ttype %1!u! context %2!u!\n",
                   UpdateType,
                   Context);
        try {
            NmStartRpc(LockerNode);
            Status = GumAttemptLockingUpdate(GumpRpcBindings[LockerNode],
                                             MyNodeId,
                                             UpdateType,
                                             Context,
                                             Sequence,
                                             BufferLength,
                                             Buffer);
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // An exception from RPC indicates that the other node is either dead
            // or insane. Kill it and retry with a new locker.
            //
            NmEndRpc(LockerNode);
            GumpCommFailure(GumInfo,
                            LockerNode,
                            GetExceptionCode(),
                            TRUE);

            //
            // The GUM update handler must have been called to select a new locker
            // node.
            //
            CL_ASSERT(LockerNode != GumpLockerNode);

            //
            // Retry the locking update with the new locker node.
            //
            goto retryLock;
        }
        if (Status == ERROR_SUCCESS)
        {
            CL_ASSERT(Sequence == GumpSequence);
        }

        if(Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }

    }

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[GUM] GumAttemptUpdate: Queued lock attempt for send type %1!d! failed %2!d!\n",
                   UpdateType,
                   Status);
        return(Status);
    }

    //
    // Grap the sendupdate lock to serialize with any replays
    //
    EnterCriticalSection(&GumpSendUpdateLock);
    if (LockerNode != GumpLockerNode) {
        //
        // Locker node changed, we need to restart again.
        //
        LeaveCriticalSection(&GumpSendUpdateLock);
    goto retryLock;
    }


    // The update is now committed on the locker node. All remaining nodes
    // must be updated successfully, or they will be killed.
    //
    for (i=LockerNode+1; i != LockerNode; i++)
    {
        if (i == (NmMaxNodeId + 1))
        {
            i=ClusterMinNodeId;
            if (i==LockerNode)
            {
                break;
            }
        }

        if (GumInfo->ActiveNode[i])
        {
            //
            // Dispatch the update to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumAttemptUpdate: Dispatching seq %1!u!\ttype %2!u! context %3!u! to node %4!d!\n",
                       Sequence,
                       UpdateType,
                       Context,
                       i);
            if (i == MyNodeId) {
                Status = GumpDispatchUpdate(UpdateType,
                                   Context,
                                   FALSE,
                                   TRUE,
                                   BufferLength,
                                   Buffer);
                if (Status != ERROR_SUCCESS){
                    ClRtlLogPrint(LOG_CRITICAL,
                            "[GUM] GumAttemptUpdate: Update on non-locker node(self) failed with %1!d! when it must succeed\n",
                            Status);
                    //Commit Suicide
                    CsInconsistencyHalt(Status);
                }

            } else {
                DWORD dwStatus;

                ClRtlLogPrint(LOG_NOISE,
                           "[GUM] GumAttemptUpdate: Locker updating seq %1!u!\ttype %2!u! context %3!u!\n",
                           Sequence,
                           UpdateType,
                           Context);
                
                dwStatus = GumpUpdateRemoteNode(
                             &AsyncState,
                             i,
                             UpdateType,
                             Context,
                             Sequence,
                             BufferLength,
                             Buffer
                             );

                //
                // If the update on the other node failed, then the
                // other node must now be out of the cluster since the
                // update has already completed on the locker node.
                //
                if (dwStatus != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[GUM] GumAttemptUpdate: Update on node %1!d! failed with %2!d! when it must succeed\n",
                                i,
                                dwStatus);

                    NmDumpRpcExtErrorInfo(dwStatus);

                    GumpCommFailure(GumInfo,
                                    i,
                                    dwStatus,
                                    TRUE);
                }
            }
        }
    }
    //
    // Our update is over
    //
    LeaveCriticalSection(&GumpSendUpdateLock);

    //
    // All nodes have been updated. Send unlocking update.
    //
    if (LockerNode == MyNodeId) {
        GumpDoUnlockingUpdate(UpdateType, Sequence, MyNodeId, dwGenerationNum);
    } else {
        try {
            NmStartRpc(LockerNode);
            Status = GumUnlockUpdate(
                GumpRpcBindings[LockerNode],
                UpdateType,
                Sequence
                );
            NmEndRpc(LockerNode);
        } except (I_RpcExceptionFilter(RpcExceptionCode())) {
            //
            // The locker node has crashed. Notify the NM, it will call our
            // notification routine to select a new locker node. The new
            // locker node will release the gum lock after propagating
            // the current update.
            //
            NmEndRpc(LockerNode);
            Status = GetExceptionCode();
            ClRtlLogPrint(LOG_CRITICAL,
                       "[GUM] GumAttemptUpdate: Unlocking update to node %1!d! failed with %2!d!\n",
                       LockerNode,
                       Status);
            GumpCommFailure(GumInfo,
                            LockerNode,
                            Status,
                            TRUE);
            CL_ASSERT(LockerNode != GumpLockerNode);
        }

        if(Status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(Status);
        }
    }

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumAttemptUpdate: completed update seq %1!u!\ttype %2!u! context %3!u!\n",
               Sequence,
               UpdateType,
               Context);

    if (AsyncState.u.hEvent != NULL) {
       CloseHandle(AsyncState.u.hEvent);
    }

    return(ERROR_SUCCESS);
}





DWORD
WINAPI
GumGetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType
    )

/*++

Routine Description:

    Obtains the current clusterwise global update sequence number

Arguments:

    UpdateType - Supplies the type of update. Each update type may
        have an independent sequence number.

Return Value:

    Current global update sequence number for the specified update type.

--*/

{
    CL_ASSERT(UpdateType < GumUpdateMaximum);

    return(GumpSequence);
}


VOID
GumSetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType,
    DWORD Sequence
    )
/*++

Routine Description:

    Sets the current sequence for the specified global update.

Arguments:

    UpdateType - Supplies the update type whose sequence is to be updated.

    Sequence - Supplies the new sequence number.

Return Value:

    None.

--*/

{
    CL_ASSERT(UpdateType < GumUpdateMaximum);

    GumpSequence = Sequence;

}


VOID
GumCommFailure(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    )
/*++

Routine Description:

    Informs the NM that a fatal communication error has occurred trying
    to talk to another node.

Arguments:

    GumInfo - Supplies the update type where the communication failure occurred.

    NodeId - Supplies the node id of the other node.

    ErrorCode - Supplies the error that was returned from RPC

    Wait - if TRUE, this function blocks until the GUM event handler has
           processed the NodeDown notification for the specified node.

           if FALSE, this function returns immediately after notifying NM

Return Value:

    None.

--*/

{
    PGUM_INFO   GumInfo = &GumTable[UpdateType];

    ClRtlLogPrint(LOG_CRITICAL,
               "[GUM] GumCommFailure %1!d! communicating with node %2!d!\n",
               ErrorCode,
               NodeId);


    GumpCommFailure(GumInfo, NodeId, ErrorCode, Wait);
}


VOID
GumpCommFailure(
    IN PGUM_INFO GumInfo,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    )
/*++

Routine Description:

    Informs the NM that a fatal communication error has occurred trying
    to talk to another node.

Arguments:

    GumInfo - Supplies the update type where the communication failure occurred.

    NodeId - Supplies the node id of the other node.

    ErrorCode - Supplies the error that was returned from RPC

    Wait - if TRUE, this function blocks until the GUM event handler has
           processed the NodeDown notification for the specified node.

           if FALSE, this function returns immediately after notifying NM

Return Value:

    None.

--*/

{
    DWORD     dwCur;

    ClRtlLogPrint(LOG_CRITICAL,
               "[GUM] GumpCommFailure %1!d! communicating with node %2!d!\n",
               ErrorCode,
               NodeId);

    // This is the general GUM RPC failure path, let's dump the extended error info.
    // NOTE: The dumping routine is benign, so calling this from a non RPC failure path would just return.
    NmDumpRpcExtErrorInfo(ErrorCode);


    // This is a hack to check if we are shutting down. See bug 88411
    if (ErrorCode == ERROR_SHUTDOWN_IN_PROGRESS) {
        // if we are shutting down, just kill self
        // set to our node id
        NodeId = NmGetNodeId(NmLocalNode);
    }

        
    //
    // Get current generation number
    //
    if (Wait) {
        dwCur = GumpGetNodeGenNum(GumInfo, NodeId);
    }

    NmAdviseNodeFailure(NodeId, ErrorCode);

    if (Wait) {
            //
            // Wait for this node to be declared down and
            // GumpEventHandler to mark it as inactive.
            //

            GumpWaitNodeDown(NodeId, dwCur);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\api.h ===
//depot/Lab01_N/Base/cluster/service/inc/api.h#1 - branch change 3 (text)
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    api.h

Abstract:

    Public data structures and procedure prototypes for
    the API subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

#ifndef __API_H_
#define __API_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
ApiInitialize(
    VOID
    );

DWORD
ApiOnlineReadOnly(
    VOID
    );

DWORD
ApiOnline(
    VOID
    );

VOID
ApiOffline(
    VOID
    );

VOID
ApiShutdown(
    VOID
    );


DWORD ApiFixupNotifyCb(
    IN DWORD    dwFixupType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR  *lpszKeyName
    );

DWORD
InitializeClusterSD(
    VOID
    );


#ifdef __cplusplus
}
#endif

#endif // ifndef __API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\bitset.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bitset.h

Abstract:

    Macro definitions that implement operations on a BITSET type.

Author:

    Gor Nishanov Aug-1998


Revision History:

--*/

#ifndef __BITSET_H
#define __BITSET_H

/************************************************************************
 * BitsetInit,
 * BitsetUnion,
 * BitsetIntersection,
 * BitsetDifference,
 * BitsetCompare,
 * BitsetSubsetOf,
 * BitsetComplement,
 * BitsetMember,
 * BitsetInsert,
 * BitsetDelete,
 * BitsetCopy,
 * BitsetEmpty
 * =================
 *
 * Description:
 *
 *    Macro definitions that implement operations on a BITSET type.
 *    Be very careful with argument order.
 *
 ************************************************************************/
typedef DWORD BITSET;

#define BITSET_BIT_COUNT       (sizeof(BITSET) * 8)

#ifndef BITSET_SKEW
# define BITSET_SKEW ClusterMinNodeId
#endif

/* Operations */
#define BitsetUnion(a,b)             ((a)|(b))
#define BitsetIntersection(a,b)      ((a)&(b))
#define BitsetDifference(a,b)        ((a)&~(b))
#define BitsetEquals(a,b)            ((a)==(b))
#define BitsetIsSubsetOf(small,big)  BitsetDifference(small,big)
#define BitsetIsEmpty(b)             ((b) == 0)
#define BitsetFromUnit(unit)         ( (1 << (unit - BITSET_SKEW)) )
#define BitsetIsMember(unit,set)     ( BitsetFromUnit(unit) & (set) )
#define BitsetIsNotMember(unit,set)  ( !BitsetIsMember(unit,set) )

/* Statements */
#define BitsetInit(set) \
            do { (set) = 0; } while(0)

#define BitsetRemove(set, unit) \
            do { (set) &= ~BitsetFromUnit(unit); } while(0)

#define BitsetAdd(set, unit) \
            do { (set) |=  BitsetFromUnit(unit); } while(0)

#define BitsetAssign(dest,src) \
            do { (dest) = (src); } while(0)

#define BitsetMergeWith(dest,src) \
            do { (dest) |= (src); } while(0)

#define BitsetSubtract(dest,src) \
            do { (dest) &= ~(src); } while(0)

#define BitsetIntersectWith(dest,src) \
            do { (dest) &= (src); } while(0)


#endif // __BITSET_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\clmsg.h ===
#ifndef  _CLMSG_H_
#define  _CLMSG_H_
/*  ----------------------- ClMsg.h ----------------------- */

/* Cluster messaging */

/* This file contains the specifications of the low-level messaging
   functions required by the Cluster Manager's module. Primary input
   to this is the node#; see the MM module for details. It is assumed
   that this module is configured (by mechanisms not described here)
   to know the various paths to the target node (IP address, netbios
   address, async line, Snet address, ...).

   It is also assumed that *all* CM->CM communication uses this
   module.  The various CM components must be able to do this without
   conflict.

   The model is this:  There are a set of apis for sending messages
   from one CM module to another CM.  All messages are sent either to
   existing cluster members or to a node attempting to join the
   cluster.  A message being sent is directed to one or more nodes,
   and its characteristics are defined (reliable, unreliable, etc).

   This module is entirely responsible for finding out the best way to
   get the message to the target node(s). It chooses the transport; it
   chooses the protocol; it chooses which of the n possible paths to
   use.  No module outside this one cares about such details.

   On the receiving side, messages must be delivered to the
   appropriate CM module.  For this, each message is tagged with a
   type. There is one type per independent module of the CM (to a
   total of a few, say less than 10). Types are statically assigned by
   values in this header file. When a message of type t arrives in a
   destination CM process, a function (msgproc) associated with that
   type t is called. Calls to msgprocs are single-threaded (by the CM
   caller).  After calling a msgproc, this module no longer cares
   about the details of the message.  Messages of one type must be
   delivered promptly, without interference from messages of different
   types; this probably requires there to be a thread per message
   type.  The characteristics of the msgproc (whether it can block,
   take a long time, etc) are not defined; if a msgproc takes too
   long, then the effect will be that other messages destined for it
   will be deferred; if it is important to avoid this, msgprocs can
   pass work off to further threads.

/* ------------ */

/* NOTE: only the important semantics of the messaging api are shown
   below. This module also needs open/close, handles, error
   returns and so on. */

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */

#include <windows.h>
#if defined (TDM_DEBUG)
#include <jrgpos.h>
#endif // TDM_DEBUG
/*------------------------- */

/* the set of messages understood by this module */

typedef enum {
      MM_MSGTYPE = 1, /* for Membership Mgr */
                      /* others to be added */
     } CLMSGTYPE;


#define CLMSGMAXBUFFERLENGTH 1024 /* random number; no reason */
/* the biggest buffer which can be sent/received by the CM */

typedef DWORD (*CLMSGPROC) (LPCSTR buffer, DWORD length);

void ClProcRegister (CLMSGTYPE msgtype, CLMSGPROC msgproc);

/* registers that function <msgproc> should be called whenever an
   incoming message of type <msgtype> is seen. The type field is always
   the first DWORD of the incoming buffer. The length passed to
   <ptype> is the length received. The worst-case length of all users
   of this api is known, so there are never cases where the
   receive-buffer isn't big enough.

   This must be called by all CM modules in all nodes on CM startup.

   The msgproc should be called immediately an incoming msg arrives;
   such msgs should not be delayed by an long blocking events in the
   thread which delivers these messages. (This may imply that clMsg
   have a special thread dedicated to handling incoming msgs).

   Every msgproc will return quickly to its caller.

  Errors: none possible.

*/


DWORD ClMsgSendUnack(DWORD   targetnode,
               LPCSTR  buffer,
               DWORD   length);

/*
   Sends an unacknowledged packet to a destination up node. This is
   used mostly for heartbeats.

   The target node may not be Up at the time.

   The paths to that node are unknown to MM.  (For safety, all paths
   should be used periodically). The packet should arrive with low
   latency (bypassing other traffic, if required; going at high
   priority if possible), and with a high probability of delivery.
   Although the message can be lost, the contents must be correct.
   This function should never fail unless zero connectivity exists.
   This function should return asap; it is preferred that the
   buffer simply be queued to some driver for later delivery.

   [It must be the case that, when this routine is used for
   heartbeats, it is possible to deliver a packet to all other
   nodes within the <polltime> established in the MM. This places
   constraints on this module to work fast, and/or on the minimum
   polltime value... tbd]

   It is undefined whether this function should always send all
   packets on all available paths, cycle through all available paths,
   or send on some preferred path till a failure occurs, or whether
   the choice of the above should be user-configurable. [Note that the
   decision eventually affects the user settings of polltime].

   [<length> is typically short and can be restricted to be so (eg,
   256 bytes) is necessary].

Errors:

xxx No path to designated node.

xxx Success; message was queued for delivery.


*/


DWORD ClSend     (DWORD      targetnode,
            LPCSTR     buffer,
            DWORD      length,
            DWORD      timeout);

/* This sends the given message to the designated node, eg to download
   configuration data to it.  The message should be reliable.  The
   function should block until the msg is delivered to the target CM.
   The target node may not be Up at the time.

   The function must fail if the target node becomes unreachable
   or is declared down during the operation.

   The function should fail if the message cannot be delivered to the
   target CM within <timeout> ms.


Errors:

xxx   No path to node; node went down.

xxx   Timeout
*/

/* ------------------------------------------------------ */

DWORD ClMsgInit (DWORD mynode);

/* Input -      my node number
   Errors :
                WSAsocket errors.
*/


#if defined (TDM_DEBUG)
/* The following templates are for simulation purposes and temporary */

DWORD ClMsgGet  (LPCSTR         buffer,
            DWORD                maxlen,
            LPDWORD              actuallen);
/* Input -  pointer to buffer data.
                        buffer length in bytes.
                        pointer to actual buffer length in bytes.
   Modifies - buffer data
                  actual byte length
   Errors :

                WSAsocket errors.
*/

DWORD ClWriteRead(
        IN              DWORD   targetnode,             // node to send to
        IN OUT  LPCSTR  buffer,                 // buffer to send and to receive in
        IN              DWORD   writelen,               // number of bytes to write
        IN              DWORD   readlen,                // number of bytes to read
        OUT             LPDWORD actuallen,              // number of bytes actually read
        IN              DWORD   timeout                 // timeout value in milliseconds
        );

DWORD ClReadUpdate(
        IN              LPCSTR  buffer,                 // buffer to receive data into
        IN              DWORD   readlen,                // number of bytes to read
        OUT             LPDWORD actuallen               // number of bytes actually read
        );

DWORD ClReply(
        IN              LPCSTR  buffer,                 // buffer to send
        IN              DWORD   writelen                // number of bytes to send
        );

//
// This structure is used for request reply messages so that we know
// who sent the message.
//
#define MAX_REQUEST_REPLY_SIZE 256
typedef struct _request_reply_message
{
        DWORD           sending_node;
        DWORD           sending_IPaddr;         // only used for CLI (sending_node is -1)
        CHAR            message[MAX_REQUEST_REPLY_SIZE];
        DWORD           messagelen;
} REQUEST_REPLY_MESSAGE, *PREQUEST_REPLY_MESSAGE;

typedef struct _reply_message_header
{
        DWORD           status;
        cluster_t       UpMask;
} REPLY_MESSAGE_HEADER, *PREPLY_MESSAGE_HEADER;

typedef struct _reply_message
{
        REPLY_MESSAGE_HEADER reply_hdr;
        DWORD           reply_data_len;
        CHAR            reply_data[];
} REPLY_MESSAGE, *PREPLY_MESSAGE;

#else  //TDM_DEBUG


DWORD
ClMsgCreateRpcBinding(
    IN  PNM_NODE              Node,
    OUT RPC_BINDING_HANDLE *  BindingHandle,
    IN  DWORD                 RpcBindingOptions
    );

DWORD
ClMsgVerifyRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    );

VOID
ClMsgDeleteRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    );

DWORD
ClMsgCreateDefaultRpcBinding(
    IN  PNM_NODE  Node,
    OUT PDWORD    Generation
    );

VOID
ClMsgDeleteDefaultRpcBinding(
    IN PNM_NODE   Node,
    IN DWORD      Generation
    );

DWORD
ClMsgCreateActiveNodeSecurityContext(
    IN DWORD     JoinSequence,
    IN PNM_NODE  Node
    );

DWORD
ClMsgInit(
    IN DWORD    MyNode
    );

VOID
ClMsgCleanup(
    VOID
    );

VOID
ClMsgBanishNode(
    IN CL_NODE_ID NodeId
    );

extern RPC_BINDING_HANDLE * Session;

#endif //TDM_DEBUG

#ifdef __cplusplus
}
#endif /* __cplusplus */


/* ------------------------ end ------------------------- */
#endif /* _CLMSG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\config.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Public data structures and procedure prototypes for
    the Config subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\cvsscluster.h ===
#pragma once

//++
//
// Copyright (c) 2001 Microsoft Corporation
//
// FACILITY:
//
//      Cluster Service
//
// MODULE DESCRIPTION:
//
//      Header for Vss support within cluster service.
//
// ENVIRONMENT:
//
//      User mode NT Service.
//
// AUTHOR:
//
//      Conor Morrison
//
// CREATION DATE:
//
//      18-Apr-2001
//
// Revision History:
//
// X-1	CM		Conor Morrison        				18-Apr-2001
//      Initial version.
//--

#include "vss.h"
#include "vswriter.h"

// Derive a class from CVssWriter so that we can override some of the default
// methods with our own funky cluster variants
//
// For more info search MSDN for CVssWriter.
//
class CVssWriterCluster : public CVssWriter
{
private:
	// callback when request for metadata comes in

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	// callback for prepare backup event

	virtual bool STDMETHODCALLTYPE OnPrepareBackup(
	    IN IVssWriterComponents *pComponent
	    );

	// callback for prepare snapsot event
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	// callback for freeze event
	virtual bool STDMETHODCALLTYPE OnFreeze();

	// callback for thaw event
	virtual bool STDMETHODCALLTYPE OnThaw();

	// callback if current sequence is aborted
	virtual bool STDMETHODCALLTYPE OnAbort();
};
typedef CVssWriterCluster* PCVssWriterCluster;

extern class CVssWriterCluster* g_pCVssWriterCluster;
extern const VSS_ID g_VssIdCluster;
extern bool g_bCVssWriterClusterSubscribed;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\gum\vote.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    vote.c

Abstract:

    Routines for sending global updates to the cluster

Author:

    Sunita Shrivastava(sunitas) 17-Mar-1998

Revision History:

--*/
#include "gump.h"

/****
@doc    EXTERNAL INTERFACES CLUSSVC GUM
****/

/****
@func       DWORD | GumSendUpdateOnVote| Allows a the caller to collect votes
            from all active nodes in the cluster before sending an update.

@parm       IN GUM_UPDATE_TYPE | UpdateType |  The update type that will
            be sent if the decision call back function returns true.

@parn       IN DWORD | dwContext | This specifies the context related to the
            Updatetype that will be sent.

@parm       IN DWORD | dwInputBufLength | The length of the input buffer
            passed in via pInputBuffer.

@parm       IN PVOID | pInputBuffer | A pointer to the input buffer that is
            passed to all the active nodes based on which they can vote.

@parm       IN DWORD | dwVoteLength | The length of the vote.  Depending
            on this, an appropriately large buffer is allocated to collect
            all the votes.

@parm       IN GUM_VOTE_DECISION_CB | pfnGumDecisionCb |  The decision call
            back function that is invoked once all the votes have been collected.


@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm
@xref       <f GumpCollectVotes>
****/
DWORD
GumSendUpdateOnVote(
    IN GUM_UPDATE_TYPE  UpdateType,
    IN DWORD            dwContext,   //vote type
    IN DWORD            dwInputBufLength,  //input data to make judgement upon
    IN PVOID            pInputBuffer,  //size of the input data
    IN DWORD            dwVoteLength,
    IN PGUM_VOTE_DECISION_CB pfnGumDecisionCb,
    IN PVOID            pContext
    )
{
    DWORD                       dwVoteBufSize;
    BOOL                        bDidAllActiveNodesVote;
    DWORD                       dwNumVotes;
    DWORD                       dwStatus;
    GUM_VOTE_DECISION_CONTEXT   GumDecisionContext;
    PBYTE                       pVoteBuffer=NULL;
    DWORD                       dwSequence;
    DWORD                       dwDecisionStatus;
    DWORD                       dwUpdateBufLength;
    PBYTE                       pUpdateBuf=NULL;

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdateOnVote: Type=%1!u! Context=%2!u!\n",
               UpdateType, dwContext);


    if (dwVoteLength == 0)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //SS: We dont have to deal with a join happening between
    // the time we allocate the buffer to the time we collect votes
    // this is because the buffer we allocate is big enough to
    // collect all votes from the maximum number of allowed nodes
    // of a cluster.

    dwVoteBufSize = (DWORD)(NmMaxNodes * (sizeof(GUM_VOTE_ENTRY) + dwVoteLength));
    //allocate a buffer big enough to collect every bodies
    pVoteBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, dwVoteBufSize);
    if (!pVoteBuffer)
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    ZeroMemory(pVoteBuffer, dwVoteBufSize);


    //setup the decision context structure
    GumDecisionContext.UpdateType = UpdateType;
    GumDecisionContext.dwContext = dwContext;
    GumDecisionContext.dwInputBufLength = dwInputBufLength;
    GumDecisionContext.pInputBuf = pInputBuffer;
    GumDecisionContext.dwVoteLength = dwVoteLength;
    GumDecisionContext.pContext = pContext;

Retry:
    //gum get sequence
    dwSequence = GumpSequence;

    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdateOnVote: Collect Vote at Sequence=%1!u!\n",
               dwSequence);

    //gets the information from all nodes
    //this is done without acquiring the gum lock
    //could have been done in parallel if we had the appropriate
    //networking constructs
    dwStatus = GumpCollectVotes(&GumDecisionContext, dwVoteBufSize,
        pVoteBuffer, &dwNumVotes, &bDidAllActiveNodesVote);

    if (dwStatus != ERROR_SUCCESS)
    {
        goto FnExit;
    }



    //Call the callback
    dwDecisionStatus = (*pfnGumDecisionCb)(&GumDecisionContext, dwVoteBufSize,
            pVoteBuffer,  dwNumVotes, bDidAllActiveNodesVote,
            &dwUpdateBufLength, &pUpdateBuf);


    ClRtlLogPrint(LOG_NOISE,
           "[GUM] GumSendUpdateOnVote: Decision Routine returns=%1!u!\n",
           dwDecisionStatus);

    if (dwDecisionStatus == ERROR_SUCCESS)
    {


        //send the update to the locker node
        dwStatus = GumAttemptUpdate(dwSequence, UpdateType, dwContext,
            dwUpdateBufLength, pUpdateBuf);

        if (dwStatus == ERROR_CLUSTER_DATABASE_SEQMISMATCH || 
            dwStatus == ERROR_REVISION_MISMATCH )  // for mixed mode
        {
            //free the update buffer
            if (pUpdateBuf)
            {
                LocalFree(pUpdateBuf);
                pUpdateBuf = NULL;
            }
            goto Retry;

        }

    }


FnExit:
    ClRtlLogPrint(LOG_NOISE,
               "[GUM] GumSendUpdateOnVote: Returning status=%1!u!\n",
               dwStatus);

    //free the buffer allocated for vote collection
    if (pVoteBuffer)
    {
        LocalFree(pVoteBuffer);
    }
    //free the buffer for update allocated by the decision callback function
    if (pUpdateBuf)
    {
        LocalFree(pUpdateBuf);
    }

    return(dwStatus);
}

/****
@func       DWORD | GumCollectVotes| Calls all the nodes in the node
            to collect their votes.

@parm       IN PGUM_VOTE_DECISION_CONTEXT | pVoteContext|  A pointer to
            the vote context structure.  This describes the type/context/input
            data for the vote.

@parn       IN DWORD | dwVoteBufSize| The size of the buffer pointed to
            by pVoteBuf.

@parm       OUT PVOID | pVoteBuffer | A pointer to the buffer allocated to
            collect the votes/data from all the nodes of the cluster.

@parm       OUT LPDWORD| pdwNumVotes| The number of nodes whose votes
            were collected.

@parm       IN BOOL| *pbDidAllActiveNodesVote | A pointer to a BOOL.  This
            is set to true if all active nodes at the time the vote
            was collected vote.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm       This is called by GumSendUpdateOnVote() to collect votes from
            all the nodes of the cluster.

@xref       <f GumSendUpdateOnVote> <f GumpDispatchVote>
****/
DWORD GumpCollectVotes(
    IN  PGUM_VOTE_DECISION_CONTEXT  pVoteContext,
    IN  DWORD                       dwVoteBufSize,
    OUT PBYTE                       pVoteBuffer,
    OUT LPDWORD                     pdwNumVotes,
    OUT BOOL                        *pbDidAllActiveNodesVote
)
{
    DWORD               dwStatus = ERROR_SUCCESS;
    DWORD               dwVoteStatus = ERROR_SUCCESS;
    DWORD               dwCount = 0;
    DWORD               i;
    PGUM_VOTE_ENTRY     pGumVoteEntry;
    PGUM_INFO           GumInfo;
    DWORD               MyNodeId;



    *pbDidAllActiveNodesVote = TRUE;
    GumInfo = &GumTable[pVoteContext->UpdateType];
    MyNodeId = NmGetNodeId(NmLocalNode);

    for (i=ClusterMinNodeId; i <= NmMaxNodeId; i++)
    {
        if (GumInfo->ActiveNode[i])
        {

            pGumVoteEntry = (PGUM_VOTE_ENTRY)(pVoteBuffer +
                (dwCount * (sizeof(GUM_VOTE_ENTRY) + pVoteContext->dwVoteLength)));

            CL_ASSERT((PBYTE)pGumVoteEntry <= (pVoteBuffer + dwVoteBufSize - sizeof(GUM_VOTE_ENTRY)));
            //
            // Dispatch the vote to the specified node.
            //
            ClRtlLogPrint(LOG_NOISE,
                       "[GUM] GumVoteUpdate: Dispatching vote type %1!u!\tcontext %2!u! to node %3!d!\n",
                       pVoteContext->UpdateType,
                       pVoteContext->dwContext,
                       i);
            if (i == MyNodeId)
            {
                dwVoteStatus = GumpDispatchVote(pVoteContext->UpdateType,
                                   pVoteContext->dwContext,
                                   pVoteContext->dwInputBufLength,
                                   pVoteContext->pInputBuf,
                                   pVoteContext->dwVoteLength,
                                   (PBYTE)pGumVoteEntry + sizeof(GUM_VOTE_ENTRY));
            }
            else
            {
	            GumpStartRpc(i);
                dwVoteStatus = GumCollectVoteFromNode(GumpRpcBindings[i],
                                   pVoteContext->UpdateType,
                                   pVoteContext->dwContext,
                                   pVoteContext->dwInputBufLength,
                                   pVoteContext->pInputBuf,
                                   pVoteContext->dwVoteLength,
                                   (PBYTE)pGumVoteEntry + sizeof(GUM_VOTE_ENTRY));
	            GumpEndRpc(i);
            }
            if (dwVoteStatus == ERROR_SUCCESS)
            {
                pGumVoteEntry->dwFlags = GUM_VOTE_VALID;
                pGumVoteEntry->dwNodeId = i;
                pGumVoteEntry->dwNumBytes = pVoteContext->dwVoteLength;

                dwCount++;
            }
            else
                *pbDidAllActiveNodesVote = FALSE;
        }
    }
    *pdwNumVotes = dwCount;
    return(dwStatus);
}



/****
@func       DWORD | GumpDispatchVote| The routine calls the vote routine
            registered for a given update type to collect vote for the
            supplied context and the input data.

@parm       IN GUM_UPDATE_TYPE | Type |  The update type for which this
            vote is requested.

@parn       IN DWORD | dwContext | This specifies the context related to the
            Updatetype for which a vote is being seeked.

@parm       IN DWORD | dwInputBufLength | The length of the input buffer
            passed in via pInputBuffer.

@parm       IN PVOID | pInputBuffer | A pointer to the input buffer via
            which the input data for the vote is supplied.

@parm       IN DWORD | dwVoteLength | The length of the vote.  This is
            also the size of the buffer to which pBuf points to.

@parm       OUT PUCHAR | pVoteBuf|  A pointer to a buffer in which
            this node may cast its vote.  The length of the vote must
            not exceed dwVoteLength.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@comm
@xref       <f GumpCollectVote> <f s_GumCollectVoteFromNode>
****/
DWORD
WINAPI
GumpDispatchVote(
    IN  GUM_UPDATE_TYPE  Type,
    IN  DWORD            dwContext,
    IN  DWORD            dwInputBufLength,
    IN  PUCHAR           pInputBuf,
    IN  DWORD            dwVoteLength,
    OUT PUCHAR           pVoteBuf
    )
{
    PGUM_INFO           GumInfo;
    PGUM_RECEIVER       Receiver;
    DWORD               Status = ERROR_REQUEST_ABORTED;

    GumInfo = &GumTable[Type];

    if (GumInfo->Joined)
    {
        Receiver = GumInfo->Receivers;
        if (Receiver != NULL)
        {

            try
            {
                if (Receiver->VoteRoutine)
                {
                    Status =(*(Receiver->VoteRoutine))(dwContext,
                                                       dwInputBufLength,
                                                       pInputBuf,
                                                       dwVoteLength,
                                                       pVoteBuf);
                }
            } except (CL_UNEXPECTED_ERROR(GetExceptionCode()),
                      EXCEPTION_EXECUTE_HANDLER
                     )
            {
                Status = GetExceptionCode();
            }
            if (Status != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[GUM] Vote routine %1!d! failed with status %2!d!\n",
                           Receiver->VoteRoutine,
                           Status);
            }
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\cp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cp.h

Abstract:

    Public data structures and procedure prototypes for the
    Checkpoint Manager (CP) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 1/14/1997

Revision History:

--*/

//
// Define public structures and types
//

//
// Define public interfaces
//
DWORD
CpInitialize(
    VOID
    );

DWORD
CpShutdown(
    VOID
    );

DWORD
CpCopyCheckpointFiles(
    IN LPCWSTR lpszPathName,
    IN BOOL IsFileChangeAttribute
    );

DWORD
CpCompleteQuorumChange(
    IN LPCWSTR lpszOldQuorumPath
    );

DWORD
CpSaveDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

DWORD
CpGetDataFile(
    IN PFM_RESOURCE Resource,
    IN DWORD dwCheckpointId,
    IN LPCWSTR lpszFileName,
    IN BOOLEAN fCryptoCheckpoint
    );

//
// Interface for adding and removing registry checkpoints
//
DWORD
CpAddRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    );

DWORD
CpDeleteRegistryCheckpoint(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR KeyName
    );

DWORD
CpGetRegistryCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CpRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    );

DWORD
CpckRemoveResourceCheckpoints(
    IN PFM_RESOURCE Resource
    );
    
DWORD
CpDeleteCheckpointFile(
    IN PFM_RESOURCE Resource,
    IN DWORD        dwCheckpointId,
    IN OPTIONAL LPCWSTR lpszQuorumPath
    );

DWORD CpRestoreCheckpointFiles(
    IN LPWSTR  lpszSourcePathName,
    IN LPWSTR  lpszSubDirName,
    IN LPCWSTR lpszQuoLogPathName 
    );

//
// Interface for adding and removing crypto checkpoints
//
DWORD
CpckAddCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CpckDeleteCryptoCheckpoint(
    IN PFM_RESOURCE Resource,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CpckGetCryptoCheckpoints(
    IN PFM_RESOURCE Resource,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\evtlog.h ===
#ifndef _EVTLOG_H
#define _EVTLOG_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    evtlog.h

Abstract:

    Header file for the eventlogging component for
    the NT Cluster Service

Author:

    Sunita Shrivastava (sunitas) 5-Dec-1996.

Revision History:

--*/


DWORD EvInitialize(void);
	
DWORD EvOnline(void);
	
DWORD EvShutdown(void);

DWORD EvCreateRpcBindings(PNM_NODE  Node);


#endif //_EVTLOG_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\ep.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ep.h

Abstract:

    Header file for definitions and structure for the Event Processor
    component of the Cluster Service portion of the Windows NT Cluster project.

Author:

    Rod Gamache (rodga) 28-Feb-1996

Revision History:

--*/

#ifndef _EVENT_PROCESSOR_
#define _EVENT_PROCESSOR_


//***********************************
//
// Global Cluster Service definitions
//
//***********************************


typedef DWORDLONG CLUSTER_EVENT;
typedef CLUSTER_EVENT *PCLUSTER_EVENT;

//
// Event flags. These indicate what should be done with the Context once
// the event has been dispatched.
//
//
#define EP_DEREF_CONTEXT    0x00000001       // OmDereferenceObject(Context)
#define EP_FREE_CONTEXT     0x00000002       // LocalFree(Context)
#define EP_CONTEXT_VALID    0x00000004

typedef
DWORD
(WINAPI *PEVENT_ROUTINE) (
    IN  CLUSTER_EVENT Event,
    IN  PVOID Context
    );

DWORD
WINAPI
EpInitialize(
    VOID
    );

DWORD EpInitPhase1();
DWORD EpIfnitPhase1();

VOID
EpShutdown(
    VOID
    );

DWORD
WINAPI
EpPostEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    );

DWORD
WINAPI
EpPostSyncEvent(
    IN CLUSTER_EVENT Event,
    IN DWORD Flags,
    IN PVOID Context
    );

DWORD
WINAPI
EpRegisterSyncEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    );

DWORD
WINAPI
EpRegisterEventHandler(
    IN CLUSTER_EVENT EventMask,
    IN PEVENT_ROUTINE EventRoutine
    );

DWORD
WINAPI
EpClusterWidePostEvent(
    IN CLUSTER_EVENT    Event,
    IN DWORD            dwFlags,
    IN PVOID            Context,
    IN DWORD            ContextSize
    );

#define ClusterEvent(Event, pObject) EpPostEvent(Event, 0, pObject)

#define ClusterEventEx(Event, Flags, Context) \
            EpPostEvent(Event, Flags, Context)

#define ClusterSyncEventEx(Event, Flags, Context) \
            EpPostSyncEvent(Event, Flags, Context)

#define ClusterWideEvent(Event, pObject) \
            EpClusterWidePostEvent(Event, 0, pObject, 0)

//if you pass in a cluster wide object pass 0 as the context
//if you pass a pointer to some other data pass EP_CONTEXT_VALID 
//You will be responsible for cleaning up the memory for that context
//i.e EP_FREE_CONTEXT is automatically added to the flag bits since this
//request is GUM'ed around to different nodes and each node makes a copy
//of this context and calls the local EpPostEvent.  EpEventHandler then 
//frees that memory
#define ClusterWideEventEx(Event, Flags, Context, ContextSize) \
            EpClusterWidePostEvent(Event, Flags, Context, ContextSize)
//
// Define Cluster Service states
//

typedef enum _CLUSTER_SERVICE_STATE {
    ClusterOffline,
    ClusterOnline,
    ClusterPaused
} CLUSTER_SERVICE_STATE;

//
// Definitions for Cluster Events.  These events are used both as masks and as
// event identifiers within the Cluster Service. Cluster Service components
// register to receive multiple events, but can deliver notification of only
// one event at a time. This mask should be a CLUSTER_EVENT type. We get 64
// unique event masks.
//

// Cluster Service Events

#define CLUSTER_EVENT_ONLINE                        0x0000000000000001
#define CLUSTER_EVENT_SHUTDOWN                      0x0000000000000002

// Node Events

#define CLUSTER_EVENT_NODE_UP                       0x0000000000000004
#define CLUSTER_EVENT_NODE_DOWN                     0x0000000000000008
        // state change
#define CLUSTER_EVENT_NODE_CHANGE                   0x0000000000000010
#define CLUSTER_EVENT_NODE_ADDED                    0x0000000000000020
#define CLUSTER_EVENT_NODE_DELETED                  0x0000000000000040
#define CLUSTER_EVENT_NODE_PROPERTY_CHANGE          0x0000000000000080
#define CLUSTER_EVENT_NODE_JOIN                     0x0000000000000100

// Group Events

#define CLUSTER_EVENT_GROUP_ONLINE                  0x0000000000000200
#define CLUSTER_EVENT_GROUP_OFFLINE                 0x0000000000000400
#define CLUSTER_EVENT_GROUP_FAILED                  0x0000000000000800
        // state change
#define CLUSTER_EVENT_GROUP_CHANGE                  0x0000000000001000
#define CLUSTER_EVENT_GROUP_ADDED                   0x0000000000002000
#define CLUSTER_EVENT_GROUP_DELETED                 0x0000000000004000
#define CLUSTER_EVENT_GROUP_PROPERTY_CHANGE         0x0000000000008000

// Resource Events

#define CLUSTER_EVENT_RESOURCE_ONLINE               0x0000000000010000
#define CLUSTER_EVENT_RESOURCE_OFFLINE              0x0000000000020000
#define CLUSTER_EVENT_RESOURCE_FAILED               0x0000000000040000
        // state change
#define CLUSTER_EVENT_RESOURCE_CHANGE               0x0000000000080000
#define CLUSTER_EVENT_RESOURCE_ADDED                0x0000000000100000
#define CLUSTER_EVENT_RESOURCE_DELETED              0x0000000000200000
#define CLUSTER_EVENT_RESOURCE_PROPERTY_CHANGE      0x0000000000400000

// Resource Type Events

#define CLUSTER_EVENT_RESTYPE_ADDED                 0x0000000000800000
#define CLUSTER_EVENT_RESTYPE_DELETED               0x0000000001000000

#define CLUSTER_EVENT_PROPERTY_CHANGE               0x0000000002000000

#define CLUSTER_EVENT_NETWORK_UNAVAILABLE           0x0000000004000000
#define CLUSTER_EVENT_NETWORK_DOWN                  0x0000000008000000
#define CLUSTER_EVENT_NETWORK_PARTITIONED           0x0000000010000000
#define CLUSTER_EVENT_NETWORK_UP                    0x0000000020000000
#define CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE       0x0000000040000000
#define CLUSTER_EVENT_NETWORK_ADDED                 0x0000000080000000
#define CLUSTER_EVENT_NETWORK_DELETED               0x0000000100000000

#define CLUSTER_EVENT_NETINTERFACE_UNAVAILABLE      0x0000000200000000
#define CLUSTER_EVENT_NETINTERFACE_FAILED           0x0000000400000000
#define CLUSTER_EVENT_NETINTERFACE_UNREACHABLE      0x0000000800000000
#define CLUSTER_EVENT_NETINTERFACE_UP               0x0000001000000000
#define CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE  0x0000002000000000
#define CLUSTER_EVENT_NETINTERFACE_ADDED            0x0000004000000000
#define CLUSTER_EVENT_NETINTERFACE_DELETED          0x0000008000000000

#define CLUSTER_EVENT_NODE_DOWN_EX                  0x0000010000000000
#define CLUSTER_EVENT_API_NODE_UP                   0x0000020000000000
#define CLUSTER_EVENT_API_NODE_SHUTTINGDOWN         0x0000040000000000

#define CLUSTER_EVENT_RESTYPE_PROPERTY_CHANGE       0x0000080000000000

        // all events
#define CLUSTER_EVENT_ALL                           0x00000FFFFFFFFFFF



//**********************************
//
// Local Event Processor definitions
//
//**********************************


//
// Define Event Processor states
//

typedef enum _EVENT_PROCESSOR_STATE {
    EventProcessorStateIniting,
    EventProcessorStateOnline,
    EventProcessorStateExiting
} EVENT_PROCESS_STATE;

//
// Event Processor Dispatch Table for dispatching events
//

typedef struct _EVENT_DISPATCH_TABLE {
    CLUSTER_EVENT   EventMask;
    PEVENT_ROUTINE  EventRoutine;
} EVENT_DISPATCH_TABLE, *PEVENT_DISPATCH_TABLE;


#endif // _EVENT_PROCESSOR_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\dm.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dm.h

Abstract:

    Public data structures and procedure prototypes for the
    Config Database Manager (DM) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 24-Apr-1996

Revision History:

--*/

#ifndef _DM_H
#define _DM_H

#ifdef __cplusplus
extern "C" {
#endif

//
// Define public structures and types
//
typedef struct _HDMKEY *HDMKEY;

//
// Definitions for GUM update types
//
// The first entries in this list are auto-marshalled through Gum...Ex.
// Any updates that are not auto-marshalled must come after DmUpdateMaxAuto
//
typedef enum {
    DmUpdateCreateKey = 0,
    DmUpdateSetSecurity,
    DmUpdateMaxAuto = 0x1000,
    DmUpdateDeleteKey,
    DmUpdateSetValue,
    DmUpdateDeleteValue,
    DmUpdateJoin
} DM_UPDATE_TYPE;


extern HDMKEY DmClusterParametersKey;
extern HDMKEY DmResourcesKey;
extern HDMKEY DmResourceTypesKey;
extern HDMKEY DmQuorumKey;
extern HDMKEY DmGroupsKey;
extern HDMKEY DmNodesKey;
extern HDMKEY DmNetworksKey;
extern HDMKEY DmNetInterfacesKey;

extern WCHAR DmpResourceListKeyName[];
extern WCHAR DmpResourceTypeListKeyName[];
extern WCHAR DmpGroupListKeyName[];
extern WCHAR DmpNodeListKeyName[];
extern WCHAR DmpTransportListKeyName[];
extern WCHAR DmpInterconnectListKeyName[];
extern const WCHAR DmpClusterParametersKeyName[];

extern DWORD gbIsQuoResEnoughSpace;

//define public cluster key value names
extern const WCHAR cszPath[];
extern const WCHAR cszMaxQuorumLogSize[];
extern const WCHAR cszParameters[];

//other const strings
extern const WCHAR cszClusFilePath[];
extern const WCHAR cszQuoFileName[];
extern const WCHAR cszQuoTombStoneFile[];
extern const WCHAR cszTmpQuoTombStoneFile[];

//local transaction handle
typedef HANDLE  HLOCALXSACTION;

//
// Define Macros
//


#define DmQuerySz(Key, ValueName, StringBuffer, StringBufferSize, StringSize) \
    DmQueryString( Key,                 \
                   ValueName,           \
                   REG_SZ,              \
                   StringBuffer,        \
                   StringBufferSize,    \
                   StringSize )

#define DmQueryMultiSz(Key,ValueName,StringBuffer,StringBufferSize,StringSize) \
    DmQueryString( Key,                 \
                   ValueName,           \
                   REG_MULTI_SZ,        \
                   StringBuffer,        \
                   StringBufferSize,    \
                   StringSize )

//
// Define public interfaces
//

DWORD
DmInitialize(
    VOID
    );

DWORD
DmShutdown(
    VOID
    );

VOID DmShutdownUpdates(
    VOID
    );

DWORD
DmFormNewCluster(
    VOID
    );

DWORD
DmJoin(
    IN RPC_BINDING_HANDLE RpcBinding,
    OUT DWORD *StartSequence
    );

DWORD
DmUpdateFormNewCluster(
    VOID
    );

DWORD
DmCompleteFormNewCluster(
    VOID
    );

DWORD
DmUpdateJoinCluster(
    VOID
    );

DWORD
DmWaitQuorumResOnline(
    VOID
    );

DWORD DmRollChanges(VOID);

DWORD DmPauseDiskManTimer(VOID);

DWORD DmRestartDiskManTimer(VOID);

DWORD DmPrepareQuorumResChange(
    IN PVOID        pResource,
    IN LPCWSTR      lpszQuorumLogPath,
    IN DWORD        dwMaxQuoLogSize
    );

DWORD DmCompleteQuorumResChange(
    IN LPCWSTR      lpszOldQuoResId,
    IN LPCWSTR      lpszOldQuoLogPath
    );

void DmSwitchToNewQuorumLog(
    IN LPCWSTR lpszQuorumLogPath,
    IN DWORD dwNewQuorumResourceCharacteristics 
    );

DWORD DmReinstallTombStone(
    IN LPCWSTR  lpszQuoLogPath
    );

DWORD DmGetQuorumLogPath(
    IN LPWSTR lpszQuorumLogPath,
    IN DWORD dwSize
    );

DWORD DmGetQuorumLogMaxSize(
    OUT LPDWORD pdwLogSize
    );

DWORD DmBackupClusterDatabase(
    IN LPCWSTR  lpszPathName
    );


HDMKEY
DmGetRootKey(
    IN DWORD samDesired
    );

HDMKEY
DmCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    );

HDMKEY
DmOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired
    );

DWORD
DmCloseKey(
    IN HDMKEY hKey
    );

DWORD
DmEnumKey(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    OUT OPTIONAL PFILETIME lpLastWriteTime
    );

DWORD
DmSetValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    );

DWORD
DmDeleteValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    );

DWORD
DmQueryValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

DWORD
DmDeleteKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

DWORD
DmGetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN LPDWORD lpcbSecurityDescriptor
    );

DWORD
DmSetKeySecurity(
    IN HDMKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


DWORD
DmDeleteTree(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

DWORD
DmEnumValue(
    IN HDMKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

DWORD
DmQueryDword(
    IN  HDMKEY hKey,
    IN  LPCWSTR lpValueName,
    OUT LPDWORD lpValue,
    IN  LPDWORD lpDefaultValue OPTIONAL
    );

DWORD
DmQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    );

LPWSTR
DmEnumMultiSz(
    IN LPWSTR  MszString,
    IN DWORD   MszStringLength,
    IN DWORD   StringIndex
    );

typedef
VOID
(WINAPI *PENUM_KEY_CALLBACK) (
    IN HDMKEY Key,
    IN PWSTR KeyName,
    IN PVOID Context
    );

VOID
DmEnumKeys(
    IN HDMKEY RootKey,
    IN PENUM_KEY_CALLBACK Callback,
    IN PVOID Context
    );

typedef
BOOL
(WINAPI *PENUM_VALUE_CALLBACK) (
    IN LPWSTR ValueName,
    IN LPVOID ValueData,
    IN DWORD ValueType,
    IN DWORD ValueSize,
    IN PVOID Context
    );

VOID
DmEnumValues(
    IN HDMKEY RootKey,
    IN PENUM_VALUE_CALLBACK Callback,
    IN PVOID Context
    );

DWORD
DmQueryInfoKey(
    IN  HDMKEY  hKey,
    OUT LPDWORD SubKeys,
    OUT LPDWORD MaxSubKeyLen,
    OUT LPDWORD Values,
    OUT LPDWORD MaxValueNameLen,
    OUT LPDWORD MaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME FileTime
    );

//
// Local registry modification routines for use in a GUM update handler.
//
HDMKEY
DmLocalCreateKey(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT LPDWORD lpDisposition
    );

DWORD
DmLocalSetValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    );

DWORD
DmLocalDeleteValue(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName
    );

DWORD
DmLocalDeleteKey(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

DWORD
DmLocalRemoveFromMultiSz(
    IN HLOCALXSACTION   hLocalXsaction,
    IN HDMKEY           hKey,
    IN LPCWSTR          lpValueName,
    IN LPCWSTR          lpString
    );

DWORD
DmLocalAppendToMultiSz(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    );

DWORD
DmLocalDeleteTree(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey
    );

HLOCALXSACTION
DmBeginLocalUpdate();

DWORD
DmCommitLocalUpdate(
    IN HLOCALXSACTION hLocalXsaction
    );

DWORD
DmAbortLocalUpdate(
    IN HLOCALXSACTION hLocalXsaction);



//
// Notification support.
//
// Supported completion filters are
//
//  CLUSTER_CHANGE_REGISTRY_NAME  - applies to changes in the namespace. (key creation and deletion).
//  CLUSTER_CHANGE_REGISTRY_ATTRIBUTES - applies to key attributes. The only key attribute is the
//                                       security descriptor.
//  CLUSTER_CHANGE_REGISTRY_VALUE - applies to creation, modification, or deletion of values.
//

//
// Notification callback routine
//
typedef VOID (*DM_NOTIFY_CALLBACK)(
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2,
    IN DWORD CompletionFilter,
    IN LPCWSTR RelativeName
    );

DWORD
DmNotifyChangeKey(
    IN HDMKEY hKey,
    IN ULONG CompletionFilter,
    IN BOOL WatchTree,
    IN OPTIONAL PLIST_ENTRY ListHead,
    IN DM_NOTIFY_CALLBACK NotifyCallback,
    IN DWORD_PTR Context1,
    IN DWORD_PTR Context2
    );

VOID
DmRundownList(
    IN PLIST_ENTRY ListHead
    );

//
// A few helper routines.
//
DWORD
DmAppendToMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    );

DWORD
DmRemoveFromMultiSz(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN LPCWSTR lpString
    );

//
// Some routines for saving and restoring registry trees
//
DWORD
DmInstallDatabase(
    IN LPWSTR   FileName,
    IN OPTIONAL LPCWSTR Directory,
    IN BOOL     bDeleteSrcFile
    );

DWORD
DmGetDatabase(
    IN HKEY hKey,
    IN LPWSTR  FileName
    );

DWORD
DmCreateTempFileName(
    OUT LPWSTR FileName
    );

typedef struct _FILE_PIPE_STATE {
    unsigned long BufferSize;
    char __RPC_FAR *pBuffer;
    QfsHANDLE hFile;
    NM_CRYPTOR Cryptor;
} FILE_PIPE_STATE;

typedef struct _FILE_PIPE {
    BYTE_PIPE Pipe;
    FILE_PIPE_STATE State;
} FILE_PIPE, *PFILE_PIPE;

VOID
DmInitFilePipe(
    IN PFILE_PIPE FilePipe,
    IN QfsHANDLE hFile
    );

VOID
DmFreeFilePipe(
    IN PFILE_PIPE FilePipe
    );

DWORD
DmPushFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe,
    IN BOOL Encrypt
    );

DWORD
DmPullFile(
    IN LPCWSTR FileName,
    IN BYTE_PIPE Pipe
    );

DWORD
DmCommitRegistry(
    VOID
    );

DWORD
DmRollbackRegistry(
    VOID
    );


DWORD
DmRtlCreateKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY  * phkResult,
    OUT LPDWORD lpDisposition
    );

DWORD
DmRtlOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired,
    OUT HDMKEY * phkResult
    );

DWORD
DmRtlLocalCreateKey(
    IN HLOCALXSACTION hLocalXsaction,
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN DWORD samDesired,
    IN OPTIONAL LPVOID lpSecurityDescriptor,
    OUT HDMKEY * phkResult,
    OUT LPDWORD lpDisposition
    );

    

#ifdef __cplusplus
}
#endif

#endif //_DM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\gum.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gum.h

Abstract:

    Public data structures and procedure prototypes for the
    Global Update Manager (Gum) subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 16-Apr-1996

Revision History:

--*/

#ifndef _GUM_H
#define _GUM_H

//
// Define public structures and types
//
#define PRE_GUM_DISPATCH    1
#define POST_GUM_DISPATCH   2


//marshalling macros
#define GET_ARG(b, x) (PVOID)(*((PULONG)(b) + (x)) + (PUCHAR)(b))

// if you add new modules to GUM, this number needs to get adjusted
#define GUM_UPDATE_JOINSEQUENCE	2

//
// Predefined update types. Add new update types before
// GumUpdateMaximum!
//
typedef enum _GUM_UPDATE_TYPE {
    GumUpdateFailoverManager,
    GumUpdateRegistry,
    GumUpdateMembership,
    GumUpdateTesting,
    GumUpdateMaximum
} GUM_UPDATE_TYPE;

//
// John Vert (jvert) 4/3/1997
// Update types used by FM. Temporarily here so the EP doesn't need its own
// update type
//
//
// Gum update message types.
//
// The first entries in this list are auto-marshalled through Gum...Ex.
// Any updates that are not auto-marshalled must come after FmUpdateMaxAuto
//

typedef enum {
    FmUpdateChangeResourceName = 0,
    FmUpdateChangeGroupName,
    FmUpdateDeleteResource,
    FmUpdateDeleteGroup,
    FmUpdateAddDependency,
    FmUpdateRemoveDependency,
    FmUpdateChangeClusterName,
    FmUpdateChangeQuorumResource,
    FmUpdateResourceState,
    FmUpdateGroupState,
    EmUpdateClusWidePostEvent,
    FmUpdateGroupNode,
    FmUpdatePossibleNodeForResType,
    FmUpdateGroupIntendedOwner,
    FmUpdateAssignOwnerToGroups,
    FmUpdateApproveJoin,
    FmUpdateCompleteGroupMove,
    FmUpdateCheckAndSetGroupOwner,
    FmUpdateUseRandomizedNodeListForGroups,
    FmUpdateChangeQuorumResource2,  //added for whistler
    FmUpdateMaxAuto = 0x10000,
    FmUpdateFailureCount,
    FmUpdateGroupOwner,
    FmUpdateCreateGroup,
    FmUpdateCreateResource,
    FmUpdateJoin,
    FmUpdateAddPossibleNode,
    FmUpdateRemovePossibleNode,
    FmUpdateCreateResourceType,
    FmUpdateDeleteResourceType,
    FmUpdateChangeGroup,
    FmUpdateMaximum
} FM_GUM_MESSAGE_TYPES;

DWORD
EpUpdateClusWidePostEvent(
    IN BOOL             SourceNode,
    IN PCLUSTER_EVENT   pEvent,
    IN LPDWORD          pdwFlags,
    IN PVOID            Context1,
    IN PVOID            Context2
    );

//
// Structure used to provide the value returned by an update handler
// on a node.
//
typedef struct _GUM_NODE_UPDATE_HANDLER_STATUS {
    BOOLEAN  UpdateAttempted;
    DWORD    ReturnStatus;
} GUM_NODE_UPDATE_HANDLER_STATUS, *PGUM_NODE_UPDATE_HANDLER_STATUS;


//
// Define public interfaces
//


//
// Initialization and shutdown
//
DWORD
WINAPI
GumInitialize(
    VOID
    );

DWORD
WINAPI
GumOnline(
    VOID
    );

VOID
WINAPI
GumShutdown(
    VOID
    );

DWORD
GumCreateRpcBindings(
    PNM_NODE  Node
    );

//
// Routines to send updates
//
DWORD
WINAPI
GumSendUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
WINAPI
GumSendUpdateReturnInfo(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
	OUT PGUM_NODE_UPDATE_HANDLER_STATUS ReturnStatusArray,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
WINAPI
GumPostUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
GumPostUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    );

DWORD
GumSendUpdateEx(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
    IN DWORD ArgCount,
    ...
    );

DWORD
GumSendUpdateExReturnInfo(
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD DispatchIndex,
	OUT PGUM_NODE_UPDATE_HANDLER_STATUS ReturnStatusBuffer,
    IN DWORD ArgCount,
    ...
    );

DWORD
WINAPI
GumAttemptUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

DWORD
WINAPI
GumGetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType
    );

VOID
WINAPI
GumSetCurrentSequence(
    IN GUM_UPDATE_TYPE UpdateType,
    DWORD Sequence
    );


PVOID GumMarshallArgs(
    OUT LPDWORD lpdwBufLength,
    IN  DWORD   dwArgCount,
    ...);


// logging routine
typedef
DWORD
(WINAPI *PGUM_LOG_ROUTINE) (
    IN DWORD dwGumDispatch,
    IN DWORD dwSequence,
    IN DWORD dwType,
    IN PVOID pVoid,
    IN DWORD dwDataSize
    );

//
// Routines to receive updates
//
typedef
DWORD
(WINAPI *PGUM_UPDATE_ROUTINE) (
    IN DWORD Context,
    IN BOOL SourceNode,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );

#define GUM_MAX_DISPATCH_ARGS 8

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE1) (
    IN BOOL SourceNode,
    IN PVOID Arg1
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE2) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE3) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE4) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3,
    IN PVOID Arg4
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE5) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3,
    IN PVOID Arg4,
    IN PVOID Arg5
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE6) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3,
    IN PVOID Arg4,
    IN PVOID Arg5,
    IN PVOID Arg6
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE7) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3,
    IN PVOID Arg4,
    IN PVOID Arg5,
    IN PVOID Arg6,
    IN PVOID Arg7
    );

typedef
DWORD
(WINAPI *PGUM_DISPATCH_ROUTINE8) (
    IN BOOL SourceNode,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Arg3,
    IN PVOID Arg4,
    IN PVOID Arg5,
    IN PVOID Arg6,
    IN PVOID Arg7,
    IN PVOID Arg8
    );

typedef struct _GUM_DISPATCH_ENTRY {
    DWORD ArgCount;
    union {
        PGUM_DISPATCH_ROUTINE1 Dispatch1;
        PGUM_DISPATCH_ROUTINE2 Dispatch2;
        PGUM_DISPATCH_ROUTINE3 Dispatch3;
        PGUM_DISPATCH_ROUTINE4 Dispatch4;
        PGUM_DISPATCH_ROUTINE5 Dispatch5;
        PGUM_DISPATCH_ROUTINE6 Dispatch6;
        PGUM_DISPATCH_ROUTINE7 Dispatch7;
        PGUM_DISPATCH_ROUTINE8 Dispatch8;
            };
} GUM_DISPATCH_ENTRY, *PGUM_DISPATCH_ENTRY;


typedef struct _GUM_VOTE_DECISION_CONTEXT{
    GUM_UPDATE_TYPE     UpdateType;
    DWORD               dwContext;
    DWORD               dwInputBufLength;  //input data to make judgement upon
    PVOID               pInputBuf;  //size of the input data
    DWORD               dwVoteLength;
    PVOID               pContext;
}GUM_VOTE_DECISION_CONTEXT, *PGUM_VOTE_DECISION_CONTEXT;


//
// Routines to collect and dispatch vote
//
typedef
DWORD
(WINAPI *PGUM_VOTE_DECISION_CB) (
    IN PGUM_VOTE_DECISION_CONTEXT pDecisionContext,
    IN DWORD    dwVoteBufLength,
    IN PVOID    pVoteBuf,
    IN DWORD    dwNumVotes,
    IN BOOL     bDidAllActiveNodesVote,
    OUT LPDWORD pdwOutputBufSize,
    OUT PVOID   *pOutputBuf
    );

// routine to vote for a gum update type
typedef
DWORD
(WINAPI *PGUM_VOTE_ROUTINE) (
    IN  DWORD dwContext,
    IN  DWORD dwInputBufLength,
    IN  PVOID pInputBuf,
    IN  DWORD dwVoteLength,
    OUT PVOID pVoteBuf
    );

#define GUM_VOTE_VALID      0x00000001


#pragma warning( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union

typedef struct _GUM_VOTE_ENTRY{
    DWORD   dwFlags;
    DWORD   dwNodeId;
    DWORD   dwNumBytes;
    BYTE    VoteBuf[];
}GUM_VOTE_ENTRY, *PGUM_VOTE_ENTRY;

#pragma warning( default : 4200 )


#define GETVOTEFROMBUF(pVoteBuf, dwVoteLength, i, pdwNodeId) \
    (((((PGUM_VOTE_ENTRY)((PBYTE)pVoteBuf + ((sizeof(GUM_VOTE_ENTRY) + dwVoteLength) * ((i)-1))))->dwFlags) & GUM_VOTE_VALID) ?  \
    (PVOID)((PBYTE)pVoteBuf + (sizeof(GUM_VOTE_ENTRY) * (i)) + (dwVoteLength * ((i)-1))) : (NULL)),     \
    (*(pdwNodeId) = ((PGUM_VOTE_ENTRY)((PBYTE)pVoteBuf + ((sizeof(GUM_VOTE_ENTRY) + dwVoteLength) * ((i)-1))))->dwNodeId)

DWORD
GumSendUpdateOnVote(
    IN GUM_UPDATE_TYPE  UpdateType,
    IN DWORD            dwContext,
    IN DWORD            dwInputBufLength,
    IN PVOID            pInputBuffer,
    IN DWORD            dwVoteLength,
    IN PGUM_VOTE_DECISION_CB pfnGumDecisionCb,
    IN PVOID            pContext
    );



VOID
WINAPI
GumReceiveUpdates(
    IN BOOL IsJoining,
    IN GUM_UPDATE_TYPE UpdateType,
    IN PGUM_UPDATE_ROUTINE UpdateRoutine,
    IN PGUM_LOG_ROUTINE LogRoutine,
    IN DWORD DispatchCount,
    IN OPTIONAL PGUM_DISPATCH_ENTRY DispatchTable,
    IN OPTIONAL PGUM_VOTE_ROUTINE VoteRoutine
    );

VOID
WINAPI
GumIgnoreUpdates(
    IN GUM_UPDATE_TYPE UpdateType,
    IN PGUM_UPDATE_ROUTINE UpdateRoutine
    );


// Interface for a component to request gum to request NM
// shoot a node down to avoid consistency
VOID
GumCommFailure(
    IN GUM_UPDATE_TYPE GumUpdateType,
    IN DWORD NodeId,
    IN DWORD ErrorCode,
    IN BOOL Wait
    );

//
// Interfaces for special join updates
//
DWORD
WINAPI
GumBeginJoinUpdate(
    IN GUM_UPDATE_TYPE UpdateType,
    OUT DWORD *Sequence
    );

DWORD
WINAPI
GumEndJoinUpdate(
    IN DWORD Sequence,
    IN GUM_UPDATE_TYPE UpdateType,
    IN DWORD Context,
    IN DWORD BufferLength,
    IN PVOID Buffer
    );



#endif // _GUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\member.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    member.h

Abstract:

    Public data structures and procedure prototypes for
    the Membership subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

DWORD
CmpInitNodes(
    VOID
    );

VOID
CmpCleanupNodes(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\logman.h ===
#ifndef _LM_H
#define _LM_H

/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    logman.h

Abstract:

    Private header file for the cluster registry

Author:

    John Vert (jvert) 15-Dec-1995

Revision History:

--*/
//
// Define interfaces used by the logger component
//

//
// Well-known Resource Manager IDs
//
typedef DWORD   RMTYPE; //the record type stored in the flags
typedef DWORD   LSN;
typedef HANDLE  HLOG;
typedef int     TRID;
typedef HANDLE  HXSACTION;

typedef enum _RMID {
    RMPageEnd,          // reserved - signifies end of a log page
    RMBeginChkPt,       // reserved - signifies a start chkpoint record
    RMEndChkPt,         // reserved - signifies the end chk point record
    RMInvalidated,      // an invalidated record is marked at mount
    RMAny,
    RMRegistryMgr
} RMID;

typedef enum _TRTYPE {
    TTDontCare,     //log management specific routines use this type
    TTStartXsaction,
    TTCommitXsaction,
    TTAbortXsaction,
    TTXsactionUnit,
    TTCompleteXsaction,
}TRTYPE;    

typedef enum _TRSTATE{
    XsactionAborted,
    XsactionCommitted,
    XsactionUnknown
}TRSTATE;

#define LOG_MAX_FILENAME_LENGTH         MAX_PATH

#define NULL_LSN 0


/****
@typedef    BOOL (WINAPI *PLOG_GETCHECKPOINT_CALLBACK) | 
			Supplies the routine to be called back in order to obtain a check
    		point file once the log manager is asked to record a checkpoint in
    		the log file.

@parm       IN LPCWSTR | lpszPath | The path where to create the checkpoint file.
           
@parm		IN PVOID | Context| Supplies the checkpoint CallbackContext specified 
			to LogCreate().

@parm		IN PVOID | pszFileName | Supplies the name of file to take the checkpt in.

@parm		OUT TRID | *pChkPtTransaction | Supplies the transaction identifier of the checkpoint.

@xref       <f LogCreate>
****/
typedef
DWORD
(WINAPI *PLOG_GETCHECKPOINT_CALLBACK) (
    IN LPCWSTR  lpszPath,
    IN PVOID    pContext,
    IN LPWSTR   pszChkPtFile,
    OUT TRID    *pChkPtTransaction
    );

HLOG
LogCreate(
    IN LPWSTR   lpFileName,
    IN DWORD    dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID    pGetChkPtContext,
    IN BOOL     bForceCreate,
    OPTIONAL OUT LSN *pLastLsn
    );

DWORD
LogClose(
    IN HLOG LogFile
    );

DWORD
LogCommitSize(
    IN HLOG     hLog,
    IN RMID     ResourceId,
    IN DWORD    dwDataSize
    );

LSN
LogWrite(
    IN HLOG LogFile,
    IN TRID TransactionId,
    IN TRTYPE TransactionType,
    IN RMID ResourceId,
    IN RMTYPE ResourceFlags,
    IN PVOID LogData,
    IN DWORD DataSize
    );

LSN
LogFlush(
    IN HLOG LogFile,
    IN LSN MinLsn
    );

LSN
LogRead(
    IN HLOG LogFile,
    IN LSN CurrentLsn,
    OUT RMID *Resource,
    OUT RMTYPE *ResourceFlags,
    OUT TRID *Transaction,
    OUT TRTYPE *TrType,
    OUT PVOID LogData,
    IN OUT DWORD *DataSize
    );

typedef
BOOL
(WINAPI *PLOG_SCAN_CALLBACK) (
    IN PVOID    Context,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceFlags,
    IN TRID     Transaction,
    IN TRTYPE   TransactionType,
    IN const PVOID LogData,
    IN DWORD DataLength
    );


typedef
BOOL
(WINAPI *PLOG_SCANXSACTION_CALLBACK) (
    IN PVOID    Context,
    IN LSN      Lsn,
    IN RMID     Resource,
    IN RMTYPE   ResourceFlags,
    IN TRID     Transaction,
    IN const PVOID LogData,
    IN DWORD DataLength
    );

DWORD
LogScan(
    IN HLOG LogFile,
    IN LSN FirstLsn,
    IN BOOL ScanForward,
    IN PLOG_SCAN_CALLBACK CallbackRoutine,
    IN PVOID CallbackContext
    );


DWORD
LogCheckPoint(
    IN HLOG     LogFile,
    IN BOOL     bAllowReset,
    IN LPCWSTR  lpszInChkPtFile,
    IN DWORD    dwChkPtSeq
    );

DWORD
LogReset(
    IN HLOG LogFile
    );

DWORD
LogGetLastChkPoint(
        IN HLOG         LogFile,
        IN LPWSTR       pszChkPtFileName,
        OUT TRID        *pTransaction,
        OUT LSN         *pChkPtLsn
);

DWORD LogGetInfo(
    IN  HLOG    hLog,
    OUT LPWSTR  szFileName,
    OUT LPDWORD pdwCurLogSize,
    OUT LPDWORD pdwMaxLogSize
    );

DWORD LogSetInfo(
    IN  HLOG    hLog,
    IN  DWORD   dwMaxLogSize
    );

//Local Xsaction related routines    
DWORD
LogFindXsactionState(
   IN   HLOG    hLog,
   IN   LSN     Lsn,
   IN   TRID    TrId,
   OUT  TRSTATE *pTrState
   );

DWORD
LogScanXsaction(
    IN HLOG     hLog,
    IN LSN      StartXsactionLsn,
    IN TRID     StartXsactionId,
    IN PLOG_SCANXSACTION_CALLBACK CallbackRoutine,
    IN PVOID    pContext
    );

HXSACTION
LogStartXsaction(
    IN HLOG     hLog,
    IN TRID     TrId,
    IN RMID     ResourceId,
    IN RMTYPE   ResourceFlags
    );

DWORD WINAPI LogCommitXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags
    );

DWORD
LogAbortXsaction(
    IN HLOG         hLog,
    IN HXSACTION    TrId,
    IN RMTYPE       ResourceFlags
    );


LSN
LogWriteXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags,
    IN PVOID        pLogData,
    IN DWORD        dwDataSize
    );

//Logmanager initialization/shutdown
DWORD   LmInitialize();

DWORD LmShutdown();

//Timer Activity Functions- these are generic functions
typedef
void
(WINAPI *PFN_TIMER_CALLBACK)(
        IN HANDLE   hTimer,
        IN PVOID    pContext
        );

DWORD
AddTimerActivity(
        IN HANDLE               hTimer,
        IN DWORD                dwInterval,
        IN LONG                 lPeriod,
        IN PFN_TIMER_CALLBACK   pfnTimerCallback,
        IN PVOID                pContext
);


DWORD
RemoveTimerActivity(
        IN HANDLE       hTimer
);

DWORD
UnpauseTimerActivity(
        IN HANDLE       hTimer
);

DWORD
PauseTimerActivity(
        IN HANDLE       hTimer
);

#endif //_LM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\init.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Public data structures and procedure prototypes for
    the INIT subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/


//
// Shutdown Types
//

typedef enum _SHUTDOWN_TYPE {
    CsShutdownTypeStop = 0,
    CsShutdownTypeShutdown,
    CsShutdownTypeMax
} SHUTDOWN_TYPE;

extern SHUTDOWN_TYPE CsShutdownRequest;

// While another node is joining, we will keep track of any DM or FM updates.
extern BOOL   CsDmOrFmHasChanged;


//
// A few interfaces for reporting of errors.
//

VOID
ClusterLogFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    );

VOID
ClusterLogEvent0(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    );

VOID
ClusterLogEvent1(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    );

VOID
ClusterLogEvent2(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    );

VOID
ClusterLogEvent3(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    );

//
// Convenient memory allocation routines
//
PVOID
CsAlloc(
    DWORD Size
    );

#define CsFree(_p_) LocalFree(_p_)

LPWSTR
CsStrDup(
    LPCWSTR String
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\fm.h ===
#ifndef _FM_H
#define _FM_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fm.h

Abstract:

    Public data structures and procedure prototypes for
    the Failover Manager subcomponent of the NT Cluster Service

Author:

    John Vert (jvert) 7-Feb-1996

Revision History:

--*/

//
// Public structure definitions
//

//
// FM notifications
// The FM supports the following notifications to allow other
// cluster components to prepare and cleanup state.
//
//SS: for now add it here..but if this is needed externally
//move it to appropriate place
// these notifications are generated only on the node where the
// resource resides
#define NOTIFY_RESOURCE_PREONLINE               0x00000001
#define NOTIFY_RESOURCE_POSTONLINE              0x00000002
#define NOTIFY_RESOURCE_PREOFFLINE              0x00000004
#define NOTIFY_RESOURCE_POSTOFFLINE             0x00000008 //this is the same as offline
#define NOTIFY_RESOURCE_FAILED                  0x00000010
#define NOTIFY_RESOURCE_OFFLINEPENDING          0x00000020
#define NOTIFY_RESOURCE_ONLINEPENDING           0x00000040

//
// Resource type structure definition
//

// Define Flags
#define RESTYPE_DEBUG_CONTROL_FUNC  1

#define     RESTYPE_STATE_LOADS      0x00000001

typedef struct FM_RESTYPE {
    LPWSTR          DllName;
    DWORD           LooksAlivePollInterval;
    DWORD           IsAlivePollInterval;
    LPWSTR          DebugPrefix;
    DWORD           Flags;
    DWORD           State;
    DWORD           Class;
    LIST_ENTRY      PossibleNodeList;
} FM_RESTYPE, *PFM_RESTYPE;


//
// Resource Possible Owners structure
//

typedef struct RESTYPE_POSSIBLE_ENTRY {
    LIST_ENTRY      PossibleLinkage;
    PNM_NODE        PossibleNode;
} RESTYPE_POSSIBLE_ENTRY, *PRESTYPE_POSSIBLE_ENTRY;

#if CLUSTER_BETA
#define FM_MAX_LOCK_ENTRIES  8
#else
#define FM_MAX_LOCK_ENTRIES  4
#endif

//
// Group structure
//

typedef struct _LOCK_INFO {
    DWORD   Module: 5;
    DWORD   ThreadId: 11;
    DWORD   LineNumber: 16;
} LOCK_INFO, *PLOCK_INFO;

typedef struct FM_GROUP {
    DWORD               dwStructState;
    LIST_ENTRY          Contains;       // List of root resources in this Group
    LIST_ENTRY          PreferredOwners; // Ordered list of preferred owners
    LIST_ENTRY          DmRundownList;  // DM rundown list
    DWORD               OrderedOwners;  // # of ordered owners in above list
    CRITICAL_SECTION    Lock;           // Critical section for this Group
    DWORD               LockIndex;
    DWORD               UnlockIndex;
    LOCK_INFO           LockTable[FM_MAX_LOCK_ENTRIES];
    LOCK_INFO           UnlockTable[FM_MAX_LOCK_ENTRIES];
    CLUSTER_GROUP_STATE State;          // State of the Group
    PRESOURCE_ENUM      MovingList;     // Ptr to List of moving resources
    BOOL                Initialized;    // TRUE if registry parameters read
    BOOL                InitFailed;     // TRUE if a resource fails to init
    PNM_NODE            OwnerNode;      // Ptr to owner node. NULL if not known
    UCHAR               FailbackType;   // See AutoFailbackTypes
    UCHAR               FailbackWindowStart; // 0-24 hours
    UCHAR               FailbackWindowEnd; // 0-24 hours (0 is immediate)
    UCHAR               FailoverPeriod; // 1-24 hours (0 is infinite)
    DWORD               FailoverThreshold; // 1-N failovers (0 is infinite)
    CLUSTER_GROUP_STATE PersistentState;   // Preferred state of this group
    DWORD               FailureTime;    // Time of first failure
    DWORD               NumberOfFailures; // Number of failures.
    HDMKEY              RegistryKey;
    LIST_ENTRY          WaitQueue;          // chained FM_WAIT_BLOCK structures
    DWORD               StateSequence;
    HANDLE              hPendingEvent;
    PNM_NODE            pIntendedOwner;
    LPWSTR              lpszAntiAffinityClassName;   // Anti-affinity property
} FM_GROUP, *PFM_GROUP;


#define FM_GROUP_STRUCT_CREATED                     0x00000001
#define FM_GROUP_STRUCT_INITIALIZED                 0x00000002
#define FM_GROUP_STRUCT_MARKED_FOR_DELETE           0x00000004
#define FM_GROUP_STRUCT_MARKED_FOR_MOVE_ON_FAIL     0x00000008
#define FM_GROUP_STRUCT_MARKED_FOR_REGULAR_MOVE     0x00000010
#define FM_GROUP_STRUCT_MARKED_FOR_PENDING_ACTION   0x00000020
#define FM_GROUP_STRUCT_MARKED_FOR_COMPLETION_EVENT 0x00000040

#define IS_VALID_FM_GROUP(pFmGroup)   \
    (!(pFmGroup->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_DELETE))

//
#define IS_PENDING_FM_GROUP(pFmGroup)   \
    (pFmGroup->dwStructState & FM_GROUP_STRUCT_MARKED_FOR_PENDING_ACTION)

// Resource structure and types
//
//
// Resource structure
//

// Define Flags
#define RESOURCE_SEPARATE_MONITOR   1
#define RESOURCE_CREATED            2
#define RESOURCE_WAITING            4


typedef struct FM_RESOURCE {
    DWORD           dwStructState;
    LIST_ENTRY      DependsOn;
    LIST_ENTRY      ProvidesFor;
    LIST_ENTRY      PossibleOwners;     // List of possible owners
    LIST_ENTRY      ContainsLinkage;    // Linkage onto FM_GROUP.Contains
    LIST_ENTRY      DmRundownList;      // DM rundown list
    //SS: for now we dont use resource locks, so dont create it and leak it !
    //CRITICAL_SECTION Lock;
    RESID           Id;
    CLUSTER_RESOURCE_STATE  State;
    BOOL            QuorumResource;
    LPWSTR          Dependencies;
    LPWSTR          DebugPrefix;
    DWORD           DependenciesSize;
    struct RESMON   *Monitor;
    PFM_RESTYPE     Type;
    PFM_GROUP       Group;
    ULONG           Flags;
    DWORD           LooksAlivePollInterval;
    DWORD           IsAlivePollInterval;
    CLUSTER_RESOURCE_STATE PersistentState;
    DWORD           RestartAction;
    DWORD           RestartThreshold;
    DWORD           RestartPeriod;
    DWORD           NumberOfFailures;
    DWORD           PendingTimeout;
    HANDLE          PendingEvent;
    HDMKEY          RegistryKey;
    DWORD           FailureTime;
    PVOID           CheckpointState;            // for use by checkpoint manager
    DWORD           ExFlags;                    // Extrinsic flags
    DWORD           Characteristic;
    DWORD           StateSequence;
    BOOL            PossibleList;   // TRUE if possible list entries specified
    DWORD           BlockingQuorum; // 1 if shared lock held, blocking quorum
    HANDLE          hTimer;         // handle to timer used for delayed restart 
    DWORD           RetryPeriodOnFailure;    //Time,in milliseconds, after which a restart will be attempted
} FM_RESOURCE, *PFM_RESOURCE;


#define FM_RESOURCE_STRUCT_CREATED              0x00000001
#define FM_RESOURCE_STRUCT_INITIALIZED          0x00000002
#define FM_RESOURCE_STRUCT_MARKED_FOR_DELETE    0x00000004

#define IS_VALID_FM_RESOURCE(pFmResource)   \
    (!(pFmResource->dwStructState & FM_RESOURCE_STRUCT_MARKED_FOR_DELETE))


//
// Dependency structure
//
typedef struct dependency {
    LIST_ENTRY           DependentLinkage;
    PFM_RESOURCE         DependentResource;
    LIST_ENTRY           ProviderLinkage;
    PFM_RESOURCE         ProviderResource;
} DEPENDENCY, *PDEPENDENCY;

//
// AutoFailbackType
//

typedef enum {
    GroupNoFailback,
    GroupFailback
} GROUP_FAILBACK_TYPE;


//
// Group Preferred Owners structure
//

typedef struct PREFERRED_ENTRY {
    LIST_ENTRY      PreferredLinkage;
    PNM_NODE        PreferredNode;
} PREFERRED_ENTRY, *PPREFERRED_ENTRY;


//
// Resource Possible Owners structure
//

typedef struct POSSIBLE_ENTRY {
    LIST_ENTRY      PossibleLinkage;
    PNM_NODE        PossibleNode;
} POSSIBLE_ENTRY, *PPOSSIBLE_ENTRY;



//
// Public function interfaces
//

//
// Startup, online and shutdown
//
DWORD
WINAPI
FmInitialize(
    VOID
    );

BOOL
FmArbitrateQuorumResource(
    VOID
    );


VOID
FmHoldIO(
    VOID
    );


VOID
FmResumeIO(
    VOID
    );


DWORD
WINAPI
FmFindQuorumResource(
        OUT PFM_RESOURCE *ppResource
        );

DWORD FmBringQuorumOnline();

DWORD
WINAPI
FmFindQuorumOwnerNodeId(
        IN PFM_RESOURCE pResource
        );

DWORD
WINAPI
FmGetQuorumResource(
    OUT PFM_GROUP   *ppQuoGroup,
    OUT LPDWORD     lpdwSignature  OPTIONAL
    );

DWORD 
WINAPI
FmpSendForceQuorumControlToResource(
    IN PFM_RESOURCE resource 
    );

BOOL
WINAPI
FmpIsNodeInForceQuorumNodes(
    IN LPCWSTR lpszNodeId
    );


DWORD
WINAPI
FmSetQuorumResource(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR  lpszLogPathName,
    IN DWORD    dwMaxQuorumLogSize
    );

DWORD
WINAPI
FmBackupClusterDatabase(
    IN LPCWSTR lpszPathName
    );


DWORD
WINAPI
FmFormNewClusterPhase1(
    IN PFM_GROUP pQuoGroup
    );

DWORD
WINAPI
FmFormNewClusterPhase2(
    VOID
    );

DWORD
WINAPI
FmJoinPhase1(
    OUT DWORD *EndSeq
    );

DWORD
WINAPI
FmJoinPhase2(
    VOID
    );

VOID
FmJoinPhase3(
    VOID
    );


VOID
FmShutdownGroups(
    VOID
    );

VOID
FmShutdown(
    VOID
    );


//
// Management APIs for groups
//

DWORD
WINAPI
FmOnlineGroup(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmOfflineGroup(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmMoveGroup(
    IN PFM_GROUP Group,
    IN PNM_NODE DestinationNode OPTIONAL
    );

PFM_GROUP
WINAPI
FmCreateGroup(
    IN LPWSTR GroupId,
    IN LPCWSTR GroupName
    );

DWORD
WINAPI
FmDeleteGroup(
    IN PFM_GROUP Group
    );

DWORD
WINAPI
FmSetGroupName(
    IN PFM_GROUP Group,
    IN LPCWSTR FriendlyName
    );

CLUSTER_GROUP_STATE
WINAPI
FmGetGroupState(
    IN PFM_GROUP Group,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength
    );


//
// Check if a cluster partition exists
//

BOOL
WINAPI
FmVerifyNodeDown(
    IN  PNM_NODE Node,
    OUT LPBOOL   IsDown
    );

DWORD
WINAPI
FmEvictNode(
    IN PNM_NODE Node
    );


//
// enumeration callback routine definitions
//
typedef BOOL (*FM_ENUM_GROUP_RESOURCE_ROUTINE)(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Resource,
    IN LPCWSTR Name
    );

DWORD
WINAPI
FmEnumerateGroupResources(
    IN PFM_GROUP Group,
    IN FM_ENUM_GROUP_RESOURCE_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    );


//
// Management APIs for resources
//

PFM_RESOURCE
WINAPI
FmCreateResource(
    IN PFM_GROUP Group,
    IN LPWSTR ResourceId,
    IN LPCWSTR ResourceName,
    IN LPCWSTR ResourceType,
    IN DWORD dwFlags
    );

DWORD
WINAPI
FmOnlineResource(
    IN PFM_RESOURCE Resource
    );

DWORD
WINAPI
FmOfflineResource(
    IN PFM_RESOURCE Resource
    );

CLUSTER_RESOURCE_STATE
WINAPI
FmGetResourceState(
    IN PFM_RESOURCE Resource,
    OUT LPWSTR NodeName,
    IN OUT PDWORD NameLength
    );

DWORD
WINAPI
FmFailResource(
    IN PFM_RESOURCE Resource
    );

DWORD
WINAPI
FmDeleteResource(
    IN PFM_RESOURCE Resource
    );

DWORD
WINAPI
FmSetResourceName(
    IN PFM_RESOURCE Resource,
    IN LPCWSTR FriendlyName
    );

DWORD
WINAPI
FmAddResourceDependency(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource
    );

DWORD
WINAPI
FmRemoveResourceDependency(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource
    );

BOOL
FmDependentResource(
    IN PFM_RESOURCE Resource,
    IN PFM_RESOURCE DependentResource,
    IN BOOL ImmediateOnly
    );

DWORD
WINAPI
FmEnumResourceDependent(
    IN PFM_RESOURCE Resource,
    IN DWORD Index,
    OUT PFM_RESOURCE *DependentResource
    );

DWORD
WINAPI
FmEnumResourceProvider(
    IN PFM_RESOURCE Resource,
    IN DWORD Index,
    OUT PFM_RESOURCE *ProviderResource
    );

DWORD
WINAPI
FmEnumResourceNode(
    IN PFM_RESOURCE Resource,
    IN DWORD Index,
    OUT PNM_NODE *ProviderResource
    );

DWORD
WINAPI
FmChangeResourceNode(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node,
    IN BOOL Add
    );

DWORD
FmCreateResourceType(
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    );

DWORD
WINAPI
FmDeleteResourceType(
    IN LPCWSTR TypeName
    );

DWORD
FmEnumResourceTypeNode(
    IN  PFM_RESTYPE  pResType,
    IN  DWORD        dwIndex,
    OUT PNM_NODE     *pPossibleNode
    );

DWORD
FmChangeResourceGroup(
    IN PFM_RESOURCE Resource,
    IN PFM_GROUP Group
    );

DWORD
FmChangeClusterName(
    IN LPCWSTR pszNewName,
    IN LPCWSTR pszOldName
    );

DWORD
FmNetNameParseProperties(
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT LPWSTR *ppszClusterName
    );

DWORD
WINAPI
FmResourceControl(
    IN PFM_RESOURCE Resource,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
FmResourceTypeControl(
    IN LPCWSTR ResourceTypeName,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
WINAPI
FmGroupControl(
    IN PFM_GROUP Group,
    IN PNM_NODE Node OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Routines for manipulating dependency trees
//
typedef struct FM_DEPENDENCY_TREE {
    LIST_ENTRY ListHead;
} FM_DEPENDENCY_TREE, *PFM_DEPENDENCY_TREE;

typedef struct FM_DEPENDTREE_ENTRY {
    LIST_ENTRY ListEntry;
    PFM_RESOURCE Resource;
} FM_DEPENDTREE_ENTRY, *PFM_DEPENDTREE_ENTRY;

PFM_DEPENDENCY_TREE
FmCreateFullDependencyTree(
    IN PFM_RESOURCE Resource
    );

VOID
FmDestroyFullDependencyTree(
    IN PFM_DEPENDENCY_TREE Tree
    );


BOOL
FmCheckNetworkDependency(
    IN LPCWSTR DependentNetwork
    );


DWORD
FmBuildWINS(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR *pszKeyName
    );

DWORD
FmBuildDHCP(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildIIS(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildSMTP(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildNNTP(
    IN  DWORD   dwFixUpType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildMSDTC(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD 
FmBuildNewMSMQ(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );

DWORD
FmBuildClusterProp(
    IN  DWORD   dwFixUpType,
    OUT PVOID  * ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR * pszKeyName
    );


DWORD
FmCreateRpcBindings(
    PNM_NODE Node
    );


//callback for registry fixups (resource type addition) 
DWORD
FmFixupNotifyCb(VOID);


//the callback registered for object notifications
typedef void (WINAPI *FM_ONLINE_ONTHISNODE_CB)(
    );

void FmCheckQuorumState(
    IN FM_ONLINE_ONTHISNODE_CB OnLineOnThisNodeCb, 
    OUT PBOOL pbQuorumOfflineOnThisNode
    );

DWORD FmDoesQuorumAllowJoin(
    IN PCWSTR pszJoinerNodeId );

DWORD FmDoesQuorumAllowLogging(
    IN DWORD dwQuorumResourceCharacteristics    OPTIONAL
    );

//Fixup function for AdminExt value
DWORD
FmFixupAdminExt(VOID);

//
//  Check if resource dll deadlock detection is enabled
//
VOID
FmCheckIsDeadlockDetectionEnabled(
    VOID
    );

#endif //_FM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\mmapi.h ===
#ifndef  _MMAPI_H_
#define  _MMAPI_H_
/* ---------------------- MMapi.h ----------------------- */

/* This module contains cluster Membership Manager (MM) functions.
 *
 * These functions are for the sole use of the ClusterManager (CM).
 * All are privileged and local; no user can call them. Security is
 * not checked.  The module is not thread-aware; only a single thread
 * can use these functions at a time (unless otherwise noted).
 * Higher levels must ensure this. Blocking characteristics of the routines are
 * noted.
 *
 *
 * All nodes of the cluster must know their own unique nodenumber
 * within that cluster (a small int in the range 0..some_max-1). This
 * number is defined for the node at configuration time (either by the
 * user or by the setup code; this module doesn't care which) and is
 * essentially permanent.  (The node number allows indexing and
 * bitmask operations easily, where names and non-small ints don't).
 * There is no code in MM to detect illegal use of nodenumber, staleness
 * of node number, etc.
 *
 * Clusters may also be named and/or numbered. Nodes are named. This
 * module makes no use of such facilities; it is based entirely on
 * node-number.
 *
 * It is assumed that all use of routines here is done on nodes which
 * agree to be members of the same cluster. This module does not check
 * such things.
 *
 * Cluster network connectivity must also be provided:
 *
 * - A node N must specify the various paths by which it can
 *   communicate with every other node; each other node must define
 *   its communication paths back to N. Full connectivity must be
 *   guaranteed; each node must be able to talk directly to every
 *   other node (and the reverse); for fault-tolerance, communication
 *   paths must not only be replicated (minimally, duplicated) but
 *   must also use entirely independent wiring and drivers. TCP/IP
 *   lans and async connections are suggested.  Heartbeat traffic
 *   (which establishes cluster membership) may travel on any or all
 *   of the connectivity paths.  [Cluster management traffic may
 *   travel on any or all of the connectivity paths, but may be
 *   restricted to high-performance paths (eg, tcp/ip)].
 *
 * - A node must know the address of the cluster as a whole. This is
 *   an IP address which failsover (or a netbios name which fails
 *   over.. TBD) such that connecting to that cluster address provides
 *   a way to talk to a valid active member of the cluster, here
 *   called the PCM.
 *
 * Note that cluster connectivity is not defined by this interface;
 * it is assumed to be in a separate module. This module deals only in
 * communication to the cluster or communication to a nodenumber
 * within that cluster; it does not care about the details of how such
 * communication is done.
 *
 * Cluster connectivity must be known to all nodes in the cluster
 * and to a joining node, before the join attempt is made.
 *
 */
#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */

#include <windows.h>
#include <bitset.h>
/* The following errors can be returned from the MM module: */

enum {
   MM_OK        = 0,  /* operation competed successfully           */
   MM_TIMEOUT   = 1,  /* operation timed out                       */
   MM_TRANSIENT = 2,  /* Transient failure; operation should be
                         retried                                   */
   MM_FAULT     = 3,  /* Illegal parameter; impossible condition,
                         etc.  NOTE: not all illegal calling
                         sequences will be detected.  Correct use
                         of the MM functions is a responsibility
                         of the CM caller.                         */
   MM_ALREADY   = 4,  /* node is already in the desired condition  */
   MM_NOTMEMBER = 5,  /* node needs to be a cluster member to
                         perform this operation                    */
     };


/* A node can be Up or Down */

typedef enum {  NODE_UP      = 1,
                NODE_DOWN    = 2
             }  NODESTATUS;


/* this type defines the cluster */

typedef struct tagCLUSTERINFO {
   DWORD      NumActiveNodes;   /* Number of nodes currently
                                   participating in this cluster   */
   LPDWORD    UpNodeList;       /* pointer to a <NumActiveNodes>
                                   sized array of node#s in the
                                   cluster which are up            */

   DWORD      clockPeriod;      /* current setting                 */
   DWORD      sendHBRate;       /* current setting                 */
   DWORD      rcvHBRate;        /* current setting                 */
} CLUSTERINFO, *LPCLUSTERINFO;

/*
 * UpNodeList is the array of active cluster members, in numeric order. The pointer
 * may be null. If non-null, it is assumed that the space is big enough.
 *
 */


/* the following are the typedefs for the callback functions from MM to
   the higher-level Cluster Mgr layer. */

typedef DWORD (*MMNodeChange)(IN DWORD node, IN NODESTATUS newstatus);

/* MMNodeChange is a function which will be called in this Up node
 *   whenever the MM declares another node Up or Down. This occurs after
 *   changing the current cluster membership (available via ClusterInfo) and
 *   in the last stage of Regroup. The CM may then
 *   initiate failovers, device ownership changes, user node status
 *   events, etc. This routine must be quick and must not block
 *   (acceptible time TBD).  Note that this will happen on all nodes
 *   of the cluster; it is up to the CM design to decide whether to
 *   issue events from only the PCM or from each CM node.
 *
 *   A node receives a NODE_UP callback for itself.
 *
 */

typedef DWORD (*MMNodesDown)(IN BITSET nodes);

/* MMNodesDown is a function that will be called at the end
 * of the regroup to indicate that node/multiple nodes is/are down.
 *
 * MMNodeChange is called only to indicate whether the node is up
 *
 */

typedef BOOL (*MMQuorumSelect)(void);

/* This is a callback to deal with the special case where only 2 members of the
 * cluster existed, and a Regroup incident occurred such that only one
 * member now survives OR there is a partition and both members survive (but cannot
 * know that). The intent of the Quorum function is to determine whether the other
 * node is alive or not, using mechanisms other than the normal heartbeating over the
 * normal comm links (eg, to do so by using non-heartbeat communication paths, such as
 * SCSI reservations). This function is called only in the case of where cluster
 * membership was previously exactly two nodes; and is called on any surviving node
 * of these two (which might mean it is called on one node or on both partitioned
 * nodes).
 *
 * If this routine returns TRUE, then the calling node stays in the cluster. If the
 * quorum algorithm determines that this node must die (because the other cluster member
 * exists), then this function should return FALSE;this will initiate an orderly
 * shutdown of the cluster services.
 *
 * In the case of a true partition, exactly one node should return TRUE.
 *
 * This routine may block and take a long time to execute (>2 secs).
 *
 */
typedef void (*MMHoldAllIO)(void);

/* This routine is called early (prior to Stage 1) in a Regroup incident.
 * It suspends all cluster IO (to all cluster-owned devices), and any relevant
 * intra-cluster messages, until resumed (or until this node dies).
 */

typedef void (*MMResumeAllIO)(void);

/* This is called during Regroup after the new cluster membership has been
 * determined, when it is known that this node will remain a member of the cluster (early in
 * Stage 4). All IO previously suspended by MMHoldAllIO should be resumed.
 */


typedef void (*MMMsgCleanup1) (IN DWORD deadnode);

/* This is called as the first part of intra-cluster message system cleanup (in stage 4).
 * It cancels all incoming messages from a failed node. In the case where multiple nodes are
 * evicted from the cluster, this function is called repeatedly, once for each node.
 *
 * This routine is synchronous and Regroup is suspended until it returns.
 * It must execute quickly.
 *
 */


typedef void (*MMMsgCleanup2)(IN BITSET nodes);

/* This is the second phase of message system cleanup (in stage 5). It cancels all outgoing
 * messages to dead nodes. Characteristics are as for Cleanup1.
 */



typedef void (*MMHalt)(IN DWORD haltcode);

/* This function is called whenever the MM detects that this node should immediately leave
 * the cluster (eg, on receipt of a poison packet or at some impossible error situation).
 * The HALT function should immediately initiate Cluster Management shutdown.
 * No MM functions should be called after this, other than MMShutdown.
 *
 * haltcode is a number identifying the halt reason.
 */

typedef void (*MMJoinFailed)(void);

/* This is called on a node being joined into the cluster when the join attempt in the PCM
 * fails. Following this callback, the node may petition to
 * join again, after cleaning up via a call to MMLeave.
 */


/* The operations on clusters are defined below: */

DWORD MMInit(
    IN DWORD             mynode,
    IN DWORD             MaxNodes,
    IN MMNodeChange      UpDownCallback,
    IN MMQuorumSelect    QuorumCallback,
    IN MMHoldAllIO       HoldIOCallback,
    IN MMResumeAllIO     ResumeIOCallback,
    IN MMMsgCleanup1     MsgCleanup1Callback,
    IN MMMsgCleanup2     MsgCleanup2Callback,
    IN MMHalt            HaltCallback,
    IN MMJoinFailed      JoinFailedCallback,
    IN MMNodesDown       NodesDownCallback
    );


/* This initialises various local MM data structures. It should be
 * called exactly once at CM startup time on every node. It must preceed any other
 * MM call. It sends no messages; the node need not have connectivity defined yet.
 * It does not block.
 *
 * Mynode is the node# of this node within the cluster.  This is
 *   assumed to be unique (but cannot be checked here to be so).
 *
 * The callbacks are described above.
 *
 *  Error returns:
 *
 *     MM_OK        Success.
 *
 *     MM_FAULT     Something impossible happened.
 *
 */


DWORD MMJoin(
    IN DWORD  joiningNode,
    IN DWORD  clockPeriod,
        IN DWORD  sendHBRate,
        IN DWORD  rcvHBRate,
    IN DWORD  joinTimeout
           );

/*
 *
 * This causes the specified node to join the active cluster.
 *
 * This routine should be issued by only one node of the cluster (the
 * PCM); all join attempts must be single-threaded (by code outside
 * this module).
 *
 * This routine may block and take a long time to execute.
 *
 *  [Prior to this being called:
 *     - joiningNode has communicated to the PCM of the cluster
 *       that it wants to join.
 *     - checks on validity of clustername, nodenumber, etc have been
 *       made; any security checks have been done;
 *     - connectivity paths have been established to/from the cluster
 *       and joiningNode.
 *     - the Registry etc has been downloaded.
 *  ]
 *
 *  joiningNode is the node number of the node being brought into
 *     the cluster.
 *
 *     If joiningNode = self (as passed in via MMinit), then the node
 *     will become the first member of a new cluster; if not, the node
 *     will be brought into the existing cluster.
 *
 *  clockPeriod, sendRate, and rcvRate can only be set by the first call (ie
 *     when the cluster is formed); later calls (from joining members)
 *     inherit the original cluster values. The entire cluster therefore operates
 *     with the same values.
 *
 *  clockPeriod is the basic clock interval which drives all internal
 *     MM activities, such as the various stages
 *     of membership reconfiguration, and eventually user-perceived
 *     recovery time. Unit= ms. This must be between the min and max
 *     allowed (values TBD; current best setting = 300ms).  Note that
 *     clockperiod is path independent and node independent. All
 *     cluster members regroup at the same rate over any/all available
 *     paths; all periods are identical in all nodes.
 *     A value of 0 implies default setting (currently 300ms).
 *
 *  sendHBrate is the multiple of clockPeriod at which heartbeats are sent. This
 *     must be between the min and max allowed (values TBD; current best setting = 4).
 *     A value of 0 implies default setting (currently 4).
 *
 *  rcvHBrate is the multiple of sendRate during which a heartbeat must arrive, or the
 *     node initiates a Regroup (probably resulting in some node leaving the cluster).
 *     This must be between min and max; (values TBD; current best setting = 2).
 *     A value of 0 implies default setting (currently 2).
 *
 *  The combination of these variables controls overall node-failure detection time,
 *  Regroup time, and the sensitivity of MM to transient comm errors. There are
 *  important considerations to be understood when changing these values; these,
 *  and then formula for calculating recovery times etc, are given elsewhere.
 *
 *
 *---  NOTES:
 *---     safe and appropriate min and max values for these have yet to be chosen.
 *---     Changing the values from the defaults is currently UNSUPPORTED and can have
 *---     serious consequences.
 *
 *  JoinTimeout is an overall timer on the entire Join attempt. If the
 *     node has not achieved full cluster membership in this time, the
 *     attempt is abandoned.
 *
 *
 *  Error returns:
 *
 *     MM_OK        Success; cluster joined. During or soon after the join, a
 *                  node-up callback will soon occur on this
 *                  and on all cluster member nodes (including the new member).
 *                  The CM is then safe to
 *                  assign ownership to cluster-owned devices on the
 *                  node, and to start failover/failback processing.
 *
 *                  Note: this routine establishes cluster membership.
 *                  However, it is usually inadvisable to start high
 *                  level CM failbacks immediately, because other
 *                  cluster members are often still joining. The CM
 *                  should typically wait a while to see whether other
 *                  nodes arrive in the cluster soon.
 *  Failure cases:
 *
 *  In the joiningNode, a joinFail callback occurs if the joiningNode node was
 *  in the middle of joining when the PCM's join attempt failed.(However, the callback
 *  is not guaranteed to happen; the joiningNode may not have started the
 *  join event yet). Any failure of the joiningNode to join the cluster
 *  should be followed by a call to MMLeave() (ignoring the return code);
 *  such failures may be from the JoinFail callback or just from overall
 *  timeouts on the entire join operation. Any subsequent attempt by
 *  joiningNode to re-join the cluster must be preceeded by a call to leave().
 *
 *     MM_ALREADY   The node is already a cluster member. This can
 *                  happen if a node reboots (or a CM is restarted)
 *                  and rejoins even before the cluster determines
 *                  that it has disappeared.  The CM should Leave and
 *                  reJoin.
 *
 *     MM_FAULT     Permanent failure; something is very bad:  the
 *                  node# is duplicated; some parameter is some
 *                  entirely illegal value.  The CM is in deep weeds.
 *
 *     MM_TRANSIENT Transient failure. The cluster state changed
 *                  during the operation (eg a node left the cluster).
 *                  The operation should be retried.
 *
 *     MM_TIMEOUT   Timeout; cluster membership not achieved in time.
 *
 *
 *
 */

DWORD MmSetRegroupAllowed( IN BOOL allowed);
 /* This function can be used to allow/disallow regroup participation
  * for the current node.
  *
  * Originally regroup was allowed immediately after receiving RGP_START
  * event. Since this happens before join is complete 
  * joiner can arbitrate and win, leaving
  * the other side without a quorum device.
  *
  * It is required to add MmSetRegroupAllowed(TRUE) at the very end
  * of the ClusterJoin. The node doesn't need to call MmSetRegroupAllowed(TRUE)
  * for ClusterForm, since MMJoin will call
  * MmSetRegroupAllowed(TRUE) for the cluster forming node
  *
  * MmSetRegroupAllowed(FALSE) can be used to disable regroup
  * participation during shutdown.
  *
  *
  * Errors:
  *
  *   MM_OK        : successful completition
  *
  *   MM_TRANSIENT : disallowing regroup when regroup is in progress
  *
  *   MM_ALREADY   : node is already in the desired condition
  *
  *
  */

void MMShutdown (void);


/* This shuts down the MM and Regroup services. Prior to this, the node should
 * voluntarily have left the cluster. Following this, all membership services
 * are non-functional; no further MM call may occur.
 *
 * THIS CALL MUST BE PRECEDED BY INCOMING MESSAGE CALLBACK SHUTDOWN.
 */


DWORD  MMLeave(void);

/*
 *
 * This function causes the current node to leave the active cluster (go to
 * Down state). The node no longer sends Regroup or Heartbeats to other cluster members.
 * A NodeDown event will not be generated in this node. A Regroup is triggered in the
 * remaining nodes (if this node was a member of the cluster).
 * A node-down callback will occur on all remaining cluster members.
 *
 * This initiates a clean, voluntary, leave operation.  For safety, prior to this,
 * the calling node's CM should arrange to lose ownership of all cluster-owned
 * devices assigned to this node (and so cause failovers, etc).
 *
 * This routine returns normally. The caller (the CM) should then shutdown
 * the cluster. MMShutdown or MMHalt may occur after this call, or
 * the node may be re-joined to the cluster. All apply-to-the-PCM-to-join
 * attempts by a node must be preceded by a call to MMleave().
 *
 * This routine may block.
 *
 * Errors:
 *
 *    MM_OK        :  Elvis has left the cluster.
 *
 *    MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 */


DWORD MMEject( IN DWORD node );

/*
 *
 * This function causes the specified node to be ejected from the active cluster. The
 * targetted node will be sent a poison packet and will enter its MMHalt code. A Regroup
 * incident will be initiated. A node-down callback will occur on all remaining cluster
 * members.
 *
 *
 * Note that the targetted node is Downed before that node has
 * a chance to call any remove-ownership or voluntary failover code. As
 * such, this is very dangerous. This call is provided only as a last
 * resort in removing an insane node from the cluster; normal removal
 * of a node from the cluster should occur by CM-CM communication,
 * followed by the node itself doing a voluntary Leave on itself.
 *
 * This routine returns when the node has been told to die. Completion of the removal
 * occurs asynchronously, and a NodeDown event will be generated when successful.
 *
 * This routine may block.
 *
 * Errors:
 *
 *    MM_OK        :  The node has been told to leave the cluster.
 *
 *    MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 *        MM_TRANSIENT :  My node state is in transition. OK to retry.
 *
 */

 DWORD MMNodeUnreachable (IN DWORD node);

/* This should be called by the CM's messaging module when a node
 * becomes unreachable FROM this node via all paths. This affects the connectivity
 * algorithm of the next Regroup incident. This function returns quickly
 * and without blocking.
 *
 * Errors:
 *
 *   Always MM_OK
 *
 */

 
/* info about the cluster */

//[Fixed] : NmAdviseNodeFailure doesnt seem to cause a regroup
//SS: this is a workaround
DWORD MMForceRegroup( IN DWORD node );



DWORD MMClusterInfo (IN OUT LPCLUSTERINFO clinfo);

/* Returns the current cluster information.
 *
 * This can be called in nodes which are not members of the cluster;
 * such calls always return NumActiveNodes = 0, because Down nodes
 * have no knowledge of current cluster membership.
 *
 * If called during a Regroup incident, this returns the currently known
 * membership. If membership changes, the Up/Down events are delivered
 * after the information used by ClusterInfo is updated. Users should be aware of
 * the inherent race condition between these two, and (if using both) should be aware
 * that Up and Down events may be seen from nodes which were already In or Not In
 * the cluster. (Typically, these events should just be discarded).
 *
 * This routine need not be single-threaded and does not block.
 *
 * Errors:
 *
 *   Always MM_OK
 *
 *
 */

BOOL MMIsNodeUp(IN DWORD node);

/* Returns true iff the node is a member of the current cluster.
 */

/* debugging and test only */


DWORD MMDiag(
        IN OUT  LPCSTR  messageBuffer,  // Diagnostic message
    IN          DWORD   maximumLength,  // maximum size of buffer
        IN OUT  LPDWORD ActualLength    // length of messageBuffer going in and coming out
           );

/* This function is called with "diagnostic" messages that are to be handled by the
 * membership manager.  The result of handling these messages is returned in the
 * buffer. This is for test purposes only.
 */

DWORD MMMapStatusToDosError(IN DWORD MMStatus);
DWORD MMMapHaltCodeToDosError(IN DWORD HaltCode);

#define MM_STOP_REQUESTED 1002 // Alias of RGP_SHUTDOWN_DURING_RGP in jrgpos.h

#define MM_INVALID_NODE 0

/* !!!!!!!! The following two functions return Dos error codes, not MmStatus codes */

DWORD MMSetQuorumOwner(
    IN DWORD NodeId,
    IN BOOL Block,
    OUT PDWORD pdwSelQuoOwnerId
    );
/*++

Routine Description:

    Inform Membership engine about changes in ownership of
    the quorum resource.

Arguments:

    NodeId - Node number to be set as a quorum owner.
             Code assumes that Node is either equal to MyNodeId.
             In this case the current node is about to become a
             quorum owner or it has a value MM_INVALID_NODE, when
             the owner decides to relinquish the quorum ownership

    Block -  if the quorum owner needs to relinquish the 
             quorum immediately no matter what (RmTerminate, RmFail),
             this parameter should be set to FALSE and to TRUE otherwise.

    pdwSelQuoOwnerId - If a regroup was in progress, this contains the 
            node id of the node that was chosen for arbitrating for the
            quorum in the last regroup.  If none was chosen, this contains
            MM_INVALID_NODE.

Return Value:

    ERROR_SUCCESS - QuorumOwner variable is set to specified value
    ERROR_RETRY - Regroup was in progress when this function
      was called and regroup engine decision conflicts with current assignment.

Comments:

 This function needs to be called before calls to
 RmArbitrate, RmOnline, RmOffline, RmTerminate, RmFailResource

 Depending on the result, the caller should either proceed with 
 Arbitrate/Online or Offline or return an error if MM_TRANSIENT is returned.

 If Block is set to TRUE, the call will block until the end of the regroup if
 the regroup was in progress on the moment of the call
 */

DWORD MMGetArbitrationWinner(
    OUT PDWORD NodeId
    );
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    or MM_INVALID_NODE if there was no arbitration performed.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    ERROR_SUCCESS - success
    ERROR_RETRY - Regroup was in progress when this function
      was called. 
      
 */

VOID MMApproxArbitrationWinner(
    OUT PDWORD NodeId
    );
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    that was doing arbitration.

    The call will block if the regroup is in progress.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    none
 */

VOID MMBlockIfRegroupIsInProgress(
    VOID
    );
/*++

Routine Description:

    The call will block if the regroup is in progress.
    
Arguments:

Return Value:

    none
 */

VOID MMStartClussvcClusnetHb(
    VOID
    );
/*++

Routine Description:

    This routine would start clussvc to clusnet heartbeating.

Arguments:

Return Value:

    none
 */

VOID MMStopClussvcClusnetHb(
    VOID
    );
/*++

Routine Description:

    This routine would stop clussvc to clusnet heartbeating. This would be called by other
    components like FM when they want to stop Clussvc->Clusnet heartbeating.

Arguments:

Return Value:

    none
 */

extern BOOL                 MmStartClussvcToClusnetHeartbeat;
extern DWORD                NmClusSvcHeartbeatTimeout;

extern DWORD MmQuorumArbitrationTimeout;
extern DWORD MmQuorumArbitrationEqualizer;
/*++

    MmQuorumArbitrationTimeout (in seconds)

        How many seconds a node is allowed to spent arbitrating for the quorum,
        before giving up

    MmQuorumArbitrationEqualizer (in seconds)

        If quourum arbitration took less than specified number of seconds
        regroup engine will delay, so that the total arbitration time will 
        be equal MmQuorumArbitrationEqualizer. 
 */

#ifdef __cplusplus
}
#endif /* __cplusplus */

/* -------------------------- end ------------------------------- */
#endif /* _MMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\om.h ===
#ifndef _OM_H
#define _OM_H

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    om.h

Abstract:

    Public data structures and procedure prototypes for the
    Object Manager (Om) subcomponent of the NT Cluster Service

Author:

    Rod Gamache (rodga) 13-Mar-1996

Revision History:

--*/

//
// Common object header
//
#define OM_TRACE_REF 0



//
// Delete object callback method
//
typedef VOID (*OM_DELETE_OBJECT_METHOD)(
    IN PVOID Object
    );

typedef OM_DELETE_OBJECT_METHOD *POM_DELETE_OBJECT_METHOD;

//
// Object Types
//

typedef enum _ObjectType {
    ObjectTypeResource = 1,
    ObjectTypeResType,
    ObjectTypeGroup,
    ObjectTypeNode,
    ObjectTypeCluster,
    ObjectTypeNetwork,
    ObjectTypeNetInterface,
    ObjectTypeMax
} OBJECT_TYPE;


//
// Object Type structure
//

typedef struct _OM_OBJECT_TYPE_INITIALIZE {
    DWORD           ObjectSize;
    DWORD           Signature;
    LPCWSTR         Name;
    OM_DELETE_OBJECT_METHOD DeleteObjectMethod;
} OM_OBJECT_TYPE_INITIALIZE, *POM_OBJECT_TYPE_INITIALIZE;

typedef struct _OM_OBJECT_TYPE {
    LIST_ENTRY      ListHead;
    LIST_ENTRY      CallbackListHead;
    DWORD           Signature;
    DWORD           Type;
    LPWSTR          Name;
    DWORD           ObjectSize;
    DWORD           EnumKey;            // If we ever run out, go to DWORDLONG
    CRITICAL_SECTION CriticalSection;
    OM_DELETE_OBJECT_METHOD DeleteObjectMethod;
} OM_OBJECT_TYPE, *POM_OBJECT_TYPE;


//
// Object flags
//
#define OM_FLAG_OBJECT_INSERTED  0x00000001

//the callback registered for object notifications
typedef void (WINAPI *OM_OBJECT_NOTIFYCB)(
    IN PVOID pContext,
    IN PVOID pObject,
    IN DWORD dwNotification
    );

// the notification record stored for an object
typedef struct _OM_NOTIFY_RECORD{
    LIST_ENTRY              ListEntry;
    OM_OBJECT_NOTIFYCB      pfnObjNotifyCb;
    DWORD                   dwNotifyMask;
    PVOID                   pContext;
}OM_NOTIFY_RECORD,*POM_NOTIFY_RECORD;


//
// Object header structure
//

typedef struct _OM_HEADER {
#if OM_TRACE_REF
    LIST_ENTRY  DeadListEntry;
#endif    
    LIST_ENTRY  ListEntry;
    DWORD       Signature;
    DWORD       RefCount;
    DWORD       Flags;
    LPWSTR      Id;
    LPWSTR      Name;
    POM_OBJECT_TYPE ObjectType;
    DWORD       EnumKey;
    LIST_ENTRY  CbListHead;
    DWORDLONG   Body;   // For alignment
} OM_HEADER, *POM_HEADER;

#define OmpObjectToHeader(pObject) CONTAINING_RECORD((pObject), OM_HEADER, Body)
#define OmpReferenceHeader(pOmHeader) InterlockedIncrement(&(pOmHeader)->RefCount)


#if OM_TRACE_REF

extern DWORDLONG *OmpMatchRef;

#define OmReferenceObject(pObject)  \
{                                   \
 CsDbgPrint(LOG_NOISE,              \
            "[OM] Reference object %1!lx! (new refcnt %2!d!) from file %3!s! line %4!u!.\n", \
            pObject,                \
            ((OmpObjectToHeader(pObject))->RefCount) + 1, \
            __FILE__,               \
            __LINE__ );            \
 OmpReferenceHeader(OmpObjectToHeader(pObject));\
}

#define OmDereferenceObject(pObject)    \
{                                       \
 CsDbgPrint(LOG_NOISE,                  \
            "[OM] DeReference object %1!lx! (new refcnt %2!d!) from file %3!s! line %4!u!.\n", \
            pObject,                    \
            ((OmpObjectToHeader(pObject))->RefCount) - 1, \
            __FILE__,                   \
            __LINE__ );                \
 OmpDereferenceObject(pObject);         \
} 

//SS: Dont use this in an initialization assignment! This includes a comma, expression
#define OmReferenceObjectByName(ObjectType, Name)   \
    ((CsDbgPrint(LOG_NOISE,                         \
            "[OM] Reference object name %1!ws! from file %2!s! line %3!u!.\n", \
            Name,                                   \
            __FILE__,                               \
            __LINE__ )),                           \
    (OmpReferenceObjectByName(ObjectType, Name)))   \

//SS: Dont use this in an initialization assignment! This includes a comma, expression
#define OmReferenceObjectById(ObjectType, Id)   \
    ((CsDbgPrint(LOG_NOISE,                     \
            "[OM] Reference object Id %1!ws! from file %2!s! line %3!u!.\n", \
            Id,                                 \
            __FILE__,                           \
            __LINE__ )),                       \
    (OmpReferenceObjectById(ObjectType, Id)))   \

#else

#define OmReferenceObject(pObject) OmpReferenceHeader(OmpObjectToHeader(pObject))
#define OmDereferenceObject(pObject) OmpDereferenceObject(pObject)

//SS: Dont use these in an initialization assignment! This includes a comma, expression
// when the OM_TRACE_REF flag is on
#define OmReferenceObjectById(ObjectType, Id)    OmpReferenceObjectById(ObjectType, Id)
#define OmReferenceObjectByName(ObjectType, Name) OmpReferenceObjectByName(ObjectType, Name)

#endif

#define OmObjectSignature(pObject) (OmpObjectToHeader(pObject))->Signature


//
// Read-only access to object name, Id, and type
//
#define OmObjectId(pObject) ((LPCWSTR)(OmpObjectToHeader(pObject)->Id))
#define OmObjectName(pObject) ((LPCWSTR)(OmpObjectToHeader(pObject)->Name))
#define OmObjectType(pObject) (OmpObjectToHeader(pObject)->ObjectType->Type)

#define OmObjectInserted(pObject) ((BOOL)(OmpObjectToHeader(pObject)->Flags & OM_FLAG_OBJECT_INSERTED))


//
// Enumeration callback routine definitions
//
typedef BOOL (*OM_ENUM_OBJECT_ROUTINE)(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


//
// Global Functions
//


//
// Startup and shutdown
//

DWORD
WINAPI
OmInitialize(
    VOID
    );

VOID
OmShutdown(
    VOID
    );

//
// Object types
//

DWORD
WINAPI
OmCreateType(
    IN OBJECT_TYPE ObjectType,
    IN POM_OBJECT_TYPE_INITIALIZE ObjectTypeInitialize
    );

//
// Objects management
//

PVOID
WINAPI
OmCreateObject(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR ObjectId,
    IN LPCWSTR ObjectName OPTIONAL,
    OUT PBOOL  Created OPTIONAL
    );


DWORD
WINAPI
OmInsertObject(
    IN PVOID Object
    );

DWORD
WINAPI
OmRemoveObject(
    IN PVOID Object
    );

PVOID
WINAPI
OmpReferenceObjectById(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Id
    );

PVOID
WINAPI
OmpReferenceObjectByName(
    IN OBJECT_TYPE ObjectType,
    IN LPCWSTR Name
    );


DWORD
WINAPI
OmCountObjects(
    IN OBJECT_TYPE ObjectType,
    OUT LPDWORD NumberOfObjects
    );

DWORD
WINAPI
OmEnumObjects(
    IN OBJECT_TYPE ObjectType,
    IN OM_ENUM_OBJECT_ROUTINE EnumerationRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    );

VOID
OmpDereferenceObject(
    IN PVOID Object
    );

DWORD
WINAPI
OmSetObjectName(
    IN PVOID Object,
    IN LPCWSTR ObjectName
    );


DWORD
WINAPI
OmRegisterNotify(
    IN PVOID                            pObject,
    IN PVOID                            pContext,
    IN DWORD                            dwNotifyMask,
    IN OM_OBJECT_NOTIFYCB       pfnObjNotifyCb
    );


DWORD
WINAPI
OmDeregisterNotify(
    IN PVOID                            pObject,
    IN OM_OBJECT_NOTIFYCB       lpfnObjNotifyCb
    );

DWORD
WINAPI
OmRegisterTypeNotify(
    IN OBJECT_TYPE ObjectType,
    IN PVOID Context,
    IN DWORD NotifyMask,
    IN OM_OBJECT_NOTIFYCB lpfnObjNotifyCb
    );

DWORD
WINAPI
OmNotifyCb(
    IN PVOID pObject,
    IN DWORD dwNotification
    );


#endif //ifndef _OM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\qfs.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    Qfs.h

Abstract:

    Redirection layer for quorum access

Author:

    GorN 19-Sep-2001

Revision History:

--*/

#ifndef _QFS_H_INCLUDED
#define _QFS_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

VOID QfsInitialize();
VOID QfsCleanup();

// By defining a handle this way
// we allow compiler to catch the places where
// QfsHANDLE is used mistakenly in Win32 api requiring 
// a regular handle and vice versa
typedef struct _QfsHANDLE
{
    PVOID realHandle;
    int IsQfs;
} QfsHANDLE, *PQfsHANDLE;

#define REAL_INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)

#define QfspHandle(x) ((x).realHandle)
#define QfsIsHandleValid(x) (QfspHandle(x) != REAL_INVALID_HANDLE_VALUE)
extern QfsHANDLE QfsINVALID_HANDLE_VALUE; 

#if !defined(QFS_DO_NOT_UNMAP_WIN32)
#undef INVALID_HANDLE_VALUE

#undef CreateFile
#define CreateFile UseQfsCreateFile
#define CreateFileW UseQfsCreateFile

#define WriteFile UseQfsWriteFile
#define ReadFile UseQfsReadFile
#define FlushFileBuffers UseQfsFlushFileBuffers

#undef DeleteFile
#define DeleteFile    UseQfsDeleteFile
#define DeleteFileW UseQfsDeleteFile

#undef RemoveDirectory
#define RemoveDirectory UseQfsRemoveDirectory
#define RemoveDirectoryW UseQfsRemoveDirectory

// NYI add the rest

#endif


QfsHANDLE QfsCreateFile(
  LPCWSTR lpFileName,                         // file name
  DWORD dwDesiredAccess,                      // access mode
  DWORD dwShareMode,                          // share mode
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition,                // how to create
  DWORD dwFlagsAndAttributes,                 // file attributes
  HANDLE hTemplateFile                        // handle to template file
);

BOOL QfsCloseHandle(
  QfsHANDLE hObject   // handle to object
);

BOOL QfsWriteFile(
  QfsHANDLE hFile,                    // handle to file
  LPCVOID lpBuffer,                // data buffer
  DWORD nNumberOfBytesToWrite,     // number of bytes to write
  LPDWORD lpNumberOfBytesWritten,  // number of bytes written
  LPOVERLAPPED lpOverlapped        // overlapped buffer
);

BOOL QfsReadFile(
  QfsHANDLE hFile,                // handle to file
  LPVOID lpBuffer,             // data buffer
  DWORD nNumberOfBytesToRead,  // number of bytes to read
  LPDWORD lpNumberOfBytesRead, // number of bytes read
  LPOVERLAPPED lpOverlapped    // overlapped buffer
);

BOOL QfsFlushFileBuffers(
  QfsHANDLE hFile  // handle to file
);

BOOL QfsDeleteFile(
LPCTSTR lpFileName ); 

BOOL QfsRemoveDirectory(
LPCTSTR lpFileName ); 

QfsHANDLE QfsFindFirstFile(
  LPCTSTR lpFileName,               // file name
  LPWIN32_FIND_DATA lpFindFileData  // data buffer
);

BOOL QfsFindNextFile(
  QfsHANDLE hFindFile,                // search handle 
  LPWIN32_FIND_DATA lpFindFileData // data buffer
);

BOOL QfsFindClose(
  QfsHANDLE hFindFile   // file search handle
);

#define QfsFindCloseIfValid(hFile) (QfsIsHandleValid(hFile)?QfsFindClose(hFile):0)
#define QfsCloseHandleIfValid(hFile) (QfsIsHandleValid(hFile)?QfsCloseHandle(hFile):0)

DWORD QfsSetEndOfFile(
    QfsHANDLE hFile,
    LONGLONG Offset
);

DWORD QfsGetFileSize(
  QfsHANDLE hFile,           // handle to file
  LPDWORD lpFileSizeHigh  // high-order word of file size
);

DWORD QfsIsOnline(
    IN    LPCWSTR Path,
    OUT BOOL *pfOnline
);
// Returns success if the Path is valid qfs path. Sets pfOnline to where the resource is online or not
// failure otherwise

HANDLE QfsCreateFileMapping(
  QfsHANDLE hFile,                       // handle to file
  LPSECURITY_ATTRIBUTES lpAttributes, // security
  DWORD flProtect,                    // protection
  DWORD dwMaximumSizeHigh,            // high-order DWORD of size
  DWORD dwMaximumSizeLow,             // low-order DWORD of size
  LPCTSTR lpName                      // object name
);

BOOL QfsGetOverlappedResult(
  QfsHANDLE hFile,                       // handle to file, pipe, or device
  LPOVERLAPPED lpOverlapped,          // overlapped structure
  LPDWORD lpNumberOfBytesTransferred, // bytes transferred
  BOOL bWait                          // wait option
);

BOOL QfsSetFileAttributes(
  LPCWSTR lpFileName,      // file name
  DWORD dwFileAttributes   // attributes
);

BOOL QfsCopyFile(
  LPCWSTR lpExistingFileName, // name of an existing file
  LPCWSTR lpNewFileName,      // name of new file
  BOOL bFailIfExists          // operation if file exists
);

BOOL QfsCopyFileEx(
  LPCWSTR lpExistingFileName,           // name of existing file
  LPCWSTR lpNewFileName,                // name of new file
  LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
  LPVOID lpData,                        // callback parameter
  LPBOOL pbCancel,                      // cancel status
  DWORD dwCopyFlags                     // copy options
);

BOOL QfsCreateDirectory(
  LPCWSTR lpPathName,                         // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
);

BOOL QfsGetDiskFreeSpaceEx(
  LPCTSTR lpDirectoryName,                 // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

BOOL QfsMoveFileEx(
  LPCTSTR lpExistingFileName,  // file name
  LPCTSTR lpNewFileName,       // new file name
  DWORD dwFlags                // move options
);

#define QfsMoveFile(lpSrc, lpDst) \
    QfsMoveFileEx(lpSrc, lpDst, MOVEFILE_COPY_ALLOWED)

UINT QfsGetTempFileName(
  LPCTSTR lpPathName,      // directory name
  LPCTSTR lpPrefixString,  // file name prefix
  UINT uUnique,            // integer
  LPTSTR lpTempFileName    // file name buffer
);

LONG QfsRegSaveKey(
  HKEY hKey,                                  // handle to key
  LPCWSTR lpFile,                             // data file
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
);

DWORD QfsMapFileAndCheckSum(
  LPCWSTR Filename,      
  PDWORD HeaderSum,  
  PDWORD CheckSum    
);

////////////// Clusrtl funcs replacement  ////////////////
BOOL
QfsClRtlCopyFileAndFlushBuffers(
    IN LPCWSTR lpszSourceFile,
    IN LPCWSTR lpszDestinationFile
    );

BOOL QfsClRtlCreateDirectory(
  LPCWSTR lpPathName                         // directory name
);

DWORD
QfsSetFileSecurityInfo(
    IN LPCWSTR          lpszFile,
    IN DWORD            dwAdminMask,
    IN DWORD            dwOwnerMask,
    IN DWORD            dwEveryoneMask
    );
// opens the specified file/directory with
//         GENERIC_READ|WRITE_DAC|READ_CONTROL,
//        0,
//        NULL,
//        OPEN_ALWAYS,
//        FILE_FLAG_BACKUP_SEMANTICS,
// and then calls ClRtlSetObjSecurityInfo on it


////////////////////////////////////////////

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\service.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.h

Abstract:

    Common top-level definitions for Cluster Service.

Author:

    Mike Massa (mikemas) 2-Jan-1996

Revision History:

--*/

#ifndef _SERVICE_INCLUDED
#define _SERVICE_INCLUDED

#define UNICODE 1
//#define CLUSTER_TESTPOINT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <cluster.h>
#include <resapi.h>
#include <stdlib.h>
#include <wchar.h>
#include <tstpoint.h>
#include <clusverp.h>

#include "qfs.h"

//
// RPC protocols and endpoints used by the various RPC servers and clients
//
#define CLUSTER_RPC_PROTSEQ     L"ncadg_cluster"
#define CLUSTER_RPC_PORT        L"2"

#define CLUSTER_INTRACLUSTER_RPC_COM_TIMEOUT    RPC_C_BINDING_DEFAULT_TIMEOUT
#define CLUSTER_EXTROCLUSTER_RPC_COM_TIMEOUT    RPC_C_BINDING_DEFAULT_TIMEOUT
#define CLUSTER_JOINVERSION_RPC_COM_TIMEOUT     RPC_C_BINDING_DEFAULT_TIMEOUT

//
// Component header files
//
#include "clusrpc.h"
#include "ep.h"
#include "init.h"
#include "nm.h"
#include "config.h"
#include "om.h"
#include "gum.h"
#include "dm.h"
#include "fm.h"
#include "cp.h"
#include "api.h"
#include "logman.h"
#include "mmapi.h"
#include "clmsg.h"
#include "cnetapi.h"
#include "evtlog.h"

//
// Service Message IDs
//
#include "clusvmsg.h"

//
// Global Data
//
extern SERVICE_STATUS       CsServiceStatus;
extern PCLRTL_WORK_QUEUE    CsDelayedWorkQueue;
extern PCLRTL_WORK_QUEUE    CsCriticalWorkQueue;
extern LPWSTR               CsClusterName;
extern RPC_BINDING_VECTOR * CsRpcBindingVector;
extern RPC_BINDING_HANDLE   CsJoinSponsorBinding;
extern DWORD                CsClusterHighestVersion;
extern DWORD                CsClusterLowestVersion;
extern DWORD                CsClusterNodeLimit;
extern DWORD                CsMyHighestVersion;
extern DWORD                CsMyLowestVersion;
extern SUITE_TYPE           CsMyProductSuite;
extern LPWSTR               CsServiceDomainAccount;
extern DWORD                CsRPCSecurityPackage[];
extern LPWSTR               CsRPCSecurityPackageName[];
extern LONG                 CsRPCSecurityPackageIndex;
extern DWORD                CsNumberOfRPCSecurityPackages;


//
// Macros
//

#if NO_SHARED_LOCKS
//assume the lock is a critical section
#define INITIALIZE_LOCK(ResLock)         \
        InitializeCriticalSection(&(ResLock))

#define ACQUIRE_EXCLUSIVE_LOCK(ResLock)     \
        EnterCriticalSection(&(ResLock))

#define ACQUIRE_SHARED_LOCK(ResLock)          \
        EnterCriticalSection(&(ResLock))

#define RELEASE_LOCK(ResLock)                \
        LeaveCriticalSection(&(ResLock))

#define DELETE_LOCK(ResLock)                \
        DeleteCriticalSection(&(ResLock))

#else  // NO_SHARED_LOCKS
//assume the lock is a rtl resource

#define INITIALIZE_LOCK(ResLock)         \
        RtlInitializeResource(&(ResLock))

#define ACQUIRE_EXCLUSIVE_LOCK(ResLock)     \
        RtlAcquireResourceExclusive(&(ResLock), TRUE)

#define ACQUIRE_SHARED_LOCK(ResLock)          \
        RtlAcquireResourceShared(&(ResLock), TRUE)

#define RELEASE_LOCK(ResLock)                \
        RtlReleaseResource(&(ResLock))

#define DELETE_LOCK(ResLock)                \
        RtlDeleteResource(&(ResLock))

#endif // NO_SHARED_LOCKS
//
// Cluster initialization
//

//
// Service Control Routines
//
VOID
CsAnnounceServiceStatus(
    VOID
    );

VOID
CsRunService(
    VOID
    );

VOID
CsStopService(
    VOID
    );

DWORD
ClusterRegisterIntraclusterRpcInterface(
    VOID
    );

VOID
CsInconsistencyHalt(
    IN DWORD Status
    );


VOID CsGetClusterVersionInfo(
    IN PCLUSTERVERSIONINFO pClusterVersionInfo
    );

DWORD
WINAPI
CsClusterControl(
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

VOID
CsRefreshGlobalsFromRegistry(
    VOID
    );

//
// Debugging
//
#if DBG

//
// Global Debug Flags
//
extern ULONG CsDebugFlags;

#define IF_DEBUG(arg)   if ( CS_DBG_## arg & CsDebugFlags)

#define CS_DBG_ALL           0xFFFFFFFF

#define CS_DBG_ERROR         0x00000001
#define CS_DBG_INIT          0x00000002
#define CS_DBG_CLEANUP       0x00000004

#else // DBG

#define IF_DEBUG(arg)  if (FALSE )

#endif // DBG

//
// Helpful macros for logging cluster service events
//

#define CsLogEvent(_level_, _msgid_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL)

#define CsLogEvent1(_level_, _msgid_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_))

#define CsLogEvent2(_level_, _msgid_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_))

#define CsLogEvent3(_level_, _msgid_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                0,                                  \
                NULL,                               \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

#define CsLogEventData(_level_, _msgid_, _dwBytes_, _pData_)                \
    ClusterLogEvent0(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_))

#define CsLogEventData1(_level_, _msgid_, _dwBytes_, _pData_, _arg1_)       \
    ClusterLogEvent1(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_))

#define CsLogEventData2(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_)       \
    ClusterLogEvent2(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_))

#define CsLogEventData3(_level_, _msgid_, _dwBytes_, _pData_, _arg1_, _arg2_, _arg3_)       \
    ClusterLogEvent3(_level_,                       \
                LOG_CURRENT_MODULE,                 \
                __FILE__,                           \
                __LINE__,                           \
                (_msgid_),                          \
                (_dwBytes_),                        \
                (_pData_),                          \
                (_arg1_),                           \
                (_arg2_),                           \
                (_arg3_))

extern BOOL   CsDebugResmon;
extern LPWSTR CsResmonDebugCmd;
extern BOOL   CsNoVersionCheck;
extern BOOL   CsUpgrade;
extern BOOL   CsFirstRun;
extern BOOL   CsNoQuorumLogging;
extern BOOL   CsUserTurnedOffQuorumLogging;
extern BOOL   CsNoQuorum;
extern BOOL   CsResetQuorumLog;
extern BOOL   CsForceQuorum;
extern LPWSTR CsForceQuorumNodes;
extern BOOL   CsCommandLineForceQuorum;
extern BOOL   CsNoRepEvtLogging;
extern BOOL   CsDatabaseRestore;
extern LPWSTR CsDatabaseRestorePath;
extern BOOL   CsForceDatabaseRestore;
extern LPWSTR CsQuorumDriveLetter;
extern BOOL   CsRunningAsService;
extern BOOL   CsNoGroupInfoEvtLogging;


#ifdef CLUSTER_TESTPOINT
//
// Test Points
//
// Codes:
//     Init   1-99
//     NM     100-199
//

extern DWORD CsTestPoint;
extern DWORD CsTestTrigger;
extern DWORD CsTestAction;
extern BOOL  CsPersistentTestPoint;

#define TESTPTMSG  \
            CsDbgPrint(LOG_NOISE, ("Hit test point %1!u!\n", CsTestPoint));

#define TESTPTCLEAR   if (!CsPersistentTestPoint) (CsTestPoint = 0)

#endif // CLUSTER_TESTPOINT

#endif // SERVICE_INCLUDED




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\nm.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nm.h

Abstract:

    Public interface definitions for the Node Manager component.

Author:

    Mike Massa (mikemas) 12-Mar-1996


Revision History:

--*/


#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <wincrypt.h>

#ifndef _NM_INCLUDED
#define _NM_INCLUDED


//
// Types
//

typedef struct _NM_NODE *PNM_NODE;
typedef struct _NM_NETWORK *PNM_NETWORK;
typedef struct _NM_INTERFACE *PNM_INTERFACE;


//the callback registered for object notifications
typedef DWORD (WINAPI *NM_FIXUP_NOTIFYCB)(
    IN DWORD    dwFixupType,
    OUT PVOID   *ppPropertyList,
    OUT LPDWORD pdwPropertyListSize,
    OUT LPWSTR  * szKeyName
    );


//
// Data
//
#define NM_DEFAULT_NODE_LIMIT 2   // This is the default if
                                  // MaxNodesInCluster is not set



#define NM_FORM_FIXUP       1
#define NM_JOIN_FIXUP       2

extern ULONG                NmMaxNodes;
extern CL_NODE_ID           NmMaxNodeId;
extern CL_NODE_ID           NmLocalNodeId;
extern PNM_NODE             NmLocalNode;
extern WCHAR                NmLocalNodeName[];
extern WCHAR                NmLocalNodeIdString[];
extern HANDLE               NmClusnetHandle;
extern BOOL                 NmLocalNodeVersionChanged;
extern RESUTIL_PROPERTY_ITEM NmJoinFixupSDProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupWINSProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupDHCPProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupSMTPProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupNNTPProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupIISProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupNewMSMQProperties[];
extern RESUTIL_PROPERTY_ITEM NmJoinFixupMSDTCProperties[];
extern RESUTIL_PROPERTY_ITEM NmFixupVersionInfo[];
extern RESUTIL_PROPERTY_ITEM NmFixupClusterProperties[];
extern HCRYPTPROV            NmCryptServiceProvider;


//
// Macros
//
#define NmIsValidNodeId(_id)    ( ((_id) >= ClusterMinNodeId) && \
                                  ((_id) <= NmMaxNodeId) )


//
// Init/Shutdown Routines
//
DWORD
NmInitialize(
    VOID
    );

VOID
NmShutdown(
    VOID
    );

DWORD
NmFormNewCluster(
    VOID
    );

DWORD
NmJoinCluster(
    IN RPC_BINDING_HANDLE  SponsorBinding
    );

DWORD
NmJoinComplete(
    OUT DWORD *EndSeq
    );

VOID
NmLeaveCluster(
    VOID
    );

DWORD
NmCreateNodeBindings(
    IN LPCWSTR lpszNodeId,
    IN LPCWSTR SponsorNetworkId
    );

BOOL
NmCreateActiveNodeBindingsCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

DWORD
NmJoinNodeToCluster(
    CL_NODE_ID  JoiningNodeId
    );

VOID
NmTimerTick(
    IN DWORD  MsTickInterval
    );

DWORD
NmGetJoinSequence(
    VOID
    );


DWORD NmGetClusterOperationalVersion(
    OUT LPDWORD pdwClusterHighestVersion,
    OUT LPDWORD pdwClusterLowestVersion,
    OUT LPDWORD pdwFlags
    );

//
// Node Object Management Routines
//
PNM_NODE
NmReferenceNodeById(
    IN DWORD NodeId
    );

CLUSTER_NODE_STATE
NmGetNodeState(
    IN PNM_NODE Node
    );

DWORD
NmPauseNode(
    IN PNM_NODE Node
    );

DWORD
NmResumeNode(
    IN PNM_NODE Node
    );

DWORD
NmEvictNode(
    IN PNM_NODE Node
    );

VOID
NmAdviseNodeFailure(
    IN DWORD NodeId,
    IN DWORD ErrorCode
    );

DWORD
NmEnumNodeInterfaces(
    IN  PNM_NODE          Node,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    );

DWORD
NmGetNodeId(
    IN PNM_NODE Node
    );

HANDLE
NmGetNodeStateDownEvent(
    IN PNM_NODE Node
    );

DWORD
NmGetCurrentNumberOfNodes(
    void
    );

DWORD
NmGetMaxNodeId(
);

PNM_NODE
NmReferenceJoinerNode(
    IN DWORD       JoinerSequence,
    IN CL_NODE_ID  NodeId
    );

VOID
NmDereferenceJoinerNode(
    PNM_NODE  JoinerNode
    );

DWORD
WINAPI
NmNodeControl(
    IN PNM_NODE Node,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Network Object Management Routines
//
CLUSTER_NETWORK_STATE
NmGetNetworkState(
    IN  PNM_NETWORK  Network
    );

DWORD
NmSetNetworkName(
    IN PNM_NETWORK   Network,
    IN LPCWSTR       Name
    );

DWORD
NmSetNetworkPriorityOrder(
    IN DWORD     NetworkCount,
    IN LPWSTR *  NetworkIdList
    );

DWORD
NmEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    );

DWORD
NmEnumNetworkInterfaces(
    IN  PNM_NETWORK       Network,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    );

DWORD
WINAPI
NmNetworkControl(
    IN PNM_NETWORK Network,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

//
// Interface Object Management Routines
//
CLUSTER_NETINTERFACE_STATE
NmGetInterfaceState(
    IN  PNM_INTERFACE  Interface
    );

DWORD
NmGetInterfaceForNodeAndNetwork(
    IN     LPCWSTR    NodeName,
    IN     LPCWSTR    NetworkName,
    OUT    LPWSTR *   InterfaceName
    );

DWORD
WINAPI
NmInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD NmPerformFixups(
    IN DWORD dwFixupType
    );

DWORD
    NmFixupNotifyCb(VOID);

//
// PnP Routines
//
VOID
NmPostPnpEvent(
    IN  CLUSNET_EVENT_TYPE   EventType,
    IN  DWORD                Context1,
    IN  DWORD                Context2
    );

//
// Connectoid related routines
//
VOID
NmCloseConnectoidAdviseSink(
    VOID
    );

DWORD
NmGetNodeHighestVersion(
    IN PNM_NODE Node
    );

DWORD
NmSetExtendedNodeState(
    IN CLUSTER_NODE_STATE State
    );

CLUSTER_NODE_STATE
NmGetExtendedNodeState(
    IN PNM_NODE Node
    );

//
// Intracluster RPC Monitoring and cancellation routines
//

VOID NmStartRpc(
    IN DWORD NodeId
    );

VOID NmEndRpc(
    IN DWORD NodeId
    );

// RPC ext error info dumping routine

VOID NmDumpRpcExtErrorInfo(
    RPC_STATUS status
    );

DWORD
NmSetServiceAccountPassword(
    IN LPCWSTR DomainName,
    IN LPCWSTR AccountName,
    IN LPWSTR NewPassword,
    IN DWORD dwFlags,
    OUT PCLUSTER_SET_PASSWORD_STATUS ReturnStatusBuffer,
    IN DWORD ReturnStatusBufferSize,
    OUT DWORD *SizeReturned,
    OUT DWORD *ExpectedBufferSize
    );

// Encryption/Decription helpers 
//   Used by dm file pipes to encrypt/decrypt
//   transmission of cryptocheckpoints

typedef struct _NM_CRYTOR {
    BYTE*   PayloadBuffer;
    DWORD PayloadSize;
    BYTE*   EncryptedBuffer;
    DWORD EncryptedSize;

    ULONG_PTR CryptProv;
    ULONG_PTR  CryptKey;
    BOOL       KeyGenerated;
    BOOL       EncryptionDisabled;
} NM_CRYPTOR, *PNM_CRYPTOR;


DWORD 
NmCryptor_Decrypt(
    PNM_CRYPTOR Encryptor, 
    PVOID Buffer, 
    DWORD BufferSize);

VOID
NmCryptor_PrepareEncryptionBuffer(
    PNM_CRYPTOR Encryptor, 
    PVOID Buffer, 
    DWORD BufferSize);

DWORD
NmCryptor_Encrypt(
    PNM_CRYPTOR Encryptor, 
    DWORD DataSize);

VOID
NmCryptor_Init(
    PNM_CRYPTOR Cryptor,
    BOOL EnableEncryption);

VOID
NmCryptor_Destroy(
    PNM_CRYPTOR Encryptor);

// Clussvc to Clusnet Heartbeating.
DWORD 
NmInitializeClussvcClusnetHb(
    VOID
    );

#endif  // _NM_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\inc\tstpoint.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tstpoint.h

Abstract:

    Public interfaces for creating and manipulating cluster test points

Author:

    John Vert (jvert) 11/25/1996

Revision History:

--*/

#ifdef CLUSTER_TESTPOINT

typedef enum _TESTPOINT_TRIGGER {
    TestTriggerNever=0,
    TestTriggerAlways=1,
    TestTriggerOnce=2,
    TestTriggerTargetCount=3
} TESTPOINT_TRIGGER;

typedef enum _TESTPOINT_ACTION {
    TestActionTrue=0,
    TestActionExit=1,
    TestActionDebugBreak=2
} TESTPOINT_ACTION;

typedef WCHAR TESTPOINT_NAME[64];

typedef struct _TESTPOINT_ENTRY {
    TESTPOINT_NAME    TestPointName;
    TESTPOINT_TRIGGER Trigger;
    TESTPOINT_ACTION Action;
    DWORD HitCount;
    DWORD TargetCount;
} TESTPOINT_ENTRY, *PTESTPOINT_ENTRY;

//SS: when you add a testpoint, add the corresponding name in init\tstpoint.c
typedef enum _TESTPOINT {
    TestpointJoinFailPetition=0,
    TpFailNmJoinCluster=1,
    TpFailRegisterIntraClusterRpc=2,
    TpFailJoinCreateBindings=3,
    TpFailJoinPetitionForMembership=4,
    TpFailNmJoin=5,
    TpFailDmJoin=6,
    TpFailApiInitPhase1=7,
    TpFailFmJoinPhase1=8,
    TpFailDmUpdateJoinCluster=9,
    TpFailEvInitialize=10,
    TpFailNmJoinComplete=11,
    TpFailApiInitPhase2=12,
    TpFailFmJoinPhase2=13,
    TpFailLogCommitSize=14,
    TpFailClusterShutdown=15,
    TpFailLocalXsaction=16,
    TpFailOnlineResource=17,
    TpFailSecurityInit=18,
    TpFailOmInit=19,
    TpFailEpInit=20,
    TpFailDmInit=21,
    TpFailNmInit=22,
    TpFailGumInit=23,
    TpFailFmInit=24,
    TpFailLmInit=25,
    TpFailCpInit=26,
    TpFailNmPauseNode=27,
    TpFailNmResumeNode=28,
    TpFailNmEvictNodeAbort=29,
    TpFailNmEvictNodeHalt=30,
    TpFailNmCreateNetwork=31,
    TpFailNmSetNetworkPriorityOrder=32,
    TpFailNmSetNetworkPriorityOrder2=33,
    TpFailNmSetNetworkCommonProperties = 34,
    TpFailNmSetInterfaceInfoAbort=35,
    TpFailNmSetInterfaceInfoHalt=36,
    TpFailPreMoveWithNodeDown=37,
    TpFailPostMoveWithNodeDown=38,
    TpFailFormNewCluster=39,
    TestpointMax=40
} TESTPOINT;



#define TESTPT(x) if (TestpointCheck(x))

VOID
TestpointInit(
    VOID
    );

VOID
TestpointDeInit(
    VOID
    );

BOOL
TestpointCheck(
    IN TESTPOINT Testpoint
    );

#else // CLUSTER_TESTPOINT

#define TestpointInit()
#define TestpointDeInit()

#define TESTPT(x) if (0)

#endif // CLUSTER_TESTPOINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\init.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module provides the main cluster initialization.

Author:

    John Vert (jvert) 6/5/1996

Revision History:

--*/
extern "C"
{
#include "initp.h"
#include <objbase.h>

RPC_STATUS ApipConnectCallback(
    IN RPC_IF_ID * Interface,
    IN void * Context
    );

}

#define CLUSTER_PRIORITY_CLASS HIGH_PRIORITY_CLASS

#include "CVssCluster.h"

//
// Global Data
//
RPC_BINDING_VECTOR *CsRpcBindingVector = NULL;
LPTOP_LEVEL_EXCEPTION_FILTER lpfnOriginalExceptionFilter = NULL;
BOOLEAN bFormCluster = TRUE;

//
// LocalData
//
BOOLEAN CspIntraclusterRpcServerStarted = FALSE;
HANDLE  CspMutex = NULL;
PCLRTL_WORK_QUEUE CspEventReportingWorkQueue = NULL;


//
// Prototypes
//
LONG
CspExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionInfo
    );


//
// Routines.
//

VOID CspLogStartEvent(
    IN BOOL bJoin)
{
    LPWSTR  pszClusterName = NULL;
    LPWSTR  pszName = NULL;
    DWORD   dwClusterNameSize;
    DWORD   dwSize;
    DWORD   dwStatus;
    WCHAR   szUnknownClusterName[]=L"Unknown";

    pszClusterName = NULL;
    dwClusterNameSize = 0;
    dwStatus = DmQueryString(DmClusterParametersKey,
                          CLUSREG_NAME_CLUS_NAME,
                          REG_SZ,
                          &pszClusterName,
                          &dwClusterNameSize,
                          &dwSize);

    if (dwStatus != ERROR_SUCCESS)
    {
        //we dont treat this error as fatal, since
        //the cluster did start, but we really shouldnt get this
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Couldnt get the cluster name, status=%1!u!\n",
                  dwStatus);
        pszName = szUnknownClusterName;
    }
    else
        pszName = pszClusterName;

    //log events in the cluster log to mark the start of the cluster server
    if (bJoin)
        CsLogEvent1(LOG_NOISE, SERVICE_SUCCESSFUL_JOIN, pszName);
    else
        CsLogEvent1(LOG_NOISE, SERVICE_SUCCESSFUL_FORM, pszName);

    if (pszClusterName)
        LocalFree(pszClusterName);

}

DWORD
ClusterInitialize(
    VOID
    )
/*++

Routine Description:

    This is the main cluster initialization path. It calls the
    initialization routines of all the other components. It then
    attempts to join an existing cluster. If the existing cluster
    cannot be found, it forms a new cluster.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD       Status;
    DWORD       JoinStatus;
    DWORD       StringBufferSize = 0, StringSize = 0;
    SIZE_T      minWorkingSetSize;
    SIZE_T      maxWorkingSetSize;
    BOOL        bJoin;
    BOOL        bEvicted;
    PNM_NODE_ENUM2 pNodeEnum = NULL;
    HRESULT     hr = S_OK;

    ClRtlLogPrint(LOG_NOISE, "[INIT] ClusterInitialize called to start cluster.\n");

    //
    // give us a fighting chance on loaded server
    //

#if CLUSTER_PRIORITY_CLASS
    if ( !SetPriorityClass( GetCurrentProcess(), CLUSTER_PRIORITY_CLASS ) ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[INIT] Failed to set cluster service priority class, Status %1!lx!.\n",
                   GetLastError() );
    }
#endif

    // initialize our product suite
    CsMyProductSuite = (SUITE_TYPE)ClRtlGetSuiteType();

    CL_ASSERT(CsMyProductSuite != 0);

    //
    // First check our OS to make sure it is ok to run.
    //
    if (!ClRtlIsOSValid() ||
        !ClRtlIsOSTypeValid()) {
        //
        // Bail out, machine is running something odd.
        //
        CsLogEvent(LOG_CRITICAL, SERVICE_FAILED_INVALID_OS);
        return(ERROR_REVISION_MISMATCH);
    }

    Status = ClRtlHasNodeBeenEvicted( &bEvicted );
    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[CS] Unable to determine if this node was previously evicted or not, status %1!u!\n",
            Status);
        return Status;
    }

    if ( bEvicted != FALSE )
    {
        // This node has been evicted previously, but cleanup could not complete.
        ClRtlLogPrint(LOG_UNUSUAL,
            "[CS] This node has been evicted from the cluster, but cleanup was not completed. Restarting cleanup\n"
            );

        // Reinitiate cleanup
        hr = ClRtlCleanupNode(
                NULL,                   // Name of the node to be cleaned up (NULL means this node)
                60000,                  // Amount of time (in milliseconds) to wait before starting cleanup
                0                       // timeout interval in milliseconds
                );

        if ( FAILED( hr ) && ( hr != RPC_S_CALLPENDING ) )
        {
            Status = HRESULT_CODE( hr );
            ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Unable to reinitiate cleanup, status 0x%1!x!\n",
                hr);
        }
        else
        {
            Status = ERROR_SUCCESS;
        }

        return Status;
    }

    //
    // Acquire our named mutex in order to prevent multiple copies
    // of the cluster service from accidentally getting started.
    //
    CspMutex = CreateMutexW(
                   NULL,
                   FALSE,
                   L"ClusterServer_Running"
                   );

    if (CspMutex==NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[CS] Unable to create cluster mutex, status %1!u!\n",
            Status);
        return Status;
    }

    if (WaitForSingleObject(CspMutex, 30000) == WAIT_TIMEOUT) {
        //
        // Somebody already has this mutex, exit immediately.
        //
        ClRtlLogPrint(LOG_CRITICAL,
            "[CS] The Cluster Service is already running.\n");
        return(ERROR_SERVICE_ALREADY_RUNNING);
    }

    //
    // Set our unhandled exception filter so that if anything horrible
    // goes wrong, we can exit immediately.
    //
    lpfnOriginalExceptionFilter = SetUnhandledExceptionFilter(CspExceptionFilter);

    //
    // Next initialize the testpoint code
    //
    TestpointInit();

    g_pCVssWriterCluster = new CVssWriterCluster;
    if ( g_pCVssWriterCluster == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] VSS: Unable to allocate VssWriter, %1!u!\n", Status);
        return(Status);
    }

    //
    // Create the global work queues.
    //
    CsDelayedWorkQueue = ClRtlCreateWorkQueue(CS_MAX_DELAYED_WORK_THREADS,
                                              THREAD_PRIORITY_NORMAL);
    if (CsDelayedWorkQueue == NULL) {
        Status = GetLastError();

        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Unable to create delayed work queue, %1!u!\n",
                   Status);
        return(Status);
    }

    CsCriticalWorkQueue = ClRtlCreateWorkQueue(CS_MAX_CRITICAL_WORK_THREADS,
                                               THREAD_PRIORITY_ABOVE_NORMAL);
    if (CsCriticalWorkQueue == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Unable to create critical work queue, %1!u!\n",
                   Status);
        return(Status);
    }

#if 0
    CspEventReportingWorkQueue = ClRtlCreateWorkQueue(1, THREAD_PRIORITY_NORMAL);
    if (CspEventReportingWorkQueue == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Unable to create event reporting work queue, %1!u!\n",
                   Status);
        return(Status);
    }

    ClRtlEventLogSetWorkQueue( CspEventReportingWorkQueue );
#endif
    //
    // Init COM
    //

    Status = CoInitializeEx( NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
    if ( !SUCCEEDED( Status )) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Couldn't init COM %1!08X!\n", Status );
        return Status;
    }

    //
    // Initialize Object Manager
    //
    Status = OmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailOmInit ) {
        Status = 99999;
    }
#endif

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Event Processor
    //
    Status = EpInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailEpInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    //  Chittur Subbaraman (chitturs) - 12/4/99
    //
    //  Initialize the restore database manager. This function is a NOOP
    //  if restore database is not being done. This function MUST be called
    //  before the DM is initialized.
    //
    Status = RdbInitialize();

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Database Manager
    //
    Status = DmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailDmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Node Manager
    //
    Status = NmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailNmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Global Update Manager
    //
    Status = GumInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailGumInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize the cluster wide event logging
    //
    if (!CsNoRepEvtLogging) {
        Status = EvInitialize();
            //if this fails, we still start the cluster service
        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[INIT] Error calling EvInitialize, Status = %1!u!\n",
                Status
                );
        }
    }

    //
    // Initialize Failover Manager component
    //
    Status = FmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailFmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize API
    //
    Status = ApiInitialize();
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize Log Manager component
    //
    Status = LmInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailLmInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // Initialize the Checkpoint Manager component
    //
    Status = CpInitialize();
#ifdef CLUSTER_TESTPOINT
    TESTPT( TpFailCpInit ) {
        Status = 99999;
    }
#endif
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    //
    // find out what domain account we're running under. This is needed by
    // some packages
    //
    Status = ClRtlGetRunningAccountInfo( &CsServiceDomainAccount );
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Couldn't determine Service Domain Account. status %1!u!\n",
                                  Status);
        return Status;
    }
    ClRtlLogPrint(LOG_NOISE, "[CS] Service Domain Account = %1!ws!\n",
                           CsServiceDomainAccount);

    //
    // Prepare the RPC server. This does not enable us to receive any calls.
    //
    Status = ClusterInitializeRpcServer();

    if (Status != ERROR_SUCCESS) {
       return(Status);
    }

    //
    // Read the cluster name from the database.
    //
    Status = DmQuerySz(
                 DmClusterParametersKey,
                 CLUSREG_NAME_CLUS_NAME,
                 &CsClusterName,
                 &StringBufferSize,
                 &StringSize
                 );

    if (Status != ERROR_SUCCESS) {
       ClRtlLogPrint(LOG_UNUSUAL,
           "[CS] Unable to read cluster name from database. Service initialization failed.\n"
           );
       return(Status);
    }

    //
    // First, attempt to join the cluster.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[INIT] Attempting to join cluster %1!ws!\n",
        CsClusterName
        );

    bFormCluster = TRUE;
    JoinStatus = ClusterJoin();

    //
    // If this node was evicted when it was down, this error code is returned by the
    // sponsor when it tries to rejoin the cluster. In this case, initiate a cleanup
    // of this node and exit.
    //
    if ( (JoinStatus == ERROR_CLUSTER_NODE_NOT_MEMBER) ||
         (JoinStatus == ERROR_CLUSTER_INSTANCE_ID_MISMATCH))
    {
        DWORD   CleanupStatus;

        //SS:  If the instance mismatch occurs the first time the service runs after
        //configuration, then it implies there is some sort of confusion(duplicate ip
        //addresses or name) during the cluster configuration process, in that case,
        //we would like the setup to make the cleanup decision

        // If this is not the first run after a clean install, the service will
        // initiate cleanup itself
        if (!CsFirstRun || CsUpgrade)
        {
            WCHAR   wStatus[32];

            ClRtlLogPrint(LOG_UNUSUAL,
                "[INIT] This node has been evicted from the cluster when it was unavailable. Initiating cleanup.\n"
                );



            // Initiate cleanup of this node.
            hr = ClRtlCleanupNode(
                    NULL,                   // Name of the node to be cleaned up (NULL means this node)
                    60000,                  // Amount of time (in milliseconds) to wait before starting cleanup
                    0                       // timeout interval in milliseconds
                    );

            if ( FAILED( hr ) && ( hr != RPC_S_CALLPENDING ) )
            {
                CleanupStatus = HRESULT_CODE( hr );
                ClRtlLogPrint(LOG_CRITICAL,
                    "[INIT] Failed to initiate cleanup of this node, status 0x%1!x!\n",
                    hr
                    );
            }
            else
            {
                CleanupStatus = ERROR_SUCCESS;
            }

            wsprintfW(&(wStatus[0]), L"%u", CleanupStatus);
            CsLogEvent1(
                LOG_NOISE,
                CS_EVENT_CLEANUP_ON_EVICTION,
                wStatus
                );


        }
        return(JoinStatus);
    }

    //
    //  Chittur Subbaraman (chitturs) - 10/27/98
    //
    //  If a database restore operation is requested, check whether
    //  you succeeded in establishing a connection. If so, check
    //  whether you are forced to restore the DB. If not, abort the
    //  whole operation and return. If you are forced to restore,
    //  you will first stop the service in other nodes and then
    //  try to form a cluster.
    //
    if ( CsDatabaseRestore == TRUE ) {
        if ( JoinStatus == ERROR_CLUSTER_NODE_UP ) {
            if ( CsForceDatabaseRestore == FALSE ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[INIT] Cannot restore DB while the cluster is up, service init failed\n"
                    );
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[INIT] You may try to restart the service with the forcerestore option\n"
                    );
                RpcBindingFree(&CsJoinSponsorBinding);
                return(JoinStatus);
            }
            //
            //  At this point, a restore database operation is forced by
            //  the user. So, enumerate the cluster nodes with the help
            //  of the sponsor and then stop the services on all the
            //  cluster nodes.
            //
            Status = NmRpcEnumNodeDefinitions2(
                            CsJoinSponsorBinding,
                            0,
                            L"0",
                            &pNodeEnum
                     );
            RpcBindingFree(&CsJoinSponsorBinding);
            if ( Status != ERROR_SUCCESS ) {
               ClRtlLogPrint(LOG_UNUSUAL,
                    "[INIT] Cannot force a restore DB: Unable to enumerate cluster nodes\n"
               );
               LocalFree( pNodeEnum );
               return (Status);
            }
            //
            //  Attempt to stop the clussvc on all nodes, except of course
            //  this node
            //
            Status = RdbStopSvcOnNodes (
                        pNodeEnum,
                        L"clussvc"
                     );
            LocalFree( pNodeEnum );
            if ( Status != ERROR_SUCCESS ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[INIT] Cannot force a restore DB: Unable to stop cluster nodes\n"
                );
                return(Status);
            } else {
                CL_LOGCLUSWARNING( CS_STOPPING_SVC_ON_REMOTE_NODES );
            }
        }
    }

    if (JoinStatus != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Failed to join cluster, status %1!u!\n",
            JoinStatus
            );

        //
        // Forming a cluster will also attempt to arbitrate the quorum
        // resource.
        //
        bJoin = FALSE;

        //
        // If we failed join and found a sponsor, skip clusterform
        //
        if (bFormCluster == FALSE) {
            return (JoinStatus);
        }

        ClRtlLogPrint(LOG_NOISE,
            "[INIT] Attempting to form cluster %1!ws!\n",
            CsClusterName
            );

        Status = ClusterForm();

        if (Status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[INIT] Failed to form cluster, status %1!u!.\n",
                Status
                );

            if (Status == ERROR_BUSY) {
                //
                // Couldn't arbitrate for the quorum disk. Return
                // the join status, since that is the real failure.
                //
                Status = JoinStatus;
            }

            CsLogEventData(
                LOG_CRITICAL,
                SERVICE_FAILED_JOIN_OR_FORM,
                sizeof(Status),
                &Status
                );

            return(Status);
        }
    }
    else {
        bJoin = TRUE;
    }

    //
    // We are now a full cluster member.
    //

    //
    // Register the ExtroCluster (join) RPC interface so we can sponsor a
    // joining node.
    //
    Status = ClusterRegisterExtroclusterRpcInterface();

    if (Status != RPC_S_OK) {
        return(Status);
    }

    //
    // Register the Join Version RPC interface so we can determine
    // the version of a joining node.
    //
    Status = ClusterRegisterJoinVersionRpcInterface();

    if (Status != RPC_S_OK) {
        return(Status);
    }

    //
    // Enable this node to participate in regroups.
    //
    MmSetRegroupAllowed(TRUE);

    //
    // Now enable Clussvc to Clusnet Heartbeating.
    //
    if ((Status = NmInitializeClussvcClusnetHb()) != ERROR_SUCCESS) {
        return Status;
    }

    //
    // Advertise that the node is fully up now
    //
    Status = NmSetExtendedNodeState( ClusterNodeUp );
    if (Status != ERROR_SUCCESS) {
        // NmSetExtendedNodeState logs an error //
        return(Status);
    }

    //
    // Chittur Subbaraman (chitturs) - 10/28/99
    //
    // Process FM join events that must be done AFTER this cluster
    // node is declared as fully UP.
    //
    if ( bJoin ) {
        FmJoinPhase3();
    }

    //
    // We are now going to attempt to increase our working set size. This,
    // plus the priority class boost, should allow the cluster service
    // to run a little better and be more responsive to cluster events.
    //
    if ( GetProcessWorkingSetSize( GetCurrentProcess(),
                                   &minWorkingSetSize,
                                   &maxWorkingSetSize ) )
    {
        if ( minWorkingSetSize < MIN_WORKING_SET_SIZE ) {
            minWorkingSetSize = MIN_WORKING_SET_SIZE;
        }

        if ( maxWorkingSetSize < MAX_WORKING_SET_SIZE ) {
            maxWorkingSetSize = MAX_WORKING_SET_SIZE;
        }

        if ( SetProcessWorkingSetSize( GetCurrentProcess(),
                                       minWorkingSetSize,
                                       maxWorkingSetSize ) )
        {
            //
            // now report what we set it to
            //
            if ( GetProcessWorkingSetSize( GetCurrentProcess(),
                                           &minWorkingSetSize,
                                           &maxWorkingSetSize ) )
            {
                ClRtlLogPrint(LOG_NOISE,
                              "[INIT] Working Set changed to [%1!u!, %2!u!].\n",
                              minWorkingSetSize,
                              maxWorkingSetSize);
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[INIT] Failed to re-read our working set size, Status %1!u!.\n",
                              GetLastError());
            }
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] Failed to set our Min WS to %1!u!, Max WS to %2!u!, Status %3!u!.\n",
                          minWorkingSetSize,
                          maxWorkingSetSize,
                          GetLastError());
        }
    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[INIT] Failed to get our working set size, Status %1!u!.\n",
                    GetLastError()
                    );
    }

    CspLogStartEvent(bJoin);

#if 0
    //
    //  Chittur Subbaraman (chitturs) - 11/4/98
    //
    if ( CsForceDatabaseRestore == TRUE )
    {
        //
        //  If you stopped the service on any nodes for database restoration
        //  purposes, then start them now
        //
        RdbStartSvcOnNodes ( L"clussvc" );
    }
#endif

    hr = ClRtlInitiatePeriodicCleanupThread();
    if ( FAILED( hr ) ) {
        ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] Error 0x%1!08lx! occurred trying to initiate periodic cleanup thread. This is not fatal and will not prevent the service from starting.\n",
                          hr);
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] Cluster started.\n");

    return(ERROR_SUCCESS);

} // ClusterInitialize (aka ClusterStartup)


VOID
ClusterShutdown(
    DWORD ExitCode
    )
/*++

Routine Description:

    Shuts down the cluster in reverse order than it was brought up.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    //
    // Shutdown all components of the Cluster Service in approximately
    // the reverse order they we brought up.
    //
    ClRtlLogPrint(LOG_UNUSUAL,
               "[INIT] The cluster service is shutting down.\n");

    //
    // Enable this when we support ClusterShuttingDown state
    //
    // NmSetExtendedNodeState( ClusterNodeDown );

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailClusterShutdown) {
        return;
    }
#endif

    MmSetRegroupAllowed(FALSE);

    // if replicated event logging was initialized, shut it down
    if (!CsNoRepEvtLogging)
    {
        //
        // Shutdown the cluster eventlog manager- this deregisters with the
        // eventlog server.
        EvShutdown();
    }

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

#if 0
    //
    //  Chittur Subbaraman (chitturs) - 5/8/2000
    //
    //  Don't shutdown DM updates for now so as to avoid spurious node shoot downs due to the locker
    //  node shutting down and hence the DM update succeeding when in fact it should fail.
    //
    DmShutdownUpdates();
#endif

    //
    // Move or offline all groups owned by this node. This will destroy
    // the resource monitors and the in-memory resource and group objects.
    //
    FmShutdownGroups();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();


    // Shutdown the dm- this flushes the log file and releases the dm hooks.
    DmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    // Unsubscribe from Vss
    //
    if ( g_bCVssWriterClusterSubscribed ) {
        ClRtlLogPrint( LOG_NOISE, "[INIT] VSS: Unsubscribing\n" );
        hr = g_pCVssWriterCluster->Unsubscribe( );
        if ( FAILED( hr ) ) {
            ClRtlLogPrint( LOG_CRITICAL, "[INIT] VSS: Failed to Unsubscribe from VSS, status 0x%1!x!\n", hr );
        } else {
            g_bCVssWriterClusterSubscribed = FALSE;
        }
    }

    // Delete our Vss instance if we have one (and if we are subscribed).
    //
    if (g_pCVssWriterCluster && (g_bCVssWriterClusterSubscribed == FALSE) ) {
        delete g_pCVssWriterCluster;
    }

    TestpointDeInit();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    NmCloseConnectoidAdviseSink();

    CoUninitialize();

    //
    // Triger banishing regroup incident prompting
    // other nodes in the cluster to regroup this node out
    //
    MMLeave();

    //
    // Exit the process now... there are a number of circular dependencies
    // that have been built up during the 'life of the cluster'. There
    // is no easy way to unwind from here... so just exit out.
    //

    //
    // Announce that we are stopped only if we were successful in
    // initializing. The SC will not restart the service if we report that
    // we've stopped. Make sure the service status announcement is the last
    // thing done since there is a race between this thread and the main
    // thread that will prevent code after the announcement from being
    // executed.
    //


    ClRtlLogPrint(( ExitCode == ERROR_SUCCESS ) ? LOG_NOISE : LOG_CRITICAL,
                  "[CS] Service Stopped. exit code = %1!u!\n\n", ExitCode);

    if ( ExitCode == ERROR_SUCCESS ) {
        CsLogEvent(LOG_NOISE, SERVICE_SUCCESSFUL_TERMINATION);

        CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CsServiceStatus.dwControlsAccepted = 0;
        CsServiceStatus.dwCheckPoint = 0;
        CsServiceStatus.dwWaitHint = 0;
        CspSetErrorCode( ExitCode, &CsServiceStatus );

        CsAnnounceServiceStatus();
    } else {
        ExitCode = CspSetErrorCode( ExitCode, &CsServiceStatus );
    }

    //release the mutex so that the next one can acquire the mutex immediately
    ReleaseMutex(CspMutex);

    ExitProcess(ExitCode);

#if 0

    //
    // Everything after this point is what should happen in a clean shutdown.
    //

    // Shutdown the Failover Manager.
    FmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Shutdown the Cluster Api.
    //
    ApiShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Stop the RPC server and deregister our endpoints & interfaces.
    //
    ClusterShutdownRpcServer();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // At this point, all calls on the Intracluster and Extrocluster
    // RPC interfaces are complete and no more will be received.
    //
    // Note - Calls on the Clusapi interface are still possible.
    //

    //
    // Shutdown the Node Manager.
    //
    NmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    // Shutdown the Event Processor.
    EpShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    LmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    CpShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //shutdown gum
    GumShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    // Shutdown the Object Manager.
    OmShutdown();

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();


    //
    // Destroy the global work queues
    //
    if (CsDelayedWorkQueue != NULL) {
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,"[CS] Destroying delayed work queue...\n");
        }

        ClRtlDestroyWorkQueue(CsDelayedWorkQueue);
        CsDelayedWorkQueue = NULL;
    }

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    if (CsCriticalWorkQueue != NULL) {
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,"[CS] Destroying critical work queue...\n");
        }

        ClRtlDestroyWorkQueue(CsCriticalWorkQueue);
        CsDelayedWorkQueue = NULL;
    }

    ClRtlEventLogSetWorkQueue( NULL );
    if (CspEventReportingWorkQueue != NULL) {
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,"[CS] Destroying event reporing work queue...\n");
        }

        ClRtlDestroyWorkQueue(CspEventReportingWorkQueue);
        CspEventReportingWorkQueue = NULL;
    }
    //
    // Free global data
    //
    LocalFree(CsClusterName);

    if (CspMutex != NULL) {
        CloseHandle(CspMutex);
        CspMutex = NULL;
    }

    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    CsLogEvent(LOG_NOISE, SERVICE_SUCCESSFUL_TERMINATION);

#endif // 0

    return;
}


DWORD
ClusterForm(
    VOID
    )
/*++

Routine Description:

    Code path for initializing a new instance of the cluster. This
    is taken when there are no nodes active in the cluster.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD       Status;
    PFM_GROUP   pQuoGroup;
    DWORD       dwError;
    DWORD       dwQuorumDiskSignature = 0;

    //
    // Initialize the event handler.
    //
    Status = EpInitPhase1();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] EpInitPhase1 failed, Status = %1!u!\n",
                   Status);
        return(Status);
    }

    //
    // The API server is required by FM, since it starts the resource monitor.
    //
    Status = ApiOnlineReadOnly();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] ApiInitPhase1 failed, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    //
    // Arbitrate for the quorum resource.
    //
    Status = FmGetQuorumResource(&pQuoGroup, &dwQuorumDiskSignature);

    if ( Status != ERROR_SUCCESS ) {
        if ( ( Status == ERROR_FILE_NOT_FOUND ) &&
             ( CsForceDatabaseRestore == TRUE ) ) {
            //
            //  Chittur Subbaraman (chitturs) - 10/30/98
            //
            //  Try to fix up the quorum disk signature and if successful
            //  try to get the quorum resource again. Note that the following
            //  function will attempt a fix up only if the CsForceDatabaseRestore
            //  flag is set.
            //
            if ( RdbFixupQuorumDiskSignature( dwQuorumDiskSignature ) ) {
                Status = FmGetQuorumResource( &pQuoGroup, NULL );
                if ( Status != ERROR_SUCCESS ) {
                    Status = ERROR_QUORUM_DISK_NOT_FOUND;
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[INIT] Could not get quorum resource even after fix up, Status = %1!u!\n",
                        Status);
                    goto partial_form_exit;
                }
            } else {
                Status = ERROR_QUORUM_DISK_NOT_FOUND;
                ClRtlLogPrint(LOG_CRITICAL,
                   "[INIT] ClusterForm: Could not get quorum resource, Status = %1!u!\n",
                   Status);
                goto partial_form_exit;
            }
        } else {
            Status = ERROR_QUORUM_DISK_NOT_FOUND;
            ClRtlLogPrint(LOG_CRITICAL,
                   "[INIT] ClusterForm: Could not get quorum resource. No fixup attempted. Status = %1!u!\n",
                   Status);
            goto partial_form_exit;
        }
    }

    //arbitrate for some quorum resources(mns) takes a while and since we call
    //arbitrate from online as well, we should inform the scm that we are making
    //progresss
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Call the Database Manager to update the cluster registry.
    //
    Status = DmFormNewCluster();
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling DmUpdateFormNewCluster, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    if (FmDoesQuorumAllowLogging(CLUS_CHAR_UNKNOWN) != ERROR_SUCCESS)
        CsNoQuorumLogging = TRUE;

    if (!CsNoQuorum)
    {
        // Bring the quorum resource online
        dwError  = FmBringQuorumOnline();
        if ((dwError == ERROR_IO_PENDING) || (dwError == ERROR_SUCCESS))
        {

            //checkpoint with scm once again before waiting for log recovery
            //if log mount takes a long time then DmWaitQuorumResOnline()
            //should also increment the checkpoints
            CsServiceStatus.dwCheckPoint++;
            CsAnnounceServiceStatus();
            //this waits on an event for the quorum resorce to come online
            //when the quorum resource comes online, the log file is opened
            //if noquorumlogging flag is not specified
            if ((dwError = DmWaitQuorumResOnline()) != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[CS] Wait for quorum resource to come online failed, error=%1!u!\r\n",
                    dwError);
                Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
                goto partial_form_exit;
            }
        }
        else
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[CS] couldnt bring quorum resource online, Error =%1!u!\n",
                dwError);
            CL_LOGFAILURE(dwError);
            Status = ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
            goto partial_form_exit;

        }
    }

    //update status with scm, the quorum resource may take a while to come online
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    if (!CsNoQuorumLogging)
    {
        //roll the Cluster Log File
        if ((Status = DmRollChanges()) != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Error calling DmRollChanges, Status = %1!u!\n",
                Status);
            goto partial_form_exit;
        }
    }

    //
    // Close the groups/resources created by fm except for the quorum
    // resource. The in memory data base needs to be created again with
    // the new rolled changes
    //
    Status = FmFormNewClusterPhase1(pQuoGroup);
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling FmOnline, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailFormNewCluster) {
        Status = 999999;
        goto partial_form_exit;
    }
#endif


    //
    // Start up the Node Manager. This will form a cluster at the membership
    // level.
    //
    Status = NmFormNewCluster();
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling NmOnline, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    //
    //call any registry fixup callbacks, if they are registered.
    //This is useful for upgrades/uninstalls if you want to clean up
    //the registry
    Status = NmPerformFixups(NM_FORM_FIXUP);
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling NmPerformFixups, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    //
    // The API server can now be brought fully online. This enables us
    // to receive calls.
    //
    Status = ApiOnline();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] ApiInitPhase2 failed, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }


    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Call the Failover Manager Phase 2 routine next.
    // Create the groups and resources.
    //
    Status = FmFormNewClusterPhase2();
    if ( Status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] Error calling FmOnline, Status = %1!u!\n",
                   Status);
        goto partial_form_exit;
    }

    //
    // Fire up the intracluster RPC server so we can receive calls.
    //
    Status = ClusterRegisterIntraclusterRpcInterface();

    if ( Status != ERROR_SUCCESS ) {
        goto partial_form_exit;
    }


    //
    // Finish initializing the cluster wide event logging
    //
    // ASSUMPTION: this is called after the NM has established cluster
    // membership.
    //
    if (!CsNoRepEvtLogging)
    {
        //is replicated logging is not disabled
        Status = EvOnline();

        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CS] Error calling EvOnline, Status = %1!u!\n",
                       Status);
        }
    }
    if (!CsNoQuorumLogging)
    {
        //check if all nodes are up, if not take a checkpoint and
        //turn quorum logging on
        Status = DmUpdateFormNewCluster();
        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CS] Error calling DmCompleteFormNewCluster, Status = %1!u!\n",
                       Status);
        }
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] Successfully formed a cluster.\n");

    return(ERROR_SUCCESS);


partial_form_exit:

    ClRtlLogPrint(LOG_NOISE, "[INIT] Cleaning up failed form attempt.\n");

    return(Status);
}



VOID
ClusterLeave(
    VOID
    )
/*++

Routine Description:

    Removes the local node from an active cluster or cleans up after
    a failed attempt to join or form a cluster.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    ClRtlLogPrint(LOG_NOISE, "[INIT] Leaving cluster\n");

    //
    // Turn off the cluster API
    //
    ApiOffline();

    //
    // If we are a cluster member, leave now.
    //
    NmLeaveCluster();

    ClusterDeregisterRpcInterfaces();

    return;

}  // Cluster Leave


//
// RPC Server Control routines
//

RPC_STATUS
ClusterInitializeRpcServer(
    VOID
    )
/*++

Routine Description:

    Initializes the RPC server for the cluster service.

Arguments:

    None.

Return Value:

    RPC_S_OK if the routine succeeds. An RPC error code if it fails.

--*/
{
    RPC_STATUS          Status;
    DWORD               i;
    DWORD               retry;
    DWORD               packagesRegistered = 0;

    ClRtlLogPrint(LOG_NOISE, "[CS] Initializing RPC server.\n");

    //
    // Enable authentication of calls to our RPC interfaces. For NTLM,
    // the PrincipleName is ignored, but we'll need to supply one if we
    // switch authentication services later on. Note that it is not
    // necessary to specify an authentication service for each interface.
    //

    for ( i = 0; i < CsNumberOfRPCSecurityPackages; ++i ) {

        Status = RpcServerRegisterAuthInfo(NULL,
                                           CsRPCSecurityPackage[ i ],
                                           NULL,
                                           NULL);

        if (Status == RPC_S_OK) {
            ++packagesRegistered;
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[CS] Unable to register %1!ws! authentication for RPC, status %2!u!.\n",
                        CsRPCSecurityPackageName[ i ],
                        Status);
        }
    }

    if ( packagesRegistered == 0 ) {
        return ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED;
    }

    //
    // Bind to UDP. This transport will be used by remote clients to
    // access the clusapi interface and by cluster nodes to
    // access the extrocluster (join) interface. This uses a dynamic
    // endpoint.
    //
    Status = RpcServerUseProtseq(
                 TEXT("ncadg_ip_udp"),
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 NULL);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to bind RPC to UDP, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Figure out which UDP endpoint we got so we can register it with
    // the endpoint mapper later. We must do this before we register any
    // other protocol sequences, or they will show up in the vector.
    // Groveling the binding vector for a specific transport is no fun.
    //
    CL_ASSERT( CsRpcBindingVector == NULL);

    Status = RpcServerInqBindings(&CsRpcBindingVector);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to obtain RPC binding vector, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Bind to LRPC. This transport will be used by clients running on this
    // system to access the clusapi interface. This also uses a dynamic endpoint.
    //
    Status = RpcServerUseProtseq(
                 TEXT("ncalrpc"),
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 NULL); // No SD. Let the object inherit from its "\RPC Control" parent object which has
                        // an IO ACE specifying R, W, E, for the World.

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to bind RPC to LPC, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Register the dynamic LRPC endpoint with the local endpoint mapper database
    //
    Status = CspRegisterDynamicLRPCEndpoint ();

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to register dynamic LRPC endpoint, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Bind to CDP (Cluster Datagram Protocol). This transport will be used
    // for the intracluster interface. This uses a well-known endpoint.
    //

    // GN: Sometimes it takes a couple of seconds for resrcmon to go away after
    // a clean shutdown. When SCM tries to restart the service the following call will fail.
    // In order to overcome this we will give up only if we couldn't bind RPC to CDP
    // 10 times with 1 second in between the calls
    //

    retry = 10;

    for (;;) {
        Status = RpcServerUseProtseqEp(
                     CLUSTER_RPC_PROTSEQ,
                     1,                      // Max calls
                     CLUSTER_RPC_PORT,
                     NULL);
        if (Status != RPC_S_DUPLICATE_ENDPOINT || retry == 0) {
            break;
        }
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Unable to bind RPC to CDP, status %1!u!. Retrying...\n",
            Status);
        Sleep(1000);
        --retry;
    }

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to bind RPC to CDP, status %1!u!.\n",
            Status);
        return(Status);
    }

    //
    // Start our RPC server. Note that we will not get any calls until
    // we register our interfaces.
    //
    Status = RpcServerListen(
                 CS_CONCURRENT_RPC_CALLS,
                 RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                 TRUE);

    if ((Status != RPC_S_OK) && (Status != RPC_S_ALREADY_LISTENING)) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[CS] Unable to start RPC server, status %1!u!.\n",
            Status
            );
        return(Status);
    }

    RpcSsDontSerializeContext();

    return(RPC_S_OK);
}



DWORD
ClusterRegisterIntraclusterRpcInterface(
    VOID
    )
{
    DWORD Status;

    Status = RpcServerRegisterIfEx(
                 s_IntraCluster_v2_0_s_ifspec,
                 NULL,
                 NULL,
                 0, // No need to set RPC_IF_ALLOW_SECURE_ONLY if security callback
                    // is specified. If security callback is specified, RPC
                    // will reject unauthenticated requests without invoking
                    // callback. This is the info obtained from RpcDev. See
                    // Windows Bug 572035.
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 reinterpret_cast<RPC_IF_CALLBACK_FN(__stdcall *)>( ApipConnectCallback )
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to register the IntraCluster interface, Status %1!u!.\n",
            Status
            );
        return(Status);
    }

    CspIntraclusterRpcServerStarted = TRUE;

    return(ERROR_SUCCESS);

}  // ClusterRegisterIntraclusterRpcInterface


DWORD
ClusterRegisterExtroclusterRpcInterface(
    VOID
    )
{
    DWORD Status;

    Status = RpcServerRegisterIfEx(
                 s_ExtroCluster_v2_0_s_ifspec,
                 NULL,
                 NULL,
                 0, // No need to set RPC_IF_ALLOW_SECURE_ONLY if security callback
                    // is specified. If security callback is specified, RPC
                    // will reject unauthenticated requests without invoking
                    // callback. This is the info obtained from RpcDev. See
                    // Windows Bug 572035.
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 reinterpret_cast<RPC_IF_CALLBACK_FN( __stdcall *)>( ApipConnectCallback )
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to register the ExtroCluster interface, status %1!u!.\n",
            Status
            );
        return(Status);
    }

    CL_ASSERT( CsRpcBindingVector != NULL);

    Status = RpcEpRegister(
                 s_ExtroCluster_v2_0_s_ifspec,
                 CsRpcBindingVector,
                 NULL,
                 L"Microsoft Extrocluster Interface"
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to register the ExtroCluster interface endpoint, status %1!u!.\n",
            Status
            );
        NmDumpRpcExtErrorInfo(Status);
        return(Status);
    }

    return(ERROR_SUCCESS);

}  // ClusterRegisterExtroclusterRpcInterface


DWORD
ClusterRegisterJoinVersionRpcInterface(
    VOID
    )
{
    DWORD Status;

    Status = RpcServerRegisterIfEx(
                 s_JoinVersion_v2_0_s_ifspec,
                 NULL,
                 NULL,
                 0, // No need to set RPC_IF_ALLOW_SECURE_ONLY if security callback
                    // is specified. If security callback is specified, RPC
                    // will reject unauthenticated requests without invoking
                    // callback. This is the info obtained from RpcDev. See
                    // Windows Bug 572035.
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 reinterpret_cast<RPC_IF_CALLBACK_FN *>( ApipConnectCallback )
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to register the JoinVersion interface, status %1!u!.\n",
            Status
            );
        return(Status);
    }

    CL_ASSERT( CsRpcBindingVector != NULL);

    Status = RpcEpRegister(
                 s_JoinVersion_v2_0_s_ifspec,
                 CsRpcBindingVector,
                 NULL,
                 L"Microsoft JoinVersion Interface"
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[INIT] Unable to register the JoinVersion interface endpoint, status %1!u!.\n",
            Status
            );
        NmDumpRpcExtErrorInfo(Status);
        return(Status);
    }

    return(ERROR_SUCCESS);

}  // ClusterRegisterJoinVersionRpcInterface


VOID
ClusterDeregisterRpcInterfaces(
    VOID
    )
{
    RPC_STATUS  Status;


    ClRtlLogPrint(LOG_NOISE,
        "[INIT] Deregistering RPC endpoints & interfaces.\n"
        );

    //
    // Deregister the Extrocluster and JoinVersion interface endpoints.
    // There is no endpoint for the Intracluster interface.
    //
    if (CsRpcBindingVector != NULL) {
        Status = RpcEpUnregister(
                     s_ExtroCluster_v2_0_s_ifspec,
                     CsRpcBindingVector,
                     NULL
                     );

        if ((Status != RPC_S_OK) && (Status != EPT_S_NOT_REGISTERED)) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[INIT] Failed to deregister endpoint for ExtroCluster interface, status %1!u!.\n",
                Status
                );
        }

        Status = RpcEpUnregister(
                     s_JoinVersion_v2_0_s_ifspec,
                     CsRpcBindingVector,
                     NULL
                     );

        if ((Status != RPC_S_OK) && (Status != EPT_S_NOT_REGISTERED)) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[INIT] Failed to deregister endpoint for JoinVersion interface, status %1!u!.\n",
                Status
                );
        }
    }

    //
    // Deregister the interfaces
    //
    Status = RpcServerUnregisterIf(
                 s_ExtroCluster_v2_0_s_ifspec,
                 NULL,
                 1    // Wait for outstanding calls to complete
                 );

    if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Unable to deregister the ExtroCluster interface, Status %1!u!.\n",
            Status
            );
    }

    Status = RpcServerUnregisterIf(
                 s_JoinVersion_v2_0_s_ifspec,
                 NULL,
                 1    // Wait for outstanding calls to complete
                 );

    if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Unable to deregister the JoinVersion interface, Status %1!u!.\n",
            Status
            );
    }

    Status = RpcServerUnregisterIf(
                 s_IntraCluster_v2_0_s_ifspec,
                 NULL,
                 1   // Wait for outstanding calls to complete
                 );

    if ((Status != RPC_S_OK) && (Status != RPC_S_UNKNOWN_IF)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Unable to deregister the IntraCluster interface, Status %1!u!.\n",
            Status
            );
    }

    return;

}  // ClusterDeregisterRpcInterfaces


VOID
ClusterShutdownRpcServer(
    VOID
    )
{
    RPC_STATUS  Status;


    ClRtlLogPrint(LOG_NOISE, "[INIT] Shutting down RPC server.\n");

    ClusterDeregisterRpcInterfaces();

    Status = RpcMgmtStopServerListening(NULL);

    if ((Status != RPC_S_OK) && (Status != RPC_S_NOT_LISTENING)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Failed to shutdown RPC server, status %1!u!.\n",
            Status
            );
    }

#if 0

    //
    // Note - We really should wait for all outstanding calls to complete,
    //        but we can't because there is no way to shutdown any
    //        pending API GetNotify calls.
    //
    Status = RpcMgmtWaitServerListen();

    if ((Status != RPC_S_OK) && (Status != RPC_S_NOT_LISTENING)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[INIT] Failed to wait for all RPC calls to complete, status %1!u!.\n",
            Status
            );
    }

#endif // 0

    if (CsRpcBindingVector != NULL) {
        RpcBindingVectorFree(&CsRpcBindingVector);
        CsRpcBindingVector = NULL;
    }

    return;

}  // ClusterShutdownRpcServer



LONG
CspExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionInfo
    )
/*++

Routine Description:

    Top level exception handler for the cluster service process.
    Currently this just exits immediately and assumes that the
    cluster proxy will notice and restart us as appropriate.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/

{
    ClRtlLogPrint(LOG_CRITICAL,
               "[CS] Exception. Code = 0x%1!lx!, Address = 0x%2!p!\n",
                ExceptionInfo->ExceptionRecord->ExceptionCode,
                ExceptionInfo->ExceptionRecord->ExceptionAddress);
    ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Exception parameters: %1!lx!, %2!lx!, %3!lx!, %4!lx!\n",
                ExceptionInfo->ExceptionRecord->ExceptionInformation[0],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[1],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[2],
                ExceptionInfo->ExceptionRecord->ExceptionInformation[3]);

    GenerateExceptionReport(ExceptionInfo);

    if (lpfnOriginalExceptionFilter)
        lpfnOriginalExceptionFilter(ExceptionInfo);

    // the system level handler will be invoked if we return
    // EXCEPTION_CONTINUE_SEARCH - for debug dont terminate the process

    if ( IsDebuggerPresent()) {
        return(EXCEPTION_CONTINUE_SEARCH);
    } else {

#if !CLUSTER_BETA
        TerminateProcess( GetCurrentProcess(),
                          ExceptionInfo->ExceptionRecord->ExceptionCode );
#endif

        return(EXCEPTION_CONTINUE_SEARCH);
    }
}



VOID
CsInconsistencyHalt(
    IN DWORD Status
    )
{
    WCHAR  string[16];
    DWORD  status;

    //
    //  Chittur Subbaraman (chitturs) - 12/17/99
    //
    //  Announce your status to the SCM as SERVICE_STOP_PENDING so that
    //  it does not affect restart. Also, it could let clients learn
    //  of the error status.
    //
    CsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    CsServiceStatus.dwControlsAccepted = 0;
    CsServiceStatus.dwCheckPoint = 0;
    CsServiceStatus.dwWaitHint = 0;
    status = CspSetErrorCode( Status, &CsServiceStatus );

    CsAnnounceServiceStatus();

    wsprintfW(&(string[0]), L"%u", Status);

    ClRtlLogPrint(LOG_CRITICAL,
        "[CS] Halting this node to prevent an inconsistency within the cluster. Error status = %1!u!\n",
        Status
        );

    CsLogEvent1(
        LOG_CRITICAL,
        CS_EVENT_INCONSISTENCY_HALT,
        string
        );

    //release the mutex so that the service when it starts can acqire the same
    //without a delay
    ReleaseMutex(CspMutex);
    ExitProcess(status); // return the fake error code
}


PVOID
CsAlloc(
    DWORD Size
    )
{
    PVOID p;
    p = LocalAlloc(LMEM_FIXED, Size);
    if (p == NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
    }
    return(p);
}


LPWSTR
CsStrDup(
    LPCWSTR String
    )
{
    LPWSTR p;
    DWORD Len;

    Len = (lstrlenW(String)+1)*sizeof(WCHAR);
    p=static_cast<LPWSTR>(LocalAlloc(LMEM_FIXED, Len));
    if (p==NULL) {
        CsInconsistencyHalt( ERROR_NOT_ENOUGH_MEMORY );
    }
    CopyMemory(p,String,Len);
    return(p);
}

DWORD
VssWriterInit(
    VOID
    )
/*++

Routine Description:

    Start subscribing for volume snapshot events as a writer.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - Subscription succeeded.
    Error status the subscription fails.

Comments:

    Should never be called from a ServiceMain() since this function would result in
    possibly starting the EventSystem service. During autostart, any calls from
    ServiceMain() that would demand start a service will cause the caller service
    to hang.

--*/
{
    DWORD       dwStatus = ERROR_SUCCESS;
    HRESULT     hr;

    //
    //  When this function is called, it is possible this global is not initialized
    //  by ClusterInitialize since it can return with success in an evict cleanup
    //  case.  In that case, bail.
    //
    if ( !g_pCVssWriterCluster ) goto FnExit;

    ClRtlLogPrint( LOG_NOISE, "[INIT] VSS Initializing\n" );

    hr = g_pCVssWriterCluster->Initialize( g_VssIdCluster, // VSS_ID WriterId;
                                           L"Cluster Service Writer", // LPCWSTR WriterName;
                                           VSS_UT_SYSTEMSERVICE,  // VSS_USAGE_TYPE UsageType;
                                           VSS_ST_OTHER // VSS_SOURCE_TYPE SourceType;
                                           // <default> VSS_APPLICATION_LEVEL AppLevel;
                                           // <default> DWORD dwTimeoutFreeze
                                           );
    if ( FAILED( hr )) {
        ClRtlLogPrint( LOG_CRITICAL, "[INIT] VSS Failed to initialize VSS, status 0x%1!x!\n", hr );
        dwStatus = HRESULT_CODE( hr );
        goto FnExit;
    }

    // Now we need to subscibe so that we get the events for backup.
    //
    ClRtlLogPrint( LOG_NOISE, "[INIT] VSS Calling subscribe to register for backup events.\n" );
    hr = g_pCVssWriterCluster->Subscribe( );
    if ( FAILED( hr )) {
        ClRtlLogPrint( LOG_CRITICAL, "[INIT] VSS Failed to subscribe to VSS, status 0x%1!x!\n", hr );
        dwStatus = HRESULT_CODE( hr );
        goto FnExit;
    } else {
        g_bCVssWriterClusterSubscribed = TRUE;
    }

FnExit:
    return ( dwStatus );
}// VssWriterInit

RPC_STATUS
CspRegisterDynamicLRPCEndpoint(
    VOID
    )
/*++

Routine Description:

    Inquire the server bindings, look for the LRPC protocol and register the clusapi interface
    with the dynamic endpoint obtained for the LRPC protocol.

Arguments:

    None.

Return Value:

    RPC_S_OK if successful.

    RPC error code otherwise.

--*/
{
    RPC_STATUS          rpcStatus;
    RPC_BINDING_VECTOR  *pServerBindingVector = NULL;
    DWORD               i;
    WCHAR               *pszProtSeq = NULL, *pServerStringBinding = NULL;

    //
    //  Get the server binding vector. This includes all the protocols and EP's registered
    //  so far.
    //
    rpcStatus = RpcServerInqBindings( &pServerBindingVector );

    if ( rpcStatus != RPC_S_OK )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[INIT] CspRegisterDynamicLRPCEndpoint: Unable to inquire server bindings, status %1!u!.\n",
                      rpcStatus);
        NmDumpRpcExtErrorInfo( rpcStatus );
        goto FnExit;
    }

    //
    //  Grovel the binding vector looking for the LRPC protocol information.
    //
    for( i = 0; i < pServerBindingVector->Count; i++ )
    {
        rpcStatus = RpcBindingToStringBinding( pServerBindingVector->BindingH[i],
                                               &pServerStringBinding );

        if ( rpcStatus != RPC_S_OK )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[INIT] CspRegisterDynamicLRPCEndpoint: Unable to convert binding to string, status %1!u!.\n",
                          rpcStatus);
            NmDumpRpcExtErrorInfo( rpcStatus );
            goto FnExit;
        }

        rpcStatus = RpcStringBindingParse( pServerStringBinding,
                                           NULL,
                                           &pszProtSeq,
                                           NULL,
                                           NULL,
                                           NULL );

        if ( rpcStatus != RPC_S_OK )
        {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[INIT] CspRegisterDynamicLRPCEndpoint: Unable to parse server string binding, status %1!u!.\n",
                          rpcStatus);
            NmDumpRpcExtErrorInfo( rpcStatus );
            goto FnExit;
        }

        if ( lstrcmp ( pszProtSeq, TEXT("ncalrpc") ) == 0 )
        {
            //
            //  Found the LRPC protocol information
            //
            RPC_BINDING_VECTOR  LrpcBindingVector;

            LrpcBindingVector.Count = 1;
            LrpcBindingVector.BindingH[0] = pServerBindingVector->BindingH[i];

            //
            //  Register the dynamic endpoint obtained for the clusapi interface to field
            //  local calls.
            //
            rpcStatus = RpcEpRegister( s_clusapi_v2_0_s_ifspec,
                                       &LrpcBindingVector,
                                       NULL,
                                       TEXT("Microsoft Cluster Server Local API") );

            if ( rpcStatus != RPC_S_OK )
            {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[INIT] CspRegisterDynamicLRPCEndpoint: Unable to register the clusapi interface lrpc endpoint, status %1!u!.\n",
                              rpcStatus);
                NmDumpRpcExtErrorInfo( rpcStatus );
            }
            ClRtlLogPrint(LOG_NOISE,
                         "[INIT] CspRegisterDynamicLRPCEndpoint: Successfully registered LRPC endpoint with EP mapper\n");
            goto FnExit;
        }

        RpcStringFree( &pszProtSeq );
        pszProtSeq = NULL;
        RpcStringFree( &pServerStringBinding );
        pServerStringBinding = NULL;
    } // for

    //
    //  If you didn't find the LRPC information, return an error.
    //
    if ( i == pServerBindingVector->Count )
    {
        rpcStatus = RPC_S_NO_BINDINGS;
        ClRtlLogPrint(LOG_CRITICAL,
                      "[INIT] CspRegisterDynamicLRPCEndpoint: Unable to get info on the LRPC binding, status %1!u!.\n",
                      rpcStatus);
        goto FnExit;
    }

FnExit:
    //
    //  Free the strings and the binding vector if they haven't already been freed
    //
    if ( pszProtSeq != NULL ) RpcStringFree ( &pszProtSeq );
    if ( pServerStringBinding != NULL ) RpcStringFree( &pServerStringBinding );
    if ( pServerBindingVector != NULL ) RpcBindingVectorFree( &pServerBindingVector );

    return ( rpcStatus );
}// CspRegisterDynamicLRPCEndpoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\initp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    initp.h

Abstract:

    Private header file for the initialization component of the
    NT Cluster Service

Author:

    John Vert (jvert) 6/5/1996

Revision History:

--*/
#include "service.h"
#include "stdio.h"
#include "stdlib.h"
#include "wchar.h"
#include "api_rpc.h"

#define LOG_CURRENT_MODULE LOG_MODULE_INIT

#define CS_CONCURRENT_RPC_CALLS 16
#define CS_DMP_FILE_NAME        L"\\clussvc.dmp"

DWORD
ClusterInitialize(
    VOID
    );

VOID
ClusterShutdown(
    DWORD ExitCode
    );

DWORD
ClusterForm(
    VOID
    );

DWORD
ClusterJoin(
    VOID
    );

VOID
ClusterLeave(
    VOID
    );

RPC_STATUS
ClusterInitializeRpcServer(
    VOID
    );

DWORD
ClusterRegisterExtroclusterRpcInterface(
    VOID
    );

DWORD
ClusterRegisterJoinVersionRpcInterface(
    VOID
    );

VOID
ClusterDeregisterRpcInterfaces(
    VOID
    );

VOID
ClusterShutdownRpcServer(
    VOID
    );

DWORD
CspSetErrorCode(
    IN DWORD ErrorCode,
    OUT LPSERVICE_STATUS ServiceStatus
    );

VOID
GenerateExceptionReport(
  IN PEXCEPTION_POINTERS pExceptionInfo
    );

//
//  Restore database related functions
//
DWORD
RdbStopSvcOnNodes(
    IN PNM_NODE_ENUM2 pNodeEnum,
    IN LPCWSTR lpszServiceName
    );

VOID 
RdbGetRestoreDbParams( 
    IN HKEY hClusSvcKey 
    );

BOOL
RdbFixupQuorumDiskSignature(
    IN DWORD dwSignature
    );

DWORD
RdbpOpenDiskDevice(
    IN  LPCWSTR  lpDriveLetter,
    OUT PHANDLE  pFileHandle
    );

DWORD
RdbpCompareAndWriteSignatureToDisk(
    IN  HANDLE  hFile,
    IN  DWORD   dwSignature
    );

DWORD
RdbStartSvcOnNodes(
    IN LPCWSTR  lpszServiceName
    );

DWORD
RdbInitialize(
    VOID
    );

DWORD
RdbpUnloadClusterHive(
    VOID
    );

DWORD 
RdbpDeleteRestoreDbParams( 
    VOID
    );

DWORD 
VssWriterInit(
    VOID
    );

RPC_STATUS
CspRegisterDynamicLRPCEndpoint(
    VOID
    );

//
// Private Constants
//
#define CS_MAX_DELAYED_WORK_THREADS    5
#define CS_MAX_CRITICAL_WORK_THREADS   1   // The critical queue is serialized

#define MIN_WORKING_SET_SIZE (1*1024*1024)
#define MAX_WORKING_SET_SIZE (2*MIN_WORKING_SET_SIZE)

extern BOOLEAN bFormCluster;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\makefile.inc ===
clussvc.rc : $(O)\clusvmsg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\excprpt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    excprt.c
    
Abstract:

    This module uses imagehlp.dll to dump the stack when an exception occurs.

Author:

    Sunita Shrivastava(sunitas) 11/5/1997

Revision History:

--*/
#define UNICODE 1
#define _UNICODE 1
#define QFS_DO_NOT_UNMAP_WIN32

#include "initp.h"
#include "dbghelp.h"


// Make typedefs for some dbghelp.DLL functions so that we can use them
// with GetProcAddress
typedef BOOL (__stdcall * SYMINITIALIZEPROC)( HANDLE, LPSTR, BOOL );
typedef BOOL (__stdcall *SYMCLEANUPPROC)( HANDLE );

typedef BOOL (__stdcall * STACKWALKPROC)
           ( DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
            PREAD_PROCESS_MEMORY_ROUTINE,
            PFUNCTION_TABLE_ACCESS_ROUTINE,
            PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE );

typedef LPVOID (__stdcall *SYMFUNCTIONTABLEACCESSPROC)( HANDLE, ULONG_PTR );

typedef ULONG_PTR (__stdcall *SYMGETMODULEBASEPROC)( HANDLE, ULONG_PTR );

typedef BOOL (__stdcall *SYMGETSYMFROMADDRPROC)
                            ( HANDLE, ULONG_PTR, PULONG_PTR, PIMAGEHLP_SYMBOL );

typedef BOOL (__stdcall *SYMFROMADDRPROC)
                            ( HANDLE, DWORD64, PDWORD64, PSYMBOL_INFO );

typedef BOOL (__stdcall *MINIDUMPWRITEDUMP)
                            ( HANDLE, DWORD, HANDLE, MINIDUMP_TYPE, 
                              PMINIDUMP_EXCEPTION_INFORMATION,
                              PMINIDUMP_USER_STREAM_INFORMATION,
                              PMINIDUMP_CALLBACK_INFORMATION );

SYMINITIALIZEPROC _SymInitialize = 0;
SYMCLEANUPPROC _SymCleanup = 0;
STACKWALKPROC _StackWalk = 0;
SYMFUNCTIONTABLEACCESSPROC _SymFunctionTableAccess = 0;
SYMGETMODULEBASEPROC _SymGetModuleBase = 0;
SYMGETSYMFROMADDRPROC _SymGetSymFromAddr = 0;
SYMFROMADDRPROC _SymFromAddr = 0;
MINIDUMPWRITEDUMP _MiniDumpWriteDump = NULL;

//local prototypes for forward use
BOOL InitImagehlpFunctions();
void ImagehlpStackWalk( IN PCONTEXT pContext );
BOOL GetLogicalAddress(
        IN PVOID    addr, 
        OUT LPWSTR  szModule, 
        IN  DWORD   len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset );

VOID
GenerateMemoryDump(
    IN PEXCEPTION_POINTERS pExceptionInfo
    );

VOID
DumpCriticalSection(
    IN PCRITICAL_SECTION CriticalSection
    )
/*++

Routine Description:

Inputs:

Outputs:

--*/

{
    DWORD status;

    ClRtlLogPrint(LOG_CRITICAL, "[CS] Dumping Critical Section at %1!08LX!\n",
                CriticalSection );

    try {
        if ( CriticalSection->LockCount == -1 ) {
            ClRtlLogPrint(LOG_CRITICAL, "     LockCount       NOT LOCKED\n" );
        } else {
            ClRtlLogPrint(LOG_CRITICAL, "     LockCount       %1!u!\n",
                        CriticalSection->LockCount );
        }
        ClRtlLogPrint(LOG_CRITICAL, "     RecursionCount  %1!x!\n",
                    CriticalSection->RecursionCount );
        ClRtlLogPrint(LOG_CRITICAL, "     OwningThread    %1!x!\n",
                    CriticalSection->OwningThread );
        ClRtlLogPrint(LOG_CRITICAL, "     EntryCount      %1!x!\n",
                    CriticalSection->DebugInfo->EntryCount );
        ClRtlLogPrint(LOG_CRITICAL, "     ContentionCount %1!x!\n\n",
                    CriticalSection->DebugInfo->ContentionCount );
    
    } except ( EXCEPTION_EXECUTE_HANDLER )  {
        status = GetExceptionCode();
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Exception %1!lx! occurred while dumping critsec\n\n",
            status );
    }

    
} // DumpCriticalSection


void GenerateExceptionReport(
    IN PEXCEPTION_POINTERS pExceptionInfo)
/*++

Routine Description:

    Top level exception handler for the cluster service process.
    Currently this just exits immediately and assumes that the
    cluster proxy will notice and restart us as appropriate.

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{    
    PCONTEXT pCtxt = pExceptionInfo->ContextRecord;

    if ( !InitImagehlpFunctions() )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Dbghelp.dll or its exported procs not found\r\n");

#if 0 
        #ifdef _M_IX86  // Intel Only!
        // Walk the stack using x86 specific code
        IntelStackWalk( pCtx );
        #endif
#endif        

        return;
    }

    GenerateMemoryDump ( pExceptionInfo );

    ImagehlpStackWalk( pCtxt );

    _SymCleanup( GetCurrentProcess() );

}

VOID
GenerateMemoryDump(
    IN PEXCEPTION_POINTERS pExceptionInfo
    )
/*++

Routine Description:

    Generates a memory dump for the cluster service process.

Arguments:

    pExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    DWORD                           dwStatus = ERROR_SUCCESS;
    WCHAR                           szFileName[ MAX_PATH + RTL_NUMBER_OF ( CS_DMP_FILE_NAME ) + 1 ];
    HANDLE                          hDumpFile = INVALID_HANDLE_VALUE;
    MINIDUMP_EXCEPTION_INFORMATION  mdumpExceptionInfo;

    if ( !_MiniDumpWriteDump ) 
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        ClRtlLogPrint(LOG_CRITICAL, "[CS] GenerateMemoryDump: _MiniDumpWriteDump fn ptr is invalid, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }
    
    dwStatus = ClRtlGetClusterDirectory( szFileName, RTL_NUMBER_OF ( szFileName ) );

    if ( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] GenerateMemoryDump: Could not get cluster dir, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }

    wcsncat( szFileName, 
             CS_DMP_FILE_NAME, 
             RTL_NUMBER_OF ( szFileName ) - 
                 ( wcslen ( szFileName ) + 1 ) );

    szFileName [ RTL_NUMBER_OF ( szFileName ) - 1 ] = UNICODE_NULL;

    hDumpFile = CreateFile( szFileName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_ALWAYS,
                            0,
                            NULL );

    if ( hDumpFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL, "[CS] GenerateMemoryDump: Could not create file %1!ws!, Status=%2!u!\n",
                      szFileName,
                      dwStatus);                              
        goto FnExit;
    }
    
    mdumpExceptionInfo.ThreadId = GetCurrentThreadId ();
    mdumpExceptionInfo.ExceptionPointers = pExceptionInfo;
    mdumpExceptionInfo.ClientPointers = TRUE;

    ClRtlLogPrint(LOG_NOISE, "[CS] GenerateMemoryDump: Start memory dump to file %1!ws!\n",
                  szFileName);                              

    if( !_MiniDumpWriteDump( GetCurrentProcess(), 
                             GetCurrentProcessId(), 
                             hDumpFile, 
                             MiniDumpNormal | MiniDumpWithHandleData,
                             &mdumpExceptionInfo,
                             NULL,
                             NULL ) )
    {
        dwStatus = GetLastError ();
        ClRtlLogPrint(LOG_CRITICAL, "[CS] GenerateMemoryDump: Could not write dump, Status=%1!u!\n",
                      dwStatus);                              
        goto FnExit;
    }
    
FnExit:
    if ( hDumpFile != INVALID_HANDLE_VALUE ) CloseHandle ( hDumpFile );

    ClRtlLogPrint(LOG_NOISE, "[CS] GenerateMemoryDump: Memory dump status %1!u!\n",
                  dwStatus);                              

    return;
}// GenerateMemoryDump

BOOL InitImagehlpFunctions()
/*++

Routine Description:

    Initializes the imagehlp functions/data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HMODULE hModImagehlp = LoadLibraryW( L"DBGHELP.DLL" );

    
    if ( !hModImagehlp )
        return FALSE;

    _SymInitialize = (SYMINITIALIZEPROC)GetProcAddress( hModImagehlp,
                                                        "SymInitialize" );
    if ( !_SymInitialize )
        return FALSE;

    _SymCleanup = (SYMCLEANUPPROC)GetProcAddress( hModImagehlp, "SymCleanup" );
    if ( !_SymCleanup )
        return FALSE;

    _StackWalk = (STACKWALKPROC)GetProcAddress( hModImagehlp, "StackWalk" );
    if ( !_StackWalk )
        return FALSE;

    _SymFunctionTableAccess = (SYMFUNCTIONTABLEACCESSPROC)
                        GetProcAddress( hModImagehlp, "SymFunctionTableAccess" );

    if ( !_SymFunctionTableAccess )
        return FALSE;

    _SymGetModuleBase=(SYMGETMODULEBASEPROC)GetProcAddress( hModImagehlp,
                                                            "SymGetModuleBase");
                                                            
    if ( !_SymGetModuleBase )
        return FALSE;

    _SymGetSymFromAddr=(SYMGETSYMFROMADDRPROC)GetProcAddress( hModImagehlp,
                                                "SymGetSymFromAddr" );
    if ( !_SymGetSymFromAddr )
        return FALSE;

    _SymFromAddr=(SYMFROMADDRPROC)GetProcAddress( hModImagehlp,
                                                "SymFromAddr" );
    if ( !_SymFromAddr )
        return FALSE;

    _MiniDumpWriteDump = (MINIDUMPWRITEDUMP)GetProcAddress( hModImagehlp,
                                                        "MiniDumpWriteDump" );
    if ( !_MiniDumpWriteDump )
        return FALSE;

    // Set the current directory so that the symbol handler functions will pick up any PDBs that happen to be in
    // the cluster dir.  
    // No need to save and restore the previous current dir since we will be dying after this.
    {
        WCHAR currentDir[ MAX_PATH + 1 ];
        UINT  windirLen = GetWindowsDirectory( currentDir, MAX_PATH );
        if ( windirLen != 0 && windirLen <= MAX_PATH - wcslen( L"\\Cluster" ) )
        {
            wcscat( currentDir, L"\\Cluster" );
            if ( !SetCurrentDirectory( currentDir ))
            {
                ClRtlLogPrint( LOG_CRITICAL, "Failed to set current directory to %1!ws!, error %2!d!\n", currentDir, GetLastError() );
            }
        }
    }

    if ( !_SymInitialize( GetCurrentProcess(), NULL, TRUE ) )
        return FALSE;

    return TRUE;        
} // InitImagehlpFunctions


void ImagehlpStackWalk(
    IN PCONTEXT pContext )
/*++

Routine Description:

    Walks the stack, and writes the results to the report file 

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    STACKFRAME      sf;
    BYTE            symbolBuffer[ sizeof(IMAGEHLP_SYMBOL) + 512 ];
    PSYMBOL_INFO    pSymbol = (PSYMBOL_INFO)symbolBuffer;
    DWORD64         symDisplacement = 0;      // Displacement of the input address,
                                        // relative to the start of the symbol
    DWORD           dwMachineType;                                        
    UCHAR           printBuffer[512];
    INT             nextPrtBufChar;

    ClRtlLogPrint(LOG_CRITICAL, 
                    "[CS] CallStack:\n");

    ClRtlLogPrint(LOG_CRITICAL, 
                    "[CS] Frame   Address\n");

    // Could use SymSetOptions here to add the SYMOPT_DEFERRED_LOADS flag

    memset( &sf, 0, sizeof(sf) );

#if defined (_M_IX86)
    dwMachineType          = IMAGE_FILE_MACHINE_I386;
    sf.AddrPC.Offset       = pContext->Eip;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->Esp;
    sf.AddrStack.Mode      = AddrModeFlat;
    sf.AddrFrame.Offset    = pContext->Ebp;
    sf.AddrFrame.Mode      = AddrModeFlat;

#elif defined(_M_AMD64)
    dwMachineType          = IMAGE_FILE_MACHINE_AMD64;
    sf.AddrPC.Offset       = pContext->Rip;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->Rsp;
    sf.AddrStack.Mode      = AddrModeFlat;

#elif defined(_M_IA64)
    dwMachineType          = IMAGE_FILE_MACHINE_IA64;
    sf.AddrPC.Offset       = pContext->StIIP;
    sf.AddrPC.Mode         = AddrModeFlat;
    sf.AddrStack.Offset    = pContext->IntSp;
    sf.AddrStack.Mode      = AddrModeFlat;

#else
#error "No Target Architecture"
#endif // defined(_M_IX86)

while ( 1 )
    {
        if ( ! _StackWalk(  dwMachineType,
                            GetCurrentProcess(),
                            GetCurrentThread(),
                            &sf,
                            pContext,
                            0,
                            _SymFunctionTableAccess,
                            _SymGetModuleBase,
                            0 ) )
               break;
                            
        if ( 0 == sf.AddrFrame.Offset ) // Basic sanity check to make sure
            break;                      // the frame is OK.  Bail if not.

        printBuffer [ RTL_NUMBER_OF ( printBuffer ) - 1 ] = ANSI_NULL; 
        nextPrtBufChar = _snprintf( printBuffer,
                                    RTL_NUMBER_OF ( printBuffer ) - 1,
                                    "     %p  %p  ",
                                    sf.AddrFrame.Offset, sf.AddrPC.Offset );

        if ( nextPrtBufChar < 0 ) continue;

        // IMAGEHLP is wacky, and requires you to pass in a pointer to an
        // IMAGEHLP_SYMBOL structure.  The problem is that this structure is
        // variable length.  That is, you determine how big the structure is
        // at runtime.  This means that you can't use sizeof(struct).
        // So...make a buffer that's big enough, and make a pointer
        // to the buffer.  We also need to initialize not one, but TWO
        // members of the structure before it can be used.

        pSymbol->SizeOfStruct = sizeof(symbolBuffer);
        pSymbol->MaxNameLen = 512;
        
        if ( _SymFromAddr(GetCurrentProcess(), sf.AddrPC.Offset,
                                &symDisplacement, pSymbol) )
        {
            _snprintf( printBuffer+nextPrtBufChar,
                       RTL_NUMBER_OF ( printBuffer ) - 1 - nextPrtBufChar,
                       "%hs+%08X\n", 
                       pSymbol->Name, symDisplacement );
            
        }
        else    // No symbol found.  Print out the logical address instead.
        {
            WCHAR szModule[MAX_PATH] = L"";
            DWORD section = 0;
            ULONG_PTR offset = 0;

            GetLogicalAddress(  (PVOID)sf.AddrPC.Offset,
                                szModule, sizeof(szModule)/sizeof(WCHAR), 
                                &section, &offset );

            _snprintf( printBuffer+nextPrtBufChar,
                       RTL_NUMBER_OF ( printBuffer ) - 1 - nextPrtBufChar,
                       "%04X:%08X %S\n",
                       section, offset, szModule );
        }
        
        ClRtlLogPrint(LOG_CRITICAL, "%1!hs!", printBuffer);
    }
}


BOOL GetLogicalAddress(
        IN PVOID addr, 
        OUT LPWSTR szModule, 
        IN DWORD len, 
        OUT LPDWORD section, 
        OUT PULONG_PTR offset )
/*++

Routine Description:

    Given a linear address, locates the module, section, and offset containing  
    that address.                                                               
    Note: the szModule paramater buffer is an output buffer of length specified 
    by the len parameter (in characters!)                                       

Arguments:

    ExceptionInfo - Supplies the exception information

Return Value:

    None.

--*/
{
    MEMORY_BASIC_INFORMATION mbi;
    ULONG_PTR hMod;
    // Point to the DOS header in memory
    PIMAGE_DOS_HEADER pDosHdr;
    // From the DOS header, find the NT (PE) header
    PIMAGE_NT_HEADERS pNtHdr;
    PIMAGE_SECTION_HEADER pSection;
    ULONG_PTR rva ;
    int   i;
    
    if ( !VirtualQuery( addr, &mbi, sizeof(mbi) ) )
        return FALSE;

    hMod = (ULONG_PTR)mbi.AllocationBase;

    if ( !GetModuleFileName( (HMODULE)hMod, szModule, len ) )
        return FALSE;

    rva = (ULONG_PTR)addr - hMod; // RVA is offset from module load address

    pDosHdr =  (PIMAGE_DOS_HEADER)hMod;
    pNtHdr = (PIMAGE_NT_HEADERS)(hMod + pDosHdr->e_lfanew);
    pSection = IMAGE_FIRST_SECTION( pNtHdr );
    
    // Iterate through the section table, looking for the one that encompasses
    // the linear address.
    for ( i = 0; i < pNtHdr->FileHeader.NumberOfSections;
            i++, pSection++ )
    {
        ULONG_PTR sectionStart = pSection->VirtualAddress;
        ULONG_PTR sectionEnd = sectionStart
                    + max(pSection->SizeOfRawData, pSection->Misc.VirtualSize);


        // Is the address in this section???
        if ( (rva >= sectionStart) && (rva <= sectionEnd) )
        {
            // Yes, address is in the section.  Calculate section and offset,
            // and store in the "section" & "offset" params, which were
            // passed by reference.
            *section = i+1;
            *offset = rva - sectionStart;
            return TRUE;
        }
    }

    return FALSE;   // Should never get here!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\join.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    join.c

Abstract:

    This module handles the initialization path where a newly booted
    node joins an existing cluster.

Author:

    John Vert (jvert) 6/6/1996

Revision History:

--*/
#include "initp.h"
#include "lmcons.h"
#include "lmremutl.h"
#include "lmapibuf.h"

#include <clusverp.h>

#define JOIN_CLIENT_NO_DELAY            0     // delay for high-prio networks
#define JOIN_CLIENT_NETWORK_DELAY       1000  // delay for low-prio networks
#define JOIN_CLIENT_RESOURCE_DELAY      2000  // delay for cluster IP/netname

#define JOIN_CLIENT_GET_NETWORK_DELAY(_NetworkPrio) \
    (((_NetworkPrio) == 1) ? JOIN_CLIENT_NO_DELAY : JOIN_CLIENT_NETWORK_DELAY)

//
// Local types
//
typedef struct {
    DWORD    Delay;
    LPWSTR   Name;
} JOIN_SPONSOR_CONTEXT, *PJOIN_SPONSOR_CONTEXT;

//
// Local data
//
CRITICAL_SECTION    CsJoinLock;
HANDLE              CsJoinEvent = NULL;
DWORD               CsJoinThreadCount = 0;
DWORD               CsJoinStatus=ERROR_SUCCESS;
RPC_BINDING_HANDLE  CsJoinSponsorBinding = NULL;
LPWSTR              CsJoinSponsorName = NULL;

// While another node is joining, we will keep track of any DM or FM updates.
BOOL   CsDmOrFmHasChanged = FALSE;


//
// Local function prototypes
//
VOID
JoinpEnumNodesAndJoinByAddress(
    IN HDMKEY  Key,
    IN PWSTR   NodeId,
    IN PVOID   Context
    );

VOID
JoinpEnumNodesAndJoinByHostName(
    IN HDMKEY  Key,
    IN PWSTR   NodeId,
    IN PVOID   Context
    );

VOID
JoinpConnectToSponsor(
    IN PWSTR   SponsorName,
    IN DWORD   Delay
    );

DWORD WINAPI
JoinpConnectThread(
    LPVOID   Parameter
    );

DWORD
JoinpAttemptJoin(
    LPWSTR               SponsorName,
    RPC_BINDING_HANDLE   JoinMasterBinding
    );

BOOL
JoinpAddNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );

BOOL
JoinpEnumNetworksToSetPriority(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    );


DWORD
ClusterJoin(
    VOID
    )
/*++

Routine Description:

    Called to attempt to join a cluster that already exists.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    LPWSTR ClusterIpAddress = NULL;
    LPWSTR ClusIpAddrResource = NULL;
    LPWSTR ClusterNameId = NULL;
    DWORD idMaxSize = 0;
    DWORD idSize = 0;
    HDMKEY hClusNameResKey = NULL;
    HDMKEY hClusIPAddrResKey = NULL;

    //
    // Try connecting using the cluster IP address first. get the cluster
    // name resource, looking up its dependency for the cluster IP addr
    //

    Status = DmQuerySz(DmClusterParametersKey,
                       CLUSREG_NAME_CLUS_CLUSTER_NAME_RES,
                       &ClusterNameId,
                       &idMaxSize,
                       &idSize);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to get cluster name resource, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // open name resource key and read its DependsOn key
    //

    hClusNameResKey = DmOpenKey( DmResourcesKey, ClusterNameId, KEY_READ );

    if ( hClusNameResKey == NULL ) {

        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to open Cluster Name resource key, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // allocate enough space for the GUID and the Parameters string
    //

    idMaxSize = ( CS_NETWORK_ID_LENGTH + sizeof( CLUSREG_KEYNAME_PARAMETERS ) + 2)
        * sizeof(WCHAR);
    ClusIpAddrResource = LocalAlloc( LMEM_FIXED, idMaxSize );

    if ( ClusIpAddrResource == NULL ) {

        Status = ERROR_NOT_ENOUGH_MEMORY;

        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] no memory for Cluster Ip address resource ID!\n");
        goto error_exit;
    }

    Status = DmQueryMultiSz(hClusNameResKey,
                            CLUSREG_NAME_RES_DEPENDS_ON,
                            &ClusIpAddrResource,
                            &idMaxSize,
                            &idSize);

    if ( Status != ERROR_SUCCESS ) {

        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to get Cluster Ip address resource ID, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    lstrcatW( ClusIpAddrResource, L"\\" );
    lstrcatW( ClusIpAddrResource, CLUSREG_KEYNAME_PARAMETERS );
    hClusIPAddrResKey = DmOpenKey( DmResourcesKey, ClusIpAddrResource, KEY_READ );

    if ( hClusIPAddrResKey == NULL ) {

        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to open Cluster IP Address resource key, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // get the IP Address; note that these value names are not defined
    // in a global way. if they are changed, this code will break
    //

    idMaxSize = idSize = 0;
    Status = DmQuerySz(hClusIPAddrResKey,
                       L"Address",
                       &ClusterIpAddress,
                       &idMaxSize,
                       &idSize);

    if ( Status != ERROR_SUCCESS ) {

        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] failed to get Cluster Ip address, error %1!u!.\n",
                   Status);
        goto error_exit;
    }

    //
    // Spawn threads to find a sponsor. We will try the make connections using
    // the cluster IP address, the IP address of each node on each network, and
    // the name of each node in the cluster. The connects will proceed in
    // parallel. We'll use the first one that succeeds.
    //
    CsJoinEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CsJoinEvent == NULL) {
        Status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[JOIN] failed to create join event, error %1!u!.\n",
            Status
            );
        goto error_exit;
    }

    CsJoinThreadCount = 1;
    InitializeCriticalSection(&CsJoinLock);
    EnterCriticalSection(&CsJoinLock);

    DmEnumKeys(DmNetInterfacesKey, JoinpEnumNodesAndJoinByAddress, NULL);

    DmEnumKeys(DmNodesKey, JoinpEnumNodesAndJoinByHostName, NULL);

    //
    // give the other threads a chance to start since using the cluster IP
    // address to join with is problematic when the resource moves in the
    // middle of a join
    //
    JoinpConnectToSponsor(ClusterIpAddress, JOIN_CLIENT_RESOURCE_DELAY);

    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();


    if(CsJoinThreadCount == 1)
        SetEvent(CsJoinEvent);

    LeaveCriticalSection(&CsJoinLock);

    Status = WaitForSingleObject(CsJoinEvent, INFINITE);
    CL_ASSERT(Status == WAIT_OBJECT_0);


    EnterCriticalSection(&CsJoinLock);
    ClRtlLogPrint(LOG_NOISE, 
        "[JOIN] Got out of the join wait, CsJoinThreadCount = %1!u!.\n",
        CsJoinThreadCount
        );

    if(--CsJoinThreadCount == 0) {
        CloseHandle(CsJoinEvent);
        DeleteCriticalSection(&CsJoinLock);
    }
    else
        LeaveCriticalSection(&CsJoinLock);

    //
    // All of the threads have failed or one of them made a connection,
    // use it to join.
    //
    if (CsJoinSponsorBinding != NULL) {
        CL_ASSERT(CsJoinSponsorName != NULL);

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Attempting join with sponsor %1!ws!.\n",
            CsJoinSponsorName
            );

        //
        //  Chittur Subbaraman (chitturs) - 10/27/98
        //
        //  If the database restore operation is requested, then
        //  refuse to join the cluster and return an error code.
        //
        if ( CsDatabaseRestore == TRUE ) {
            Status = ERROR_CLUSTER_NODE_UP;
            LocalFree(CsJoinSponsorName);
            goto error_exit;
        }


        Status = JoinpAttemptJoin(CsJoinSponsorName, CsJoinSponsorBinding);

        RpcBindingFree(&CsJoinSponsorBinding);
        LocalFree(CsJoinSponsorName);
    }
    else {
        //we couldnt create a binding to the sponsorer
        if(CsJoinStatus == ERROR_SUCCESS) {
            //we did the version check in joinpconnectthread but for some reason 
            //couldnt produce a binding
            Status = ERROR_BAD_NETPATH;
            ClRtlLogPrint(LOG_CRITICAL, 
                "[JOIN] Unable to connect to any sponsor node.\n");
        }
        else {
            Status = CsJoinStatus;
        }


        // rajdas: If the join did not suceed due to version mismatch we shouldn't try to form a cluster.
        // Bug ID: 152229
        //
        if(CsJoinStatus == ERROR_CLUSTER_INCOMPATIBLE_VERSIONS)
            bFormCluster = FALSE;
    }


error_exit:
    if ( ClusterNameId ) {
        LocalFree( ClusterNameId );
    }

    if ( ClusterIpAddress ) {
        LocalFree( ClusterIpAddress );
    }

    if ( ClusIpAddrResource ) {
        LocalFree( ClusIpAddrResource );
    }

    if ( hClusNameResKey ) {
        DmCloseKey( hClusNameResKey );
    }

    if ( hClusIPAddrResKey ) {
        DmCloseKey( hClusIPAddrResKey );
    }

    return(Status);
}


VOID
JoinpEnumNodesAndJoinByAddress(
    IN HDMKEY  Key,
    IN PWSTR   NetInterfaceId,
    IN PVOID   Context
    )

/*++

Routine Description:

    Attempts to establish an RPC connection to a specified
    node using its IP address

Arguments:

    Key - pointer to the node key handle

    NetInterfaceId - pointer to string representing net IF ID (guid)

    Context - pointer to a location to return the final status

Return Value:

    None

--*/

{
    DWORD       status;
    LPWSTR      NetIFNodeID = NULL;
    LPWSTR      NetIFIpAddress = NULL;
    LPWSTR      NetIFNetwork = NULL;
    HDMKEY      NetIFNetworkKey = NULL;
    DWORD       NetIFNetworkPriority;
    DWORD       idMaxSize = 0;
    DWORD       idSize = 0;


    //
    // get the NodeId Value from the NetIF key and if it's us,
    // skip this netIF
    //

    status = DmQuerySz(Key,
                       CLUSREG_NAME_NETIFACE_NODE,
                       &NetIFNodeID,
                       &idMaxSize,
                       &idSize);

    if ( status == ERROR_SUCCESS ) {

        if (lstrcmpiW(NetIFNodeID, NmLocalNodeIdString) != 0) {

            //
            // it's not us so get the address and try it...
            //
            idMaxSize = idSize = 0;
            status = DmQuerySz(Key,
                               CLUSREG_NAME_NETIFACE_ADDRESS,
                               &NetIFIpAddress,
                               &idMaxSize,
                               &idSize);

            if ( status != ERROR_SUCCESS ) {

                ClRtlLogPrint(LOG_CRITICAL,
                    "[JOIN] failed to get NetInterface Address, error %1!u!.\n",
                     status);
                goto error_exit;
            }

            //
            // Determine the delay based on the network priority. If we
            // cannot find it in the cluster database, we still try to 
            // connect to the sponsor assuming the lowest priority.
            //
            NetIFNetworkPriority = 0xFFFFFFFF;
            idMaxSize = idSize = 0;
            status = DmQuerySz(Key,
                               CLUSREG_NAME_NETIFACE_NETWORK,
                               &NetIFNetwork,
                               &idMaxSize,
                               &idSize);

            if ( status != ERROR_SUCCESS ) {

                ClRtlLogPrint(LOG_CRITICAL,
                    "[JOIN] Failed to get NetInterface Network, error %1!u!.\n",
                     status);
                goto ConnectToSponsor;
            }

            NetIFNetworkKey = DmOpenKey(DmNetworksKey,
                                        NetIFNetwork,
                                        KEY_READ);

            if ( NetIFNetworkKey == NULL ) {

                ClRtlLogPrint(LOG_CRITICAL,
                    "[JOIN] Failed to open key for network %1!ws!, error %2!u!.\n",
                    NetIFNetwork, status
                    );
                goto ConnectToSponsor;
            }

            status = DmQueryDword(NetIFNetworkKey, 
                                  CLUSREG_NAME_NET_PRIORITY,
                                  &NetIFNetworkPriority,
                                  0);

            if ( status != ERROR_SUCCESS ) {

                ClRtlLogPrint(LOG_CRITICAL,
                    "[JOIN] Failed to get NetInterface network priority, error %1!u!.\n",
                     status);
            }

ConnectToSponsor:
            //
            // attempt the join with this address
            //
            JoinpConnectToSponsor(NetIFIpAddress, 
                                  JOIN_CLIENT_GET_NETWORK_DELAY(NetIFNetworkPriority));
        }
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] failed to get NetInterface Node ID, error %1!u!.\n",
             status);
    }

error_exit:
    DmCloseKey(Key);

    if ( NetIFNodeID ) {
        LocalFree( NetIFNodeID );
    }

    if ( NetIFIpAddress ) {
        LocalFree( NetIFIpAddress );
    }

    return;
}


VOID
JoinpEnumNodesAndJoinByHostName(
    IN HDMKEY  Key,
    IN PWSTR   NodeId,
    IN PVOID   Context
    )

/*++

Routine Description:

    Attempts to establish an RPC connection to a specified node using
    its host name

Arguments:

    Key - pointer to the node key handle

    NodeId - pointer to string representing node ID (number)

    Context - pointer to a location to return the final status

Return Value:

    None

--*/

{
    DWORD       status;
    LPWSTR      nodeName=NULL;
    DWORD       nodeNameLen=0;
    DWORD       nodeNameSize=0;

    //
    // Try to connect if this is not us
    //
    if (lstrcmpiW(NodeId, NmLocalNodeIdString) != 0) {

        status = DmQuerySz(Key,
                           CLUSREG_NAME_NODE_NAME,
                           &nodeName,
                           &nodeNameLen,
                           &nodeNameSize);

        if (status == ERROR_SUCCESS) {

            JoinpConnectToSponsor(nodeName, JOIN_CLIENT_NETWORK_DELAY);
            LocalFree(nodeName);
        }
    }

    DmCloseKey(Key);

    return;
}


VOID
JoinpConnectToSponsor(
    IN PWSTR   SponsorName,
    IN DWORD   Delay
    )
/*++

Routine Description:

    Attempts to establish an RPC connection to a specified node.

Arguments:

    SponsorName - The name (or IP address) of the target sponsor.

    Delay - Milliseconds to wait before sending request

Return Value:

    ERROR_SUCCESS if an RPC connection is successfully made to the sponsor.
    An RPC error code otherwise.

--*/

{
    HANDLE                  threadHandle;
    DWORD                   status = ERROR_SUCCESS;
    DWORD                   threadId;
    PJOIN_SPONSOR_CONTEXT   context;
    BOOL                    setEvent = FALSE;


    ClRtlLogPrint(LOG_UNUSUAL, 
       "[JOIN] Spawning thread to connect to sponsor %1!ws!\n",
        SponsorName
        );

    //
    // Allocate the context and sponsor name buffer separately. If this
    // thread "wins" sponsorship, the name buffer will be reused.
    //
    context = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof(JOIN_SPONSOR_CONTEXT) );

    if (context != NULL) {

        context->Name = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                    (lstrlenW(SponsorName) + 1 ) * sizeof(WCHAR) );

        if (context->Name != NULL) {
            
            lstrcpyW(context->Name, SponsorName);
            context->Delay = Delay;

            CsJoinThreadCount++;

            threadHandle = CreateThread(
                               NULL,
                               0,
                               JoinpConnectThread,
                               context,
                               0,
                               &threadId
                               );

            if (threadHandle != NULL) {
                CloseHandle(threadHandle);
            }
            else {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL, 
                    "[JOIN] Failed to spawn connect thread, error %1!u!.\n",
                    status
                    );

                --CsJoinThreadCount;
                LocalFree(context->Name);
                LocalFree(context);
            }
        }
        else {
            LocalFree(context);
            ClRtlLogPrint(LOG_CRITICAL, 
                "[JOIN] Failed to allocate memory for sponsor name.\n"
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[JOIN] Failed to allocate memory.\n"
            );
    }

    return;

}  // JoinpConnectToSponsor


DWORD WINAPI
VerifyJoinVersionData(
    LPWSTR  sponsorName
    )

/*++

Routine Description:

    Verify that the sponsor and the joiner are compatible

Arguments:

    sponsorName - pointer to text string of sponsor to use

Return Value:

    ERROR_SUCCESS - if ok to continue join

--*/

{
    DWORD                   status;
    LPWSTR                  bindingString = NULL;
    RPC_BINDING_HANDLE      bindingHandle = NULL;
    DWORD                   SponsorNodeId;
    DWORD                   ClusterHighestVersion;
    DWORD                   ClusterLowestVersion;
    DWORD                   JoinStatus = ERROR_SUCCESS;
    DWORD                   packageIndex;

    //
    // Attempt to connect to the sponsor's JoinVersion RPC interface.
    //
    status = RpcStringBindingComposeW(
                 L"6e17aaa0-1a47-11d1-98bd-0000f875292e",
                 L"ncadg_ip_udp",
                 sponsorName,
                 NULL,
                 NULL,
                 &bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to compose JoinVersion string binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    status = RpcBindingFromStringBindingW(bindingString, &bindingHandle);

    RpcStringFreeW(&bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to build JoinVersion binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    //
    // under load, the sponsor might take a while to respond back to the
    // joiner. The default timeout is at 30 secs and this seems to work
    // ok. Note that this means the sponsor has 30 secs to reply to either
    // the RPC request or ping. As long it makes any reply, then the joiner's
    // RPC will continue to wait and not time out the sponsor.
    //

    status = RpcMgmtSetComTimeout( bindingHandle, CLUSTER_JOINVERSION_RPC_COM_TIMEOUT );
    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to set JoinVersion com timeout for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
    }

    status = RpcEpResolveBinding(bindingHandle, JoinVersion_v2_0_c_ifspec);

    if (status != RPC_S_OK) {
        if ( (status == RPC_S_SERVER_UNAVAILABLE) ||
             (status == RPC_S_NOT_LISTENING) ||
             (status == EPT_S_NOT_REGISTERED)
           )
        {
            ClRtlLogPrint(LOG_NOISE, 
                "[JOIN] Sponsor %1!ws! is not available (JoinVersion), status=%2!u!.\n",
                sponsorName,
                status
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[JOIN] Unable to resolve JoinVersion endpoint for sponsor %1!ws!, status %2!u!.\n",
                sponsorName,
                status
                );
        }
        goto error_exit;
    }

    //
    // run through the list of RPC security packages, trying to establish a
    // security context with this binding.
    //

    for (packageIndex = 0;
         packageIndex < CsNumberOfRPCSecurityPackages;
         ++packageIndex )        
    {
        status = RpcBindingSetAuthInfoW(bindingHandle,
                                        CsServiceDomainAccount,
                                        RPC_C_AUTHN_LEVEL_CONNECT,
                                        CsRPCSecurityPackage[ packageIndex ],
                                        NULL,
                                        RPC_C_AUTHZ_NAME);

        if (status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[JOIN] Unable to set JoinVersion AuthInfo using %1!ws! package, status %2!u!.\n",
                          CsRPCSecurityPackageName[packageIndex],
                          status);
            continue;
        }

        status = CsRpcGetJoinVersionData(bindingHandle,
                                         NmLocalNodeId,
                                         CsMyHighestVersion,
                                         CsMyLowestVersion,
                                         &SponsorNodeId,
                                         &ClusterHighestVersion,
                                         &ClusterLowestVersion,
                                         &JoinStatus);

        if ( status == RPC_S_OK ) {
            break;
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[JOIN] Unable to get join version data from sponsor %1!ws! using "
                          "%2!ws! package, status %3!u!.\n",
                          sponsorName,
                          CsRPCSecurityPackageName[packageIndex],
                          status);
        }
    }

    //
    // jump out now if nothing work (as in the case of a form)
    //
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // use the join lock to set the RPC package index
    //
    EnterCriticalSection( &CsJoinLock );

    if ( CsRPCSecurityPackageIndex < 0 ) {
        CsRPCSecurityPackageIndex = packageIndex;
    }

    LeaveCriticalSection( &CsJoinLock );

    //
    // check the sponsor was in agreement with the join
    //
    if ( JoinStatus != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN]  Sponsor %1!ws! has discontinued join, status %2!u!.\n",
            sponsorName,
            JoinStatus);
        if (JoinStatus == ERROR_CLUSTER_INCOMPATIBLE_VERSIONS)
        {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[JOIN] Join version data from sponsor %1!ws! doesn't match: JH: 0x%2!08X! JL: 0x%3!08X! SH: 0x%4!08X! SL: 0x%5!08X!.\n",
                sponsorName,
                CsMyHighestVersion,
                CsMyLowestVersion,
                ClusterHighestVersion,
                ClusterLowestVersion);
            //
            // rajdas: In this case I have managed to contact a sponsor, but there is a version mismatch. If all the join
            // threads meet the same fate, clussvc should not try to form a cluster.
            // BUG ID: 152229
            //
            CsJoinStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
                
        }
        goto error_exit;
    }

    // SS: we will leave this check because win2K clusters didnt do the 
    // server side check, so the client must continue to do it
    //
    // now check that it is ok to join. We want this node to run
    // at the highest level of compatibility possible. One of the
    // following conditions must be true:
    //
    // 1) the High versions match exactly (major and build number)
    // 2) our Highest matches the sponsor's Lowest exactly, downgrading
    //    the sponsor to our level of compatibility
    // 3) our Lowest matches the sponsor's Highest, downgrading ourselves
    //    to the sponsor's level of compatibility
    //
    // note that the minor (build) version must match as well. The previous
    // version numbers are "well known" and shouldn't change when a newer
    // version is available/implemented.
    //

    if ( CsMyHighestVersion == ClusterHighestVersion ||
         CsMyHighestVersion == ClusterLowestVersion  ||
         CsMyLowestVersion == ClusterHighestVersion
#if 1 // CLUSTER_BETA
         || CsNoVersionCheck
#endif
         )
    {
        status = ERROR_SUCCESS;

    } else {

        ClRtlLogPrint(LOG_CRITICAL, 
            "[JOIN] Join version data from sponsor %1!ws! doesn't match: JH: 0x%2!08X! JL: 0x%3!08X! SH: 0x%4!08X! SL: 0x%5!08X!.\n",
            sponsorName,
            CsMyHighestVersion,
            CsMyLowestVersion,
            ClusterHighestVersion,
            ClusterLowestVersion);

        status = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;

        //
        // rajdas: In this case I have managed to contact a sponsor, but there is a version mismatch. If all the join
        // threads meet the same fate, clussvc should not try to form a cluster.
        // BUG ID: 152229
        //
        CsJoinStatus = ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
    }

error_exit:
    if (bindingHandle != NULL) {
        RpcBindingFree(&bindingHandle);
    }

    return status;
}

DWORD WINAPI
JoinpConnectThread(
    LPVOID   Parameter
    )
{
    PJOIN_SPONSOR_CONTEXT   context = (PJOIN_SPONSOR_CONTEXT) Parameter;
    LPWSTR                  sponsorName = context->Name;
    DWORD                   status;
    LPWSTR                  bindingString = NULL;
    RPC_BINDING_HANDLE      bindingHandle = NULL;
    BOOL                    setEvent = FALSE;

    //
    // Sleep for the specified delay.
    //
    if (context->Delay > 0) {
        Sleep(context->Delay);
    }

    //
    // No need to send a sponsorship request if a sponsor has
    // already been chosen.
    //
    if (CsJoinSponsorBinding != NULL) {
        ClRtlLogPrint(LOG_UNUSUAL, 
           "[JOIN] No need to ask %1!ws! to sponsor us after delay of %2!u! milliseconds.\n",
            sponsorName, context->Delay
            );
        status = RPC_S_CALL_FAILED_DNE;
        goto error_exit;
    }

    //
    // Try to connect to the specified node.
    //
    ClRtlLogPrint(LOG_UNUSUAL, 
       "[JOIN] Asking %1!ws! to sponsor us after delay of %2!u! milliseconds.\n",
        sponsorName, context->Delay
        );

    //
    // connect to the JoinVersion interface first to see if we should progress
    // any further. since this is the first RPC call to the other node, we can
    // determine which security package should be used for the other interfaces.
    //

    status = VerifyJoinVersionData( sponsorName );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] JoinVersion data for sponsor %1!ws! is invalid, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    //
    // Attempt to connect to the sponsor's extrocluster (join) RPC interface.
    //
    status = RpcStringBindingComposeW(
                 L"ffe561b8-bf15-11cf-8c5e-08002bb49649",
                 L"ncadg_ip_udp",
                 sponsorName,
                 NULL,
                 NULL,
                 &bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to compose ExtroCluster string binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    status = RpcBindingFromStringBindingW(bindingString, &bindingHandle);

    RpcStringFreeW(&bindingString);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to build ExtroCluster binding for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
        goto error_exit;
    }

    //
    // under load, the sponsor might take a while to respond back to the
    // joiner. The default timeout is at 30 secs and this seems to work
    // ok. Note that this means the sponsor has 30 secs to reply to either
    // the RPC request or ping. As long it makes any reply, then the joiner's
    // RPC will continue to wait and not time out the sponsor.
    //

    status = RpcMgmtSetComTimeout( bindingHandle, CLUSTER_EXTROCLUSTER_RPC_COM_TIMEOUT );

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[JOIN] Unable to set ExtroCluster com timeout for sponsor %1!ws!, status %2!u!.\n",
            sponsorName,
            status
            );
    }

    status = RpcEpResolveBinding(bindingHandle, ExtroCluster_v2_0_c_ifspec);

    if (status != RPC_S_OK) {
        if ( (status == RPC_S_SERVER_UNAVAILABLE) ||
             (status == RPC_S_NOT_LISTENING) ||
             (status == EPT_S_NOT_REGISTERED)
           )
        {
            ClRtlLogPrint(LOG_NOISE, 
                "[JOIN] Sponsor %1!ws! is not available (ExtroCluster), status=%2!u!.\n",
                sponsorName,
                status
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[JOIN] Unable to resolve ExtroCluster endpoint for sponsor %1!ws!, status %2!u!.\n",
                sponsorName,
                status
                );
        }
        goto error_exit;
    }

    //
    // establish a security context with this binding.
    //
    status = RpcBindingSetAuthInfoW(bindingHandle,
                                    CsServiceDomainAccount,
                                    RPC_C_AUTHN_LEVEL_CONNECT,
                                    CsRPCSecurityPackage[ CsRPCSecurityPackageIndex ],
                                    NULL,
                                    RPC_C_AUTHZ_NAME);

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[JOIN] Unable to set ExtroCluster AuthInfo using %1!ws! package, status %2!u!.\n",
                      CsRPCSecurityPackageName[ CsRPCSecurityPackageIndex ],
                      status);

        goto error_exit;
    }

error_exit:

    EnterCriticalSection(&CsJoinLock);

    if (status == RPC_S_OK) {
        if (CsJoinSponsorBinding == NULL) {
            //
            // This is the first successful connection.
            //
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[JOIN] Selecting %1!ws! as join sponsor.\n",
                sponsorName
                );

            CsJoinSponsorBinding = bindingHandle;
            bindingHandle = NULL;
            CsJoinSponsorName = sponsorName;
            sponsorName = NULL;
            SetEvent(CsJoinEvent);
        }
        else {
            ClRtlLogPrint(LOG_NOISE, 
                "[JOIN] Closing connection to sponsor %1!ws!.\n",
                sponsorName
                );
        }
    }

    if (--CsJoinThreadCount == 0) {
        CloseHandle(CsJoinEvent);
        DeleteCriticalSection(&CsJoinLock);
    }
    else if (CsJoinThreadCount == 1) {
        SetEvent(CsJoinEvent);
        LeaveCriticalSection(&CsJoinLock);
    }
    else
        LeaveCriticalSection(&CsJoinLock);

    if (bindingHandle != NULL) {
        RpcBindingFree(&bindingHandle);
    }

    if (sponsorName != NULL) {
        LocalFree(sponsorName);
    }

    LocalFree(context);

    return(status);

}  // JoinpConnectThread



DWORD
JoinpAttemptJoin(
    LPWSTR               SponsorName,
    RPC_BINDING_HANDLE   JoinMasterBinding
    )
/*++

Routine Description:

    Called to attempt to join a cluster that already exists.

Arguments:

    SponsorName - The name (or IP address) of the target sponsor.

    JoinMasterBinding - RPC binding to use to perform join.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;
    NET_API_STATUS netStatus;
    LPTIME_OF_DAY_INFO tod = NULL;
    SYSTEMTIME systemTime;
    PNM_NETWORK network;
    DWORD startseq, endseq;


#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmJoinCluster) {
        Status = 999999;
        goto error_exit;
    }
#endif

    Status = NmJoinCluster(JoinMasterBinding);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[JOIN] NmJoinCluster failed, status %1!u!.\n",
                   Status
                   );
        goto error_exit;
    }

    //
    // Synchronize the registry database
    //
#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailDmJoin) {
        Status = 999999;
        goto error_exit;
    }
#endif

    Status = DmJoin(JoinMasterBinding, &startseq);

    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] DmJoin failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }



    //
    // Initialize the event handler, needs to register with gum for cluster wide
    //events.
    Status = EpInitPhase1();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] EpInitPhase1 failed, Status = %1!u!\n",
                   Status);
        return(Status);
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailApiInitPhase1) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //
    // Bring the API online in read-only mode. There is no join phase for
    // the API. The API is required by FmOnline, which starts the
    // resource monitor.
    //
    Status = ApiOnlineReadOnly();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] ApiOnlineReadOnly failed, error = %1!u!\n",
            Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailFmJoinPhase1) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Resynchronize the FM. We cannot enable the Groups until after the
    // the API is fully operational. See below.
    //
    Status = FmJoinPhase1(&endseq);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] FmJoinPhase1 failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailDmUpdateJoinCluster) {
        Status = 999999;
        goto error_exit;
    }
#endif

    // Call the DM to hook the notifications for quorum resource and
    //event handler
    Status = DmUpdateJoinCluster();
    if (Status != ERROR_SUCCESS)
    {
            ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] DmUpdateJoin failed, error = %1!u!\n",
            Status);
            goto error_exit;
    }



#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmJoinComplete) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //
    // We are now fully online, call NM to globally change our state.
    //
    Status = NmJoinComplete(&endseq);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] NmJoinComplete failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }

    //perform the fixup for the AdminExt value on both Nt4 and Nt5 nodes.
    Status=FmFixupAdminExt();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] FmFixupAdminExt failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }


    //perform the fixups after the registry is downloaded
    //walk the list of fixups
    Status = NmPerformFixups(NM_JOIN_FIXUP);
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] NmPerformFixups failed, error %1!d!\n",
                   Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailApiInitPhase2) {
        Status = 999999;
        goto error_exit;
    }
#endif



    //
    // Finally enable the full API.
    //
    Status = ApiOnline();
    if ( Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[JOIN] ApiOnline failed, error = %1!u!\n",
            Status);
        goto error_exit;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailFmJoinPhase2) {
        Status = 999999;
        goto error_exit;
    }
#endif

    //update status for scm
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    //
    // Call back the Failover Manager to enable and move groups.
    // The full registry is now available, so all groups/resources/resource
    // types can be created (since they use the registry calls).
    //
    Status = FmJoinPhase2();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[JOIN] FmJoinPhase2 failed, status %1!d!.\n",
                   Status);
        goto error_exit;
    }


#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailEvInitialize) {
        Status = 999999;
        goto error_exit;
    }
#endif
    //
    // Finish initializing the cluster wide event logging
    //
    // ASSUMPTION: this is called after the NM has established cluster
    // membership.
    //
    if (!CsNoRepEvtLogging)
    {
        Status = EvOnline();
            //if this fails, we still start the cluster service
        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[JOIN] Error calling EvOnline, Status = %1!u!\n",
                Status);
        }
    }

    return(ERROR_SUCCESS);


error_exit:

    ClRtlLogPrint(LOG_NOISE, "[INIT] Cleaning up failed join attempt.\n");

    ClusterLeave();

    return(Status);

}





BOOL
JoinpAddNodeCallback(
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Object,
    IN LPCWSTR Name
    )
/*++

Routine Description:

    Callback enumeration routine for adding a new node. This callback
    figures out what node IDs are available.

Arguments:

    Context1 - Supplies a pointer to an array of BOOLs. The node ID for
        the enumerated node is set to FALSE.

    Context2 - Not used.

    Object - A pointer to the node object.

    Name - The node name.

Return Value:

     TRUE

--*/

{
    PBOOL Avail;
    DWORD Id;

    Id = NmGetNodeId(Object);
    CL_ASSERT(NmIsValidNodeId(Id));

    Avail = (PBOOL)Context1;

    Avail[Id] = FALSE;


    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\ioctl.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Cluster control functions.

Author:

    Mike Massa (mikemas) 23-Jan-1998

Revision History:

--*/

#include "initp.h"


//
// Parameter block used for setting all cluster properties.
//
typedef struct {
    LPWSTR                  AdminExtensions;
    DWORD                   AdminExtensionsLength;
    CLUSTER_NETWORK_ROLE    DefaultNetworkRole;
    LPWSTR                  Description;
    LPBYTE                  Security;
    DWORD                   SecurityLength;
    LPBYTE                  SecurityDescriptor;
    DWORD                   SecurityDescriptorLength;
    LPWSTR                  GroupsAdminExtensions;
    DWORD                   GroupsAdminExtensionsLength;
    LPWSTR                  NetworksAdminExtensions;
    DWORD                   NetworksAdminExtensionsLength;
    LPWSTR                  NetworkInterfacesAdminExtensions;
    DWORD                   NetworkInterfacesAdminExtensionsLength;
    LPWSTR                  NodesAdminExtensions;
    DWORD                   NodesAdminExtensionsLength;
    LPWSTR                  ResourcesAdminExtensions;
    DWORD                   ResourcesAdminExtensionsLength;
    LPWSTR                  ResourceTypesAdminExtensions;
    DWORD                   ResourceTypesAdminExtensionsLength;
    DWORD                   EnableEventLogReplication;
    DWORD                   QuorumArbitrationTimeout;
    DWORD                   QuorumArbitrationEqualizer;
    DWORD                   DisableGroupPreferredOwnerRandomization;
    DWORD                   EnableEventLogDeltaGeneration;
    DWORD                   EnableResourceDllDeadlockDetection;
    DWORD                   ResourceDllDeadlockTimeout;
    DWORD                   ResourceDllDeadlockThreshold;
    DWORD                   ResourceDllDeadlockPeriod;
    DWORD                   ClusSvcHeartbeatTimeout;
    ClussvcHangAction       HangRecoveryAction;
} CS_CLUSTER_INFO, *PCS_CLUSTER_INFO;

//
// Parameter block used for setting the cluster 'Security Descriptor' property
//
typedef struct {
    LPBYTE                  Security;
    DWORD                   SecurityLength;
} CS_CLUSTER_SECURITY_INFO, *PCS_CLUSTER_SECURITY_INFO;

//
// Parameter block used for setting the cluster 'Security' property
//
typedef struct {
    LPBYTE                  SecurityDescriptor;
    DWORD                   SecurityDescriptorLength;
} CS_CLUSTER_SD_INFO, *PCS_CLUSTER_SD_INFO;


//
// Cluster Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
CspClusterCommonProperties[] = {
    { CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, AdminExtensions)
    },
    { CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      ClusterNetworkRoleClientAccess,
      ClusterNetworkRoleNone,
      ClusterNetworkRoleInternalAndClient,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, DefaultNetworkRole)
    },
    { CLUSREG_NAME_CLUS_DESC,
      NULL,
      CLUSPROP_FORMAT_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, Description)
    },
    { CLUSREG_NAME_CLUS_SECURITY,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, Security)
    },
    { CLUSREG_NAME_CLUS_SD,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, SecurityDescriptor)
    },
    { CLUSREG_KEYNAME_GROUPS L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, GroupsAdminExtensions)
    },
    { CLUSREG_KEYNAME_NETWORKS L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, NetworksAdminExtensions)
    },
    { CLUSREG_KEYNAME_NETINTERFACES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, NetworkInterfacesAdminExtensions)
    },
    { CLUSREG_KEYNAME_NODES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, NodesAdminExtensions)
    },
    { CLUSREG_KEYNAME_RESOURCES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ResourcesAdminExtensions)
    },
    { CLUSREG_KEYNAME_RESOURCE_TYPES L"\\" CLUSREG_NAME_ADMIN_EXT,
      NULL,
      CLUSPROP_FORMAT_MULTI_SZ,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ResourceTypesAdminExtensions)
    },
    { CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      1, // default value //
      0, // min value //
      1, // max value //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, EnableEventLogReplication)
    },
    { CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      60,      // default value //
      1,       // min value //
      60 * 60, // max value // One hour for arbitration. Should be enough
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, QuorumArbitrationTimeout)
    },
    { CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      7,       // default value //
      0,       // min value //
      60 * 60, // max value // One hour for arbitration. Should be enough
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, QuorumArbitrationEqualizer)
    },
    { CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      0,       // default value // don't disable randomization
      0,       // min value //
      1,       // max value //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, DisableGroupPreferredOwnerRandomization)
    },
    { CLUSREG_NAME_CLUS_EVTLOGDELTA_GENERATION,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      1, // default value //
      0, // min value //
      1, // max value //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, EnableEventLogDeltaGeneration)
    },
    { CLUSREG_NAME_CLUS_ENABLE_RESOURCE_DLL_DEADLOCK_DETECTION,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      0, // default value //
      0, // min value //
      1, // max value //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, EnableResourceDllDeadlockDetection)
    },
    { CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_TIMEOUT,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_TIMEOUT_SECS, // default value in secs //
      CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_TIMEOUT_SECS, // min value in secs //
      CLUSTER_RESOURCE_DLL_MAXIMUM_DEADLOCK_TIMEOUT_SECS, // max value in secs //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ResourceDllDeadlockTimeout)
    },
    { CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_THRESHOLD,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_THRESHOLD, // default value in secs //
      CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_THRESHOLD, // min value in secs //
      CLUSTER_RESOURCE_DLL_MAXIMUM_DEADLOCK_THRESHOLD, // max value in secs //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ResourceDllDeadlockThreshold)
    },
    { CLUSREG_NAME_CLUS_RESOURCE_DLL_DEADLOCK_PERIOD,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      CLUSTER_RESOURCE_DLL_DEFAULT_DEADLOCK_PERIOD_SECS, // default value in secs //
      CLUSTER_RESOURCE_DLL_MINIMUM_DEADLOCK_PERIOD_SECS, // min value in secs //
      CLUSTER_RESOURCE_DLL_MAXIMUM_DEADLOCK_PERIOD_SECS, // max value in secs //
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ResourceDllDeadlockPeriod)
    },
    { CLUSTER_HEARTBEAT_TIMEOUT_KEYNAME,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      CLUSTER_HEARTBEAT_TIMEOUT_DEFAULT,
      CLUSTER_HEARTBEAT_TIMEOUT_MIN,
      0xFFFFFFFF,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, ClusSvcHeartbeatTimeout)
    },
    { CLUSTER_HANG_RECOVERY_ACTION_KEYNAME,
      NULL,
      CLUSPROP_FORMAT_DWORD,
      CLUSTER_HANG_RECOVERY_ACTION_DEFAULT,
      ClussvcHangActionDisable,
      ClussvcHangActionBugCheckMachine,
      0,
      FIELD_OFFSET(CS_CLUSTER_INFO, HangRecoveryAction)
    },  
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Property table used for setting the cluster 'Security Descriptor' property
//
RESUTIL_PROPERTY_ITEM
CspClusterSDProperty[] = {
    { CLUSREG_NAME_CLUS_SD,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_SD_INFO, SecurityDescriptor)
    },
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Property table used for setting the cluster 'Security' property
//
RESUTIL_PROPERTY_ITEM
CspClusterSecurityProperty[] = {
    { CLUSREG_NAME_CLUS_SECURITY,
      NULL,
      CLUSPROP_FORMAT_BINARY,
      0,
      0,
      0,
      0,
      FIELD_OFFSET(CS_CLUSTER_SECURITY_INFO, Security)
    },
    { NULL, NULL, 0, 0, 0, 0, 0 } };


//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
CspClusterROCommonProperties[] = {
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
CspClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    NULL,
    NULL,
    NULL
};


//
// Local Functions
//

DWORD
CspClusterControl(
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterGetCommonProperties(
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterValidateCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CspClusterSetCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CspClusterEnumPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterGetPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
CspClusterValidatePrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
CspClusterSetPrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );


DWORD
WINAPI
CsClusterControl(
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a cluster.

Arguments:

    HostNode - Supplies the host node on which the cluster control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    //
    // In the future - we should verify the access mode!
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_CLUSTER ) {
        return(ERROR_INVALID_FUNCTION);
    }

    status = CspClusterControl(
                 ControlCode,
                 InBuffer,
                 InBufferSize,
                 OutBuffer,
                 OutBufferSize,
                 BytesReturned,
                 Required
                 );

    return(status);

} // CsClusterControl



DWORD
CspClusterControl(
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    ControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD                    status;
    CLUSPROP_BUFFER_HELPER   props;
    DWORD                    bufSize;
    BOOL                     success;
    DWORD                    nameLenChars;
    DWORD                    charsLeft;

    LPWSTR  FQDNBuffer = (LPWSTR)OutBuffer;

    if (DmClusterParametersKey == NULL) {
        return(ERROR_SHARING_PAUSED);
    }

    switch ( ControlCode ) {

    case CLUSCTL_CLUSTER_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_CLUSTER_GET_COMMON_PROPERTY_FMTS:
        status = ClRtlGetPropertyFormats( CspClusterCommonProperties,
                                          OutBuffer,
                                          OutBufferSize,
                                          BytesReturned,
                                          Required );
            break;

    case CLUSCTL_CLUSTER_GET_FQDN:
        //
        // we leverage the passed in buffer directly; if the user didn't pass
        // in a large enough buffer, then clussvc won't return a partially
        // filled buffer; it will be null.
        //
        // get the length of the cluster name without the trailing null and
        // the amount of chars in the Output buffer.
        //
        nameLenChars = wcslen( CsClusterName );
        charsLeft = OutBufferSize / sizeof( WCHAR );

        if ( nameLenChars < charsLeft ) {
            //
            // output buffer is large enough to contain the name so copy it to
            // the beginning of the output buffer. wcsncpy will put a
            // terminating NULL in since the buffer is large enough to hold it.
            //
            wcsncpy( FQDNBuffer, CsClusterName, charsLeft );

            //
            // indicate remaining space by subtracting out the length of the
            // cluster name and the separating dot between the hostname and
            // the suffix.
            //
            charsLeft -= ( nameLenChars + 1 );
        } else {
            //
            // not enough space for the cluster name means we won't have
            // enough space for the domain portion.
            //
            charsLeft = 0;
        }

        //
        // charsLeft will be modified to reflect the number of chars written
        // to the buffer. If the buffer is too small, the terminating null is
        // included, otherwise the terminating null is NOT included.
        //
        success = GetComputerNameEx( ComputerNameDnsDomain,
                                     &FQDNBuffer[ nameLenChars + 1 ],
                                     &charsLeft );   

        if ( success ) {
            if ( charsLeft > 0 ) {

                //
                // there was enough space for the domain name and something
                // was copied (on NT4 DCs, there is no primary DNS suffix, so
                // GCNEx returns success but with a returned copied char count
                // of zero). Add the period between the hostname and the
                // domain suffix. If charsLeft is zero, then the name is
                // properly terminated by the wcsncpy above.
                //
                FQDNBuffer[ nameLenChars ] = L'.';
            }

            //
            // calc the total number of bytes in the buffer by adding the
            // cluster name length to the domain name length. Add one for
            // either the separating dot or the NULL terminator (in the NT4 DC
            // case). Add one at the end since the terminating null is not
            // included in charsLeft when soemthing was successfully copied.
            //
            *BytesReturned = ( nameLenChars + 1 + charsLeft + 1 ) * sizeof( WCHAR );
            status = ERROR_SUCCESS;
        } else {
            status = GetLastError();
            if ( status == ERROR_MORE_DATA ) {
                //
                // GetComputerNameEx does return the full length (including
                // the terminating null) when you don't supply a large enough
                // buffer. Sheesh!
                //
                *Required = ( nameLenChars + 1 + charsLeft ) * sizeof( WCHAR );
            } else {
                *Required = 0;
            }

            *BytesReturned = 0;
        }
        break;


    case CLUSCTL_CLUSTER_ENUM_COMMON_PROPERTIES:
        status = CspClusterEnumCommonProperties(
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES:
        status = CspClusterGetCommonProperties(
                     TRUE, // ReadOnly
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES:
        status = CspClusterGetCommonProperties(
                     FALSE, // ReadOnly
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_VALIDATE_COMMON_PROPERTIES:
        status = CspClusterValidateCommonProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES:
        status = CspClusterSetCommonProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_CLUSTER_ENUM_PRIVATE_PROPERTIES:
        status = CspClusterEnumPrivateProperties(
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES:
        status = CspClusterGetPrivateProperties(
                     DmClusterParametersKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_CLUSTER_VALIDATE_PRIVATE_PROPERTIES:
        status = CspClusterValidatePrivateProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES:
        status = CspClusterSetPrivateProperties(
                     DmClusterParametersKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    return(status);

} // CspClusterControl



DWORD
CspClusterEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given node.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties(
                 CspClusterCommonProperties,
                 OutBuffer,
                 OutBufferSize,
                 BytesReturned,
                 Required
                 );

    return(status);

} // CspClusterEnumCommonProperties



DWORD
CspClusterGetCommonProperties(
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given cluster.

Arguments:

    ReadOnly - TRUE if the read-only properties should be read.
               FALSE otherwise.

    RegistryKey - Supplies the registry key for this cluster.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    PRESUTIL_PROPERTY_ITEM  propertyTable;

    if ( ReadOnly ) {
        propertyTable = CspClusterROCommonProperties;
    } else {
        propertyTable = CspClusterCommonProperties;
    }

    //
    // Get the common properties.
    //
    status = ClRtlGetProperties( RegistryKey,
                                 &CspClusterRegApis,
                                 propertyTable,
                                 OutBuffer,
                                 OutBufferSize,
                                 BytesReturned,
                                 Required );

    return(status);

} // CspClusterGetCommonProperties


DWORD
CspValidateSecurityProperties(
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Searches for either of the security properties and validates that they are
    legitimate security descriptors.

Arguments:

    InBuffer - Supplies the buffer containing the property list.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;
    LPWSTR  propNames[] = { CLUSREG_NAME_CLUS_SD, CLUSREG_NAME_CLUS_SECURITY };
    DWORD   i;

    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;
    DWORD                   cbSecurityDescriptorSize = 0;

    //
    // See if either the "Security Descriptor" (W2K) or Security (NT4)
    // property exists in the input property list. If so, perform some basic
    // validatation.
    //
    for ( i = 0; i < RTL_NUMBER_OF( propNames ); ++i ) {
        status = ClRtlFindBinaryProperty(InBuffer,
                                         InBufferSize,
                                         propNames[i],
                                         (LPBYTE *) &pSecurityDescriptor,
                                         &cbSecurityDescriptorSize
                                         );

        if ( status == ERROR_SUCCESS ) {
            //
            // a valid security property is present; make sure it is non-null
            // and contains a valid SD
            //
            if ( cbSecurityDescriptorSize == 0 ||
                 IsValidSecurityDescriptor( pSecurityDescriptor ) == FALSE )
            {
                status = ERROR_INVALID_SECURITY_DESCR;
            }

            LocalFree( pSecurityDescriptor );
            pSecurityDescriptor = NULL;
        }
        else if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // not an error if these properties are not present
            // 
            status = ERROR_SUCCESS;
        }

        if ( status != ERROR_SUCCESS ) {
            break;
        }
    }

    return status;
}


DWORD
CspClusterValidateCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given cluster.

Arguments:

    Node - Supplies the cluster object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( CspClusterCommonProperties,
                                       NULL,     // Reserved
                                       FALSE,    // Don't allow unknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status == ERROR_SUCCESS ) {
        status = CspValidateSecurityProperties( InBuffer, InBufferSize );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[CS] ValidateCommonProperties: invalid security "
                          "property change. status %1!u!\n",
                          status);
        }
    }
    else {
        ClRtlLogPrint( LOG_CRITICAL,
                       "[CS] ValidateCommonProperties: error in verify routine. status %1!u!\n",
                       status);
    }

    return(status);

} // CspClusterValidateCommonProperties



DWORD
CspClusterSetCommonProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given cluster.

Arguments:

    Node - Supplies the cluster object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;

    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;
    DWORD                   cbSecurityDescriptorSize = 0;

    PRESUTIL_PROPERTY_ITEM  pOtherPropertyTable = NULL;
    LPBYTE                  pOtherParameterBlock = NULL;

    BOOL                    bSDFound = FALSE;
    BOOL                    bSecurityFound = FALSE;

    DWORD                   dwValue;

    //
    // Only one of securityInfo or sdInfo is going to be used at at time.
    // So use a union.
    //
    union
    {
        CS_CLUSTER_SECURITY_INFO    securityInfo;
        CS_CLUSTER_SD_INFO          sdInfo;

    } paramBlocks;


    //
    // Dummy do-while loop to avoid gotos
    //
    do
    {
        //
        // Validate the property list.
        //
        status = CspClusterValidateCommonProperties(
                     RegistryKey,
                     InBuffer,
                     InBufferSize );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_CRITICAL,
                           "[CS] ClusterSetCommonProperties, error trying to verify property table. %1!u!\n",
                           status);
            break;
        }

        //
        // Set all the properties that were passed in.
        //
        status = ClRtlSetPropertyTable(
                        NULL,
                        RegistryKey,
                        &CspClusterRegApis,
                        CspClusterCommonProperties,
                        NULL,    // Reserved
                        FALSE,   // Don't allow unknowns
                        InBuffer,
                        InBufferSize,
                        FALSE,   // bForceWrite
                        NULL
                        );

        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_CRITICAL,
                           "[CS] ClusterSetCommonProperties, error trying to set properties in table. %1!u!\n",
                           status);
            break;
        }

        //
        // Clear the parameter blocks.
        //
        ZeroMemory( &paramBlocks, sizeof( paramBlocks ) );

        //
        // See if the "Security Descriptor" property exists in the input
        // property list. If so, set the 'Security' property also.

        status = ClRtlFindBinaryProperty(
                        InBuffer,
                        InBufferSize,
                        CLUSREG_NAME_CLUS_SD,
                        (LPBYTE *) &pSecurityDescriptor,
                        &cbSecurityDescriptorSize
                        );

        if ( status == ERROR_SUCCESS ) {
            //
            // The 'Security Descriptor' property is present.
            // Choose this over the 'Security' property.
            //
            if ( cbSecurityDescriptorSize > 0 ) {
                //
                // A security descriptor of nonzero size has been found.
                // Check if this is a valid security descriptor.
                //
                if ( IsValidSecurityDescriptor( pSecurityDescriptor ) == FALSE ) {
                    //
                    // Return the most appropriate error code, since IsValidSecurityDescriptor
                    // does not provide extended error information.
                    //
                    ClRtlLogPrint( LOG_CRITICAL,
                                   "[CS] ClusterSetCommonProperties, Invalid security descriptor.\n");
                    status = ERROR_INVALID_DATA;
                    break;
                }

                paramBlocks.securityInfo.Security = ClRtlConvertClusterSDToNT4Format( pSecurityDescriptor );

                //
                //  Bail on error
                //
                if ( paramBlocks.securityInfo.Security == NULL ) {
                    status = GetLastError();
                    ClRtlLogPrint(LOG_CRITICAL,
                                  "[CS] ClusterSetCommonProperties, Unable to convert SD to NT4 format, status %1!u!\n",
                                  status);
                    break;
                }
                paramBlocks.securityInfo.SecurityLength = GetSecurityDescriptorLength(
                                                                paramBlocks.securityInfo.Security );
            }
            else {
                //
                // The security string could have been passed in, but it may be
                // a zero length buffer. In this case, we will delete the
                // Security property too.
                //
                paramBlocks.securityInfo.Security = NULL;
                paramBlocks.securityInfo.SecurityLength = 0;
            }

            bSDFound = TRUE;
            pOtherPropertyTable = CspClusterSecurityProperty;
            pOtherParameterBlock = (LPBYTE) &paramBlocks.securityInfo;
        }
        else {
            //
            // We haven't found a valid security descriptor so far.
            //
            PSECURITY_DESCRIPTOR    pSecurity = NULL;
            DWORD                   cbSecuritySize = 0;

            status = ClRtlFindBinaryProperty(
                            InBuffer,
                            InBufferSize,
                            CLUSREG_NAME_CLUS_SECURITY,
                            (LPBYTE *) &pSecurity,
                            &cbSecuritySize
                            );

            if ( status == ERROR_SUCCESS ) {
                if ( cbSecuritySize > 0 ) {
                    //
                    // A security descriptor of nonzero size has been found.
                    // Check if this is a valid security descriptor.
                    //
                    if ( IsValidSecurityDescriptor( pSecurity ) == FALSE ) {
                        //
                        // Return the most appropriate error code, since IsValidSecurityDescriptor
                        // does not provide extended error information.
                        //
                        ClRtlLogPrint( LOG_CRITICAL,
                                       "[CS] ClusterSetCommonProperties, Invalid security descriptor.\n");
                        status = ERROR_INVALID_DATA;
                        break;
                    }

                    //
                    // Since we will not be modifying the info pointed to by the parameter block,
                    // just point it to the right place in the input buffer itself.
                    // A valid NT4 security descriptor is valid for NT5 too.
                    //
                    paramBlocks.sdInfo.SecurityDescriptor = pSecurity;
                    paramBlocks.sdInfo.SecurityDescriptorLength = cbSecuritySize;
                }
                else {
                    //
                    // The security string could have been passed in, but it may be
                    // a zero length buffer. In this case, we will delete the
                    // Security Descriptor property too.
                    //
                    paramBlocks.sdInfo.SecurityDescriptor = NULL;
                    paramBlocks.sdInfo.SecurityDescriptorLength  = 0;
                }

                bSecurityFound = TRUE;
                pOtherPropertyTable = CspClusterSDProperty;
                pOtherParameterBlock = (LPBYTE) &paramBlocks.sdInfo;
            }
            else {
                //
                // We didn't find any security information.
                // Nevertheless, we were successful in setting the properties.
                //
                status = ERROR_SUCCESS;
            }
        }

        if ( ( bSDFound != FALSE ) || ( bSecurityFound != FALSE ) ) {
            PVOID                   pPropertyList = NULL;
            DWORD                   cbPropertyListSize = 0;
            DWORD                   cbBytesReturned = 0;
            DWORD                   cbBytesRequired = 0;

            //
            // Create a new property list to incorporate the changed security information.
            //
            status = ClRtlPropertyListFromParameterBlock(
                            pOtherPropertyTable,
                            NULL,                         // OUT PVOID pOutPropertyList
                            &cbPropertyListSize,          // IN OUT LPDWORD pcbOutPropertyListSize
                            pOtherParameterBlock,
                            &cbBytesReturned,
                            &cbBytesRequired
                            );

            if ( status != ERROR_MORE_DATA ) {
                //
                // We have passed in a NULL buffer, so the return code has to
                // be ERROR_MORE_DATA. Otherwise something else has gone wrong,
                // so abort.
                //
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, Error getting temporary "
                               "property list size. %1!u!\n",
                               status);
                break;
            }

            pPropertyList = LocalAlloc( LMEM_FIXED, cbBytesRequired );
            if ( pPropertyList == NULL ) {
                status = GetLastError();
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, Error allocating memory "
                               "for property list. %1!u!\n",
                               status);
                break;
            }
            cbPropertyListSize = cbBytesRequired;

            status = ClRtlPropertyListFromParameterBlock(
                            pOtherPropertyTable,
                            pPropertyList,
                            &cbPropertyListSize,
                            pOtherParameterBlock,
                            &cbBytesReturned,
                            &cbBytesRequired
                            );

            if ( status == ERROR_SUCCESS ) {
                status = ClRtlSetPropertyTable(
                                NULL,
                                RegistryKey,
                                &CspClusterRegApis,
                                pOtherPropertyTable,
                                NULL,    // Reserved
                                FALSE,   // Don't allow unknowns
                                pPropertyList,
                                cbPropertyListSize,
                                FALSE,   // bForceWrite
                                NULL
                                );
            }
            else {
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, Error creating property list. %1!u!\n",
                               status);

                LocalFree( pPropertyList );
                break;
            }

            LocalFree( pPropertyList );

            if ( status != ERROR_SUCCESS ) {
                ClRtlLogPrint( LOG_CRITICAL,
                               "[CS] ClusterSetCommonProperties, error in setting property table. %1!u!\n",
                               status);
                break;
            }
        }
    }
    while ( FALSE ); // do-while: dummy loop to avoid gotos

    if (status == ERROR_SUCCESS) {
        if ( ERROR_SUCCESS == ClRtlFindDwordProperty(
                InBuffer,
                InBufferSize,
                CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
                &dwValue) )
        {
            ClRtlLogPrint( LOG_UNUSUAL, "[CS] Arbitration Timeout is changed %1!d! => %2!d!.\n",
                MmQuorumArbitrationTimeout, dwValue);
            MmQuorumArbitrationTimeout = dwValue;
        }
        if ( ERROR_SUCCESS == ClRtlFindDwordProperty(
                InBuffer,
                InBufferSize,
                CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER,
                &dwValue) )
        {
            ClRtlLogPrint( LOG_UNUSUAL, "[CS] Arbitration Equalizer is changed %1!d! => %2!d!.\n",
                MmQuorumArbitrationEqualizer, dwValue);
            MmQuorumArbitrationEqualizer = dwValue;
        }
        if ( ClRtlFindDwordProperty(
                InBuffer,
                InBufferSize,
                CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION,
                &dwValue ) == ERROR_SUCCESS )
        {
            ClRtlLogPrint(LOG_NOISE, "[CS] Cluster common property %1!ws! is changed to %2!u!...\n",
                          CLUSREG_NAME_DISABLE_GROUP_PREFERRED_OWNER_RANDOMIZATION, 
                          dwValue);
        }        
    }

    //
    // If the 'Security Descriptor' property was found, free the memory allocated,
    // to store the NT4 security descriptor.
    //
    if ( bSDFound != FALSE ) {
        LocalFree( paramBlocks.securityInfo.Security );
    }

    return(status);

} // CspClusterSetCommonProperties



DWORD
CspClusterEnumPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given cluster.

Arguments:

    RegistryKey - Registry key for the cluster.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;
    DWORD       status;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster cluster parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );

    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enum the private properties for the cluster.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &CspClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // CspClusterEnumPrivateProperties



DWORD
CspClusterGetPrivateProperties(
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given cluster.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster\parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the cluster.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &CspClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // CspClusterGetPrivateProperties



DWORD
CspClusterValidatePrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given cluster.

Arguments:

    RegistryKey - Registry key for the cluster.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // CspClusterValidatePrivateProperties



DWORD
CspClusterSetPrivateProperties(
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given cluster.

Arguments:

    RegistryKey - Registry key for the cluster.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster\parameters key
        //
        parametersKey = DmOpenKey( RegistryKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   MAXIMUM_ALLOWED );
        if ( parametersKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                parametersKey = DmCreateKey( RegistryKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             0,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &disposition );
                if ( parametersKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              parametersKey,
                                              &CspClusterRegApis,
                                              InBuffer,
                                              InBufferSize );

        DmCloseKey( parametersKey );
    }

    return(status);

} // CspClusterSetPrivateProperties


void
CsRefreshGlobalsFromRegistry()
{
    DWORD dwValue;
    DWORD status;

    // Currently the only globals that are read once from the registry are two MM globals.
    if( ERROR_SUCCESS == DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
                 &dwValue, NULL) )
    {
        if ( MmQuorumArbitrationTimeout != dwValue ) {
	        MmQuorumArbitrationTimeout = dwValue;
	        ClRtlLogPrint(LOG_NOISE, 
	            "[CS] MmQuorumArbitrationTimeout: %1!d!.\n", dwValue);
        }
    }

    if( ERROR_SUCCESS == DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER,
                 &dwValue, NULL) )
    {
        if ( MmQuorumArbitrationEqualizer != dwValue ) {
            MmQuorumArbitrationEqualizer = dwValue;
            ClRtlLogPrint(LOG_NOISE, 
                "[CS] MmQuorumArbitrationEqualizer: %1!d!.\n", dwValue);
        }
    }

    // No need to check return value or log anything here -- the routine does its own logging,
    // and if we fail to read the cluster SD from the registry, it will be set to NULL and a default
    // SD will be used.
    InitializeClusterSD();

    //
    // Check if resource dll deadlock detection is enabled.
    //
    FmCheckIsDeadlockDetectionEnabled (); 
} // CspRefreshGlobalsFromRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\qfs.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    Qfs.c

Abstract:

    Redirection layer for quorum access

Author:

    GorN 19-Sep-2001

Revision History:

TODO:
    Support more than one Qfs provider

--*/

#define QFS_DO_NOT_UNMAP_WIN32  // get access to regular CreateFile, etc

#ifndef DUMB_CLIENT
#include "service.h"
#endif
#include "QfsTrans.h"

#include <stdlib.h>
#include <stdarg.h>
#include <Imagehlp.h>

#ifndef min
#define min(a, b)   ((a) < (b) ? (a) : (b))
#endif

////////////////// Debug Junk //////////////////

int QfsLogLevel = 0;

void
debug_log(char *format, ...)
{
    va_list marker;

    va_start(marker, format);

#ifdef DUMB_CLIENT
    if (QfsLogLevel > 2) {
        printf("%d:%x:",GetTickCount(), GetCurrentThreadId());
        vprintf(format, marker);
    }
#else
    {
        char buf[1024];
        vsprintf(buf, format, marker);
        ClRtlLogPrint(LOG_NOISE, "%1!hs!\r\n",buf);
    }    
#endif    

    va_end(marker);
    
}

void
error_log(char *format, ...)
{
    va_list marker;

    va_start(marker, format);

#ifdef DUMB_CLIENT
    if (QfsLogLevel > 0) {
        printf("*E %d:%x:",GetTickCount(), GetCurrentThreadId());
        vprintf(format, marker);
    }
#else
    {
        char buf[1024];
        vsprintf(buf, format, marker);
        ClRtlLogPrint(LOG_ERROR, "%1!hs!\r\n",buf);
    }    
#endif    

    va_end(marker);

}

#ifndef QfsError
#  define QfsError(x) error_log x
#endif
#ifndef QfsNoise
#  define QfsNoise(x) debug_log x
#endif

// When give a UNS path that looks like a Qfs path
// we contact the Qfs server and query whether it
// recognizes that path. If it is, we cache this recognized
// path in QfsPath veriable, so that next time we 
// can immediately pass the request coming to this path to Qfs

WCHAR QfsPath[MAX_PATH];
UINT ccQfsPath = 0;
CRITICAL_SECTION QfsCriticalSection;
SHARED_MEM_SERVER Client;

VOID QfsInitialize()
{
    InitializeCriticalSection(&QfsCriticalSection);
    MemClient_Init(&Client);
}

VOID QfsCleanup()
{
    MemClient_Cleanup(&Client);
    DeleteCriticalSection(&QfsCriticalSection);
}

#define AcquireExclusive() EnterCriticalSection(&QfsCriticalSection)
#define ReleaseExclusive() LeaveCriticalSection(&QfsCriticalSection)

#define UpgradeToExclusive() (0)

#define AcquireShared() EnterCriticalSection(&QfsCriticalSection)
#define ReleaseShared() LeaveCriticalSection(&QfsCriticalSection)

// the whole transport interface is incapsulated in 
// three functions
//    ReserveBuffer, DeliverBuffer and RelaseBuffer
// The pattern of usage is
//
//   ReserveBuffer(Operation, Path or Handle)
//      [gets a pointer to a job buffer if Path or Handle belong to Qfs]
//      Copy in parameters to a buffer
//   DeliverBuffer
//      Copy out parameters from a buffer
//   ReleaseBuffer

DWORD QfspReserveBuffer(
    DWORD OpCode, 
    LPCWSTR FileName, 
    QfsHANDLE* HandlePtr,
    PJOB_BUF *pj);
    
BOOL QfspDeliverBuffer(
    PJOB_BUF j,
    DWORD* Status);

void QfspReleaseBuffer(
    PJOB_BUF j);

BOOL QfspDeliverBufferInternal(
    LPWSTR PipeName,
    LPVOID buf,
    DWORD len,
    DWORD timeout,
    DWORD* Status
    );

DWORD QfspReserveBufferNoChecks(
    DWORD OpCode, 
    LPCWSTR FileName, 
    QfsHANDLE* HandlePtr,
    PJOB_BUF *pj);

LPCWSTR SkipUncPrefix(
    IN LPCWSTR p, 
    OUT LPBOOL bIsShareName)
/*++

Routine Description:

    If the passed string looks like \\?\unc, or \\ strip the prefix and set pIsShareName to true

Outputs:

    bIsShareName - set to TRUE if the path looks like UNC path and to FALSE otherwise

Returns:

    The path without \\?\unc or \\ prefix, if it is a UNC path, otherwise returns p

--*/
{
    if (p[0] == '\\' && p[1] == '\\') {
        *bIsShareName = TRUE;
        p += 2;
        if (p[0]=='?' && p[1]=='\\' && p[2]=='U' && p[3]=='N' && p[4]=='C' && p[5] == '\\') {
            p += 6;
            if (p[0] != 0 && p[1]==':') {
                p += 2;
                if (p[0] == '\\') {
                    ++p;
                }
                *bIsShareName = FALSE;
            }
        }
    } else {
        *bIsShareName = FALSE;
    }
    return p;
}

BOOL IsQfsPath(LPCWSTR Path)
/*++

Routine Description:

    Checks whether the path looks like a QfsPath

    This routine has fast and slow path.
    If QfsPath is set and is a valid prefix of Path, the function immediately returns
    Otherwise, it delivers opConnect request to the QfsServer to verify that it can 
    handle this path.

    If QfsServer is not running, it will get a connection failure
    If QfsServer is up and recognizes the path, we set QfsPath, so that we don't 
    have to do all this when we called next time for a similar path

Inputs:

    Path,
    QfsPath global

Side effects:

    Sets QfsPath if succesfully talked to Qfs server.

--*/
{    
    BOOL IsShare;
    PWCHAR p;
    WCHAR shareName[MAX_PATH];
    JobBuf_t *j;
    SIZE_T len;
    DWORD Status=ERROR_NO_MATCH;
    
    Path = SkipUncPrefix(Path, &IsShare);
    if (!IsShare) {
        SetLastError(Status);
        return FALSE;
    }
    
    AcquireShared();
    if (ccQfsPath) {
        if (wcsncmp(Path, QfsPath, ccQfsPath) == 0) {
            ReleaseShared();
            return TRUE;
        }
    }
    ReleaseShared();
    
    p = wcschr(Path, '$');
    if (p == NULL || p[1] !='\\' ) {
        SetLastError(Status);
        return FALSE;
    }
    len = p - Path + 2;
    if (len+10 >= MAX_PATH) {
        SetLastError(Status);
        return FALSE;
    }
    CopyMemory(shareName, Path, (len) * sizeof(WCHAR));
    shareName[len] = 0;

    // We are trying to connect to MNS now to verify the share path. We need to zero
    // out the length field (ccQfsPath). Look at QfspCopyPath().
    //
    AcquireExclusive();
    ccQfsPath = 0;
    ReleaseExclusive();

    Status = QfspReserveBufferNoChecks(opConnect, shareName, 0, &j);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return FALSE;
    }

    // Get the clussvc process ID.
    j->ClussvcProcessId = GetCurrentProcessId();
    QfspDeliverBuffer(j,&Status);
    QfspReleaseBuffer(j);
    
    if (Status == ERROR_SUCCESS) {
        AcquireExclusive();
        wcscpy(QfsPath, shareName);
        ccQfsPath = (DWORD)len;
        ReleaseExclusive();
        
        QfsNoise(("[Qfs] QfsPath %ws", QfsPath));
        // need to update
    } else {
        SetLastError(Status);
        return FALSE;
    }
    return TRUE;
}

// QfsINVALID_HANDLE_VALUE is to be used in place of INVALID_HANDLE_VALUE
// to initalize hadle of QfsHANDLE type

QfsHANDLE QfsINVALID_HANDLE_VALUE = {INVALID_HANDLE_VALUE, 0};

#define HandlePtr(x) (&(x))

BOOL IsQfsHandle(QfsHANDLE handle)
{
    return handle.IsQfs;
}

HANDLE GetRealHandle(QfsHANDLE QfsHandle) 
{
    return QfsHandle.realHandle;
}

QfsHANDLE MakeQfsHandle(HANDLE handle)
{
    QfsHANDLE result;
    result.IsQfs = 1;
    result.realHandle = handle;
    return result;
}

QfsHANDLE MakeWin32Handle(HANDLE handle)
{
    QfsHANDLE result;
    result.IsQfs = 0;
    result.realHandle = handle;
    return result;
}

//////////////////////////////////////////////////////////////////

#undef malloc
#undef free

#define malloc(dwBytes) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes)
#define free(hHeap) HeapFree(GetProcessHeap(), 0, hHeap)

DWORD QfspCopyPath(
    OUT LPVOID Buf,
    IN DWORD BufSize,
    IN LPCWSTR FileName)
/*++

Routine Description:

    Copy path without QfsPath prefix.
    Ie it will take:

    \\.\UNC\12378\234-79879-87987$\a\b and transforms it into \a\b

    Sets QfsPath if succesfully talked to Qfs server.

WARNING: It is a coller responsibility to make sure that the buffer
    is large enough to fit the filename

--*/
{
    BOOL bIsShare;
    DWORD cbLen;
    
    FileName = SkipUncPrefix(FileName, &bIsShare) + ccQfsPath; 
    cbLen = sizeof(WCHAR) * (wcslen(FileName)+1);

    if (cbLen > BufSize) {
        return ERROR_BAD_PATHNAME;
    }    
    CopyMemory(Buf, FileName, cbLen);
    return ERROR_SUCCESS;
}

DWORD QfspReserveBufferNoChecks(
    DWORD OpCode, 
    LPCWSTR FileName, 
    QfsHANDLE* HandlePtr,
    PJOB_BUF *pj)
/*++

Routine Description:

    Prepares a job buffer.

    Sets the OpCode, copies FileName and Handle if present

Output:

    If the operation is successful, the pointer to a job buffer is returned in *pj    

--*/
{
    PJOB_BUF j;
    DWORD status;

    status = MemClient_ReserveBuffer(&Client, &j);
    if (status != ERROR_SUCCESS) {
        return status;
    }

    j->hdr.OpCode = OpCode;
    if (HandlePtr) {
        j->Handle = GetRealHandle(*HandlePtr);
    }
    if (FileName) {
        status = QfspCopyPath(j->Buffer, sizeof(j->Buffer), FileName);
        if (status != ERROR_SUCCESS) {
            free(j);
            return  status;
        }
    }
    *pj = j;
    return ERROR_SUCCESS;
}

DWORD QfspReserveBuffer(
    DWORD OpCode, 
    LPCWSTR FileName, 
    QfsHANDLE* HandlePtr,
    PJOB_BUF *pj)
/*++

Routine Description:

    Prepares a job buffer.

    Sets the OpCode, copies FileName and Handle if present

Return codes:

    ERROR_NO_MATCH: the handle or path do not belong to Qfs, 
                                  the caller needs to use regular Win32 i/o APIs

--*/
{
    if(HandlePtr &&  GetRealHandle(*HandlePtr) == INVALID_HANDLE_VALUE) return ERROR_INVALID_HANDLE;
    if(FileName && !IsQfsPath(FileName)) return ERROR_NO_MATCH;
    if(HandlePtr && !IsQfsHandle(*HandlePtr)) return ERROR_NO_MATCH;
    
    return QfspReserveBufferNoChecks(OpCode, FileName, HandlePtr, pj);
}

BOOL QfspDeliverBuffer(
    PJOB_BUF j,
    DWORD* Status)
{
    *Status = MemClient_DeliverBuffer(j);
    if (*Status == ERROR_SUCCESS) {
        *Status = j->hdr.Status;
    }
    return *Status == ERROR_SUCCESS;
}    

void QfspReleaseBuffer(
    PJOB_BUF j)
{
    MemClient_Release(j);
}


////////////////////////////////////////////////////////////////////
// Redirection shims, most of them follow the following pattern
//
//   ReserveBuffer(Operation, Path or Handle)
//      [gets a pointer to a job buffer if Path or Handle belong to Qfs]
//      Copy in parameters to a buffer
//   DeliverBuffer
//      Copy out parameters from a buffer
//   ReleaseBuffer
//
//   If ReserveBuffer failed with error NO_MATCH, calls regular Win32 API
//
////////////////////////////////////////////////////////////////////

#define StatusFromBool(expr) (Status = (expr)?ERROR_SUCCESS:GetLastError())
#define BoolToStatus(expr) StatusFromBool(expr)
#define StatusFromHandle(expr) (Status = ((expr) != INVALID_HANDLE_VALUE)?ERROR_SUCCESS:GetLastError())

BOOL QfsCloseHandle(
  QfsHANDLE hObject   // handle to object
)
{
    PJOB_BUF j;
    DWORD Status = QfspReserveBuffer(opCloseFile, NULL, HandlePtr(hObject), &j);

    if (Status == ERROR_SUCCESS) {
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        Status = CloseHandle(GetRealHandle(hObject))?ERROR_SUCCESS:GetLastError();
    }
    QfsNoise(("[Qfs] QfsCloseHandle %x, status %d", GetRealHandle(hObject), Status));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;        
}

DWORD QfspRemapCreateFileStatus(DWORD Status, DWORD DispReq, DWORD DispAct)
{
    if (Status == ERROR_ALREADY_EXISTS && DispReq == CREATE_NEW) 
        return ERROR_FILE_EXISTS;
        
    if (Status != ERROR_SUCCESS) 
        return Status;

    if (DispAct != OPEN_EXISTING)
        return Status;

    if (DispReq == CREATE_ALWAYS || DispReq == OPEN_ALWAYS)
        return ERROR_ALREADY_EXISTS;

    return Status;
}

QfsHANDLE QfsCreateFile(
  LPCWSTR lpFileName,                         // file name
  DWORD dwDesiredAccess,                      // access mode
  DWORD dwShareMode,                          // share mode
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition,                // how to create
  DWORD dwFlagsAndAttributes,                 // file attributes
  HANDLE hTemplateFile                        // handle to template file
)
{
    QfsHANDLE Result=QfsINVALID_HANDLE_VALUE;
    PJOB_BUF j;
    DWORD Status = QfspReserveBuffer(opCreateFile, lpFileName, NULL, &j);
    
    if (Status == ERROR_SUCCESS) {
        
        j->dwDesiredAccess = dwDesiredAccess;
        j->dwShareMode = dwShareMode;
        j->dwCreationDisposition = dwCreationDisposition;
        j->dwFlagsAndAttributes = dwFlagsAndAttributes;

        if( QfspDeliverBuffer(j, &Status) ) {
            Result = MakeQfsHandle(j->Handle);
        } else {
            Result = QfsINVALID_HANDLE_VALUE; 
        }

        Status = QfspRemapCreateFileStatus(Status, 
            dwCreationDisposition,  j->dwCreationDisposition);
            
        dwCreationDisposition = j->dwCreationDisposition;        
        QfspReleaseBuffer(j);
        
    } else if (Status == ERROR_NO_MATCH) {

        Result = MakeWin32Handle(
            CreateFile(
                lpFileName, dwDesiredAccess, dwShareMode, 
                lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile)
        );

        Status = GetLastError();
    }
    QfsNoise(("[Qfs] QfsOpenFile %ws => %x, %x status %d", lpFileName, dwCreationDisposition, Result, Status));
    SetLastError(Status);
    return Result;
}


// little helper structure that simplifies printing a sample of 
// a buffer data for debugging

typedef struct _sig { char sig[5]; } SIG;

SIG Prefix(LPCVOID lpBuffer) {
    char* p = (char*)lpBuffer;
    SIG Result = {"...."};
    if (isalpha(p[0])) Result.sig[0] = p[0];
    if (isalpha(p[1])) Result.sig[1] = p[1];
    if (isalpha(p[2])) Result.sig[2] = p[2];
    if (isalpha(p[3])) Result.sig[3] = p[3];
    return Result;
}


// NOWHOW MNS interprets WriteFile with Size zero as SetEndOfFile //
BOOL QfsWriteFile(
  QfsHANDLE hFile,                    // handle to file
  LPCVOID lpBuffer,                // data buffer
  DWORD nNumberOfBytesToWrite,     // number of bytes to write
  LPDWORD lpNumberOfBytesWritten,  // number of bytes written
  LPOVERLAPPED lpOverlapped        // overlapped buffer
) 
{
    PJOB_BUF j; 
    ULONG PreOffset = 0, PostOffset = 0;
    DWORD Status = QfspReserveBuffer(opWriteFile, NULL, HandlePtr(hFile), &j);
    if (Status == ERROR_SUCCESS) {        
        DWORD nRemainingBytes = nNumberOfBytesToWrite;
        const char* BufferWalker = lpBuffer;

        if (lpOverlapped) {
            j->Offset = lpOverlapped->Offset;
        } else {
            j->Offset = ~0; // use file pointer
        }
        PreOffset = (ULONG)j->Offset;        
        do {
            j->cbSize = (USHORT)min(JOB_BUF_MAX_BUFFER, nRemainingBytes) ;
            CopyMemory(j->Buffer, BufferWalker, j->cbSize);
            if (QfspDeliverBuffer(j, &Status)) {
                nRemainingBytes -= j->cbSize;
                BufferWalker +=  j->cbSize;              
            } else {
                break;
            }
        } while (nRemainingBytes > 0 && j->cbSize > 0);
        if (lpNumberOfBytesWritten) {
            *lpNumberOfBytesWritten = nNumberOfBytesToWrite - nRemainingBytes;
        }
        PostOffset = (ULONG)j->Offset;
        QfspReleaseBuffer(j);
        
    } else if (Status == ERROR_NO_MATCH) {
        if(WriteFile(GetRealHandle(hFile), lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped)) {
            Status = ERROR_SUCCESS;
        } else {
            Status = GetLastError();
        }
    }
    QfsNoise(("[Qfs] WriteFile %x (%s) %d, status %d (%d=>%d)", GetRealHandle(hFile), Prefix(lpBuffer).sig, 
        nNumberOfBytesToWrite, Status, PreOffset, PostOffset));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsReadFile(
  QfsHANDLE hFile,                // handle to file
  LPVOID lpBuffer,             // data buffer
  DWORD nNumberOfBytesToRead,  // number of bytes to read
  LPDWORD lpNumberOfBytesRead, // number of bytes read
  LPOVERLAPPED lpOverlapped    // overlapped buffer
)
{
    PJOB_BUF j; ULONG PreOffset = 0, PostOffset = 0;
    DWORD Status = QfspReserveBuffer(opReadFile, NULL, HandlePtr(hFile), &j);
    if (Status == ERROR_SUCCESS) {        
        DWORD nRemainingBytes = nNumberOfBytesToRead;
        PCHAR BufferWalker = lpBuffer;
        
        if (lpOverlapped) {
            j->Offset = lpOverlapped->Offset;
        } else {
            j->Offset = (ULONGLONG)-1; // use file pointer
        }

        PreOffset = (ULONG)j->Offset;
        do {
            j->cbSize = (USHORT)min(JOB_BUF_MAX_BUFFER, nRemainingBytes);
            if (QfspDeliverBuffer(j, &Status)) {
                CopyMemory(BufferWalker, j->Buffer, j->cbSize);
                nRemainingBytes -= j->cbSize;
                BufferWalker +=  j->cbSize;              
            } else {
                break;
            }
        } while (nRemainingBytes > 0 && j->cbSize > 0);
        if (lpNumberOfBytesRead) {
            *lpNumberOfBytesRead = nNumberOfBytesToRead - nRemainingBytes;
        }
        PostOffset = (ULONG)j->Offset;
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        if(ReadFile(GetRealHandle(hFile), lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped)) {
            Status = ERROR_SUCCESS;
        } else {
            Status = GetLastError();
        }
    }
    QfsNoise(("[Qfs] ReadFile %x (%s) %d %d, (%d=>%d) %x status %d", 
        GetRealHandle(hFile), &Prefix(lpBuffer).sig, 
        nNumberOfBytesToRead, *lpNumberOfBytesRead, 
        PreOffset, PostOffset,  lpOverlapped, Status));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsFlushFileBuffers(
  QfsHANDLE hFile  // handle to file
)
{
    PJOB_BUF j;
    DWORD Status = QfspReserveBuffer(opFlushFile, NULL, HandlePtr(hFile), &j);
    if (Status == ERROR_SUCCESS) {                
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        Status = FlushFileBuffers(GetRealHandle(hFile))?ERROR_SUCCESS:GetLastError();
    }
    QfsNoise(("[Qfs] QfsFlushBuffers %x, status %d", GetRealHandle(hFile), Status));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsDeleteFile(
   LPCTSTR lpFileName
)
{
    PJOB_BUF j;
    DWORD Status = QfspReserveBuffer(opDeleteFile, lpFileName, NULL, &j);
    if (Status == ERROR_SUCCESS) {                
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        Status = DeleteFile(lpFileName)?ERROR_SUCCESS:GetLastError();
    }
    QfsNoise(("[Qfs] QfsDeleteFile %ws, status %d", lpFileName, Status));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsRemoveDirectory(
   LPCTSTR lpFileName
)
{
    PJOB_BUF j;
    DWORD Status = QfspReserveBuffer(opDeleteFile, lpFileName, NULL, &j);
    if (Status == ERROR_SUCCESS) {                
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        Status = RemoveDirectory(lpFileName)?ERROR_SUCCESS:GetLastError();
    }
    QfsNoise(("[Qfs] QfsRemoveDirectory %ws, status %d", lpFileName, Status));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

QfsHANDLE QfsFindFirstFile(
  LPCWSTR lpFileName,               // file name
  LPWIN32_FIND_DATA lpFindFileData  // data buffer
) 
{
    QfsHANDLE Result=QfsINVALID_HANDLE_VALUE; 
    PJOB_BUF j;
    DWORD Status = QfspReserveBuffer(opFindFirstFile, lpFileName, NULL, &j);
    if (Status == ERROR_SUCCESS) {                
        if(QfspDeliverBuffer(j, &Status)) {
            Result = MakeQfsHandle(j->Handle);
            *lpFindFileData = j->FindFileData;
        } else {
            Result = QfsINVALID_HANDLE_VALUE;
        }
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        Result = MakeWin32Handle(
            FindFirstFile(lpFileName, lpFindFileData)
        );
        Status = QfsIsHandleValid(Result)?ERROR_SUCCESS:GetLastError();
    }
    QfsNoise(("[Qfs] QfsFindFirstFile %ws => %x,  error %d", lpFileName, GetRealHandle(Result),  Status));    
    SetLastError(Status);
    return Result;
}

BOOL QfsFindNextFile(
  QfsHANDLE hFindFile,                // search handle 
  LPWIN32_FIND_DATA lpFindFileData // data buffer
)
{
    PJOB_BUF j;
    DWORD Status = QfspReserveBuffer(opFindNextFile, NULL, HandlePtr(hFindFile), &j);
    if (Status == ERROR_SUCCESS) {                
        if(QfspDeliverBuffer(j, &Status)) {
            *lpFindFileData = j->FindFileData;
        }
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        StatusFromBool( FindNextFile(GetRealHandle(hFindFile), lpFindFileData) );
    }        
    QfsNoise(("[Qfs] QfsFindNextFile %x", GetRealHandle(hFindFile)));    
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsFindClose(
  QfsHANDLE hFindFile   // file search handle
)
{
    PJOB_BUF j; 
    DWORD Status = QfspReserveBuffer(opFindClose, NULL, HandlePtr(hFindFile), &j);
    if (Status == ERROR_SUCCESS) {
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        StatusFromBool( FindClose(GetRealHandle(hFindFile)) );
    }
    QfsNoise(("[Qfs] QfsFindClose %x", GetRealHandle(hFindFile)));    
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsCreateDirectory(
  LPCWSTR lpPathName,                         // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
)
{
    PJOB_BUF j; 
    DWORD Status = QfspReserveBuffer(opCreateDir, lpPathName, NULL, &j);
    if (Status == ERROR_SUCCESS) {
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        StatusFromBool( CreateDirectory(lpPathName, lpSecurityAttributes) );
    }
    QfsNoise(("[Qfs] QfsCreateDirectory %ws, status %d", lpPathName, Status));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsGetDiskFreeSpaceEx(
  LPCTSTR lpDirectoryName,                 // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
)
{
    PJOB_BUF j; 
    DWORD Status = QfspReserveBuffer(opGetDiskFreeSpace, lpDirectoryName, NULL, &j);
    if (Status == ERROR_SUCCESS) {
        if(QfspDeliverBuffer(j, &Status)) {
            lpFreeBytesAvailable->QuadPart = j->FreeBytesAvailable;
            lpTotalNumberOfBytes->QuadPart = j->TotalNumberOfBytes;
            if (lpTotalNumberOfFreeBytes) {
                lpTotalNumberOfFreeBytes->QuadPart = j->TotalNumberOfFreeBytes;
            }
        }
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        StatusFromBool( GetDiskFreeSpaceEx(lpDirectoryName, lpFreeBytesAvailable, 
                                          lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes) );
    }
    QfsNoise(("[Qfs] GetDiskFreeSpaceEx %ws, status %d", lpDirectoryName, Status));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsGetFileSizeEx(
  QfsHANDLE hFile,           // handle to file
  PLARGE_INTEGER lpFileSize)  // file size
{
    PJOB_BUF j; 
    DWORD Status = QfspReserveBuffer(opGetAttr, NULL, HandlePtr(hFile), &j);
    if (Status == ERROR_SUCCESS) {
        if(QfspDeliverBuffer(j, &Status)) {
            lpFileSize->QuadPart = j->EndOfFile;
        }
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        StatusFromBool( GetFileSizeEx(GetRealHandle(hFile), lpFileSize) );
    }        
    QfsNoise(("[Qfs] QfsGetFileSize %x %I64d", GetRealHandle(hFile), lpFileSize->QuadPart));
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

DWORD QfsGetFileSize(
  QfsHANDLE hFile,           // handle to file
  LPDWORD lpFileSizeHigh)  // high-order word of file size
{
    LARGE_INTEGER Li;
    if ( QfsGetFileSizeEx(hFile,&Li) ) {
        if ( lpFileSizeHigh ) {
            *lpFileSizeHigh = (DWORD)Li.HighPart;
        }
        if (Li.LowPart == -1 ) {
            SetLastError(0);
        }
    } else {
        Li.LowPart = -1;
    }
    return Li.LowPart;
}

// NOWHOW MNS interprets WriteFile with Size zero as SetEndOfFile //
DWORD QfsSetEndOfFile(
    QfsHANDLE hFile,
    LONGLONG Offset
)
{
    PJOB_BUF j; 
    DWORD Status = QfspReserveBuffer(opWriteFile, NULL, HandlePtr(hFile), &j);
    if (Status == ERROR_SUCCESS) {
        j->Offset = Offset; 
        j->cbSize = 0;
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        Status = SetFilePointerEx(GetRealHandle(hFile), *(PLARGE_INTEGER)&Offset, NULL, FILE_BEGIN);
        if (Status != 0xFFFFFFFF && SetEndOfFile(GetRealHandle(hFile))) {
            Status = ERROR_SUCCESS;
        } else {
            Status = GetLastError();
        }
    }
    QfsNoise(("[Qfs] QfsSetEndOfFile %x %d, Status %d", GetRealHandle(hFile), Offset, Status));
    return Status;
}

DWORD QfsIsOnline(
    IN  LPCWSTR Path,
    OUT BOOL *pfOnline
) 
{
    PJOB_BUF j;
    DWORD Status=ERROR_NO_MATCH;
    
    if (IsQfsPath(Path)) {
        // This is a MNS path.
        // Try to perform null operation on the server.
        //
        Status = QfspReserveBufferNoChecks(opNone, NULL, NULL, &j);
        if (Status == ERROR_SUCCESS) {
            *pfOnline = QfspDeliverBuffer(j, &Status);
            QfspReleaseBuffer(j);
        }
        else {
            *pfOnline = FALSE;
        }
    }
    else {
        // Cases:
        // 1. If this is not MNS path, should return ERROR_NO_MATCH.
        // 2. If this is MNS path, but MNS not online, should return some other error value.
        // 
        // Soln: IsQfsPath() now returns the error value through SetLastError().
        //
        Status = GetLastError();
        *pfOnline = FALSE;
    }
    
    QfsNoise(("[Qfs] QfsIsOnline => %d, Status %d", *pfOnline, Status)); 
    return Status; 
}

HANDLE QfsCreateFileMapping(
  QfsHANDLE hFile,                       // handle to file
  LPSECURITY_ATTRIBUTES lpAttributes, // security
  DWORD flProtect,                    // protection
  DWORD dwMaximumSizeHigh,            // high-order DWORD of size
  DWORD dwMaximumSizeLow,             // low-order DWORD of size
  LPCTSTR lpName                      // object name
)
{
    if (IsQfsHandle(hFile)) {
        QfsError(("[Qfs] !!!!! CreateFileMapping for qfs handle !!!!! %x", hFile));
        return  INVALID_HANDLE_VALUE;
    } else {
        return CreateFileMapping(GetRealHandle(hFile), lpAttributes, flProtect, 
            dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
    }        
}

BOOL QfsGetOverlappedResult(
  QfsHANDLE hFile,                       // handle to file, pipe, or device
  LPOVERLAPPED lpOverlapped,          // overlapped structure
  LPDWORD lpNumberOfBytesTransferred, // bytes transferred
  BOOL bWait                          // wait option
)
{
    if (IsQfsHandle(hFile)) {
        QfsError(("[Qfs] GetOverlappedResults for qfs handle !!!%x", hFile));
        return FALSE;
    } else {
        return GetOverlappedResult(GetRealHandle(hFile), lpOverlapped,
            lpNumberOfBytesTransferred, bWait);
    }        
}

BOOL QfsSetFileAttributes(
  LPCWSTR lpFileName,      // file name
  DWORD dwFileAttributes   // attributes
)
{
    PJOB_BUF j; 
    DWORD Status = QfspReserveBuffer(opSetAttr2, lpFileName, NULL, &j);
    if (Status == ERROR_SUCCESS) {
        j->EndOfFile = 0;
        j->AllocationSize = 0;
        j->CreationTime = 0;
        j->LastAccessTime = 0;
        j->LastWriteTime = 0;
        j->FileAttributes = dwFileAttributes;
        QfspDeliverBuffer(j, &Status);
        QfspReleaseBuffer(j);
    } else if (Status == ERROR_NO_MATCH) {
        StatusFromBool( SetFileAttributes(lpFileName, dwFileAttributes) );
    }       
    QfsNoise(("[Qfs] QfsSetFileAttributes %ws %x, status %d", lpFileName, dwFileAttributes, Status));    
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

BOOL QfsCopyFile(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    return QfsCopyFileEx(
            lpExistingFileName,
            lpNewFileName,
            (LPPROGRESS_ROUTINE)NULL,
            (LPVOID)NULL,
            (LPBOOL)NULL,
            bFailIfExists ? COPY_FILE_FAIL_IF_EXISTS : 0
            );
}

// We have to implement our own version of CopyFile,
// using Qfs apis, if either a source or destination contain QfsPath

#define BUF_SIZE (32 * 1024)

#define COPY_FILE_FLUSH_BUFFERS 1

DWORD QfspCopyFileInternal(
    LPCWSTR lpSrc, 
    LPCWSTR lpDst, 
    LPBOOL pbCancel, 
    DWORD dwCopyFlags,
    DWORD ExtraFlags)
{
    QfsHANDLE src = QfsINVALID_HANDLE_VALUE;
    QfsHANDLE dst = QfsINVALID_HANDLE_VALUE;
    DWORD dstDisp;
    char* buf = malloc(65536);
    DWORD Status=ERROR_SUCCESS;
    
    if (buf == NULL) {
        Status = GetLastError();
        goto exit;
    }

    if (dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) {
        dstDisp = CREATE_NEW;
    } else {
        dstDisp = CREATE_ALWAYS;
    }

    src = QfsCreateFile(lpSrc, 
        GENERIC_READ, 
        FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, 
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (!QfsIsHandleValid(src)) {
        Status = GetLastError();
        goto exit;
    }

    dst = QfsCreateFile(lpDst, 
        GENERIC_WRITE, 
        FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, 
        dstDisp, FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (!QfsIsHandleValid(dst)) {
        Status = GetLastError();
        goto exit;
    }
        
    for(;;) {
        DWORD dwSize;
        if (pbCancel && *pbCancel) {
            Status = ERROR_OPERATION_ABORTED;
            goto exit;
        }
        if ( !QfsReadFile(src, buf, BUF_SIZE, &dwSize, NULL) ) {
            Status = GetLastError(); 
            goto exit;
        }
        if (dwSize == 0) {
            break;
        }
        if (pbCancel && *pbCancel) {
            Status = ERROR_OPERATION_ABORTED;
            goto exit;
        }
        if (!QfsWriteFile(dst, buf, dwSize, &dwSize, NULL) ) {
            Status = GetLastError(); 
            goto exit;
        }
    }
    if (ExtraFlags & COPY_FILE_FLUSH_BUFFERS) {
        QfsFlushFileBuffers(dst);
    }

exit:
    QfsCloseHandleIfValid(src);
    QfsCloseHandleIfValid(dst);
    if (buf) { free(buf); }
    return Status;
}

BOOL QfsCopyFileEx(
  LPCWSTR lpExistingFileName,           // name of existing file
  LPCWSTR lpNewFileName,                // name of new file
  LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
  LPVOID lpData,                        // callback parameter
  LPBOOL pbCancel,                      // cancel status
  DWORD dwCopyFlags                     // copy options
)
{
    DWORD Status;
    if (!IsQfsPath(lpExistingFileName) && !IsQfsPath(lpNewFileName)) {
        BoolToStatus( CopyFileEx(lpExistingFileName, lpNewFileName, lpProgressRoutine, 
                lpData, pbCancel, dwCopyFlags) );
    } else if (lpProgressRoutine || (dwCopyFlags & COPY_FILE_RESTARTABLE)) {
        Status = ERROR_INVALID_PARAMETER;
    } else {
        Status = QfspCopyFileInternal(
            lpExistingFileName, lpNewFileName, pbCancel, dwCopyFlags, 0);
    }
    QfsNoise(("[Qfs] QfsCopyFileEx %ws=>%ws, status %d", lpExistingFileName, lpNewFileName, Status));    
    return Status == ERROR_SUCCESS;        
}

BOOL QfsMoveFileEx(
  LPCWSTR lpExistingFileName,  // file name
  LPCWSTR lpNewFileName,       // new file name
  DWORD dwFlags                // move options
)
{
    BOOL bSrcQfs = IsQfsPath(lpExistingFileName);
    BOOL bDstQfs = IsQfsPath(lpNewFileName);
    DWORD Status;
    if (!bSrcQfs && !bDstQfs) {
        BoolToStatus( MoveFileEx(lpExistingFileName, lpNewFileName, dwFlags) );
    } else if (bSrcQfs && bDstQfs) {
        PJOB_BUF j; 
        Status = QfspReserveBuffer(opRename, lpExistingFileName, NULL, &j);
        if (Status == ERROR_SUCCESS) {
            Status = QfspCopyPath(j->FileNameDest, sizeof(j->FileNameDest), lpNewFileName);
            if (Status == ERROR_SUCCESS) {
                QfspDeliverBuffer(j, &Status);
            }
            QfspReleaseBuffer(j);
        }
    } else {
        BoolToStatus(
            QfsClRtlCopyFileAndFlushBuffers(lpExistingFileName, lpNewFileName) );
        if (Status == ERROR_SUCCESS) {
            BoolToStatus(QfsDeleteFile(lpExistingFileName));
        }
    }
    QfsNoise(("[Qfs] QfsMoveFileEx %ws=>%ws", lpExistingFileName, lpNewFileName));    
    SetLastError(Status);
    return Status == ERROR_SUCCESS;
}

// GetTempFileName had to be shimmed so that it can work over Qfs path

UINT QfsGetTempFileName(
  LPCWSTR lpPathName,      // directory name
  LPCWSTR lpPrefixString,  // file name prefix
  UINT uUnique,            // integer
  LPWSTR lpTempFileName    // file name buffer
)
{
    DWORD Status = ERROR_SUCCESS;
    
    if ( IsQfsPath(lpPathName) ) {
        int len;
        
        wcscpy(lpTempFileName, lpPathName);
        wcscat(lpTempFileName, lpPrefixString);
        len = wcslen(lpTempFileName);

        uUnique = uUnique & 0x0000ffff;
        if (uUnique) {
            wsprintf(lpTempFileName+len, L"%04x.tmp", uUnique);
        } else {
            DWORD uStartPoint = GetTickCount() & 0x0000ffff | 1;
            uUnique = uStartPoint;
        
            for(;;) {
                QfsHANDLE hdl;
                
                wsprintf(lpTempFileName+len, L"%04x.tmp", uUnique);

                hdl  = QfsCreateFile(lpTempFileName, GENERIC_WRITE, 
                    FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_NEW, 0, 0);
                if (QfsIsHandleValid(hdl)) {
                    QfsCloseHandle(hdl);
                    break;
                }
                Status = GetLastError();
                if (Status == ERROR_ALREADY_EXISTS 
                 ||Status == ERROR_FILE_EXISTS
                 ||Status == ERROR_SHARING_VIOLATION
                 ||Status == ERROR_ACCESS_DENIED)
                {
                    uUnique = (uUnique + 1) & 0xFFFF;
                    if (uUnique == 0) { ++uUnique; }
                    if (uUnique == uStartPoint) {
                        SetLastError(Status = ERROR_NO_MORE_FILES);
                        break;
                    }
                } else {
                    break;
                }
            }
        }        
    } else { // not QfsPath
        uUnique = GetTempFileName(
            lpPathName, lpPrefixString, uUnique, lpTempFileName);
        if (uUnique == 0) {
            Status = GetLastError();
            lpTempFileName[0] = 0;
        }
    }

    QfsNoise(("[Qfs] QfsGetTempFileName %ws, %ws, %d => %ws, status %d", 
        lpPathName, lpPrefixString, uUnique, lpTempFileName, Status));    
    
    return uUnique;
}

// Helper routine for QfsRegSaveKey and QfsMapFileAndCheckSum
// creates thread specific TempFile name

DWORD QfspThreadTempFileName(
    OUT LPWSTR Path // assumes MAX_PATH size
    )
{
    DWORD Status = GetModuleFileName(NULL, Path, MAX_PATH);
    PWCHAR p;
    if (Status == 0) {
        return GetLastError();
    }
    if (Status == MAX_PATH) {
        return ERROR_BUFFER_OVERFLOW;
    }
    p = wcsrchr(Path, '\\');
    if (p == NULL) {
        return ERROR_PATH_NOT_FOUND;
    }
    wsprintf(p+1, L"Qfs%x.tmp", GetCurrentThreadId());
    QfsNoise(("[Qfs] TempName generated %ws", p));
    return ERROR_SUCCESS;
}

// Saves registry key in a temporary file on the system disk
// then copies it onto the quorum

LONG QfsRegSaveKey(
  HKEY hKey,                                  // handle to key
  LPCWSTR lpFile,                             // data file
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
)
{
    DWORD Status;
    if (IsQfsPath(lpFile)) {
        WCHAR TempName[MAX_PATH];
        Status = QfspThreadTempFileName(TempName);
        if (Status == ERROR_SUCCESS) {
            DeleteFile(TempName);
            Status = RegSaveKey(hKey, TempName, lpSecurityAttributes);
            if (Status == ERROR_SUCCESS) {
                BoolToStatus( QfsMoveFile(TempName, lpFile) );
            }
        }
    } else {
        Status = RegSaveKey(hKey, lpFile, lpSecurityAttributes);
    }
    QfsNoise(("[Qfs] QfsRegSaveKey %ws, status %d", 
        lpFile, Status));    
    return Status;
}

#ifndef DUMB_CLIENT

// Computes a checksome for the file on the quorum disk,
// by copying it to the temp file on the system disk and invoking regular MapFileAndChecksum API

DWORD QfsMapFileAndCheckSum(
  LPCWSTR Filename,      
  PDWORD HeaderSum,  
  PDWORD CheckSum    
)
{
    DWORD RetCode = 1, Status;
    if (IsQfsPath(Filename)) {
        WCHAR TempName[MAX_PATH];
        Status = QfspThreadTempFileName(TempName);
        if (Status == ERROR_SUCCESS) {
            DeleteFile(TempName);
            if (QfsCopyFile(Filename, TempName, 0)) {
                RetCode = MapFileAndCheckSum((LPWSTR)TempName, HeaderSum, CheckSum);
                DeleteFile(TempName);
            }
        }
    } else {
        RetCode = MapFileAndCheckSum((LPWSTR)Filename, HeaderSum, CheckSum);
    }
    Status = RetCode ? GetLastError() : ERROR_SUCCESS;
    QfsNoise(("[Qfs] QfsMapFileAndCheckSum %ws, ret %d status %d", 
        Filename, RetCode, Status));
    return RetCode;
}

// Some of the ClRtl function has to be redone here.
// The reason is that ClRtl is not Qfs aware and cannot call Qfs shims directly

DWORD
QfsSetFileSecurityInfo(
    IN LPCWSTR          lpszFile,
    IN DWORD            dwAdminMask,
    IN DWORD            dwOwnerMask,
    IN DWORD            dwEveryoneMask
    )
{
    HANDLE hFile;
    DWORD dwError;
    
    if (IsQfsPath(lpszFile)) {
        // don't do this for QFS shares
        return ERROR_SUCCESS;
    } 
    
    hFile = CreateFile(lpszFile,
        GENERIC_READ|WRITE_DAC|READ_CONTROL,
        0,
        NULL,
        OPEN_ALWAYS,
        FILE_FLAG_BACKUP_SEMANTICS,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[Qfs] QfsSetFileSecurityInfo - Failed to open file %1!ws!, Status=%2!u!\n",
            lpszFile,
            dwError);
        return dwError;
    }

    dwError = ClRtlSetObjSecurityInfo(hFile, 
        SE_FILE_OBJECT,
        dwAdminMask, 
        dwOwnerMask, 
        dwEveryoneMask);
    CloseHandle(hFile);
    
    return dwError;
}

#endif

BOOL
QfsClRtlCopyFileAndFlushBuffers(
    IN LPCWSTR lpszSourceFile,
    IN LPCWSTR lpszDestinationFile
    )
{
    DWORD Status = QfspCopyFileInternal(
        lpszSourceFile, lpszDestinationFile, 
        NULL, 0, COPY_FILE_FLUSH_BUFFERS);
    
    return Status == ERROR_SUCCESS;
}

BOOL QfsClRtlCreateDirectory(
    IN LPCWSTR lpszPath
    )
{
    WCHAR   cSlash = L'\\';
    DWORD   dwLen;
    LPCWSTR pszNext;
    WCHAR   lpszDir[MAX_PATH];
    LPWSTR  pszDirPath=NULL;
    DWORD   dwError = ERROR_SUCCESS;

    if (!lpszPath || ((dwLen=lstrlenW(lpszPath)) < 1))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    pszDirPath = (LPWSTR)LocalAlloc(LMEM_FIXED, ((dwLen + 2) * sizeof(WCHAR)));
    if (pszDirPath == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(pszDirPath, lpszPath);

    //if it doesnt terminate with \, terminate it
    if (pszDirPath[dwLen-1] != cSlash)
    {
        pszDirPath[dwLen] = cSlash;
        pszDirPath[dwLen+1] = L'\0';
    }

    dwLen = lstrlenW(pszDirPath);
    //handle SMB Path names e.g \\xyz\abc\lmn
    if ((dwLen > 2) && (pszDirPath[0]== L'\\') && (pszDirPath[1] == L'\\'))
    {
        //check if the name if of format \\?\UNC\XYZ\ABC\LMN
        // or if the format \\?\C:\xyz\abz
        if ((dwLen >3) && (pszDirPath[2] == L'?'))
        {
            //search for the \ after ?
            pszNext = wcschr(pszDirPath + 2, cSlash);
            //check if it is followed by UNC
            if (pszNext)
            {
                if (!wcsncmp(pszNext+1, L"UNC", lstrlenW(L"UNC")))
                {
                    //it is a UNC Path name
                    //move past the third slash from here
                    pszNext = wcschr(pszNext+1, cSlash);
                    if (pszNext) 
                        pszNext = wcschr(pszNext+1, cSlash);
                    if (pszNext) 
                        pszNext = wcschr(pszNext+1, cSlash);
                }
                else
                {
                    //it is a volume name, move to the next slash
                    pszNext = wcschr(pszNext+1, cSlash);
                }
            }                
        }
        else
        {
            //it is of type \\xyz\abc\lmn
            pszNext = wcschr(pszDirPath + 2, cSlash);
            if (pszNext) 
                pszNext = wcschr(pszNext+1, cSlash);
        }
    }
    else
    {
        pszNext = pszDirPath;
        pszNext = wcschr(pszNext, cSlash);
        // if the character before the first \ is :, skip the creation
        // of the c:\ level directory
        if (pszNext && pszNext > pszDirPath)
        {
            pszNext--;
            if (*pszNext == L':')
            {
                pszNext++;
                pszNext = wcschr(pszNext+1, cSlash);
            }
            else
                pszNext++;
        }
    }
    
    while ( pszNext)
    {
        DWORD_PTR dwptrLen;

        dwptrLen = pszNext - pszDirPath + 1;

        dwLen=(DWORD)dwptrLen;
        lstrcpynW(lpszDir, pszDirPath, dwLen+1);

        if (!QfsCreateDirectory(lpszDir, NULL))
        {
            dwError = GetLastError();
            if (dwError == ERROR_ALREADY_EXISTS)
            {
                //this is not a problem,continue
                dwError = ERROR_SUCCESS;
            }
            else
            {
                QfsError(("[ClRtl] CreateDirectory Failed on %ws. Error %u",
                    lpszDir, dwError));
                goto FnExit;
            }
        }

        pszNext = wcschr(pszNext+1, cSlash);
    }

FnExit:
    if (pszDirPath) LocalFree(pszDirPath);
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\restore.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    restore.c

Abstract:

    Functions supporting the restoration of the cluster database 
    to the quorum disk

Author:

    Chittur Subbaraman (chitturs) 27-Oct-1998


Revision History:

--*/
#define QFS_DO_NOT_UNMAP_WIN32
#include "initp.h"
#include "winioctl.h"
#include <stdio.h>
#include <stdlib.h>
#include "strsafe.h"

//
//  Static global variables used only in this file
//
//  static LPWSTR  szRdbpNodeNameList = NULL;
//  static DWORD   dwRdbpNodeCount = 0;

/****
@func       DWORD | RdbStopSvcOnNodes | Stop the requested service
            on the given node list

@parm       IN PNM_NODE_ENUM2 | pNodeEnum | Pointer to the list of
            nodes in which the requested service has to be stopped.
            
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       This function attempts to stop the chosen service on the chosen
            list of nodes. If it fails in stopping the service on any
            one of the nodes, it returns a Win32 error code.

            At this time, this function DOES NOT STOP a cluster service
            which is run as a process in a remote node.

@xref       <f RdbStartSvcOnNodes> 
****/
DWORD
RdbStopSvcOnNodes(
    IN PNM_NODE_ENUM2 pNodeEnum,
    IN LPCWSTR lpszServiceName
    )
{
    SC_HANDLE       hService;
    SC_HANDLE       hSCManager;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwRetryTime;
    DWORD           dwRetryTick;
    SERVICE_STATUS  serviceStatus;
    WCHAR           szNodeName[CS_MAX_NODE_NAME_LENGTH + 1];
    DWORD           i;
    BOOL            bStopCommandGiven;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
#if 0
    //  
    //  Allocate storage for the node names which you would use to
    //  start the service later. Memory is freed in RdbpStartSvcOnNodes
    //
    if ( pNodeEnum->NodeCount > 0 )
    {
        szRdbpNodeNameList = ( LPWSTR ) LocalAlloc( LMEM_FIXED,
                                                      sizeof ( WCHAR) *
                                                      ( CS_MAX_NODE_NAME_LENGTH + 1 ) *
                                                      pNodeEnum->NodeCount );
        if ( szRdbpNodeNameList == NULL )
        {            
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStopSvcOnNodes: Unable to allocate memory for node names, Error = %1!d!\n",
                  GetLastError());
        } 
    }
#endif
    //
    //  Walk through the list of nodes
    //
    for ( i=0; i<pNodeEnum->NodeCount; i++ )
    {  
        ( void ) StringCchCopy( szNodeName, RTL_NUMBER_OF ( szNodeName ), pNodeEnum->NodeList[i].NodeName );
        //
        //  Skip the local node, if it is included in the list
        //
        if ( ( lstrcmpW ( szNodeName, NmLocalNodeName ) == 0 ) )
        {
            continue;
        }
        // 
        //  Try for 2 minutes max to stop the service on a node. Retry
        //  in steps of 5 secs.
        //
        dwRetryTime = 120 * 1000;
        dwRetryTick = 05 * 1000;

        //
        //  Open a handle to the service control manager
        //
        hSCManager = OpenSCManager( szNodeName,
                                    NULL,
                                    SC_MANAGER_ALL_ACCESS );
        if ( hSCManager == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStopSvcOnNodes: Unable to open SC manager on node %1!ws!, Error = %2!d!\n",
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Open a handle to the service
        //
        hService = OpenService( hSCManager,
                                lpszServiceName,
                                SERVICE_ALL_ACCESS );
                                     
        CloseServiceHandle( hSCManager );
        
        if ( hService == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStopSvcOnNodes: Unable to open handle to %1!ws! service on node %2!ws!, Error = %3!d!\n",
                  lpszServiceName,
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Check whether the service is already in the SERVICE_STOPPED
        //  state.
        //
        if ( QueryServiceStatus( hService,
                                 &serviceStatus ) ) 
        {
            if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
            {
                ClRtlLogPrint(LOG_NOISE, 
                    "[INIT] RdbStopSvcOnNodes: %1!ws! on node %2!ws! already stopped\n",
                      lpszServiceName,
                      szNodeName);
                CloseServiceHandle( hService );
                continue;
            }
        }
        
        bStopCommandGiven = FALSE;
        
        while ( TRUE ) 
        {
            dwStatus = ERROR_SUCCESS;
            if ( bStopCommandGiven == TRUE )
            {
                if ( QueryServiceStatus( hService,
                                         &serviceStatus ) ) 
                {
                    if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
                    {
                        //
                        //  Succeeded in stopping the service
                        //
                        ClRtlLogPrint(LOG_NOISE, 
                            "[INIT] RdbStopSvcOnNodes: %1!ws! on node %2!ws! stopped successfully\n",
                            lpszServiceName,
                            szNodeName);
                        break;                    
                    }
                } else
                {
                    dwStatus = GetLastError();
                    ClRtlLogPrint(LOG_ERROR, 
                        "[INIT] RdbStopSvcOnNodes: Error %3!d! in querying status of %1!ws! on node %2!ws!\n",
                        lpszServiceName,
                        szNodeName,
                        dwStatus);
                }
            } else
            {
                if ( ControlService( hService,
                                     SERVICE_CONTROL_STOP,
                                     &serviceStatus ) ) 
                {
                    bStopCommandGiven = TRUE;
                    dwStatus = ERROR_SUCCESS;
                } else
                {
                    dwStatus = GetLastError();
                    ClRtlLogPrint(LOG_ERROR, 
                        "[INIT] RdbStopSvcOnNodes: Error %3!d! in trying to stop %1!ws! on node %2!ws!\n",
                        lpszServiceName,
                        szNodeName,
                        dwStatus);
                }
            }

            if ( ( dwStatus == ERROR_EXCEPTION_IN_SERVICE ) ||
                 ( dwStatus == ERROR_PROCESS_ABORTED ) ||
                 ( dwStatus == ERROR_SERVICE_NOT_ACTIVE ) ) 
            {
                //
                //  The service is essentially in a terminated state
                //
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] RdbStopSvcOnNodes: %1!ws! on node %2!ws! died/inactive\n",
                        lpszServiceName,
                        szNodeName);
                dwStatus = ERROR_SUCCESS;
                break;
            }

            if ( ( dwRetryTime -= dwRetryTick ) <= 0 ) 
            {
                //
                //  All tries to stop the service failed, exit from this
                //  function with an error code
                //
                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[INIT] RdbStopSvcOnNodes: Service %1!ws! service on node %2!ws! did not stop, giving up...\n",
                        lpszServiceName,
                        szNodeName);
                dwStatus = ERROR_TIMEOUT;
                break;
            }

            ClRtlLogPrint(LOG_NOISE, 
                   "[INIT] RdbStopSvcOnNodes: Trying to stop %1!ws! on node %2!ws!\n",
                     lpszServiceName,
                     szNodeName);
            //
            //  Sleep for a while and retry stopping the service
            //
            Sleep( dwRetryTick );
        } // while
    
        CloseServiceHandle( hService );
        
        if ( dwStatus != ERROR_SUCCESS )
        {
            goto FnExit;
        }
#if 0
        //
        //  Save the node name for later use when starting the service
        //
        if ( szRdbpNodeNameList != NULL )
        {
            lstrcpyW( szRdbpNodeNameList + dwRdbpNodeCount *
                                           ( CS_MAX_NODE_NAME_LENGTH + 1 ), 
                      szNodeName );
            dwRdbpNodeCount++;
        }
#endif
    } // for

FnExit:
    return( dwStatus );   
}

/****
@func       DWORD | RdbGetRestoreDbParams | Check the registry and see
            whether the restore database option is set. If so, get the
            params.

@parm       IN HKEY | hKey | Handle to the cluster service parameters key
            
@comm       This function attempts read the registry and return the 
            parameters for the restore database operation.

@xref       <f CspGetServiceParams> 
****/
VOID 
RdbGetRestoreDbParams( 
    IN HKEY hClusSvcKey 
    )
{
    DWORD   dwLength = 0;
    DWORD   dwType;
    DWORD   dwStatus;
    DWORD   dwForceDatabaseRestore;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    if ( hClusSvcKey == NULL ) 
    {
        return;
    }

    //  
    //  Try to query the clussvc parameters key. If the RestoreDatabase
    //  value is present, then get the length of the restore database
    //  path. 
    //
    if ( ClRtlRegQueryString( hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_RESTORE_DB,
                              REG_SZ,
                              &CsDatabaseRestorePath,
                              &dwLength,
                              &dwLength ) != ERROR_SUCCESS )
    {
        goto FnExit; 
    }

    ClRtlLogPrint(LOG_NOISE, 
              "[INIT] RdbGetRestoreDbparams: Restore Cluster Database is in progress...\n");

    CsDatabaseRestore = TRUE;
    
    //  
    //  Try to query the clussvc parameters key for the ForceRestoreDatabase
    //  value. Don't bother to delete the param, since the 
    //  RestoreClusterDatabase API will do it.
    //
    if ( ClRtlRegQueryDword(  hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB,
                              &dwForceDatabaseRestore,
                              NULL ) != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE, 
                      "[INIT] RdbGetRestoreDbparams: ForceRestoreDatabase params key is absent or unreadable\n"
                      );
        goto FnExit;
    }
            
    CsForceDatabaseRestore = TRUE; 

    //  
    //  Try to query the clussvc parameters key for the NewQuorumDriveLetter
    //  value. Check for the validity of the drive letter later when
    //  you attempt to fix up stuff. 
    //
    dwLength = 0;
    if ( ClRtlRegQueryString( hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER,
                              REG_SZ,
                              &CsQuorumDriveLetter,
                              &dwLength,
                              &dwLength ) != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE, 
                      "[INIT] RdbGetRestoreDbparams: NewQuorumDriveLetter params key is absent or unreadable\n"
                      );
    }

FnExit:
    //
    //  Make sure you delete these registry values read above. It is OK if you fail in finding
    //  some of these values. Note that the RestoreClusterDatabase API will also try to clean
    //  up these values. We cannot assume that the API will clean up these values since the
    //  values could be set by (a) ASR (b) A user by hand, and not always by the API.
    //
    RdbpDeleteRestoreDbParams();
}

/****
@func       DWORD | RdbFixupQuorumDiskSignature | Fixup the quorum disk
            signature with the supplied value, if necessary

@parm       IN DWORD | dwSignature | The new signature which must be
            written to the quorum disk.
            
@rdesc      Returns a non-zero value if successful. 0 on failure.

@comm       This function attempts to write the given signature into
            the physical quorum disk, if necessary.

@xref       <f RdbStartSvcOnNodes> 
****/
BOOL
RdbFixupQuorumDiskSignature(
    IN DWORD dwSignature
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       dwStatus;
    BOOL        bStatus = 1;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    if ( ( dwSignature == 0 ) ||
         ( lstrlenW ( CsQuorumDriveLetter ) != 2 ) ||
         ( !iswalpha( CsQuorumDriveLetter[0] ) ) ||
         ( CsQuorumDriveLetter[1] != L':' ) )
    {
        bStatus = 0;
        goto FnExit;
    }

    //
    //  Now try to open the quorum disk device
    //
    if ( ( dwStatus = RdbpOpenDiskDevice ( CsQuorumDriveLetter, &hFile ) ) 
            != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbFixupQuorumDiskSignature: Error %1!d! in opening %2!ws!\n",
                dwStatus,
                CsQuorumDriveLetter
            );
        bStatus = 0;
        goto FnExit;
    }

    //
    //  Get the signature from the drive, compare it with the input
    //  parameter and if they are different, write new signature to
    //  disk.
    //
    if ( ( dwStatus = RdbpCompareAndWriteSignatureToDisk( hFile, dwSignature ) )
            != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbFixupQuorumDiskSignature: Error %1!d! in attempting to write signature to %2!ws!\n",
                dwStatus,
                CsQuorumDriveLetter
            );
        bStatus = 0;
        goto FnExit;     
    }
    
FnExit:
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }
    return ( bStatus );   
}

/****
@func       DWORD | RdbpOpenDiskDevice | Open and get a handle
            to a physical disk device

@parm       IN LPCWSTR | lpDriveLetter | The disk drive letter.

@parm       OUT PHANDLE | pFileHandle | Pointer to the handle to the open 
            device.
            
@rdesc      Returns ERROR_SUCCESS if successful. A Win32 error code on 
            failure.

@comm       This function attempts to open a disk device and return a
            handle to it. Different ways are used to open the device.
          
@xref       <f RdbFixupQuorumDiskSignature> 
****/
DWORD
RdbpOpenDiskDevice(
    IN  LPCWSTR  lpDriveLetter,
    OUT PHANDLE  pFileHandle
    )
{
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               accessMode;
    DWORD               shareMode;
    DWORD               dwStatus;
    BOOL                bFailed = FALSE;
    WCHAR               deviceNameString[128];

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    //  Note it is important to access the device with 0 access mode 
    //  so that the file open code won't do extra I/O to the device.
    //
    shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    accessMode = GENERIC_READ | GENERIC_WRITE;

    ( void ) StringCchCopy( deviceNameString, RTL_NUMBER_OF ( deviceNameString ), L"\\\\.\\" );
    ( void ) StringCchCat( deviceNameString, RTL_NUMBER_OF ( deviceNameString ), lpDriveLetter );

    hFile = CreateFileW( deviceNameString,
                         accessMode,
                         shareMode,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) 
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;
    *pFileHandle = hFile;

FnExit:
    return( dwStatus );
}

/****
@func       DWORD | RdbpCompareAndWriteSignatureToDisk | Compare the
            signature on disk with the input parameter and if they
            are not the same, write the input parameter as a new signature.

@parm       IN HANDLE | hFile | Handle to the disk device.

@parm       IN DWORD | dwSignature | Signature to be compared with
            exisiting disk signature.
            
@rdesc      Returns ERROR_SUCCESS if successful. A Win32 error code on 
            failure.

@comm       This function attempts to first get the drive layout, read the
            signature information, and then if necessary write back a
            new signature to the drive. [This code is stolen from Rod's 
            clusdisk\test\disktest.c and then adapted to suit our needs.]
          
@xref       <f RdbFixupQuorumDiskSignature> 
****/
DWORD
RdbpCompareAndWriteSignatureToDisk(
    IN  HANDLE  hFile,
    IN  DWORD   dwSignature
    )
{
    DWORD                       dwStatus;
    DWORD                       dwBytesReturned;
    DWORD                       dwDriveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION   pDriveLayout = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 10/30/98
    //
    if ( !ClRtlGetDriveLayoutTable( hFile, &pDriveLayout, &dwBytesReturned )) {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbpCompareAndWriteSignatureToDisk: Error %1!d! in getting "
             "drive layout from %2!ws!\n",
             dwStatus,
             CsQuorumDriveLetter
            );
        goto FnExit;
    }

    dwDriveLayoutSize = sizeof( DRIVE_LAYOUT_INFORMATION ) +
                          ( sizeof( PARTITION_INFORMATION ) *
                                ( pDriveLayout->PartitionCount - 1 ) );

    if ( dwBytesReturned < dwDriveLayoutSize ) 
    {
        ClRtlLogPrint(LOG_ERROR,
          "[INIT] RdbpCompareAndWriteSignatureToDisk: Error reading driveLayout information. Expected %1!u! bytes, got %2!u! bytes.\n",
            dwDriveLayoutSize, 
            dwBytesReturned
          );
        dwStatus = ERROR_INSUFFICIENT_BUFFER;
        goto FnExit;
    }

    if ( pDriveLayout->Signature == dwSignature )
    {
        dwStatus = ERROR_SUCCESS;
        ClRtlLogPrint(LOG_NOISE,
          "[INIT] RdbpCompareAndWriteSignatureToDisk: Disk %1!ws! signature is same as in registry. No fixup needed\n",
             CsQuorumDriveLetter
          );
        goto FnExit;
    }
    //
    //  Change just the signature field and send an ioctl down
    //
    pDriveLayout->Signature = dwSignature;
    
    if ( !DeviceIoControl( hFile,
                           IOCTL_DISK_SET_DRIVE_LAYOUT,
                           pDriveLayout,
                           dwDriveLayoutSize,
                           NULL,
                           0,
                           &dwBytesReturned,
                           FALSE ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_ERROR, 
            "[INIT] RdbpCompareAndWriteSignatureToDisk: Error %1!d! in setting drive layout to %2!ws!\n",
                dwStatus,
                CsQuorumDriveLetter
            );
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE, 
              "[INIT] RdbpCompareAndWriteSignatureToDisk: Quorum disk signature fixed successfully\n"
              );

FnExit:
    if ( pDriveLayout != NULL ) {
        LocalFree( pDriveLayout );
    }

    return( dwStatus );
}

#if 0
/****
@func       DWORD | RdbStartSvcOnNodes | Start the cluster service on
            the nodes in which you stopped the service.

@parm       IN LPCWSTR | lpszServiceName | Name of the service to start.
           
@rdesc      Returns a Win32 error code on failure. ERROR_SUCCESS on success.

@comm       This function attempts to start the service on the nodes on
            which it stopped the service for a restoration operation.

@xref       <f RdbStopSvcOnNodes> 
****/
DWORD
RdbStartSvcOnNodes(
    IN LPCWSTR  lpszServiceName
    )
{
    SC_HANDLE       hService;
    SC_HANDLE       hSCManager;
    DWORD           dwStatus = ERROR_SUCCESS;
    SERVICE_STATUS  serviceStatus;
    WCHAR           szNodeName[CS_MAX_NODE_NAME_LENGTH + 1];
    DWORD           i;
    //
    //  Chittur Subbaraman (chitturs) - 11/4/98
    //
    //  Walk through the list of nodes
    //
    for ( i=0; i<dwRdbpNodeCount; i++ )
    {  
        lstrcpyW( szNodeName, szRdbpNodeNameList + i *
                                                   ( CS_MAX_NODE_NAME_LENGTH + 1 ) );
        
        //
        //  Open a handle to the service control manager
        //
        hSCManager = OpenSCManager( szNodeName,
                                    NULL,
                                    SC_MANAGER_ALL_ACCESS );
        if ( hSCManager == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStartSvcOnNodes: Unable to open SC manager on node %1!ws!, Error = %2!d!\n",
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Open a handle to the service
        //
        hService = OpenService( hSCManager,
                                lpszServiceName,
                                SERVICE_ALL_ACCESS );
                                     
        CloseServiceHandle( hSCManager );
        
        if ( hService == NULL ) 
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[INIT] RdbStartSvcOnNodes: Unable to open handle to %1!ws! service on node %2!ws!, Error = %3!d!\n",
                  lpszServiceName,
                  szNodeName,
                  dwStatus);
            continue;
        }

        //
        //  Check whether the service is already started.
        //
        if ( QueryServiceStatus( hService,
                                 &serviceStatus ) ) 
        {
            if ( ( serviceStatus.dwCurrentState == SERVICE_RUNNING ) ||
                 ( serviceStatus.dwCurrentState == SERVICE_START_PENDING ) )
            {
                ClRtlLogPrint(LOG_NOISE, 
                    "[INIT] RdbStartSvcOnNodes: %1!ws! on node %2!ws! already started\n",
                      lpszServiceName,
                      szNodeName);
                CloseServiceHandle( hService );
                continue;
            }
        }
        
        //
        //  Now, start the cluster service
        //
        if ( !StartService( hService,
                            0,
                            NULL ) )
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_ERROR, 
                      "[INIT] RdbStartSvcOnNodes: Unable to start cluster service on %1!ws!\n",
                        szNodeName
                      );  
        } else
        {
            ClRtlLogPrint(LOG_ERROR, 
                      "[INIT] RdbStartSvcOnNodes: Cluster service started on %1!ws!\n",
                        szNodeName
                      );  
        }
        //
        //  And, close the current handle
        //
        CloseServiceHandle( hService );   
   } // for

   //
   //  Now free the memory
   //
   LocalFree( szRdbpNodeNameList );

   return( dwStatus );   
}
#endif

/****
@func       DWORD | RdbInitialize | This function performs the
            initialization steps necessary for the restore database
            manager. Specifically, copy the most recent checkpoint
            file from the backup path to the cluster directory overwriting
            the CLUSDB there.
                      
@rdesc      Returns a Win32 error code if the operation is 
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f DmInitialize>     
****/
DWORD
RdbInitialize(
    VOID
    )
{
#define RDB_EXTRA_LEN   25

    QfsHANDLE                  hFindFile = QfsINVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW            FindData;
    DWORD                       dwStatus;
    WCHAR                       szDestFileName[MAX_PATH];
    LPWSTR                      szSourceFileName = NULL;
    LPWSTR                      szSourcePathName = NULL;
    DWORD                       dwLen;
    WIN32_FILE_ATTRIBUTE_DATA   FileAttributes;
    LARGE_INTEGER               liFileCreationTime;
    LARGE_INTEGER               liMaxFileCreationTime;
    WCHAR                       szCheckpointFileName[MAX_PATH];
    WCHAR                       szClusterDir[MAX_PATH];
    LPCWSTR                     lpszPathName = CsDatabaseRestorePath;
    DWORD                       cchSourcePathName;


    //
    //  Chittur Subbaraman (chitturs) - 12/4/99
    //

    //
    //  If there is no cluster database restore in progress, don't do anything.
    //
    if( CsDatabaseRestore == FALSE ) 
    {
        return( ERROR_SUCCESS );
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] RdbInitialize: Entry...\n");

    dwLen = lstrlenW ( lpszPathName );
    //  
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own destination path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                 ( dwLen + RDB_EXTRA_LEN ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[INIT] RdbInitialize: Error %1!d! in allocating memory for %2!ws!\n",
                      dwStatus,
                      lpszPathName); 
        goto FnExit;
    }
    
    ( void ) StringCchCopy ( szSourcePathName,  dwLen + RDB_EXTRA_LEN, lpszPathName );
  
    //
    //  If the client-supplied path is not already terminated with '\', 
    //  then add it.
    //
    if ( ( dwLen > 0 ) && ( szSourcePathName [dwLen-1] != L'\\' ) )
    {
        szSourcePathName [dwLen++] = L'\\';
        szSourcePathName [dwLen] = L'\0';
    }

    ( void ) StringCchCat ( szSourcePathName, dwLen + RDB_EXTRA_LEN, L"CLUSBACKUP.DAT" );

    //
    //  Try to find the CLUSBACKUP.DAT file in the directory
    //
    hFindFile = QfsFindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( !QfsIsHandleValid(hFindFile) )
    {
        dwStatus = GetLastError();
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[INIT] RdbInitialize: Path %1!ws! unavailable, Error = %2!d!\n",
                          szSourcePathName,
                          dwStatus); 
        } else
        {
            dwStatus = ERROR_DATABASE_BACKUP_CORRUPT;
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] RdbInitialize: Backup procedure from %1!ws! not fully" 
                          " successful, can't restore checkpoint to CLUSDB, Error = %2!d! !!!\n",
                          szSourcePathName,
                          dwStatus); 
        }
        goto FnExit;
    }
    QfsFindClose ( hFindFile );

    ( void ) StringCchCat ( szSourcePathName, dwLen + RDB_EXTRA_LEN, L"chk*.tmp" );

    //
    //  Try to find the first chk*.tmp file in the directory
    //
    hFindFile = QfsFindFirstFile( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( !QfsIsHandleValid(hFindFile) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
                      "[INIT] RdbInitialize: Error %2!d! in trying"
                      "to find chk*.tmp file in path %1!ws!\r\n",
                      szSourcePathName,
                      dwStatus); 
        goto FnExit;
    }

    cchSourcePathName = lstrlenW ( szSourcePathName );
    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED, 
                                    ( cchSourcePathName + MAX_PATH ) *
                                    sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
                  "[INIT] RdbInitialize: Error %1!d! in allocating memory for source file name\n",
                   dwStatus); 
        goto FnExit;
    }   
   
    dwStatus = ERROR_SUCCESS;
    liMaxFileCreationTime.QuadPart = 0;
    
    //
    //  Now, find the most recent chk*.tmp file from the source path
    //
    while ( dwStatus == ERROR_SUCCESS )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            goto skip;
        }
        
        ( void ) StringCchCopy( szSourceFileName, cchSourcePathName + MAX_PATH, szSourcePathName );
        ( void ) StringCchCat( szSourceFileName, cchSourcePathName + MAX_PATH, FindData.cFileName );
        if ( !GetFileAttributesExW( szSourceFileName,
                                    GetFileExInfoStandard,
                                    &FileAttributes ) )
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL, "[INIT] RdbInitialize: Error %1!d! in getting file" 
                       " attributes for %2!ws!\n",
                         dwStatus,
                         szSourceFileName); 
            goto FnExit;
        }
        
        liFileCreationTime.HighPart = FileAttributes.ftCreationTime.dwHighDateTime;
        liFileCreationTime.LowPart  = FileAttributes.ftCreationTime.dwLowDateTime;
        if ( liFileCreationTime.QuadPart > liMaxFileCreationTime.QuadPart )
        {
            liMaxFileCreationTime.QuadPart = liFileCreationTime.QuadPart;
            ( void ) StringCchCopy( szCheckpointFileName, RTL_NUMBER_OF ( szCheckpointFileName ), FindData.cFileName );
        }
skip:
        if ( QfsFindNextFile( hFindFile, &FindData ) )
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            dwStatus = GetLastError();
        }
    }
    
    if ( dwStatus == ERROR_NO_MORE_FILES )
    {
        dwStatus = ERROR_SUCCESS;
    } else
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[INIT] RdbInitialize: FindNextFile failed, error=%1!d!\n",
                      dwStatus);
        goto FnExit;
    }

    //
    //  Get the directory where the cluster is installed
    //
    if ( ( dwStatus = ClRtlGetClusterDirectory( szClusterDir, MAX_PATH ) )
                    != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                      "[INIT] RdbInitialize: Error %1!d! in getting cluster dir !!!\n",
                      dwStatus);
        goto FnExit;
    }

    ( void ) StringCchCopy( szSourceFileName, cchSourcePathName + MAX_PATH, szSourcePathName );
    ( void ) StringCchCat( szSourceFileName, cchSourcePathName + MAX_PATH, szCheckpointFileName );

    ( void ) StringCchCopy( szDestFileName, RTL_NUMBER_OF ( szDestFileName ), szClusterDir );
    dwLen = lstrlenW( szDestFileName );
    if ( szDestFileName[dwLen-1] != L'\\' )
    {
        szDestFileName[dwLen++] = L'\\';
        szDestFileName[dwLen] = L'\0';
    }

#ifdef   OLD_WAY
    ( void ) StringCchCat ( szDestFileName, RTL_NUMBER_OF ( szDestFileName ), L"CLUSDB" );
#else    // OLD_WAY
    ( void ) StringCchCat ( szDestFileName, RTL_NUMBER_OF ( szDestFileName ), CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY

    //
    //  Set the destination file attribute to normal. Continue even 
    //  if you fail in this step because you will fail in the
    //  copy if this error is fatal.
    //
    SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL );

    //
    //  Now try to copy the checkpoint file to CLUSDB
    //
    dwStatus = QfsCopyFile( szSourceFileName, szDestFileName, FALSE );
    if ( !dwStatus ) 
    {
        //
        //  You failed in copying. Check whether you encountered a
        //  sharing violation. If so, try unloading the cluster hive and
        //  then retry.
        //
        dwStatus = GetLastError();
        if ( dwStatus == ERROR_SHARING_VIOLATION )
        {
            dwStatus = RdbpUnloadClusterHive( );
            if ( dwStatus == ERROR_SUCCESS )
            {
                QfsSetFileAttributes( szDestFileName, FILE_ATTRIBUTE_NORMAL );
                dwStatus = QfsCopyFile( szSourceFileName, szDestFileName, FALSE );
                if ( !dwStatus ) 
                {
                    dwStatus = GetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL, 
                              "[INIT] RdbInitialize: Unable to copy file %1!ws! "
                              "to %2!ws! for a second time, Error = %3!d!\n",
                                szSourceFileName,
                                szDestFileName,
                                dwStatus);
                    goto FnExit;
                }
            } else
            {
                ClRtlLogPrint(LOG_UNUSUAL, 
                              "[INIT] RdbInitialize: Unable to unload cluster hive, Error = %1!d!\n",
                              dwStatus);
                goto FnExit;
            }
        } else
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] RdbInitialize: Unable to copy file %1!ws! "
                          "to %2!ws! for the first time, Error = %3!d!\n",
                          szSourceFileName,
                          szDestFileName,
                          dwStatus);
            goto FnExit;
        }
    }  

    //
    //  Set the destination file attribute to normal. 
    //
    if ( !SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
                  "[INIT] RdbInitialize: Unable to change the %1!ws! "
                    "attributes to normal, Error = %2!d!\n",
                     szDestFileName,
                     dwStatus);
        goto FnExit;
    }
    
    dwStatus = ERROR_SUCCESS;
FnExit:
    QfsFindCloseIfValid( hFindFile );
    
    LocalFree( szSourcePathName );
    LocalFree( szSourceFileName );

    ClRtlLogPrint(LOG_NOISE, 
              "[INIT] RdbInitialize: Exit with Status = %1!d!...\n",
               dwStatus);

    return( dwStatus );
}

/****
@func       DWORD | RdbpUnloadClusterHive | Unload the cluster hive
                   
@rdesc      Returns a Win32 error code if the operation is 
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f RdbInitialize>     
****/
DWORD
RdbpUnloadClusterHive(
    VOID
    )
{
    BOOLEAN  bWasEnabled;
    DWORD    dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 12/4/99
    //
    dwStatus = ClRtlEnableThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                           &bWasEnabled );
                                
    if ( dwStatus != ERROR_SUCCESS ) 
    {
        if ( dwStatus == STATUS_PRIVILEGE_NOT_HELD ) 
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[INIT] RdbpUnloadClusterHive: Restore privilege not held by client\n");
        } else 
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[INIT] RdbpUnloadClusterHive: Attempt to enable restore "
                          "privilege failed, Error = %1!d!\n",
                          dwStatus);
        }
        goto FnExit;
    }

    dwStatus = RegUnLoadKeyW( HKEY_LOCAL_MACHINE,
                              CLUSREG_KEYNAME_CLUSTER );

    ClRtlRestoreThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                 bWasEnabled );   
FnExit:
    return( dwStatus );
}

/****
@func       DWORD | RdbpDeleteRestoreDbParams | Clean up the restore parameters stored
            under HKLM\System\CCC\Services\Clussvc\Parameters. The RestoreClusterDatabase
            API will also attempt to do this.
       
@comm       This function attempts clean the registry parameters for the restore database 
            operation. 

@rdesc      Returns a Win32 error code if the opening of the params key is unsuccessful. 
            ERROR_SUCCESS on success.

@xref       <f RdbGetRestoreDbParams> 
****/
DWORD 
RdbpDeleteRestoreDbParams( 
    VOID
    )
{
    HKEY    hClusSvcKey = NULL;
    DWORD   dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 08/28/2000
    //
    if( CsDatabaseRestore == FALSE ) 
    {
        return( ERROR_SUCCESS );
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] RdbDeleteRestoreDbParams: Entry...\n");

    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                            CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                            &hClusSvcKey );

    if( dwStatus != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to open clussvc params key, error=%1!u!...\n",
                  dwStatus);    
        goto FnExit;
    }

    //
    //  Try to delete the values you set. You may fail in these steps, because all these values need
    //  not be present in the registry.
    //
    dwStatus = RegDeleteValueW( hClusSvcKey, 
                                CLUSREG_NAME_SVC_PARAM_RESTORE_DB ); 

    if ( ( dwStatus != ERROR_SUCCESS ) && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_NOISE, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to delete %2!ws! param value, error=%1!u!...\n",
                  dwStatus,
                  CLUSREG_NAME_SVC_PARAM_RESTORE_DB);    
    }
    
    dwStatus = RegDeleteValueW( hClusSvcKey, 
                                CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB ); 

    if ( ( dwStatus != ERROR_SUCCESS ) && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_NOISE, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to delete %2!ws! param value, error=%1!u!...\n",
                  dwStatus,
                  CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB);    
    }

    dwStatus = RegDeleteValueW( hClusSvcKey, 
                                CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER );

    if ( ( dwStatus != ERROR_SUCCESS ) && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
    {
        ClRtlLogPrint(LOG_NOISE, 
                  "[INIT] RdbDeleteRestoreDbParams: Unable to delete %2!ws! param value, error=%1!u!...\n",
                  dwStatus,
                  CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER);    
    }

    dwStatus = ERROR_SUCCESS;
    
FnExit:
    if ( hClusSvcKey != NULL )
    {
        RegCloseKey( hClusSvcKey );
    }

    ClRtlLogPrint(LOG_NOISE, "[INIT] RdbDeleteRestoreDbParams: Exit with status=%1!u!...\n",
              dwStatus);

    return( dwStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\service.c ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    service.c

Abstract:

    Service control functions for the Cluster Service.

Author:

    Mike Massa (mikemas) 2-Jan-1996


Revision History:

--*/

#include <initp.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <clusverp.h>

//
// Public data
//
#define CLUSTER_SERVICE_CONTROLS    (SERVICE_ACCEPT_STOP | \
                                     SERVICE_ACCEPT_SHUTDOWN )

ULONG                CsLogLevel=LOG_UNUSUAL;
PCLRTL_WORK_QUEUE    CsDelayedWorkQueue = NULL;
PCLRTL_WORK_QUEUE    CsCriticalWorkQueue = NULL;
LPWSTR               CsClusterName = NULL;
SERVICE_STATUS       CsServiceStatus = {
                         SERVICE_WIN32_OWN_PROCESS, // dwServiceType
                         SERVICE_STOPPED,           // dwCurrentState
                         CLUSTER_SERVICE_CONTROLS,  // dwControlsAccepted
                         ERROR_SUCCESS,             // dwWin32ExitCode
                         ERROR_SUCCESS,             // dwServiceSpecificExitCode
                         1,                         // dwCheckPoint
                         180000                      // dwWaitHint - 180 seconds -nm uses 90 sec timeout, mns uses 180
                         };

//
// internal cluster versions. The major version is bumped during
// product releases (which could include service pack releases).
//
DWORD CsMyHighestVersion = CLUSTER_MAKE_VERSION(
                                    CLUSTER_INTERNAL_CURRENT_MAJOR_VERSION,
                                    VER_PRODUCTBUILD);

DWORD CsMyLowestVersion = CLUSTER_INTERNAL_PREVIOUS_HIGHEST_VERSION;

//initialize by calling an rtl funcion
SUITE_TYPE CsMyProductSuite; 

DWORD CsClusterHighestVersion;

DWORD CsClusterLowestVersion;

DWORD CsClusterNodeLimit;

SHUTDOWN_TYPE CsShutdownRequest = CsShutdownTypeStop;

//
// domain and user account under which the service is run
//
LPWSTR  CsServiceDomainAccount;

//
// security packages to use during the join for authenticated RPC; JoinVersion
// determines which package will be used by the ExtroCluster interface.
// CsRPCSecurityPackageInUse reflects that choice. The package used for the
// Intracluster interface is negotiated separately.
//

//
// when using kerberos with RPC, RPC calls fail with 1825 (sec. pkg error)
// somewhere between 30 minutes and 12 hours. For beta 2, we'll revert back to
// NTLM where expiration is not a problem.
//

//DWORD   CsRPCSecurityPackage[] = { RPC_C_AUTHN_GSS_KERBEROS, RPC_C_AUTHN_WINNT };
//LPWSTR  CsRPCSecurityPackageName[] = { L"Kerberos", L"NTLM" };

DWORD   CsRPCSecurityPackage[] = { RPC_C_AUTHN_WINNT };
LPWSTR  CsRPCSecurityPackageName[] = { L"NTLM" };
DWORD   CsNumberOfRPCSecurityPackages = sizeof( CsRPCSecurityPackage ) / sizeof( CsRPCSecurityPackage[0] );
LONG    CsRPCSecurityPackageIndex = -1;

//
// Public Debug Data
//
#if 1 // CLUSTER_BETA

BOOL   CsDebugResmon = FALSE;
LPWSTR CsResmonDebugCmd;

BOOL   CsNoVersionCheck = FALSE;
#endif

#if DBG // DBG

ULONG  CsDebugFlags = CS_DBG_ALL;

#endif // DBG

#ifdef CLUSTER_TESTPOINT

DWORD  CsTestPoint = 0;
DWORD  CsTestTrigger = TestTriggerNever;
DWORD  CsTestAction = TestActionTrue;
BOOL   CsPersistentTestPoint = FALSE;

#endif // CLUSTER_TESTPOINT

BOOL   CsUpgrade = FALSE;
BOOL   CsFirstRun = FALSE;
BOOL   CsNoQuorumLogging = FALSE;
BOOL   CsUserTurnedOffQuorumLogging = FALSE;
BOOL   CsNoQuorum = FALSE;
BOOL   CsResetQuorumLog = FALSE;
BOOL   CsForceQuorum = FALSE;
LPWSTR CsForceQuorumNodes = NULL;
BOOL   CsCommandLineForceQuorum = FALSE;
BOOL   CsNoRepEvtLogging = FALSE;
LPWSTR CsDatabaseRestorePath = NULL;
BOOL   CsDatabaseRestore = FALSE;
BOOL   CsForceDatabaseRestore = FALSE;
LPWSTR CsQuorumDriveLetter = NULL;
DWORD  CspInitStatus;
BOOL   CsRunningAsService = TRUE;
BOOL   CsNoGroupInfoEvtLogging = FALSE;

//
// Private Data
//
SERVICE_STATUS_HANDLE   CspServiceStatusHandle = 0;
HANDLE                  CspStopEvent = NULL;


//
// Private service initialization & cleanup routines.
//


DWORD
CspSetErrorCode(
    IN DWORD ErrorCode,
    OUT LPSERVICE_STATUS ServiceStatus
    )
/*++

Routine Description:

    Sets the correct error return for the Service Control Manager.

  Problem:

    The original cluster error codes overlap with many of the network error
    codes. For those overlaps, this function will return the error code as a
    service specific error code.

Inputs:

    EerrorCode - the correct error code to set.
    ServiceStatus - pointer to the service status for SCM

Outputs:

    ServiceStatus - Sets the correct error code in the service status.

--*/

{
    DWORD   status;

    if ( ( ErrorCode > 5000 ) && ( ErrorCode < 5090 ) ) {
        ServiceStatus->dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        ServiceStatus->dwServiceSpecificExitCode = ErrorCode;
        status = ERROR_SERVICE_SPECIFIC_ERROR;
    } else {
        ServiceStatus->dwWin32ExitCode = ErrorCode;
        ServiceStatus->dwServiceSpecificExitCode = ErrorCode;
        status = ErrorCode;
    }
    
    return (status);

} // CspSetErrorCode



VOID
CspCleanup(
    VOID
    )
/*++

 Routine Description:

     Main Cluster Manager cleanup routine. Called when the service is
     stopping.

 Arguments:

     None.

 Return Value:

     None.

--*/

{
    //
    // Cleanup & shutdown the service
    //

    IF_DEBUG(CLEANUP) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Cleaning up\n");
    }

    //
    // Free the stop event
    //
    if (CspStopEvent != NULL) {
        CloseHandle(CspStopEvent);
        CspStopEvent = NULL;
    }
    CsServiceStatus.dwCheckPoint++;
    CsAnnounceServiceStatus();

    if ( CsDatabaseRestorePath != NULL ) {
        LocalFree ( CsDatabaseRestorePath );
    }

    if ( CsQuorumDriveLetter != NULL ) {
        LocalFree ( CsQuorumDriveLetter );
    }

    if ( CsForceQuorumNodes != NULL && !CsCommandLineForceQuorum ) {
        LocalFree ( CsForceQuorumNodes );
    }

    IF_DEBUG(CLEANUP) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Cleanup complete.\n");
    }

    return;
} // CspCleanup


//
// Public service control routines.
//
VOID
CsWaitForStopEvent(
    VOID
    )
/*++

 Routine Description:

     Main body of the Cluster Manager service. Called when the service
     has been successfully started.

 Arguments:

     None.

 Return Value:

     A Win32 status code.

--*/

{
    DWORD           status;

    CL_ASSERT(CsRunningAsService);

    IF_DEBUG(INIT) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Service Started.\n\n");
    }

    //
    // Wait for the service to be stopped.
    //
    WaitForSingleObject(CspStopEvent,   // handle
                        INFINITE        // no timeout
                        );

    return;
} // CsWaitForStopEvent


VOID
CsStopService(
    VOID
    )
/*++

 Routine Description:

     Handler for a service controller STOP message. Initiates the process
     of stopping the Cluster Manager service.

 Arguments:

     None.

 Return Value:

     None.

--*/

{
    if (CsRunningAsService) {
        //
        // Announce that we are stopping.
        //
        CsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        CsServiceStatus.dwCheckPoint = 1;
        CsServiceStatus.dwWaitHint = 20000;  // 20 seconds
        CsAnnounceServiceStatus();
    }

    //
    // Wake up the main service thread.
    //
    SetEvent(CspStopEvent);

    return;
}



VOID
CsAnnounceServiceStatus (
    VOID
    )

/*++

Routine Description:

    Announces the service's status to the service controller.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Don't announce our status if running as a console app.
    //
    if (!CsRunningAsService) {
        return;
    }

    //
    // Service status handle is NULL if RegisterServiceCtrlHandler failed.
    //
    if ( CspServiceStatusHandle == 0 ) {
        return;
    }

    //
    // Call SetServiceStatus, ignoring any errors.
    //
    SetServiceStatus(CspServiceStatusHandle, &CsServiceStatus);

    return;

} // CsAnnounceServiceStatus



//
// Private routines for executing as a Win32 service.
//
VOID WINAPI
CspControlHandler(
    DWORD ControlCode
    )
/*++

 Routine Description:

     Handler for Service Controller messages.

 Arguments:

     ControlCode - The code indicating the Service Controller's request.

 Return Value:

     None.

--*/

{
    switch(ControlCode){

    case SERVICE_CONTROL_SHUTDOWN:

        CsShutdownRequest = CsShutdownTypeShutdown;

        // Fall Through

    case SERVICE_CONTROL_STOP:
        IF_DEBUG(CLEANUP) {
            ClRtlLogPrint(LOG_NOISE,
                       "[CS] Received %1!ws! command\n",
                        (ControlCode == SERVICE_CONTROL_STOP ? L"STOP" : L"SHUTDOWN"));
        }

        CsStopService();
        break;

    case SERVICE_CONTROL_INTERROGATE:
        CsAnnounceServiceStatus();
        break;

    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_PAUSE:
        break;

    default:
        ClRtlLogPrint(LOG_NOISE,
            "[CS] Received unknown service command %1!u!\n",
            ControlCode
            );

        break;
    }

    return;

} // CspControlHandler

DWORD CspGetFirstRunState(
    OUT LPDWORD pdwFirstRun
    )
{
    HKEY  hKey = NULL;
    DWORD dwStatus;     // returned by registry API functions
    DWORD dwClusterInstallState;
    DWORD dwValueType;
    DWORD dwDataBufferSize = sizeof( DWORD );

    *pdwFirstRun = 0;
    // Read the registry key that indicates whether cluster files are installed.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_READ,
                                &hKey );

    // Was the registry key opened successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwFirstRun = 1;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

    // Read the entry.
    dwStatus = RegQueryValueExW( hKey,
                                  L"ClusterFirstRun",
                                  0, // reserved
                                  &dwValueType,
                                  (LPBYTE) pdwFirstRun,
                                  &dwDataBufferSize );

    // Was the value read successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            *pdwFirstRun = 1;
            dwStatus = ERROR_SUCCESS;
            goto FnExit;
        }
    }

FnExit:    
    // Close the registry key.
    if ( hKey )
    {
        RegCloseKey( hKey );
    }

    return ( dwStatus );

} //*** CspGetFirstRunState

DWORD CspGetServiceParams()
{
    HKEY  hClusSvcKey = NULL;
    DWORD Length;
    DWORD Type;
    DWORD Status;
    eClusterInstallState eState;

    //
    // Figure out if this is the first run on upgrade or fresh install
    //
    Status = CspGetFirstRunState( ( LPDWORD ) &CsFirstRun );

    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Error in getting first run state, status %1!u!\n",
                      Status);
        goto ret;
    }

    //
    // If there is upgrade, this must be the first run
    //
    Status = ClRtlGetClusterInstallState( NULL, &eState );

    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Error in getting install state, status %1!u!\n",
                      Status);
        goto ret;
    }

    if ( eState == eClusterInstallStateUpgraded )
    {
        CsUpgrade = TRUE;
        CsFirstRun = TRUE;
    }

    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    Status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                         &hClusSvcKey);

    //
    // If you failed in the open, don't consider it as a fatal error enough to stop cluster
    // service from starting.
    //
    if ( Status != ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_UNUSUAL, "[CS] Error in opening cluster service params key, status %1!u!\n",
                      Status);
        Status = ERROR_SUCCESS;
        goto ret;
    }

    Length = sizeof(DWORD);
    Status = RegQueryValueExW(hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_NOVER_CHECK,
                              0,
                              &Type,
                              (LPBYTE)&CsNoVersionCheck,
                              &Length);

    // by default, version checking is turned on
    if (Status != ERROR_SUCCESS) {
        CsNoVersionCheck = FALSE;
        Status = ERROR_SUCCESS;
    }

    Length = sizeof(DWORD);
    Status = RegQueryValueExW(hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_NOREP_EVTLOGGING,
                              0,
                              &Type,
                              (LPBYTE)&CsNoRepEvtLogging,
                              &Length);
    //For now, default is to turn eventlogging on
    if (Status != ERROR_SUCCESS) {
        CsNoRepEvtLogging = FALSE;
        Status = ERROR_SUCCESS;
    }

    Length = sizeof(DWORD);
    Status = RegQueryValueExW(hClusSvcKey,
                              CLUSREG_NAME_SVC_PARAM_NOGROUPINFO_EVTLOGGING,
                              0,
                              &Type,
                              (LPBYTE)&CsNoGroupInfoEvtLogging,
                              &Length);
    //For now, default is to turn group info eventlogging on
    if (Status != ERROR_SUCCESS) {
        CsNoGroupInfoEvtLogging = FALSE;
        Status = ERROR_SUCCESS;
    }

    //
    //  Check the registry to see whether RestoreDatabase option is
    //  chosen. If so, get the params and save them in global variables.
    //
    RdbGetRestoreDbParams( hClusSvcKey );

    //
    // See if the force quorum option has been set.  Unfortunately we
    // need two calls to get the size and do the alloc.  Note that if
    // we have command line stuff already then this overrides registry
    // parameters.  If we have command line stuff then CsForceQuorum
    // will be set.  Care is needed since we could be unlucky with the
    // time between the two calls.
    //
    if ( !CsForceQuorum ) {
GetForceQuorum:
        Length = 0;
        Status = RegQueryValueExW( hClusSvcKey,
                                   CLUSREG_NAME_SVC_PARAM_FORCE_QUORUM,
                                   0,
                                   &Type,
                                   NULL,
                                   &Length);
        if (Status == ERROR_SUCCESS) {
        
            // Got the length, check the type before allocating
            //
            if ( Type != REG_SZ ) {
                ClRtlLogPrint(LOG_UNUSUAL, "[CS] Error in forcequorum value under service parameters, type was not REG_SZ.\n");
                Status = ERROR_INVALID_PARAMETER;
                goto ret;
            }
            // Got a valid type so force quorum is set, check the length.
            // If the length is 0 or 1 WCHAR's then we have the key but no data which
            // is OK.  Otherwise alloc and read the data.
            //
            if ( Length < 2 * sizeof ( WCHAR ) ) {
                ClRtlLogPrint(LOG_UNUSUAL, "[CS] forcequorum value found under service parameters, length %1!u! bytes, ignoring\n",
                              Length);
                goto ret;
            }

            CsForceQuorumNodes = (LPWSTR) LocalAlloc( LMEM_FIXED, Length );

            if ( CsForceQuorumNodes == NULL )
            {
                Status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,"[CS] Error in memory allocation for CsForceQuorumNodes, status %1!u!\n",
                              Status);
                goto ret;               
            }
            
            Status = RegQueryValueExW( hClusSvcKey,
                                       CLUSREG_NAME_SVC_PARAM_FORCE_QUORUM,
                                       0,
                                       &Type,
                                       (LPBYTE) CsForceQuorumNodes,
                                       &Length);
            if ( Status == ERROR_MORE_DATA || Type != REG_SZ ) {
                LocalFree( CsForceQuorumNodes );
                CsForceQuorumNodes = NULL;
                CsForceQuorum = FALSE;
                goto GetForceQuorum;
            }
            if ( Status != ERROR_SUCCESS ) {
                LocalFree( CsForceQuorumNodes );
                CsForceQuorumNodes = NULL;
                goto ret;
            }
            else CsForceQuorum = TRUE;
        } else {
            Status = ERROR_SUCCESS;
        }
    }
ret:
    //close the key
    if (hClusSvcKey) RegCloseKey(hClusSvcKey);

    return(Status);
}


BOOL CspResetFirstRunState(DWORD dwFirstRunState)
{
    //initialize return to FALSE
    BOOL     fReturnValue = FALSE;

    // Set the state of the ClusterInstallationState registry key to indicate
    // that Cluster Server has been configured.

    HKEY     hKey;

    DWORD    dwStatus;     // returned by registry API functions

    // Attempt to open an existing key in the registry.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_WRITE,
                                &hKey );

    // Was the regustry key opened successfully ?

    if ( dwStatus == ERROR_SUCCESS )
    {
        // set the first run state to 0.

        DWORD dwFirstRun = 0;

        DWORD dwValueType = REG_DWORD;
        DWORD dwDataBufferSize = sizeof( DWORD );

        dwStatus = RegSetValueExW( hKey,
                                    L"ClusterFirstRun",
                                    0, // reserved
                                    dwValueType,
                                    (LPBYTE) &dwFirstRun,
                                    dwDataBufferSize );

        // Close the registry key.

        RegCloseKey( hKey );

        // Was the value set successfully?

        if ( dwStatus == ERROR_SUCCESS )
        {
            fReturnValue = TRUE;
        }
    }

    return ( fReturnValue );

} //*** CspResetFirstRunState

DWORD
CspSetInstallAndFirstRunState(
    VOID
    )

/*++

Routine Description:

    Sets the cluster state to Configured.  Called
    after the service has started running after the first upgrade.
    If it is a fresh install, Cluscfg sets the state of this to 
    Configured before starting the cluster service

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/
{
    DWORD Status = ERROR_SUCCESS;

    if (CsUpgrade)
    {

        if (!ClRtlSetClusterInstallState(eClusterInstallStateConfigured))
        {
            Status = GetLastError();
        }

    }

    if (CsFirstRun)
    {
        CspResetFirstRunState(0);    
    }
    return(Status);

} // CspResetUpgradeBit


VOID 
CspGetServiceCmdLineParams(
    DWORD  argc,
    LPTSTR argv[]
    )
/*++

Routine Description:

    Get the command line parameters supplied as a part of StartService.

Arguments:

    argc - Number of arguments passed in.

    argv - Argument list.

Return Value:

    None.

Comments:

    PSS desired behavior - Halt the service if illegal parameters are supplied by user.

--*/
{
    DWORD i;
    
    if ( ( argc > 1 ) && ( ( *argv[1] == '-' ) || ( *argv[1] == '/' ) ) )
    {
        for (i=1; i<argc; i++)
        {                          
            //
            //  PSS wants short aliases for some options. Seems like users make mistake typing
            //  the full forms and causes a lot of headache.
            //
            if ( ( !lstrcmpi ( argv[i]+1, L"noquorumlogging" ) ) || ( !lstrcmpi(argv[i]+1, L"NQ" ) ) )                       
            {                                                                  
                CsNoQuorumLogging = TRUE;
                CsUserTurnedOffQuorumLogging = TRUE;
                ClRtlLogPrint(LOG_NOISE,"[CS] noquorumlogging option chosen: quorum logging is off\n");  
            }                                                                  
            else if ( ( !lstrcmpi ( argv[i]+1, L"fixquorum" ) ) || ( !lstrcmpi ( argv[i]+1, L"FQ" ) ) )                       
            {                                                                  
                CsNoQuorum = TRUE;  
                CsNoQuorumLogging = TRUE;
                CsUserTurnedOffQuorumLogging = TRUE;
                ClRtlLogPrint(LOG_NOISE, "[CS] fixquorum option chosen: quorum is not arbitrated or brought online\n");
            }
            else if ( ( !lstrcmpi ( argv[i]+1, L"resetquorumlog" ) ) || ( !lstrcmpi ( argv[i]+1, L"RQ" ) ) )                        
            {                                                                  
                CsResetQuorumLog = TRUE;  
                ClRtlLogPrint(LOG_NOISE, "[CS] resetquorumlog option chosen: force reset quorum log\n");
            }
            else if ( ( !lstrcmpi ( argv[i]+1, L"forcequorum" ) ) || ( !lstrcmpi ( argv[i]+1, L"FO" ) ) )                        
            {
                //
                //  Throw away anything you picked up from the clussvc params area in
                //  the registry via CspGetServiceParams()
                //
                if ( CsForceQuorumNodes ) 
                {
                    LocalFree ( CsForceQuorumNodes );
                    CsForceQuorumNodes = NULL;
                    CsForceQuorum = FALSE;
                }

                if ( ( argc < i+2 )
                    || ( *argv[i+1] == L'-' ) 
                    || ( *argv[i+1] == L'/' )) {
                    ClRtlLogPrint(LOG_UNUSUAL, "[CS] Invalid node list for forcequorum option supplied\n");
                    CsInconsistencyHalt( ERROR_INVALID_PARAMETER );
                } else 
                {
                    CsForceQuorumNodes = argv[++i]; /* increment i to ensure we skip the node list. */
                    CsForceQuorum = TRUE;
                    CsCommandLineForceQuorum = TRUE;
                }
                ClRtlLogPrint(LOG_NOISE, "[CS] forcequorum option chosen: force majority node set for nodes %1!ws!\n", CsForceQuorumNodes);
            }
            else if ( ( !lstrcmpi ( argv[i]+1, L"nogroupinfoevtlogging" ) ) || ( !lstrcmpi ( argv[i]+1, L"NG" ) ) )                      
            {                                                                  
                CsNoGroupInfoEvtLogging = TRUE;  
                ClRtlLogPrint(LOG_NOISE, "[CS] nogroupinfoevtlogging option chosen: turn Group Information Event Logging off\n");
            }
            else if ( ( lstrcmpi( L"debugresmon", argv[i]+1 ) == 0 ) || ( lstrcmpi( L"DR", argv[i]+1 ) == 0 ) )
            {
                CsDebugResmon = TRUE;
                ClRtlLogPrint(LOG_NOISE, "[CS] debugresmon option chosen\n");
                //
                // check for optional, non-NULL command string
                //
                if ( argc >= i+2  ) 
                {
                    if ( *argv[i+1] != L'-' && *argv[i+1] != L'/' && *argv[i+1] != UNICODE_NULL ) 
                    {
                        CsResmonDebugCmd = argv[++i];
                    }
                }
            } else {
                ClRtlLogPrint(LOG_CRITICAL, "[CS] Invalid start parameter '%1!ws!' supplied to clussvc, stopping\n",
                              argv[i]+1);
                CsLogEvent1( LOG_CRITICAL,
                             CS_INVALID_START_PARAMETER,
                             argv[i]+1 );
                CsInconsistencyHalt( ERROR_INVALID_PARAMETER );
            }
        } // for
    } // if
}   // CspGetServiceCmdLineParams

VOID WINAPI
CspServiceMain(
    DWORD  argc,
    LPTSTR argv[]
    )
{
    DWORD               status;

    ClRtlLogPrint(LOG_NOISE,"[CS] Service Starting...\n");

    if ( CspInitStatus == ERROR_SUCCESS ) {
        CsServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    } else {
        CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CsServiceStatus.dwWin32ExitCode = CspInitStatus;
    }

    //
    // Initialize server to receive service requests by registering the
    // control handler.
    //

    CspServiceStatusHandle = RegisterServiceCtrlHandler(
                                   CLUSTER_SERVICE_NAME,
                                   CspControlHandler
                                   );

    if ( CspServiceStatusHandle == 0 ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_NOISE,"[CS] Service Registration failed, %1!u!\n", status);
        CL_UNEXPECTED_ERROR( status );
        return;
    }

    IF_DEBUG(INIT) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Service control handler registered\n");
    }

    CsAnnounceServiceStatus();

    if ( CspInitStatus != ERROR_SUCCESS ) {
        return;
    }

    CspGetServiceCmdLineParams(argc, argv);

    //
    // Initialize the cluster. If this succeeds, wait for
    // the SC mgr to stop us
    //
    status = ClusterInitialize();
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] ClusterInitialize failed %1!d!\n",
                                  status);
    } else {
        CspSetInstallAndFirstRunState();
        //
        // Announce that we're up and running.
        //
        CsServiceStatus.dwCurrentState = SERVICE_RUNNING;
        CsServiceStatus.dwControlsAccepted = CLUSTER_SERVICE_CONTROLS;
        CsServiceStatus.dwCheckPoint = 0;
        CsServiceStatus.dwWaitHint = 0;

        CsAnnounceServiceStatus();

        //
        //  The following writer initialize call must be made only after the cluster service
        //  is announced to have fully started. This is to avoid a deadlock during autostart
        //  caused by the following code (indirectly) demand starting the EventSystem service.
        //  NOTE: This was the LEAST UGLY HACK we (SCM team, VSS guys and us) could come up with.
        //
        status = VssWriterInit();

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, "[CS] VssWriterInit failed %1!d!\n",
                          status);
        } else {
            //
            // Initiate the process that notifies interested listeners that the cluster
            // service has started up.
            //
            HRESULT hr = ClRtlInitiateStartupNotification();

            if ( FAILED( hr ) ) {
                //
                // If the process of notifying listeners could not be initiated, just log
                // the return code as a warning.
                //
                ClRtlLogPrint(LOG_UNUSUAL,
                              "[CS] Error 0x%1!08lx! occurred trying to initiate cluster startup notifications. This is not fatal and will not prevent the service from starting.\n",
                              hr);
            }

            CsWaitForStopEvent();
        }
    }

    //
    // Announce that we're stopping
    //
    IF_DEBUG(CLEANUP) {
        ClRtlLogPrint(LOG_NOISE,"[CS] Service Stopping...\n");
    }

    CsServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    CsServiceStatus.dwCheckPoint = 1;
    CsServiceStatus.dwWaitHint = 20000;  // 20 seconds
    CspSetErrorCode( status, &CsServiceStatus );

    CsAnnounceServiceStatus();

    //
    // ClusterShutdown currently never returns
    //

    ClusterShutdown(status);

#if 0
    CspCleanup();

    //
    // Announce that we are stopped.
    //
    CsServiceStatus.dwCurrentState = SERVICE_STOPPED;
    CsServiceStatus.dwControlsAccepted = 0;
    CsServiceStatus.dwCheckPoint = 0;
    CsServiceStatus.dwWaitHint = 0;
    CspSetErrorCode( status, &CsServiceStatus );

    CsAnnounceServiceStatus();

    ClRtlLogPrint(LOG_NOISE,"[CS] Service Stopped.\n\n");

    //
    // Can't call ClRtlLogPrint after this point.
    //
    ClRtlCleanup();

    return;
#endif
} // CspServiceMain



//
// Private routines for executing as a console application.
//
BOOL WINAPI
CspConsoleHandler(
    DWORD dwCtrlType
    )
/*++

 Routine Description:

     Handler for console control events when running the service as
     a console application.

 Arguments:

     dwCtrlType - Indicates the console event to handle.

 Return Value:

     TRUE if the event was handled, FALSE otherwise.

--*/

{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            printf("Stopping service...\n");
            CsStopService();
            return TRUE;
            break;

    }

    return FALSE;
}



DWORD
CspDebugService(
    int         argc,
    wchar_t **  argv
    )
/*++

 Routine Description:

     Runs the service as a console application

 Arguments:

     Standard command-line arguments.

 Return Value:

     None.

--*/

{
    DWORD status;

    SetConsoleCtrlHandler( CspConsoleHandler, TRUE );

    status = ClusterInitialize();

    if (status == ERROR_SUCCESS) {

        CspSetInstallAndFirstRunState();

        //
        //  Initialize the cluster backup writer. This is moved out of ClusterInitialize due to
        //  possible deadlocks caused at autostart. See comments in CspServiceMain.
        //
        status = VssWriterInit();

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL, "[CS] VssWriterInit failed %1!d!\n",
                          status);
            goto FnExit;
        }

        //
        // Wait for ctrl-c to initiate shutdown.
        //
        WaitForSingleObject(CspStopEvent, INFINITE);

    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[CS] ClusterInitialize failed %1!d!\n",
                   status);
    }

FnExit:
    ClusterShutdown(status);

    CspCleanup();

    //
    // Can't call ClRtlLogPrint after this point.
    //
    ClRtlCleanup();

    return(status);
}


//
// Main program routines
//

VOID
CspUsage(
    VOID
    )
{
#if DBG

    printf("\nCluster Service\n");
    printf("\n");
    printf("Start with 'net start' to run as a Win32 service\n");
    printf("\n");
    printf("Command line options:\n");
    printf("\t-loglevel N           set the debugging log level.\n");
    printf("\t-debug                run as a console app.\n");
    printf("\t-debugresmon [dbgcmd] enable debugging of resrcmon process using optional command.\n");
    printf("\t                          use quotes to include args, i.e., -debugresmon \"ntsd -d\"\n");
    printf("\t-fixquorum            no quorum device, no quorum logging.\n");
    printf("\t-noquorumlogging      no quorum logging.\n");
    printf("\t-forcequorum N1,...,Nn force a majority node set for node N1 up to Nn inclusive.\n");
    printf("\t-restoredatabase D    restore cluster DB to quorum disk from dir D.\n");
    printf("\t-forcerestore         force a restore DB operation by performing fixups.\n"); 
    printf("\t-resetquorumlog       force a form despite a missing quorum log file.\n"); 
    printf("\t-quodriveletter Q     drive letter for a replacement quorum disk\n"); 
    printf("\t-norepevtlogging      no replication of event log entries.\n");
    printf("\t-novercheck           ignore join version checking.\n");
    printf("\t-nogroupinfoevtlogging    no group informational events logged in the eventlog.\n");
    printf("\t-testpt N             enable test point N.\n");
    printf("\t-persistent           make test points persistent.\n");
    printf("\t-trigger N            sets test point trigger type.\n");
    printf("\t                          (0-never (default), 1-always, 2-once, 3-count)\n");
    printf("\t-action N             sets trigger action.\n");
    printf("\t                          (0-true (default), 1-exit, 2-break)\n");
    printf("\n");

#else // DBG

    ClRtlMsgPrint(CS_COMMAND_LINE_HELP);

#endif // DBG
    exit(1);
}





int __cdecl
wmain(
    int     argc,
    wchar_t **argv
    )
{
    DWORD                   Status;
    int                     i;
    LPWSTR                  LogLevel;
    BOOLEAN                 debugFlagFound = FALSE;
    OSVERSIONINFOEXW        Version;
    DWORD                   dwLen;
    BOOL                    success;
    PWCHAR                  suiteInfo;
    SYSTEMTIME              localTime;
    BOOLEAN                 dbgOutputToConsole;
    UINT                    errorMode;
    DWORD                   dwMask;

    SERVICE_TABLE_ENTRY dispatchTable[] = {
        { CLUSTER_SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)CspServiceMain },
        { NULL, NULL }
    };

    //
    //  BUGBUG - 06/23/2000
    //
    //  This is a temporary change to let the cluster service and resource monitor process run 
    //  despite 64-bit alignment faults.  This will be removed as soon as all alignment issues 
    //  are fixed.
    //
    errorMode = SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT );

    SetErrorMode( SEM_NOALIGNMENTFAULTEXCEPT | errorMode );

    LogLevel = _wgetenv(L"ClusterLogLevel");

    if (LogLevel != NULL) {
        swscanf(LogLevel, L"%u", &CsLogLevel);
    }

    if ( (argc > 1) && ((*argv[1] == L'-') || (*argv[1] == L'/')) ) {
        //
        // Invoked from the command line.
        //
        CsRunningAsService = FALSE;
        dbgOutputToConsole = TRUE;
    } else {
        //
        // Invoked by the Service Controller
        //
        CsRunningAsService = TRUE;
        dbgOutputToConsole = FALSE;
    }

    //
    // initialize the run time library
    //
    Status = ClRtlInitialize( dbgOutputToConsole, &CsLogLevel );
    if (Status != ERROR_SUCCESS) {
        if (Status == ERROR_PATH_NOT_FOUND) {
            CsLogEvent( LOG_CRITICAL, SERVICE_CLUSRTL_BAD_PATH );
        } else {
            PWCHAR  msgString;
            DWORD   msgStatus;

            msgStatus = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                       FORMAT_MESSAGE_FROM_SYSTEM,
                                       NULL,
                                       Status,
                                       0,
                                       (LPWSTR)&msgString,
                                       0,
                                       NULL);

            if ( msgStatus != 0 ) {
                CsLogEventData1(LOG_CRITICAL,
                                SERVICE_CLUSRTL_ERROR,
                                sizeof(Status),
                                (PVOID)&Status,
                                msgString);
                LocalFree( msgString);
            }
        }

        goto init_failed;
    }

    QfsInitialize();
    ClRtlInitWmi(L"Clustering Service");
    //
    // Log the version number
    //
    ClRtlLogPrint( LOG_NOISE, "\n\n");
    ClRtlLogPrint( LOG_NOISE,
                "[CS] Cluster Service started - Cluster Node Version %1!u!.%2!u!\n",
                 CLUSTER_GET_MAJOR_VERSION( CsMyHighestVersion ),
                 CLUSTER_GET_MINOR_VERSION( CsMyHighestVersion ));

    Version.dwOSVersionInfoSize = sizeof(Version);
    success = GetVersionExW((POSVERSIONINFOW)&Version);

    if ( success ) {
    //
    // Log the System version number
    //
        if ( Version.wSuiteMask & VER_SUITE_DATACENTER ) {
            suiteInfo = L"DTC";
        } else if ( Version.wSuiteMask & VER_SUITE_ENTERPRISE ) {
            suiteInfo = L"ADS";
        } else if ( Version.wSuiteMask & VER_SUITE_EMBEDDEDNT ) {
            suiteInfo  = L"EMB";
        } else if ( Version.wProductType & VER_NT_WORKSTATION ) {
            suiteInfo = L"WS";
        } else if ( Version.wProductType & VER_NT_DOMAIN_CONTROLLER ) {
            suiteInfo = L"DC";
        } else if ( Version.wProductType & VER_NT_SERVER ) {
            suiteInfo = L"SRV";  // otherwise - some non-descript Server
        } else {
            suiteInfo = L"";
        }

        dwMask = (Version.wProductType << 24) | Version.wSuiteMask;

        ClRtlLogPrint(LOG_NOISE,
                   "                               OS Version %1!u!.%2!u!.%3!u!%4!ws!%5!ws! (%6!ws! %7!08XL!)\n",
                    Version.dwMajorVersion,
                    Version.dwMinorVersion,
                    Version.dwBuildNumber,
                    *Version.szCSDVersion ? L" - " : L"",
                    Version.szCSDVersion,
                    suiteInfo,
                    dwMask);
    } else {
        ClRtlLogPrint( LOG_UNUSUAL,
                    "                               OS Version not available! (error %1!u!)\n",
                     GetLastError()
                     );
    }

    //
    // log the local time so we can correlate other logs which show local time
    //
    GetLocalTime( &localTime );
    ClRtlLogPrint( LOG_NOISE,
                "                               Local Time is "\
                 " %1!02d!/%2!02d!/%3!02d!-%4!02d!:%5!02d!:%6!02d!.%7!03d!\n",
                 localTime.wYear,
                 localTime.wMonth,
                 localTime.wDay,
                 localTime.wHour,
                 localTime.wMinute,
                 localTime.wSecond,
                 localTime.wMilliseconds);

    Status = ClRtlBuildClusterServiceSecurityDescriptor( NULL );
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Failed to build cluster security descriptor %1!x!\n",
                                  Status);
        goto init_failed;
    }

    //get params set in the registry
    Status = CspGetServiceParams();
    if (Status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, "[CS] Failed to read service params %1!d!\n",
                                  Status);
        goto init_failed;
    }

    //the params on the command line over ride the ones in the registry
    if (CsRunningAsService == FALSE) {
        for (i=1; i<argc; i++) {
            if (lstrcmpiW( L"loglevel", argv[i]+1) == 0) {
                if (argc < i+2) {
                    CspUsage();
                }

                CsLogLevel = _wtoi(argv[++i]);
            }
#ifdef CLUSTER_TESTPOINT
            else if (lstrcmpiW( L"testpt", argv[i]+1 ) == 0 ) {
                if (argc < i+2) {
                    CspUsage();
                }

                CsTestPoint = _wtoi(argv[++i]);
            }
            else if ( lstrcmpiW( L"persistent", argv[i]+1 ) == 0 ) {
                CsPersistentTestPoint = TRUE;
            }
            else if ( lstrcmpiW( L"trigger", argv[i]+1 ) == 0 ) {
                if ( argc < i+2  ) {
                    CspUsage();
                }
                CsTestTrigger = _wtoi(argv[++i]);
            }
            else if ( lstrcmpiW( L"action", argv[i]+1 ) == 0 ) {
                if ( argc < i+2  ) {
                    CspUsage();
                }
                CsTestAction = _wtoi(argv[++i]);
            }

#endif // CLUSTER_TESTPOINT

            else if ( lstrcmpiW( L"debugresmon", argv[i]+1 ) == 0 ) {
                CsDebugResmon = TRUE;
                //
                // check for optional, non-NULL command string
                //
                if ( argc >= i+2  ) {
                    if ( *argv[i+1] != L'-' && *argv[i+1] != L'/' && *argv[i+1] != UNICODE_NULL ) {
                        CsResmonDebugCmd = argv[++i];
                    }
                }
            }
            else if ( lstrcmpiW( L"novercheck", argv[i]+1 ) == 0 ) {
                CsNoVersionCheck = TRUE;
            }
            else if ( lstrcmpiW( L"noquorumlogging", argv[i]+1 ) == 0 ) {
                CsNoQuorumLogging = TRUE;
                CsUserTurnedOffQuorumLogging = TRUE;
            }
            else if ( lstrcmpiW( L"nogroupinfoevtlogging", argv[i]+1 ) == 0 ) {
                CsNoGroupInfoEvtLogging = TRUE;
            }
            else if ( lstrcmpiW( L"fixquorum", argv[i]+1 ) == 0 ) {
                CsNoQuorum = TRUE;
                CsNoQuorumLogging = TRUE;
                CsUserTurnedOffQuorumLogging = TRUE;
            }
            else if ( lstrcmpiW( L"resetquorumlog", argv[i]+1 ) == 0 ) {
                CsResetQuorumLog = TRUE;
            }
            else if ( lstrcmpiW( L"forcequorum", argv[i]+1 ) == 0 ) {
                //
                //  Throw away anything you picked up from the clussvc params area in
                //  the registry via CspGetServiceParams()
                //
                if ( CsForceQuorumNodes ) {
                    LocalFree ( CsForceQuorumNodes );
                    CsForceQuorumNodes = NULL;
                    CsForceQuorum = FALSE;
                }
                if (( argc < i+2 )
                    || ( *argv[i+1] == L'-' ) 
                    || ( *argv[i+1] == L'/' )) {
                    CsForceQuorumNodes = NULL;
                    printf("\n\n*** forcequorum option needs a nodelist parameter ***\n\n");
                    CspUsage ();
                } else {
                    CsForceQuorumNodes = argv[++i];
                    CsForceQuorum = TRUE;
                    CsCommandLineForceQuorum = TRUE;
                }
            }
            else if ( lstrcmpiW( L"norepevtlogging", argv[i]+1 ) == 0 ) {
                CsNoRepEvtLogging = TRUE;
            }

            else if ( lstrcmpiW( L"debug", argv[i]+1 ) == 0 ) {
                debugFlagFound = TRUE;
            }
            else if ( lstrcmpiW( L"restoredatabase", argv[i]+1 ) == 0 ) {
                if ( ( argc < i+2 ) ||
                     ( *argv[i+1] == L'-' ) ||
                     ( *argv[i+1] == L'/' ) )
                {
                    printf("\n\n*** restoredatabase option needs a path parameter ***\n\n");
                    CspUsage();
                }

                if ( !ClRtlIsPathValid( argv[i+1] )) {
                    printf( "\n\n*** restoredatabase path is invalid ***\n\n" );
                    CspUsage();
                }

                if ( !ClRtlPathFileExists( argv[i+1] )) {
                    printf( "\n\n*** restoredatabase file cannot be accessed ***\n\n" );
                    CspUsage();
                }

                dwLen = lstrlenW ( argv[++i] );
                CsDatabaseRestorePath = (LPWSTR) LocalAlloc (LMEM_FIXED,
                                            ( dwLen + 1 ) * sizeof ( WCHAR ) );
                if ( CsDatabaseRestorePath == NULL ) {
                    printf("Error %d in allocating storage for restoredatabase path name (%ws)...\n",
                            GetLastError(),
                            argv[i]);
                    CspUsage();
                }
                wcscpy( CsDatabaseRestorePath, argv[i] );
                CsDatabaseRestore = TRUE;
            }
            else if ( lstrcmpiW( L"quodriveletter", argv[i]+1 ) == 0 ) {
                if ( ( argc < i+2 ) ||
                     ( *argv[i+1] == L'-' ) ||
                     ( *argv[i+1] == L'/' ) )
                {
                    printf("\n\n*** quodriveletter option needs a drive letter parameter ***\n\n");
                    CspUsage();
                }

                dwLen = lstrlenW ( argv[++i] );
                if ( ( dwLen != 2 ) ||
                     !iswalpha( *argv[i] ) ||
                     ( *( argv[i]+1 ) != L':' ) ) {
                    printf("\n\n*** invalid drive letter %ws supplied with quodriveletter option ***\n\n",
                            argv[i]);
                    CspUsage();
                }

                CsQuorumDriveLetter = (LPWSTR) LocalAlloc (LMEM_FIXED,
                                            ( dwLen + 1 ) * sizeof ( WCHAR ) );
                if ( CsQuorumDriveLetter == NULL ) {
                    printf("Error %d in allocating storage for quodriveletter option (%ws)...\n\n",
                            GetLastError(),
                            argv[i]);
                    CspUsage();
                }
                wcscpy( CsQuorumDriveLetter,  argv[i] );
            }
            else if ( lstrcmpiW( L"forcerestore", argv[i]+1 ) == 0 ) {
                CsForceDatabaseRestore = TRUE;
            }
            else {
                CspUsage();
            }
        }

        if (!debugFlagFound && !CspStopEvent) {
            CspUsage();
        }

        if ( CsDatabaseRestore == TRUE ) {
            if ( CsNoQuorumLogging || CsNoQuorum ) {
                printf("\n\n**** restoredatabase cannot be used with noquorumlogging/fixquorum options ****\n\n");
                CspUsage();
            }
        } else if ( CsForceDatabaseRestore ) {
            printf("\n\n**** forcerestore cannot be used without restoredatabase option ****\n\n");
            CspUsage();
        } 

        if ( ( CsQuorumDriveLetter != NULL ) && !CsForceDatabaseRestore ) {
            printf("\n\n**** quodriveletter cannot be used without forcerestore option ****\n\n");
            CspUsage();
        }
    }

    //
    // Create our stop event
    //
    Status = ERROR_SUCCESS;
    if (!CspStopEvent)
    {
        CspStopEvent = CreateEvent(
                        NULL,   // default security
                        FALSE,  // auto-reset
                        FALSE,  // initial state is non-signalled
                        NULL    // unnamed event
                        );

        if (CspStopEvent == NULL) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Unable to create stop event, %1!u!\n",
                Status);
        }
    }

    //
    // we can't fire up our main routine if we're running as a service until
    // now (race conditions between reading startup params out of the registry
    // versus whether we're running as a service at all, etc.). Note that we
    // failed initialization so if we are running as a service, we'll detect
    // it in CspServiceMain and issue the stop
    //
init_failed:
    CspInitStatus = Status;

    //
    // Run the service.
    //
    if (CsRunningAsService) {
        if (!StartServiceCtrlDispatcher(dispatchTable)) {
            Status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[CS] Unable to dispatch to SC, %1!u!\n",
                Status);
            CL_UNEXPECTED_ERROR( Status );
        }
    }
    else if ( CspInitStatus == ERROR_SUCCESS ) {
        Status = CspDebugService(argc, argv);
    }

    ClRtlFreeClusterServiceSecurityDescriptor( );
    QfsCleanup();

    return(Status);
}



void CsGetClusterVersionInfo(
    IN PCLUSTERVERSIONINFO pClusterVersionInfo)
{
    OSVERSIONINFOW   OsVersionInfo;

    pClusterVersionInfo->dwVersionInfoSize = sizeof(CLUSTERVERSIONINFO);
    pClusterVersionInfo->MajorVersion = (WORD)VER_PRODUCTVERSION_W >> 8;
    pClusterVersionInfo->MinorVersion = (WORD)VER_PRODUCTVERSION_W & 0xff;
    pClusterVersionInfo->BuildNumber = (WORD)CLUSTER_GET_MINOR_VERSION(CsMyHighestVersion);

    mbstowcs(pClusterVersionInfo->szVendorId, VER_CLUSTER_PRODUCTNAME_STR,
        (lstrlenA(VER_CLUSTER_PRODUCTNAME_STR)+1));

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionExW(&OsVersionInfo);
    lstrcpynW(pClusterVersionInfo->szCSDVersion, OsVersionInfo.szCSDVersion,
        (sizeof(pClusterVersionInfo->szCSDVersion)/sizeof(WCHAR)));
    pClusterVersionInfo->dwReserved = 0;
    NmGetClusterOperationalVersion(&(pClusterVersionInfo->dwClusterHighestVersion),
        &(pClusterVersionInfo->dwClusterLowestVersion),&(pClusterVersionInfo->dwFlags));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\dmplog.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dmplog.c

Abstract:

    Test app for the cluster registry logging component

    Dumps out a log file

Author:

    John Vert (jvert) 15-Dec-1995


Revision History:

--*/
#include "windows.h"
#include "lmp.h"
#include "stdio.h"
#include "stdlib.h"

#define CsLogModule     0xffff

HLOG MyLog;
LPWSTR LogName = L"c:\\TLOG.LOG";

BOOL WINAPI ScanCb (
    IN PVOID Context,
    IN RMID RmId,
    IN TRID Trid,
    IN const PVOID Buffer,
    IN DWORD DataSize
    );

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    LSN CurrentLsn;
    LSN NextLsn;
    DWORD Status;
    DWORD i,j;
    PDWORD Buffer;
    RMID RmId;
    RMTYPE RmType;
    DWORD DataSize;
    TRID Trid;
    LSN LastLsn;

    MyLog = LogCreate(LogName, 0, NULL, NULL, &LastLsn);
    if (MyLog == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "DMPLOG: LogCreate failed %d\n",GetLastError());
        return(0);
    }

    if (LastLsn == NULL_LSN) {
        fprintf(stderr, "DMPLOG: Log file did not exist\n",LastLsn);
        return(0);
    }

    Buffer = malloc(1000 * sizeof(DWORD));
    if (Buffer == NULL) {
        fprintf(stderr, "DMPLOG: couldn't allocate buffer\n");
        return(0);
    }

        if (argc == 1)
        {
                //read all the records
        CurrentLsn = NULL_LSN;
        do {
                DataSize = 1000 * sizeof(DWORD);
                NextLsn = LogRead(MyLog,
                                CurrentLsn,
                                &RmId,
                                &RmType,
                                &Trid,
                                &TrType,
                                Buffer,
                                &DataSize);
                if (NextLsn != NULL_LSN) {
                printf("LSN %08lx: RMID %d \tTRID %d size: %d",
                        CurrentLsn,
                        RmId,
                        Trid,
                        DataSize);
                for (i=0; i<DataSize/sizeof(DWORD); i++) {
                        if ((i % 4) == 0) {
                        printf("\n\t");
                        }
                        printf("%08lx ",Buffer[i]);
                }
                printf("\n");
                } else {
                printf("END OF LOG\n");
                }


                CurrentLsn = NextLsn;
        } while ( CurrentLsn != NULL_LSN );
        }
        else
        {
                CurrentLsn = atoi(argv[1]);
                //scan the records from the lsn specified
                if (LogScan(MyLog, CurrentLsn, TRUE, (PLOG_SCAN_CALLBACK)ScanCb, NULL) != ERROR_SUCCESS)
                        printf("LogScan returned error\r\n");

        }

    Status = LogClose(MyLog);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DMPLOG: LogClose failed %d\n",Status);
        return(0);
    }

}



BOOL WINAPI ScanCb (
    IN PVOID Context,
    IN RMID RmId,
    IN TRID Trid,
    IN const PVOID Buffer,
    IN DWORD DataSize
    )
{
        int     i;
        PDWORD  pData=Buffer;

        if (!pData)
        {
                printf("Error - scancb got a null buffer\r\n");
        }
    printf("LSN %08lx: RMID %d \tTRID %d size: %d",
        (LSN)(*pData),
        RmId,
        Trid,
        DataSize);
    for (i=0; i<(int)(DataSize/sizeof(DWORD)); i++) {
        if ((i % 4) == 0) {
            printf("\n\t");
        }
        printf("%08lx ",pData[i]);
    }
    printf("\n");
        return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\init\tstpoint.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tstpoint.c

Abstract:

    Implementation of cluster test points

Author:

    John Vert (jvert) 11/25/1996

Revision History:

--*/
#include "initp.h"

#ifdef CLUSTER_TESTPOINT

PTESTPOINT_ENTRY TestArray=NULL;
HANDLE           gTestPtFileMapping;

extern DWORD CsTestPoint;
extern DWORD CsTestTrigger;
extern DWORD CsTestAction;

TESTPOINT_NAME TestPointNames[TestpointMax]={
    L"JoinFailPetition",                  //0
    L"FailNmJoinCluster",                 //1
    L"FailRegisterIntraClusterRpc",       //2
    L"FailJoinCreateBindings",            //3
    L"FailJoinPetitionForMembership",     //4
    L"FailNmJoin",                        //5
    L"FailDmJoin",                        //6
    L"FailApiInitPhase1",                 //7
    L"FailFmJoinPhase1",                  //8
    L"FailDmUpdateJoinCluster",           //9
    L"FailEvInitialize",                  //10
    L"FailNmJoinComplete",                //11
    L"FailApiInitPhase2",                 //12
    L"FailFmJoinPhase2",                  //13
    L"FailLogCommitSize",                 //14
    L"FailClusterShutdown",               //15
    L"FailLocalXsaction",                 //16
    L"FailOnlineResource",                //17
    L"FailSecurityInit",                  //18
    L"FailOmInit",                        //19
    L"FailEpInit",                        //20
    L"FailDmInit",                        //21
    L"FailNmInit",                        //22
    L"FailGumInit",                       //23
    L"FailFmInit",                        //24
    L"FailLmInit",                        //25
    L"FailCpInit",                        //26
    L"FailNmPauseNode",                   //27
    L"FailNmResumeNode",                  //28
    L"FailNmEvictNodeAbort",              //29
    L"FailNmEvictNodeHalt",               //30
    L"FailNmCreateNetwork",               //31
    L"FailNmSetNetworkPriorityOrder",     //32
    L"FailNmSetNetworkPriorityOrder2",    //33
    L"FailNmSetNetworkCommonProperties",  //34
    L"FailNmSetInterfaceInfoAbort",       //35
    L"FailNmSetInterfaceInfoHalt",        //36
    L"FailPreMoveWithNodeDown",           //37
    L"FailPostMoveWithNodeDown",          //38
    L"FailFormNewCluster"                 //39
};


VOID
TestpointInit(
    VOID
    )
/*++

Routine Description:

    Initializes the testpoint code.

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD ArraySize;
    DWORD i;

    //
    // Create the array of testpoint entries in named shared memory.
    //
    ArraySize = sizeof(TESTPOINT_ENTRY)*TestpointMax;
    gTestPtFileMapping = CreateFileMapping((HANDLE)-1,
                                    NULL,
                                    PAGE_READWRITE,
                                    0,
                                    ArraySize,
                                    L"Cluster_Testpoints");
    if (gTestPtFileMapping == NULL) {
        CL_UNEXPECTED_ERROR( GetLastError() );
        return;
    }

    TestArray = MapViewOfFile(gTestPtFileMapping,
                              FILE_MAP_READ | FILE_MAP_WRITE,
                              0,0,
                              ArraySize);
    if (TestArray == NULL) {
        CL_UNEXPECTED_ERROR( GetLastError() );
        return;
    }

    //
    // Initialize test point array
    //
    for (i=0; i<TestpointMax; i++) {
        lstrcpyW(TestArray[i].TestPointName,TestPointNames[i]);
        if ( i == CsTestPoint ) {
            TestArray[i].Trigger = CsTestTrigger;
            TestArray[i].Action = CsTestAction;
        } else {
            TestArray[i].Trigger = TestTriggerNever;
            TestArray[i].Action = TestActionTrue;
        }
        TestArray[i].HitCount = 0;
        TestArray[i].TargetCount = 0;
    }

    return;
}

void TestpointDeInit()
{

    if (TestArray) UnmapViewOfFile(TestArray);
    if (gTestPtFileMapping) CloseHandle(gTestPtFileMapping);
    return;
}



BOOL
TestpointCheck(
    IN TESTPOINT Testpoint
    )
/*++

Routine Description:

    Checks a testpoint to see if it should fire.

Arguments:

    Testpoint - Supplies the testpoint number.

Return Value:

    TRUE if the testpoint has fired.

    FALSE otherwise

--*/

{
    PTESTPOINT_ENTRY Entry;

    if (TestArray == NULL) {
        return(FALSE);
    }
    Entry = &TestArray[Testpoint];
    Entry->HitCount += 1;

    switch (Entry->Trigger) {
        case TestTriggerNever:
            return(FALSE);

        case TestTriggerAlways:
            break;

        case TestTriggerOnce:
            Entry->Trigger = TestTriggerNever;
            break;

        case TestTriggerTargetCount:
            if (Entry->HitCount == Entry->TargetCount) {
                Entry->HitCount = 0;
                break;
            } else {
                return(FALSE);
            }

        default:
            CL_UNEXPECTED_ERROR( Entry->Trigger );

    }

    CsDbgPrint(LOG_CRITICAL,
               "[TP] Testpoint %1!ws! being executed.\n",
               TestPointNames[Testpoint] );

    //
    // The testpoint has fired, figure out what we are supposed to do.
    //
    switch (Entry->Action) {
        case TestActionTrue:
            return(TRUE);
        case TestActionExit:
            ExitProcess(Testpoint);
            break;

        case TestActionDebugBreak:
            DebugBreak();
            break;

    }
    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\lmp.h ===
#ifndef _LMP_H
#define _LMP_H

/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    lmp.h

Abstract:

    Private header file for quorum logging

Author:

    John Vert (jvert) 15-Dec-1995

Revision History:

--*/
#include "windows.h"
#include "service.h"
#include "imagehlp.h"

#define LOG_CURRENT_MODULE LOG_MODULE_LM

//
// Definitions for the behavior of the logger
//
#define MAXNUMPAGES_PER_RECORD      16
#define GROWTH_CHUNK (MAXNUMPAGES_PER_RECORD * 2 * 1024)                 // size to grow file by when we need to reserve space
#define SECTOR_SIZE             1024
#define LOG_MANAGE_INTERVAL     (2 * 60 * 1000) //1 minute..log management functions are performed
//
// Definitions of on-disk structures. The first sector of a log
// file is a LOG_HEADER structure, followed by a sequence of LOGPAGE structures.
// Each LOGPAGE is a size that is a multiple of the sector
// size of the drive. Each LOGPAGE contains a series of LOG_RECORDs, which
// contain the data logged by the client.
//

//
// Define log structure
//
#define LOG_HEADER_SIG 'GOLC'            // "CLOG"
#define LOG_SIG         'GOLH'               // "HLOG"
#define LOGREC_SIG      'SAQS'                          // "random"
#define XSACTION_SIG    'CASX'          // "XSAC"
#define CHKSUM_SIG      L"SKHC"         // "CHKS"          


//SS:size of logrecord is 48 bytes
typedef struct _LOGRECORD {
    DWORD               Signature;      //we need the signature to validate the record
    LSN                 CurrentLsn;
    LSN                 PreviousLsn;
    DWORD               RecordSize;
    RMID                ResourceManager;
    TRID                Transaction;
    TRTYPE              XsactionType;
    DWORD               Flags;
    FILETIME            Timestamp;
    DWORD               NumPages; // set to 1 if not a large record, else set to the number of pages required by the large record.
    DWORD               DataSize;   //date size
    BYTE                Data[];
} LOGRECORD, *PLOGRECORD;

typedef struct _LOGPAGE {
    DWORD       Offset;
    DWORD       Size;
    LOGRECORD   FirstRecord;
} LOGPAGE, *PLOGPAGE;

//
// LOG_HEADER structure is the first 512 bytes of every log
// file. The structure below is carefully computed to be 512
// bytes long.
//
typedef struct _LOG_HEADER {
    DWORD       Signature;                                    // LOG_HEADER_SIG = "CLOG"
    DWORD       HeaderSize;
    FILETIME    CreateTime;
    LSN         LastChkPtLsn;  //points to the lsn of the endchkpt record of the last lsn
    WCHAR       FileName[256-(sizeof(DWORD)*2+sizeof(LSN)+sizeof(FILETIME))];
} LOG_HEADER, *PLOG_HEADER;

typedef struct _LOG_CHKPTINFO{
    WCHAR       szFileName[LOG_MAX_FILENAME_LENGTH];
    LSN         ChkPtBeginLsn; //points to the lsn of the begin chkptrecord for this chkpt.
    DWORD       dwCheckSum;    //checksum for the checkpoint file
}LOG_CHKPTINFO,*PLOG_CHKPTINFO;

//
// Define in-memory structure used to contain current log data
// The HLOG returned to callers by LogCreate is actually a pointer
// to this structure.
//

typedef struct _LOG {
    DWORD       LogSig;                       // "HLOG"
    LPWSTR      FileName;
    QfsHANDLE   FileHandle;
    DWORD       SectorSize;
    PLOGPAGE    ActivePage;
    LSN         NextLsn;
    LSN         FlushedLsn;
    DWORD       FileSize;                     // physical size of file
    DWORD       FileAlloc;                    // total filespace used (always <= FileSize)
    DWORD		MaxFileSize;
    PLOG_GETCHECKPOINT_CALLBACK			pfnGetChkPtCb;
    PVOID		pGetChkPtContext;		//this is passed back to the checkpoint callback function.
    OVERLAPPED  Overlapped;              // use for overlapped I/O
    CRITICAL_SECTION Lock;
    HANDLE      hTimer;                 //timer for managing this lock
} LOG, *PLOG;


typedef struct _XSACTION{
    DWORD       XsactionSig;    //signature for this structure
    LSN         StartLsn;            //the LSN for the start xsaction record
    TRID        TrId;           //the transaction id for the LSN
    RMID        RmId;           //the id of the resource Manager
} XSACTION, *PXSACTION;    
    
//
// Define macros for creating and translating LSNs
//

//
// LSN
// MAKELSN(
//      IN PLOGPAGE Page,
//      IN PLOGRECORD Pointer
//      );
//
// Given a pointer to a page, and a pointer to a log record within that page, generates
// the LSN.
//
#define MAKELSN(Page,Pointer) (LSN)((Page)->Offset + ((ULONG_PTR)Pointer - (ULONG_PTR)Page))

//
// DWORD
// LSNTOPAGE(
//      IN LSN Lsn
//      );
//
// Given an LSN returns the page that contains it.
//
#define LSNTOPAGE(Lsn) ((Lsn) >> 10)

//
// GETLOG(
//      PLOG pLog,
//      HLOG hLog
//      );
//
// Translates an HLOG handle to a pointer to a LOG structure
//
#define GETLOG(plog, hlog) (plog) = (PLOG)(hlog); \
                           CL_ASSERT((plog)->LogSig == LOG_SIG)



// Given a pointer to a record, it fetches the LSN of the next or
// previous record
//
#define GETNEXTLSN(pLogRecord,ScanForward) ((ScanForward) ?     \
    (pLogRecord->CurrentLsn + pLogRecord->RecordSize) :         \
    (pLogRecord->PreviousLsn))


//
// GETXSACTION(
//      PXSACTION pXsaction,
//      HXSACTION hXsaction
//      );
//
// Translates an HLOG handle to a pointer to a LOG structure
//
#define GETXSACTION(pXsaction, hXsaction) (pXsaction) = (PXSACTION)(hXsaction); \
                           CL_ASSERT((pXsaction)->XsactionSig == XSACTION_SIG)


// given the header of the log file, check its validity.
//
#define ISVALIDHEADER(Header) ((Header).Signature == LOG_HEADER_SIG)

//
// Private helper macros
//

#define CrAlloc(size) LocalAlloc(LMEM_FIXED, (size))
#define CrFree(size)  LocalFree((size))

#define AlignAlloc(size) VirtualAlloc(NULL, (size), MEM_COMMIT, PAGE_READWRITE)
#define AlignFree(ptr) VirtualFree((ptr), 0, MEM_RELEASE)



//Timeractivity related stuff

#define MAX_TIMER_ACTIVITIES            5

#define TIMER_ACTIVITY_SHUTDOWN         1
#define TIMER_ACTIVITY_CHANGE           2

//state values for timer activity structure management
#define ACTIVITY_STATE_READY    1   //AddTimerActivity sets it to ready
#define ACTIVITY_STATE_DELETE   2   //RemoveTimerActivity sets it to delete
#define ACTIVITY_STATE_PAUSED   3   //PauseTimerActivity sets it to pause

typedef struct _TIMER_ACTIVITY {
    LIST_ENTRY          ListEntry;
    DWORD               dwState;
    HANDLE              hWaitableTimer;
    LARGE_INTEGER       Interval;
    PVOID               pContext;
    PFN_TIMER_CALLBACK  pfnTimerCb;
}TIMER_ACTIVITY, *PTIMER_ACTIVITY;

//
//  Extern variables
//
extern BOOL bLogExceedsMaxSzWarning;


//inline functions
_inline
DWORD
LSNOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN LSN Lsn
    );

//_inline
DWORD
RECORDOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN PLOGRECORD LogRecord
    );

//_inline
PLOGRECORD
LSNTORECORD(
     IN PLOGPAGE Page,
     IN LSN Lsn
     );

//
// Define function prototypes local to this module
//
PLOG
LogpCreate(
    IN LPWSTR lpFileName,
    IN DWORD  dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID  pGetChkPtContext,
    IN BOOL     bForceReset,
    OPTIONAL OUT LSN *LastLsn
    );

DWORD
LogpMountLog(
    IN PLOG Log
    );

DWORD
LogpInitLog(
    IN PLOG Log
    );

DWORD
LogpGrowLog(
    IN PLOG Log,
    IN DWORD GrowthSize
    );

PLOGPAGE
LogpAppendPage(
    IN PLOG         Log,
    IN DWORD        Size,
    OUT PLOGRECORD  *Record,
    OUT BOOL        *pbMaxFileSizeReached,
    OUT DWORD       *pdwNumPages
    );

DWORD
LogpRead(IN PLOG pLog,
    OUT PVOID       pBuf,
    IN DWORD        dwBytesToRead,
    OUT PDWORD      pdwBytesRead
    );

DWORD
LogpWrite(
    IN PLOG pLog,
    IN PVOID pData,
    IN DWORD dwBytesToWrite,
    IN DWORD *pdwBytesWritten);

void WINAPI
LogpManage(
    IN HANDLE   hTimer,
    IN PVOID    pContext);

DWORD
LogpWriteLargeRecordData(
    IN PLOG pLog,
    IN PLOGRECORD pLogRecord,
    IN PVOID pLogData,
    IN DWORD dwDataSize);

DWORD LogpCheckFileHeader(
    IN  PLOG        pLog,
    OUT LPDWORD     pdwHeaderSize,
    OUT FILETIME    *HeaderCreateTime,
    OUT LSN         *pChkPtLsn
    );

DWORD LogpValidateChkPoint(
    IN PLOG         pLog,
    IN LSN          ChkPtLsn,
    IN LSN          LastChkPtLsn
    );

DWORD LogpValidateLargeRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord, 
    OUT LSN         *pNextLsn
    ) ;

DWORD LogpInvalidatePrevRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord 
    );

DWORD LogpEnsureSize(
    IN PLOG     pLog, 
    IN DWORD    dwTotalSize,
    IN BOOL     bForce
    );

DWORD LogpReset(
    IN PLOG Log,
    IN LPCWSTR  lpszInChkPtFile
    );

VOID
LogpWriteWarningToEvtLog(
    IN DWORD dwWarningType,
    IN LPCWSTR  lpszLogFileName
    );


//timer activity functions
DWORD
TimerActInitialize(VOID);

DWORD
TimerActShutdown(VOID);

#endif //_LMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\logger.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    logger.c

Abstract:

    Provides the persistent log used by the cluster registry service

    This is a very simple logger that supports writing arbitrarily
    sized chunks of data in an atomic fashion.

Author:

    John Vert (jvert) 15-Dec-1995

Revision History:
    sunitas : added mount, scan, checkpointing, reset functionality.
    sunitas : added large record support
--*/
#include "service.h"
#include "lmp.h"
#include "clusudef.h"
/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/

/****
@func       HLOG | LogCreate| Creates or opens a log file. If the file
            does not exist, it will be created. If the file already exists, and is
            a valid log file, it will be opened.

@parm       IN LPWSTR | lpFileName | Supplies the name of the log file to create or open.

@parm       IN DWORD | dwMaxFileSize | Supplies the maximum file size in bytes, must be
            greater than 8K and    smaller than 4 gigabytes.  If the file is exceeds this
            size, the reset function will be called. If 0, the maximum log file size limit
            is set to the default maximum size.

@parm       IN PLOG_GETCHECKPOINT_CALLBACK | CallbackRoutine | The callback routine that
            will provide a checkpoint file and the transaction associated with that checkpoint
            file when LogCheckPoint() is called for this log file.  If this is NULL, then the checkpointing capabilities are
            not associated with the log file.

@parm       IN PVOID | pGetChkPtContext | Supplies an arbitrary context pointer, which will be
            passed to the CallbackRoutine.

@parm       IN BOOL | bForceReset | If true, this function creates an empty log file 
            if the log file doesnt exist or if it is corrupt.

@parm       LSN | *LastLsn | If present, Returns the last LSN written to the log file.
              (NULL_LSN if the log file was created)

@rdesc      Returns a handle suitable for use in subsequent log calls.  NUll in the case of an error.

@xref       <f LogClose>
****/
HLOG
LogCreate(
    IN LPWSTR lpFileName,
    IN DWORD  dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID  pGetChkPtContext,
    IN BOOL     bForceReset,
    OPTIONAL OUT LSN *pLastLsn
    )
{
    PLOG    pLog;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCreate : Entry FileName=%1!ls! MaxFileSize=0x%2!08lx!\r\n",
        lpFileName,dwMaxFileSize);

    //create the log structure
    pLog = LogpCreate(lpFileName, dwMaxFileSize, CallbackRoutine, 
        pGetChkPtContext, bForceReset, pLastLsn);

    if (pLog == NULL)       
        goto FnExit;

    //create a timer for this log
    //SS:TODO?? - currently we have a single timer perfile
    //if that is too much of an overhead, we can manage multiple
    //file with a single timer.
    //create a synchronization timer to manage this file
    pLog->hTimer = CreateWaitableTimer(NULL, FALSE, NULL);

    if (!(pLog->hTimer))
    {
    	CL_LOGFAILURE(GetLastError());
    	return (0);
    }

    //register the timer for this log with the periodic activity timer thread
    AddTimerActivity(pLog->hTimer, LOG_MANAGE_INTERVAL, 1, LogpManage, (HLOG)pLog);

FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCreate : Exit *LastLsn=0x%1!08lx! Log=0x%2!08lx!\r\n",
        *pLastLsn, pLog);
    return((HLOG)pLog);
}

/****
@func       DWORD | LogGetInfo | This is the callback registered to perform
            periodic management functions like flushing for quorum log files.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       OUT LPWSTR | szFileName | Should be a pointer to a buffer MAX_PATH characters wide.

@parm       OUT LPDWORD | pdwCurLogSize | The current size of the log file
            is returned via this.

@parm       OUT LPDWORD | pdwMaxLogSize | The maximum size of the log file
            is returned via this.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
DWORD LogGetInfo(
    IN  HLOG    hLog,
    OUT LPWSTR  szFileName,
    OUT LPDWORD pdwCurLogSize,
    OUT LPDWORD pdwMaxLogSize
    )
{
    PLOG    pLog;
    DWORD   dwError=ERROR_SUCCESS;
    
    GETLOG(pLog, hLog);

    EnterCriticalSection(&pLog->Lock);

    *pdwMaxLogSize = pLog->MaxFileSize;
    *pdwCurLogSize = pLog->FileSize;
    lstrcpyW(szFileName, pLog->FileName);

    LeaveCriticalSection(&pLog->Lock);

    return(dwError);
}

/****
@func       DWORD | LogSetInfo | This is the callback registered to perform
            periodic management functions like flushing for quorum log files.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       OUT LPWSTR | szFileName | Should be a pointer to a buffer MAX_PATH characters wide.

@parm       OUT LPDWORD | pdwCurLogSize | The current size of the log file
            is returned via this.

@parm       OUT LPDWORD | pdwMaxLogSize | The maximum size of the log file
            is returned via this.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
DWORD LogSetInfo(
    IN  HLOG    hLog,
    IN  DWORD   dwMaxLogSize
    )
{
    PLOG    pLog;
    DWORD   dwError=ERROR_SUCCESS;
    
    GETLOG(pLog, hLog);

    EnterCriticalSection(&pLog->Lock);

    if (dwMaxLogSize == 0) dwMaxLogSize = CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE;

    pLog->MaxFileSize = dwMaxLogSize;

    LeaveCriticalSection(&pLog->Lock);

    return(dwError);
}

/****
@func       DWORD | LogClose | Closes an open log file. All pending log writes are
            committed, all allocations are freed, and all handles are closed.

@parm       HLOG | hLog | Supplies the identifier of the log.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
DWORD
LogClose(
    IN HLOG LogFile
    )
{
    PLOG    pLog;
    LSN     NextLsn;
    BOOL    Success;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogClose : Entry LogFile=0x%1!08lx!\r\n",
        LogFile);

    GETLOG(pLog, LogFile);

    //this will close the timer handle
    // we do this while not holding the log so that if a
    // timer event to flush fires it has an opportunity to finish
    if (pLog->hTimer) 
    {
        RemoveTimerActivity(pLog->hTimer);
        pLog->hTimer = NULL;
    }
    EnterCriticalSection(&pLog->Lock);

    
    //if the file is open, LogReset calls LogClose after closing the log handle
    if (QfsIsHandleValid(pLog->FileHandle))
    {
        NextLsn = LogFlush(LogFile, pLog->NextLsn);
        //close the file handle
        Success = QfsCloseHandle(pLog->FileHandle);
//        CL_ASSERT(Success); GORN If connection with MNS resource is broken. Close can fail
    }

    Success = CloseHandle(pLog->Overlapped.hEvent);
    CL_ASSERT(Success);


    AlignFree(pLog->ActivePage);
    CrFree(pLog->FileName);
    LeaveCriticalSection(&pLog->Lock);
    DeleteCriticalSection(&pLog->Lock);
    ZeroMemory(pLog, sizeof(LOG));                   // just in case somebody tries to
                                                    // use this log again.
    CrFree(pLog);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogClose : Exit returning success\r\n");

    return(ERROR_SUCCESS);
}


/****
@func       LSN | LogWrite | Writes a log record to the log file. The record is not
            necessarily committed until LogFlush is called with an LSN greater or equal to the returned LSN.

@parm       HLOG | hLog | Supplies the identifier of the log.

@parm       TRID | TransactionId | Supplies a transaction ID of the record.

@parm       TRID | TransactionType | Supplies a transaction type, start/commit/complete/unit
            transaction.

@parm       RMID | ResourceId | Supplies the ID of the resource manager submitting the log record.

@parm       RMTYPE | ResourceFlags |Resource manager associated flags to be associated with this log record.

@parm       PVOID | LogData | Supplies a pointer to the data to be logged.

@parm       DWORD | DataSize | Supplies the number of bytes of data pointed to by LogData

@rdesc      The LSN of the log record that was created. NULL_LSN if something terrible happened.
            GetLastError() will provide the error code.

@xref       <f LogRead> <f LogFlush>
****/
LSN
LogWrite(
    IN HLOG     LogFile,
    IN TRID     TransactionId,
    IN TRTYPE   XsactionType,
    IN RMID     ResourceId,
    IN RMTYPE   ResourceFlags,
    IN PVOID    LogData,
    IN DWORD    DataSize
    )
{
    PLOGPAGE    Page;
    PLOG        Log;
    PLOGRECORD  LogRecord;
    LSN         Lsn=NULL_LSN;
    BOOL        bMaxFileSizeReached;
    DWORD       TotalSize;
    DWORD       dwError;
    DWORD       dwNumPages;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWrite : Entry TrId=%1!u! RmId=%2!u! RmType = %3!u! Size=%4!u!\r\n",
        TransactionId, ResourceId, ResourceFlags, DataSize);

    CL_ASSERT(ResourceId > RMAny);     // reserved for logger's use

    GETLOG(Log, LogFile);
    TotalSize = sizeof(LOGRECORD) + (DataSize + 7) & ~7;       // round up to qword size

    EnterCriticalSection(&Log->Lock);

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(Log->ActivePage, Log->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    Page = LogpAppendPage(Log, TotalSize, &LogRecord, &bMaxFileSizeReached, &dwNumPages);
    //if a new page couldnt be allocated due to file size limits,
    //then try and reset the log
    if ((Page == NULL) && bMaxFileSizeReached)
    {
        //after resetting the log, try and allocate record space again
        LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, Log->FileName);
        dwError = LogReset(LogFile);
        //SS:LogReset sets the page to be readonly again
#if DBG    
        {
            DWORD dwOldProtect;
            DWORD Status;
            BOOL VPWorked;

            VPWorked = VirtualProtect(Log->ActivePage, Log->SectorSize, PAGE_READWRITE, &dwOldProtect);
            Status = GetLastError();
            CL_ASSERT( VPWorked );
        }        
#endif        
        if (dwError == ERROR_SUCCESS)
            Page = LogpAppendPage(Log, TotalSize, &LogRecord, &bMaxFileSizeReached, &dwNumPages);
        else
            SetLastError(dwError);
    }

    if (Page == NULL)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
        "[LM] LogWrite : LogpAppendPage failed.\r\n");
        goto FnExit;
    }

    CL_ASSERT(((ULONG_PTR)LogRecord & 0x7) == 0);      // ensure qword alignment
    Lsn = MAKELSN(Page, LogRecord);

    //
    // Fill in log record.
    //
    LogRecord->Signature = LOGREC_SIG;
    LogRecord->ResourceManager = ResourceId;
    LogRecord->Transaction = TransactionId;
    LogRecord->XsactionType = XsactionType;
    LogRecord->Flags = ResourceFlags;
    GetSystemTimeAsFileTime(&LogRecord->Timestamp);
    LogRecord->NumPages = dwNumPages;
    LogRecord->DataSize = DataSize;
    if (dwNumPages < 1)
        CopyMemory(&LogRecord->Data, LogData, DataSize);
    else
    {
        if (LogpWriteLargeRecordData(Log, LogRecord, LogData, DataSize) 
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogWrite : LogpWriteLargeRecordData failed. Lsn=0x%1!08lx!\r\n",
                Lsn);
            Lsn = NULL_LSN;                
        }
    }

FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(Log->ActivePage, Log->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    LeaveCriticalSection(&Log->Lock);
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWrite : Exit returning=0x%1!08lx!\r\n",
        Lsn);

    return(Lsn);
}


/****
@func       LSN | LogCommitSize | Commits the size for a record of this size.

@parm       HLOG | hLog | Supplies the identifier of the log.

@parm       DWORD | dwSize | Supplies the size of the data that needs
            to be logged.

@rdesc      The LSN of the log record that was created. NULL_LSN if something terrible happened.
            GetLastError() will provide the error code.

@xref       <f LogRead> <f LogFlush>
****/
DWORD
LogCommitSize(
    IN HLOG     hLog,
    IN RMID     ResourceId,
    IN DWORD    dwDataSize
    )
{
    PLOGPAGE    Page;
    PLOG        pLog;
    PLOGRECORD  LogRecord;
    LSN         Lsn=NULL_LSN;
    BOOL        bMaxFileSizeReached;
    DWORD       dwTotalSize;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwNumPages;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCommitSize : Entry RmId=%1!u! Size=%2!u!\r\n",
        ResourceId, dwDataSize);

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailLogCommitSize) {
        dwError = ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE;
        return(dwError);
    }
#endif

    CL_ASSERT(ResourceId > RMAny);     // reserved for logger's use

    GETLOG(pLog, hLog);
    dwTotalSize = sizeof(LOGRECORD) + (dwDataSize + 7) & ~7;       // round up to qword size

    EnterCriticalSection(&pLog->Lock);
    //dont force the file to grow beyond its max limit
    dwError = LogpEnsureSize(pLog, dwTotalSize, FALSE);
    if (dwError == ERROR_SUCCESS)
        goto FnExit;
    if (dwError == ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE)
    {
        //after resetting the log, try and allocate record space again
        LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, pLog->FileName);
        dwError = LogReset(hLog);
        if (dwError == ERROR_SUCCESS)
        {
            //this time force the file to grow beyond its max size if required
            //this is because we do want to log records greater than the max
            //size of the file
            dwError = LogpEnsureSize(pLog, dwTotalSize, TRUE);

        }        
    }
    if (dwError == ERROR_DISK_FULL)
    {
        //map error
        dwError = ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE;
    }
FnExit:
    LeaveCriticalSection(&pLog->Lock);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCommitSize : Exit, returning 0x%1!08lx!\r\n",
        dwError);

    return(dwError);
}

/****
@func       LSN | LogFlush | Ensures that the given LSN is committed to disk. If this
            routine returns successfully, the given LSN is safely stored on disk and
            is guaranteed to survive a system crash.

@parm       HLOG | hLog | Supplies the identifier of the log.

@parm       LSN | MinLsn | Supplies the minimum LSN to be committed to disk.

@rdesc      The last LSN actually committed to disk. This will always be >= the requested MinLsn.
            NULL_LSN on failure

@xref       <f LogWrite>
****/
LSN
LogFlush(
    IN HLOG LogFile,
    IN LSN MinLsn
    )
{
    PLOG        pLog;
    PLOGPAGE    pPage;
    PLOGRECORD  pRecord;
    LSN         Lsn;
    LSN         FlushedLsn = NULL_LSN;
    DWORD       dwBytesWritten;
    DWORD       dwError;

/*
    //SS: avoid clutter in cluster log
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogFlush : Entry LogFile=0x%1!08lx!\r\n",
        LogFile);

*/
    GETLOG(pLog, LogFile);

    EnterCriticalSection(&pLog->Lock);

    
    //if the MinLSN is greater than a record written to the log file
    if (MinLsn > pLog->NextLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    //find the first record on the active page
    pPage = pLog->ActivePage;
    pRecord = &pPage->FirstRecord;
    Lsn = MAKELSN(pPage, pRecord);


    //if the lsn till which a flush is requested is on an unflushed page,
    //and there are records on the unflushed page and if the flush till
    // this lsn hasnt occured before, orchestrate a flush
    // SS: this scheme is not perfect though it shouldnt cause unnecessary
    // flushing as the flushing interval is 2 minutes..ideally we want to delay the
    // flush if the writes are in progress.
    if ((MinLsn >= Lsn) && (Lsn < pLog->NextLsn) &&  (MinLsn > pLog->FlushedLsn))
    {
        //there are uncommited records
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogFlush : pLog=0x%1!08lx! writing the %2!u! bytes for active page at offset 0x%3!08lx!\r\n",
            pLog, pPage->Size, pPage->Offset);

        (pLog->Overlapped).Offset = pPage->Offset;
        (pLog->Overlapped).OffsetHigh = 0;

        if ((dwError = LogpWrite(pLog, pPage, pPage->Size, &dwBytesWritten))
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogFlush::LogpWrite failed, error=0x%1!08lx!\r\n",
                dwError);
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }
        pLog->FlushedLsn = FlushedLsn = pLog->NextLsn;
    }


/*
    //SS: avoid clutter in cluster log
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogFlush : returning 0x%1!08lx!\r\n",
            pLog->NextLsn);
*/
FnExit:
    LeaveCriticalSection(&pLog->Lock);
    return(FlushedLsn);

}



/****
@func       LSN | LogRead | Reads a log record from the given log.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | Lsn | The LSN of the record to be read.  If NULL_LSN, the first
            record is read.

@parm       OUT RMID | *ResourceId | Returns the resource ID of the requested log record.

@parm       OUT RMTYPE | *ResourceFlags |Returns the resource flags associated with the
            requested log record.

@parm       OUT TRID | *Transaction | Returns the TRID of the requested log record

@parm       TRID | TrType | Returns the transaction type, start/commit/complete/unit
            transaction.

@parm       OUT PVOID | LogData | Returns the data associated with the log record.

@parm       IN OUT DWORD | *DataSize | Supplies the available size of the LogData buffer.
               Returns the number of bytes of data in the log record

@rdesc      Returns the next LSN in the log file.  On failure, returns NULL_LSN.

@xref       <f LogWrite>
****/
LSN
LogRead(
    IN HLOG LogFile,
    IN LSN Lsn,
    OUT RMID *Resource,
    OUT RMTYPE *ResourceFlags,
    OUT TRID *Transaction,
    OUT TRTYPE *TrType,
    OUT PVOID LogData,
    IN OUT DWORD *DataSize
    )
{
    PLOG        pLog;
    DWORD       PageIndex;
    PLOGPAGE    pPage=NULL;
    BOOL        Success;
    DWORD       dwError=ERROR_SUCCESS;
    LSN         NextLsn=NULL_LSN;
    PLOGRECORD  pRecord;
    DWORD       BytesRead;
    LOGPAGE     Dummy;
    PLOGPAGE    pCurPage;
    
    
    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);
    
    EnterCriticalSection(&pLog->Lock);

    Dummy.Size = SECTOR_SIZE;
    if (Lsn == NULL_LSN) 
    {
        Lsn = pLog->SectorSize + RECORDOFFSETINPAGE(&Dummy, &Dummy.FirstRecord);
    }

    if (Lsn >= pLog->NextLsn) 
    {
        CL_LOGFAILURE(dwError = ERROR_INVALID_PARAMETER);
        goto FnExit;
    }

    //
    // Translate LSN to a page number and offset within the page
    //
    PageIndex = LSNTOPAGE(Lsn);

    //if the record exists in the unflushed page, dont need to read 
    //from the disk
    if (pLog->ActivePage->Offset == PageIndex * pLog->SectorSize)
    {
        //if this data is being read, should we flush the page
        pCurPage = pLog->ActivePage;
        goto GetRecordData;
    }

    pPage = AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) 
    {
        CL_LOGFAILURE(dwError = ERROR_NOT_ENOUGH_MEMORY);
        goto FnExit;
    }

    pCurPage = pPage;

    //
    // Translate LSN to a page number and offset within the page
    //
    PageIndex = LSNTOPAGE(Lsn);

    pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
    pLog->Overlapped.OffsetHigh = 0;

    Success = QfsReadFile(pLog->FileHandle,
                       pCurPage,
                       SECTOR_SIZE,
                       &BytesRead,
                       &pLog->Overlapped);
    if (!Success && (GetLastError() == ERROR_IO_PENDING)) {
        Success = QfsGetOverlappedResult(pLog->FileHandle,
                                      &pLog->Overlapped,
                                      &BytesRead,
                                      TRUE);
    }
    if (!Success)
    {
        CL_UNEXPECTED_ERROR(dwError = GetLastError());
        NextLsn = NULL_LSN;
        goto FnExit;
    }
    
GetRecordData:    
    pRecord = LSNTORECORD(pCurPage, Lsn);
    if (pRecord->Signature != LOGREC_SIG)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        NextLsn = NULL_LSN;
        goto FnExit;
    }

    *Resource = pRecord->ResourceManager;
    *ResourceFlags = pRecord->Flags;
    *Transaction = pRecord->Transaction;
    *TrType = pRecord->XsactionType;
    if (LogData)
        CopyMemory(LogData, pRecord->Data, *DataSize);
    *DataSize = pRecord->RecordSize - sizeof(LOGRECORD);
    NextLsn = Lsn + pRecord->RecordSize;

    pRecord = LSNTORECORD(pCurPage, NextLsn);
    if (pRecord->ResourceManager == RMPageEnd) 
    {
        //
        // The next log record is the end of page marker
        // Adjust the LSN to be the one at the start of the
        // next page.
        //
        NextLsn = pCurPage->Offset + pCurPage->Size + 
            RECORDOFFSETINPAGE(pCurPage, &pCurPage->FirstRecord);
    }

FnExit:
    LeaveCriticalSection(&pLog->Lock);
    if (pPage) AlignFree(pPage);
    if (dwError !=ERROR_SUCCESS)
        SetLastError(dwError);
    return(NextLsn);
}

/****
@cb         BOOL |(WINAPI *PLOG_SCAN_CALLBACK)| The callback called by LogScan.

@parm       IN PVOID | Context | Supplies the CallbackContext specified to LogScan

@parm       IN LSN | Lsn | Supplies the LSN of the record.

@parm       IN RMID | Resource | Supplies the resource identifier of the log record

@parm       IN TRID | Transaction | Supplies the transaction identifier of the log record

@parm       IN PVOID | LogData | Supplies a pointer to the log data. This is a read-
            only pointer and may be referenced only until the callback returns.

@parm       IN DWORD | DataLength | Supplies the length of the log record.

@rdesc      Returns TRUE to  Continue scan or FALSE to Abort scan.

@xref       <f LogScan>
****/

/****
@func       LSN | LogScan| Initiates a scan of the log. The scan can be done either forwards (redo) or
            backwards (undo).

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | First | Supplies the first LSN to start with. If NULL_LSN is specified,
            the scan begins at the start (for a forward scan) or end (for
            a backwards scan) of the log.

@parm       IN BOOL | ScanForward | Supplies the direction to scan the log in.
                TRUE - specifies a forward (redo) scan
                FALSE - specifies a backwards (undo) scan.

@parm       IN PLOG_SCAN_CALLBACK | CallbackRoutine |Supplies the routine to be called for each log record.

@parm       IN PVOID | CaklbackContext | Supplies an arbitrary context pointer, which will be
            passed to the CallbackRoutine

@rdesc      ERROR_SUCCESS if successful.  Win32 status if something terrible happened.

@xref       <f LogRead> <f (WINAPI *PLOG_SCAN_CALLBACK)>
****/
DWORD
LogScan(
    IN HLOG LogFile,
    IN LSN FirstLsn,
    IN BOOL ScanForward,
    IN PLOG_SCAN_CALLBACK CallbackRoutine,
    IN PVOID CallbackContext
    )
{
    PLOG        pLog;
    PLOGRECORD  pRecord;
    LOGPAGE     Dummy;
    DWORD       dwError=ERROR_SUCCESS;
    PUCHAR      Buffer;
    PUCHAR      pLargeBuffer;
    PLOGPAGE    pPage;
    int         PageIndex;
    int         OldPageIndex;
    LSN         Lsn;
    DWORD       dwBytesRead;


    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogScan::Entry Lsn=0x%1!08lx! ScanForward=%2!u! CallbackRoutine=0x%3!08lx!\r\n",
        FirstLsn, ScanForward, CallbackRoutine);

    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);

    Buffer = AlignAlloc(SECTOR_SIZE);
    if (Buffer == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    Lsn = FirstLsn;
    if ((!CallbackRoutine) || (Lsn >= pLog->NextLsn))
    {
        //set to invaid param
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    if (Lsn == NULL_LSN)
    {
        if (ScanForward)
        {
            Dummy.Size = SECTOR_SIZE;
            //get the Lsn for the first record
            if (Lsn == NULL_LSN)
                Lsn = pLog->SectorSize + RECORDOFFSETINPAGE(&Dummy, &Dummy.FirstRecord);
        }
        else
        {
            //get the Lsn for the last record
            pPage =pLog->ActivePage;
            pRecord = LSNTORECORD(pPage, pLog->NextLsn);
            Lsn = pRecord->PreviousLsn;
        }
    }

    //initialize to -1 so the first page is read
    OldPageIndex = -1;
    pPage = (PLOGPAGE)Buffer;
    //while there are more records that you can read
    //read the page

    //SS: For now we grab the crtitical section for entire duration
    //Might want to change that
    EnterCriticalSection(&pLog->Lock);

    while ((Lsn != NULL_LSN) & (Lsn < pLog->NextLsn))
    {

        //
        // Translate LSN to a page number and offset within the page
        //
        PageIndex = LSNTOPAGE(Lsn);


        if (PageIndex != OldPageIndex)
        {
            //if the record exists in the unflushed page, dont need to read 
            //from the disk
            if (pLog->ActivePage->Offset == PageIndex * pLog->SectorSize)
            {
                //if this data is being read, should we flush the page
                pPage = pLog->ActivePage;
            }
            else
            {
                //read the page
                pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
                pLog->Overlapped.OffsetHigh = 0;



                dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
                //if it is the last page, then set the new page as the active
                //page
                if (dwError)
                {
                    if (dwError == ERROR_HANDLE_EOF)
                    {
                        //not fatal, set this page as current page
                        dwError = ERROR_SUCCESS;
                        //SS: assume that this page has no
                        //records, set the offset
                        //this will be the current page
                        Lsn = NULL_LSN;
                        continue;
                    }
                    else
                        goto FnExitUnlock;
                }
            }
            //read was successful, no need to read the page unless the
            //record falls on a different page
            OldPageIndex = PageIndex;
        }
        pRecord = LSNTORECORD(pPage, Lsn);

        //SS: skip checkpoint records
        //TBD:: what if the user wants to scan checkpoint records
        //as well
        if (pRecord->ResourceManager < RMAny)
        {
            //
            // The next log record is the end of page marker
            // Adjust the LSN to the next one
            //
            Lsn = GETNEXTLSN(pRecord, ScanForward);

            continue;
        }

        //check if the transaction types are the valid ones
        //for application.
        if ((pRecord->XsactionType != TTStartXsaction) && 
            (pRecord->XsactionType != TTCompleteXsaction))
        {
            //Cant assume that the record will fit in a small page
            //even a transaction unit may be large, even though transaction
            //units records are not returned by this call.
            if (pRecord->NumPages < 1)
            {
                Lsn = GETNEXTLSN(pRecord, ScanForward);
            }                
            else
            {
                //if it is a large record it should be followed by
                //an eop page record
                //get the lsn of the eop record
                Lsn = GETNEXTLSN(pRecord,TRUE);

                //get the page index of the page where the eop record resides
                PageIndex = PageIndex + pRecord->NumPages - 1;
                CL_ASSERT(LSNTOPAGE(Lsn) == (DWORD)PageIndex);
                //read the last page for the large record
                (pLog->Overlapped).Offset = PageIndex * pLog->SectorSize;
                (pLog->Overlapped).OffsetHigh = 0;

                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogScan::reading %1!u! bytes at offset 0x%2!08lx!\r\n",
                    pLog->SectorSize, PageIndex * pLog->SectorSize);

                dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
                //if there are no errors, then check the last record
                if (dwError != ERROR_SUCCESS)
                {

                    goto FnExitUnlock;
                }

                //read the page, make sure that the eop record follows the 
                //large record
                pRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
                    (Lsn - (pLog->Overlapped).Offset));
                CL_ASSERT((pRecord->Signature == LOGREC_SIG) && 
                        (pRecord->ResourceManager == RMPageEnd))
                Lsn = GETNEXTLSN(pRecord, TRUE);
            }
            continue;
        }
            
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogScan::Calling the scancb for Lsn=0x%1!08lx! Trid=%2!u! RecordSize=%3!u!\r\n",
            Lsn, pRecord->Transaction, pRecord->DataSize);

        if (pRecord->NumPages < 1)
        {
             //if the callback requests to stop scan
            if (!(*CallbackRoutine)(CallbackContext, Lsn, pRecord->ResourceManager,
                pRecord->Flags, pRecord->Transaction, pRecord->XsactionType,
                pRecord->Data, pRecord->DataSize))
            break;
            //else go the the next record
            Lsn = GETNEXTLSN(pRecord, ScanForward);

        }
        else
        {
            //for a large record you need to read in the entire data
            pLargeBuffer = AlignAlloc(pRecord->NumPages * SECTOR_SIZE);
            if (pLargeBuffer == NULL) 
            {
                //exit and put something in the eventlog
                dwError = ERROR_NOT_ENOUGH_MEMORY ;
                CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
                break;
            }
            //read the pages
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pLargeBuffer, pRecord->NumPages *
                pLog->SectorSize, &dwBytesRead);
            //if it is the last page, then set the new page as the active
            //page
            if (dwError != ERROR_SUCCESS)
            {
                CL_LOGFAILURE(dwError);
                AlignFree(pLargeBuffer);
                break;
            }
            pRecord = LSNTORECORD((PLOGPAGE)pLargeBuffer, Lsn);

            //if the callback requests to stop scan
            if (!(*CallbackRoutine)(CallbackContext, Lsn, pRecord->ResourceManager,
                pRecord->Flags, pRecord->Transaction, pRecord->XsactionType,
                pRecord->Data, pRecord->DataSize))
            {    
                AlignFree(pLargeBuffer);
                break;
            }
            //the next record should be an eop buffer on the last page
            //of the large record, skip that
            Lsn = GETNEXTLSN(pRecord, ScanForward);
            //since this page doesnt begin with the typical page info,
            //you cant validate this
            pRecord = (PLOGRECORD)(
                (ULONG_PTR)(pLargeBuffer + (Lsn - (pLog->Overlapped).Offset)));

            CL_ASSERT(pRecord->ResourceManager == RMPageEnd);

            //go the the next record
            Lsn = GETNEXTLSN(pRecord, ScanForward);
            AlignFree(pLargeBuffer);
        }
    }

FnExitUnlock:
    LeaveCriticalSection(&pLog->Lock);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogScan::Exit - Returning 0x%1!08lx!\r\n",
        dwError);

FnExit:
    AlignFree(Buffer);
    return(dwError);

}


/****
@func       LSN | LogCheckPoint| Initiates a chk point process in the log.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN BOOL | bAllowReset | Allow the reset of log file to occur
            while checkpointing.  In general, this will be set to TRUE.  Since
            When LogReset() internally invokes LogCheckPoint(), this will be
            set to FALSE.

@parm       IN LPCWSTR | lpszChkPtFile | The checkpt file that should be saved.
            If NULL, the callback function registered for checkpointing is invoked
            to get the checkpoint.

@parm       IN DWORD | dwChkPtSeq | If lpszChkPtFile is not NULL, this should point
            to a valid sequence number associated with the checkpoint.

@rdesc      ERROR_SUCCESS if successful.  Win32 status if something terrible happened.

@comm       The log manager writes the start check point record. Then it invokes the call back to get the checkpoint data.  After writing the
            data to a checkpoint file, it records the lsn of the end checkpoint record in the header.

@xref       <f LogGetLastChkPoint>
****/
DWORD
LogCheckPoint(
    IN HLOG     LogFile,
    IN BOOL     bAllowReset,
    IN LPCWSTR  lpszInChkPtFile,
    IN DWORD    dwChkPtSeq
    )
{
    PLOG            pLog;
    PLOGPAGE        pPage;
    PLOG_HEADER     pLogHeader=NULL;
    DWORD           dwError=ERROR_SUCCESS;
    DWORD           dwTotalSize;
    PLOGRECORD      pLogRecord;
    TRID            ChkPtTransaction,Transaction;
    LSN             Lsn,ChkPtLsn;
    LOG_CHKPTINFO   ChkPtInfo;
    DWORD           dwBytesRead,dwBytesWritten;
    RMID            Resource;
    RMTYPE          RmType;
    BOOL            bMaxFileSizeReached;
    WCHAR           szNewChkPtFile[LOG_MAX_FILENAME_LENGTH];
    DWORD           dwNumPages;
    WCHAR           szPathName[MAX_PATH];
    TRTYPE          TrType;
    DWORD           dwCheckSum = 0;
    DWORD           dwHeaderSum = 0;
    DWORD           dwLen;
    
    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);


    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint entry\r\n");

    ZeroMemory( &ChkPtInfo, sizeof(LOG_CHKPTINFO) );
    
    EnterCriticalSection(&pLog->Lock);
    
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        


    //write the start chkpoint record
    dwTotalSize = sizeof(LOGRECORD) + 7 & ~7;       // round up to qword size
    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    if ((pPage == NULL) && (bMaxFileSizeReached) && (bAllowReset))
    {
        //try and reset the log file
        //the checkpoint will be taken as a part of the reset process
        //if no input checkpoint file is specified
        //SS:note here LogCheckPoint will be called recursively
        LeaveCriticalSection(&pLog->Lock);
        return(LogpReset(pLog, lpszInChkPtFile));
    }

    if (pPage == NULL)
    {
        CL_LOGFAILURE(dwError = GetLastError());
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogCheckPoint: LogpAppendPage failed, error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    Lsn = MAKELSN(pPage, pLogRecord);

    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = RMBeginChkPt;
    pLogRecord->Transaction = 0;                 
    pLogRecord->XsactionType = TTDontCare;
    pLogRecord->Flags = 0;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = 0;
    
    //if chkpt is not specifed get one from input checkpoint
    if (!lpszInChkPtFile)
    {
        if (!pLog->pfnGetChkPtCb)
        {
            dwError = ERROR_INVALID_PARAMETER;
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }

        // get a checkpoint
        dwError = DmGetQuorumLogPath(szPathName, sizeof(szPathName));
        if (dwError  != ERROR_SUCCESS)
        {
            dwError = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: DmGetQuorumLogPath failed, error=%1!u!\r\n",
                dwError);
            goto FnExit;
        }

        szNewChkPtFile[0]= TEXT('\0');
        dwError = (*(pLog->pfnGetChkPtCb))(szPathName, pLog->pGetChkPtContext, szNewChkPtFile,
            & ChkPtTransaction);
        
        //if the chkptfile is created and if it could not be created because it
        //already existed, then we are set.
        if ((dwError != ERROR_SUCCESS)  &&
            ((dwError != ERROR_ALREADY_EXISTS) || (!szNewChkPtFile[0])))
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: Callback failed to return a checkpoint\r\n");
            CL_LOGCLUSERROR1(LM_CHKPOINT_GETFAILED, pLog->FileName);
            goto FnExit;
        }
    }
    else
    {
        //SS:we trust the application to not write a stale checkpoint
        lstrcpyW(szNewChkPtFile, lpszInChkPtFile);
        ChkPtTransaction = dwChkPtSeq;
    }

    //
    //  Chittur Subbaraman (chitturs) - 1/28/99 
    //
    //  Compute and save the checksum for the checkpoint file
    //
    dwError = QfsMapFileAndCheckSum( szNewChkPtFile, &dwHeaderSum, &dwCheckSum );
    if ( dwError != CHECKSUM_SUCCESS )  
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogCheckPoint: MapFileAndCheckSumW returned error=%1!u!\r\n",
              dwError);
        goto FnExit;
    }
    ChkPtInfo.dwCheckSum = dwCheckSum;  

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint: ChkPtFile=%1!ls! Chkpt Trid=%2!d! CheckSum=%3!d!\r\n",
        szNewChkPtFile, ChkPtTransaction, dwCheckSum);

    //prepare the chkpt info structure
    ChkPtInfo.ChkPtBeginLsn = Lsn;
    lstrcpyW(ChkPtInfo.szFileName, szNewChkPtFile);

    //
    //  Chittur Subbaraman (chitturs) - 1/29/99
    //
    //  Add a signature at the end of the file name to denote that
    //  a checksum has been taken.
    //
    dwLen = lstrlenW( ChkPtInfo.szFileName );
    if ( ( dwLen + lstrlenW( CHKSUM_SIG ) + 2 ) <= LOG_MAX_FILENAME_LENGTH )
    {
        lstrcpyW( &ChkPtInfo.szFileName[dwLen+1], CHKSUM_SIG );
    }

    dwTotalSize = sizeof(LOGRECORD) + (sizeof(LOG_CHKPTINFO) + 7) & ~7;       // round up to qword size
    //write the endchk point record to the file.
    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    if ((pPage == NULL) && bMaxFileSizeReached && bAllowReset)
    {
        //try and reset the log file
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogCheckPoint: Maxfilesize exceeded. Calling LogpReset\r\n");
        //the checkpoint will be taken as a part of the reset process
        //if no input checkpoint file is specified
        //SS:note here LogCheckPoint will be called recursively
        LeaveCriticalSection(&pLog->Lock);
        return(LogpReset(pLog, lpszInChkPtFile));
    }

    if (pPage == NULL) {
        CL_LOGFAILURE(dwError = GetLastError());
        goto FnExit;
    }

    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    ChkPtLsn = MAKELSN(pPage, pLogRecord);

    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = RMEndChkPt;
    pLogRecord->Transaction = ChkPtTransaction;    // transaction id associated with the chkpt
    pLogRecord->XsactionType = TTDontCare;
    pLogRecord->Flags = 0;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = sizeof(LOG_CHKPTINFO);
    
    CopyMemory(&pLogRecord->Data, (PBYTE)&ChkPtInfo, sizeof(LOG_CHKPTINFO));



    //flush the log file
    LogFlush(pLog,ChkPtLsn);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint: EndChkpt written. EndChkPtLsn =0x%1!08lx! ChkPt Seq=%2!d! ChkPt FileName=%3!ls!\r\n",
        ChkPtLsn, ChkPtTransaction, ChkPtInfo.szFileName);

    //read the log header and get the old chk point sequence
    //if null
    pLogHeader = AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        ClRtlLogPrint(LOG_UNUSUAL,
                       "[LM] LogCheckPoint: couldn't allocate memory for the header\r\n");
        goto FnExit;
    }


    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if ((dwError = LogpRead(pLog, pLogHeader, pLog->SectorSize, &dwBytesRead))
        != ERROR_SUCCESS)
    {
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to read the header. Error=0x%1!08lx!\r\n",
                dwError);
            goto FnExit;
        }
    }

    if (dwBytesRead != pLog->SectorSize)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to read the complete header\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        //SS: should we do an implicit reset here
        goto FnExit;

    }

    Lsn = pLogHeader->LastChkPtLsn;
    //if there was a previous chkpoint and in most cases
    //there should be one,except when the system just comes up
    ChkPtInfo.szFileName[0]= TEXT('\0');
    if (Lsn != NULL_LSN)
    {
        (pLog->Overlapped).Offset = LSNTOPAGE(Lsn) * pLog->SectorSize;
        (pLog->Overlapped).OffsetHigh = 0;

        //get the old check point file name
        dwBytesRead = sizeof(LOG_CHKPTINFO);
        if ((LogRead(pLog, Lsn, &Resource, &RmType, &Transaction, &TrType,
            &ChkPtInfo, &dwBytesRead)) == NULL_LSN)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to read the chkpt lsn. Error=0x%1!08lx!\r\n",
                dwError);
            goto FnExit;
        }
        if (Resource != RMEndChkPt)
        {
        //SS: this should not happen
#if DBG        
            if (IsDebuggerPresent())
                DebugBreak();
#endif                
            ChkPtInfo.szFileName[0]= TEXT('\0');
            CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        }
    }
    //update the last chkpoint lsn in the header
    pLogHeader->LastChkPtLsn = ChkPtLsn;

    //write the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpCheckpoint : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pLog->SectorSize, pLog->Overlapped.Offset);

    if ((dwError = LogpWrite(pLog, pLogHeader, pLog->SectorSize, &dwBytesWritten))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogCheckPoint: failed to update header after checkpointing, Error=0x%1!08lx!\r\n",
                dwError);
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //flush the log file.

    QfsFlushFileBuffers(pLog->FileHandle);

    //delete the old checkpoint file
    //the old checkpoint file may be the same as the current one, dont delete it, if so
    if (Lsn && (ChkPtInfo.szFileName[0]) &&
        (lstrcmpiW(szNewChkPtFile, ChkPtInfo.szFileName)))
        QfsDeleteFile((LPCTSTR)(ChkPtInfo.szFileName));

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCheckPoint Exit\r\n");


FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    if (pLogHeader != NULL) {
        AlignFree(pLogHeader);
    }
    LeaveCriticalSection(&pLog->Lock);
    return(dwError);
}


/****
@func       LSN | LogReset| Resets the log file and takes a  new checkpoint.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@rdesc      ERROR_SUCCESS if successful.  Win32 status if something terrible happened.

@comm       The log manager creates a new log, takes a checkpoint and renames the old log file.

@xref       <f LogCheckPoint>
****/
DWORD
LogReset(
    IN HLOG LogFile
    )
{
    PLOG        pLog;
    DWORD       dwError;

    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogReset entry...\r\n");

    dwError = LogpReset (pLog, NULL);
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogReset exit, returning 0x%1!08lx!\r\n",
        dwError);
            
    return(dwError);
}


/****
@func       DWORD | LogGetLastChkPoint| This is a callback that is called on
            change of state on quorum resource.

@parm       HLOG | LogFile | A pointer to a DMLOGRECORD structure.
@parm       PVOID | szChkPtFileName | The name of the checkpoint file.
@parm       TRID | *pTransaction | The transaction id associated with the
            checkpoint.
@parm       LSN | *pChkPtLsn | The LSN of the start checkpoint record.

@rdesc      Returns a result code. ERROR_SUCCESS on success.  To find transactions,
            past this checkpoint, the application must scan from the LSN of the start
            checkpoint record.

@xref
****/
DWORD LogGetLastChkPoint(
    IN HLOG     LogFile,
    OUT LPWSTR   szChkPtFileName,
    OUT TRID    *pTransactionId,
    OUT LSN     *pChkPtLsn)
{
    PLOG_HEADER     pLogHeader=NULL;
    PLOG            pLog;
    DWORD           dwError = ERROR_SUCCESS;
    DWORD           dwBytesRead;
    RMID            Resource;
    RMTYPE          RmType;
    TRTYPE          TrType;
    LOG_CHKPTINFO   ChkPtInfo;
    DWORD           dwCheckSum = 0;
    DWORD           dwHeaderSum = 0;
    DWORD           dwLen;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogGetLastChkPoint:: Entry\r\n");


    GETLOG(pLog, LogFile);
    CL_ASSERT(pLog->SectorSize == SECTOR_SIZE);


    EnterCriticalSection(&pLog->Lock);
    if (!szChkPtFileName || !pTransactionId || !pChkPtLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    *pTransactionId = 0;
    *pChkPtLsn = NULL_LSN;

    pLogHeader = AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //read the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if (LogpRead(LogFile, pLogHeader, pLog->SectorSize, &dwBytesRead) != ERROR_SUCCESS)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        goto FnExit;
    }

    if (dwBytesRead != pLog->SectorSize)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;

    }
    //validate the header
    if (!ISVALIDHEADER((*pLogHeader)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogGetLastChkPoint::the file header is corrupt.\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //read the last Chkpoint end record
    if (pLogHeader->LastChkPtLsn != NULL_LSN)
    {
        dwBytesRead = sizeof(LOG_CHKPTINFO);
        if ((LogRead(LogFile , pLogHeader->LastChkPtLsn, &Resource, &RmType, 
            pTransactionId, &TrType, &ChkPtInfo, &dwBytesRead)) == NULL_LSN)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogGetLastChkPoint::LogRead for chkpt lsn 0x%1!08lx! failed\r\n",
                pLogHeader->LastChkPtLsn);
            dwError = GetLastError();
            goto FnExit;
        }
        if (Resource != RMEndChkPt)
        {
        //SS: This should not happen
#if DBG        
            if (IsDebuggerPresent())
                DebugBreak();
#endif                
            dwError = ERROR_CLUSTERLOG_CORRUPT;
            CL_LOGFAILURE(dwError);
            CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
            goto FnExit;
        }
        //
        //  Chittur Subbaraman (chitturs) - 1/28/99
        //
        //  Check if the checkpoint file itself got corrupted. But first
        //  make sure that a checksum was indeed recorded.
        //
        dwLen = lstrlenW( ChkPtInfo.szFileName );
        if ( ( dwLen + lstrlenW( CHKSUM_SIG ) + 2 <= LOG_MAX_FILENAME_LENGTH ) &&
             ( lstrcmpW( &ChkPtInfo.szFileName[dwLen+1], CHKSUM_SIG ) == 0 ) )
        {
            dwError = QfsMapFileAndCheckSum( ChkPtInfo.szFileName, &dwHeaderSum, &dwCheckSum );
            if ( ( dwError != CHECKSUM_SUCCESS ) ||
                 ( dwCheckSum != ChkPtInfo.dwCheckSum ) ||
                 ( dwCheckSum == 0 ) )
            {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[LM] LogGetLastChkPoint - MapFileAndCheckSumW returned error=%1!u!\r\n",
                    dwError);
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[LM] LogGetLastChkPoint - Stored CheckSum=%1!u!, Retrieved CheckSum=%2!u!\r\n",
                    ChkPtInfo.dwCheckSum,
                    dwCheckSum);
                CL_LOGCLUSERROR1( LM_LOG_CHKPOINT_NOT_FOUND, ChkPtInfo.szFileName );
                dwError = ERROR_CLUSTERLOG_CORRUPT;
                goto FnExit;
            }
        }
   
        lstrcpyW(szChkPtFileName, ChkPtInfo.szFileName);
        *pChkPtLsn = ChkPtInfo.ChkPtBeginLsn;
        ClRtlLogPrint(LOG_NOISE,
                "[LM] LogGetLastChkPoint: ChkPt File %1!ls! ChkPtSeq=%2!d! ChkPtLsn=0x%3!08lx! Checksum=%4!d!\r\n",
                szChkPtFileName, *pTransactionId, *pChkPtLsn, dwCheckSum);
    }
    else
    {
        dwError = ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND;
        CL_LOGCLUSWARNING1(LM_LOG_CHKPOINT_NOT_FOUND, pLog->FileName);
    }

FnExit:
    if (pLogHeader) AlignFree(pLogHeader);
    LeaveCriticalSection(&pLog->Lock);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogGetLastChkPoint exit, returning 0x%1!08lx!\r\n",
        dwError);

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\lmmgmt.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lmmgmt.c

Abstract:

    Provides the maintenance functions for the log manager.

Author:

    Sunita Shrivastava (sunitas) 10-Nov-1995

Revision History:

--*/
#include "service.h"
#include "lmp.h"



/****
@doc	EXTERNAL INTERFACES CLUSSVC LM
****/



/****
@func	 	DWORD | LmInitialize| It initializes structures for log file
			management and creates a timer thread to process timer activities.

@rdesc 		ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm		This function is called when the cluster components are initialized.

@xref		<f LmShutdown> <f ClTimerThread>
****/
DWORD
LmInitialize()
{
	DWORD dwError = ERROR_SUCCESS;
	DWORD dwThreadId;
	
	//we need to create a thread to general log management
	//later this may be used by other clussvc client components
	ClRtlLogPrint(LOG_NOISE,
		"[LM] LmInitialize Entry. \r\n");

    if ((dwError = TimerActInitialize()) != ERROR_SUCCESS)
    {
        goto FnExit;
    }
	

	
FnExit:
	return(dwError);
}


/****
@func	 	DWORD | LmShutdown | Deinitializes the Log manager.

@rdesc 		ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm		This function notifies the timer thread to shutdown down and closes
			all resources associated with timer activity management.
@xref		<f LmInitialize>
****/
DWORD
LmShutdown(
    )
{

    ClRtlLogPrint(LOG_NOISE,
    	"[LM] LmShutDown : Entry \r\n");

    TimerActShutdown();
    

	ClRtlLogPrint(LOG_NOISE,
    	"[LM] LmShutDown : Exit\r\n");

	//clean up the activity structure
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\tlog.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tlog.c

Abstract:

    Test app for the cluster registry logging component

Author:

    John Vert (jvert) 15-Dec-1995


Revision History:

--*/
#include "windows.h"
#include "lmp.h"
#include "stdio.h"
#include "stdlib.h"

HLOG MyLog;
LPWSTR LogName = L"c:\\TLOG.LOG";

#define LOG_RECORDS 1000

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    LSN LastLsn;
    DWORD Status;
    int i,j;
    PDWORD Buffer;

    DeleteFileW(LogName);
    MyLog = LogCreate(LogName, 0,
    	NULL, NULL, &LastLsn);
    if (MyLog == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "TLOG: LogCreate failed %d\n",GetLastError);
        return(0);
    }

    if (LastLsn != NULL_LSN) {
        fprintf(stderr, "TLOG: new log file returned LastLsn == %08lx\n",LastLsn);
        return(0);
    }

    Buffer = malloc(1000 * sizeof(DWORD));
    if (Buffer == NULL) {
        fprintf(stderr, "TLOG: couldn't allocate buffer\n");
        return(0);
    }
    for (i=0; i<1000; i++) {
        Buffer[i] = i;
    }

    LastLsn = NULL_LSN;
    for (i=0; i<LOG_RECORDS; i++) {
        Buffer[0] = LastLsn;
        printf("Logging TRID %d size %d\n",i,(sizeof(DWORD)*i));
        LastLsn = LogWrite(MyLog,
                           (TRID)i,
                           (RMID)3,
                           (RMTYPE)0,
                           Buffer,
                           sizeof(DWORD) * i);
        printf("LSN of the last record %d\r\n",LastLsn);
        if (LastLsn == NULL_LSN) {
            fprintf(stderr,
                    "TLOG: LogWrite TRID %d, %d bytes failed %d\n",
                    i,
                    sizeof(DWORD) * i,
                    GetLastError());
            return(0);
        }
    }

    Status = LogClose(MyLog);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "TLOG: LogClose failed %d\n",Status);
        return(0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\timeract.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    timeract.c

Abstract:

    Provides the timer activity functions.

Author:

    Sunita Shrivastava (sunitas) 10-Nov-1995

Revision History:

--*/
#include "service.h"
#include "lmp.h"

//global data
static LIST_ENTRY    gActivityHead;
static HANDLE        ghTimerCtrlEvent=NULL;
static HANDLE        ghTimerCtrlDoneEvent = NULL;       
static HANDLE        ghTimerThread=NULL;
static CRITICAL_SECTION    gActivityCritSec;
static HANDLE        grghWaitHandles[MAX_TIMER_ACTIVITIES];
static PTIMER_ACTIVITY    grgpActivity[MAX_TIMER_ACTIVITIES];
static DWORD        gdwNumHandles;
static DWORD        gdwTimerCtrl;

//internal prototypes
DWORD WINAPI ClTimerThread(PVOID pContext);
void ReSyncTimerHandles();

/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/



/****
@func   DWORD | TimerActInitialize| It initializes structures for log file
            management and creates a timer thread to process timer activities.

@rdesc  ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm   This function is called when the cluster components are initialized.

@xref   <f TimerActShutdown> <f ClTimerThread>
****/
DWORD
TimerActInitialize()
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwThreadId;
    
    //we need to create a thread to general log management
    //later this may be used by other clussvc client components
    ClRtlLogPrint(LOG_NOISE,
        "[LM] TimerActInitialize Entry. \r\n");


    InitializeCriticalSection(&gActivityCritSec);
    
    //initialize the activity structures
    //when a log file is created, an activity structure
    //will be added to this list
    InitializeListHead(&gActivityHead);

    //create an auto-reset event to signal changes to the timer list
    ghTimerCtrlEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!ghTimerCtrlEvent)
    {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
        goto FnExit;        
    }

    //create a manual reset event for the timer thread to signal
    //when it is done syncing the activitity list
    ghTimerCtrlDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!ghTimerCtrlDoneEvent)
    {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
        goto FnExit;        
    }

    
    gdwNumHandles = 1;
    grghWaitHandles[0] = ghTimerCtrlEvent;
    
    //create a thread to do the periodic management
    ghTimerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClTimerThread,
        NULL, 0, &dwThreadId);

    if (!ghTimerThread)
    {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
    }

    
FnExit:
    if (dwError != ERROR_SUCCESS)
    {
        //free up resources
        if (ghTimerCtrlEvent)
        {
            CloseHandle(ghTimerCtrlEvent);
            ghTimerCtrlEvent = NULL;
        }            
        //free up resources
        if (ghTimerCtrlDoneEvent)
        {
            CloseHandle(ghTimerCtrlDoneEvent);
            ghTimerCtrlDoneEvent = NULL;
        }            
        
        DeleteCriticalSection(&gActivityCritSec);
    }
    return(dwError);
}


/****
@func         DWORD | ClTimerThread | This thread does a wait on all the 
            waitable timers registered within the cluster service.

@parm         PVOID | pContext | Supplies the identifier of the log.

@comm        When any of the timers is signaled, it calls the activity callback
            function corresponding to that timer.  When the timer control event
            is signaled, it either resyncs its wait handles or shuts down.
            
@rdesc         ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref        <f AddTimerActivity> <f RemoveTimerActivity>
****/
DWORD WINAPI ClTimerThread(PVOID pContext)
{

    HANDLE      hClTimer;
    DWORD       dwReturn;
    

    while (TRUE)
    {
        dwReturn = WaitForMultipleObjects(gdwNumHandles, grghWaitHandles, FALSE, INFINITE);
        //walk the activity list
        if (dwReturn == WAIT_FAILED)
        {
            //run down the activity lists and call the functions
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] ClTimerThread: WaitformultipleObjects failed 0x%1!08lx!\r\n",
                GetLastError());

        }
        else if (dwReturn == 0)
        {
            //the first handle is the timer ctrl event
            if (gdwTimerCtrl == TIMER_ACTIVITY_SHUTDOWN)
            {
                ExitThread(0);
            }
            else if (gdwTimerCtrl == TIMER_ACTIVITY_CHANGE)
            {
                ReSyncTimerHandles();
            }
        }
        else
        {
            // SS::we got rid of holding the critsec by using the manual
            // reset event.
            if (dwReturn < gdwNumHandles) 
            {
                //if the activity has been set up for delete, we cant rely
                //on the context and callback being there!
                if (grgpActivity[dwReturn]->dwState == ACTIVITY_STATE_READY)
                {
                    //call the corresponding activity fn
                    (*((grgpActivity[dwReturn])->pfnTimerCb))
                        ((grgpActivity[dwReturn])->hWaitableTimer,
                        (grgpActivity[dwReturn])->pContext);
                }                        
            }                
                
        }
    }
    
    return(0);
}


/****
@func       DWORD | ReSyncTimerHandles | resyncs the wait handles,
            when the activity list changes.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function is called by the timer thread to resync its
            wait handles according to the timer activities currently 
            registered.
            
@xref       <f ClTimerThread>
****/
void ReSyncTimerHandles()
{
    PLIST_ENTRY        pListEntry;
    PTIMER_ACTIVITY    pActivity;
    int                i = 1;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] ReSyncTimerHandles Entry. \r\n");


    EnterCriticalSection(&gActivityCritSec);
    pListEntry = gActivityHead.Flink;


    gdwNumHandles = 1;
    
    //will resync the list of waitable timers and activities
    //depending on the activity list
    while ((pListEntry != &gActivityHead) && (i< MAX_TIMER_ACTIVITIES))
    {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        //goto the next link
        pListEntry = pListEntry->Flink;

        if (pActivity->dwState == ACTIVITY_STATE_DELETE)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[LM] ResyncTimerHandles: removed Timer 0x%1!08lx!\r\n",
                pActivity->hWaitableTimer);
            RemoveEntryList(&pActivity->ListEntry);
            //close the timer handle here 
            CloseHandle(pActivity->hWaitableTimer);
            LocalFree(pActivity);
            continue;
        }
        //call the fn
        grghWaitHandles[i] = pActivity->hWaitableTimer;
        grgpActivity[i] = pActivity;
        gdwNumHandles++;
        i++;
    }
    LeaveCriticalSection(&gActivityCritSec);
    //now if timer activities were resynced, we need to 
    //signal all threads that might be waiting on this
    SetEvent(ghTimerCtrlDoneEvent);
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] ReSyncTimerHandles Exit gdwNumHandles=%1!u!\r\n",
        gdwNumHandles);

}


/****
@func       DWORD | AddTimerActivity | Adds a periodic Activity to the timer
            callback list.

@parm       HANDLE | hTimer | A handle to a waitaible timer object.

@parm       DWORD | dwInterval | The duration for this timer, in
            msecs.

@parm       LONG | lPeriod | If lPeriod is 0, the timer is signalled once
            if greater than 0, the timer is periodic. If less than zero, then
            error will be returned.
            
@parm       PFN_TIMER_CALLBACK | pfnTimerCb | A pointer to the callback function
            that will be called when this timer is signaled.

@parm       PVOID | pContext | A pointer to the callback data that will be
            passed to the callback function.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       SetWaitableTimer() for the corresponding timer is called by this
            function for the given duration.  CreateWaitableTimer() must be used to 
            create this timer handle.
            
@xref       <f RemoveTimerActivity>
****/
DWORD AddTimerActivity(IN HANDLE hTimer, IN DWORD dwInterval,
    IN LONG lPeriod, IN PFN_TIMER_CALLBACK pfnTimerCb, IN PVOID pContext)
{
    PTIMER_ACTIVITY     pActivity = NULL;
    DWORD               dwError = ERROR_SUCCESS;
    LARGE_INTEGER       Interval;
    

    ClRtlLogPrint(LOG_NOISE,
        "[LM] AddTimerActivity: hTimer = 0x%1!08lx! pfnTimerCb=0x%2!08lx! dwInterval(in msec)=%3!u!\r\n",
        hTimer, pfnTimerCb, dwInterval);

    pActivity =(PTIMER_ACTIVITY) LocalAlloc(LMEM_FIXED,sizeof(TIMER_ACTIVITY));

    if (!pActivity)
    {
        
        dwError = GetLastError();
        CL_UNEXPECTED_ERROR(dwError);
        goto FnExit;
    }

    Interval.QuadPart = -10 * 1000 * (_int64)dwInterval;    //time in 100 nano secs

    ClRtlLogPrint(LOG_NOISE,
        "[LM] AddTimerActivity: Interval(high)=0x%1!08lx! Interval(low)=0x%2!08lx!\r\n",
        Interval.HighPart, Interval.LowPart);

    pActivity->hWaitableTimer = hTimer;
    memcpy(&(pActivity->Interval), (LPBYTE)&Interval, sizeof(LARGE_INTEGER));
    pActivity->pfnTimerCb = pfnTimerCb;
    pActivity->pContext = pContext;
    //set the timer
    if (lPeriod)
    {
        lPeriod = (LONG)dwInterval;
    }
    else
    {
        lPeriod = 0;
    }        
    if (!SetWaitableTimer(hTimer,  &Interval, lPeriod , NULL, NULL, FALSE))
    {
        CL_LOGFAILURE((dwError = GetLastError()));
        goto FnExit;
    };

    //add to the list of activities
    //and get the timer thread to resync
    EnterCriticalSection(&gActivityCritSec);
    pActivity->dwState = ACTIVITY_STATE_READY;
    InitializeListHead(&pActivity->ListEntry);
    InsertTailList(&gActivityHead, &pActivity->ListEntry);    
    gdwTimerCtrl = TIMER_ACTIVITY_CHANGE;
    LeaveCriticalSection(&gActivityCritSec);
    
    SetEvent(ghTimerCtrlEvent);


FnExit:
    if ( (dwError != ERROR_SUCCESS) &&
         pActivity ) {
        LocalFree(pActivity);
    }
    ClRtlLogPrint(LOG_NOISE,
        "[LM] AddTimerActivity: returns 0x%1!08lx!\r\n",
        dwError);
    return(dwError);
}


/****
@func       DWORD | RemoveTimerActivity | This functions removes the
            activity associated with a timer from the timer threads activity
            list.

@parm       HANDLE | hTimer | The handle to the timer whose related activity will
            be removed.  The handle is closed.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function cancels the waitable timer and removes the activity 
            corresponding to it.  The calling component must not close the handle 
            to the timer. It is closed by the timer activity manager once this function is called.
@xref       <f AddTimerActivity>
****/
DWORD RemoveTimerActivity(HANDLE hTimer)
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;
    PTIMER_ACTIVITY     pActivityToDel = NULL;
    DWORD               dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LmRemoveTimerActivity: Entry 0x%1!08lx!\r\n",
        hTimer);

    EnterCriticalSection(&gActivityCritSec);

    pListEntry = gActivityHead.Flink;
    while (pListEntry != &gActivityHead) {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        if (pActivity->hWaitableTimer == hTimer)
        {
            pActivityToDel = pActivity;
            break;
        }
        pListEntry = pListEntry->Flink;
    }
    if (!pActivityToDel)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LmRemoveTimerActivity: didnt find activity correspondint to 0x%1!08lx!\r\n",
            hTimer);
    }
    else
    {
        //will be deleted by resynctimerhandles
        CancelWaitableTimer(pActivityToDel->hWaitableTimer);
        pActivityToDel->dwState = ACTIVITY_STATE_DELETE;
    }
    //signal the timer thread to resync its array of wait handles
    //from this list
    SetEvent(ghTimerCtrlEvent);
    //do a manual reset on the done event so that we will wait on it
    //until the timer thread has done a resync of its array of
    //wait handles from the list after this thread leaves the critsec
    //note that we do this holding the critsec
    //now we are guaranteed that timer thread will wake us up
    ResetEvent(ghTimerCtrlDoneEvent);
    LeaveCriticalSection(&gActivityCritSec);
    //wait till the timer thread signals that done event
    WaitForSingleObject(ghTimerCtrlDoneEvent, INFINITE);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LmRemoveTimerActivity:  Exit\r\n");

    return(dwError);
}

/****
@func       DWORD | PauseTimerActivity | This functions pauses the
            activity associated with a timer in the timer threads activity
            list.

@parm       HANDLE | hTimer | The handle to the timer whose related activity will
            be removed.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function sets the timer into a paused state so that the timer 
            callbacks are not proccessed.
            
@xref       <f AddTimerActivity> <f 
****/
DWORD PauseTimerActivity(HANDLE hTimer)
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;
    PTIMER_ACTIVITY     pActivityToDel = NULL;
    DWORD               dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] PauseTimerActivity:  Entry 0x%1!08lx!\r\n",
        hTimer);

    EnterCriticalSection(&gActivityCritSec);

    pListEntry = gActivityHead.Flink;
    while (pListEntry != &gActivityHead) {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        if (pActivity->hWaitableTimer == hTimer)
        {
            pActivityToDel = pActivity;
            break;
        }
        pListEntry = pListEntry->Flink;
    }
    if (!pActivityToDel)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] PauseTimerActivity:  didnt find activity correspondint to 0x%1!08lx!\r\n",
            hTimer);
    }
    else
    {
        CL_ASSERT(pActivity->dwState == ACTIVITY_STATE_READY);
        //set the state to be paused
        pActivityToDel->dwState = ACTIVITY_STATE_PAUSED;
    }
    //signal the timer thread to resync its array of wait handles
    //from this list
    SetEvent(ghTimerCtrlEvent);
    //do a manual reset on the done event so that we will wait on it
    //until the timer thread has done a resync of its array of
    //wait handles from the list after this thread leaves the critsec
    //note that we do this holding the critsec
    //now we are guaranteed that timer thread will wake us up
    ResetEvent(ghTimerCtrlDoneEvent);
    LeaveCriticalSection(&gActivityCritSec);
    //wait till the timer thread signals that done event
    WaitForSingleObject(ghTimerCtrlDoneEvent, INFINITE);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] PauseTimerActivity:  Exit\r\n");

    return(dwError);
}

/****
@func       DWORD | UnpauseTimerActivity | This functions unpauses the
            activity associated with a timer in the timer threads activity
            list.

@parm       HANDLE | hTimer | The handle to the timer whose related activity will
            be removed.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function sets the activity into a ready state.
            
@xref       <f AddTimerActivity> <f 
****/
DWORD UnpauseTimerActivity(HANDLE hTimer)
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;
    PTIMER_ACTIVITY     pActivityToDel = NULL;
    DWORD               dwError = ERROR_SUCCESS;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] UnpauseTimerActivity:  Entry 0x%1!08lx!\r\n",
        hTimer);

    EnterCriticalSection(&gActivityCritSec);

    pListEntry = gActivityHead.Flink;
    while (pListEntry != &gActivityHead) {
        pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
        if (pActivity->hWaitableTimer == hTimer)
        {
            pActivityToDel = pActivity;
            break;
        }
        pListEntry = pListEntry->Flink;
    }
    if (!pActivityToDel)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] PauseTimerActivity:  didnt find activity correspondint to 0x%1!08lx!\r\n",
            hTimer);
    }
    else
    {
        CL_ASSERT(pActivity->dwState == ACTIVITY_STATE_PAUSED);
        //set the state to be paused
        pActivityToDel->dwState = ACTIVITY_STATE_READY;
    }
    LeaveCriticalSection(&gActivityCritSec);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] UnpauseTimerActivity:  Exit\r\n");

    return(dwError);
}

/****
@func       DWORD | TimerActShutdown | Deinitializes the TimerActivity manager.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@comm       This function notifies the timer thread to shutdown down and closes
            all resources associated with timer activity management.
@xref       <f TimerActInitialize>
****/
DWORD
TimerActShutdown(
    )
{

    PLIST_ENTRY         pListEntry;
    PTIMER_ACTIVITY     pActivity;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] TimerActShutDown : Entry \r\n");

    //check if we were initialized before
    if (ghTimerThread && ghTimerCtrlEvent)
    {
        //signal the timer thread to kill itself
        gdwTimerCtrl = TIMER_ACTIVITY_SHUTDOWN;
        SetEvent(ghTimerCtrlEvent);
        //wait for the thread to exit
        WaitForSingleObject(ghTimerThread,INFINITE);

        //close the timer thread control event
        CloseHandle(ghTimerCtrlEvent);
        ghTimerCtrlEvent = NULL;

        //close the timer thread control done event
        CloseHandle(ghTimerCtrlDoneEvent);
        ghTimerCtrlDoneEvent = NULL;
        
        CloseHandle(ghTimerThread);
        ghTimerThread = NULL;

        //clean up the activity structures, if there any left
        pListEntry = gActivityHead.Flink;
        while (pListEntry != &gActivityHead) 
        {
            pActivity = CONTAINING_RECORD(pListEntry, TIMER_ACTIVITY, ListEntry);
            CloseHandle(pActivity->hWaitableTimer);
            LocalFree(pActivity);
            pListEntry = pListEntry->Flink;
        }
        //reset the activity head structure
        InitializeListHead(&gActivityHead);

        DeleteCriticalSection(&gActivityCritSec);

    }

    ClRtlLogPrint(LOG_NOISE,
        "[LM] TimerActShutDown : Exit\r\n");

    
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\lmutils.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    lmutils.c
    
Abstract:

    Provides the utility functions used by the logger.
    
Author:

    Sunita Shrivastava (jvert) 30-Mar-1997

Revision History:

--*/
#include "service.h"
#include "lmp.h"

BOOL bLogExceedsMaxSzWarning = FALSE;

/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/

//
// DWORD
// LSNOFFSETINPAGE(
//      IN PLOGPAGE Page,
//      IN LSN Lsn
//      );
//
// Given a pointer to a page and an LSN within that page, computes the offset into the
// page that the log record starts at.
//
_inline
DWORD
LSNOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN LSN Lsn
    )
{
    DWORD Offset;

    Offset = (DWORD)(Lsn - Page->Offset);
    CL_ASSERT(Offset < Page->Size);
    return(Offset);
}


//
// PLOGRECORD
// LSNTORECORD(
//      IN PLOGPAGE Page,
//      IN LSN Lsn
//      );
//
// Given a pointer to a page and an LSN within that page, generates a pointer to the log record
//

//_inline
PLOGRECORD
LSNTORECORD(
     IN PLOGPAGE Page,
     IN LSN Lsn
     )
{
    CL_ASSERT(Lsn != NULL_LSN);
    return((PLOGRECORD)((ULONG_PTR)Page + LSNOFFSETINPAGE(Page,Lsn)));
}

//
// DWORD
// RECORDOFFSETINPAGE(
//      IN PLOGPAGE Page,
//      IN PLOGRECORD LogRecord
//      );
//
// Given a pointer to a page and a log record within that page, computes the offset into the
// page that the log record starts at.
//

//_inline
DWORD
RECORDOFFSETINPAGE(
    IN PLOGPAGE Page,
    IN PLOGRECORD LogRecord
    )
{
    DWORD Offset;

    Offset = (DWORD)((ULONG_PTR)(LogRecord) - (ULONG_PTR)Page);
    CL_ASSERT(Offset < Page->Size);
    return(Offset);
}


/****
@func       PLOG | LogpCreate| Internal entry point for LogCreate.Creates or opens a log file. If the file
            does not exist, it will be created. If the file already exists, and is
            a valid log file, it will be opened.

@parm       IN LPWSTR | lpFileName | Supplies the name of the log file to create or open.

@parm       IN DWORD | dwMaxFileSize | Supplies the maximum file size in bytes, must be
            greater than 8K and smaller than 4 gigabytes.  If the file is exceeds this
            size, the reset function will be called. If 0, the maximum log file size limit
            is set to the default maximum size.

@parm       IN PLOG_GETCHECKPOINT_CALLBACK | CallbackRoutine | The callback routine that
            will provide a checkpoint file and the transaction associated with that checkpoint
            file when LogCheckPoint() is called for this log file.  If this is NULL, then the checkpointing capabilities are
            not associated with the log file.

@parm       IN PVOID | pGetChkPtContext | Supplies an arbitrary context pointer, which will be
            passed to the CallbackRoutine.

@parm       IN BOOL | bForceReset | If true, this function creates an empty log file 
            if the log file doesnt exist or if it is corrupt.
            
@parm       LSN | *LastLsn | If present, Returns the last LSN written to the log file.
              (NULL_LSN if the log file was created)

@rdesc      Returns a pointer to a PLOG structure.  NUll in the case of an error.

@xref       <f LogCreate>
****/

PLOG
LogpCreate(
    IN LPWSTR lpFileName,
    IN DWORD  dwMaxFileSize,
    IN PLOG_GETCHECKPOINT_CALLBACK CallbackRoutine,
    IN PVOID  pGetChkPtContext,
    IN BOOL   bForceReset,
    OPTIONAL OUT LSN *LastLsn
    )
{
    //create a timer activity for this
    PLOG    pLog = NULL;
    LPWSTR  FileName = NULL;
    DWORD   Status;
    BOOL    Success;
    BOOL    FileExists;
    //
    // Capture the filename string
    //
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpCreate : Entry \r\n");

    if (dwMaxFileSize == 0) dwMaxFileSize = CLUSTER_QUORUM_DEFAULT_MAX_LOG_SIZE;

    //SS: we dont put a upper limit on the MaxFileSize that a user may choose.
    FileName = CrAlloc((lstrlenW(lpFileName) + 1) * sizeof(WCHAR));
    if (FileName == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }
    lstrcpyW(FileName, lpFileName);

    //
    // Allocate the log file data structure
    //
    pLog = CrAlloc(sizeof(LOG));
    if (pLog == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }
    pLog->FileHandle = QfsINVALID_HANDLE_VALUE;
    pLog->Overlapped.hEvent = NULL;
    pLog->ActivePage = NULL;
    pLog->hTimer = NULL;
    pLog->FileName = FileName;
    pLog->LogSig = LOG_SIG;
    pLog->MaxFileSize = dwMaxFileSize;
    pLog->pfnGetChkPtCb = CallbackRoutine;
    pLog->pGetChkPtContext = pGetChkPtContext;
    InitializeCriticalSection(&pLog->Lock);

    ZeroMemory(&(pLog->Overlapped), sizeof(OVERLAPPED));
    //
    // Create the event used to synchronize our overlapped I/O.
    //
    pLog->Overlapped.hEvent = CreateEvent(NULL,
                                         TRUE,
                                         TRUE,
                                         NULL);
    if (pLog->Overlapped.hEvent == NULL) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }


    //
    // Create the file
    //
    //SS: we want to create this file with write through since
    //we control the flushing of log pages to the log file
    pLog->FileHandle = QfsCreateFile(pLog->FileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
    //                            0,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
    //                            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
    //                            0,
                                  NULL);
    if (!QfsIsHandleValid(pLog->FileHandle)) {
        Status = GetLastError();
        CL_LOGFAILURE(Status);
        goto ErrorExit;
    }

    FileExists = (GetLastError() == ERROR_ALREADY_EXISTS);

    pLog->SectorSize = SECTOR_SIZE;

    if (FileExists)
    {
        //
        // Log already exists, open it up, validate it,
        // and set everything up so that we can read and
        // write the log records.
        //
        Status = LogpMountLog(pLog);
        if (Status != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_CRITICAL,
                "[LM] LogCreate : LogpMountLog failed, Error=%1!u!\r\n",
                Status);
                
            //
            // Chittur Subbaraman (chitturs) - 12/4/1999
            //
            // Try and blow away the corrupt log and create a new one
            // if the bForceReset flag is TRUE, else exit with error 
            // status.
            //
            if (Status == ERROR_CLUSTERLOG_CORRUPT)
            {               
                if (!bForceReset)
                {
                    CL_LOGFAILURE(Status);
                    CL_LOGCLUSERROR1(LM_QUORUM_LOG_CORRUPT, pLog->FileName);
                    goto ErrorExit;
                }

                //truncate the file
                Status = QfsSetEndOfFile(pLog->FileHandle, 0);
                if (Status != ERROR_SUCCESS)  {
                    CL_LOGFAILURE(Status);
                    goto ErrorExit;
                }
                //create a new one
                Status = LogpInitLog(pLog);
                *LastLsn = NULL_LSN;
            }
        }
        else
        {
            *LastLsn = pLog->NextLsn;
        }
    }
    else
    {
        //
        // Log has been created, write out header
        // page and set everything up for writing.
        //
        if (bForceReset)
        {
            Status = LogpInitLog(pLog);
            *LastLsn = NULL_LSN;
        }
        else
        {
            //
            //  The user has not allowed a reset. So, log a
            //  message to the event log and exit with error status.
            //
            Status = ERROR_CLUSTER_QUORUMLOG_NOT_FOUND;
            *LastLsn = NULL_LSN;
            QfsCloseHandle(pLog->FileHandle);
            pLog->FileHandle = QfsINVALID_HANDLE_VALUE;
            QfsDeleteFile(pLog->FileName);
            CL_LOGCLUSERROR1(LM_QUORUM_LOG_NOT_FOUND, pLog->FileName);
        }
    }

ErrorExit:

    if (Status != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpCreate : Exit Error=0x%1!08lx!\r\n",
            Status);
        if (FileName != NULL) {
            CrFree(FileName);
        }
        if (pLog != NULL) {
            DeleteCriticalSection(&pLog->Lock);
            QfsCloseHandleIfValid(pLog->FileHandle);
            if (pLog->Overlapped.hEvent != NULL) {
                Success = CloseHandle(pLog->Overlapped.hEvent);
                CL_ASSERT(Success);
            }
            if (pLog->ActivePage !=NULL)
                AlignFree(pLog->ActivePage);
            CrFree(pLog);
        }
        SetLastError(Status);
        return(NULL);

    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpCreate : Exit with success\r\n");
        return(pLog);
    }

}


/****
@func       DWORD | LogpManage | This is the callback registered to perform
            periodic management functions like flushing for quorum log files.

@parm       HLOG | hLog | Supplies the identifier of the log.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogCreate>
****/
void WINAPI LogpManage(
    IN HANDLE hTimer, 
    IN PVOID pContext)
{

    HLOG    hLog;
    PLOG    pLog;

/*
    //avoid clutter in cluster log as this is called periodically
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpManage : Entry pContext=0x%1!08lx!\r\n",
        pContext);
*/

    //
    //LogpRaiseAlert();
    hLog = (HLOG)pContext;
    GETLOG(pLog, hLog);

    LogFlush(hLog, pLog->NextLsn);

/*
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpManage : Exit\r\n");
*/

}


/****
@func   DWORD | LogpEnsureSize | This ensures that there is space on
        the disk to commit a record of the given size.

@parm   IN HLOG | hLog | Supplies the identifier of the log.

@parm   IN DWORD |dwSize |  The size of the record.

@parm   IN BOOL |bForce |  If FALSE, the size is not committed if it
        exceeds the file size.  If TRUE, commit the size irrespective
        of the file size.

@comm   This function checks if the disk space for the given record is
        already committed.  If not, it tries to grow the file.  
        
        
@rdesc  ERROR_SUCCESS if successful in commiting disk space or Win32 
        error code if something horrible happened.

@xref   <f LogCommitSize>
****/
DWORD
LogpEnsureSize(
    IN PLOG         pLog,
    IN DWORD        dwSize,
    IN BOOL         bForce
    )
{
    PLOGPAGE    pPage;
    PLOGRECORD  pRecord;
    DWORD       Status=ERROR_SUCCESS;
    DWORD       dwNumPages;
    DWORD       dwNewSize;
    DWORD       dwError;
    //
    // Nobody should ever write less than one log record
    //
    CL_ASSERT(dwSize >= sizeof(LOGRECORD));
    dwNumPages = 0;   //typically zero for small records

    pPage = pLog->ActivePage;
    //
    // Nobody should ever write more than the page size until we
    // support dynamically sized pages.
    //
    if (dwSize > pPage->Size - (sizeof(LOGRECORD) + sizeof(LOGPAGE))) 
    {
        //this is a large record
        //calculate the total number of pages required 
        //sizeof(LOGPAGE) includes space for one record header
        //that will account for the eop written after a large record
        dwNumPages = (sizeof(LOGPAGE) + sizeof(LOGRECORD) + dwSize)/pPage->Size;
        if ((sizeof(LOGPAGE) + sizeof(LOGRECORD) + dwSize) % pPage->Size)
            dwNumPages += 1;
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpEnsureSize : Large record Size=%1!u! dwNumPages=%2!u!\r\n",
            dwSize, dwNumPages);
        /*
        //SS: dont restrict record size here- if the registry takes it
        //make the best effort to log it 

        if (dwNumPages > MAXNUMPAGES_PER_RECORD)
        {
            Status = ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE;
            goto FnExit;
        } 
        */
    }

    pRecord = LSNTORECORD(pPage, pLog->NextLsn);

    //
    // There must always be enough space remaining in the page to write
    // an end-of-page log record.
    //
    CL_ASSERT((RECORDOFFSETINPAGE(pPage, pRecord) + sizeof(LOGRECORD)) <= pPage->Size);

    //
    // If there is not enough space in this page for the requested data and
    // the end-of-page log record, commit size for the new page.
    //
    if ((RECORDOFFSETINPAGE(pPage, pRecord) + dwSize + sizeof(LOGRECORD)) > pPage->Size) 
    {

        //make sure there is enough room in the disk for the new page
        //if there isnt grow the file.
        //if the file has reached its max ceiling, return error
        if (pLog->FileAlloc + ((dwNumPages+1) * pLog->SectorSize) > 
            pLog->FileSize) 
        {
            dwNewSize = pLog->FileSize + GROWTH_CHUNK;
            CL_ASSERT(dwNewSize > pLog->FileSize);         // bummer, log file is >4GB

            //check if the file can be grown, if not, may be a reset
            //is required
            // if the force flag is set, then allow the file
            // to grow the file beyond its max size
            if (dwNewSize > pLog->MaxFileSize && !bForce)
            {
                LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, pLog->FileName);
                Status = ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE;
                goto FnExit;
            }
            //
            // Grow the file.
            //

            Status = QfsSetEndOfFile(pLog->FileHandle, dwNewSize);
            if (Status != ERROR_SUCCESS) 
            {
                CL_LOGFAILURE(Status);
                goto FnExit;
            }
            pLog->FileSize += GROWTH_CHUNK;
 
        }

    }
    
FnExit:
    return(Status);

}


PLOGPAGE
LogpAppendPage(
    IN PLOG         Log,
    IN DWORD        Size,
    OUT PLOGRECORD  *Record,
    OUT BOOL        *pbMaxFileSizeReached,
    OUT DWORD       *pdwNumPages
    )

/*++

Routine Description:

    Finds the next available log record. If this is in the current
    log page, it is returned directly. If the requested size is too
    large for the remaining space in the current log page, the current
    log page is written to disk and a new log page allocated.

Arguments:

    Log - Supplies the log to be appended to

    Size - Supplies the total size in bytes of the log record to append

    Record - Returns a pointer to the log record.

    pbMaxFileSizeReached - if the maximum file size is reached, this is set to
            TRUE.

    pdwNumPages - number of partial or complete pages consumed by this record, if this
        is a large record.  Else it is set to zero.
    
Return Value:

    Returns a pointer to the current log page.

    NULL if something horrible happened.

--*/

{
    PLOGPAGE    pPage;
    PLOGRECORD  Last;
    PLOGRECORD  Current;
    DWORD       Status=ERROR_SUCCESS;
    BOOL        Success;
    DWORD       BytesWritten;
    LSN         LastLsn;
    PLOGPAGE    pRetPage=NULL;

    //
    // Nobody should ever write less than one log record
    //
    CL_ASSERT(Size >= sizeof(LOGRECORD));
    *pdwNumPages = 0;   //typically zero for small records
    *pbMaxFileSizeReached = FALSE;

    pPage = Log->ActivePage;
    //
    // Nobody should ever write more than the page size until we
    // support dynamically sized pages.
    //
    if (Size > pPage->Size - (sizeof(LOGRECORD) + sizeof(LOGPAGE))) 
    {
        //this is a large record
        //calculate the total number of pages required 
        //sizeof(LOGPAGE) includes space for one record header
        //that will account for the eop written after a large record
        *pdwNumPages = (sizeof(LOGPAGE) + sizeof(LOGRECORD) + Size)/pPage->Size;
        if ((sizeof(LOGPAGE) + sizeof(LOGRECORD) + Size) % pPage->Size)
            *pdwNumPages += 1;
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpAppendPage : Large record Size=%1!u! dwNumPages=%2!u!\r\n",
            Size, *pdwNumPages);
        /*
        //SS: dont restrict record size here- if the registry takes it
        //make the best effort to log it 
        if (*pdwNumPages > MAXNUMPAGES_PER_RECORD)
        {
            Status = ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE;
            goto FnExit;
        } 
        */
    }

    Current = LSNTORECORD(pPage, Log->NextLsn);

    //
    // There must always be enough space remaining in the page to write
    // an end-of-page log record.
    //
    CL_ASSERT((RECORDOFFSETINPAGE(pPage, Current) + sizeof(LOGRECORD)) <= pPage->Size);

    //
    // If there is not enough space in this page for the requested data and
    // the end-of-page log record, write the end-of-page record, send the
    // page off to disk, and allocate a new page.
    //
    if ((RECORDOFFSETINPAGE(pPage, Current) + Size + sizeof(LOGRECORD)) > pPage->Size) {

        //
        // Create an end-of-page record
        //
        Current->Signature = LOGREC_SIG;
        Current->RecordSize = pPage->Size - RECORDOFFSETINPAGE(pPage, Current) + (sizeof(LOGPAGE)-sizeof(LOGRECORD));
        Current->ResourceManager = RMPageEnd;
        Current->Transaction = 0;                 
        Current->Flags = 0;
        GetSystemTimeAsFileTime(&Current->Timestamp);
        Current->NumPages = 0;
        //
        // PERFNOTE John Vert (jvert) 18-Dec-1995
        //      No reason this has to be synchronous, there is no commit
        //      necessary here. If we were smart, we would just post these
        //      writes and have them complete to a queue which would free
        //      up or recycle the memory.
        //

        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpAppendPage : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
            pPage->Size, pPage->Offset);

        //
        // Write the current page to disk.
        //
        Log->Overlapped.Offset = pPage->Offset;
        Log->Overlapped.OffsetHigh = 0;
        Status = LogpWrite(Log, pPage, pPage->Size, &BytesWritten);
        if (Status != ERROR_SUCCESS)
        {
            CL_LOGFAILURE(Status);
            goto FnExit;

        }

        LastLsn = Current->CurrentLsn;
        //set the flushed LSN as the LSN of the last record that was committed
        Log->FlushedLsn = Log->NextLsn;
        Log->NextLsn = LastLsn + Current->RecordSize;

        //
        // Create new page
        //
        pPage->Offset += pPage->Size;             // voila, new page!

        //
        //  Make sure all records in the page are zerod out. This will remove headaches caused
        //  by flushing invalid records in a page by say LogFlush. LogFlush flushes an entire 
        //  page and doesn't care if there are invalid records in the page.
        //
        ZeroMemory ( &pPage->FirstRecord, 
                     pPage->Size - ( sizeof ( LOGPAGE ) - sizeof ( LOGRECORD ) ) );

        Current = &pPage->FirstRecord;           // log record immediately following page header
        Current->PreviousLsn = LastLsn;
        Current->CurrentLsn = Log->NextLsn;

        //make sure there is enough room in the disk for the new page
        //if there isnt grow the file.
        //if the file has reached its max ceiling, pbMaxFileSizeReached is set to true
        //At this point, we try and reset the log file
        //SS:Note that if a log file max size is smaller than the number of pages
        //required to contain the record, then we will not be able to grow it
        //even after resetting it.  This means that that right will fail
        if ((Status = LogpGrowLog(Log, (*pdwNumPages+1) * Log->SectorSize)) != ERROR_SUCCESS)
        {
            if (Status == ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE)
                *pbMaxFileSizeReached = TRUE;
            goto FnExit;
        }
    }
    *Record = Current;
    
    //if the record is a large record but does not use the second last page
    //completely, extend it to fill the second last page completely and add the
    //size of the logpage so that offset+currentsize points to the eop record.
    if ((*pdwNumPages) && 
        ((Size + sizeof(LOGPAGE) - sizeof(LOGRECORD)) <= 
            ((*pdwNumPages - 1) * pPage->Size)))
    {
        CL_ASSERT(*pdwNumPages > 1);
        //large records always start on the beginning of the first page
        //the next lsn now points to the first record on the next page
        Size = pPage->Size * (*pdwNumPages - 1);
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpAppendPage : the record fits in one page but not with an eop\r\n");
    }
    Current->RecordSize = Size;

    

    // Advance to next LSN 
    LastLsn = Current->CurrentLsn;
    Log->NextLsn = LastLsn + Current->RecordSize;
    
    //fill in its LSN header
    if (*pdwNumPages == 0)
    {
        //for a large record, logpWriteLargeRecord, will set the next
        //lsn
        Current = LSNTORECORD(pPage, Log->NextLsn);
        Current->PreviousLsn = LastLsn;
        Current->CurrentLsn = Log->NextLsn;
    }
    pRetPage = pPage;
FnExit:
    if (Status != ERROR_SUCCESS)
        SetLastError(Status);
    return(pRetPage);

}


DWORD
LogpInitLog(
    IN PLOG pLog
    )

/*++

Routine Description:

    Initializes a newly created log file.

Arguments:

    Log - Supplies the log to be created.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful.

--*/

{
    PLOG_HEADER     Header=NULL;
    PLOGPAGE        pPage=NULL;
    PLOGRECORD      Record;
    LPWSTR          FileName;
    DWORD           NameLen;
    DWORD           MaxLen;
    DWORD           Status;
    DWORD           dwBytesWritten;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpInitLog : Entry pLog=0x%1!08lx!\r\n",
        pLog);

    //
    // Grow the file to accomodate header and the first log page.
    //
    pLog->FileSize = pLog->FileAlloc = 0;
    Status = LogpGrowLog(pLog, 2 * pLog->SectorSize);
    if (Status != ERROR_SUCCESS)
    {
        goto FnExit;
    }

    //
    // Allocate and initialize log header.
    //
    Header = AlignAlloc(pLog->SectorSize);
    if (Header == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    Header->Signature = LOG_HEADER_SIG;
    Header->HeaderSize = pLog->SectorSize;
    Header->LastChkPtLsn = NULL_LSN;
    GetSystemTimeAsFileTime(&(Header->CreateTime));
    FileName = pLog->FileName;
    NameLen = lstrlenW(FileName);
    MaxLen = sizeof(Header->FileName) / sizeof(WCHAR) - 1;
    if (NameLen > MaxLen) {
        FileName += (NameLen - MaxLen);
    }
    lstrcpyW(Header->FileName,FileName);

    //
    // Write header to disk
    //
    pLog->Overlapped.Offset = 0;
    pLog->Overlapped.OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpAppendPage : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        Header->HeaderSize, pLog->Overlapped.Offset);

    if ((Status = LogpWrite(pLog, Header, Header->HeaderSize, &dwBytesWritten))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpInitLog: failed to write the file header, Error=0x%1!08lx!\r\n",
                Status);
        CL_LOGFAILURE(Status);
        goto FnExit;
    }

    //
    // Allocate and initialize next log page.
    //
    pPage = AlignAlloc(pLog->SectorSize);
    if (pPage == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    pLog->ActivePage = pPage;


    pPage->Offset = Header->HeaderSize;
    pPage->Size = pLog->SectorSize;

    Record = &pPage->FirstRecord;
    Record->PreviousLsn = NULL_LSN;
    Record->CurrentLsn = pLog->NextLsn = MAKELSN(pPage, Record);

    pLog->FlushedLsn = pLog->NextLsn;

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pPage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        

    ClRtlLogPrint(LOG_NOISE,
    "[LM] LogpInitLog : NextLsn=0x%1!08lx! FileAlloc=0x%2!08lx! ActivePageOffset=0x%3!08lx!\r\n",
        pLog->NextLsn, pLog->FileAlloc, pPage->Offset);

FnExit:
    if (Header) {
        AlignFree(Header);
    }
    return(Status);

}


/****
@func       DWORD | LogpMountLog| Mounts an existing log file. Reads the log
            header, verifies the log integrity, and sets up
            the LOG structure to support further operations.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.

@rdesc      Returns ERROR_SUCCESS if successful, else returns the error code.  If
            the log file doesnt look correct, it returns ERROR_LOG_CORRUPT.

@comm       This is called by LogCreate() to mount an existing log file.
            LogCreate() calls LogpInitLog(), if this function returns
            ERROR_CLUSTERLOG_CORRUPT.

@xref       <f LogCreate>
****/
DWORD
LogpMountLog(
    IN PLOG pLog
    )
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwFileSizeHigh;
    PLOGRECORD  pRecord;
    PLOGPAGE    pPage;
    DWORD       Status;
    LSN         Lsn,PrevLsn;
    int         PageIndex, OldPageIndex;
    BOOL        bLastRecord;
    DWORD       dwBytesRead;
    TRID        OldTransaction;
    FILETIME    LastTimestamp;
    LSN         ChkPtLsn = NULL_LSN;    //the checkptlsn read from the header
    LSN         LastChkPtLsn = NULL_LSN; // the last checkptlsn record seen while validating

    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpMountLog : Entry pLog=0x%1!08lx!\r\n",
        pLog);

    //check the size
    pLog->FileSize = QfsGetFileSize(pLog->FileHandle, &dwFileSizeHigh);

    if ((pLog->FileSize == 0xFFFFFFFF) &&
        ((dwError = GetLastError()) != NO_ERROR))
    {
        CL_UNEXPECTED_ERROR(dwError);
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpMountLog GetFileSize returned error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;

    }

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpMountLog::Quorumlog File size=0x%1!08lx!\r\n",
        pLog->FileSize);

    //dont let the file grow more than  4 gigabytes or the max limit
    if ((dwFileSizeHigh != 0 ) || (pLog->FileSize > pLog->MaxFileSize))
    {
        //set in the eventlog
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //if filesize is zero, the file exists but essentially needs to
    //be created, this is needed for reset functionality
    if (!pLog->FileSize)
    {
        dwError = LogpInitLog(pLog);
        goto FnExit;
    }

    //check if the file is atleast as big as one page.
    //assume a fixed sector size
    if (pLog->FileSize < pLog->SectorSize)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpMountLog::file is smaller than log header, error=0x%1!08lx!\r\n",
            dwError);
        //set in the eventlog
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //allocate memore for the active page
    pPage = AlignAlloc(pLog->SectorSize);
    if (pPage == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    //validate the file header, returns the time stamp of the header
    dwError = LogpCheckFileHeader(pLog, &(pPage->Offset),&LastTimestamp, 
        &ChkPtLsn);
    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpMountLog::LogpCheckFileHeader failed, error=0x%1!08lx!\r\n",
            dwError);
        goto FnExit;
    }

    //traverse the chain of records, to find the active page
    //find the next lsn while validating the records.
    //pPageOffset is set by LogpCheckFileHeader
    pPage->Size = pLog->SectorSize;
    pRecord = &pPage->FirstRecord;
    OldPageIndex = -1;
    OldTransaction = 0;
    bLastRecord = FALSE;
    Lsn = MAKELSN(pPage, pRecord);
    PrevLsn = NULL_LSN;
    
    while (!bLastRecord)
    {
        //
        // Translate LSN to a page number and offset within the page
        //
        PageIndex = LSNTOPAGE(Lsn);

        if (PageIndex != OldPageIndex)
        {
            //read the page
            (pLog->Overlapped).Offset = PageIndex * pLog->SectorSize;
            (pLog->Overlapped).OffsetHigh = 0;

            ClRtlLogPrint(LOG_NOISE,
                "[LM] LogpMountLog::reading %1!u! bytes at offset 0x%2!08lx!\r\n",
                pLog->SectorSize, PageIndex * pLog->SectorSize);

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            //if it is the last page, then set the new page as the active
            //page
            if (dwError)
            {
                if (dwError == ERROR_HANDLE_EOF)
                {

                    ClRtlLogPrint(LOG_NOISE,
                        "[LM] LogpMountLog::eof detected, extend this file,setting this page active\r\n");

                    //find the current allocated size,
                    //file alloc is currently at the end of the previous page
                    pLog->FileAlloc = PageIndex * pLog->SectorSize;
                    //extend the file to accomodate this page
                    Status = LogpGrowLog(pLog, pLog->SectorSize);
                    if (Status != ERROR_SUCCESS)
                    {
                        //set in the eventlog
                        dwError = ERROR_CLUSTERLOG_CORRUPT;
                        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
                        goto FnExit;
                    }
                    //file alloc should now point to the end of the current page

                    //not fatal, set this page as current page
                    dwError = ERROR_SUCCESS;

                    pPage->Offset = (pLog->Overlapped).Offset;
                    pPage->Size = pLog->SectorSize;

                    //set the LSN to be the first LSN on this page.
                    pRecord = &pPage->FirstRecord;
                    pRecord->PreviousLsn = PrevLsn;
                    Lsn = pRecord->CurrentLsn = MAKELSN(pPage, pRecord);
                    bLastRecord = TRUE;
                    continue;
                }
                else
                    goto FnExit;
            }
            //the read may succeed and the page may have invalid data
            //since the last log writes may not be flushed
            if ((pPage->Offset != (pLog->Overlapped).Offset) ||
                (pPage->Size != pLog->SectorSize))
            {

                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogpMountLog::unflushed page detected, set as active\r\n");

                pPage->Offset = (pLog->Overlapped).Offset;
                pPage->Size = pLog->SectorSize;

                pRecord = &pPage->FirstRecord;
                pRecord->PreviousLsn = PrevLsn;
                Lsn = pRecord->CurrentLsn = MAKELSN(pPage, pRecord);
                bLastRecord = TRUE;
                continue;
            }
            //set the new page index to the old one
            OldPageIndex = PageIndex;

        }
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpMountLog::checking LSN 0x%1!08lx!\r\n",
            Lsn);
        pRecord = LSNTORECORD(pPage, Lsn);

        //if the record is doesnt look valid then set the active
        //record and page as the current one
        if ((pRecord->Signature != LOGREC_SIG) || (pRecord->CurrentLsn != Lsn))
        {
            ClRtlLogPrint(LOG_NOISE,
                          "[LM] LogpMountLog: Reached last record, RecordLSN=0x%1!08lx!...\n",
                          pRecord->CurrentLsn);
            bLastRecord = TRUE;
            continue;
        }
        //if the new time stamp is smaller, then log a message
        if (CompareFileTime(&LastTimestamp, &(pRecord->Timestamp)) > 0)
        {
            //
            //  Chittur Subbaraman (chitturs) - 3/7/2001
            //
            //  Do not compare the timestamps for monotonic increase. Due to clocks between nodes
            //  not being as close in sync as they should be, we run into situation in which
            //  we stop mounting the log after a certain LSN. This leads the subsequent LogpValidateCheckpoint
            //  to believe that the log is corrupted when in fact it is just time-screwed.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[LM] LogpMountLog: Timestamp in log is not monotonically increasing, LastTS=0x%1!08lx!, NewTS=0x%2!08lx!\n",
                          LastTimestamp,
                          pRecord->Timestamp);
#if 0
            bLastRecord = TRUE;
            continue;
#endif
        }
        //if it is a log management record
        if (pRecord->ResourceManager < RMAny)
        {
            // This record is a logmanagement record
            // if it is an end checkpoint record, remember that just in case
            // the header doesnt indicate that
            if (pRecord->ResourceManager == RMEndChkPt)
                LastChkPtLsn = Lsn;

            // Adjust the LSN to the next one

            PrevLsn = Lsn;
            Lsn = GETNEXTLSN(pRecord, TRUE);
            LastTimestamp = pRecord->Timestamp;
            continue;
        }


        //SS : should we also validate transaction ids on write
        //check that the transaction id is greater
        if (pRecord->Transaction < OldTransaction)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                          "[LM] LogpMountLog: Current Xid less than last Xid, CurXid=0x%1!08lx!, LastXid=0x%2!08lx!...\n",
                          pRecord->Transaction,
                          OldTransaction);
            bLastRecord = TRUE;
            continue;
        }

        
        //save the current LSN,go the the next record if this is valid
        PrevLsn = Lsn;

        //if this is a large record, skip the eop on the last page
        //but look for an eop to ensure that the large record is valid
        //SS: Have checksums for phase 2
        if (pRecord->NumPages)
        {
            //if the record is not valid, then set this as the current
            //record
            if (LogpValidateLargeRecord(pLog, pRecord, &Lsn) != ERROR_SUCCESS)
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogpMountLog::Invalid large record at LSN 0x%1!08lx!\r\n",
                    Lsn);
                bLastRecord = TRUE;
                continue;
            }
            
            
        }
        else
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
        }
        //this is a valid record, if the transaction id is the same as the last id
        //invalidate the previous LSN
        //SS: local xsactions have the same id, 
        if ((pRecord->Transaction == OldTransaction) && 
            ((pRecord->XsactionType ==  TTCommitXsaction) || 
            (pRecord->XsactionType == TTCompleteXsaction)))
             LogpInvalidatePrevRecord(pLog, pRecord);

        //save the the old transaction id for completed or committed records
        //save the time stamp and the transaction id of the current record
        LastTimestamp = pRecord->Timestamp;
        if ((pRecord->XsactionType == TTCompleteXsaction) ||
            (pRecord->XsactionType == TTCommitXsaction))
            OldTransaction = pRecord->Transaction;
    }

    // set the active page and the next record
    pLog->NextLsn = Lsn;
    pLog->ActivePage = pPage;

      //set the file alloc size, to the end of the current page
    pLog->FileAlloc = pPage->Offset + pPage->Size;
    CL_ASSERT(pLog->FileAlloc <= pLog->FileSize);

    //make sure that the next lsn is prepared
    pRecord = LSNTORECORD(pPage, Lsn);
    pRecord->PreviousLsn = PrevLsn;
    pRecord->CurrentLsn = Lsn;

    pLog->FlushedLsn = Lsn;

    //validate the chkpoint record
    //either it should be null or there should be a valid checkpoint record in there
    dwError = LogpValidateChkPoint(pLog, ChkPtLsn, LastChkPtLsn);
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpMountLog : NextLsn=0x%1!08lx! FileAlloc=0x%2!08lx! ActivePageOffset=0x%3!08lx!\r\n",
        pLog->NextLsn, pLog->FileAlloc, pPage->Offset);

#if DBG    
    {
        DWORD dwOldProtect;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pPage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }
#endif        

FnExit:
    return(dwError);

}


/****
@func       DWORD | LogpMountLog| Mounts an existing log file. Reads the log
            header, verifies the log integrity, and sets up
            the LOG structure to support further operations.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       OUT LPDWORD | pdwLogHeaderSize | Returns the size of the log header structure.
@parm       OUT FILETIME | *pHeaderTimestamp | Returns the time when the log header 
            was created.
            
@rdesc      Returns ERROR_SUCCESS if successful, else returns the error code.  If
            the log file doesnt look correct, it returns ERROR_CLUSTERLOG_CORRUPT.

@comm       This is called by LogpMountLog() to validate the header of a log file.

@xref       <f LogpMountLog>
****/
DWORD LogpCheckFileHeader(
    IN PLOG         pLog,
    OUT LPDWORD     pdwLogHeaderSize,
    OUT FILETIME    *pHeaderTimestamp,
    OUT LSN         *pChkPtLsn
    )
{
    PLOG_HEADER pLogHeader;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwBytesRead;

    
    pLogHeader = AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }


    //read the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if ((dwError = LogpRead(pLog, pLogHeader, pLog->SectorSize, &dwBytesRead))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::Read of the log header failed, error=0x%1!08lx!\r\n",
            dwError);
        dwError = ERROR_CLUSTERLOG_CORRUPT;            
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    if (dwBytesRead != pLog->SectorSize)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::Failed to read the complete header,bytes read 0x%1!u!\r\n",
            dwBytesRead);
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;

    }
    //validate the header
    if (!ISVALIDHEADER((*pLogHeader)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::the file header is corrupt.\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    *pdwLogHeaderSize = pLogHeader->HeaderSize;
    *pHeaderTimestamp = pLogHeader->CreateTime;
    *pChkPtLsn = pLogHeader->LastChkPtLsn;
FnExit:
    if (pLogHeader) 
    {
        AlignFree(pLogHeader);
    }
    return(dwError);
}

/****
@func       DWORD | LogpValidateChkPt| This checks that the header points to the
            last checkpoint.  If not, it scans the log file from the end
            and if it finds a checkpoint, updates the header with that information.
            If no valid checkpoint exists, it sets the header Checkpt LSN to
            NULL_LSN.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       IN LSN | ChkPtLsn | Supplies the ChkPtLsn read from the log header
@parm       IN LSN | LastChkPtLsn | Supplies the last valid chkpoint record found
                during the mount process.

@rdesc      Returns ERROR_SUCCESS if successful, else returns the error code.  If
            the log file doesnt look correct, it returns ERROR_CLUSTERLOG_CORRUPT.

@comm       This is called by LogpMountLog() to validate the header of a log file.

@xref       <f LogpMountLog>
****/
DWORD LogpValidateChkPoint(
    IN PLOG         pLog,
    IN LSN          ChkPtLsn,
    IN LSN          LastChkPtLsn)
{
    PLOG_HEADER     pLogHeader = NULL;
    DWORD           dwError = ERROR_SUCCESS;
    DWORD           dwNumBytes;
    DWORD           Status;
    RMID            Resource;
    RMTYPE          RmType;
    TRTYPE          TrType;
    LOG_CHKPTINFO   ChkPtInfo;
    TRID            TrId;
    QfsHANDLE          hChkPtFile = QfsINVALID_HANDLE_VALUE;

    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateChkPoint: Entry\r\n");

    CL_ASSERT(LastChkPtLsn < pLog->NextLsn);
    
    //if the header indicates that there is a checkpoint
    //and the most recent checkpoint record is the same as the one in the header
    //there is nothing to do, return success.
    if ((ChkPtLsn == LastChkPtLsn) && (ChkPtLsn < pLog->NextLsn))
    {
        goto ValidateChkPtFile;
    }        
    //if the header indicates there is a check point but it wasnt mounted, 
    //log corruption in the event log
    if (ChkPtLsn >= pLog->NextLsn)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpValidateChkPoint: ChkptLsn in header wasnt validated by mount\r\n");
        //but the mount procedure failed to validate that record
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT, pLog->FileName);
#if DBG
        if (IsDebuggerPresent())
            DebugBreak();
#endif            
            
    }            

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateChkPoint: Updating header with the LastChkPtLsn=0x%1!08lx!\r\n",
        LastChkPtLsn);

    //if not it could be that a checkpoint was taken but the header couldnt
    //be flushed with the last chkpt
    
    pLogHeader = (PLOG_HEADER)AlignAlloc(pLog->SectorSize);
    if (pLogHeader == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }


    //read the header
    (pLog->Overlapped).Offset = 0;
    (pLog->Overlapped).OffsetHigh = 0;

    if ((dwError = LogpRead(pLog, pLogHeader, pLog->SectorSize, &dwNumBytes))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpValidateChkPoint::Read of the log header failed, error=0x%1!08lx!\r\n",
            dwError);
        dwError = ERROR_CLUSTERLOG_CORRUPT;            
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    //recheck the header signature
    if (!ISVALIDHEADER((*pLogHeader)))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpCheckFileHeader::the file header is corrupt.\r\n");
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    //set the last lsn
    pLogHeader->LastChkPtLsn = LastChkPtLsn;

    //write the header back        
    pLog->Overlapped.Offset = 0;
    pLog->Overlapped.OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateChkPoint : Writing %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pLogHeader->HeaderSize, pLog->Overlapped.Offset);


    if ((dwError = LogpWrite(pLog, pLogHeader, pLogHeader->HeaderSize, &dwNumBytes))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpInitLog: failed to write the file header, Error=0x%1!08lx!\r\n",
                dwError);
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

ValidateChkPtFile:
    //no need to verify that the checkpoint file exists
    if (LastChkPtLsn == NULL_LSN)
        goto FnExit;
    dwNumBytes = sizeof(LOG_CHKPTINFO);
    if ((LogRead((HLOG)pLog , LastChkPtLsn, &Resource, &RmType, 
        &TrId, &TrType, &ChkPtInfo, &dwNumBytes)) == NULL_LSN)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpValidateChkPt::LogRead for chkpt lsn 0x%1!08lx! failed\r\n",
            pLogHeader->LastChkPtLsn);
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }
    if (Resource != RMEndChkPt)
    {
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGFAILURE(dwError);
        CL_LOGCLUSERROR1(LM_LOG_CORRUPT, pLog->FileName);
        goto FnExit;
    }

    //get the file name, try and open it
    hChkPtFile = QfsCreateFile(ChkPtInfo.szFileName,
                                  GENERIC_READ ,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL);

    if (!QfsIsHandleValid(hChkPtFile) )
    {        
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpValidateChkPoint: The checkpt file %1!ws! could not be opened. Error=%2!u!\r\n",
                ChkPtInfo.szFileName, dwError);       
        dwError = ERROR_CLUSTERLOG_CORRUPT;
        CL_LOGCLUSWARNING1(LM_LOG_CORRUPT,pLog->FileName);
        goto FnExit;
    }

    
FnExit:
    ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpValidateChkPoint: Exit, returning 0x%1!08lx!\r\n", 
            dwError);
    QfsCloseHandleIfValid(hChkPtFile);
    if (pLogHeader) AlignFree(pLogHeader);
    return(dwError);
}


/****
@func       DWORD | LogpValidateLargeRecord| Validates a large record and advances
            the LSN to the record following the eop record which marks the end of
            a large record.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       IN PLOGRECORD | pRecord| Supplies a pointer to the large record.
@parm       IN PLOGRECORD | pNextLsn| The LSN of the record following the
            EOP record after the large record is returned.

@rdesc      If a valid EOP record exists after the large record, the large
            record is considered valid and this function returns ERROR_SUCCESS,
            else it returns an error code.           

@comm       This is called by LogpMountLog() to validate large records.

@xref       <f LogpMountLog>
****/
DWORD LogpValidateLargeRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord, 
    OUT LSN         *pNextLsn) 
{

    DWORD       dwError = ERROR_SUCCESS;
    LSN         EopLsn;
    PLOGRECORD  pEopRecord;
    PLOGPAGE    pPage = NULL;
    DWORD       dwBytesRead;
    DWORD       dwPageIndex;

    //traverse the chain of records, to find the active page
    //find the next lsn
    pPage = AlignAlloc(pLog->SectorSize);
    if (pPage == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }

    dwPageIndex = LSNTOPAGE(pRecord->CurrentLsn);
    dwPageIndex = (dwPageIndex + pRecord->NumPages - 1);
    //read the last page for the large record
    (pLog->Overlapped).Offset = dwPageIndex * pLog->SectorSize;
    (pLog->Overlapped).OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpValidateLargeRecord::reading %1!u! bytes at offset 0x%2!08lx!\r\n",
        pLog->SectorSize, dwPageIndex * pLog->SectorSize);

    dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
    //if there are no errors, then check the last record
    if (dwError == ERROR_SUCCESS)
    {
        //read the page, make sure that the eop record follows the 
        //large record
        EopLsn = GETNEXTLSN(pRecord,TRUE);
        CL_ASSERT(LSNTOPAGE(EopLsn) == dwPageIndex);
        pEopRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
            (EopLsn - (pLog->Overlapped).Offset));
        if ((pEopRecord->Signature == LOGREC_SIG) && 
            (pEopRecord->ResourceManager == RMPageEnd) &&
            (CompareFileTime(&(pRecord->Timestamp),&(pEopRecord->Timestamp)) <= 0)
            )
        {
            //move to the next page 
            *pNextLsn = GETNEXTLSN(pEopRecord, TRUE);
        }
        else
            dwError = ERROR_CLUSTERLOG_CORRUPT;
        
    }
FnExit:
    if (pPage) 
        AlignFree(pPage);
    return(dwError);
}



/****
@func       DWORD | LogpInvalidatePrevRecord| This function is called at mount time to 
            invalidate a previous record with the same transaction id.

@parm       IN PLOG | pLog | Supplies a pointer to the log structure.
@parm       IN PLOGRECORD | pRecord| Supplies a pointer to the record.

@rdesc      Returns ERROR_SUCCESS on success, else returns error code.

@comm       This is called by LogpMountLog() to invalidate a record with the same transaction
            id.  This is because the locker node may write a transaction record to the 
            log and die before it can be propagated to other nodes. This transaction record
            is then invalid.

@xref       <f LogpMountLog>
****/
DWORD LogpInvalidatePrevRecord(
    IN PLOG         pLog, 
    IN PLOGRECORD   pRecord 
) 
{

    DWORD       dwError = ERROR_SUCCESS;
    PLOGRECORD  pPrevRecord;
    LSN         PrevLsn;
    PLOGPAGE    pPage = NULL;
    DWORD       dwBytesRead;
    DWORD       dwPageIndex;
    TRID        TrId;
    BOOL        bPrevRecordFound = FALSE;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpInvalidatePrevRecord : Entry, TrId=%1!08lx!\r\n",
        pRecord->Transaction);

    //allocate a page to read the record headers
    pPage = AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) 
    {
        CL_LOGFAILURE(dwError = ERROR_NOT_ENOUGH_MEMORY);
        goto FnExit;
    }
    TrId = pRecord->Transaction;

    //try and find the last valid transaction with the same id, there should be one
    pPrevRecord = pRecord;       
    while (!bPrevRecordFound)
    {
        PrevLsn = pPrevRecord->PreviousLsn;

        if (PrevLsn == NULL_LSN)
            break;
            
        dwPageIndex = LSNTOPAGE(PrevLsn);

        pLog->Overlapped.Offset = dwPageIndex * pLog->SectorSize;
        pLog->Overlapped.OffsetHigh = 0;

        dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);

        if (dwError != ERROR_SUCCESS)
            goto FnExit;

        pPrevRecord = LSNTORECORD(pPage, PrevLsn);

        if (pPrevRecord->ResourceManager < RMAny)
            continue;
        if ((pPrevRecord->ResourceManager == pRecord->ResourceManager) && 
            (pPrevRecord->Transaction == TrId) &&
            ((pPrevRecord->XsactionType == TTCompleteXsaction) || 
             (pPrevRecord->XsactionType == TTCommitXsaction)))
        {
            bPrevRecordFound = TRUE;                
            pPrevRecord->ResourceManager = RMInvalidated;
            //write the new page out
            dwError = LogpWrite(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError != ERROR_SUCCESS)
            {
                goto FnExit;
            }
            ClRtlLogPrint(LOG_NOISE,
                "[LM] LogpInvalidatePrevRecord : record at LSN=%1!08lx! invalidated\r\n",
                PrevLsn);
        }
            
    }
    
FnExit:    
    if (pPage) AlignFree(pPage);
    return(dwError);
}


DWORD
LogpRead(
    IN PLOG     pLog,
    OUT PVOID   pBuf,
    IN DWORD    dwBytesToRead,
    OUT PDWORD  pdwBytesRead
    )

/*++

Routine Description:

    Reads a page(pLog->SectorSize) from the log file from the offsets set in pLog->Overlapped
    structure.

Arguments:

    Log - Supplies the log to be grown.

    pBuf - Supplies the buffer to read into

    dwBytesToRead - bytes to read

    pdwBytesRead - pointer where the bytes read are returned


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful. ERROR_HANDLE_EOF if the end of file is
    reached.

--*/
{
    DWORD   dwError=ERROR_SUCCESS;
    BOOL    Success;

    *pdwBytesRead = 0;

    //
    // Make sure input buffer is aligned
    //
    CL_ASSERT(((ULONG_PTR)pBuf % 512) == 0);

    Success = QfsReadFile(pLog->FileHandle,
                   pBuf,
                   dwBytesToRead,
                   pdwBytesRead,
                   &(pLog->Overlapped));
//                   NULL);


    if (!Success)
    {

        // deal with the error code
        switch (dwError = GetLastError())
        {
            case ERROR_IO_PENDING:
            {
                // asynchronous i/o is still in progress
                // check on the results of the asynchronous read
                Success = QfsGetOverlappedResult(pLog->FileHandle,
                                      &(pLog->Overlapped),
                                      pdwBytesRead,
                                      TRUE);

                // if there was a problem ...
                if (!Success)
                {

                    // deal with the error code
                    switch (dwError = GetLastError())
                    {
                        //ss:for end of file dont log error
                        case ERROR_HANDLE_EOF:
                            break;

                        default:
                            // deal with other error cases
                            CL_LOGFAILURE(dwError);
                            break;
                    }
                }
                else
                    dwError = ERROR_SUCCESS;
                break;
            }

            case ERROR_HANDLE_EOF:
                break;

            default:
                CL_UNEXPECTED_ERROR(dwError);
                break;
        }
    }
    return(dwError);
}

DWORD
LogpWrite(
    IN PLOG pLog,
    IN PVOID pData,
    IN DWORD dwBytesToWrite,
    IN DWORD *pdwBytesWritten)

{

    DWORD   dwError=ERROR_SUCCESS;
    BOOL    Success;

    *pdwBytesWritten = 0;

#if DBG
    if (pLog->Overlapped.Offset == 0)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpWrite : Writing the file header, CheckPtLsn=0x%1!08lx!\r\n",
            ((PLOG_HEADER)pData)->LastChkPtLsn);

    }
#endif    
    Success = QfsWriteFile(pLog->FileHandle,
                   pData,
                   dwBytesToWrite,
                   pdwBytesWritten,
                   &(pLog->Overlapped));


    if (!Success)
    {

        // deal with the error code
        switch (dwError = GetLastError())
        {
            case ERROR_IO_PENDING:
            {
                // asynchronous i/o is still in progress
                // check on the results of the asynchronous read
                Success = QfsGetOverlappedResult(pLog->FileHandle,
                                      &(pLog->Overlapped),
                                      pdwBytesWritten,
                                      TRUE);

                // if there was a problem ...
                if (!Success)
                    CL_LOGFAILURE((dwError = GetLastError()));
                else
                    dwError = ERROR_SUCCESS;
                break;
            }

            default:
                CL_LOGFAILURE(dwError);
                break;
        }
    }
    return(dwError);


}

/****
@func   DWORD | LogpWriteLargeRecordData | Writes thru the data for a 
        large record.

@parm   PLOG | pLog | The pointer to the log.        
@parm   PLOGRECORD | pLogRecord | Supplies the logrecord where this record starts. The 
        record header is already written.
@parm   PVOID | pLogData | A pointer to the large record data.
@parm   DWORD | dwDataSize | The size of the large record data.

@comm   Called by LogWrite() to write a large record.  The maximum size is
        restricted by the growth chunk size.
        
@xref   <f LogCreate> 
****/

DWORD
LogpWriteLargeRecordData(
    IN PLOG pLog,
    IN PLOGRECORD pLogRecord, 
    IN PBYTE pLogData, 
    IN DWORD dwDataSize)        
{    
    DWORD       dwBytesWritten;
    DWORD       dwDataBytesWritten;
    DWORD       dwDataBytesLeft;
    DWORD       dwNumPagesLeft;    //pages written
    DWORD       dwError=ERROR_SUCCESS;
    PLOGRECORD  Current;
    DWORD       Status;
    LSN         LastLsn;
    DWORD       dwOldOffset;
    PLOGPAGE    pPage;
    PBYTE       pLargeBuffer=NULL;
    
    ClRtlLogPrint(LOG_UNUSUAL,
        "[LM] LogpWriteLargeRecordData::dwDataSize=%1!u!\r\n",
        dwDataSize);
        

    pPage = pLog->ActivePage;

    //write as much data into the current page as you possibly can    
    dwDataBytesWritten = pPage->Size - sizeof(LOGPAGE);
    if (dwDataBytesWritten > dwDataSize)
        dwDataBytesWritten = dwDataSize;
    dwDataBytesLeft = dwDataSize - dwDataBytesWritten;
    CopyMemory(&(pLogRecord->Data), pLogData, dwDataBytesWritten);
    
    //flush this page
    (pLog->Overlapped).Offset = pPage->Offset;
    (pLog->Overlapped).OffsetHigh = 0;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : Writing(firstpageoflargerecord) %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pPage->Size, pPage->Offset);

    if ((dwError = LogpWrite(pLog, pPage, pPage->Size, &dwBytesWritten))
            != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpWriteLargeRecordData::LogpWrite returned error=0x%1!08lx!\r\n",
            dwError);
        CL_LOGFAILURE(dwError);
        goto FnExit;
    }
    //update the data pointer
    pLogData += dwDataBytesWritten;
    dwNumPagesLeft = pLogRecord->NumPages - 1;

    //if the number of bytes left is greater than a page
    //write everything but the last page
    if (dwNumPagesLeft > 1)
    {
        dwDataBytesWritten = (dwNumPagesLeft - 1) * pPage->Size;
        pLargeBuffer = AlignAlloc(dwDataBytesWritten);
        if (pLargeBuffer == NULL) 
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY ;
            CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
            goto FnExit;
        }
        if (dwDataBytesWritten > dwDataBytesLeft)
            dwDataBytesWritten = dwDataBytesLeft;
        dwDataBytesLeft -= dwDataBytesWritten;
        //continue writing from the next page
        (pLog->Overlapped).Offset = pPage->Size + pPage->Offset;
        (pLog->Overlapped).OffsetHigh = 0;

        CopyMemory(pLargeBuffer, pLogData, dwDataBytesWritten);

        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogpWriteLargeRecord : Writing(restoflargerecord) %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
            dwDataBytesWritten, (pLog->Overlapped).Offset);
        
        if ((dwError = LogpWrite(pLog, pLargeBuffer, 
            (dwNumPagesLeft - 1) * pPage->Size, &dwBytesWritten))
                != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpWriteLargeRecordData::LogpWrite returned error=0x%1!08lx!\r\n",
                dwError);
            CL_LOGFAILURE(dwError);
            goto FnExit;
        }
        //update the data pointer
        pLogData += dwDataBytesWritten;
        //now only the last page is left
        dwNumPagesLeft = 1;
    }
    
    //set the offset to the last page
    pPage->Offset += pPage->Size * (pLogRecord->NumPages - 1);
    Current = LSNTORECORD(pPage, pLog->NextLsn);
    Current->PreviousLsn = pLogRecord->CurrentLsn;
    Current->CurrentLsn = pLog->NextLsn;

    //write the last page, first write the eop data and then copy the
    //remaining user data into the page and then write to disk
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : Writing eoprecord of %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        pPage->Size, pPage->Offset);

    pLog->Overlapped.Offset = pPage->Offset;
    pLog->Overlapped.OffsetHigh = 0;

    //current points to the next record in the last page
    //this will be the eop record
    // Create an end-of-page record
    //
    Current->Signature = LOGREC_SIG;
    Current->RecordSize = pPage->Size - RECORDOFFSETINPAGE(pPage, Current) + (sizeof(LOGPAGE)-sizeof(LOGRECORD));
    Current->ResourceManager = RMPageEnd;
    Current->Transaction = 0;                 
    Current->Flags = 0;
    Current->NumPages = 1;
    GetSystemTimeAsFileTime(&Current->Timestamp);

    dwDataBytesWritten = dwDataBytesLeft;
    if (dwDataBytesWritten)
        dwDataBytesLeft -= dwDataBytesWritten;
    CL_ASSERT(dwDataBytesLeft == 0);
        
    //use dwDataBytesLeft to remember the page size
    //since we are now going to copy user data over it
    dwDataBytesLeft = pPage->Size;
    dwOldOffset = pPage->Offset;
    if (dwDataBytesWritten)
        CopyMemory(pPage, pLogData, dwDataBytesWritten);
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : Writing(lastpageoflargerecord) %1!u! bytes to disk at offset 0x%2!08lx!\r\n",
        dwDataBytesLeft, (pLog->Overlapped).Offset);

    //write the last page        
    dwError = LogpWrite(pLog, pPage, dwDataBytesLeft, &dwBytesWritten);
    if (dwError != ERROR_SUCCESS)
    {
        CL_LOGFAILURE(dwError);
        goto FnExit;

    }
    //restore page size and offset
    pPage->Size = dwDataBytesLeft;
    pPage->Offset = dwOldOffset;
    
    //set the next lsn to the first record on the next page
    LastLsn = Current->CurrentLsn;
    pLog->NextLsn = LastLsn + Current->RecordSize;
    pLog->FlushedLsn = pLog->NextLsn;

    // Create new page and keep the new record ready
    // note disk space for this record has already been commited
    pPage->Offset += pPage->Size;             // voila, new page!

    //
    //  Make sure all records in the page are zerod out. This will remove headaches caused
    //  by flushing invalid records in a page by say LogFlush. LogFlush flushes an entire 
    //  page and doesn't care if there are invalid records in the page.
    //
    ZeroMemory ( &pPage->FirstRecord, 
                 pPage->Size - ( sizeof ( LOGPAGE ) - sizeof ( LOGRECORD ) ) );

    Current = &pPage->FirstRecord;           // log record immediately following page header
    Current->PreviousLsn = LastLsn;
    Current->CurrentLsn = pLog->NextLsn;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpWriteLargeRecord : success pLog->NextLsn=0x%1!08lx!\r\n",
        pLog->NextLsn);
    

FnExit:
    if (pLargeBuffer) AlignFree(pLargeBuffer);
    return (dwError);
}



DWORD
LogpGrowLog(
    IN PLOG Log,
    IN DWORD GrowthSize
    )

/*++

Routine Description:

    Ensures that there is sufficient disk space to handle subsequent
    writes by preallocating the log file. Two variables, FileSize and
    FileAlloc are tracked in the LOG structure. This routine increases
    FileAlloc by the specified GrowthSize. Once FileAlloc exceeds
    FileSize, the file is grown to accomodate the new data.

    If this routine returns successfully, it guarantees that subsequent
    will not fail due to lack of disk space.

Arguments:

    Log - Supplies the log to be grown.

    GrowthSize - Supplies the number of bytes required.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful.

--*/

{
    DWORD NewSize;
    DWORD Status;

    if(Log->FileAlloc > Log->FileSize)
    {
        return(ERROR_CLUSTERLOG_CORRUPT);       
    }

    if (Log->FileAlloc + GrowthSize <= Log->FileSize) 
    {
        Log->FileAlloc += GrowthSize;
        return(ERROR_SUCCESS);
    }


    NewSize = Log->FileSize + GROWTH_CHUNK;
    CL_ASSERT(NewSize > Log->FileSize);         // bummer, log file is >4GB

    //check if the file can be grown, if not, may be a reset
    //is required

    if (NewSize > Log->MaxFileSize)
    {
        LogpWriteWarningToEvtLog(LM_LOG_EXCEEDS_MAXSIZE, Log->FileName);
        return(ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE);
    }
    //
    // Grow the file.
    //

    Status = QfsSetEndOfFile(Log->FileHandle, NewSize);
    if (Status != ERROR_SUCCESS) {
        CL_LOGFAILURE(Status);
        return(Status);
    }

    Log->FileAlloc += GrowthSize;
    Log->FileSize += GROWTH_CHUNK;
    return(ERROR_SUCCESS);

}

DWORD
LogpReset(
    IN PLOG Log,
    IN LPCWSTR  lpszInChkPtFile
    )
/*++

Routine Description:

    Resets the log file and takes a  new checkpoint if a NULL checkpoint
    file is specified as the second parameter.

Arguments:

    Log - Supplies the log to be reset.

    lpszInChkPtFile - Supplies the checkpoint file.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code if unsuccessful.

--*/
{
    PLOG        pLog;
    PLOG        pNewLog;
    DWORD       dwError=ERROR_SUCCESS;
    WCHAR       szPathName[MAX_PATH];
    WCHAR       szFilePrefix[MAX_PATH]=L"tquolog";
    WCHAR       szTmpFileName[MAX_PATH];
    WCHAR       szOldChkPtFileName[MAX_PATH];
    LSN         Lsn;
    TRID        Transaction;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpReset entry...\r\n");

    pLog = Log;
   
    //
    // SS: the path name must be specified by the api as well,
    // here we assume it is hardcoded for the use for the quorum
    // log
    //
    dwError = DmGetQuorumLogPath(szPathName, sizeof(szPathName));
    if (dwError  != ERROR_SUCCESS)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset : DmGetQuorumLogPath failed, error=%1!u!\r\n",
            dwError);
        goto FnExit;
    }

    //
    //  Generate a tmp file name
    //
    if (!QfsGetTempFileName(szPathName, szFilePrefix, 0, szTmpFileName))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset failed to generate a tmp file name,PathName=%1!ls!, FilePrefix=%2!ls!, error=%3!u!\r\n",
            szPathName, szFilePrefix, dwError);
        goto FnExit;
    }

    //
    //  Initialize the new log file, no timer is created
    //
    if (!(pNewLog = LogpCreate(szTmpFileName, pLog->MaxFileSize,
        pLog->pfnGetChkPtCb, pLog->pGetChkPtContext, TRUE, &Lsn)))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset failed to create the new log file, error=0x%1!08lx\n",
            dwError);
        //
        // Chittur Subbaraman (chitturs) - 2/18/99
        //
        // Make sure you get rid of the temp file. Otherwise, repeated
        // log resets can clog the disk.
        //
        if ( !QfsDeleteFile( szTmpFileName ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpReset:: Unable to delete tmp file %1!ws! after failed log create, Error=%2!d!\r\n",
                szTmpFileName,
                GetLastError());
        }
        goto FnExit;
    }


    //
    //  Reset the log file
    //
    EnterCriticalSection(&pLog->Lock);

    //
    //  Get the name of the previous checkpoint file in the old log file
    //
    szOldChkPtFileName[0] = TEXT('\0');
    if (LogGetLastChkPoint((HLOG)pLog, szOldChkPtFileName, &Transaction, &Lsn)
        != ERROR_SUCCESS)
    {
        // 
        //  Continue, this only means there is no old file to delete
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogReset:: no check point found in the old log file\r\n");
    }

    //
    //  write a check point to it, if there is a checkpoint function
    //
    if ((dwError = LogCheckPoint((HLOG)pNewLog, FALSE, lpszInChkPtFile, 0))
        != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: Callback failed to return a checkpoint, error=%1!u!\r\n",
            dwError);
        CL_LOGFAILURE(dwError);
        LogClose((HLOG)pNewLog);
        LeaveCriticalSection(&pLog->Lock);
        //
        // Chittur Subbaraman (chitturs) - 2/18/99
        //
        // Make sure you get rid of the temp file. Otherwise, repeated
        // log resets can clog the disk.
        //
        if ( !QfsDeleteFile( szTmpFileName ) )
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[LM] LogpReset:: Unable to delete tmp file %1!ws! after failed checkpoint attempt, Error=%2!d!\r\n",
                szTmpFileName, 
                GetLastError());
        }
        goto FnExit;
    }

    //
    //  Get the name of the most recent checkpoint file in the new log file
    //
    szFilePrefix[0] = TEXT('\0');
    if (LogGetLastChkPoint((HLOG)pNewLog, szFilePrefix, &Transaction, &Lsn)
        != ERROR_SUCCESS)
    {
        //
        //  Continue, this only means there is no old file to delete
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: no check point found in the old log file\r\n");
    }

    //
    //  Close the old file handle so that we can move this temp file over
    //
    QfsCloseHandle(pLog->FileHandle);
    QfsCloseHandle(pNewLog->FileHandle);
    pNewLog->FileHandle = QfsINVALID_HANDLE_VALUE;
    pLog->FileHandle = QfsINVALID_HANDLE_VALUE;

    //
    //  Rename the new file to the log file
    //
    if (!QfsMoveFileEx(szTmpFileName, pLog->FileName, MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH))
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: MoveFileExW failed. Error = 0x%1!08lx!\r\n",
            dwError);
        //
        //  Move failed, close the new log file
        //
        LogClose((HLOG)pNewLog);
        LeaveCriticalSection(&pLog->Lock);
        //
        // Chittur Subbaraman (chitturs) - 2/18/99
        //
        // Attempt to delete the temp file. You may not necessarily
        // succeed here.
        //
        QfsDeleteFile( szTmpFileName );
        goto FnExit;
    }

    //
    //  Open the new file again
    //
    pNewLog->FileHandle = QfsCreateFile(pLog->FileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
    //                            0,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED,
    //                            FILE_FLAG_WRITE_THROUGH | FILE_FLAG_OVERLAPPED,
    //                            0,
                                  NULL);
    if (!QfsIsHandleValid(pNewLog->FileHandle)) {
        dwError = GetLastError();
        CL_LOGFAILURE(dwError);
        LeaveCriticalSection(&pLog->Lock);
        goto FnExit;
    }

    //
    //  Delete the last checkpoint in the old log file
    //
    if (szOldChkPtFileName[0] != TEXT('\0') && lstrcmpiW(szOldChkPtFileName, szFilePrefix))
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[LM] LogpReset:: deleting previous checkpoint file %1!ls!\r\n",
            szOldChkPtFileName);
        QfsDeleteFile(szOldChkPtFileName);
    }

    //
    //  Free the old resources
    //
    CloseHandle(pLog->Overlapped.hEvent);
    AlignFree(pLog->ActivePage);
    
    //
    //  Update the old log structure with the new info
    //  retain the name, callback info and the critical section
    //  continue to manage this file with the old timer as well
    //
    pLog->FileHandle = pNewLog->FileHandle;
    pLog->SectorSize = pNewLog->SectorSize;
    pLog->ActivePage = pNewLog->ActivePage;
    pLog->NextLsn = pNewLog->NextLsn;
    pLog->FlushedLsn = pNewLog->FlushedLsn;
    pLog->FileSize = pNewLog->FileSize;
    pLog->FileAlloc = pNewLog->FileAlloc;
    pLog->MaxFileSize = pNewLog->MaxFileSize;
    pLog->Overlapped = pNewLog->Overlapped;

    //
    //  Delete the new pLog structure and associated memory for name
    //
    DeleteCriticalSection(&pNewLog->Lock);
    CrFree(pNewLog->FileName);
    CrFree(pNewLog);

    LeaveCriticalSection(&pLog->Lock);

FnExit:
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogpReset exit, returning 0x%1!08lx!\r\n",
            dwError);
    return(dwError);
}

/****
@func   DWORD | LogpWriteWarningToEvtLog | Conditionally write a warning
        to the event log

@parm   DWORD | dwWarningType | Type of warning.
@parm   LPCWSTR | lpszLogFileName | The log file name.        

@comm   This function is added in order to prevent the event log from
        being filled with the same type of warning message.
        
@xref   
****/
VOID
LogpWriteWarningToEvtLog(
    IN DWORD dwWarningType,
    IN LPCWSTR  lpszLogFileName
    )
{
    //
    //  Chittur Subbaraman (chitturs) - 1/4/99
    //
    //  (Use switch-case for easy future expansion purposes)
    //
    switch( dwWarningType )
    {
        case LM_LOG_EXCEEDS_MAXSIZE:
            if( bLogExceedsMaxSzWarning == FALSE )
            {
                CL_LOGCLUSWARNING1( dwWarningType, lpszLogFileName );
                bLogExceedsMaxSzWarning = TRUE;
            }
            break;

        default:
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\lm\xsaction.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    xsaction.c

Abstract:

    Provides basic xscational services for cluster logging.

Author:

    Sunita Shrivastava (sunitas) 17-Mar-1997

Revision History:
--*/
#include "service.h"
#include "lmp.h"


/****
@doc    EXTERNAL INTERFACES CLUSSVC LM
****/

/****
@func       HXSACTION | LogStartXsaction| Write a start transaction record to
            the log.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN TRID | TrId | Supplies the transaction id.

@parm       IN RMID | ResourceId | The resource id that identifies the
            resource manager.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@rdesc      Returns a handle suitable for use in subsequent log calls.  
            NUll in case failure. Call GetLastError() to get the error.

@xref       <f LogCommitXsaction> <f LogAbortXsaction>
****/
HXSACTION
LogStartXsaction(
    IN HLOG     hLog,
    IN TRID     TrId,
    IN RMID     ResourceId,
    IN RMTYPE   ResourceFlags
)
{
    PLOG        pLog;
    DWORD       dwError=ERROR_SUCCESS;
    LSN         Lsn = NULL_LSN;
    PLOGRECORD  pLogRecord;
    DWORD       dwNumPages;
    PLOGPAGE    pPage;
    DWORD       dwTotalSize;
    BOOL        bMaxFileSizeReached;
    PXSACTION   pXsaction = NULL;

    
    GETLOG(pLog, hLog);

    //write the record, dont allow resets to happen
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogStartXsaction : Entry TrId=%1!u! RmId=%2!u! RmType = %3!u!\r\n",
        TrId, ResourceId, ResourceFlags);

    EnterCriticalSection(&pLog->Lock);

    pXsaction = (PXSACTION)LocalAlloc(LMEM_FIXED, sizeof(XSACTION));
    if (!pXsaction)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }   
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        
    //reset the file
    dwError = LogReset(hLog);

    if (dwError != ERROR_SUCCESS)
    {
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogStartXsaction : LogReset failed\r\n");
        goto FnExit;            
    }

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        


    CL_ASSERT(ResourceId > RMAny);     // reserved for logger's use

    dwTotalSize = sizeof(LOGRECORD) +  7 & ~7;       // round up to qword size


    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    //we just reset the file, if it cant take the new startxsaction
    //record, something is awfully wrong !!!
    if (pPage == NULL)
    {
        dwError = GetLastError();
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogStartXsaction : LogpAppendPage failed.\r\n");
        goto FnExit;
    }


    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    Lsn = MAKELSN(pPage, pLogRecord);

    //
    // Fill in log record.
    //
    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = ResourceId;
    pLogRecord->Transaction = TrId;
    pLogRecord->XsactionType = TTStartXsaction;
    pLogRecord->Flags = ResourceFlags;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = 0;

    pXsaction->XsactionSig = XSACTION_SIG;
    pXsaction->TrId = TrId;
    pXsaction->StartLsn = Lsn;
    pXsaction->RmId = ResourceId;
    
FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogStartXsaction : Exit returning=0x%1!08lx!\r\n",
        Lsn);

    if (dwError != ERROR_SUCCESS)
    {
        if (pXsaction) {
            LocalFree(pXsaction);
            pXsaction = NULL;
        }
        SetLastError(dwError);
    }
    
    LeaveCriticalSection(&pLog->Lock);

    return((HXSACTION)pXsaction);
}

/****
@func       LSN | LogWriteXsaction| Write a transaction unit record to
            the log.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN HXSACTION | hXsaction | Supplies the handle to the transaction.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@parm       IN PVOID | LogData | Supplies a pointer to the data to be logged.

@parm       DWORD | DataSize | Supplies the number of bytes of data pointed to by LogData

@rdesc      The LSN of the log record that was created. NULL_LSN if something terrible happened.
            GetLastError() will provide the error code.

@comm       This should use a transaction handle obtained from LogStartXsaction. This
            call is used to write the parts of a transaction to the quorum log.
            
@xref       <f LogStartXsaction>
****/
LSN
LogWriteXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags,
    IN PVOID        pLogData,
    IN DWORD        dwDataSize)
{
    PLOG        pLog;
    DWORD       dwError=ERROR_SUCCESS;
    LSN         Lsn = NULL_LSN;
    PLOGRECORD  pLogRecord;
    DWORD       dwNumPages;
    PLOGPAGE    pPage;
    DWORD       dwTotalSize;
    BOOL        bMaxFileSizeReached;
    PXSACTION   pXsaction = NULL;

    GETLOG(pLog, hLog);

    GETXSACTION(pXsaction, hXsaction);
    
    //write the record, dont allow resets to happen
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWriteXsaction : Entry TrId=%1!u! RmId=%2!u! RmType = %3!u!\r\n",
        pXsaction->TrId, pXsaction->RmId, ResourceFlags);

#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READWRITE, &dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        


    CL_ASSERT(pXsaction->RmId > RMAny);     // reserved for logger's use

    dwTotalSize = sizeof(LOGRECORD) + (dwDataSize+ 7) & ~7;       // round up to qword size

    EnterCriticalSection(&pLog->Lock);

    pPage = LogpAppendPage(pLog, dwTotalSize, &pLogRecord, &bMaxFileSizeReached, &dwNumPages);
    //we reset the file in logstartxsaction, if it cant take the new startxsaction
    //record, something is awfully wrong !!!
    if (pPage == NULL)
    {
        dwError = GetLastError();
        //assert if a complete local xsaction extends the log beyond its max size
        CL_ASSERT( dwError != ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE);
        ClRtlLogPrint(LOG_NOISE,
            "[LM] LogWriteXsaction : LogpAppendPage failed.\r\n");
        goto FnExit;
    }


    CL_ASSERT(((ULONG_PTR)pLogRecord & 0x7) == 0);     // ensure qword alignment
    Lsn = MAKELSN(pPage, pLogRecord);

    //
    // Fill in log record.
    //
    pLogRecord->Signature = LOGREC_SIG;
    pLogRecord->ResourceManager = pXsaction->RmId;
    pLogRecord->Transaction = pXsaction->TrId;
    pLogRecord->XsactionType = TTXsactionUnit;
    pLogRecord->Flags = ResourceFlags;
    GetSystemTimeAsFileTime(&pLogRecord->Timestamp);
    pLogRecord->NumPages = dwNumPages;
    pLogRecord->DataSize = dwDataSize;
    if (dwNumPages < 1)
        CopyMemory(&pLogRecord->Data, pLogData, dwDataSize);
    else
    {
        if (LogpWriteLargeRecordData(pLog, pLogRecord, pLogData, dwDataSize) 
            != ERROR_SUCCESS)
        {
            ClRtlLogPrint(LOG_NOISE,
                "[LM] LogWriteXsaction : LogpWriteLargeRecordData failed. Lsn=0x%1!08lx!\r\n",
                Lsn);
            Lsn = NULL_LSN;                
        }
    }

FnExit:
#if DBG    
    {
        DWORD dwOldProtect;
        DWORD Status;
        BOOL VPWorked;

        VPWorked = VirtualProtect(pLog->ActivePage, pLog->SectorSize, PAGE_READONLY, & dwOldProtect);
        Status = GetLastError();
        CL_ASSERT( VPWorked );
    }        
#endif        
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWriteXsaction : Exit returning=0x%1!08lx!\r\n",
        Lsn);

    if (dwError != ERROR_SUCCESS)
        SetLastError(dwError);
    LeaveCriticalSection(&pLog->Lock);

    return(Lsn);      
}


/****
@func       DWORD | LogCommitXsaction | This writes the commit transaction
            record to the log and flushes it.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN TRID | TrId | Supplies the transaction id.

@parm       IN RMID | ResourceId | The resource id that identifies the
            resource manager.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@comm       A commit record is written to the quorum log. The hXsaction handle 
            is invalidated at this point and should not be used after this call has
            been made.  The commit is record is used to identify committed transactions
            during rollback.
            
@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogStartXsaction>
****/
DWORD WINAPI LogCommitXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags)
{
    DWORD       dwError = ERROR_SUCCESS;
    LSN         Lsn;
    PXSACTION   pXsaction;

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogCommitXsaction : Entry, hXsaction=0x%1!08lx!\r\n",
        hXsaction);

    GETXSACTION(pXsaction, hXsaction);
    
    Lsn = LogWrite(hLog, pXsaction->TrId, TTCommitXsaction, 
        pXsaction->RmId, ResourceFlags, NULL, 0);
        
    if (Lsn == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit; 
    }

FnExit:  
    //free up the transation memory
    ZeroMemory(pXsaction, sizeof(XSACTION));                   // just in case somebody tries to
    LocalFree(pXsaction);

    if ( dwError == ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE, "[LM] LogCommitXsaction: Exit with success\n");
    } else
    {
        ClRtlLogPrint(LOG_CRITICAL, "[LM] LogCommitXsaction: Exit, dwError=0x%1!08lx!\n",
                     dwError);     
    }

    return(dwError);        
}

/****
@func       DWORD | LogAbortXsaction | Marks a given transaction as aborted in the 
            quorum log file.

@parm       IN HLOG | hLog | Supplies the handle to the log.

@parm       IN HXSACTION | hXsaction | Supplies the handle to the transaction.

@parm       IN RMTYPE | ResourceFlags | A dword of flags that the resource 
            manager may use to store any data it wants with this record.

@comm       An abort transaction is written to the quorum log.  This is used in 
            identifying aborted transactions during roll back. The hXsaction 
            handle is invalidated at this point and should not be used after this.

@rdesc      ERROR_SUCCESS if successful. Win32 error code if something horrible happened.

@xref       <f LogStartXsaction> <f LogCommitXsaction>
****/
DWORD
LogAbortXsaction(
    IN HLOG         hLog,
    IN HXSACTION    hXsaction,
    IN RMTYPE       ResourceFlags
    )
{
    PXSACTION   pXsaction;
    LSN         Lsn;
    DWORD       dwError = ERROR_SUCCESS;
    
    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogAbortXsaction : Entry, hXsaction=0x%1!08lx!\r\n",
        hXsaction);

    GETXSACTION(pXsaction, hXsaction);

    Lsn = LogWrite(hLog, pXsaction->TrId, TTAbortXsaction, pXsaction->RmId,
            ResourceFlags, NULL, 0);

    if (Lsn == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit;        
    }


FnExit:
    ZeroMemory(pXsaction, sizeof(XSACTION));                   // just in case somebody tries to
    LocalFree(pXsaction);

    if ( dwError == ERROR_SUCCESS )
    {
        ClRtlLogPrint(LOG_NOISE, "[LM] LogAbortXsaction: Exit with success\n");
    } else
    {
        ClRtlLogPrint(LOG_CRITICAL, "[LM] LogAbortXsaction: Exit, dwError=0x%1!08lx!\n",
                     dwError);     
    }
    return(dwError);
}

/****
@func       LSN | LogFindXsactionState | This fuctions scans the record and finds
            the state of a given transaction.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | StartXsactionLsn | The LSN of the start transaction record.

@parm       IN TRID | XsactionId | The transaction id of the transaction.

@parm       OUT TRSTATE | *pXsactionState | The state of the transaction.

@comm       Transaction state is set to XsactionCommitted, XsactionAborted or XsactionUnknown.
            depending on whether a commit record, or abort record or no record is found
            for this record in the log.
            
@rdesc      ERROR_SUCCESS, else returns the error code if something horrible happens.

@xref       <f LogScanXsaction> 
****/
DWORD
LogFindXsactionState(
   IN HLOG      hLog,
   IN LSN       StartXsactionLsn,
   IN TRID      XsactionId,
   OUT TRSTATE *pXsactionState)
{
    PLOG        pLog;
    PLOGRECORD  pRecord, pEopRecord;
    DWORD       dwError = ERROR_SUCCESS;
    int         PageIndex, OldPageIndex;
    RMID        Resource;
    TRID        TrId;
    TRTYPE      TrType;
    LSN         Lsn, EopLsn;
    PLOGPAGE    pPage = NULL,pLargeBuffer = NULL;
    DWORD       dwBytesRead;
    RMTYPE      ResourceFlags;
    BOOL        bFound = FALSE;
    
    GETLOG(pLog, hLog);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogWrite : Entry StartXLsn=0x%1!08lx! StartXId=%2!u!\r\n",
        StartXsactionLsn, XsactionId);

    EnterCriticalSection(&pLog->Lock);


    if (StartXsactionLsn >= pLog->NextLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //read this record
    dwBytesRead = 0;
    if ((Lsn = LogRead( hLog, StartXsactionLsn, &Resource, &ResourceFlags, &TrId, &TrType,
        NULL, &dwBytesRead)) == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit;
    }

    //check the record
    if ((TrType != TTStartXsaction) ||
        (TrId != XsactionId))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    pPage = (PLOGPAGE)AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    //Lsn is now set to the next Lsn after the start
    //initialize this to -1 so that the first page is always read
    OldPageIndex = -1;
    while (Lsn < pLog->NextLsn && !bFound)
    {
        //
        // Scan From Next record to find either the commit or abort record
        //
        PageIndex = LSNTOPAGE(Lsn);


        if (PageIndex != OldPageIndex)
        {
            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            //read was successful, no need to read the page unless the
            //record falls on a different page
            OldPageIndex = PageIndex;
        }
        pRecord = LSNTORECORD(pPage, Lsn);

        //skip other log management records     
        //these are small records by definition
        if (pRecord->ResourceManager < RMAny)
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
            continue;
        }
        //if the transaction id is the same, check the xsaction type
        if (pRecord->Transaction == XsactionId)
        {
            if ((pRecord->XsactionType == TTCommitXsaction) ||
                (pRecord->XsactionType == TTStartXsaction))
            {
                bFound = TRUE;
                continue;
            }
        }
        //handle large records
        if (pRecord->NumPages > 0)
        {
            EopLsn = GETNEXTLSN(pRecord,TRUE);
            
            PageIndex = LSNTOPAGE(EopLsn);

            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            OldPageIndex = PageIndex;
            pEopRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
                (EopLsn - (pLog->Overlapped).Offset));
            //move to the next page 
            Lsn = GETNEXTLSN(pEopRecord, TRUE);
        }
        else
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
        }            
    }

    if (bFound)
    {
        if (pRecord->XsactionType == TTCommitXsaction)
            *pXsactionState = XsactionCommitted;
        else
            *pXsactionState = XsactionAborted;
    }
    else
    {
        *pXsactionState = XsactionUnknown;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogFindXsactionState : Exit,State=%1!u!\r\n",
        *pXsactionState);

FnExit:
    LeaveCriticalSection(&pLog->Lock);
    if (pPage) AlignFree(pPage);
    return(dwError);
}


/****
@func       LSN | LogScanXsaction | This fuctions scans the multiple units
            of a transaction.

@parm       IN HLOG | hLog | Supplies the identifier of the log.

@parm       IN LSN | StartXsacionLsn | The LSN of the start transaction record.

@parm       IN TRID | XsactionId | The transaction id of the transaction.

@parm       IN PLOG_SCANXSACTION_CALLBACK | CallbackRoutine | The routine to call
            for every unit of a transaction.
            
@parm       IN PVOID | pContext | The context to be passed to state of the transaction.

@comm       Stops enumerating the transaction units if the callback function returns
            FALSE, or if the abort or commit record for this transaction is found or
            if the next transacion is found.

@rdesc      ERROR_SUCCESS if the state is found, else returns the error code.

@xref       <f LogFindXsactionState> 
****/
DWORD
LogScanXsaction(
    IN HLOG     hLog,
    IN LSN      StartXsactionLsn,
    IN TRID     XsactionId,
    IN PLOG_SCANXSACTION_CALLBACK CallbackRoutine,
    IN PVOID    pContext)
{
    PLOG        pLog;
    PLOGRECORD  pRecord;
    DWORD       dwError = ERROR_SUCCESS;
    int         PageIndex, OldPageIndex;
    RMID        Resource;
    TRID        TrId;
    TRTYPE      TrType;
    LSN         Lsn;
    PLOGPAGE    pPage = NULL;
    PUCHAR      pLargeBuffer;
    DWORD       dwBytesRead;
    RMTYPE      ResourceFlags;
    
    GETLOG(pLog, hLog);

    ClRtlLogPrint(LOG_NOISE,
        "[LM] LogScanXsaction : Entry StartXLsn=0x%1!08lx! StartXId=%2!u!\r\n",
        StartXsactionLsn, XsactionId);


    Lsn = StartXsactionLsn;
    if (Lsn >= pLog->NextLsn)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //read this record
    dwBytesRead = 0;
    if (LogRead( hLog, Lsn, &Resource, &ResourceFlags, &TrId, &TrType,
        NULL, &dwBytesRead) == NULL_LSN)
    {
        dwError = GetLastError();
        goto FnExit;
    }

    //check the record
    if ((TrType != TTStartXsaction) ||
        (TrId != XsactionId))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }


    pPage = (PLOGPAGE)AlignAlloc(SECTOR_SIZE);
    if (pPage == NULL) {
        CL_UNEXPECTED_ERROR( ERROR_NOT_ENOUGH_MEMORY );
    }

    //initialize this to -1 so that the first page is always read
    OldPageIndex = -1;
    while (Lsn < pLog->NextLsn)
    {
        //
        // Scan From Next record to find either the commit or abort record
        //
        PageIndex = LSNTOPAGE(Lsn);


        if (PageIndex != OldPageIndex)
        {
            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            //read was successful, no need to read the page unless the
            //record falls on a different page
            OldPageIndex = PageIndex;
        }
        pRecord = LSNTORECORD(pPage, Lsn);

        //skip other log management records     
        if (pRecord->ResourceManager < RMAny)
        {
            Lsn = GETNEXTLSN(pRecord, TRUE);
            continue;
        }

        //stop if next transaction record is encountered
        if (pRecord->Transaction > XsactionId) 
        {
            break;
        } 
        //stop when a commit or abort record is found
        if ((pRecord->Transaction == XsactionId) &&
            ((pRecord->XsactionType == TTCommitXsaction) || 
            (pRecord->XsactionType == TTAbortXsaction)))
        {
            break;
        }

        //handle large records
        if (pRecord->NumPages > 0)
        {
            //if the transaction id is the same
            if ((pRecord->Transaction == XsactionId) && 
                (pRecord->XsactionType == TTXsactionUnit))
            {
                //read the whole record
                //for a large record you need to read in the entire data
                pLargeBuffer = AlignAlloc(pRecord->NumPages * SECTOR_SIZE);
                if (pLargeBuffer == NULL) 
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY ;
                    CL_LOGFAILURE(ERROR_NOT_ENOUGH_MEMORY);
                    break;
                }
                //read the pages
                pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
                pLog->Overlapped.OffsetHigh = 0;

                dwError = LogpRead(pLog, pLargeBuffer, pRecord->NumPages *
                    pLog->SectorSize, &dwBytesRead);
                //if it is the last page, then set the new page as the active
                //page
                if (dwError != ERROR_SUCCESS)
                {
                    CL_LOGFAILURE(dwError);
                    AlignFree(pLargeBuffer);
                    break;
                }
                pRecord = LSNTORECORD((PLOGPAGE)pLargeBuffer, Lsn);

                ClRtlLogPrint(LOG_NOISE,
                "[LM] LogScanXsaction::Calling the scancb for Lsn=0x%1!08lx! Trid=%2!u! RecordSize=%3!u!\r\n",
                    Lsn, pRecord->Transaction, pRecord->DataSize);

                //if the callback requests to stop scan
                if (!(*CallbackRoutine)(pContext, Lsn, pRecord->ResourceManager,
                    pRecord->Flags, pRecord->Transaction,
                    pRecord->Data, pRecord->DataSize))
                {    
                    AlignFree(pLargeBuffer);
                    break;
                }
            }
            //read the last page of the large record and advance
            Lsn = GETNEXTLSN(pRecord,TRUE);

            AlignFree(pLargeBuffer);
            PageIndex = LSNTOPAGE(Lsn);

            //read the page
            pLog->Overlapped.Offset = PageIndex * pLog->SectorSize;
            pLog->Overlapped.OffsetHigh = 0;

            dwError = LogpRead(pLog, pPage, pLog->SectorSize, &dwBytesRead);
            if (dwError)
            {
                goto FnExit;
            }
            OldPageIndex = PageIndex;
            pRecord = (PLOGRECORD)((ULONG_PTR) pPage + 
                (Lsn - (pLog->Overlapped).Offset));
            CL_ASSERT(pRecord->ResourceManager == RMPageEnd);
            //move to the next page 
            Lsn = GETNEXTLSN(pRecord, TRUE);

        }
        else
        {
            if ((pRecord->Transaction == XsactionId) && 
                (pRecord->XsactionType == TTXsactionUnit))
            {
                ClRtlLogPrint(LOG_NOISE,
                    "[LM] LogScanXsaction: Calling the scancb for Lsn=0x%1!08lx! Trid=%2!u! RecordSize=%3!u!\r\n",
                    Lsn, pRecord->Transaction, pRecord->DataSize);

                //call the callback
                if (!(*CallbackRoutine)(pContext, Lsn, pRecord->ResourceManager,
                    pRecord->Flags, pRecord->Transaction, 
                    pRecord->Data, pRecord->DataSize))
                {    
                    break;
                }
  
            }                

            Lsn = GETNEXTLSN(pRecord, TRUE);
        }            
    }


FnExit:
    if (pPage) AlignFree(pPage);
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\jrgpos.h ===
#ifndef  _JRGPOS_H_
#define  _JRGPOS_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "jrgpos.h - T9050 - OS-specific declarations for Regroup Module"
#endif

/* @@@@@@ START COPYRIGHT @@@@@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@@@@ END COPYRIGHT @@@@@@
**/

/*---------------------------------------------------------------------------
 * This file (jrgpos.h) contains OS-specific declarations used by Regroup.
 * Use appropriate #includes to pull in declarations from other native
 * OS files.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#ifdef NSK
#include <jmsgtyp.h>   /* to get "uint8", "uint16" and "uint32" */
#include <dmem.h>
#include <dcpuctl.h>
#include <jmsglit.h>

#define RGP_NULL_PTR       NIL_       /* Null pointer for use by RGP        */
#define MAX_CLUSTER_SIZE   MAX_CPUS   /* max # of nodes supported in system */
#define LOWEST_NODENUM     ((node_t)0)    /* starting node number           */
#define RGP_NULL_NODE      ((node_t)-1)   /* special node# for defaults     */
#define RGP_KEY_NODE       RGP_NULL_NODE  /* No node is special */
#endif /* NSK */

#if defined(LCU) || defined(UNIX) || defined(NT)
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;

#ifndef NULL
#define NULL ((void *)0)
#endif /* NULL */
#define RGP_NULL_PTR       NULL       /* Null pointer for use by RGP        */

#if defined(LCU) || defined(UNIX)
#define MAX_CLUSTER_SIZE   16         /* max # of nodes supported in system */
#define LOWEST_NODENUM     ((node_t)1)    /* starting node number           */
#endif

#if defined(NT)
#include "service.h"

#define MAX_CLUSTER_SIZE   ClusterDefaultMaxNodes
                                      /* max # of nodes supported in system */
#define LOWEST_NODENUM     ((node_t)ClusterMinNodeId)    /* starting node number           */
#endif

#define RGP_NULL_NODE      ((node_t)-1)
                                          /* special node# for defaults     */
#define RGP_KEY_NODE       RGP_NULL_NODE  /* No node is special             */

#define _priv       /* used only by NSK compilers */
#define _resident   /* used only by NSK compilers */

#endif /* LCU || UNIX || NT */


/*---------------------------------------------------------------
 * Unacknowledged packet subtypes used by regroup.
 * These are made visible to the OS for reporting and counting
 * purposes only.
 *---------------------------------------------------------------*/

/* Maximum payload of packets sent by Regroup is 56 bytes.
 * This allows a maximum transport overhead of 8 bytes in the
 * ServerNet interrupt packet which has a size of 64 bytes.
 */
#define RGP_UNACK_PKTLEN   56 /*bytes*/

typedef struct
{
   uint8 pktsubtype;
   uint8 subtype_specific[RGP_UNACK_PKTLEN - sizeof(uint8)];
} rgp_unseq_pkt_t;


/* Regroup unacknowledged packet subtypes */
#define RGP_UNACK_IAMALIVE   (uint8) 1    /* I am alive packet     */
#define RGP_UNACK_REGROUP    (uint8) 2    /* regroup status packet */
#define RGP_UNACK_POISON     (uint8) 3    /* poison packet         */


/*---------------------------------------------------------------*/
/* Processor status codes returned by the Service Processor (SP) */
/*---------------------------------------------------------------*/

#define RGP_NODE_UNREACHABLE     0

#define RGP_NODE_TIMED_OUT       1
#define RGP_NODE_FROZEN          2
#define RGP_NODE_HALTED          3
#define RGP_NODE_OPERATIONAL     4


/*----------------------*/
/* Processor halt codes */
/*----------------------*/

#ifdef NSK
#include <dhalt.h>
#endif /* NSK */

#if defined(LCU) || defined(UNIX) || defined(NT)
#define RGP_RELOADFAILED          1
#define RGP_INTERNAL_ERROR        2
#define RGP_MISSED_POLL_TO_SELF   3
#define RGP_AVOID_SPLIT_BRAIN     4
#define RGP_PRUNED_OUT            5
#define RGP_PARIAH                6
#define RGP_PARIAH_FIRST          RGP_PARIAH + LOWEST_NODENUM
#define RGP_PARIAH_LAST           RGP_PARIAH_FIRST + MAX_CLUSTER_SIZE - 1

#define RGP_ARBITRATION_FAILED    1000
#define RGP_ARBITRATION_STALLED   1001
#define RGP_SHUTDOWN_DURING_RGP   1002 // Alias of MM_STOP_REQUESTED in mmapi.h

#endif /* LCU || UNIX || NT */


/*-------------------------------------------------------------------------
 * Timing parameters for Regroup. Of these, RGP_IAMALIVE_TICKS can be
 * overridden at run time using the rgp_getrgpinfo(), rgp_setrgpinfo()
 * routine pair. This is useful to slow node failure detection during
 * kernel debug sessions.
 *-------------------------------------------------------------------------*/

#ifdef NSK
#define RGP_CLOCK_PERIOD          30   /* period between regroup ticks,
                                        * in units of 10 milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* NSK */

#ifdef LCU
#define RGP_CLOCK_PERIOD          30   /* period between regroup ticks,
                                        * in units of 10 milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* LCU */

#ifdef UNIX
#define RGP_CLOCK_PERIOD         100   /* period between regroup ticks,
                                        * in units of 10 milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* UNIX */

#ifdef NT

#define RGP_INACTIVE_PERIOD        60000   /* period between regroup ticks in ms when
                                                                                * node is inactive. 1 minute period */
#define RGP_CLOCK_PERIOD         300   /* period between regroup ticks,
                                        * in units of milliseconds */
#define RGP_PFAIL_TICKS           16   /* # of regroup ticks after a
                                        * power on event to forgive
                                        * missing self IamAlives */
#endif /* NT */

/* The following timing parameters can be overridden at run time by using
 * the rgp_getrgpinfo(), rgp_setrgpinfo() routine pair.
 */

// Bug#328641
//
// Extend min_stage1 to approx 4 seconds to match NM values (check_ticks 2=>3)
// Extend connectivity ticks to 3 to 9 ticks
// adjust rgp_must_restart accordingly (20=>23) half conn_tick increase
//

#define RGP_IAMALIVE_TICKS         4   /* rgp clock ticks between IamAlives */
#define RGP_CHECK_TICKS            3   /* rgp clock ticks before at least 1 ImAlive received */
#define RGP_MIN_STAGE1_TICKS       (RGP_IAMALIVE_TICKS * RGP_CHECK_TICKS)

/* The following parameters can be made to be OS-dependent if needed.
 */

#define RGP_MUST_ENTER_STAGE2     32   /* must enter stage2 after this many
                                          ticks, regardless of conditions */
#define RGP_CONNECTIVITY_TICKS     9   /* max # of ticks to wait in stage 2
                                          to collect connectivity info */
#define RGP_MUST_RESTART          23   /* stall detector tick count; if no
                                          progress after this many ticks,
                                          abort and restart regroup. */
#define RGP_RESTART_MAX            3   /* maximum number of restarts
                                          allowed per regroup incident;
                                          if this is exceeded, the node
                                          halts. */

/*--------------------------------------*/
/* Definition of node and cluster types */
/*--------------------------------------*/

typedef short node_t;


/* The cluster_t data type is a bit array with MAX_CLUSTER_SIZE
 * bits. It is implemented as an array of MAX_CLUSTER_SIZE/8
 * (rounded up) uint8s.
 */
#define BYTEL 8 /* number of bits in a uint8 */
#define BYTES_IN_CLUSTER ((MAX_CLUSTER_SIZE + BYTEL - 1) / BYTEL)

typedef uint8 cluster_t [BYTES_IN_CLUSTER];


/************************************************************************
 * rgp_msgsys_t (shared by regroup and message system)
 * ---------------------------------------------------
 * This structure is used by Regroup and the Message System to co-ordinate
 * actions that are to be done by the Message System on behalf of Regroup.
 * Regroup posts work requests in timer or IPC interrupt context and the
 * message system performs these at appropriate times (from the
 * dispatcher in NSK).
 *
 *      ___________________________________________________________
 * wd0 |        flags (bitfields)    |       regroup_nodes         |
 *     |_____________________________|_____________________________|
 * wd1 |        iamalive_nodes       |        poison_nodes         |
 *     |_____________________________|_____________________________|
 * wd2 |                   *regroup_data                           |
 *     |___________________________________________________________|
 * wd3 |                   *iamalive_data                          |
 *     |___________________________________________________________|
 * wd4 |                   *poison_data                            |
 *     |___________________________________________________________|
 * wd5 |                   regroup_datalen                         |
 *     |___________________________________________________________|
 * wd6 |                   iamalive_datalen                        |
 *     |___________________________________________________________|
 * wd7 |                   poison_datalen                          |
 *     |___________________________________________________________|
 *
 *
 * flags:
 *
 * sendrgppkts           - have regroup status packets to send
 * sendiamalives         - have iamalive status packets to send
 * sendpoisons           - have poison packets to send
 * phase1_cleanup        - need to start phase1 cleanup due to node death
 * phase2_cleanup        - need to start phase2 cleanup due to node death
 *
 * regroup_nodes         - mask of nodes to send regroup pkts to
 * iamalive_nodes        - mask of nodes to send iamalives to
 * poison_nodes          - mask of nodes to send poison pkts to
 *
 * The following fields are used in NSK and the user-level UNIX
 * simulation only.
 *
 * regroup_data          - address of regroup pkt data to send
 * iamalive_data         - address of iamalive data to send
 * poison_data           - address of poison pkt data to send
 *
 * regroup_datalen       - length of regroup pkt data to send
 * iamalive_datalen      - length of iamalive data to send
 * poison_datalen        - length of poison pkt data to send
 *
 */

#ifdef  __TANDEM
#pragma fieldalign shared8 rgp_msgsys
#endif  /* __TANDEM */

typedef struct rgp_msgsys
{
   uint16 sendrgppkts         : 1;
   uint16 sendiamalives       : 1;
   uint16 sendpoisons         : 1;
   uint16 phase1_cleanup      : 1;
   uint16 phase2_cleanup      : 1;
   uint16 filler              : 11;

   cluster_t    regroup_nodes;
   cluster_t    iamalive_nodes;
   cluster_t    poison_nodes;
#if defined(NSK) || defined(UNIX) || defined(NT)
   void         *regroup_data;
   void         *iamalive_data;
   void         *poison_data;
   uint32       regroup_datalen;
   uint32       iamalive_datalen;
   uint32       poison_datalen;
#endif /* NSK || UNIX || NT */
} rgp_msgsys_t;

typedef struct rgp_msgsys *rgp_msgsys_p;


/*----------------------------------------------------------------------
 * OS-dependent routines used by Regroup.
 *
 * These are defined either in the regroup file srgpos.c or in other
 * modules in the OS.
 *----------------------------------------------------------------------*/

_priv _resident extern void rgp_init_OS(void);
_priv _resident extern void rgp_broadcast(uint8 packet_subtype);
_priv _resident extern void rgp_node_failed(node_t node);
_priv _resident extern void rgp_start_phase1_cleanup(void);
_priv _resident extern void rgp_start_phase2_cleanup(void);
_priv _resident extern void rgp_cleanup_complete(void);
_priv _resident extern void rgp_had_power_failure(node_t node);
_priv _resident extern int  rgp_status_of_node(node_t node);
_priv _resident extern void rgp_newnode_online(node_t newnode);
_priv _resident extern int  rgp_select_cluster(cluster_t cluster_choices[],
                                               int num_clusters);
_priv _resident extern int  rgp_select_cluster_ex(cluster_t cluster_choices[],
                                               int num_clusters, node_t keynode);
_priv _resident extern void rgp_cleanup_OS(void);

#ifdef NSK
#include <tsrtnvl.h>                                                             /*F40:MB06452.1*/
#include <tsdevdf.h>                                                             /*F40:MB06452.2*/
#include <tsport.h>                                                              /*F40:MB06452.3*/
#include <tsentry.h>                                                             /*F40:MB06452.4*/
                                                                                 /*F40:MB06452.5*/
#define rgp_hold_all_io      TSER_TRANSFER_PAUSE_                                /*F40:MB064514.1*/
#define rgp_resume_all_io    TSER_TRANSFER_CONTINUE_                             /*F40:MB064514.2*/
                                                                                 /*F40:MB06452.8*/
#else
   _priv _resident extern void rgp_hold_all_io(void);
   _priv _resident extern void rgp_resume_all_io(void);
#endif /* NSK */

/*
 * Macros to set and get the members of a cluster using a mask of
 * appropriate size.
 */
#define SetCluster(/* cluster_t */ cluster, /* uint16 */ mask) \
{ \
   cluster[0] = (uint8)(mask >> 8); \
   cluster[1] = (uint8)(mask & 0xFF); \
}

#define GetCluster(/* cluster_t */ cluster) \
   (((uint16)cluster[0] << 8) | (uint16)cluster[1])

/* Macro to combine two cluster masks into a uint32.
 * This is used in tracing regroup events.
 */
#define RGP_MERGE_TO_32( c1, c2 )    \
   ( ( GetCluster( c1 ) << 16 ) | ( GetCluster( c2 ) ) )

/*----------------------------------------------------------------------
 * OS-dependent routines used by the Regroup module.
 *
 * These are defined in srgpos.c.
 *----------------------------------------------------------------------*/

/* Routines to halt the node upon catastrophic errors. */

#ifdef NSK
#include <dutil.h>                                                               /*F40:MB06458.3*/
#define RGP_ERROR(/* uint16 */ halt_code) SYSTEM_FREEZE_(halt_code)
#else
_priv _resident extern void RGP_ERROR_EX (uint16 halt_code, char* fname, DWORD lineno);
#define RGP_ERROR(halt_code) RGP_ERROR_EX(halt_code, __FILE__, __LINE__)

#endif /* NSK */

#ifdef UNIX
_priv _resident extern void PrintRegroupStart();
_priv _resident extern void PrintPruningResult();
_priv _resident extern void PrintStage();
_priv _resident extern void PrintMatrix();
#endif /* UNIX */

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.4*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.5*/
 - Some cleanup of the code                                                      /*F40:MB06458.6*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.7*/
   unsequenced messages sent.                                                    /*F40:MB06458.8*/
 - Fixed some bugs                                                               /*F40:MB06458.9*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.10*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.11*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.12*/
   tnet services queue.                                                          /*F40:MB06458.13*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.14*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.15*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.16*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.17*/
 - Added new steps in the build file called                                      /*F40:MB06458.18*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.19*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.20*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.21*/
-----------------------------------------------------------------------          /*F40:MB06458.22*/

#endif    /* 0 - change descriptions */


#endif  /* _JRGPOS_H_ defined */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\setprior.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    setprior.c

Abstract:

    Set a threads priority.

Author:

    Rod Gamache (rodga) 3-Oct-1996

Revision History:

--*/

#include "nt.h"
#include "ntdef.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"


DWORD
MmSetThreadPriority(
    VOID
    )

/*++

Routine Description:

    Set the thread's priority.

Arguments:

    None.

Return Value:

    Status of the request.

--*/

{
    DWORD   priority = 15;

    if ( !SetThreadPriority( GetCurrentThread(),
                             priority ) ) {
        return(GetLastError());
    }

    return(ERROR_SUCCESS);

} // MmSetThreadPriority
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\jrgp.h ===
#ifndef  _JRGP_H_
#define  _JRGP_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "jrgp.h - T9050 - external declarations for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (jrgp.h) contains all the type and function declarations exported
 * by Regroup.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <jrgpos.h>

/*  The following literals define the various events that may impinge
 *  upon the regroup algorithm main state.
 */
enum
{
   RGP_EVT_POWERFAIL            = 1,
   RGP_EVT_NODE_UNREACHABLE     = 2,
   RGP_EVT_PHASE1_CLEANUP_DONE  = 3,
   RGP_EVT_PHASE2_CLEANUP_DONE  = 4,
   RGP_EVT_LATEPOLLPACKET       = 5,
   RGP_EVT_CLOCK_TICK           = 6,
   RGP_EVT_RECEIVED_PACKET      = 7,
   RGP_EVT_BANISH_NODE          = 8,
   RGP_EVT_IGNORE_MASK          = 9
};


/* Detailed description of event codes:
 * -----------------------------------
 *
 * RGP_EVT_POWERFAIL
 *
 *    After a power failure, regroup must start or be restarted.
 *    This event can also be used when a power fail shout packet
 *    indicating a power failure is received from another node,
 *    even though our own node hasn't detected a power failure.
 *
 * RGP_EVT_NODE_UNREACHABLE
 *
 *    When all paths to a node are down, the message system reports
 *    this event.
 *
 * RGP_EVT_PHASE1_CLEANUP_DONE,
 * RGP_EVT_PHASE2_CLEANUP_DONE
 *
 *    Regroup provides two phases for the message system or cluster manager
 *    to clean up messages on all nodes. The first phase of cleanup begins
 *    after regroup reports one or more node failures. The second phase
 *    begins when a node learns that all nodes have completed phase 1
 *    clean up.
 *
 *    The message system or cluster manager on each node must inform
 *    regroup when the local cleanup for each phase is complete using
 *    the following events.
 *
 *    The NSK message system uses phase 1 to cancel all incoming (server)
 *    messages and phase 2 to terminate all outgoing (requester) messages.
 *
 *
 * The remaining events are for internal use by the Regroup algorithm.
 * ------------------------------------------------------------------
 *
 * RGP_EVT_LATEPOLLPACKET
 *
 *    When a node is late with its IamAlive messages, regroup must start a
 *    new round of regrouping.
 *
 * RGP_EVT_CLOCK_TICK
 *
 *    Once regroup is active, it needs to get clock ticks at periodic
 *    intervals.
 *
 * RGP_EVT_RECEIVED_PACKET
 *
 *    When a regroup packet arrives, it must be processed.
 *
 * RGP_EVT_BANISH_NODE
 *
 *    When regroup is restarted with the reason RGP_EVT_BANISH_NODE,
 *    each node participating in this regroup event shall install the
 *    causing node into its Banished mask.
 *
 * RGP_EVT_IGNORE_MASK
 *
 *    When regroup's ignore mask has changed, the reason code is set
 *    to RGP_EVT_IGNORE_MASK. This will allow UnpackIgnoreScreen routine
 *    to process causingnode and reason fields in a special way.
 *    If the reason is less than RGP_EVT_IGNORE_MASK, ignore mask is
 *    considered to be empty.
 */


/************************************************************************
 * rgp_info_t (used to get and set regroup parameters)
 * ---------------------------------------------------
 * This structure is used to get the current regroup parameters in order to
 * pass them to a new node being brought up. The structure can also be
 * used to modify regroup timing parameters before a cluster is formed
 * (that is, more than one node is booted).
 *
 *      ___________________________________________________________
 * wd0 |                        version                            |
 *     |___________________________________________________________|
 * wd1 |                        seqnum                             |
 *     |___________________________________________________________|
 * wd2 |   a_tick                    |        imalive_ticks        |
 *     |_____________________________|_____________________________|
 * wd3 |   check_ticks 				 |        min_stage1_ticks     |
 *	   |_____________________________|_____________________________|
 * wd4 |   cluster       			 |        unused			   |
 *     |_____________________________|_____________________________|
 *
 *
 * version            - version# of this data structure
 * seqnum             - sequence number for coordinating regroup
 *                      incidents between nodes
 * a_tick             - regroup clockperiod. in milliseconds.
 * iamalive_ticks     - # of regroup clock ticks between IamAlive
 *                      messages
 * check_ticks        - # of imalive ticks by which at least 1 imalive must arrive
 * min_stage1_ticks   - precomputed to be (imalive_ticks*check_ticks)
 * cluster            - current cluster membership mask
 */

#ifdef __TANDEM
#pragma fieldalign shared8 rgpinfo
#endif /* __TANDEM */

typedef struct rgpinfo
{
   uint32      version;
   uint32      seqnum;
   uint16	   a_tick; /* in ms.== clockPeriod */
   uint16      iamalive_ticks; /* number of ticks between imalive sends == sendHBRate */
   uint16	   check_ticks; /* number of imalive ticks before at least 1 imalive == rcvHBRate */
   uint16	   Min_Stage1_ticks; /* precomputed to be imalive_ticks*check_ticks */
   cluster_t   cluster;
} rgpinfo_t;

typedef struct rgpinfo *rgpinfo_p;


/*---------------------------------------------------------------------------*/
/* Routines exported by the Regroup Module
 * ---------------------------------------
 *
 * These routine names are in upper case to enable them to be called from
 * routines written in the PTAL language which is case insensitive and
 * converts all symbols to upper case.
 */

_priv _resident extern int
RGP_ESTIMATE_MEMORY(void);
#define rgp_estimate_memory RGP_ESTIMATE_MEMORY

_priv _resident extern void
RGP_INIT(node_t          this_node,
         unsigned int    num_nodes,
         void            *rgp_buffer,
         int             rgp_buflen,
         rgp_msgsys_p    rgp_msgsys_p);
#define rgp_init RGP_INIT

_priv _resident extern void
RGP_CLEANUP(void);
#define rgp_cleanup RGP_CLEANUP

_priv _resident extern uint32
RGP_SEQUENCE_NUMBER(void);
#define rgp_sequence_number RGP_SEQUENCE_NUMBER

_priv _resident extern int
RGP_GETRGPINFO(rgpinfo_t *rgpinfo);
#define rgp_getrgpinfo RGP_GETRGPINFO

_priv _resident extern int
RGP_SETRGPINFO(rgpinfo_t *rgpinfo);
#define rgp_setrgpinfo RGP_SETRGPINFO

_priv _resident extern void
RGP_START(void (*nodedown_callback)(cluster_t failed_nodes),
          int (*select_cluster)(cluster_t cluster_choices[],
                                    int num_clusters));
#define rgp_start RGP_START

_priv _resident extern int
RGP_ADD_NODE(node_t node);
#define rgp_add_node RGP_ADD_NODE

_priv _resident extern int
RGP_MONITOR_NODE(node_t node);
#define rgp_monitor_node RGP_MONITOR_NODE

_priv _resident extern int
RGP_REMOVE_NODE(node_t node);
#define rgp_remove_node RGP_REMOVE_NODE

_priv _resident extern int
RGP_IS_PERTURBED(void);
#define rgp_is_perturbed RGP_IS_PERTURBED

_priv _resident extern void
RGP_PERIODIC_CHECK(void);
#define rgp_periodic_check RGP_PERIODIC_CHECK

_priv _resident extern void
RGP_RECEIVED_PACKET(node_t node, void *packet, int packetlen);
#define rgp_received_packet RGP_RECEIVED_PACKET

_priv _resident extern void
RGP_EVENT_HANDLER_EX(int event, node_t causingnode, void* arg);
#define RGP_EVENT_HANDLER(_event, _causingnode) RGP_EVENT_HANDLER_EX(_event, _causingnode, NULL)

#define rgp_event_handler RGP_EVENT_HANDLER
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */

#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------

#endif    /* 0 - change descriptions */

#endif /* _JRGP_H_ defined */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\message.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    message.c

Abstract:

    Routines for the message passing interface for regroup

Author:

    John Vert (jvert) 5/30/1996

Revision History:

--*/
#include "service.h"
#include "sspi.h"
#include "issperr.h"
#include "clmsg.h"
#include "wrgp.h"
#include "wsclus.h"


//
// Private Constants
//
#define CLMSG_DATAGRAM_PORT         1
#define CLMSG_MAX_WORK_THREADS      2
#define CLMSG_WORK_THREAD_PRIORITY  THREAD_PRIORITY_ABOVE_NORMAL

//
// security package info
//
// For NT5, the security context generation code was rewritten to allow
// multiple packages to be specified. The packages are tried in order until
// there are no more packages or a context has been successfully
// generated.
//
// The default is the negotiate package in secur32.dll which will negotiate
// either kerberos or NTLM. Between NT5 systems, the actual package used
// depends on the veresion of the DC: NT5 DCs support kerberos while NT4 DCs
// use NTLM. Mixed mode clusters use NTLM. The NTLM portion of Negotiate
// doesn't interoperate with NT4 NTLM hence the need for trying NTLM directly.
//
// These routines use multi-leg style authentication, i.e., a security blob is
// passed between the client and server until the security routines indicate
// that they have succeeded or failed. Note that encryption is not specified
// for two reasons: we don't need it and it prevents the code from working on
// the non-US versions where NTLM doesn't have an encryption capability.
//
// The DLL and package values can be overridden via the registry.
//

#define DEFAULT_SSPI_DLL            TEXT("SECUR32.DLL")
WCHAR DefaultSspiPackageList[] = L"NTLM" L"\0";
//WCHAR DefaultSspiPackageList[] = L"negotiate" L"\0" L"NTLM" L"\0";

#define VALID_SSPI_HANDLE( _x )     ((_x).dwUpper != (ULONG_PTR)-1 && \
                                     (_x).dwLower != (ULONG_PTR)-1 )

#define INVALIDATE_SSPI_HANDLE( _x ) { \
        (_x).dwUpper = (ULONG_PTR)-1; \
        (_x).dwLower = (ULONG_PTR)-1; \
    }


//
// Private Types
//

//
// the Data array in CLMSG_DATAGRAM_CONTEXT contains the contents of the
// regroup message and the digital signature of the message. Currently, it is
// not possible to get the signature buffer size until a context is
// negotiated. A DCR has been submitted asking for a query that doesn't
// require a context. In lieu of that, we know that for kerberos, the sig
// buffer size is 35b while it is 16b for NTLM. When that feature is
// available, the DatagramContext allocation should be moved into
// ClMsgLoadSecurityProvider.
//

#define MAX_SIGNATURE_SIZE  64

typedef struct {
    CLRTL_WORK_ITEM    ClRtlWorkItem;
    DWORD              Flags;
    SOCKADDR_CLUSTER   SourceAddress;
    INT                SourceAddressLength;
    UCHAR              Data[ sizeof(rgp_msgbuf) + MAX_SIGNATURE_SIZE ];
} CLMSG_DATAGRAM_CONTEXT, *PCLMSG_DATAGRAM_CONTEXT;

typedef struct {
    CLRTL_WORK_ITEM    ClRtlWorkItem;
    CLUSNET_EVENT      EventData;
} CLMSG_EVENT_CONTEXT, *PCLMSG_EVENT_CONTEXT;

//
// info specific to a package. Many pair-wise context associations may use the
// same package. Package info is maintained in a single linked list.
//
typedef struct _CLUSTER_PACKAGE_INFO {
    struct _CLUSTER_PACKAGE_INFO * Next;
    LPWSTR                         Name;
    CredHandle                     OutboundSecurityCredentials;
    CredHandle                     InboundSecurityCredentials;
    ULONG                          SecurityTokenSize;
    ULONG                          SignatureBufferSize;
} CLUSTER_PACKAGE_INFO, *PCLUSTER_PACKAGE_INFO;

//
// security context handles with ref counts
//
typedef struct _SECURITY_CTXT_HANDLE {
    CtxtHandle              Handle;
    ULONG                   RefCount;
} SECURITY_CTXT_HANDLE, *PSECURITY_CTXT_HANDLE;

//
// pair-wise context data
//
typedef struct _CLUSTER_SECURITY_DATA {
    PSECURITY_CTXT_HANDLE   Outbound;
    PSECURITY_CTXT_HANDLE   Inbound;
    PCLUSTER_PACKAGE_INFO   PackageInfo;
    BOOL                    OutboundStable;
    BOOL                    InboundStable;
    ULONG                   OutboundChangeCount;
    ULONG                   InboundChangeCount;
} CLUSTER_SECURITY_DATA, *PCLUSTER_SECURITY_DATA;

//
// Private Data
//
PCLRTL_WORK_QUEUE        WorkQueue = NULL;
PCLMSG_DATAGRAM_CONTEXT  DatagramContext = NULL;
PCLMSG_EVENT_CONTEXT     EventContext = NULL;
SOCKET                   DatagramSocket = INVALID_SOCKET;
HANDLE                   ClusnetHandle = NULL;
RPC_BINDING_HANDLE *     Session = NULL;
BOOLEAN                  ClMsgInitialized = FALSE;
HINSTANCE                SecurityProvider;
PSecurityFunctionTable   SecurityFuncs;
CRITICAL_SECTION         SecContextLock;
PCLUSTER_PACKAGE_INFO    PackageInfoList;

//
// [GorN 08/01/99]
//
// Every time CreateDefaultBinding is called we increase
// generation counter for the node.
//
// In DeleteDefaultBinding, we do a delete, only if generation
// number passed matches the binding generation of that node. 
//
// We use GenerationCritSect for synchronization. 
// [HACKHACK] We are not deleting GenerationCritSect.
// It will get cleaned up by ExitProcess <grin>
//
DWORD                   *BindingGeneration = NULL;
CRITICAL_SECTION         GenerationCritSect;

//
// the security context array is indexed using internal node numbering (0
// based) and protected by SecContextLock. For sending and recv'ing packets,
// the lock is held while the signature is created/verified. Locking gets
// trickier during the setup of a security context since it involves separate
// inbound and outbound contexts which cause messages to be sent between
// nodes. There is still a window where something bad could happen since
// verifying a signature with a partially setup context is bad. The
// {In,Out}boundStable vars are used to track whether the actual context
// handle can be checked for validity and then, if valid, used for signature
// operations.
//
// The joining node initially sets up an outbound context with its sponsor
// (inbound for sponsor). If that is successful, the sponsor sets up an
// outbound context with the joiner (inbound for joiner). This is done in such
// a way that SecContextLock cannot be held at a high level; it must be
// released when ever a message is sent via MmRpcEstablishSecurityContext.
// The lock may be held recursively (by the same thread obviously) during
// certain periods.
//
// Update (daviddio 8/28/2001): SecContextLock cannot be held while invoking
// the SSPI API because SSPI may call out to a domain controller. Holding
// the lock while calling a DC can delay time-critical operations, such as
// regroup, that need to access the security context array to sign and
// verify messages.
//

CLUSTER_SECURITY_DATA SecurityCtxtData[ ClusterDefaultMaxNodes ];
SECURITY_CTXT_HANDLE  InvalidCtxtHandle;

//
// Private Routines
//
PSECURITY_CTXT_HANDLE
ClMsgCreateSecurityCtxt(
    VOID
    )
{
    PSECURITY_CTXT_HANDLE ctxt;

    ctxt = LocalAlloc( LMEM_FIXED, sizeof(SECURITY_CTXT_HANDLE) );
    if (ctxt != NULL) {
        INVALIDATE_SSPI_HANDLE( ctxt->Handle );
        ctxt->RefCount = 1;
    }

    return ctxt;
}

#define ClMsgReferenceSecurityCtxt(_ctxt)                                  \
    InterlockedIncrement( &(_ctxt)->RefCount )
    

#define ClMsgDereferenceSecurityCtxt(_ctxt)                                \
    if (InterlockedDecrement( &((_ctxt)->RefCount) ) == 0) {               \
        CL_ASSERT((_ctxt) != &InvalidCtxtHandle);                          \
        if ( VALID_SSPI_HANDLE( (_ctxt)->Handle )) {                       \
            (*SecurityFuncs->DeleteSecurityContext)( &((_ctxt)->Handle) ); \
        }                                                                  \
        if ((_ctxt) != &InvalidCtxtHandle) {                               \
            LocalFree( (_ctxt) );                                          \
        }                                                                  \
    }


VOID
ClMsgDatagramHandler(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
{
    WSABUF                   wsaBuf;
    int                      err;
    SecBufferDesc            BufferDescriptor;
    SecBuffer                SignatureDescriptor[2];
    ULONG                    fQOP;
    SECURITY_STATUS          SecStatus;
    PCLUSTER_SECURITY_DATA   SecurityData;
    PSECURITY_CTXT_HANDLE    InboundCtxt;
    DWORD                    retryCount;
    DWORD                    signatureBufferSize;
    PVOID                    signatureBuffer;
    rgp_msgbuf *             regroupMsg;

    PCLMSG_DATAGRAM_CONTEXT  datagramContext = CONTAINING_RECORD(
        WorkItem,
        CLMSG_DATAGRAM_CONTEXT,
        ClRtlWorkItem
        );

    UNREFERENCED_PARAMETER(IoContext);
    CL_ASSERT(WorkItem == &(datagramContext->ClRtlWorkItem));

    if (Status == ERROR_SUCCESS || Status == WSAEMSGSIZE ) {

        if (BytesTransferred == sizeof(rgp_msgbuf)) {
            // If clusnet verified the signature of a packet,
            // it sets sac_zero field of a source address to 1
            if (datagramContext->SourceAddress.sac_zero == 1) {
                ClRtlLogPrint(LOG_NOISE,
                              "[ClMsg] recv'd mcast from %1!u!\n",
                              datagramContext->SourceAddress.sac_node);
                RGP_LOCK;
                MMDiag((PVOID)datagramContext->Data,
                    BytesTransferred,
                    &BytesTransferred);
                RGP_UNLOCK;
            } else {
                ClRtlLogPrint(LOG_NOISE,
                              "[ClMsg] unrecognized packet from %1!u! discarded (%2!u!)\n",
                              datagramContext->SourceAddress.sac_node, datagramContext->SourceAddress.sac_zero);
            }
        } else {
            
            EnterCriticalSection( &SecContextLock );

            SecurityData = &SecurityCtxtData[ INT_NODE( datagramContext->SourceAddress.sac_node )];

            if ( SecurityData->InboundStable &&
                 VALID_SSPI_HANDLE( SecurityData->Inbound->Handle ))
            {
                //
                // copy remainder of needed data from SecurityData structure
                //
                signatureBufferSize = SecurityData->PackageInfo->SignatureBufferSize;
                InboundCtxt = SecurityData->Inbound;
                ClMsgReferenceSecurityCtxt( InboundCtxt );

                LeaveCriticalSection( &SecContextLock );

                //
                // get pointer to  signature buffer at back of packet
                //
                regroupMsg = (rgp_msgbuf *)(datagramContext->Data);
                signatureBuffer = (PVOID)(regroupMsg + 1);
                CL_ASSERT( sizeof(rgp_msgbuf) == BytesTransferred - signatureBufferSize );

                //
                // Build the descriptors for the message and the
                // signature buffer
                //
                BufferDescriptor.cBuffers = 2;
                BufferDescriptor.pBuffers = SignatureDescriptor;
                BufferDescriptor.ulVersion = SECBUFFER_VERSION;

                SignatureDescriptor[0].BufferType = SECBUFFER_DATA;
                SignatureDescriptor[0].cbBuffer = BytesTransferred - signatureBufferSize;
                SignatureDescriptor[0].pvBuffer = (PVOID)regroupMsg;

                SignatureDescriptor[1].BufferType = SECBUFFER_TOKEN;
                SignatureDescriptor[1].cbBuffer = signatureBufferSize;
                SignatureDescriptor[1].pvBuffer = (PVOID)signatureBuffer;

                SecStatus = (*SecurityFuncs->VerifySignature)(
                                &InboundCtxt->Handle,
                                &BufferDescriptor,
                                0,                       // no sequence number
                                &fQOP);                  // Quality of protection

                ClMsgDereferenceSecurityCtxt( InboundCtxt );

                if ( SecStatus == SEC_E_OK ) {

                    //
                    // only feed this buffer to MM if it hasn't been tampered
                    // with.  since we're running over a datagram transport, it
                    // will be possible to lose packets
                    //

                    RGP_LOCK;
                    MMDiag((PVOID)datagramContext->Data,
                           BytesTransferred - signatureBufferSize,
                           &BytesTransferred);
                    RGP_UNLOCK;
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] Signature verify on message from node %1!u! failed, "
                                "status %2!08X!\n",
                                datagramContext->SourceAddress.sac_node,
                                SecStatus);
                }
            } else {

                LeaveCriticalSection( &SecContextLock );
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[ClMsg] No security context to verify message from node %1!u!!\n",
                            datagramContext->SourceAddress.sac_node);
            }

        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Receive datagram failed, status %1!u!\n",
            Status
            );
    }

    retryCount = 0;

    while ((Status != WSAENOTSOCK) && (retryCount++ < 10)) {
        //
        // Repost the request
        //
        ZeroMemory(datagramContext, sizeof(CLMSG_DATAGRAM_CONTEXT));

        datagramContext->ClRtlWorkItem.WorkRoutine = ClMsgDatagramHandler;
        datagramContext->ClRtlWorkItem.Context = datagramContext;

        datagramContext->SourceAddressLength = sizeof(SOCKADDR_CLUSTER);

        wsaBuf.len = sizeof( datagramContext->Data );
        wsaBuf.buf = (PCHAR)&datagramContext->Data;

        err = WSARecvFrom(
                  DatagramSocket,
                  &wsaBuf,
                  1,
                  &BytesTransferred,
                  &(datagramContext->Flags),
                  (struct sockaddr *) &(datagramContext->SourceAddress),
                  &(datagramContext->SourceAddressLength),
                  &(datagramContext->ClRtlWorkItem.Overlapped),
                  NULL
                  );

        if ((err == 0) || ((Status = WSAGetLastError()) == WSA_IO_PENDING)) {
            return;
        }

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Post of receive datagram failed, status %1!u!\n",
            Status
            );

        Sleep(100);
    }

    if (Status != WSAENOTSOCK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Post of receive datagram failed too many times. Halting.\n"
            );
        CL_UNEXPECTED_ERROR(Status);
        CsInconsistencyHalt(Status);
    }
    else {
        //
        // The socket was closed. Do nothing.
        //
        ClRtlLogPrint(LOG_NOISE, 
            "[ClMsg] Datagram socket was closed. status %1!u!\n",
            Status
            );
    }

    LocalFree(DatagramContext); DatagramContext = NULL;
    return;

}  // ClMsgDatagramHandler

#if defined(DBG)
int IgnoreJoinerNodeUp = MM_INVALID_NODE; // Fault Injection variable
#endif

VOID
ClMsgEventHandler(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
{
    PCLMSG_EVENT_CONTEXT  eventContext = CONTAINING_RECORD(
                                             WorkItem,
                                             CLMSG_EVENT_CONTEXT,
                                             ClRtlWorkItem
                                             );
    PCLUSNET_EVENT        event = &(eventContext->EventData);
    BOOL                  EpochsEqual;

    UNREFERENCED_PARAMETER(IoContext);
    CL_ASSERT(WorkItem == &(eventContext->ClRtlWorkItem));

    if (Status == ERROR_SUCCESS) {
        if (BytesTransferred == sizeof(CLUSNET_EVENT)) {

            //
            // handle the event. First make sure that the epoch in the event
            // matches MM's epoch. If not, ignore this event.
            //

            switch ( event->EventType ) {
            case ClusnetEventNodeUp:

                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received node up event for node %1!u!, epoch %2!u!\n",
                    event->NodeId,
                    event->Epoch
                    );
#if defined(DBG)
                if( IgnoreJoinerNodeUp == (node_t)event->NodeId ) {
                    ClRtlLogPrint(LOG_NOISE, 
                        "[ClMsg] Fault injection. Ignoring node up for %1!u!\n",
                        event->NodeId
                        );
                    break;
                }
#endif

                RGP_LOCK;
                EpochsEqual = ( event->Epoch == rgp->OS_specific_control.EventEpoch );

                if ( EpochsEqual ) {
                    rgp_monitor_node( (node_t)event->NodeId );
                    RGP_UNLOCK;
                } else {
                    RGP_UNLOCK;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[ClMsg] Unequal Event Epochs. MM = %1!u! Clusnet = %2!u! !!!\n",
                         rgp->OS_specific_control.EventEpoch,
                         event->Epoch);
                }

                break;

            case ClusnetEventNodeDown:
                //
                // handle this the same as if the rgp periodic check had
                // detected a late IAmAlive packet
                //

                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received node down event for node %1!u!, epoch %2!u!\n",
                    event->NodeId,
                    event->Epoch
                    );

                RGP_LOCK;
                EpochsEqual = ( event->Epoch == rgp->OS_specific_control.EventEpoch );

                if ( EpochsEqual ) {
                    rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t)event->NodeId );
                    RGP_UNLOCK;
                } else {
                    RGP_UNLOCK;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[ClMsg] Unequal Event Epochs. MM = %1!u! Clusnet = %2!u! !!!\n",
                         rgp->OS_specific_control.EventEpoch,
                         event->Epoch);
                }

                break;

            case ClusnetEventPoisonPacketReceived:
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received poison event.\n",
                    event->NodeId,
                    event->Epoch
                    );

                RGP_ERROR((uint16) (RGP_PARIAH + event->NodeId));

                break;

            case ClusnetEventNetInterfaceUp:
            case ClusnetEventNetInterfaceUnreachable:
            case ClusnetEventNetInterfaceFailed:
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received interface %1!ws! event for node %2!u! network %3!u!\n",
                    ( (event->EventType == ClusnetEventNetInterfaceUp) ?
                        L"up" :
                        ( ( event->EventType ==
                            ClusnetEventNetInterfaceUnreachable
                          ) ?
                          L"unreachable" :
                          L"failed"
                        )
                    ),
                    event->NodeId,
                    event->NetworkId
                    );

                NmPostPnpEvent(
                    event->EventType,
                    event->NodeId,
                    event->NetworkId
                    );

                break;

            case ClusnetEventAddAddress:
            case ClusnetEventDelAddress:
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] Received %1!ws! address event, address %2!x!\n",
                    ((event->EventType == ClusnetEventAddAddress) ?
                        L"add" : L"delete"),
                     event->NetworkId
                     );

                NmPostPnpEvent(
                    event->EventType,
                    event->NetworkId,
                    0
                    );

                break;

            case ClusnetEventMulticastSet:
                ClRtlLogPrint(LOG_NOISE,
                    "[ClMsg] Received new multicast reachable node "
                    "set event: %1!x!.\n",
                    event->NodeId
                    );
                SetMulticastReachable(event->NodeId);
                break;

            default:
                ClRtlLogPrint(LOG_NOISE,
                    "[ClMsg] Received unhandled event type %1!u! node %2!u! network %3!u!\n",
                     event->EventType,
                     event->NodeId,
                     event->NetworkId
                     );

                break;
            }
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[ClMsg] Received event buffer of size %1!u! !!!\n",
                BytesTransferred
                );
            CL_ASSERT(BytesTransferred == sizeof(CLUSNET_EVENT));
        }

        //
        // Repost the request
        //
        ClRtlInitializeWorkItem(
            &(eventContext->ClRtlWorkItem),
            ClMsgEventHandler,
            eventContext
            );

        Status = ClusnetGetNextEvent(
                     ClusnetHandle,
                     &(eventContext->EventData),
                     &(eventContext->ClRtlWorkItem.Overlapped)
                     );

        if ((Status == ERROR_IO_PENDING) || (Status == ERROR_SUCCESS)) {
            return;
        }
    }

    //
    // Some kind of error occurred
    //
    if (Status != ERROR_OPERATION_ABORTED) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] GetNextEvent failed, status %1!u!\n",
            Status
            );
        CL_UNEXPECTED_ERROR(Status);
    }
    else {
        //
        // The control channel was closed. Do nothing.
        //
        ClRtlLogPrint(LOG_NOISE, "[ClMsg] Control Channel was closed.\n");
    }

    LocalFree(EventContext); EventContext = NULL;

    return;

}  // ClMsgEventHandler

DWORD
ClMsgInitializeSecurityPackage(
    LPCWSTR PackageName
    )

/*++

Routine Description:

    Find the specified security package and acquire inboud/outbound credential
    handles to it

Arguments:

    PackageName - package to find in security DLL

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD                status;
    ULONG                i;
    PWSTR                securityPackageName;
    DWORD                numPackages;
    PSecPkgInfo          secPackageInfoBase = NULL;
    PSecPkgInfo          secPackageInfo;
    TimeStamp            expiration;
    PCLUSTER_PACKAGE_INFO clusterPackageInfo;

    //
    // enumerate the packages provided by this provider and look through the
    // results to find one that matches the specified package name.
    //

    status = (*SecurityFuncs->EnumerateSecurityPackages)(&numPackages,
                                                         &secPackageInfoBase);

    if ( status != SEC_E_OK ) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Can't enum security packages 0x%1!08X!\n",
            status
            );
        goto error_exit;
    }

    secPackageInfo = secPackageInfoBase;
    for ( i = 0; i < numPackages; ++i ) {

        if ( ClRtlStrICmp( PackageName, secPackageInfo->Name ) == 0) {
            break;
        }

        ++secPackageInfo;
    }

    if ( i == numPackages ) {
        status = (DWORD)SEC_E_SECPKG_NOT_FOUND;            // [THINKTHINK] not a good choice

        ClRtlLogPrint(LOG_CRITICAL,
                   "[ClMsg] Couldn't find %1!ws! security package\n",
                    PackageName);
        goto error_exit;
    }

    //
    // allocate a blob to hold our package info and stuff it on the the list
    //
    clusterPackageInfo = LocalAlloc( LMEM_FIXED, sizeof(CLUSTER_PACKAGE_INFO));
    if ( clusterPackageInfo == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[ClMsg] Couldn't allocate memory for package info (%1!u!)\n",
                    status);
        goto error_exit;
    }

    clusterPackageInfo->Name = LocalAlloc(LMEM_FIXED,
                                          (wcslen(secPackageInfo->Name)+1) * sizeof(WCHAR));

    if ( clusterPackageInfo->Name == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                   "[ClMsg] Couldn't allocate memory for package info name (%1!u!)\n",
                    status);
        goto error_exit;
    }
    wcscpy( clusterPackageInfo->Name, secPackageInfo->Name );

    if ( PackageInfoList == NULL ) {
        PackageInfoList = clusterPackageInfo;
    } else {
        PCLUSTER_PACKAGE_INFO nextPackage;

        nextPackage = PackageInfoList;
        while ( nextPackage->Next != NULL ) {
            nextPackage = nextPackage->Next;
        }
        nextPackage->Next = clusterPackageInfo;
    }
    clusterPackageInfo->Next = NULL;

    clusterPackageInfo->SecurityTokenSize = secPackageInfo->cbMaxToken;

    //
    // finally get a set of credential handles. Note that there is a bug in
    // the security packages that prevent using an in/outbound
    // credential. When/if that gets fixed, this code could be greatly
    // simplified.
    //

    status = (*SecurityFuncs->AcquireCredentialsHandle)(
                 NULL,
                 secPackageInfo->Name,
                 SECPKG_CRED_OUTBOUND,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 &clusterPackageInfo->OutboundSecurityCredentials,
                 &expiration);

    if ( status != SEC_E_OK ) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Can't obtain outbound credentials %1!08X!\n",
            status
            );
        goto error_exit;
    }

    status = (*SecurityFuncs->AcquireCredentialsHandle)(
                 NULL,
                 secPackageInfo->Name,
                 SECPKG_CRED_INBOUND,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 &clusterPackageInfo->InboundSecurityCredentials,
                 &expiration);

    if ( status != SEC_E_OK ) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Can't obtain inbound credentials %1!08X!\n",
            status
            );
    }

error_exit:
    if ( secPackageInfoBase != NULL ) {
        (*SecurityFuncs->FreeContextBuffer)( secPackageInfoBase );
    }

    return status;
} // ClMsgInitializeSecurityPackage

DWORD
ClMsgLoadSecurityProvider(
    VOID
    )

/*++

Routine Description:

    Load the security DLL and construct a list of packages to use for context
    establishment.

    This allows use of a set of registry keys to override the current security
    DLL/packages. This is not meant as a general mechanism since switching the
    security provider in a synchronized fashion through out all the nodes in
    the cluster has numerous issues. This is meant as a bailout for a customer
    that is stuck because of some random problem with security or has their
    own security package (the fools!)

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD                   status;
    WCHAR                   securityProviderDLLName[ MAX_PATH ];
    DWORD                   securityDLLNameSize = sizeof( securityProviderDLLName );
    DWORD                   packageListSize = 0;
    INIT_SECURITY_INTERFACE initSecurityInterface;
    BOOL                    dllNameSpecified = TRUE;
    LPWSTR                  securityPackages = NULL;
    LPWSTR                  packageName;
    ULONG                   packagesLoaded = 0;
    ULONG                   i;
    HKEY                    hClusSvcKey = NULL;
    DWORD                   regType;

    //
    // see if a specific security DLL is named in the registry.  if not, fail
    // back to the default.
    //
    status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                         &hClusSvcKey);

    if ( status == ERROR_SUCCESS ) {

        status = RegQueryValueExW(hClusSvcKey,
                                  CLUSREG_NAME_SECURITY_DLL_NAME,
                                  0,
                                  &regType,
                                  (LPBYTE)&securityProviderDLLName,
                                  &securityDLLNameSize);

        if (status != ERROR_SUCCESS ||
            securityDLLNameSize == sizeof( UNICODE_NULL ) ||
            regType != REG_SZ)
        {
            if ( status == ERROR_SUCCESS ) {
                if ( regType != REG_SZ ) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] The security DLL key must be of type REG_SZ. Using "
                                "%1!ws! as provider.\n",
                                DEFAULT_SSPI_DLL);
                } else if ( securityDLLNameSize == sizeof( UNICODE_NULL )) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] No value specified for security DLL key. Using "
                                "%1!ws! as provider.\n",
                                DEFAULT_SSPI_DLL);
                }
            } else  if ( status != ERROR_FILE_NOT_FOUND ) {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[ClMsg] Can't read security DLL key, status %1!u!. Using "
                            "%2!ws! as provider\n",
                            status,
                            DEFAULT_SSPI_DLL);
            }

            wcscpy( securityProviderDLLName, DEFAULT_SSPI_DLL );
            dllNameSpecified = FALSE;
        } else {
            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] Using %1!ws! as the security provider DLL\n",
                        securityProviderDLLName);
        }
    } else {
        wcscpy( securityProviderDLLName, DEFAULT_SSPI_DLL );
        dllNameSpecified = FALSE;
    }

    SecurityProvider = LoadLibrary( securityProviderDLLName );

    if ( SecurityProvider == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to load security provider %1!ws!, status %2!u!\n",
            securityProviderDLLName,
            status);
        goto error_exit;
    }

    //
    // get a pointer to the initialize function in the DLL
    //
    initSecurityInterface =
        (INIT_SECURITY_INTERFACE)GetProcAddress(SecurityProvider,
                                                SECURITY_ENTRYPOINT_ANSI);

    if ( initSecurityInterface == NULL ) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to get security init function, status %1!u!\n",
            status);
        goto error_exit;
    }

    //
    // now get a pointer to all the security funcs
    //
    SecurityFuncs = (*initSecurityInterface)();
    if ( SecurityFuncs == NULL ) {
        status = ERROR_INVALID_FUNCTION;
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to get security function table\n");
        goto error_exit;
    }

    if ( dllNameSpecified ) {

        //
        // If a DLL name was specified in the registry, then the package name
        // key must be specified as well. Get its size first.
        //
        status = RegQueryValueExW(hClusSvcKey,
                                  CLUSREG_NAME_SECURITY_PACKAGE_LIST,
                                  0,
                                  &regType,
                                  NULL,
                                  &packageListSize);

        if (status != ERROR_SUCCESS ||
            packageListSize == sizeof( UNICODE_NULL ) ||
            regType != REG_MULTI_SZ)
        {
            if ( status == ERROR_SUCCESS ) {
                if ( regType != REG_MULTI_SZ ) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[ClMsg] The security package key must of type REG_MULTI_SZ.\n");
                } else if ( packageListSize == sizeof( UNICODE_NULL )) {
                    ClRtlLogPrint(LOG_CRITICAL,
                               "[ClMsg] No package names were specified for %1!ws!.\n",
                                securityProviderDLLName);
                }

                status = ERROR_INVALID_PARAMETER;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[ClMsg] Can't read security package key (%1!u!).\n",
                            status);
            }
            goto error_exit;
        }

        securityPackages = LocalAlloc( LMEM_FIXED, packageListSize );
        if ( securityPackages == NULL ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Can't allocate memory for package list.\n");

            status = GetLastError();
            goto error_exit;
        }

        status = RegQueryValueExW(hClusSvcKey,
                                  CLUSREG_NAME_SECURITY_PACKAGE_LIST,
                                  0,
                                  &regType,
                                  (PUCHAR)securityPackages,
                                  &packageListSize);
        CL_ASSERT( status == ERROR_SUCCESS );
    } else {
        securityPackages = LocalAlloc(LMEM_FIXED,
                                      sizeof( DefaultSspiPackageList ));

        if ( securityPackages == NULL ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Can't allocate memory for default package list.\n");

            status = GetLastError();
            goto error_exit;
        }

        memcpy(securityPackages,
               DefaultSspiPackageList,
               sizeof( DefaultSspiPackageList ));
    }

    //
    // initialize each package in the list
    //

    packageName = securityPackages;
    while ( *packageName != UNICODE_NULL ) {

        status = ClMsgInitializeSecurityPackage( packageName );
        if ( status == ERROR_SUCCESS ) {
            ++packagesLoaded;
            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] Initialized %1!ws! package.\n",
                        packageName);
        } else {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] %1!ws! package failed to initialize, status %2!08X!.\n",
                        packageName,
                        status);
        }

        packageName = packageName + wcslen( packageName ) + 1;;
    }

    if ( packagesLoaded == 0 ) {
        ClRtlLogPrint(LOG_CRITICAL, "[ClMsg] No security packages could be initialized.\n");
        status = ERROR_NO_SUCH_PACKAGE;
        goto error_exit;
    }

    //
    // initialize the individual client and server side security contexts.
    // a context handle is stable when it is marked as invalid.
    //

    INVALIDATE_SSPI_HANDLE( InvalidCtxtHandle.Handle );
    InvalidCtxtHandle.RefCount = 1;

    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; ++i ) {
        PCLUSTER_SECURITY_DATA SecurityData = &SecurityCtxtData[ INT_NODE( i )];

        SecurityData->OutboundStable = TRUE;
        SecurityData->InboundStable = TRUE;
        SecurityData->PackageInfo = NULL;
        SecurityData->OutboundChangeCount = 0;
        SecurityData->InboundChangeCount = 0;
        SecurityData->Outbound = &InvalidCtxtHandle;
        SecurityData->Inbound = &InvalidCtxtHandle;
    }

error_exit:

    if ( hClusSvcKey != NULL ) {
        RegCloseKey(hClusSvcKey);
    }

    if ( securityPackages != NULL ) {
        LocalFree( securityPackages );
    }

    return status;
} // ClMsgLoadSecurityProvider

DWORD
ClMsgImportSecurityContexts(
    CL_NODE_ID            NodeId,
    LPWSTR                SecurityPackageName,
    DWORD                 SignatureBufferSize,
    PSECURITY_CTXT_HANDLE InboundCtxt,
    PSECURITY_CTXT_HANDLE OutboundCtxt
    )

/*++

Routine Description:

    Export the inbound/outbound security contexts for the specified node and
    ship them to clusnet for use in signing heartbeat and poison pkts

Arguments:

    NodeId - Id of the node whose contexts are being exported

    SecurityPackageName - name of package used with which to establish context

    SignatureBufferSize - number of bytes needed for the signature buffer
    
    InboundCtxt - inbound security context
    
    OutboundCtxt - outbound security context

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD Status = ERROR_SUCCESS;
    SecBuffer ServerContext;
    SecBuffer ClientContext;
    CL_NODE_ID InternalNodeId = INT_NODE( NodeId );

    ClRtlLogPrint(LOG_NOISE, "[ClMsg] Importing security contexts from %1!ws! package.\n",
                           SecurityPackageName);

    Status = (*SecurityFuncs->ExportSecurityContext)(
                 &InboundCtxt->Handle,
                 0,
                 &ServerContext,
                 0);

    if ( !NT_SUCCESS( Status )) {
        goto error_exit;
    }

    Status = (*SecurityFuncs->ExportSecurityContext)(
                 &OutboundCtxt->Handle,
                 0,
                 &ClientContext,
                 0);

    if ( NT_SUCCESS( Status )) {
        CL_ASSERT( SignatureBufferSize > 0 );

        Status = ClusnetImportSecurityContexts(NmClusnetHandle,
                                               NodeId,
                                               SecurityPackageName,
                                               SignatureBufferSize,
                                               &ServerContext,
                                               &ClientContext);

        (*SecurityFuncs->FreeContextBuffer)( ClientContext.pvBuffer );
    }

    (*SecurityFuncs->FreeContextBuffer)( ServerContext.pvBuffer );

error_exit:

    return Status;

} // ClMsgImportSecurityContexts

DWORD
ClMsgEstablishSecurityContext(
    IN  DWORD JoinSequence,
    IN  DWORD TargetNodeId,
    IN  SECURITY_ROLE RoleOfClient,
    IN  PCLUSTER_PACKAGE_INFO PackageInfo,
    IN  PSECURITY_CTXT_HANDLE MemberInboundCtxt
    )

/*++

Routine Description:

    try to establish an outbound security context with the other node using
    the specified package name. The initialized security blob is shipped to
    the other side via RPC. This process continues back and forth until the
    security APIs indicate that the context has been successfully generated or
    has failed.

Arguments:

    JoinSequence - Sequence number of the join. Used by the other node to
                   determine if this blob is the generation of a new context

    TargetNodeId - Id of the node with which to generate the context

    RoleOfClient - indicates whether the client establishing the security
                   context is acting as a cluster member or a joining
                   member. Determines when the client/server roles of
                   establishing a security context are reversed

    PackageInfo - pointer to security package info to be used

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    CtxtHandle          ClientContext;
    TimeStamp           Expiration;
    SecBufferDesc       ServerBufferDescriptor;
    SecBuffer           ServerSecurityToken;
    SecBufferDesc       ClientBufferDescriptor;
    SecBuffer           ClientSecurityToken;
    ULONG               ContextRequirements;
    ULONG               ContextAttributes;
    SECURITY_STATUS     OurStatus;
    SECURITY_STATUS     ServerStatus = SEC_I_CONTINUE_NEEDED;
    ULONG               passCount = 1;
    error_status_t      RPCStatus;
    DWORD               Status = ERROR_SUCCESS;
    DWORD               FacilityCode;
    PCLUSTER_SECURITY_DATA TargetSecurityData;
    PSECURITY_CTXT_HANDLE  OutboundCtxt;
    PSECURITY_CTXT_HANDLE  InboundCtxt;
    ULONG               outboundChangeCount;
    BOOL                pkgInfoValid = FALSE;

    ClRtlLogPrint(LOG_NOISE,"[ClMsg] Establishing outbound security context with the "
                          "%1!ws! package.\n",
                          PackageInfo->Name);

    //
    // obtain a security context with the target node by swapping token
    // buffers until the process is complete.
    //
    // Build the Client (caller of this function) and Server (target node)
    // buffer descriptors.
    //

    ServerBufferDescriptor.cBuffers = 1;
    ServerBufferDescriptor.pBuffers = &ServerSecurityToken;
    ServerBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ServerSecurityToken.BufferType = SECBUFFER_TOKEN;
    ServerSecurityToken.pvBuffer = LocalAlloc(LMEM_FIXED, PackageInfo->SecurityTokenSize);

    if ( ServerSecurityToken.pvBuffer == NULL ) {
        return GetLastError();
    }

    ClientBufferDescriptor.cBuffers = 1;
    ClientBufferDescriptor.pBuffers = &ClientSecurityToken;
    ClientBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ClientSecurityToken.BufferType = SECBUFFER_TOKEN;
    ClientSecurityToken.pvBuffer = LocalAlloc(LMEM_FIXED, PackageInfo->SecurityTokenSize);
    ClientSecurityToken.cbBuffer = 0;

    if ( ClientSecurityToken.pvBuffer == NULL ) {
        LocalFree( ServerSecurityToken.pvBuffer );
        return GetLastError();
    }

    //
    // Indicate context requirements. replay is necessary in order for the
    // context to generate valid signatures
    //
    ContextRequirements = ISC_REQ_MUTUAL_AUTH |
                          ISC_REQ_REPLAY_DETECT |
                          ISC_REQ_DATAGRAM;

    //
    // mark the outbound context unstable. increment the change count
    // in anticipation of committing a new outbound context at the 
    // conclusion of this routine.
    //

    TargetSecurityData = &SecurityCtxtData[ INT_NODE( TargetNodeId )];

    EnterCriticalSection( &SecContextLock );

    OutboundCtxt = TargetSecurityData->Outbound;
    TargetSecurityData->Outbound = &InvalidCtxtHandle;
    TargetSecurityData->OutboundStable = FALSE;
    outboundChangeCount = ++TargetSecurityData->OutboundChangeCount;

    LeaveCriticalSection( &SecContextLock );

    //
    // if there was an old outbound context, dereference it now
    //
    if ( OutboundCtxt != &InvalidCtxtHandle ) {
        ClMsgDereferenceSecurityCtxt( OutboundCtxt );
    }

    //
    // Create a new outbound context.
    //
    OutboundCtxt = ClMsgCreateSecurityCtxt();
    if ( OutboundCtxt == NULL ) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to allocate outbound security context "
            "for node %1!u!.\n",
            TargetNodeId
            );
        OutboundCtxt = &InvalidCtxtHandle;
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // we obtain a blob from the SSPI provider, which is shiped over to the
    // other side where another blob is generated. This continues until the
    // two SSPI providers say we're done or an error has occurred.
    //

    do {

        //
        // init the output buffer each time we loop
        //
        ServerSecurityToken.cbBuffer = PackageInfo->SecurityTokenSize;

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,"[ClMsg] init pass %1!u!: server token size = %2!u!, "
                              "client = %3!u!\n",
                                passCount,
                                ServerSecurityToken.cbBuffer,
                                ClientSecurityToken.cbBuffer);
#endif

        OurStatus = (*SecurityFuncs->InitializeSecurityContext)(
                        &PackageInfo->OutboundSecurityCredentials,
                        passCount == 1 ? NULL : &OutboundCtxt->Handle,
                        NULL, // CsServiceDomainAccount, BUGBUG Temporary Workaround See Bug 160108
                        ContextRequirements,
                        0,
                        SECURITY_NATIVE_DREP,
                        passCount == 1 ? NULL : &ClientBufferDescriptor,
                        0,
                        &OutboundCtxt->Handle,
                        &ServerBufferDescriptor,
                        &ContextAttributes,
                        &Expiration);

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,"[ClMsg] after init pass %1!u!: status = %2!X!, server "
                              "token size = %3!u!, client = %4!u!\n",
                                passCount,
                                OurStatus,
                                ServerSecurityToken.cbBuffer,
                                ClientSecurityToken.cbBuffer);
#endif

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] The outbound security context to node %1!u! was %2!ws!, "
                    "status %3!08X!.\n",
                    TargetNodeId,
                    NT_SUCCESS( OurStatus ) ? L"initialized" : L"rejected",
                    OurStatus);

        if ( !NT_SUCCESS( OurStatus )) {

            ClMsgDereferenceSecurityCtxt( OutboundCtxt );
            OutboundCtxt = &InvalidCtxtHandle;
            Status = OurStatus;
            break;
        }

        //
        // complete the blob if the Security package directs us as such
        //

        if ( OurStatus == SEC_I_COMPLETE_NEEDED ||
             OurStatus == SEC_I_COMPLETE_AND_CONTINUE ) {

            (*SecurityFuncs->CompleteAuthToken)(
                &OutboundCtxt->Handle,
                &ServerBufferDescriptor
                );
        }

        //
        // blobs are passed to the server side until it returns ok.
        //

        if (ServerStatus == SEC_I_CONTINUE_NEEDED ||
            ServerStatus == SEC_I_COMPLETE_AND_CONTINUE ) {

            ClientSecurityToken.cbBuffer = PackageInfo->SecurityTokenSize;

            RPCStatus = MmRpcEstablishSecurityContext(
                            Session[ TargetNodeId ],
                            JoinSequence,
                            NmLocalNodeId,
                            passCount == 1,
                            RoleOfClient,
                            ServerSecurityToken.pvBuffer,
                            ServerSecurityToken.cbBuffer,
                            ClientSecurityToken.pvBuffer,
                            &ClientSecurityToken.cbBuffer,
                            &ServerStatus);

            FacilityCode = HRESULT_FACILITY( ServerStatus );
            if (
                ( FacilityCode != 0 && !SUCCEEDED( ServerStatus ))
                ||
                ( FacilityCode == 0 && ServerStatus != ERROR_SUCCESS )
                ||
                RPCStatus != RPC_S_OK )
            {

                //
                // either the blob was rejected or we had an RPC failure. If
                // RPC, then ServerStatus is meaningless. Note that we don't
                // delete the security context on the side since that might
                // clobber an already negotiated context (i.e., the joiner has
                // already negotiated its outbound context and the sponsor is
                // in this routine trying to negotiate its outbound
                // context. If the sponsor negotiation fails at some point, we
                // don't want to whack the joiner's outbound context).
                //
                if ( RPCStatus != RPC_S_OK ) {
                    ServerStatus = RPCStatus;
                }

                ClRtlLogPrint(LOG_UNUSUAL, 
                    "[ClMsg] The outbound security context was rejected by node %1!u!, "
                    "status 0x%2!08X!.\n",
                    TargetNodeId,
                    ServerStatus);

                ClMsgDereferenceSecurityCtxt( OutboundCtxt );
                OutboundCtxt = &InvalidCtxtHandle;
                Status = ServerStatus;
                break;
            } else {
                ClRtlLogPrint(LOG_NOISE, 
                    "[ClMsg] The outbound security context was accepted by node %1!u!, "
                    "status 0x%2!08X!.\n",
                    TargetNodeId,
                    ServerStatus);
            }
        }

        ++passCount;

    } while ( ServerStatus == SEC_I_CONTINUE_NEEDED ||
              ServerStatus == SEC_I_COMPLETE_AND_CONTINUE ||
              OurStatus == SEC_I_CONTINUE_NEEDED ||
              OurStatus == SEC_I_COMPLETE_AND_CONTINUE );

    if ( OurStatus == SEC_E_OK && ServerStatus == SEC_E_OK ) {
        
        SecPkgContext_Sizes contextSizes;
        SecPkgContext_PackageInfo packageInfo;
        

#if 0
        SYSTEMTIME localSystemTime;
        SYSTEMTIME renegotiateSystemTime;
        FILETIME expFileTime;
        FILETIME renegotiateFileTime;
        TIME_ZONE_INFORMATION timeZoneInfo;
        DWORD timeType;

        //
        // convert the expiration time to something meaningful we can print in
        // the log.
        //
        timeType = GetTimeZoneInformation( &timeZoneInfo );

        if ( timeType != TIME_ZONE_ID_INVALID ) {
            expFileTime.dwLowDateTime = Expiration.LowPart;
            expFileTime.dwHighDateTime = Expiration.HighPart;
            if ( FileTimeToSystemTime( &expFileTime, &localSystemTime )) {
                PWCHAR timeDecoration = L"";

                if ( timeType == TIME_ZONE_ID_STANDARD ) {
                    timeDecoration = timeZoneInfo.StandardName;
                } else if ( timeType == TIME_ZONE_ID_DAYLIGHT ) {
                    timeDecoration = timeZoneInfo.DaylightName;
                }

                ClRtlLogPrint(LOG_NOISE,
                           "[ClMsg] Context expires at %1!u!:%2!02u!:%3!02u! %4!u!/%5!u!/%6!u! %7!ws!\n",
                            localSystemTime.wHour,
                            localSystemTime.wMinute,
                            localSystemTime.wSecond,
                            localSystemTime.wMonth,
                            localSystemTime.wDay,
                            localSystemTime.wYear,
                            timeDecoration);
            }
        }

        //
        // now compute the half life of the expiration and set a timer to go
        // off and renegotiate a context at that time
        //
#endif

        //
        // Get the inbound context. If it wasn't provided, fish it out
        // of the SecContext array.
        //
        if ( MemberInboundCtxt == NULL ) {

            CL_ASSERT( RoleOfClient == SecurityRoleJoiningMember );

            EnterCriticalSection( &SecContextLock );

            InboundCtxt = TargetSecurityData->Inbound;
            ClMsgReferenceSecurityCtxt( InboundCtxt );

            // mark context data as usable
            TargetSecurityData->InboundStable = TRUE;
            
            LeaveCriticalSection( &SecContextLock );
        
        } else {

            CL_ASSERT( RoleOfClient == SecurityRoleClusterMember );
            InboundCtxt = MemberInboundCtxt;
        }
        

        //
        // get the size of the signature buffer
        //
        Status = (*SecurityFuncs->QueryContextAttributes)(
                     &InboundCtxt->Handle,
                     SECPKG_ATTR_SIZES,
                     &contextSizes);

        if ( !NT_SUCCESS( Status )) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to query signature size, status %1!08X!.\n",
                        Status);
            ClMsgDereferenceSecurityCtxt( InboundCtxt );
            goto error_exit;
        }

        PackageInfo->SignatureBufferSize = contextSizes.cbMaxSignature;
        CL_ASSERT( contextSizes.cbMaxSignature <= MAX_SIGNATURE_SIZE );

        //
        // get the name of the negotiated package and import the contexts for
        // use in clusnet
        //
        Status = (*SecurityFuncs->QueryContextAttributes)(
                     &InboundCtxt->Handle,
                     SECPKG_ATTR_PACKAGE_INFO,
                     &packageInfo);

        if ( !NT_SUCCESS( Status )) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to query package info, status %1!08X!.\n",
                        Status);
            ClMsgDereferenceSecurityCtxt( InboundCtxt );
            goto error_exit;
        }

        Status = ClMsgImportSecurityContexts(TargetNodeId,
                                             packageInfo.PackageInfo->Name,
                                             contextSizes.cbMaxSignature,
                                             InboundCtxt,
                                             OutboundCtxt);

        (*SecurityFuncs->FreeContextBuffer)( packageInfo.PackageInfo );

        if ( Status != ERROR_SUCCESS ) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] Can't import node %1!u! security contexts on server, "
                        "status %2!08X!.\n",
                        TargetNodeId,
                        Status);
        }

        //
        // done with inbound security context handle.
        //
        if ( MemberInboundCtxt == NULL ) {
            ClMsgDereferenceSecurityCtxt( InboundCtxt );
        }

        //
        // we have valid contexts with this package so record that this is the
        // one we're using
        //
        pkgInfoValid = TRUE;
    }

error_exit:

    //
    // the context is stable (either good or invalid) at this point
    //
    EnterCriticalSection( &SecContextLock );

    if ( TargetSecurityData->OutboundChangeCount != outboundChangeCount ) {
        if ( NT_SUCCESS(Status) ) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[ClMsg] Outbound security context for node %1!u! "
                "changed during establishment.\n",
                TargetNodeId
                );
            Status = SEC_E_UNFINISHED_CONTEXT_DELETED;
        }    
    } else {

        TargetSecurityData->Outbound = OutboundCtxt;
        TargetSecurityData->OutboundStable = TRUE;
        TargetSecurityData->OutboundChangeCount++;
        if ( pkgInfoValid ) {
            TargetSecurityData->PackageInfo = PackageInfo;
        }
    }

    LeaveCriticalSection( &SecContextLock );

    //
    // free buffers used during this process
    //

    LocalFree( ClientSecurityToken.pvBuffer );
    LocalFree( ServerSecurityToken.pvBuffer );

    return Status;
} // ClMsgEstablishSecurityContext

//
// Exported Routines
//
DWORD
ClMsgInit(
    DWORD mynode
    )
{
    DWORD                status;
    SOCKADDR_CLUSTER     clusaddr;
    int                  err;
    DWORD                ignored;
    DWORD                bytesReceived = 0;
    WSABUF               wsaBuf;

    UNREFERENCED_PARAMETER(mynode);

    if (ClMsgInitialized == TRUE) {
        ClRtlLogPrint(LOG_NOISE, "[ClMsg] Already initialized!!!\n");
        return(ERROR_SUCCESS);
    }

    ClRtlLogPrint(LOG_NOISE, "[ClMsg] Initializing.\n");

    InitializeCriticalSection( &SecContextLock );

    //
    // load the security provider DLL and get the list of package names
    //
    status = ClMsgLoadSecurityProvider();
    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    InitializeCriticalSection( &GenerationCritSect );
    
    //
    // Create the binding generation table.
    //
    BindingGeneration = LocalAlloc(
                  LMEM_FIXED,
                  sizeof(DWORD) * (NmMaxNodeId + 1)
                  );

    if (BindingGeneration == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory(BindingGeneration, sizeof(DWORD) * (NmMaxNodeId + 1));
    
    //
    // Create the RPC binding handle table.
    //
    Session = LocalAlloc(
                  LMEM_FIXED,
                  sizeof(RPC_BINDING_HANDLE) * (NmMaxNodeId + 1)
                  );

    if (Session == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    ZeroMemory(Session, sizeof(RPC_BINDING_HANDLE) * (NmMaxNodeId + 1));

    //
    // Create a work queue to process overlapped I/O completions
    //
    WorkQueue = ClRtlCreateWorkQueue(
                    CLMSG_MAX_WORK_THREADS,
                    CLMSG_WORK_THREAD_PRIORITY
                    );

    if (WorkQueue == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Unable to create work queue, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Allocate a datagram receive context
    //
    DatagramContext = LocalAlloc(LMEM_FIXED, sizeof(CLMSG_DATAGRAM_CONTEXT));

    if (DatagramContext == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to allocate datagram receive buffer, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Allocate an event receive context
    //
    EventContext = LocalAlloc(LMEM_FIXED, sizeof(CLMSG_EVENT_CONTEXT));

    if (EventContext == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to allocate event context, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Open and bind the datagram socket
    //
    DatagramSocket = WSASocket(
                         AF_CLUSTER,
                         SOCK_DGRAM,
                         CLUSPROTO_CDP,
                         NULL,
                         0,
                         WSA_FLAG_OVERLAPPED
                         );

    if (DatagramSocket == INVALID_SOCKET) {
        status = WSAGetLastError();
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Unable to create dgram socket, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    ZeroMemory(&clusaddr, sizeof(SOCKADDR_CLUSTER));

    clusaddr.sac_family = AF_CLUSTER;
    clusaddr.sac_port = CLMSG_DATAGRAM_PORT;
    clusaddr.sac_node = 0;

    err = bind(
              DatagramSocket,
              (struct sockaddr *) &clusaddr,
              sizeof(SOCKADDR_CLUSTER)
              );

    if (err == SOCKET_ERROR) {
        status = WSAGetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to bind dgram socket, status %1!u!\n",
            status
            );
        closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        goto error_exit;
    }

    //
    // Tell the Cluster Transport to disable node state checks on
    // this socket.
    //
    err = WSAIoctl(
              DatagramSocket,
              SIO_CLUS_IGNORE_NODE_STATE,
              NULL,
              0,
              NULL,
              0,
              &ignored,
              NULL,
              NULL
              );

    if (err == SOCKET_ERROR) {
        status = WSAGetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Ignore state ioctl failed, status %1!u!\n",
            status
            );
        closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        goto error_exit;
    }

    //
    // Associate the socket with the work queue
    //
    status = ClRtlAssociateIoHandleWorkQueue(
                 WorkQueue,
                 (HANDLE) DatagramSocket,
                 0
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to associate socket with work queue, status %1!u!\n",
            status
            );
        closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        goto error_exit;
    }

    //
    // Open a control channel to the Cluster Network driver.
    //
    ClusnetHandle = ClusnetOpenControlChannel(FILE_SHARE_READ);

    if (ClusnetHandle == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to open control channel to Cluster Network driver, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Associate the control channel with the work queue
    //
    status = ClRtlAssociateIoHandleWorkQueue(
                 WorkQueue,
                 ClusnetHandle,
                 0
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to associate control channel with work queue, status %1!u!\n",
            status
            );
        CloseHandle(ClusnetHandle); ClusnetHandle = NULL;
        goto error_exit;
    }

    //
    // Post a receive on the socket
    //
    ZeroMemory(DatagramContext, sizeof(CLMSG_DATAGRAM_CONTEXT));

    DatagramContext->ClRtlWorkItem.WorkRoutine = ClMsgDatagramHandler,
    DatagramContext->ClRtlWorkItem.Context = DatagramContext;

    DatagramContext->SourceAddressLength = sizeof(SOCKADDR_CLUSTER);

    wsaBuf.len = sizeof( DatagramContext->Data );
    wsaBuf.buf = (PCHAR)&DatagramContext->Data;

    err = WSARecvFrom(
              DatagramSocket,
              &wsaBuf,
              1,
              &bytesReceived,
              &(DatagramContext->Flags),
              (struct sockaddr *) &(DatagramContext->SourceAddress),
              &(DatagramContext->SourceAddressLength),
              &(DatagramContext->ClRtlWorkItem.Overlapped),
              NULL
              );

    if (err == SOCKET_ERROR) {
        status = WSAGetLastError();

        if (status != WSA_IO_PENDING) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[ClMsg] Unable to post datagram receive, status %1!u!\n",
                status
                );
            goto error_exit;
        }
    }

    //
    // Enable delivery of all Cluster Network event types
    //
    status = ClusnetSetEventMask(ClusnetHandle, ClusnetEventAll);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Unable to set event mask, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Post a work item to receive the next Cluster Network event
    //
    ClRtlInitializeWorkItem(
        &(EventContext->ClRtlWorkItem),
        ClMsgEventHandler,
        EventContext
        );

    status = ClusnetGetNextEvent(
                 ClusnetHandle,
                 &(EventContext->EventData),
                 &(EventContext->ClRtlWorkItem.Overlapped)
                 );

    if ((status != ERROR_IO_PENDING) && (status != ERROR_SUCCESS)) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[ClMsg] GetNextEvent failed, status %1!u!\n",
                status
                );
            goto error_exit;
    }

    ClMsgInitialized = TRUE;
    return(ERROR_SUCCESS);

error_exit:

    ClMsgCleanup();

    return(status);
} // ClMsgInit


VOID
ClMsgCleanup(
    VOID
    )
{
    ULONG                   i;
    PCLUSTER_PACKAGE_INFO   packageInfo;

    ClRtlLogPrint(LOG_NOISE, "[ClMsg] Cleaning up\n");

    if (Session != NULL) {
        LocalFree(Session); Session = NULL;
    }

    if (BindingGeneration != NULL) {
        LocalFree(BindingGeneration); BindingGeneration = NULL;
    }

    if (WorkQueue != NULL) {
        if (DatagramSocket != INVALID_SOCKET) {
            closesocket(DatagramSocket); DatagramSocket = INVALID_SOCKET;
        }
        else {
            if (DatagramContext != NULL) {
                LocalFree(DatagramContext); DatagramContext = NULL;
            }
        }

        if (ClusnetHandle != NULL) {
            CloseHandle(ClusnetHandle); ClusnetHandle = NULL;
        }
        else {
            if (EventContext != NULL) {
                LocalFree(EventContext); EventContext = NULL;
            }
        }

        ClRtlDestroyWorkQueue(WorkQueue); WorkQueue = NULL;
    }

    //
    // clean up the security related stuff
    //

    EnterCriticalSection( &SecContextLock );

    for ( i = ClusterMinNodeId; i <= NmMaxNodeId; ++i ) {
        PCLUSTER_SECURITY_DATA SecurityData = &SecurityCtxtData[ INT_NODE( i )];

        if ( SecurityData->Outbound != &InvalidCtxtHandle ) {
            ClMsgDereferenceSecurityCtxt( SecurityData->Outbound );
            SecurityData->Outbound = &InvalidCtxtHandle;
            SecurityData->OutboundChangeCount++;
        }

        if ( SecurityData->Inbound != &InvalidCtxtHandle ) {
            ClMsgDereferenceSecurityCtxt( SecurityData->Inbound );
            SecurityData->Inbound = &InvalidCtxtHandle;
            SecurityData->InboundChangeCount++;
        }

        SecurityData->PackageInfo = NULL;
        SecurityData->InboundStable = TRUE;
        SecurityData->OutboundStable = TRUE;
    }

    LeaveCriticalSection( &SecContextLock );

    packageInfo = PackageInfoList;
    while ( packageInfo != NULL ) {
        PCLUSTER_PACKAGE_INFO lastInfo;

        if ( VALID_SSPI_HANDLE( packageInfo->OutboundSecurityCredentials )) {
            (*SecurityFuncs->FreeCredentialHandle)( &packageInfo->OutboundSecurityCredentials );
        }

        if ( VALID_SSPI_HANDLE( packageInfo->InboundSecurityCredentials )) {
            (*SecurityFuncs->FreeCredentialHandle)( &packageInfo->InboundSecurityCredentials );
        }

        LocalFree( packageInfo->Name );
        lastInfo = packageInfo;
        packageInfo = packageInfo->Next;
        LocalFree( lastInfo );
    }

    PackageInfoList = NULL;

    if ( SecurityProvider != NULL ) {
        FreeLibrary( SecurityProvider );
        SecurityProvider = NULL;
        SecurityFuncs = NULL;
    }

    ClMsgInitialized = FALSE;

    //
    // [REENGINEER] GorN 8/25/2000: if a join fails, ClMsgCleanup will be executed,
    // but some stray RPC thread can call s_MmRpcDeleteSecurityContext later.
    // s_MmRpcDeleteSecuryContext needs SecContextLock for synchronization
    // See bug #145746.
    // I traced the code and it seems that all code paths that execute ClMsgCleanup
    // will eventually lead to clustering service death, so it is valid (though ugly)
    // not to delete this critical section.
    //
    // DeleteCriticalSection( &SecContextLock );

    return;

}  // ClMsgCleanup


DWORD
ClMsgSendUnack(
    DWORD   DestinationNode,
    LPCSTR  Message,
    DWORD   MessageLength
    )

/*++

Description

    Send an unacknowledged datagram to the destintation node. The only
    packets coming through this function should be regroup packets.
    Heartbeats and poison packets originate in clusnet. Packets sent by
    MM as a result of the Join process are handled by MmRpcMsgSend, which
    is authenticated.

    A valid security context must be established between the local and
    destination node. The message is signed.

--*/
{
    DWORD                   status = ERROR_SUCCESS;
    SOCKADDR_CLUSTER        clusaddr;
    int                     bytesSent;
    SecBufferDesc           SignatureDescriptor;
    SecBuffer               SignatureSecBuffer[2];
    PUCHAR                  SignatureBuffer;
    WSABUF                  wsaBuf[2];
    SECURITY_STATUS         SecStatus;
    PCLUSTER_SECURITY_DATA  SecurityData;
    PSECURITY_CTXT_HANDLE   OutboundCtxt;
    ULONG                   SigBufferSize;

    CL_ASSERT(ClMsgInitialized == TRUE);
    CL_ASSERT(DatagramSocket != INVALID_SOCKET);
    CL_ASSERT(DestinationNode <= NmMaxNodeId);

    if (DestinationNode == 0) {
        // no signing if multicasting
        
        ZeroMemory(&clusaddr, sizeof(SOCKADDR_CLUSTER));

        clusaddr.sac_family = AF_CLUSTER;
        clusaddr.sac_port = CLMSG_DATAGRAM_PORT;
        clusaddr.sac_node = DestinationNode;

        wsaBuf[0].len = MessageLength;
        wsaBuf[0].buf = (PCHAR)Message;

        status = WSASendTo(DatagramSocket,
                           wsaBuf,
                           1,
                           &bytesSent,
                           0,
                           (struct sockaddr *) &clusaddr,
                           sizeof(clusaddr),
                           NULL,
                           NULL);

        if (status == SOCKET_ERROR) {
            status = WSAGetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] Multicast Datagram send failed, status %1!u!\n",
                        status
                        );
        }
        
    } else if (DestinationNode != NmLocalNodeId) {

        EnterCriticalSection( &SecContextLock );

        SecurityData = &SecurityCtxtData[ INT_NODE( DestinationNode )];
        SigBufferSize = SecurityData->PackageInfo->SignatureBufferSize;
        CL_ASSERT( SigBufferSize <= 256 );
        SignatureBuffer = _alloca( SigBufferSize );
        if ( !SignatureBuffer ) {
            // if we fail - return error now
            LeaveCriticalSection( &SecContextLock );
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if ( SecurityData->OutboundStable &&
             VALID_SSPI_HANDLE( SecurityData->Outbound->Handle )) {

            OutboundCtxt = SecurityData->Outbound;
            ClMsgReferenceSecurityCtxt( OutboundCtxt );

            LeaveCriticalSection( &SecContextLock );

            //
            // build a descriptor for the message and signature
            //

            SignatureDescriptor.cBuffers = 2;
            SignatureDescriptor.pBuffers = SignatureSecBuffer;
            SignatureDescriptor.ulVersion = SECBUFFER_VERSION;

            SignatureSecBuffer[0].BufferType = SECBUFFER_DATA;
            SignatureSecBuffer[0].cbBuffer = MessageLength;
            SignatureSecBuffer[0].pvBuffer = (PVOID)Message;

            SignatureSecBuffer[1].BufferType = SECBUFFER_TOKEN;
            SignatureSecBuffer[1].cbBuffer = SigBufferSize;
            SignatureSecBuffer[1].pvBuffer = SignatureBuffer;

            //
            // generate the signature. We'll let the provider generate
            // the sequence number.
            //

            SecStatus = (*SecurityFuncs->MakeSignature)(
                            &OutboundCtxt->Handle,
                            0,
                            &SignatureDescriptor,
                            0);                        // no supplied sequence number

            ClMsgDereferenceSecurityCtxt( OutboundCtxt );

            if ( NT_SUCCESS( SecStatus )) {

                ZeroMemory(&clusaddr, sizeof(SOCKADDR_CLUSTER));

                clusaddr.sac_family = AF_CLUSTER;
                clusaddr.sac_port = CLMSG_DATAGRAM_PORT;
                clusaddr.sac_node = DestinationNode;

                wsaBuf[0].len = MessageLength;
                wsaBuf[0].buf = (PCHAR)Message;

                wsaBuf[1].len = SigBufferSize;
                wsaBuf[1].buf = (PCHAR)SignatureBuffer;

                status = WSASendTo(DatagramSocket,
                                   wsaBuf,
                                   2,
                                   &bytesSent,
                                   0,
                                   (struct sockaddr *) &clusaddr,
                                   sizeof(clusaddr),
                                   NULL,
                                   NULL);

                if (status == SOCKET_ERROR) {
                    status = WSAGetLastError();
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[ClMsg] Datagram send failed, status %1!u!\n",
                                status
                                );
                }
            } else {
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[ClMsg] Couldn't create signature for packet to node %u. Status: %08X\n",
                            DestinationNode,
                            SecStatus);
            }
        } else {
            LeaveCriticalSection( &SecContextLock );
            status = ERROR_CLUSTER_NO_SECURITY_CONTEXT;

            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] No Security context for node %1!u!\n",
                        DestinationNode);
        }
    }
    else {
        MMDiag( (LPCSTR)Message, MessageLength, &MessageLength);
    }

    return(status);
} // ClMsgSendUnack


DWORD
ClMsgCreateRpcBinding(
    IN  PNM_NODE              Node,
    OUT RPC_BINDING_HANDLE *  BindingHandle,
    IN  DWORD                 RpcBindingOptions
    )
{
    DWORD                Status;
    RPC_BINDING_HANDLE   NewBindingHandle;
    WCHAR               *BindingString = NULL;
    CL_NODE_ID           NodeId = NmGetNodeId(Node);


    ClRtlLogPrint(LOG_NOISE, 
        "[ClMsg] Creating RPC binding for node %1!u!\n",
        NodeId
        );

    Status = RpcStringBindingComposeW(
                 L"e248d0b8-bf15-11cf-8c5e-08002bb49649",
                 CLUSTER_RPC_PROTSEQ,
                 (LPWSTR) OmObjectId(Node),
                 CLUSTER_RPC_PORT,
                 NULL,
                 &BindingString
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to compose binding string for node %1!u!, status %2!u!\n",
            NodeId,
            Status
            );
        return(Status);
    }

    Status = RpcBindingFromStringBindingW(BindingString, &NewBindingHandle);

    RpcStringFreeW(&BindingString);

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClMsg] Failed to compose binding handle for node %1!u!, status %2!u!\n",
            NodeId,
            Status
            );
        return(Status);
    }

    //
    // If we have RpcBindingOptions, then set them
    //
    if ( RpcBindingOptions ) {
        Status = RpcBindingSetOption(
                     NewBindingHandle,
                     RpcBindingOptions,
                     TRUE
                     );

        if (Status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[ClMsg] Unable to set unique RPC binding option for node %1!u!, status %2!u!.\n",
                NodeId,
                Status
                );
        }
    }

    Status = RpcMgmtSetComTimeout(
                 NewBindingHandle,
                 CLUSTER_INTRACLUSTER_RPC_COM_TIMEOUT
                 );

    if (Status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClMsg] Unable to set RPC com timeout to node %1!u!, status %2!u!.\n",
            NodeId,
            Status
            );
    }

    Status = ClMsgVerifyRpcBinding(NewBindingHandle);

    if (Status == ERROR_SUCCESS) {
        *BindingHandle = NewBindingHandle;
    }

    return(Status);

} // ClMsgCreateRpcBinding


DWORD
ClMsgVerifyRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    )
{
    DWORD    status = ERROR_SUCCESS;
    DWORD    packageIndex;


    //
    // establish a security context with for the intracluster binding. We need
    // a routine to call since datagram RPC doesn't set up the context until
    // the first call. MmRpcDeleteSecurityContext is idempotent and won't do
    // any damage in that respect.
    //
    for (packageIndex = 0;
         packageIndex < CsNumberOfRPCSecurityPackages;
         ++packageIndex )        
    {
        status = RpcBindingSetAuthInfoW(
                                        BindingHandle,
                                        CsServiceDomainAccount,
                                        RPC_C_AUTHN_LEVEL_CONNECT,
                                        CsRPCSecurityPackage[ packageIndex ],
                                        NULL,
                                        RPC_C_AUTHZ_NAME
                                        );

        if (status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                          "[ClMsg] Unable to set IntraCluster AuthInfo using %1!ws! "
                          "package, Status %2!u!.\n",
                          CsRPCSecurityPackageName[packageIndex],
                          status
                          );
            continue;
        }

        status = MmRpcDeleteSecurityContext(
                                            BindingHandle,
                                            NmLocalNodeId
                                            );

        if ( status == RPC_S_OK ) {
            ClRtlLogPrint(LOG_NOISE, 
                          "[ClMsg] Using %1!ws! package for RPC security contexts.\n",
                          CsRPCSecurityPackageName[packageIndex]
                          );
            break;
        } else {
            ClRtlLogPrint(LOG_NOISE, 
                          "[ClMsg] Failed to establish RPC security context using %1!ws! package "
                          ", status %2!u!.\n",
                          CsRPCSecurityPackageName[packageIndex],
                          status
                          );
        }
    }

    return(status);

} // ClMsgVerifyRpcBinding


VOID
ClMsgDeleteRpcBinding(
    IN RPC_BINDING_HANDLE  BindingHandle
    )
{
    RPC_BINDING_HANDLE  bindingHandle = BindingHandle;

    RpcBindingFree(&bindingHandle);

    return;

} // ClMsgDeleteRpcBinding


DWORD
ClMsgCreateDefaultRpcBinding(
    IN  PNM_NODE  Node,
    OUT PDWORD    Generation
    )
{
    DWORD                Status;
    RPC_BINDING_HANDLE   BindingHandle;
    CL_NODE_ID           NodeId = NmGetNodeId( Node );


    CL_ASSERT(Session != NULL);

    //
    // [GorN 08/01.99] InterlockedAdd will not work here,
    // see the code in ClMsgdeleteDefaultRpcBinding
    //
    EnterCriticalSection( &GenerationCritSect );
    
        *Generation = ++BindingGeneration[NodeId];
        
    LeaveCriticalSection( &GenerationCritSect );
    
    ClRtlLogPrint(LOG_NOISE, 
        "[ClMsg] BindingGeneration %1!u!\n",
        BindingGeneration[NodeId]
        );

    if (Session[NodeId] != NULL) {
        ClRtlLogPrint(LOG_NOISE, 
            "[ClMsg] Verifying old RPC binding for node %1!u!\n",
            NodeId
            );

        BindingHandle = Session[NodeId];

        Status = ClMsgVerifyRpcBinding(BindingHandle);
    }
    else {
        Status = ClMsgCreateRpcBinding(
                                Node,
                                &BindingHandle,
                                0 );

        if (Status == RPC_S_OK) {
            Session[NodeId] = BindingHandle;
        }
    }

    return(Status);

} // ClMsgCreateDefaultRpcBinding


VOID
ClMsgDeleteDefaultRpcBinding(
    IN PNM_NODE   Node,
    IN DWORD      Generation
    )
{
    CL_NODE_ID           NodeId = NmGetNodeId(Node);
    RPC_BINDING_HANDLE   BindingHandle;


    if (Session != NULL) {
        EnterCriticalSection( &GenerationCritSect );

        BindingHandle = Session[NodeId];
        
        if (Generation != BindingGeneration[NodeId]) {

            BindingHandle = NULL;
            
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] DeleteDefaultBinding. Gen %1!u! != BindingGen %2!u!\n",
                        Generation,
                        BindingGeneration[NodeId]);
            
        }
        
        LeaveCriticalSection( &GenerationCritSect );

        if (BindingHandle != NULL) {
            Session[NodeId] = NULL;
            ClMsgDeleteRpcBinding(BindingHandle);
        }
    }

    return;

} // ClMsgDeleteDefaultRpcBinding


DWORD
ClMsgCreateActiveNodeSecurityContext(
    IN DWORD     JoinSequence,
    IN PNM_NODE  Node
    )

/*++

Routine Description:

    Create security contexts between the joiner and the specified cluster
    member.

Arguments:

    JoinSequence - the current join sequence number. Used the sponsor to
                   determine if this is beginning of a new context generation
                   sequence

    Node - A pointer to the target node object.

Return Value:

    ERROR_SUCCESS if everything worked ok...

--*/

{
    DWORD               memberNodeId = NmGetNodeId( Node );
    CLUSTER_NODE_STATE  nodeState;
    DWORD               status = ERROR_SUCCESS;
    DWORD               internalMemberId;
    PCLUSTER_PACKAGE_INFO   packageInfo;
    PSECURITY_CTXT_HANDLE outboundCtxt;

    nodeState = NmGetNodeState( Node );

    if (nodeState == ClusterNodeUp || nodeState == ClusterNodePaused) {

#if DBG
        CLUSNET_NODE_COMM_STATE   NodeCommState;

        status = ClusnetGetNodeCommState(
                     NmClusnetHandle,
                     memberNodeId,
                     &NodeCommState);

        if (status != ERROR_SUCCESS || NodeCommState != ClusnetNodeCommStateOnline)
        {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[ClMsg] CreateActiveNodeSecurityContext: ClusnetGetNodeCommState status %1!d! node state %2!d!\n",
                        status,
                        NodeCommState);
        }
        CL_ASSERT(status == ERROR_SUCCESS);
        CL_ASSERT(NodeCommState == ClusnetNodeCommStateOnline);
#endif // DBG

        packageInfo = PackageInfoList;
        while ( packageInfo != NULL ) {

            status = ClMsgEstablishSecurityContext(JoinSequence,
                                                   memberNodeId,
                                                   SecurityRoleJoiningMember,
                                                   packageInfo,
                                                   NULL);

            if ( status == ERROR_SUCCESS ) {
                break;
            }

            //
            // clean up if it didn't work
            //

            internalMemberId = INT_NODE( memberNodeId );

            EnterCriticalSection( &SecContextLock );

            outboundCtxt = SecurityCtxtData[ internalMemberId ].Outbound;
            SecurityCtxtData[ internalMemberId ].Outbound = &InvalidCtxtHandle;

            LeaveCriticalSection( &SecContextLock );

            if (outboundCtxt != &InvalidCtxtHandle) {
                ClMsgDereferenceSecurityCtxt( outboundCtxt );
            }

            MmRpcDeleteSecurityContext(Session[ memberNodeId ],
                                       NmLocalNodeId);
            
            packageInfo = packageInfo->Next;
        }
    }

    return status;
} // ClMsgCreateActiveNodeSecurityContext

error_status_t
s_TestRPCSecurity(
    IN handle_t IDL_handle
    )

/*++

Description:

    Dummy routine to make sure we don't get any failures due to
    authentication when calling other ExtroCluster interfaces

--*/

{
    return ERROR_SUCCESS;
} // s_TestRPCSecurity

error_status_t
s_MmRpcEstablishSecurityContext(
    IN handle_t IDL_handle,
    DWORD NmJoinSequence,
    DWORD EstablishingNodeId,
    BOOL FirstTime,
    SECURITY_ROLE RoleOfClient,
    const UCHAR *ServerContext,
    DWORD ServerContextLength,
    UCHAR *ClientContext,
    DWORD *ClientContextLength,
    HRESULT * ServerStatus
    )

/*++

Routine Description:

    Server side of the RPC interface for establishing a security context

Arguments:

    IDL_handle - RPC binding handle, not used.

    EstablishingNodeId - ID of node wishing to establish security context with us

    FirstTime - used for multi-leg authentication sequences

    RoleOfClient - indicates whether the client establishing the security
        context is acting as a cluster member or a joining member. Determines
        when the client/server roles of establishing a security context are
        reversed.

    ServerContext - security context buffer built by client and used as
        input by server

    ServerContextLength - size of ServerContext in bytes

    ClientContext - address of buffer used by Server in which to write
        context to be sent back to client

    ClientContextLength - pointer to size of ClientContext in bytes. Set by
        client on input to reflect length of ClientContext. Set by server to
        indicate length of ClientContext after AcceptSecurityContext is called.

    ServerStatus - pointer to value that receives status of security package
        call. This is not returned as a function value so as to distinguish
        between RPC errors and errors from this function.

Return Value:

    ERROR_SUCCESS if everything works ok.

--*/

{
    SecBufferDesc       ServerBufferDescriptor;
    SecBuffer           ServerSecurityToken;
    SecBufferDesc       ClientBufferDescriptor;
    SecBuffer           ClientSecurityToken;
    SECURITY_STATUS     Status = ERROR_SUCCESS;
    ULONG               ContextAttributes;
    TimeStamp           Expiration;
    PCLUSTER_SECURITY_DATA SecurityData;
    PSECURITY_CTXT_HANDLE InboundCtxt;
    PNM_NODE            joinerNode = NULL;
    ULONG               contextRequirements;
    PCLUSTER_PACKAGE_INFO   clusterPackageInfo;
    PCLUSTER_PACKAGE_INFO   acceptedPackageInfo=NULL;
    static ULONG        passCount;
    ULONG               inboundChangeCount;
    BOOL                setInvalid = FALSE;
    BOOL                deleteInbound = FALSE;
    BOOL                changeCollision = FALSE;

    CL_ASSERT(EstablishingNodeId >= ClusterMinNodeId &&
              EstablishingNodeId <= NmMaxNodeId );

    if (RoleOfClient == SecurityRoleJoiningMember) {
        //
        // The caller is a joining member.
        //
        joinerNode = NmReferenceJoinerNode(NmJoinSequence,
                                           EstablishingNodeId);

        if (joinerNode == NULL) {
            Status = GetLastError();
        }
    }
    else {
        //
        // The caller is a cluster member.
        //
        DWORD joinSequence = NmGetJoinSequence();
        CL_ASSERT(joinSequence == NmJoinSequence);

        if (joinSequence != NmJoinSequence) {
            //
            // This should never happen.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Received call to establish a security context from member node "
                        "%1!u! with bogus join sequence %2!u!.\n",
                        EstablishingNodeId,
                        NmJoinSequence);

            Status = ERROR_INVALID_PARAMETER;
        }
    }

    if ( Status != ERROR_SUCCESS ) {
        *ServerStatus = Status;
        return ERROR_SUCCESS;
    }

    if ( FirstTime ) {
        passCount = 1;

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] Establishing inbound security context with node %1!u!, sequence %2!u!\n",
                    EstablishingNodeId,
                    NmJoinSequence);
    } else {
        ++passCount;
    }

    SecurityData = &SecurityCtxtData[ INT_NODE( EstablishingNodeId )];
    
    EnterCriticalSection( &SecContextLock );
    
    InboundCtxt = SecurityData->Inbound;
    inboundChangeCount = ++SecurityData->InboundChangeCount;
    
    if ( FirstTime ) {

        // clear the current inbound context
        SecurityData->InboundStable = FALSE;
        SecurityData->Inbound = &InvalidCtxtHandle;
                
    } else {

        // retrieve the context we're building and ref it.
        ClMsgReferenceSecurityCtxt( InboundCtxt );

        // retrieve the package info accepted on the first time
        acceptedPackageInfo = SecurityData->PackageInfo;
    }

    LeaveCriticalSection( &SecContextLock );

    //
    // create an inbound security context if this is the first pass.
    // if we have a leftover handle, try to zap it now.
    //

    if ( FirstTime ) {
        if ( VALID_SSPI_HANDLE( InboundCtxt->Handle )) {
            ClMsgDereferenceSecurityCtxt( InboundCtxt );
        }
        
        InboundCtxt = ClMsgCreateSecurityCtxt();
        if ( InboundCtxt == NULL ) {
            ClRtlLogPrint(LOG_CRITICAL, 
                "[ClMsg] Failed to allocate inbound security context "
                "for node %1!u!.\n",
                EstablishingNodeId
                );
            Status = ERROR_NOT_ENOUGH_MEMORY;
            setInvalid = TRUE;
            goto error_exit;
        }
    } else {
        if ( !VALID_SSPI_HANDLE( InboundCtxt->Handle ) ) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[ClMsg] Inbound security context for node %1!u! "
                "is invalid after first pass.\n",
                EstablishingNodeId
                );
            Status = SEC_E_UNFINISHED_CONTEXT_DELETED;
            goto error_exit;
        }
    }

    //
    // Build the input buffer descriptor.
    //

    ServerBufferDescriptor.cBuffers = 1;
    ServerBufferDescriptor.pBuffers = &ServerSecurityToken;
    ServerBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ServerSecurityToken.BufferType = SECBUFFER_TOKEN;
    ServerSecurityToken.cbBuffer = ServerContextLength;
    ServerSecurityToken.pvBuffer = (PUCHAR)ServerContext;

    //
    // Build the output buffer descriptor.
    //

    ClientBufferDescriptor.cBuffers = 1;
    ClientBufferDescriptor.pBuffers = &ClientSecurityToken;
    ClientBufferDescriptor.ulVersion = SECBUFFER_VERSION;

    ClientSecurityToken.BufferType = SECBUFFER_TOKEN;
    ClientSecurityToken.cbBuffer = *ClientContextLength;
    ClientSecurityToken.pvBuffer = ClientContext;

    contextRequirements = ASC_REQ_MUTUAL_AUTH |
                          ASC_REQ_REPLAY_DETECT |
                          ASC_REQ_DATAGRAM;

    //
    // we don't want to rely on version info to determine what type of package
    // the joiner is using, so we'll try to accept the context with all the
    // packages that are listed in the security package list.
    //
    if ( FirstTime ) {
        CL_ASSERT( PackageInfoList != NULL );

        clusterPackageInfo = PackageInfoList;
        while ( clusterPackageInfo != NULL ) {

            Status = (*SecurityFuncs->AcceptSecurityContext)(
                         &clusterPackageInfo->InboundSecurityCredentials,
                         NULL,
                         &ServerBufferDescriptor,
                         contextRequirements,
                         SECURITY_NATIVE_DREP,
                         &InboundCtxt->Handle,     // receives new context handle
                         &ClientBufferDescriptor,  // receives output security token
                         &ContextAttributes,       // receives context attributes
                         &Expiration               // receives context expiration time
                         );

#if CLUSTER_BETA
            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] pass 1 accept using %1!ws!: status = 0x%2!08X!, server "
                        "token size = %3!u!, client = %4!u!\n",
                        clusterPackageInfo->Name,
                        Status,
                        ServerSecurityToken.cbBuffer,
                        ClientSecurityToken.cbBuffer);
#endif

            ClRtlLogPrint(LOG_NOISE,
                       "[ClMsg] The inbound security context from node %1!u! using the "
                        "%2!ws! package was %3!ws!, status %4!08X!\n",
                        EstablishingNodeId,
                        clusterPackageInfo->Name,
                        NT_SUCCESS( Status ) ? L"accepted" : L"rejected",
                        Status);

            if ( NT_SUCCESS( Status )) {
                acceptedPackageInfo = clusterPackageInfo;
                break;
            }

            clusterPackageInfo = clusterPackageInfo->Next;
        }

        if ( !NT_SUCCESS( Status )) {
            setInvalid = TRUE;
            goto error_exit;
        }
    } else {
        CL_ASSERT( acceptedPackageInfo != NULL );

        Status = (*SecurityFuncs->AcceptSecurityContext)(
                     &acceptedPackageInfo->InboundSecurityCredentials,
                     &InboundCtxt->Handle,
                     &ServerBufferDescriptor,
                     contextRequirements,
                     SECURITY_NATIVE_DREP,
                     &InboundCtxt->Handle,     // receives new context handle
                     &ClientBufferDescriptor,  // receives output security token
                     &ContextAttributes,       // receives context attributes
                     &Expiration               // receives context expiration time
                     );

#if CLUSTER_BETA
        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] after pass %1!u! accept using %2!ws!: status = 0x%3!08X!, server "
                    "token size = %4!u!, client = %5!u!\n",
                    passCount,
                    acceptedPackageInfo->Name,
                    Status,
                    ServerSecurityToken.cbBuffer,
                    ClientSecurityToken.cbBuffer);
#endif

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] The inbound security context from node %1!u! using the %2!ws! package "
                    "was %3!ws!, status: %4!08X!\n",
                    EstablishingNodeId,
                    acceptedPackageInfo->Name,
                    NT_SUCCESS( Status ) ? L"accepted" : L"rejected",
                    Status);

        if ( !NT_SUCCESS( Status )) {
            setInvalid = TRUE;
            deleteInbound = TRUE;
            goto error_exit;
        }
    }

    //
    // update the client's notion of how long its buffer is
    //

    *ClientContextLength = ClientSecurityToken.cbBuffer;

    if (Status == SEC_E_OK
        &&
        RoleOfClient == SecurityRoleJoiningMember)
    {

        //
        // now we have the server side (inbound) of a security context between
        // the joining node and its sponsor (the joining side may not be
        // completely done generating the context). This context is used by
        // the joining node to sign packets and by the sponsor to verify
        // them. Now we do the same thing with client/server roles reversed in
        // order to create an outbound security context which is used by the
        // sponsor to sign packets and by the joining node to verify those
        // packets.
        //
        // look up the package that was used to generate the inbound context
        // and use it for the outbound
        //
        SecPkgContext_PackageInfo packageInfo;

        Status = (*SecurityFuncs->QueryContextAttributes)(
                     &InboundCtxt->Handle,
                     SECPKG_ATTR_PACKAGE_INFO,
                     &packageInfo);

        if ( !NT_SUCCESS( Status )) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to query inbound context package info, status %1!08X!.\n",
                        Status);
            setInvalid = TRUE;
            deleteInbound = TRUE;
            goto error_exit;
        }

        clusterPackageInfo = PackageInfoList;
        while ( clusterPackageInfo != NULL ) {
            if (( wcscmp( clusterPackageInfo->Name, packageInfo.PackageInfo->Name ) == 0 )
                ||
                ( ClRtlStrICmp( L"kerberos", packageInfo.PackageInfo->Name ) == 0
                  &&
                  ClRtlStrICmp( L"negotiate", clusterPackageInfo->Name ) == 0
                ))
            {
                break;
            }

            clusterPackageInfo = clusterPackageInfo->Next;
        }

        if ( clusterPackageInfo == NULL ) {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[ClMsg] Unable to find matching security package for %1!ws!.\n",
                        packageInfo.PackageInfo->Name);

            (*SecurityFuncs->FreeContextBuffer)( packageInfo.PackageInfo );
            Status = SEC_E_SECPKG_NOT_FOUND;
            setInvalid = TRUE;
            deleteInbound = TRUE;
            goto error_exit;
        }

        (*SecurityFuncs->FreeContextBuffer)( packageInfo.PackageInfo );

        Status = ClMsgEstablishSecurityContext(NmJoinSequence,
                                               EstablishingNodeId,
                                               SecurityRoleClusterMember,
                                               clusterPackageInfo,
                                               InboundCtxt);
        if ( !NT_SUCCESS( Status ) ) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[ClMsg] Failed to establish outbound security context with "
                "node %1!u!, status %2!u!.\n",
                EstablishingNodeId, Status
                );
            setInvalid = TRUE;
            deleteInbound = TRUE;
            goto error_exit;
        }
    }

error_exit:

    if (joinerNode != NULL) {
        NmDereferenceJoinerNode(joinerNode);
    }

    EnterCriticalSection( &SecContextLock );

    // Figure out what to store in the Sec Context Array, if 
    // anything at all.
    
    if ( SecurityData->InboundChangeCount != inboundChangeCount ) {
        if ( NT_SUCCESS(Status) ) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[ClMsg] Inbound security context for node %1!u! "
                "changed during establishment.\n",
                EstablishingNodeId
                );
            Status = SEC_E_UNFINISHED_CONTEXT_DELETED;
        }

        changeCollision = TRUE;

    } else {
        
        if ( NT_SUCCESS( Status ) ) {
            // Commit the changes to the Sec Context Array.        
            SecurityData->Inbound = InboundCtxt;
            SecurityData->PackageInfo = acceptedPackageInfo;
            SecurityData->InboundChangeCount++;

            // Mark the Inbound context stable if we are the
            // cluster member. For the cluster joiner, the 
            // Inbound context is marked stable in 
            // ClMsgEstablishSecurityContext.
            if ( RoleOfClient == SecurityRoleJoiningMember ) {
                SecurityData->InboundStable = TRUE;
            }
        } else {

            // Something went wrong. Use the failure flags to
            // determine how to clean up.

            if ( setInvalid ) {
                
                // we must reset the SecContext array entry
                // to invalid.
                SecurityData->Inbound = &InvalidCtxtHandle;
                SecurityData->InboundStable = TRUE;
            }
        }        
    }

    LeaveCriticalSection( &SecContextLock );

    if ( deleteInbound && !FirstTime ) {
        // We replaced the inbound context in the SecContext array
        // with invalid. We must drop the reference from when the
        // inbound context was placed in the array.
        // Ignore the deleteInbound flag if FirstTime, because its
        // impossible for the InboundCtxt to have already been stuffed
        // into the SecContext array (and hence have that extra ref).
        CL_ASSERT( setInvalid );
        ClMsgDereferenceSecurityCtxt( InboundCtxt );
    }

    // Drop the reference taken for non-first-time callers.
    if ( !FirstTime && InboundCtxt != &InvalidCtxtHandle ) {
        ClMsgDereferenceSecurityCtxt( InboundCtxt );
    }

    // If something went wrong on the first time and we were
    // not able to store the inbound ctxt in the SecContext
    // array, we must deref it now. 
    // Note that this includes inboundChangeCount mismatch.
    // If this is not the first time and there was an
    // inboundChangeCount mismatch, we do not need to deref 
    // in addition to the non-first-time deref because
    // whoever wrote in the SecContext array would have
    // derefed then.
    if ( FirstTime && 
         InboundCtxt != NULL &&
         ( !NT_SUCCESS( Status ) || changeCollision ) ) {
        ClMsgDereferenceSecurityCtxt( InboundCtxt );
    }

    *ServerStatus = Status;

    return ERROR_SUCCESS;
} // s_MmRpcEstablishSecurityContext

error_status_t
s_MmRpcDeleteSecurityContext(
    IN handle_t IDL_handle,
    DWORD NodeId
    )

/*++

Routine Description:

    Server side of the RPC interface for clearing a security context

Arguments:

    IDL_handle - RPC binding handle, not used.

    NodeId - Node ID of client wishing to tear down this context

Return Value:

    ERROR_SUCCESS

--*/

{
    PCLUSTER_SECURITY_DATA SecurityData;
    PSECURITY_CTXT_HANDLE  InboundCtxt;
    PSECURITY_CTXT_HANDLE  OutboundCtxt;

    if ( NodeId >= ClusterMinNodeId && NodeId <= NmMaxNodeId ) {

        ClRtlLogPrint(LOG_NOISE,
                   "[ClMsg] Deleting security contexts for node %1!u!.\n",
                    NodeId);

        SecurityData = &SecurityCtxtData[ INT_NODE( NodeId )];

        EnterCriticalSection( &SecContextLock );
        
        InboundCtxt = SecurityData->Inbound;
        SecurityData->Inbound = &InvalidCtxtHandle;
        SecurityData->InboundStable = TRUE;
        SecurityData->InboundChangeCount++;
        
        OutboundCtxt = SecurityData->Outbound;
        SecurityData->Outbound = &InvalidCtxtHandle;
        SecurityData->OutboundStable = TRUE;
        SecurityData->OutboundChangeCount++;
        
        LeaveCriticalSection( &SecContextLock );

        if ( InboundCtxt != &InvalidCtxtHandle ) {
            ClMsgDereferenceSecurityCtxt( InboundCtxt );
        }
    
        if ( OutboundCtxt != &InvalidCtxtHandle ) {
            ClMsgDereferenceSecurityCtxt( OutboundCtxt );
        }
    }

    return ERROR_SUCCESS;
} // s_MmRpcDeleteSecurityContext

DWORD
ClSend(
    DWORD      targetnode,
    LPCSTR     buffer,
    DWORD      length,
    DWORD      timeout
    )
{

/* This sends the given message to the designated node, and receives
   an acknowledgement from the target to confirm good receipt. This
   function blocks until the msg is delivered to the target CM.
   The target node may not be Up at the time.

   The function will fail if the message is not acknowledged by the
   target node within <timeout> ms. <timeout> = -1 implies BLOCKING.


Errors:

xxx   No path to node; node went down.

xxx   Timeout
*/

    DWORD       status=RPC_S_OK;


    ClRtlLogPrint(LOG_NOISE, 
        "[ClMsg] send to node %1!u!\n",
        targetnode
        );

    if (targetnode != NmLocalNodeId) {
        CL_ASSERT(Session[targetnode] != NULL);

        NmStartRpc(targetnode);
        status = MmRpcMsgSend(
                     Session[targetnode],
                     buffer,
                     length);
        NmEndRpc(targetnode);

        if (status != ERROR_SUCCESS) {
            if (status == RPC_S_CALL_FAILED_DNE) {
                //
                // Try again since the first call to a restarted RPC server
                // will fail.
                //
                NmStartRpc(targetnode);
                status = MmRpcMsgSend(
                             Session[targetnode],
                             buffer,
                             length
                             );
                NmEndRpc(targetnode);

                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_UNUSUAL, 
                        "[ClMsg] send failed, status %1!u!\n",
                        status
                        );
                }
            }
        }
        if(status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(status);
        }
    }
    else {
        MMDiag( (LPCSTR)buffer, sizeof(rgp_msgbuf), &length /* in/out */ );
        status = ERROR_SUCCESS;
    }

    return(status);
} // ClSend



error_status_t
s_MmRpcMsgSend(
    IN handle_t IDL_handle,
    IN const UCHAR *buffer,
    IN DWORD length
    )
/*++

Routine Description:

    Server side of the RPC interface for unacknowledge messages.

Arguments:

    IDL_handle - RPC binding handle, not used.

    buffer - Supplies a pointer to the message data.

    length - Supplies the length of the message data.

Return Value:

    ERROR_SUCCESS

--*/

{
    //
    // Dispatch the message.
    //
    MMDiag( (LPCSTR)buffer, sizeof(rgp_msgbuf), &length /* in/out */ );

    return(ERROR_SUCCESS);
} // s_MmRpcMsgSend


VOID
ClMsgBanishNode(
    IN CL_NODE_ID BanishedNodeId
    )

/*

  RPC to all the other cluster members that the specified node
  is banished. It must rejoin the cluster in order to participate
  in cluster activity

 */

{
    DWORD node;
    DWORD Status;
    node_t InternalNodeId;

    for (node = ClusterMinNodeId; node <= NmMaxNodeId; ++node ) {

        //
        // don't send this message to:
        // 1) us
        // 2) the banished node
        // 3) any other node we have marked as banished
        // 4) any node not part of the cluster
        //

        InternalNodeId = INT_NODE( node );

        if ( node != NmLocalNodeId &&
             node != BanishedNodeId &&
             !ClusterMember(
                 rgp->OS_specific_control.Banished,
                 InternalNodeId
                 ) &&
             ClusterMember( rgp->outerscreen, InternalNodeId ))
        {

            Status = MmRpcBanishNode( Session[node], BanishedNodeId );

            if( Status != ERROR_SUCCESS ) {
               ClRtlLogPrint(LOG_UNUSUAL, 
                   "[ClMsg] Node %1!u! failed request to banish node %2!u!, status %3!u!\n",
                   node, BanishedNodeId, Status
                   );
            }
        }
    }
}

error_status_t
s_MmRpcBanishNode(
    IN handle_t IDL_handle,
    IN DWORD BanishedNodeId
    )
{
    RGP_LOCK;

    if ( !ClusterMember (
             rgp->outerscreen,
             INT_NODE(BanishedNodeId) )
       )
    {
       int perturbed = rgp_is_perturbed();

       RGP_UNLOCK;

       if (perturbed) {
          ClRtlLogPrint(LOG_UNUSUAL, 
              "[MM] s_MmRpcBanishNode: %1!u!, banishing is already in progress.\n",
              BanishedNodeId
              );
       } else {
          ClRtlLogPrint(LOG_UNUSUAL, 
              "[MM] s_MmRpcBanishNode: %1!u! is already banished.\n",
              BanishedNodeId
              );
       }

       return MM_OK;
    }

    rgp_event_handler( RGP_EVT_BANISH_NODE, (node_t) BanishedNodeId );

    RGP_UNLOCK;

    return ERROR_SUCCESS;

} // s_MmRpcBanishNode

/************************************************************************
 *
 * MMiNodeDownCallback
 * ===================
 *
 * Description:
 *
 *     This Membership Manager internal routine is registered with the
 *     OS-independent portion of the regroup engine to get called when
 *     a node is declared down.  This routine will then call the "real"
 *     callback routine which was registered with the MMInit call.
 *
 * Parameters:
 *
 *     failed_nodes
 *         bitmask of the nodes that failed.
 *
 * Returns:
 *
 *   none
 *
 ************************************************************************/

void
MMiNodeDownCallback(
    IN cluster_t failed_nodes
    )
{
    BITSET bitset;
    node_t i;

    //
    // Translate cluster_t into Bitset
    // and call NodesDownCallback
    //
    BitsetInit(bitset);
    for ( i=0; i < (node_t) rgp->num_nodes; i++)
    {
        if ( ClusterMember(failed_nodes, i) ) {
           BitsetAdd(bitset, EXT_NODE(i));
        }
    }

    //
    // [Future] - Leave the binding handle in place so we can send back
    //          poison packets. Reinstate the delete when we have a
    //          real response mechanism.
    //
    // ClMsgDeleteNodeBinding(nodeId);

    if ( rgp->OS_specific_control.NodesDownCallback != RGP_NULL_PTR ) {
        (*(rgp->OS_specific_control.NodesDownCallback))( bitset );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\srgpsm.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgpsm.c - T9050 - Regroup Module state machine routines"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgpsm.c) contains regroup state machine routines.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>


/*---------- arbitration algorithm ------------ */

DWORD MmQuorumArbitrationTimeout   = CLUSTER_QUORUM_DEFAULT_ARBITRATION_TIMEOUT; // seconds
DWORD MmQuorumArbitrationEqualizer = 7;  // seconds

#define RGP_ARBITRATION_TIMEOUT             ((MmQuorumArbitrationTimeout * 100)/30) // tick == 300ms 
#define AVERAGE_ARBITRATION_TIME_IN_SECONDS (MmQuorumArbitrationEqualizer)

void enter_first_cleanup_stage();
void regroup_restart();
int ClusterEmpty(cluster_t c);

DWORD
DiskArbitrationThread(
    IN LPVOID param
    ) ;

_priv _resident static int
regroup_test_arbitrate_advance()
{
   cluster_t temp;
   int orig_numnodes    = ClusterNumMembers(rgp->rgpinfo.cluster);
   int current_numnodes = ClusterNumMembers(rgp->rgppkt.pruning_result);

   if( orig_numnodes == current_numnodes ) {
      return 1;
   }
   //
   // If somebody entered stage4 then our group owns the quorum
   //
   ClusterIntersection(
       temp,
       rgp->rgppkt.knownstage4,
       rgp->rgppkt.pruning_result
       );

   return ClusterNumMembers(temp) != 0;
}

_priv _resident static int
regroup_start_arbitrate()
{
   int orig_numnodes    = ClusterNumMembers(rgp->rgpinfo.cluster);
   int current_numnodes = ClusterNumMembers(rgp->rgppkt.pruning_result);

   if( orig_numnodes == current_numnodes ) {
      enter_first_cleanup_stage();
      return 0; // No Arbitration needed. Proceed to clean up stage //
   }
   else {
      cluster_t arbitrators;
      int       n_arbitrators;
      node_t    arbitrator;
      HANDLE    thread;
      DWORD     threadId;
      ULONG     epoch;

      RGP_LOCK;

      epoch = rgp->OS_specific_control.EventEpoch;

      if(rgp->arbitration_started) {
         RGP_UNLOCK;
         return 1; // stay in this stage for awhile
      }

      rgp->arbitration_ticks = 0;
      rgp->arbitration_started = 1;

      RGP_UNLOCK;

      ClusterIntersection(
          arbitrators,
          rgp->rgppkt.pruning_result,
          rgp->rgppkt.quorumowner
          );

      n_arbitrators = ClusterNumMembers(arbitrators);

      if(n_arbitrators == 0) {
         //
         // If there are no quorum owners in this group //
         // Let's take the guy with the lowest id       //
         //
         arbitrator = rgp_select_tiebreaker(rgp->rgppkt.pruning_result);
      } else {
         //
         // Otherwise we will take the quorum owner guy
         // with the lowest id
         //
         arbitrator = rgp_select_tiebreaker(arbitrators);

         if(n_arbitrators > 1) {
            RGP_TRACE( "RGP !!! More than one quorum owner",
                       EXT_NODE(arbitrator),                    /* TRACE */
                       GetCluster( rgp->rgpinfo.cluster ),      /* TRACE */
                       GetCluster( rgp->rgppkt.pruning_result ),/* TRACE */
                       GetCluster( rgp->rgppkt.knownstage2 ) ); /* TRACE */
            // Do we need to kill all other arbitrators?
            // No.
            // ClusterDelete(arbitrators, arbitrator);
            // ClusterUnion(
            //     rgp->poison_targets,
            //     rgp->poison_targets,
            //     arbitrators
            //     );
            // rgp_broadcast(RGP_UNACK_POISON);
         }
      }

      rgp->tiebreaker = arbitrator;

      //
      // Now we have an arbitrating node
      // We will run a thread that will run arbitration algorithm
      //

      RGP_TRACE( "RGP Arbitration Delegated to",
                 EXT_NODE(arbitrator),                    /* TRACE */
                 GetCluster( rgp->rgpinfo.cluster ),      /* TRACE */
                 GetCluster( rgp->rgppkt.pruning_result ),       /* TRACE */
                 GetCluster( rgp->rgppkt.knownstage2 ) ); /* TRACE */

      // Fix Bug #460991
      // regroup_restart on stage 4 or later will reset ArbitratingNode
      // and if all the nodes are present after restart ApproxArbitrationWinner
      // will be not set properly. Assign it here.
      rgp->OS_specific_control.ApproxArbitrationWinner =
      rgp->OS_specific_control.ArbitratingNode = (DWORD)EXT_NODE(arbitrator);
  
      if(arbitrator != rgp->mynode) {
         return 1;
      }

      thread = CreateThread( NULL, // security attributes
                             0,    // stack_size = default
                             DiskArbitrationThread,
                             ULongToPtr(epoch),
                             0,    // runs immediately
                             &threadId );
      if(thread == NULL) {
         //
         // Force Others to regroup //
         //
         RGP_LOCK;

         rgp_event_handler( RGP_EVT_BANISH_NODE, EXT_NODE(rgp->mynode) );

         RGP_UNLOCK;

         //
         // Kill this node
         //
         RGP_ERROR(RGP_ARBITRATION_FAILED);

         return FALSE;
      }

      CloseHandle(thread);
   }
   return TRUE;
}

DWORD
DiskArbitrationThread(
    IN LPVOID param
    )
{
   cluster_t current_participants;
   DWORD     status;
   int       participant_count;
   int       delay;
   ULONG_PTR startingEpoch = (ULONG_PTR) param;
   BOOL      EpochsEqual;
   int       orig_numnodes;
   int       current_numnodes;
   LONGLONG  Time1, Time2;
   
   ClusterCopy(current_participants, rgp->rgppkt.pruning_result);
   orig_numnodes = ClusterNumMembers(rgp->rgpinfo.cluster);
   current_numnodes = ClusterNumMembers(current_participants);

   RGP_LOCK;

   EpochsEqual = ( startingEpoch == rgp->OS_specific_control.EventEpoch );

   RGP_UNLOCK;

   if(!EpochsEqual)
      return 0;

   delay = (orig_numnodes+1)/2 - current_numnodes;

   if(delay < 0) delay = 0;

   Sleep(delay * 6000);

   RGP_LOCK;

   EpochsEqual = ( startingEpoch == rgp->OS_specific_control.EventEpoch );
   if (EpochsEqual) {
      rgp->OS_specific_control.ArbitrationInProgress += 1;
   }

   RGP_UNLOCK;

   if(!EpochsEqual)
      return 0;

   GetSystemTimeAsFileTime((LPFILETIME)&Time1);
   status = (*(rgp->OS_specific_control.QuorumCallback))();
   GetSystemTimeAsFileTime((LPFILETIME)&Time2);

   if (status != 0 
    && startingEpoch == rgp->OS_specific_control.EventEpoch)
   {
       // If we won the arbitration and we are in the same epoch (approx check)
       // we need to figure out whether we need to slow down a little
   
       Time2 -= Time1;

       // Convert to seconds

       Time2 = Time2 / 10 / 1000 / 1000;
       //
       // [HACKHACK] GorN Oct/30/1999
       //   We had a weird timejump in the middle of the arbitration
       //   Arbitration was completed before it started, we slept for 
       //   too long and regroup timed us out. Let's guard against it.
       //
       if ( (Time2 >= 0)
         && (Time2 < AVERAGE_ARBITRATION_TIME_IN_SECONDS) ) 
       {
       
          //
          // Don't need to be better than the average
          // If we are so fast, let's slow down
          //

          Time2 = AVERAGE_ARBITRATION_TIME_IN_SECONDS - Time2;
       
          RGP_TRACE( "RGP sleeping",
                  (ULONG)Time2,  /* TRACE */
                  0,      /* TRACE */
                  0,      /* TRACE */
                  0 );    /* TRACE */
          Sleep( (ULONG)(Time2 * 1000) );
       }
   }       
   

   RGP_LOCK;

   rgp->OS_specific_control.ArbitrationInProgress -= 1;

   EpochsEqual = ( startingEpoch == rgp->OS_specific_control.EventEpoch );

   if(!EpochsEqual) {
      RGP_UNLOCK;
      return 0;
   }

   if(status) {
      //
      // We own the quorum device
      // Let's proceed to the next stage
      //
      enter_first_cleanup_stage();
      RGP_UNLOCK;
      //
      // All the rest will see that we are in cleanup stage and
      // will proceed to it too
      //
   } else {
      //
      // Force Others to regroup //
      //
      rgp_event_handler( RGP_EVT_BANISH_NODE, EXT_NODE(rgp->mynode) );
      RGP_UNLOCK;

      //
      // Kill this node
      //
      RGP_ERROR(RGP_ARBITRATION_FAILED);
   }

   return 0;
}

/************************************************************************
 * rgp_check_packet
 * rgp_print_packet
 * =================
 *
 * Description:
 *
 *    Forward declarations of functions used in rgp_sanity_check macro
 *
 ************************************************************************/
void rgp_print_packet(rgp_pkt_t* pkt, char* label, int code);
int  rgp_check_packet(rgp_pkt_t* pkt);

/************************************************************************
 * rgp_sanity_check
 * =================
 *
 * Description:
 *
 *   This macro prints RGP packet if it has unreasonable values in
 *   powerfail, knownstages, pruning_result, and connectivity_matrix fields.
 *
 * Parameters:
 *
 *    rgp_pkt_t* pkt -
 *       packet to be checked
 *    char* label -
 *       label that will be printed together with a packet
 *
 * Returns:
 *
 *    VOID
 *
 ************************************************************************/

#define rgp_sanity_check(__pkt,__label)                    \
do {                                                       \
  int __code; __code = rgp_check_packet(__pkt);            \
  if( __code ) {rgp_print_packet(__pkt, __label, __code);} \
} while ( 0 )



/*---------------------------------------------------------------------------*/

/************************************************************************
 * split_brain_avoidance_algorithm
 * ===============================
 *
 * Description:
 *
 *    This algorithm ensures that, after a regroup incident completes,
 *    at most one group of nodes will survive regardless of connectivity
 *    failures.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value; The algorithm results in either this node
 *    halting (with the RGP_AVOID_SPLIT_BRAIN halt code) or this group
 *    being the only group that survives.
 *
 * Algorithm:
 *
 *    The algorithm is described in detail in the Sierra Tech Memo S.84,
 *    "Modifications in Regroup Algorithm for Sierra".
 *
 *    The algorithm looks at the set of nodes currently visible from the
 *    local cluster and compares it to the set of nodes alive before
 *    the regroup incident started (outerscreen). The decision to survive
 *    or halt depends on the number of nodes in the current group compared
 *    to the number of nodes in the original group.
 *
 *    Case 1:
 *       If the current group contains > half the original number, this
 *       group survives.
 *
 *    Case 2:
 *       If the current group contains < half the original number, this
 *       node (and group) halts.
 *
 *    Case 3:
 *       If the current group contains exactly half the original number AND
 *       the current group has at least two members, then this group
 *       survives if and only if it contains the tie-breaker node (selected
 *       when the cluster is formed and after each regroup incident).
 *
 *    Case 4:
 *       If the current group contains exactly half the original number AND
 *       the current group has exactly one member, then we will call the
 *               QuromSelect procedure to check if the Quorum Disk is accessible
 *               from this node. If the procedure returns value TRUE we survive;
 *               else we halt.
 *
 *
 ************************************************************************/
_priv _resident static void
split_brain_avoidance_algorithm()
{
   int orig_numnodes, current_numnodes;

   RGP_TRACE( "RGP SpltBrainAlg",
              EXT_NODE(rgp->tiebreaker),               /* TRACE */
              GetCluster( rgp->rgpinfo.cluster ),      /* TRACE */
              GetCluster( rgp->outerscreen ),          /* TRACE */
              GetCluster( rgp->rgppkt.knownstage2 ) ); /* TRACE */

   /* Sanity checks:
    * 1. The current set of nodes must be a subset of the original set
    *    of nodes.
    * 2. My node must be in the current set. This was checked
    *    when stage2 was entered. No need to check again.
    */
   if (!ClusterSubsetOf(rgp->rgpinfo.cluster, rgp->rgppkt.knownstage2))
      RGP_ERROR(RGP_INTERNAL_ERROR);

   orig_numnodes    = ClusterNumMembers(rgp->rgpinfo.cluster);
   current_numnodes = ClusterNumMembers(rgp->rgppkt.knownstage2);

   if (orig_numnodes == current_numnodes)
      /* All nodes are alive. No split brain possibility. */
      return;

   else if (orig_numnodes == 2)  /* Special 2-node case */
   {
      if ((*(rgp->OS_specific_control.QuorumCallback))())
         return; /* we have access to Quorum disk. We survive. */
      else {
#if defined( NT )
          ClusnetHalt( NmClusnetHandle );
#endif
          RGP_ERROR(RGP_AVOID_SPLIT_BRAIN);
      }
   } /* Special 2-node case */

   else /* Multi (>2) node case */
   {
      if ((current_numnodes << 1) > orig_numnodes)
         /* Our group has more than half the nodes => we are the majority.
          * We can survive. Other group(s) will kill themselves.
          */
         return;
      else if ((current_numnodes << 1) < orig_numnodes)
         /* Our group has less than half the nodes => there may be a
          * larger group alive. We must halt and allow that group to
          * survive.
          */
         RGP_ERROR(RGP_AVOID_SPLIT_BRAIN);
      else
      {
         /* Our group has exactly half the number of processors;
          * We survive if we contain the tie-breaker node and halt otherwise.
          */
         if (ClusterMember(rgp->rgppkt.knownstage2, rgp->tiebreaker))
            return;
         else
            RGP_ERROR(RGP_AVOID_SPLIT_BRAIN);
      }
   } /* Multi (>2) node case */

}


/************************************************************************
 * regroup_restart
 * ===============
 *
 * Description:
 *
 *    Starts a new regroup incident.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Sets the regroup state to RGP_ACTIVATED, pauses all IO and
 *    initializes the stage masks and connectivity matrix.
 *
 ************************************************************************/
_priv _resident static void
regroup_restart()
{
   cluster_t old_ignorescreen;
   UnpackIgnoreScreen(&rgp->rgppkt, old_ignorescreen);

   RGP_TRACE( "RGP (re)starting",
              rgp->rgppkt.seqno,                               /* TRACE */
              rgp->rgppkt.reason,                              /* TRACE */
              rgp->rgppkt.activatingnode,                      /* TRACE */
              rgp->rgppkt.causingnode );                       /* TRACE */

   RGP_TRACE( "RGP masks       ",
              RGP_MERGE_TO_32( rgp->outerscreen,               /* TRACE */
                               rgp->innerscreen ),             /* TRACE */
              RGP_MERGE_TO_32( rgp->rgppkt.knownstage1,        /* TRACE */
                               rgp->rgppkt.knownstage2 ),      /* TRACE */
              RGP_MERGE_TO_32( rgp->rgppkt.knownstage3,        /* TRACE */
                               rgp->rgppkt.knownstage4 ),      /* TRACE */
              RGP_MERGE_TO_32( rgp->rgppkt.knownstage5,        /* TRACE */
                               rgp->rgppkt.pruning_result ) ); /* TRACE */

   /* We are about to start a new pass of the regroup algorithm.
    * This does not necessarily mean we have finished the previous
    * pass; i.e., in an abort situation we may be starting over.
    * This may occur when some other node fails during the current
    * pass through the algorithm leaving us hung up at one of the
    * intermediate stages.
    */

   //
   // GN. When we do MM_LEAVE. Our state is COLDLOADED.
   //  Bailing out of regroup_restart here would prevent us from
   //  forming a regroup packet that would initate a banishing regroup incident
   //

   /* To avoid split brained nodes from corrupting data in storage
    * devices, we request the transport subsystem to hold all IO requests
    * in a queue and not transfer them over SNet. We will allow IO to
    * be resumed when regroup can guarantee that there can no longer be
    * split brains. This will be done when the final group is determined
    * and regroup enters the RGP_PHASE1_CLEANUP stage.
    */

   rgp_hold_all_io();

   /* The following is a bit of history from the NSK regroup algorithm from
    * pre-Sierra systems based on the InterProcessor Bus (IPB). Some of
    * the particulars mentioned here have changed, but the principle remains.
    *
    * Previously, we used to mark all the known stages as zero, except for
    * stage1. We used to mark only ourselves as in stage1. So, even if our
    * bus reception logic is screwed up, and we are not receiving packets
    * from anybody including ourselves, we would mark ourselves as being in
    * stage1. And after (what used to be) six ticks, we would proceed into
    * stage2 and mark ourselves as being in stage2. This would cause stage1
    * and stage2 to be equal, and our world would constitute just
    * ourselves. Thus we would go through regroup eliminating everybody
    * else. However, since we are not receiving packets from anybody else,
    * we would miss our own iamalive packets, and we too will soon die of
    * %4032. Thus the symptoms would constitute everybody else dying of
    * (%4040 + some node number), and that node dying with a %4032 halt.
    * See TPR S 88070112309628 for more details.
    *
    * To avoid this situation, we now do not mark ourselves as in a
    * particular stage until we get our own regroup packets indicating we
    * are in that stage. Thus, in regroup_restart, all the stages are
    * cleared. Previously, regroupbroadcaststatus in sendqueuedmessages
    * used to send directly from the regroup_control structures.
    * regroupbroadcaststatus has been modified to construct the unsequenced
    * packets on its stack. It would first copy the state from the
    * regroup_control structure, and then would LOR in our node into a known
    * stage, if requested to do so. When we receive that packet, we would
    * merge that information into our state, and thus we would be
    * guaranteed that our bus sending and reception logic is working, and
    * that we can legitimately mark ourselves as being in that stage. This
    * whole change avoids problems where bus sending logic works, but bus
    * reception logic is screwed up for both buses in a node.
    */

   rgp->sendstage = 0; /* Don't let anyone know I am in stage 1 until
                        * I have seen a regroup clock tick; this is to
                        * cause this node to halt if it is not getting
                        * clock ticks. I will halt when the other nodes
                        * advance without me and send me a status packet
                        * indicating this or send me a poison packet
                        * after declaring me down.
                        */


   rgp->rgpcounter = 0;
   ClusterInit(rgp->rgppkt.knownstage1);
   ClusterInit(rgp->rgppkt.knownstage2);
   ClusterInit(rgp->rgppkt.knownstage3);
   ClusterInit(rgp->rgppkt.knownstage4);
   ClusterInit(rgp->rgppkt.knownstage5);
   ClusterInit(rgp->rgppkt.pruning_result);

   MatrixInit(rgp->rgppkt.connectivity_matrix);
   MatrixInit(rgp->internal_connectivity_matrix);
   
   /* Just for ease of debugging, to send in our poison packets, we keep
    * the known nodes mask at the start of regroup. poison packets contain
    * known nodes at the beginning of regroup and at the end of it.
    */

   ClusterCopy(rgp->initnodes, rgp->rgpinfo.cluster);
   ClusterInit(rgp->endnodes);

#if defined( NT )
   //
   // increment the event epoch so we can detect stale events
   // from clusnet
   //
   ++rgp->OS_specific_control.EventEpoch;
#endif

   if ( (rgp->rgppkt.stage >= RGP_CLOSING) &&
        (rgp->rgppkt.stage <= RGP_PHASE2_CLEANUP) &&
        ClusterCompare(rgp->rgppkt.knownstage1,
                       rgp->rgppkt.knownstage2) ) 
   {
       //
       // If we were interrupted by this restart after we closed
       // 1st stage regroup window, then no nodes can be added to group w/o joining.
       //
       // Thus we will add missing nodes into our ignorescreen.
       // This will force the regroup not to wait for them in stage1
       cluster_t tmp;

       ClusterDifference(tmp, rgp->rgpinfo.cluster, rgp->innerscreen);
       ClusterUnion(rgp->ignorescreen, rgp->ignorescreen, tmp);
   }

   if ( ClusterMember(rgp->ignorescreen, rgp->mynode) ) {
       // We shouldn't have get here, but since we are here
       // Let's shield us from the outside world
       RGP_TRACE( "Self Isolation", 0, 0, 0, 0 );
       ClusterCopy(rgp->ignorescreen, rgp->rgpinfo.cluster);
       ClusterDelete(rgp->ignorescreen, rgp->mynode);
   }

   if ( !ClusterEmpty(rgp->ignorescreen) ) {
       // if we are ignoring somebody we have
       // to be cautious. I.e. we will stay longer in the
       // first stage to give a chance to everybody to learn about
       // our ignorescreen
       rgp->cautiousmode = 1;
   } 
   
   if ( !ClusterCompare(old_ignorescreen, rgp->ignorescreen) ) {
       // Ignore screen is changed, reset restart counter //
       RGP_TRACE( "Ignorescreen->", GetCluster(old_ignorescreen), GetCluster(rgp->ignorescreen), 0, 0 );
       rgp->restartcount = 0;
   }
   PackIgnoreScreen(&rgp->rgppkt, rgp->ignorescreen);

   rgp->arbitration_started = 0;

   rgp->OS_specific_control.ArbitratingNode = MM_INVALID_NODE;
   if ( !rgp_is_perturbed() ) {
       ResetEvent( rgp->OS_specific_control.Stabilized );
   }

   ClusterInit(rgp->rgppkt.quorumowner);
   if( QuorumOwner == (DWORD)EXT_NODE(rgp->mynode) ) {
      ClusterInsert(rgp->rgppkt.quorumowner, rgp->mynode);
   }


   if (rgp->rgppkt.stage == RGP_COLDLOADED)
   {
       if (!rgp->OS_specific_control.ShuttingDown) {
           //
           // Currently, RGP_RELOADFAILED calls ExitProcess
           // During clean shutdown we would like to send the regroup packet
           // out triggering a regroup. So we don't want to die.
           //
           // Since we are not resetting state to RGP_ACTIVATED, this
           // node will not be able to participate in the regroup.
           //
           RGP_ERROR(RGP_RELOADFAILED);
       }
   } else {
       rgp->rgppkt.stage = RGP_ACTIVATED;
   }

}

/************************************************************************
 * regroup_test_stage2_advance
 * ===========================
 *
 * Description:
 *
 *    Checks to see if we can advance to regroup stage 2.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    int - 1 if stage 2 can be entered and 0 if not.
 *
 * Algorithm:
 *
 *    Stage 2 can be entered if one of the following conditions is true.
 *
 *    (a) all nodes are present and accounted for and at least one
 *        regroup clock tick has occurred
 *    (b) we are not in cautious mode, all but one node are present
 *        and accounted for, AND a minimum number of ticks
 *        (rgp_quickdecisionlegit) have elapsed.
 *    (c) if RGP_MUST_ENTER_STAGE2 ticks have elapsed.
 *
 ************************************************************************/
_priv _resident static int
regroup_test_stage2_advance()
{

   cluster_t stragglers; /* set of nodes not yet checkd in */
   int num_stragglers;   /* # of nodes not yet checkd in   */

   /* Stage 2 must be entered after some interval regardless of any
    * other conditions.
    */
   if (rgp->rgpcounter == 0)
      return(0);
   if (rgp->rgpcounter >= RGP_MUST_ENTER_STAGE2)
   {
       RGP_TRACE( "RGP S->2cautious",
                  rgp->rgpcounter,                         /* TRACE */
                  rgp->cautiousmode,                       /* TRACE */
                  GetCluster( rgp->outerscreen ),          /* TRACE */
                  GetCluster( rgp->rgppkt.knownstage1 ) ); /* TRACE */
      return(1);
   }

   /* The number of ticks is between 1 and RGP_MUST_ENTER_STAGE2.
    * We need to examine the stage1 mask to decide if we can
    * advance.
    *
    * If every node in the old configuration has checked in, I can
    * advance at once. This is either a false alarm or caused by
    * power failure or connectivity failures.
    */

   /* Compute the set of nodes from the original configuration not yet
    * recognized.
    */
   ClusterDifference(stragglers, rgp->outerscreen,
                     rgp->rgppkt.knownstage1);

   //
   // We shouldn't wait for the nodes we are ignoring,
   // since we cannot get a packet from them anyway
   //
   ClusterDifference(stragglers, stragglers, 
                     rgp->ignorescreen);

   if ((num_stragglers = ClusterNumMembers(stragglers)) == 0)
   {
      RGP_TRACE( "RGP S->2 all in ",
                 rgp->rgpcounter,                        /* TRACE */
                 GetCluster( rgp->outerscreen ), 0, 0 ); /* TRACE */

      return(1);   /* all present and accounted for */
   }

   /* If stragglers is non-empty, perhaps I can still advance to stage 2
    * if I am not in cautious mode (no recent power fail and not
    * aborting and rerunning the regroup algorithm) AND all nodes but
    * one have checked in AND some minimum number of ticks have elapsed.
    *
    * The minimum number of ticks is selected to be 1 greater than the
    * the LATEPOLL inititiation period (allowed consecutive missed IamAlive time)
        * since that should guarantee that, if the
    * cluster has broken off into multiple disconnected clusters,
    * the other clusters would have detected the missing IamAlives,
    * started regroup and paused IO, thus preventing the possibility
    * of data corruption caused by a split brain situation.
    */

   if (!(rgp->cautiousmode) &&
       (num_stragglers == 1) &&
           (rgp->rgpcounter > rgp->rgpinfo.Min_Stage1_ticks))
   {
      RGP_TRACE( "RGP S->2 1 miss ",
                 rgp->rgpcounter,                            /* TRACE */
                 GetCluster( rgp->outerscreen ),             /* TRACE */
                 GetCluster( rgp->rgppkt.knownstage1 ), 0 ); /* TRACE */
      return(1);  /* advance - all but one checked in */
   }

   return(0); /* sorry cannot advance yet */

}


/************************************************************************
 * regroup_stage3_advance
 * ===========================
 *
 * Description:
 *
 *    This function is called after the split brain avoidance algorithm
 *    is run and the tie-breaker is selected in stage 2. It checks if
 *    we can proceed to stage 3 (RGP_PRUNING) and advances to stage 3
 *    if possible.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    int - 1 if the regroup stage has been advanced to RGP_PRUNING;
 *          0 if the stage cannot be advanced yet.
 *
 * Algorithm:
 *
 *    The algorithm depends on whether we are the tie-breaker or not.
 *
 *    On the tie-breaker node, we first check if there are any
 *    disconnects in the cluster. If there aren't any, there is no need
 *    for pruning. We can then set pruning_result to knownstage2,
 *    advance to the RGP_PRUNING stage and return 1. If there are
 *    disconnects, we must wait a certain number of ticks to collect
 *    connectivity info from all nodes. If the number of ticks have not
 *    passed, return 0. If the required number of ticks have elapsed,
 *    we must call the pruning algorithm to get the list of potential
 *    groups. After that, the select_cluster() routine is called to
 *    pick one from the set of possible clusters. After this is done,
 *    pruning_result is set to the selected cluster and we return 1.
 *
 *    On a non-tiebreaker node, nothing is done till a stage3 packet is
 *    received from the tie-breaker node or another node which got a
 *    stage 3 packet. If a stage 3 packet has not been received, we
 *    simply return 0. If a stage 3 packet is received, RGP_PRUNING
 *    stage is entered and we return 1.
 *
 ************************************************************************/
_priv _resident int
regroup_stage3_advance()
{
   int stage_advanced = 0, numgroups, groupnum;

   if (rgp->tiebreaker == rgp->mynode)
   {
      if (connectivity_complete(rgp->rgppkt.connectivity_matrix))
      {

         /* No disconnects. All nodes in knownstage2 survive. */
         rgp->rgppkt.stage = RGP_PRUNING;

         ClusterCopy(rgp->rgppkt.pruning_result,
                     rgp->rgppkt.knownstage2);
         stage_advanced = 1;

         RGP_TRACE( "RGP S->3 NoPrune", rgp->rgpcounter, 0, 0, 0 );
      }

      /* There are disconnects; must wait for connectivity
       * information to be complete. The info is deemed
       * complete after a fixed number of ticks have
       * elapsed.
       */

      else if (rgp->pruning_ticks >= RGP_CONNECTIVITY_TICKS)
      { /* connectivity info collection complete; enter stage 3 */

         RGP_TRACE( "RGP Con. matrix1",
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[0],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[1] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[2],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[3] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[4],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[5] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[6],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[7])); /*TRACE*/
         RGP_TRACE( "RGP Con. matrix2",
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[8],   /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[9] ), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[10],  /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[11]), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[12],  /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[13]), /*TRACE*/
              RGP_MERGE_TO_32( rgp->rgppkt.connectivity_matrix[14],  /*TRACE*/
                               rgp->rgppkt.connectivity_matrix[15]));/*TRACE*/

         numgroups = find_all_fully_connected_groups(
                        rgp->rgppkt.connectivity_matrix,
                        rgp->tiebreaker,
                        rgp->potential_groups);

         if ((void *)rgp->select_cluster == RGP_NULL_PTR)
         {
             node_t keynode;
             cluster_t temp;
             ClusterIntersection(
                 temp,
                 rgp->rgppkt.knownstage2,
                 rgp->rgppkt.quorumowner
                 );
             if ( ClusterEmpty(temp) ) {
                 keynode = RGP_NULL_NODE;
             } else {
                 keynode = rgp_select_tiebreaker(temp);
             }
             RGP_TRACE( "RGP keynode ng  ", keynode, numgroups, 0, 0); /*TRACE*/
            /* No callback specified; use regroup's own routine. */
            groupnum = rgp_select_cluster_ex(
                           rgp->potential_groups, numgroups, keynode);
         }
         else
         {
            /* Call routine specified at rgp_start() time. */
            groupnum = (*(rgp->select_cluster))(
                           rgp->potential_groups, numgroups);
         }

         if (groupnum >= 0)
            ClusterCopy(rgp->rgppkt.pruning_result,
                        rgp->potential_groups[groupnum]);
         else
            /* No group can survive. Can't halt yet.
             * Need to tell everyone else.
             */
            ClusterInit(rgp->rgppkt.pruning_result);

         rgp->rgppkt.stage = RGP_PRUNING;

         stage_advanced = 1;

         RGP_TRACE( "RGP S->3 Pruned ",
                    rgp->rgpcounter,                          /* TRACE */
                    GetCluster( rgp->rgppkt.knownstage2 ),    /* TRACE */
                    GetCluster( rgp->rgppkt.pruning_result ), /* TRACE */
                    numgroups );                              /* TRACE */

      } /* connectivity info collection complete; enter stage 3 */

   } /* tie-breaker node */

   else

   { /* not tie-breaker node */

      if (ClusterNumMembers(rgp->rgppkt.knownstage3) != 0)
      {
         /* We got a stage 3 packet from someone. Enter stage 3. */
         rgp->rgppkt.stage = RGP_PRUNING;

         stage_advanced = 1;

         RGP_TRACE( "RGP Got S3 pkt  ",
                    rgp->rgpcounter,                          /* TRACE */
                    GetCluster( rgp->rgppkt.knownstage2 ),    /* TRACE */
                    GetCluster( rgp->rgppkt.pruning_result ), /* TRACE */
                    GetCluster( rgp->rgppkt.knownstage3 ) );  /* TRACE */
      }

   } /* not tie-breaker node */

   return(stage_advanced);
}


/************************************************************************
 * enter_first_cleanup_stage
 * =========================
 *
 * Description:
 *
 *    This function performs the actions required when entering the
 *    first of the message clean up stages.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    There are many actions to be performed after the final cluster
 *    is selected. The actions are described in comments throughout
 *    this routine.
 *
 ************************************************************************/
_priv _resident void
enter_first_cleanup_stage()
{
   cluster_t banishees;
   node_t failer;

   rgp->rgppkt.stage = RGP_PHASE1_CLEANUP;

   RGP_TRACE( "RGP S->4        ", rgp->rgpcounter, 0, 0, 0 );

   /* The packets we send now will not indicate we are in the phase 1
    * cleanup stage yet. We indicate we are in this stage only after
    * we have completed the clean up action associated with the stage.
    * This is done in rgp_event_handler, under the
    * RGP_EVT_PHASE1_CLEANUP_DONE event.
    */
   rgp->sendstage = 0;

   /* Now, we can resume IO since we have passed the split brain danger.
    * New split brain situations will result in regroup restarting and
    * pausing IO again.
    */

   rgp_resume_all_io();

   /* Compute in banishees the set of nodes being lost from the old
    * configuration.
    */

   ClusterDifference(banishees, rgp->rgpinfo.cluster,
                     rgp->rgppkt.pruning_result);

   /* Install the new configuration into the masks. */

   ClusterCopy(rgp->outerscreen,     rgp->rgppkt.pruning_result);

#if defined( NT )
   ClusnetSetOuterscreen(
       NmClusnetHandle,
       (ULONG)*((PUSHORT)rgp->outerscreen)
       );
#endif

   ClusterCopy(rgp->innerscreen,     rgp->rgppkt.pruning_result);
   ClusterCopy(rgp->endnodes,        rgp->rgppkt.pruning_result);
   ClusterCopy(rgp->rgpinfo.cluster, rgp->rgppkt.pruning_result);

   /* Select a new tiebreaker because the previous one may have been    */
   /* pruned out. Note: tiebreaker_selected has already been set in S2. */
   rgp->tiebreaker =
      rgp_select_tiebreaker(rgp->rgppkt.pruning_result);
      /* F40 Bug FixID KCY0833 */

   /* Mark the state of the banishees as dead and invoke the
    * node down callback routine.
    */
   for (failer = 0; failer < (node_t) rgp->num_nodes; failer++)
      if (ClusterMember(banishees, failer)
          || rgp->node_states[failer].status == RGP_NODE_COMING_UP // fix bug#265069
          )
      {
         rgp->node_states[failer].status = RGP_NODE_DEAD;
         rgp->node_states[failer].pollstate = AWAITING_IAMALIVE;
         rgp->node_states[failer].lostHBs = 0;

#if !defined(NT)
         (*(rgp->nodedown_callback))(EXT_NODE(failer));
#else

         ClusnetSetNodeMembershipState(NmClusnetHandle,
                                       EXT_NODE( failer ),
                                       ClusnetNodeStateDead);

         //
         // On NT we do the nodedown callback at the end of stage 5.
         // This allows the cleanup phases to complete before we let
         // the "upper" layers know that a node went down.
         //
         if ( ClusterMember(rgp->OS_specific_control.CPUUPMASK,failer) )
            ClusterInsert(
                rgp->OS_specific_control.NeedsNodeDownCallback,
                failer
                );

#endif // !defined(NT)

      }

   /* If some nodes have been lost from the configuration, then I will
    * queue regroup status packets to them. This is a best efforts
    * attempt to ensure that they get quickly taken out if they
    * do in fact continue to run.
    */

   ClusterUnion(rgp->status_targets, banishees, rgp->status_targets);

   //
   // In NT, we are using rgp->rgppkt.hadpowerfail to transmit
   // quorum ownership information
   //
   #if !defined(NT)

   /* I should inform the message system of any node that experienced a
    * power on recovery. The message system can use this to clear error
    * counters so that a link will not be declared down due to errors
    * which may have been caused by the power failure.
    */

   for (failer = 0; failer < (node_t) rgp->num_nodes; failer++)
      if ((ClusterMember(rgp->rgppkt.hadpowerfail, failer)) &&
          !(ClusterMember(banishees, failer)))
         /* This survivor had a power failure. */
         rgp_had_power_failure( EXT_NODE(failer) );

   #endif // NT

   /* Tell the OS to start clean up operations for the failed nodes. */
   rgp_start_phase1_cleanup();
}


/************************************************************************
 * evaluatestageadvance
 * ====================
 *
 * Description:
 *
 *    This function evaluates whether additional state transitions are
 *    possible as a result of the info just received.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    To evaluate whether we can advance through the stages, a loop is
 *    used with a case entry for each stage. If an entry decides not to
 *    advance to the next stage, it must return from the function. If
 *    it does advance, it should not return but remain in the loop
 *    since it is possible to have cascaded stage transitions
 *    especially in a two node system. Thus, the loop is exited when no
 *    more stage transitions are possible.
 *
 ************************************************************************/
_priv _resident static void
evaluatestageadvance()
{
   cluster_t   temp_cluster;
   node_t      node;
   node_t          i;

   for (;;)  /* loop until someone exits by returning */
   {
      switch (rgp->rgppkt.stage)
      {

         case RGP_COLDLOADED :
         {
            if (!rgp->OS_specific_control.ShuttingDown) {
                RGP_ERROR(RGP_RELOADFAILED);
            }
            return;
         }


         case RGP_ACTIVATED :
         { /* evaluate whether to go to stage RGP_CLOSING */

            if (!regroup_test_stage2_advance())
               return;

            if (!ClusterMember(rgp->rgppkt.knownstage1, rgp->mynode))
               RGP_ERROR(RGP_MISSED_POLL_TO_SELF);

            rgp->rgppkt.stage = RGP_CLOSING;

            rgp->rgpcounter = 0;
            rgp->tiebreaker_selected = 0;

            /* If we abort the regroup, and there's somebody that everybody
             * banished on this regroup, the following line keeps him from
             * joining up on the next regroup.
             */
            ClusterCopy(rgp->innerscreen, rgp->rgppkt.knownstage1);

            break;

         } /* evaluate whether to go to stage RGP_CLOSING */


         case RGP_CLOSING :
         { /* evaluate whether to go to stage RGP_PRUNING */

            if (rgp->tiebreaker_selected)
            {
               if (regroup_stage3_advance())
                  break;  /* try to advance further */
               else
                  return; /* cannot advance any more */
            }

            if (!ClusterCompare(rgp->rgppkt.knownstage1,
                                rgp->rgppkt.knownstage2))
               return;

           //
           // In NT, we no longer use the split-brain avoidance algorithm.
           // We use a cluster-wide arbitration algorithm instead.
           //
           #if !defined(NT)
            /* When the known stage 1 and known stage 2 sets are the
             * same, we have the complete set of nodes that are
             * connected to us. It is time to execute the split-
             * brain avoidance algorithm. If we are a splinter group
             * cut off from the main group, we will not survive this
             * algorithm.
             */

           split_brain_avoidance_algorithm();

           #endif // NT

            /* We are the lucky survivors of the split brain avoidance
             * algorithm. Now, we must proceed to elect a new tie-breaker
             * since the current tie-breaker may no longer be with us.
             */

            rgp->tiebreaker =
               rgp_select_tiebreaker(rgp->rgppkt.knownstage2);

            rgp->tiebreaker_selected = 1;

            RGP_TRACE( "RGP S2 tiebr sel",
                       rgp->rgpcounter,               /* TRACE */
                       EXT_NODE(rgp->tiebreaker),     /* TRACE */
                       0, 0 );                        /* TRACE */

            rgp->pruning_ticks = 0;
            break;

         } /* evaluate whether to go to stage 3 */


         case RGP_PRUNING :
         { /* evaluate whether to go to RGP_PHASE1_CLEANUP stage */

            if (rgp->arbitration_started) {
               if (regroup_test_arbitrate_advance()) {
                  enter_first_cleanup_stage();
                  break;
               } else {
                  return; // Stay in this stage //
               }
            }

            if (rgp->has_unreachable_nodes)
            {
               RGP_TRACE( "RGP Unreach Node",
                  GetCluster( rgp->rgppkt.pruning_result ),     /* TRACE */
                  GetCluster( rgp->unreachable_nodes ), 0, 0 ); /* TRACE */

               /* Must check if the unreachable nodes are in the
                * selected final group. If so, we must restart
                * regroup.
                */
               ClusterIntersection(temp_cluster, rgp->unreachable_nodes,
                                   rgp->rgppkt.pruning_result);

               /* Clear the unreachable node mask and flag after examining
                * them. If we restart, we will start with a clean slate.
                */
               rgp->has_unreachable_nodes = 0;
               ClusterInit(rgp->unreachable_nodes);

               if (ClusterNumMembers(temp_cluster) != 0)
               {
                  /* We have a node unreachable event to a node
                   * selected to survive. We must regenerate
                   * the connectivity matrix and re-run the node
                   * pruning algorithm. Start a new regroup incident.
                   * All restarts are in cautious mode.
                   */
                  rgp->cautiousmode = 1;
                  rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
                  rgp->rgppkt.reason = RGP_EVT_NODE_UNREACHABLE;
                  rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);

                  /* For causingnode, pick the first unreachable node
                   * in temp_cluster.
                   */
                  for (node = 0; node < (node_t) rgp->num_nodes; node++)
                  {
                     if (ClusterMember(temp_cluster, node))
                     {
                        rgp->rgppkt.causingnode = (uint8) EXT_NODE(node);
                        break;
                     }
                  }
                  regroup_restart();
                  return;
               }
            }

            if (!ClusterCompare(rgp->rgppkt.knownstage2,
                                rgp->rgppkt.knownstage3))
               return;

            /* All nodes in the connected cluster have been notified
             * of the pruning decision (entered stage 3). If we are
             * selected to survive, we can now enter stage 4. If we are
             * not in the selected group (pruning_result), we must halt.
             * Wait for at least one node in PRUNING_RESULT to get into
             * stage 4 before halting. This ensures that the algorithm
             * does not stall in stage 3 with all pruned out nodes
             * halting before ANY of the survivors finds that all nodes
             * entered stage 3.
             */

            if (!ClusterMember(rgp->rgppkt.pruning_result, rgp->mynode))
            {
               /* Wait for at least one node in PRUNING_RESULT
                * to get into stage 4 before halting. Since only
                * nodes in PRUNING_RESULT get into stage 4, it is
                * sufficient to check if knownstage4 has any members.
                */
               if (ClusterNumMembers(rgp->rgppkt.knownstage4) != 0)
                  RGP_ERROR(RGP_PRUNED_OUT);
                           return;
            }

            // proceed to second stage of pruning - arbitration
            if( regroup_start_arbitrate() ) {
               return; // stay in this stage
            } else {
               break;  // either proceed to the next, or restart
            }

            break;

         }  /* evaluate whether to go to RGP_PHASE1_CLEANUP stage */


         case RGP_PHASE1_CLEANUP :
         { /* evaluate whether to go to RGP_PHASE2_CLEANUP stage */

            if (!ClusterCompare(rgp->rgppkt.pruning_result,
                                rgp->rgppkt.knownstage4))
               return;

            rgp->rgppkt.stage = RGP_PHASE2_CLEANUP;

            RGP_TRACE( "RGP S->5        ", rgp->rgpcounter, 0, 0, 0 );

            /* The packets we send now will not indicate we are in the phase 2
             * cleanup stage yet. We indicate we are in this stage only after
             * we have completed the clean up action associated with the stage.
             * This is done in rgp_event_handler, under the
             * RGP_EVT_PHASE2_CLEANUP_DONE event.
             */
            rgp->sendstage = 0;

            rgp_start_phase2_cleanup();

            break;

         }   /* evaluate whether to go to RGP_PHASE2_CLEANUP stage */


         case RGP_PHASE2_CLEANUP :
         { /* evaluate whether to go to RGP_STABILIZED stage */

            if (!ClusterCompare(rgp->rgppkt.knownstage4,
                                rgp->rgppkt.knownstage5))
               return;

            RGP_LOCK;

            //
            // [HACKHACK] This is not necessary anymore, since we
            // are holding the lock in message.c when delivering 
            // regroup packet received event
            //
            if (RGP_PHASE2_CLEANUP != rgp->rgppkt.stage) {
                RGP_TRACE( "RGP S->6 (race) ", rgp->rgpcounter, rgp->rgppkt.stage, 0, 0 );
                break;
            }

            rgp->rgppkt.stage             = RGP_STABILIZED;

            RGP_TRACE( "RGP S->6        ", rgp->rgpcounter, 0, 0, 0 );

            rgp->rgpcounter        = 0;
            rgp->restartcount      = 0;

            /* Reset the regroup flags which have not yet been cleared. */
            rgp->cautiousmode      = 0;

            /* Clear the mask indicating nodes which own the quorum resrc. */
            ClusterInit(rgp->rgppkt.quorumowner);

            /* Copy the sequence number into the rgpinfo area. */
            rgp->rgpinfo.seqnum = rgp->rgppkt.seqno;

            SetEvent( rgp->OS_specific_control.Stabilized );
            if (rgp->OS_specific_control.ArbitratingNode != MM_INVALID_NODE) {
                // Somebody was arbitrating //
                rgp->OS_specific_control.ApproxArbitrationWinner =
                	rgp->OS_specific_control.ArbitratingNode;
                if (rgp->OS_specific_control.ArbitratingNode == (DWORD)EXT_NODE(rgp->mynode)) {
                    //
                    // [HackHack] To close 422405
                    // when 421828 is fixed, please uncomment the following line
                    //
                    // QuorumOwner = rgp->OS_specific_control.ArbitratingNode;
                } else {
                    if (QuorumOwner != MM_INVALID_NODE) {
                        ClRtlLogPrint(LOG_UNUSUAL, 
                            "[MM] : clearing quorum owner var (winner is %1!u!), %.\n", 
                            rgp->OS_specific_control.ArbitratingNode
                            );
                    }
                    QuorumOwner = MM_INVALID_NODE;
                }
            }

            rgp_cleanup_complete();

#if defined(NT)
            //
            // On NT we deferred doing the node down callback until all the
            // cleanup phases have been complete.
            //
            ClusterCopy(
                rgp->OS_specific_control.CPUUPMASK,
                rgp->rgpinfo.cluster
                );

            (*(rgp->nodedown_callback))(
                rgp->OS_specific_control.NeedsNodeDownCallback
                );

            //
            // Clear the down node mask
            //
            ClusterInit(rgp->OS_specific_control.NeedsNodeDownCallback);

            //
            // finally, tell clusnet that regroup has finished
            //
            ClusnetRegroupFinished(NmClusnetHandle,
                                   rgp->OS_specific_control.EventEpoch,
                                   rgp->rgppkt.seqno);

            rgp->last_stable_seqno = rgp->rgppkt.seqno;
            

            RGP_UNLOCK;
#endif

            return;

         } /* evaluate whether to go to RGP_STABILIZED stage */


         case RGP_STABILIZED :
            return;            /* stabilized, so I am all done */

                 default :
            RGP_ERROR(RGP_INTERNAL_ERROR);  /* unknown stage */

      } /* switch (rgp->rgppkt.stage) */

  } /* loop until someone exits by returning */
}


/************************************************************************
 * rgp_event_handler
 * =================
 *
 * Description:
 *
 *    The state machine and the heart of the regroup algorithm.
 *
 * Parameters:
 *
 *    int event -
 *       which event happened
 *
 *    node_t causingnode -
 *       node causing the event: node which sent a regroup status
 *       packet or whose IamAlives are missed; if the causing node is
 *       not relevant information, RGP_NULL_NODE can be passed and
 *       is ignored. *This node ID is in external format.*
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    The state machine is the heart of the regroup algorithm.
 *    It is organized as a switch statement with the regroup stage as
 *    the case label and the regroup event as the switch variable.
 *    Events could cause regroup to start a new incident, to advance
 *    through stages or to update information without advancing to
 *    another stage. This routine also arranges for regroup status
 *    packets to be sent to all relevant nodes including our own
 *    node.
 *
 ************************************************************************/
_priv _resident void
RGP_EVENT_HANDLER_EX(int event, node_t causingnode, void *arg)
{

   rgp_pkt_t    *rcvd_pkt_p;
   cluster_t    ignorescreen_rcvd;
   uint8        oldstage;
   int          send_status_pkts = 0;


    /* Note: arg is only used when event == RGP_EVENT_RECEIVED_PACKET.  It is the ptr to the packet */

   /* Trace unusual invocations of this routine. */
   if  (event != RGP_EVT_RECEIVED_PACKET  &&  event != RGP_EVT_CLOCK_TICK)
	  RGP_TRACE( "RGP Event       ", event, causingnode, rgp->rgppkt.stage, rgp->rgpcounter );  /* TRACE */

   switch (event)
   {
      case RGP_EVT_NODE_UNREACHABLE :
      { /* All paths to a node are unreachable */

         /* Ignore the event if the unreachable node has been eliminated
          * from our outerscreen. The message system probably doesn't
          * know it yet.
          */
         if (ClusterMember(rgp->outerscreen, INT_NODE(causingnode)))
         {
            /* Store this event and check after node pruning (when
             * entering the RGP_PRUNING stage). If a regroup incident
             * is in progress and we haven't entered the RGP_PRUNING
             * stage yet, this will happen in the current incident.
             * If not, it will happen in the next regroup incident
             * which will surely start soon due to this disconnect.
             *
             * We do not start a regroup incident for this event. We will
             * wait for IamAlives to be missed for starting a new regroup
             * incident. This is due to the requirement that, in case
             * of a total disconnect resulting in multiple groups, we must
             * stay in stage 1 till we can guarantee that the other group(s)
             * has started regroup and paused IO. We assume that the
             * regroup incident started at the IamAlive check tick and
             * use the periodic nature of the IamAlive sends and
             * IamAlive checks to limit the stage1 pause to the period
             * of IamAlive sends (+ 1 tick to drain IO). If we started
             * a regroup incident due to the node unreachable event, we
             * have to stay in stage1 longer.
             */
            rgp->has_unreachable_nodes = 1;
            ClusterInsert(rgp->unreachable_nodes, INT_NODE(causingnode));

            break;
         }
      } /* All paths to a node are unreachable */


      case RGP_EVT_PHASE1_CLEANUP_DONE :
      {
         /* The following checks are needed in case we restarted
          * regroup and asked for phase1 cleanup multiple times.
          * We must make sure that all such requests have been
          * completed.
          */
         if ( (rgp->rgppkt.stage == RGP_PHASE1_CLEANUP) &&
              (rgp->rgp_msgsys_p->phase1_cleanup == 0) )
         { /* all caught up */

            /* Let others and ourselves get packets indicating we are in
             * this stage. When we get that packet, we will update our
             * knownstage field. If our sending or receiving apparatus
             * failed meanwhile and we don't get our own packet, it
             * will cause regroup to be restarted.
             */
            rgp->sendstage = 1;
            send_status_pkts = 1;
            evaluatestageadvance();
         } /* all caught up */

         break;
      }


      case RGP_EVT_PHASE2_CLEANUP_DONE :
      {

         /* The following checks are needed in case we restarted
          * regroup and asked for phase2 cleanup multiple times.
          * We must make sure that all such requests have been
          * completed.
          */
         if ( (rgp->rgppkt.stage == RGP_PHASE2_CLEANUP) &&
              (rgp->rgp_msgsys_p->phase2_cleanup == 0) )
         { /* all caught up */
            /* Let others and ourselves get packets indicating we are
             * in this stage.
             */
            rgp->sendstage = 1;
            send_status_pkts = 1;
            evaluatestageadvance();
         } /* all caught up */
         break;
      }


      case RGP_EVT_LATEPOLLPACKET :
      { /* some node is late with IamAlives */

         RGP_LOCK; // to ensure that the packet receive does not initiate
                           // regroup asynchronously.
                 /* Start a new regroup incident if not already active. */
         if (rgp->rgppkt.stage == RGP_STABILIZED)
         {
            rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
            rgp->rgppkt.reason = RGP_EVT_LATEPOLLPACKET;
            rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
            rgp->rgppkt.causingnode = (uint8) causingnode;
            regroup_restart();
            send_status_pkts = 1;
         } else if (rgp->rgppkt.stage == RGP_COLDLOADED)
         {
            RGP_ERROR(RGP_RELOADFAILED);
         }
         RGP_UNLOCK;
         break;
      } /* some node is late with IamAlives */

      case MM_EVT_LEAVE:
         rgp->OS_specific_control.ShuttingDown = TRUE;
      case RGP_EVT_BANISH_NODE :
      { /* assumes that the lock is held */

         rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
         rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
         // Pack Ignore Screen in the regroup_restart will
         // fill reason and causingnode fields of the packet
         ClusterInsert(rgp->ignorescreen, INT_NODE(causingnode) );
         regroup_restart();
         send_status_pkts = 1;
         break;
      }
#if 0
      case MM_EVT_LEAVE: // this node needs to leave the cluster gracefully
      {
                // Initiate a Regroup Event amongst remaining members if any
                // Start a new regroup incident if not already active.
        if (rgp->rgppkt.stage == RGP_STABILIZED)
        {
           rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
           rgp->rgppkt.reason = MM_EVT_LEAVE;
           rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
           rgp->rgppkt.causingnode = (uint8) EXT_NODE(rgp->mynode);
           regroup_restart();
           send_status_pkts = 1;
        }
        break;
      }
#endif

      case RGP_EVT_CLOCK_TICK :
      { /* called on regroup clock tick when regroup is active */

         if( (rgp->rgppkt.stage == RGP_PRUNING) &&
             (rgp->arbitration_started)
           )
         {
            rgp->arbitration_ticks++;

            if (rgp->arbitration_ticks >= RGP_ARBITRATION_TIMEOUT) {
               //
               // Kill timed-out arbitrator
               //
               if(rgp->tiebreaker == rgp->mynode) {
                  //
                  // If this node was arbitrating, then die
                  //
                  if ( IsDebuggerPresent() ) {
                     DebugBreak();
                  }

                  RGP_ERROR(RGP_ARBITRATION_STALLED);
               }
               else {
                  //
                  // Kill the arbitrator and initiate another regroup
                  //
                  RGP_TRACE(
                      "RGP arbitration stalled     ",
                      rgp->rgppkt.stage, 0, 0, 0
                      );

                  rgp_event_handler(
                      RGP_EVT_BANISH_NODE,
                      EXT_NODE(rgp->tiebreaker)
                      );

                  break;
               }
            }

            evaluatestageadvance();

            //
            // No need to send packets while we are waiting for
            // the arbitrator to win
            //
            // send_status_pkts = rgp->rgppkt.stage != RGP_PRUNING;
            //
            // [GN] Wrong. We do have to send status packets.
            // If we have partial connectivity, we need to 
            // continue exchanging packets, so that the pruner,
            // can learn indirectly that all nodes got the pruning results.
            //
            send_status_pkts = 1;

            break;
         }
         else {
            rgp->rgpcounter++;  /* increment the counter */
         }

         if ( (rgp->rgppkt.stage == RGP_ACTIVATED) && (rgp->sendstage == 0) )
         {
            /* To detect the potential failure of my timer pop mechanism
             * (such as by the corruption of the time list), I wait for
             * at least one regroup clock tick before I let myself and
             * others know I am in stage 1.
             */
            // [GorN Jan14/2000] 
            //   We don't send our connectivity information,
            //   before we get the first clock tick.
            //   However we collect this information in
            //   rgp->internal_connectivity_matrix.
            //      Let's put it in the outgoing packet
            //   so that everybody will see what we think about them.
            
            MatrixOr(rgp->rgppkt.connectivity_matrix, 
                     rgp->internal_connectivity_matrix);
                     
            rgp->sendstage = 1; /* let everyone know we are in stage 1 */
         }
         else if ( (rgp->rgppkt.stage >= RGP_CLOSING) &&
              (rgp->rgppkt.stage <= RGP_PHASE2_CLEANUP) )
         { /* check for possible abort and restart */

            if (rgp->rgpcounter >= RGP_MUST_RESTART)
            {
              /* Stalled out. Probably someone died after starting
               * or another node is still in stage 1 cautious mode
               */

               if ( ++(rgp->restartcount) > RGP_RESTART_MAX ) {
                   // It is not a good idea to die, because somebody
                   // is stalling. Let's add stallees into ignore mask and restart
                   //
                   // RGP_ERROR(RGP_INTERNAL_ERROR); // [Fixed]
                   cluster_t tmp, *stage;

                   switch (rgp->rgppkt.stage) {
                   case RGP_CLOSING: stage = &rgp->rgppkt.knownstage2; break;
                   case RGP_PRUNING: stage = &rgp->rgppkt.knownstage3; break;
                   case RGP_PHASE1_CLEANUP: stage = &rgp->rgppkt.knownstage4; break;
                   case RGP_PHASE2_CLEANUP: stage = &rgp->rgppkt.knownstage5; break;
                   }
                   ClusterDifference(tmp, rgp->rgpinfo.cluster, *stage);

                   //
                   // If we stalled during closing, due to tiebraker running
                   // the pruning algorithn going bunkers, we can have tmp = 0
                   // In this case, we need to ignore somebody to guarantee that
                   // the algorithm completes.
                   //
                   if ( ClusterEmpty(tmp) && rgp->tiebreaker_selected) {
                       ClusterInsert(tmp, rgp->tiebreaker);
                   }

                   ClusterUnion(rgp->ignorescreen, rgp->ignorescreen, tmp);
               }

               /* If we are stalling in stage 3 and we have been pruned out,
                * it is possible that we are stalling because we have been
                * isolated from all other nodes. We must halt in this case.
                */
               if ( (rgp->rgppkt.stage == RGP_PRUNING) &&
                    !ClusterMember(rgp->rgppkt.pruning_result, rgp->mynode) )
                  RGP_ERROR(RGP_PRUNED_OUT);

               rgp->cautiousmode = 1;
               rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;

               RGP_TRACE( "RGP stalled     ", rgp->rgppkt.stage, 0, 0, 0 );

               regroup_restart();

            } /* Stalled out ... */
         } /* check for possible abort and restart */

         if ((rgp->rgppkt.stage == RGP_CLOSING) && rgp->tiebreaker_selected)
            rgp->pruning_ticks++;

         evaluatestageadvance();

         send_status_pkts = 1; /* send rgp packets regardless of progress */

         break;

      } /* called on regroup clock tick when regroup is active */


      case RGP_EVT_RECEIVED_PACKET :
      { /* received an rgp packet */

         /* If the sending node is excluded by the outer screen, then it is
          * not even part of the current (most recently known) configuration.
          * Therefore the packet should not be honored, and a poison message
          * should be sent to try to kill this renegade processor.
          * That is done in the calling routine that processes all incoming
          * regroup module packets (IamAlive, regroup and poison packets).
          */

         /* If the sending node was accepted by the outer screen but then
          * excluded by the inner screen, then the packet will be disregarded
          * but no poison message sent. This phenomenon may occur when this
          * node has entered stage 2 without having heard from (recognized)
          * the sending node and then a message arrives late from that
          * sending node. In this case the fate of the sending node, i.e.
          * whether it gets ruled out of the global configuration or not is
          * unknown at this point. If the sender can get itself recognized
          * by some node before that node enters stage 2, then it will be
          * saved. Otherwise it will be declared down and subsequently shot
          * with poison packets if it ever tries to assert itself.
          */

	  /* Remember the arg to this routine is the packet pointer */
         rcvd_pkt_p = (rgp_pkt_t *)arg; /* address of pkt just received */
	     if ( rgp->rgppkt.seqno != rcvd_pkt_p->seqno)
		     RGP_TRACE( "RGP Event       ", event, causingnode, rgp->rgppkt.stage, rgp->rgpcounter );  /* TRACE */

         UnpackIgnoreScreen(rcvd_pkt_p, ignorescreen_rcvd);
         if ( !ClusterEmpty(ignorescreen_rcvd) ) {
             RGP_TRACE( "RGP Incoming pkt", GetCluster(ignorescreen_rcvd), 
                        rcvd_pkt_p->seqno, rgp->rgppkt.stage, causingnode);
         }

         if ( !ClusterMember(rgp->innerscreen, INT_NODE(causingnode))) {
             RGP_TRACE( "RGP Ignoring !inner", causingnode, rgp->rgppkt.stage, 
                        GetCluster(rgp->innerscreen), GetCluster(ignorescreen_rcvd) );
             return;
         }

         RGP_LOCK; // To ensure that the timer thread does not initiate
                   // regroup asynchronously at this time.

//////////////////////////// New Ignore Screen Stuff /////////////////////////////////         
         
         if (ClusterMember(rgp->ignorescreen, INT_NODE(causingnode) )) {
             RGP_UNLOCK;
             RGP_TRACE( "RGP Ignoring", causingnode, rgp->rgppkt.stage, 
                        GetCluster(rgp->ignorescreen), GetCluster(ignorescreen_rcvd) );
             return;
         }

         if (rcvd_pkt_p->seqno < rgp->last_stable_seqno ) {
             RGP_UNLOCK;
             RGP_TRACE( "RGP old packet", causingnode, rcvd_pkt_p->seqno, rgp->last_stable_seqno, 0);
             // This is a late packet from the previous regroup incident
             // from the node that is currently in my outerscreen. 
             // This node could not have sent it now, this is probably a packet
             // that stuck somewhere and was delieverd eons later.
             // Simply ignore it.
             return;
         }


         if ( ClusterMember(ignorescreen_rcvd, rgp->mynode ) ) {
             //
             // Sender ignores me. We will do the same to him.
             //
             ClusterInsert(rgp->ignorescreen, INT_NODE(causingnode) );
             rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
             regroup_restart();
             send_status_pkts = 1;
             RGP_UNLOCK;
             break;
         }

         if ( ClusterCompare(ignorescreen_rcvd, rgp->ignorescreen) ) {
             // We have the same ignore screen.
             // No work needs to be done
         } else if ( ClusterSubsetOf(rgp->ignorescreen, ignorescreen_rcvd) ) {
             // Incoming packet has smaller ignore screen
             // Ignore this packet, but reply to its sender with
             // our current regroup packet to force to upgrade to
             // our view of the world.
             
             // do so only if we are properly initialized
             if (rgp->rgppkt.stage == RGP_COLDLOADED && !rgp->OS_specific_control.ShuttingDown) {
                 RGP_ERROR(RGP_RELOADFAILED);
             }
         
             RGP_TRACE( "RGP smaller ignore mask ",
                        GetCluster(ignorescreen_rcvd), GetCluster(rgp->ignorescreen),   /* TRACE */
                        rgp->rgppkt.stage, rcvd_pkt_p->stage ); /* TRACE */
 
             ClusterInsert(rgp->status_targets, INT_NODE(causingnode));
             rgp_broadcast(RGP_UNACK_REGROUP);
             RGP_UNLOCK;
             return;
         } else if ( ClusterSubsetOf(ignorescreen_rcvd, rgp->ignorescreen) ) {
             RGP_TRACE( "RGP bigger ignore mask ",
                        GetCluster(ignorescreen_rcvd), GetCluster(rgp->ignorescreen),   /* TRACE */
                        rgp->rgppkt.stage, causingnode ); /* TRACE */
             // Incoming packet has bigger ignore screen.
             // Upgrade to this information and process the packet
             rgp->rgppkt.seqno = rcvd_pkt_p->seqno;
 
             /*  Somebody else activated regroup. So, let's just copy */
             /*  the sender's reason code and reason nodes.           */

             //
             // Ignore mask parts are in the reason and activatingnode fields
             //
 
             ClusterCopy(rgp->ignorescreen, ignorescreen_rcvd); // fix bug #328216
             rgp->rgppkt.reason = rcvd_pkt_p->reason;
             rgp->rgppkt.activatingnode = rcvd_pkt_p->activatingnode;
             rgp->rgppkt.causingnode = rcvd_pkt_p->causingnode;
             regroup_restart();
             send_status_pkts = 1;
         } else {
             RGP_TRACE( "RGP different ignore masks ",
                        GetCluster(ignorescreen_rcvd), GetCluster(rgp->ignorescreen),   /* TRACE */
                        rgp->rgppkt.stage, causingnode ); /* TRACE */
             // Ignore masks are different and neither of them is
             // a subset of another.
             //
             // We need to merge information out of these masks
             // and restart the regroup.
             //
             // Packet that we just received will be ignored

             ClusterUnion(rgp->ignorescreen, rgp->ignorescreen, ignorescreen_rcvd);
             rgp->rgppkt.seqno = max(rgp->rgppkt.seqno, rcvd_pkt_p->seqno) + 1;
             regroup_restart();
             send_status_pkts = 1;
             RGP_UNLOCK;
             break;
         }

//////////////////////////// End of new Ignore Screen Stuff ///////////////////////////////// 

         // Now ignorescreens of this node packet and incoming packet are the same //
         // proceed with regular regroup processing //
         
         /* Since the packet is acceptable, the regroup sequence number
          * must be compared to that of this node. If the incoming message
          * has a higher sequence number, then a new pass of the regroup
          * algorithm has started. This node must accept the new sequence
          * number, reinitialize its data, and start partcicipating in
          * the new pass. Also, the incoming message must be processed
          * since, once the algorithm reinitializes, the sequence numbers
          * now match.
          *
          * If the incoming packet has a matching sequence number, then it
          * should be accepted. The knowledge of the global state of the
          * algorithm it reflects must be merged with that already present
          * in this node. Then this node must evaluate whether further
          * state transitions are possible.
          *
          * Finally, if the incoming packet has a lower sequence number, then
          * it comes from a node unaware of the current level of the global
          * algorithm. The data in it should be ignored, but a packet should
          * be sent to it so that it will reinitialize its algorithm.
          *
          * The sequence number is a 32 bit algebraic value - hopefully it
          * will never wrap around.
          */


         if (rcvd_pkt_p->seqno < rgp->rgppkt.seqno)
         { /* sender below current level - ignore but let him know it*/

            RGP_TRACE( "RGP lower seqno ",
                       rgp->rgppkt.seqno, rcvd_pkt_p->seqno,   /* TRACE */
                       rgp->rgppkt.stage, rcvd_pkt_p->stage ); /* TRACE */

            ClusterInsert(rgp->status_targets, INT_NODE(causingnode));
            rgp_broadcast(RGP_UNACK_REGROUP);
                        RGP_UNLOCK;
            return;
         }

         if (rcvd_pkt_p->seqno > rgp->rgppkt.seqno)
         { /* sender above current level - I must upgrade to it*/

            // The node that forces a restart responsible for keeping
            // track of restarts and making a decision who will die/be ignored
            // if ( ++(rgp->restartcount) > RGP_RESTART_MAX )
            //   RGP_ERROR(RGP_INTERNAL_ERROR);

            if ( (rgp->rgppkt.stage != RGP_STABILIZED) ||
                 ((rcvd_pkt_p->seqno - rgp->rgppkt.seqno) > 1) )
            {
               RGP_TRACE( "RGP higher seqno",
                          rgp->rgppkt.seqno, rcvd_pkt_p->seqno,  /* TRACE */
                          rgp->rgppkt.stage, rcvd_pkt_p->stage );/* TRACE */
               rgp->cautiousmode = 1;
            }

            rgp->rgppkt.seqno = rcvd_pkt_p->seqno;

            /*  Somebody else activated regroup. So, let's just copy */
            /*  the sender's reason code and reason nodes.           */

            rgp->rgppkt.reason = rcvd_pkt_p->reason;
            rgp->rgppkt.activatingnode = rcvd_pkt_p->activatingnode;
            rgp->rgppkt.causingnode = rcvd_pkt_p->causingnode;
            regroup_restart();
            send_status_pkts = 1;

         } /* sender above current level - I must upgrade to it*/

         /* Now we are at the same level - even if we weren't at first.
          *
          * If the sender has already commited to a view of the world
          * that excludes me, I must halt in order to keep the system in
          * a consistent state.
          *
          * This is true even with the split brain avoidance algorithm.
          * The fact that stage1 = stage2 in the packet implies that the
          * sender has already run the split brain avoidance algorithm
          * and decided that he should survive.
          */

         if ( (rcvd_pkt_p->stage > RGP_ACTIVATED) &&
              ClusterCompare(rcvd_pkt_p->knownstage1,
                             rcvd_pkt_p->knownstage2) &&
              !ClusterMember(rcvd_pkt_p->knownstage1, rgp->mynode) )
         {
             ClusterInsert(rgp->ignorescreen, INT_NODE(causingnode) );
             rgp->rgppkt.seqno ++;
             regroup_restart();
             send_status_pkts = 1;
             RGP_UNLOCK;
//             /* I must die for overall consistency. */
//             RGP_ERROR((uint16) (RGP_PARIAH + causingnode)); // [Fixed]
             break;
         }
         RGP_UNLOCK;


         /* If I have terminated the active part of the algorithm, I
          * am in stage 6 and am not routinely broadcasting my status
          * anymore. If I get a packet from someone else who has not
          * yet terminated, then I must send him the word. But if he
          * has terminated, I must not send any packet or else there
          * will be an infinite loop of packets bouncing back and forth.
          */

         if (rgp->rgppkt.stage == RGP_STABILIZED)
         { /* I have terminated so can't learn anything more. */
            if (!ClusterCompare(rcvd_pkt_p->knownstage5,
                                rgp->rgppkt.knownstage5))
            { /* but sender has not so I must notify him */
               ClusterInsert(rgp->status_targets, INT_NODE(causingnode));
               rgp_broadcast(RGP_UNACK_REGROUP);
            }
            return;
         }

         /* At this point, the packet is from a legal node within the
          * current round of the algorithm and I have not terminated
          * at stage RGP_STABILIZED so I need to absorb whatever new
          * info is in this packet.
          *
          * The way to merge what this packet says with what I already
          * know is to just logically OR the known stage x fields
          * together.
          */
          {
              int seqno = rcvd_pkt_p->seqno&0xffff;
              int stage = rcvd_pkt_p->stage&0xffff;
              int trgs = *(int*)rgp->status_targets & 0xffff;
              int node = INT_NODE(causingnode)&0xffff;

              RGP_TRACE( "RGP recv pkt ",
                  ((seqno << 16) | stage),
                  RGP_MERGE_TO_32(
                      rcvd_pkt_p->knownstage1,
                      rcvd_pkt_p->knownstage2
                      ),
                  RGP_MERGE_TO_32(
                      rcvd_pkt_p->knownstage3,
                      rcvd_pkt_p->knownstage4
                      ),
                  (trgs << 16) | node
                  );
         }

         rgp_sanity_check(rcvd_pkt_p,  "RGP Received packet");
         rgp_sanity_check(&(rgp->rgppkt), "RGP Internal packet");

         ClusterUnion(rgp->rgppkt.quorumowner, rcvd_pkt_p->quorumowner,
                      rgp->rgppkt.quorumowner);
         ClusterUnion(rgp->rgppkt.knownstage1, rcvd_pkt_p->knownstage1,
                      rgp->rgppkt.knownstage1);
         ClusterUnion(rgp->rgppkt.knownstage2, rcvd_pkt_p->knownstage2,
                      rgp->rgppkt.knownstage2);
         ClusterUnion(rgp->rgppkt.knownstage3, rcvd_pkt_p->knownstage3,
                      rgp->rgppkt.knownstage3);
         ClusterUnion(rgp->rgppkt.knownstage4, rcvd_pkt_p->knownstage4,
                      rgp->rgppkt.knownstage4);
         ClusterUnion(rgp->rgppkt.knownstage5, rcvd_pkt_p->knownstage5,
                      rgp->rgppkt.knownstage5);
         ClusterUnion(rgp->rgppkt.pruning_result, rcvd_pkt_p->pruning_result,
                      rgp->rgppkt.pruning_result);

         /* But when I am in stage 2, it is possible that I can learn to
          * recognize some node I have not previously recognized by hearing
          * of it indirectly from some other node that I have recognized.
          * To handle this case, I always merge knownstage1 info into
          * the inner screen so that subsequent messages from the newly
          * recognized node will be accepted and processed.
          */
         if  ((rgp->rgppkt.stage == RGP_CLOSING) &&
              !(rgp->tiebreaker_selected))
            ClusterUnion(rgp->innerscreen, rgp->rgppkt.knownstage1,
                         rgp->innerscreen);

         /* In the first two stages of regroup, the inter-node connectivity
          * information is collected and propagated. When we get a regroup
          * packet, we turn ON the bit corresponding to the [our-node,
          * sender-node] entry in the connectivity matrix. We also OR in
          * the matrix sent by the sender node in the regroup packet.
          *
          * The matrix is not updated if we are in stage 1 and haven't
          * received the first clock tick. This is to prevent the
          * node pruning algorithm from considering us alive if our
          * timer mechanism is disrupted, but the IPC mechanism is OK.
          */

         /* [GorN 01/07/2000] If we are not collection connectivity information,
          * until we receive a first tick we can ran into problems if the node is
          * killed right after it send out its first timer driven packet 
          * (which doesn't have any connectivity info yet). This can cause a 
          * confusion. See bug 451792. 
          *
          * What we will do is we will collect connectivity information on
          * the side even when rgp->sendstage is FALSE and move it into the regroup
          * packet if we ever get a clock tick
          */

         if (rgp->rgppkt.stage < RGP_PRUNING && !rgp->sendstage)
         {
            MatrixSet(rgp->internal_connectivity_matrix,
                      rgp->mynode, INT_NODE(causingnode));
            if (causingnode != EXT_NODE(rgp->mynode))
               MatrixOr(rgp->internal_connectivity_matrix,
                        rcvd_pkt_p->connectivity_matrix);
         }

         if ((rgp->rgppkt.stage < RGP_PRUNING) && rgp->sendstage) 
         {
            MatrixSet(rgp->rgppkt.connectivity_matrix,
                      rgp->mynode, INT_NODE(causingnode));
            if (causingnode != EXT_NODE(rgp->mynode))
               MatrixOr(rgp->rgppkt.connectivity_matrix,
                        rcvd_pkt_p->connectivity_matrix);
         }

         /* Now, I can evaluate whether additional state transitions are
          * possible as a result of the info just received.
          */
         oldstage = rgp->rgppkt.stage;

//       QuorumCheck now runs in a separate thread
//         if (oldstage != RGP_CLOSING) // Cannot run Quorumcheck from here.
         evaluatestageadvance();

         /* To speed things up, let us broadcast our status if our
          * stage has changed and we are willing to let others and
          * ourselves see it.
          */

         if ( (oldstage != rgp->rgppkt.stage) && rgp->sendstage )
            send_status_pkts = 1; /* broadcast at once to speed things up */

         break;
      }   /* received an rgp packet */

      //
      // We do not support power failure notifications in NT
      //
      #if defined(NT)

      CL_ASSERT(event != RGP_EVT_POWERFAIL);
      //
      // Fall thru to default case
      //

      #else // NT

      case RGP_EVT_POWERFAIL :
      { /* Our node got a power up interrupt or an indication of power
         * failure from another node. */

         /* Note that this code will unconditionally abort and restart
          * the algorithm even if it was active before the power failure.
          * The new incident must be in cautious mode.
          */

         rgp->cautiousmode = 1;
         rgp->rgppkt.seqno = rgp->rgppkt.seqno + 1;
         rgp->rgppkt.reason = RGP_EVT_POWERFAIL;
         rgp->rgppkt.activatingnode = (uint8) EXT_NODE(rgp->mynode);
         rgp->rgppkt.causingnode = (uint8) causingnode;

         /* rgp->pfail_state is set to a non-zero value when a pfail event
          * is reported to regroup. It is decremented at every regroup clock
          * tick till it reaches zero. While this number is non-zero, missing
          * self IamAlives are ignored and do not cause the node to halt.
          * This gives the sending hardware some time to recover from power
          * failures before self IamAlives are checked.
          */
         if (causingnode == EXT_NODE(rgp->mynode))
            rgp->pfail_state = RGP_PFAIL_TICKS;

         /* Store the fact that causingnode experienced a PFAIL,
          * for reporting to the message system when regroup stabilizes.
          */
         ClusterInsert(rgp->rgppkt.hadpowerfail, INT_NODE(causingnode));

         regroup_restart();
         send_status_pkts = 1;
         break;
      } /* power failure */

      #endif // NT

      default :
      {
         RGP_ERROR(RGP_INTERNAL_ERROR);
      }
   }

   if (send_status_pkts) /* significant change - send status at once */
   {
      ClusterUnion(rgp->status_targets,
                   rgp->outerscreen, rgp->status_targets);
      rgp_broadcast(RGP_UNACK_REGROUP);
   }
}

/************************************************************************
 * rgp_check_packet
 * =================
 *
 * Description:
 *
 *  verifies that RGP packet has reasonable values in
 *  powerfail, knownstages, pruning_result, and connectivity_matrix fields
 *
 * Parameters:
 *
 *    rgp_pkt_t* pkt -
 *       packet to be checked
 *
 * Returns:
 *
 *    0 - packet looks good
 *    1,2,3... - strange looking packet
 *
 ************************************************************************/
int rgp_check_packet(rgp_pkt_t* pkt) {
   node_t       i;

   //
   // Verify that
   //   knownstage5 \subset knownstage4 \subset knownstage3 \subset
   //   knownstage2 \subset knownstage1 \subset rgp->rgpinfo.cluster
   //
   // int ClusterSubsetOf(cluster_t big, cluster_t small)
   //   Returns 1 if set small = set big or small is a subset of big.
   //

   if( !ClusterSubsetOf(pkt->knownstage4, pkt->knownstage5) ) {
      return 5;
   }
   if( !ClusterSubsetOf(pkt->knownstage3, pkt->knownstage4) ) {
      return 4;
   }
   if( !ClusterSubsetOf(pkt->knownstage2, pkt->knownstage3) ) {
      return 3;
   }
   if( !ClusterSubsetOf(pkt->knownstage1, pkt->knownstage2) ) {
      return 2;
   }
   if( !ClusterSubsetOf(rgp->rgpinfo.cluster, pkt->knownstage1) ) {
      return 1;
   }

   //
   // pruning_result has to be a subset of knownstage2
   //
   if( !ClusterSubsetOf(pkt->knownstage2, pkt->pruning_result) ) {
      return 9;
   }

   //
   // quorumowner has to be a subset of original cluster
   //
   if(!ClusterSubsetOf(rgp->rgpinfo.cluster, pkt->quorumowner)) {
      return 8;
   }
   //
   // Check connectivity matrix
   //
   for(i = 0; i < MAX_CLUSTER_SIZE; ++i) {
      if( ClusterMember( rgp->rgpinfo.cluster, i ) ) {
         //
         // Node i is a member of a cluster
         // Its connectivity bitmap has to be a subset of rgp->rgpinfo.cluster
         //
         if(!ClusterSubsetOf(rgp->rgpinfo.cluster, pkt->connectivity_matrix[i])) {
            return 10;
         }
      } else {
         //
         // Node i is not a member of a cluster
         // Its connectivity bitmap has to be 0
         //
         if(!ClusterEmpty(pkt->connectivity_matrix[i]))
            return 11;
      }
   }

   return 0;
}

/************************************************************************
 * rgp_print_packet
 * =================
 *
 * Description:
 *
 *    Prints RGP packet fields
 *
 * Parameters:
 *
 *    rgp_pkt_t* pkt -
 *       packet to be printed
 *    char* label -
 *       label to be printed together with a packet
 *    int code -
 *       a number to be printed together with a packet
 *
 * Returns:
 *
 *    VOID
 *
 ************************************************************************/
void rgp_print_packet(rgp_pkt_t* pkt, char* label, int code)
{
   uint8                   pktsubtype;
   uint8                   stage;
   uint16                  reason;
   uint32                  seqno;
   uint8                   activatingnode;
   uint8                   causingnode;
   cluster_t               quorumowner;

   RGP_TRACE( label,
              pkt->seqno,                               /* TRACE */
              code,
              (pkt->stage << 16) |
              (pkt->activatingnode  << 8) |
              (pkt->causingnode),                       /* TRACE */
              RGP_MERGE_TO_32( rgp->outerscreen,
                               rgp->innerscreen )
               );
   RGP_TRACE( "RGP CHK masks       ",
              RGP_MERGE_TO_32( rgp->rgpinfo.cluster,    /* TRACE */
                               pkt->quorumowner ),      /* TRACE */
              RGP_MERGE_TO_32( pkt->knownstage1,        /* TRACE */
                               pkt->knownstage2 ),      /* TRACE */
              RGP_MERGE_TO_32( pkt->knownstage3,        /* TRACE */
                               pkt->knownstage4 ),      /* TRACE */
              RGP_MERGE_TO_32( pkt->knownstage5,        /* TRACE */
                               pkt->pruning_result ) ); /* TRACE */
   RGP_TRACE( "RGP CHK Con. matrix1",
        RGP_MERGE_TO_32( pkt->connectivity_matrix[0],   /*TRACE*/
                         pkt->connectivity_matrix[1] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[2],   /*TRACE*/
                         pkt->connectivity_matrix[3] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[4],   /*TRACE*/
                         pkt->connectivity_matrix[5] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[6],   /*TRACE*/
                         pkt->connectivity_matrix[7])); /*TRACE*/
   RGP_TRACE( "RGP CHK Con. matrix2",
        RGP_MERGE_TO_32( pkt->connectivity_matrix[8],   /*TRACE*/
                         pkt->connectivity_matrix[9] ), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[10],  /*TRACE*/
                         pkt->connectivity_matrix[11]), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[12],  /*TRACE*/
                         pkt->connectivity_matrix[13]), /*TRACE*/
        RGP_MERGE_TO_32( pkt->connectivity_matrix[14],  /*TRACE*/
                         pkt->connectivity_matrix[15]));/*TRACE*/
}


/************************************************************************
 * UnpackIgnoreScreen
 * =================
 *
 * Description:
 *
 *    Extracts ignorescreen out of regroup packet
 *
 * Parameters:
 *
 *    rgp_pkt_t* from -
 *       source packet 
 *    cluster_t to -
 *       target node set
 *
 * Returns:
 *
 *    VOID
 *
 * Comments:
 *
 *   If the packet is received from NT4 node, unpacked ignorescreen
 *   will ne always 0.
 *
 ************************************************************************/
void UnpackIgnoreScreen(rgp_pkt_t* from, cluster_t to) 
{
#pragma warning( push )
#pragma warning( disable : 4244 )
    if (from->reason < RGP_EVT_IGNORE_MASK) {
        ClusterInit(to);
    } else {
        to[0] = ((uint16)from->reason) >> 8;
        to[1] = (uint8)from->causingnode;
    }
#pragma warning( pop )
}

/************************************************************************
 * rgp_print_packet
 * =================
 *
 * Description:
 *
 *    Put an ignorescreen back into a regroup packet
 *
 * Parameters:
 *
 *    rgp_pkt_t* to -
 *       packet to be updated
 *    cluster_t from -
 *       source node set
 *
 * Returns:
 *
 *    VOID
 *
 ************************************************************************/
void PackIgnoreScreen(rgp_pkt_t* to, cluster_t from)
{
    if ( ClusterEmpty(from) ) {
        to->reason &= 255;
        to->causingnode = 0;
    } else {
        to->reason = (uint8)RGP_EVT_IGNORE_MASK | (from[0] << 8);
        to->causingnode = from[1];
    }
}



/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.2*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\srgpos.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgpos.c - T9050 - OS-dependent routines for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgpos.c) contains OS-specific code used by Regroup.
 *---------------------------------------------------------------------------*/


#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>

#ifdef NSK
#include <pmsgrgp.h>
#endif /* NSK */

#if defined(NT)

DWORD
MmSetThreadPriority(
    VOID
    );

void
NT_timer_thread(
    void
    );

PWCHAR
RgpGetNodeNameFromId(
    node_t
    );

#endif // NT

/* The global pointer to regroup's internal data structure. */

#ifdef NSK
/* The global regroup pointer is #defined to a pointer in the message
 * system root structure.
 */
#endif

#if defined(LCU) || defined(UNIX) || defined(NT)
rgp_control_t *rgp = (rgp_control_t *) RGP_NULL_PTR;
DWORD  QuorumOwner = MM_INVALID_NODE; 
  /* quorum owner can be set by the forming node before rgp is initialized */
  /* Clussvc to Clusnet Heartbeating stuff. This bool would enable it. */
BOOL MmStartClussvcToClusnetHeartbeat=FALSE;  
LONG MmCheckSystemHealthTick=0;
#endif /* LCU || UNIX || NT */


#ifdef LCU

/************************************************************************
 * rgp_lcu_serv_listen
 * ===================
 *
 * Description:
 *
 *    This is an LCU-specific routine that gets called in IPC interrupt
 *    context when a datagram addressed to the Regroup Module is received.
 *
 * Parameters:
 *
 *    void     *listen_callarg  - required param, unused by regroup
 *    lcumsg_t *lcumsgp         - pointer to message
 *    uint     moredata         - required param, unused by regroup
 *
 * Returns:
 *
 *    int - Always returns ELCU_OK
 *
 * Algorithm:
 *
 *    The routine simply picks apart the arguments and calls
 *    rgp_received_packet().
 *
 *
 ************************************************************************/
_priv _resident int
rgp_lcu_serv_listen(void *listen_callarg, lcumsg_t *lcumsgp, uint moredata)
{
   /* Ignore if the packet is not from the local system. */
   if (lcumsgp->lcu_sysnum == rgp->OS_specific_control.my_sysnum)
      rgp_received_packet(lcumsgp->lcu_node,
                lcumsgp->lcu_reqmbuf.lcu_ctrlbuf,
                lcumsgp->lcu_reqmbuf.lcu_ctrllen);
   return(ELCU_OK);
}


/************************************************************************
 * rgp_lcu_event_callback
 * ======================
 *
 * Description:
 *
 *    This is an LCU-specific routine that gets called in IPC interrupt
 *    context when the LCUEV_NODE_UNREACHABLE event is generated.
 *
 * Parameters:
 *
 *    ulong      event        -  event # (= LCUEV_NODE_UNREACHABLE)
 *    sysnum_t   sysnum       -  system # (= local system #)
 *    nodenum_t  node         -  # of node that is unreachable
 *    int        event_info   -  required parameter, unused by regroup
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    The routine simply transforms the LCU event into the regroup event
 *    RGP_EVT_NODE_UNREACHABLE and calls rgp_event_handler().
 *
 ************************************************************************/
_priv _resident void
rgp_lcu_event_callback(
   ulong      event,
   sysnum_t   sysnum,
   nodenum_t  node,
   int        event_info)
{
   /* Sanity checks:
    * (1) The event must be LCUEV_NODE_UNREACHABLE, the only event
    *     we asked for.
    * (1) The event must be for the local system, the only system
    *     we asked for.
    */
   if ((event != LCUEV_NODE_UNREACHABLE) ||
       (sysnum != rgp->OS_specific_control.my_sysnum))
      RGP_ERROR(RGP_INTERNAL_ERROR);

   rgp_event_handler(RGP_EVT_NODE_UNREACHABLE, node);
}

#endif /* LCU */


/************************************************************************
 * rgp_init_OS
 * ===========
 *
 * Description:
 *
 *    This routine does OS-dependent regroup initialization such as
 *    initializing the regroup data structure lock, requesting a
 *    periodic timer to be installed and registering the callback
 *    routine for receiving regroup's unacknowledged packets.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    OS-dependent initializations.
 *
 ************************************************************************/
_priv _resident void
rgp_init_OS(void)
{

#ifdef UNIX
   struct sigaction sig_action; /* to install signals */
#endif
#ifdef LCU
   sysnum_t sysnum;
   lcumsg_t *lcumsgp;
#endif
#ifdef NT
   HANDLE       tempHandle;
   DWORD        threadID = 0;
#endif

#if defined(NSK) || defined(UNIX) || defined(NT)
   /*
    * In NSK, the regroup caller ensures that timer and IPC interrupts
    * are disabled before the regroup routines are called. Therefore,
    * there is no regroup lock initialization. Also, rather than using
    * registration of callback routines, the appropriate routine names
    * are hard coded into routines that must call them. Thus, the timer
    * routine is called from POLLINGCHECK, the periodic message system
    * routine, and the packet reception routine is called from the
    * IPC interrupt handler.
    */

   /* Initialize the unchanging fields in the rgp_msgsys struct. */

   rgp->rgp_msgsys_p->regroup_data = (void *) &(rgp->rgppkt_to_send);
   rgp->rgp_msgsys_p->regroup_datalen = RGPPKTLEN;
   rgp->rgp_msgsys_p->iamalive_data = (void *) &(rgp->iamalive_pkt);
   rgp->rgp_msgsys_p->iamalive_datalen = IAMALIVEPKTLEN;
   rgp->rgp_msgsys_p->poison_data = (void *) &(rgp->poison_pkt);
   rgp->rgp_msgsys_p->poison_datalen = POISONPKTLEN;

#endif /* NSK || UNIX || NT */

#ifdef LCU

   if (itimeout(rgp_periodic_check,
                NULL, /* parameter pointer */
                ((RGP_CLOCK_PERIOD * HZ) / 100) | TO_PERIODIC,
                plstr /* interrupt priority level */
               ) == 0)
      RGP_ERROR(RGP_INTERNAL_ERROR);
   if (lcuxprt_listen(LCU_RGP_PORT,
                      rgp_lcu_serv_listen,
                      NULL /* no call arg */,
                      NULL /* no options */
                     ) != ELCU_OK)
      RGP_ERROR(RGP_INTERNAL_ERROR);

   if (lcuxprt_config(LCU_GET_MYSYSNUM, &sysnum) != ELCU_OK)
      RGP_ERROR(RGP_INTERNAL_ERROR);
   rgp->OS_specific_control.my_sysnum = sysnum;

   /* Allocate 3 message buffers to send regroup packets, iamalive packets
    * and poison packets.
    */
   if ((lcumsgp = lcuxprt_msg_alloc(LCU_UNACKMSG, LCU_RGP_FLAGS)) == NULL)
      RGP_ERROR(RGP_INTERNAL_ERROR); /* no memory */
   rgp->OS_specific_control.lcumsg_regroup_p = lcumsgp;
   lcumsgp->lcu_tag = NULL;
   lcumsgp->lcu_sysnum = sysnum;
   lcumsgp->lcu_port = LCU_RGP_PORT;
   lcumsgp->lcu_flags = LCUMSG_CRITICAL;
   lcumsgp->lcu_reqmbuf.lcu_ctrllen = RGPPKTLEN;
   lcumsgp->lcu_reqmbuf.lcu_ctrlbuf = (char *)&(rgp->rgppkt_to_send);

   if ((lcumsgp = lcuxprt_msg_alloc(LCU_UNACKMSG, LCU_RGP_FLAGS)) == NULL)
      RGP_ERROR(RGP_INTERNAL_ERROR); /* no memory */
   rgp->OS_specific_control.lcumsg_iamalive_p = lcumsgp;
   lcumsgp->lcu_tag = NULL;
   lcumsgp->lcu_sysnum = sysnum;
   lcumsgp->lcu_port = LCU_RGP_PORT;
   lcumsgp->lcu_reqmbuf.lcu_ctrllen = IAMALIVEPKTLEN;
   lcumsgp->lcu_reqmbuf.lcu_ctrlbuf = (char *)&(rgp->iamalive_pkt);

   if ((lcumsgp = lcuxprt_msg_alloc(LCU_UNACKMSG, LCU_RGP_FLAGS)) == NULL)
      RGP_ERROR(RGP_INTERNAL_ERROR); /* no memory */
   rgp->OS_specific_control.lcumsg_poison_p = lcumsgp;
   lcumsgp->lcu_tag = NULL;
   lcumsgp->lcu_sysnum = sysnum;
   lcumsgp->lcu_port = LCU_RGP_PORT;
   lcumsgp->lcu_reqmbuf.lcu_ctrllen = POISONPKTLEN;
   lcumsgp->lcu_reqmbuf.lcu_ctrlbuf = (char *)&(rgp->poison_pkt);

   /* Register to get the LCUEV_NODE_UNREACHABLE event. */
   if (lcuxprt_events(LCU_CATCH_EVENTS, sysnum, LCUEV_NODE_UNREACHABLE,
                      rgp_lcu_event_callback) != ELCU_OK)
      RGP_ERROR(RGP_INTERNAL_ERROR);

#endif /* LCU */

#ifdef UNIX
   /* For testing on UNIX at user level, we use alarm() to simulate timer
    * ticks. */
   /* Install the alarm handler. */
   sig_action.sa_flags = 0;
   sig_action.sa_handler = alarm_handler;
   sigemptyset(&(sig_action.sa_mask));
   /* Block messages when handling timer pops. */
   sigaddset(&(sig_action.sa_mask), SIGPOLL);
   sigaction(SIGALRM, &sig_action, NULL);

   alarm_callback = rgp_periodic_check;

   /* Round up the alarm period to the next higher second. */
   alarm_period = (RGP_CLOCK_PERIOD + 99) / 100;

   /* Get first timer tick as soon as possible; subsequent ones will be
    * at alarm_period.
    */
   alarm(1);
#endif /* UNIX */

#ifdef NT
   /* On NT we create a separate thread that will be our timer. */
   /* The Timer Thread waits on TimerSignal Event to indicate an RGP rate change. */
   /* An RGP rate of 0 is a signal for the Timer Thread to exit */

   tempHandle = CreateEvent ( NULL,         /* no security */
                              FALSE,        /* Autoreset */
                              TRUE,         /* Initial State is Signalled */
                              NULL);        /* No name */
   if ( !tempHandle )
   {
           RGP_ERROR (RGP_INTERNAL_ERROR);
   }
   rgp->OS_specific_control.TimerSignal = tempHandle;
   
   tempHandle = CreateEvent ( NULL,         /* no security */
                              TRUE,         /* Manual reset */
                              TRUE,         /* Initial State is Signalled */
                              NULL);        /* No name */
   if ( !tempHandle )
   {
           RGP_ERROR (RGP_INTERNAL_ERROR);
   }
   rgp->OS_specific_control.Stabilized = tempHandle;
   rgp->OS_specific_control.ArbitrationInProgress = FALSE;
   rgp->OS_specific_control.ArbitratingNode = MM_INVALID_NODE;
   rgp->OS_specific_control.ApproxArbitrationWinner = MM_INVALID_NODE;
   rgp->OS_specific_control.ShuttingDown = FALSE;

   tempHandle = CreateThread( 0,                /* security */
                              0,                /* stack size - use same as primary thread */
                              (LPTHREAD_START_ROUTINE)NT_timer_thread,      /* starting point */
                              (VOID *) NULL,    /* no parameter */
                              0,                /* create flags - start immediately */
                              &threadID );      /* thread ID returned here */
   if ( !tempHandle )
   {
                RGP_ERROR( RGP_INTERNAL_ERROR );        /* at least for now */
   }
   rgp->OS_specific_control.TimerThread = tempHandle;
   rgp->OS_specific_control.TimerThreadId = threadID;

   rgp->OS_specific_control.UpDownCallback = RGP_NULL_PTR;
   rgp->OS_specific_control.NodesDownCallback = RGP_NULL_PTR;
   rgp->OS_specific_control.EventEpoch = 0;

#if defined TDM_DEBUG
   rgp->OS_specific_control.debug.frozen = 0;
   rgp->OS_specific_control.debug.reload_in_progress = 0;
   rgp->OS_specific_control.debug.timer_frozen = 0;
   rgp->OS_specific_control.debug.doing_tracing = 0;
   rgp->OS_specific_control.debug.MyTestPoints.TestPointWord = 0;

   // seed the random number function used in testing
   srand((unsigned) time( NULL ) );
#endif

#endif /* NT */



}

/************************************************************************
 * rgp_cleanup_OS
 * ===========
 *
 * Description:
 *
 *    This routine does OS-dependent cleanup of regroup structures
 *    and timer thread activity to ready for a new JOIN attempt.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    OS-dependent initializations.
 *
 ************************************************************************/
_priv _resident void
rgp_cleanup_OS(void)
{
#if defined (NT)
        // Tell Timer Thread to restart RGP Timer
        // a_tick might have changed.
        SetEvent( rgp->OS_specific_control.TimerSignal);
#endif // NT
}


/************************************************************************
 * rgp_update_regroup_packet
 * =========================
 *
 * Description:
 *
 *    Macro to copy the current regroup status into the regroup packet
 *    sending buffer.
 *
 * Parameters:
 *
 *    None
 *
 * Algorithm:
 *
 *    Copies the status (which is already in the form of a regroup status
 *    packet) into the packet buffer. Then, if we should let others (and
 *    ourselves) know of our stage, the current knownstage field is
 *    updated to include the local node number.
 *
 ************************************************************************/
#define rgp_update_regroup_packet                                        \
do                                                                       \
{                                                                        \
   /* Copy the regroup status to the sending packet area. */             \
   rgp->rgppkt_to_send = rgp->rgppkt;                                    \
                                                                         \
   /* If we should let others know of our stage, we must modify the      \
    * current stage mask to include ourselves.                           \
    */                                                                   \
   if (rgp->sendstage)                                                   \
      switch (rgp->rgppkt.stage)                                         \
      {                                                                  \
         case RGP_ACTIVATED:                                             \
            ClusterInsert(rgp->rgppkt_to_send.knownstage1, rgp->mynode); \
            break;                                                       \
         case RGP_CLOSING:                                               \
            ClusterInsert(rgp->rgppkt_to_send.knownstage2, rgp->mynode); \
            break;                                                       \
         case RGP_PRUNING:                                               \
            ClusterInsert(rgp->rgppkt_to_send.knownstage3, rgp->mynode); \
            break;                                                       \
         case RGP_PHASE1_CLEANUP:                                        \
            ClusterInsert(rgp->rgppkt_to_send.knownstage4, rgp->mynode); \
            break;                                                       \
         case RGP_PHASE2_CLEANUP:                                        \
            ClusterInsert(rgp->rgppkt_to_send.knownstage5, rgp->mynode); \
            break;                                                       \
         default:                                                        \
            break;                                                       \
      }                                                                  \
} while(0)


/************************************************************************
 * rgp_update_poison_packet
 * ========================
 *
 * Description:
 *
 *    Macro to copy the current regroup status into the poison packet
 *    sending buffer.
 *
 * Parameters:
 *
 *    None
 *
 * Algorithm:
 *
 *    Copies the appropriate regroup status fields into the poison
 *    packet buffer to help debugging when a dump of a poisoned
 *    node is examined.
 *
 ************************************************************************/
#define rgp_update_poison_packet                                         \
do                                                                       \
{                                                                        \
   rgp->poison_pkt.seqno = rgp->rgppkt.seqno;                            \
   rgp->poison_pkt.reason = rgp->rgppkt.reason;                          \
   rgp->poison_pkt.activatingnode = rgp->rgppkt.activatingnode;          \
   rgp->poison_pkt.causingnode = rgp->rgppkt.causingnode;                \
   ClusterCopy(rgp->poison_pkt.initnodes, rgp->initnodes);               \
   ClusterCopy(rgp->poison_pkt.endnodes, rgp->endnodes);                 \
} while(0)


/************************************************************************
 * rgp_broadcast
 * =============
 *
 * Description:
 *
 *    This routine asks the message system to broadcast an unacknowledged
 *    packet of subtype "packet_subtype" to a set of nodes indicated in
 *    an appropriate field in the rgp control struct. How the broadcast
 *    is implemented depends on the OS.
 *
 * Parameters:
 *
 *    uint8 packet_subtype - type of unsequenced packet to send
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    The same data packet is to be sent to the set of nodes indicated
 *    in the rgp control struct field. The sending can be done by queueing
 *    the packets directly to the send engine or the send can be deferred
 *    to a lower priority interrupt level. The former approach reduces
 *    the latency for sending these urgent packets while the latter
 *    approach may reduce the number of sends if several requests to
 *    send the same type of packets (this is true only of regroup
 *    packets) are made in quick succession. In this case, previous
 *    requests are overwritten by later requests. This is OK since the
 *    regroup algorithm has enough redundancy in packet sending.
 *
 *    In NSK, the message system provides a broadcast facility for
 *    unacknowledged packets. It copies regroup's packet into its own
 *    buffer and issues multiple requests to the SNet services layer.
 *    When it copies the buffer, it disables the timer and IPC
 *    interrupts ensuring that there will be no contention with Regroup.
 *    Therefore, this routine can safely update the packet area here
 *    without checking if the sending apparatus has completed sending
 *    the previous packet.
 *
 *    This is not true of LCU where the message system does not
 *    provide a broadcast facility. In LCU, the updating of the packet
 *    buffer can be done only when the send engine has completed
 *    sending. This is assured only in the send completion interrupt
 *    handler (rgp_msgsys_work).
 *
 ************************************************************************/
_priv _resident void
rgp_broadcast(uint8 packet_subtype)
{
   cluster_t temp_cluster;

   //[Raj Das] Copy the ignorescreen before sending.....
   PackIgnoreScreen(&rgp->rgppkt, rgp->ignorescreen);
   
   switch (packet_subtype)
   {
      case RGP_UNACK_REGROUP :

         /* Trace the queueing of regroup status packets. */
         RGP_TRACE( "RGP Send packets",
                    rgp->rgppkt.stage,                             /* TRACE */
                    RGP_MERGE_TO_32( rgp->status_targets,          /* TRACE */
                                     rgp->rgppkt.knownstage1 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage2,      /* TRACE */
                                     rgp->rgppkt.knownstage3 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage4,      /* TRACE */
                                     rgp->rgppkt.knownstage5 ) );  /* TRACE */

#if defined(NSK) || defined(UNIX) || defined(NT)
         /* In NSK, the packet buffer can be updated even if the send
          * engine is working on the previous send. See algorithm
          * description above.
          */

         if ((rgp->rgppkt.reason == MM_EVT_LEAVE) &&
                         (rgp->rgppkt.causingnode == rgp->mynode))
                         // If a LEAVE event is in progress exclude our node from knownstage mask
                         rgp->rgppkt_to_send = rgp->rgppkt;
                 else
                         // copy regroup packet and insert our node number into knownstage mask
                         rgp_update_regroup_packet;
#endif /* NSK || UNIX || NT */

         ClusterUnion(rgp->rgp_msgsys_p->regroup_nodes,
                      rgp->status_targets,
                      rgp->rgp_msgsys_p->regroup_nodes);

         /* Clear the targets field in the rgp_control struct after
          * copying this info. The message system must clear the target
          * bits in the common regroup/msgsys struct after sending the
          * packets.
          */
         ClusterInit(rgp->status_targets);

         rgp->rgp_msgsys_p->sendrgppkts = 1;

         break;

      case RGP_UNACK_IAMALIVE :

         /* Count number of IamAlive requests queued. */
         RGP_INCREMENT_COUNTER( QueuedIAmAlive );

         ClusterUnion(rgp->rgp_msgsys_p->iamalive_nodes,
                      rgp->rgpinfo.cluster,
                      rgp->rgp_msgsys_p->iamalive_nodes);
         rgp->rgp_msgsys_p->sendiamalives = 1;

         /* No targets field to clear in the rgp_control struct.
          * The message system must clear the target bits in the common
          * regroup/msgsys struct after sending the packets.
          */
         break;

      case RGP_UNACK_POISON :

         /* Trace the sending of poison packets. */
         RGP_TRACE( "RGP Send poison ",
                    rgp->rgppkt.stage,                             /* TRACE */
                    RGP_MERGE_TO_32( rgp->poison_targets,          /* TRACE */
                                     rgp->rgppkt.knownstage1 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage2,      /* TRACE */
                                     rgp->rgppkt.knownstage3 ),    /* TRACE */
                    RGP_MERGE_TO_32( rgp->rgppkt.knownstage4,      /* TRACE */
                                     rgp->rgppkt.knownstage5 ) );  /* TRACE */

         /* The poison packet targets must NOT be considered alive. */

         ClusterIntersection(temp_cluster, rgp->rgpinfo.cluster,
                             rgp->poison_targets);

         ClusterDifference(temp_cluster,
                           temp_cluster,
                           rgp->OS_specific_control.Banished);

         if (ClusterNumMembers(temp_cluster) != 0)
               RGP_ERROR(RGP_INTERNAL_ERROR);

#if defined(NSK) || defined(NT)
         /* In NSK, the packet buffer can be updated even if the send
          * engine is working on the previous send. See algorithm
          * description above.
          */
         rgp_update_poison_packet;
#endif /* NSK || NT */

         ClusterUnion(rgp->rgp_msgsys_p->poison_nodes,
                      rgp->poison_targets,
                      rgp->rgp_msgsys_p->poison_nodes);

         /* Clear the targets field in the rgp_control struct after
          * copying this info. The message system must clear the target
          * bits in the common regroup/msgsys struct after sending the
          * packets.
          */
         ClusterInit(rgp->poison_targets);

         rgp->rgp_msgsys_p->sendpoisons = 1;

         break;

      default :

         RGP_ERROR(RGP_INTERNAL_ERROR);
         break;
   }

   QUEUESEND; /* invoke OS-specific sending function/macro */
}


/************************************************************************
 * rgp_had_power_failure
 * =====================
 *
 * Description:
 *
 *    Tells the OS at the end of a regroup incident if a surviving node
 *    had a power failure. The message system can use this to clear all
 *    bus errors collected so far to node because node seems to have
 *    had a power failure and has now recovered from it.  Perhaps, the
 *    bus errors were due to the power failure.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls a message system routine to perform any error clearing.
 *
 ************************************************************************/
_priv _resident void
rgp_had_power_failure(node_t node)
{
   /* Currently, there is nothing to do. */
   RGP_TRACE( "RGP Power fail  ", node, 0, 0, 0);
}


/************************************************************************
 * rgp_status_of_node
 * ==================
 *
 * Description:
 *
 *    Ask the SP to return the status of a node. The SP must return the
 *    current status and not return a stale status. This routine is
 *    called by the split-brain avoidance algorithm in the two-node
 *    case, for the non-tie-breaker to get the status of the tie-breaker
 *    node.
 *
 * Parameters:
 *
 *    node_t node
 *       the node whose status is to be obtained.
 *
 * Returns:
 *
 *    int - the status code of the node returned by the SP, appropriately
 *    encoded into one of the values known to regroup.
 *
 * Algorithm:
 *
 *    Calls a millicode routine to ask the SP for the status of the node.
 *
 ************************************************************************/
_priv _resident int
rgp_status_of_node(node_t node)
{
#if defined(NT)
        /* noone home */
        return RGP_NODE_UNREACHABLE;
#else
        return _get_remote_cpu_state_( node );                                        /*F40:MB06452.1*/
#endif
}


/************************************************************************
 * rgp_newnode_online
 * ==================
 *
 * Description:
 *
 *    This routine is called if the first IamAlive is received from a
 *    newly booted node before the cluster manager gets a chance to
 *    call rgp_monitor_node(). The OS can use this routine to mark the
 *    node as up if it does not have any other means to detect that
 *    a node has come up.
 *
 * Parameters:
 *
 *    node_t node -
 *       the new node that has just been detected to be up
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    This routine marks the state of the node as up as seen by the
 *    native OS.
 *
 *    In NSK, on the reloader node, the marking of the reloadee as up
 *    is done by the message system when the initial address handshake
 *    packet is received from the reloadee. NSK does not require the
 *    regroup module to report the fact that the reloadee is online.
 *
 *    The above is probably true for LCU as well. However, the details
 *    are not yet worked out. For now, this routine is a no-op for LCU.
 *
 ************************************************************************/
_priv _resident void
rgp_newnode_online(node_t newnode)
{
   RGP_TRACE( "RGP New node up ", newnode, 0, 0, 0);
}


/************************************************************************
 * rgp_select_cluster_ex
 * =====================
 *
 * Description:
 *
 *    Given an array of cluster choices, this routine picks the best
 *    cluster to keep alive. cluster_choices[] is the array of choices
 *    and num_clusters is the number of entries in the array.
 *
 * Parameters:
 *
 *    cluster_t cluster_choices[]
 *       array of cluster choices
 *
 *    int num_clusters
 *       number of entries (choices) in the array
 *
 *    node_t key_node
 *       internal node number of the key node or RGP_NULL_NODE
 *
 * Returns:
 *
 *    int - the index of the selected cluster; if no cluster
 *    is viable, -1 is returned.
 *
 * Algorithm:
 *
 *    By default, the best cluster is defined as the largest cluster.
 *    Optionally, a node called key_node can be required to be present
 *    for a cluster to be viable. key_node can be set to RGP_NULL_NODE
 *    to imply that no specific node is required to be present.  The
 *    routine returns the index of the best cluster and -1 if none of
 *    the clusters is viable (that is, does not include the key node).
 *
 ************************************************************************/
_priv _resident int
rgp_select_cluster_ex(cluster_t cluster_choices[], int num_clusters, node_t key_node)
{

   int max_members = 0, num_members;
   int cluster_selected = -1;
   int i;

#if defined(UNIX)
   printf("rgp_select_cluster() called with %d choices:", num_clusters);
   for (i = 0; i < num_clusters; i++)
   {
      node_t j;
      printf("(");
      for (j = 0; j < (node_t) rgp->num_nodes; j++)
      {
         if (ClusterMember(cluster_choices[i], j))
            printf("%d,", EXT_NODE(j));
      }
      printf(")");
   }
   printf("\n");
   fflush(stdout);
#endif /* UNIX */

   for (i = 0; i < num_clusters; i++)
   {
      /* Skip the current cluster if a key node is defined and is not
       * in the cluster.
       */
      if ((key_node != RGP_NULL_NODE) &&
          !ClusterMember(cluster_choices[i], key_node))
         continue;

      if ((num_members = ClusterNumMembers(cluster_choices[i])) > max_members)
      {
         cluster_selected = i;
         max_members = num_members;
      }
   }

#if defined(UNIX)
   printf("Node %d: rgp_select_cluster() returned %d.\n",
          EXT_NODE(rgp->mynode), cluster_selected);
   fflush(stdout);
#endif /* UNIX */

   return (cluster_selected);
}

/************************************************************************
 * rgp_select_cluster
 * ==================
 *
 * Description:
 *
 *    Given an array of cluster choices, this routine picks the best
 *    cluster to keep alive. cluster_choices[] is the array of choices
 *    and num_clusters is the number of entries in the array.
 *
 * Parameters:
 *
 *    cluster_t cluster_choices[]
 *       array of cluster choices
 *
 *    int num_clusters
 *       number of entries (choices) in the array
 *
 * Returns:
 *
 *    int - the index of the selected cluster; if no cluster
 *    is viable, -1 is returned.
 *
 * Algorithm:
 *
 *    By default, the best cluster is defined as the largest cluster.
 *    Optionally, a node called RGP_KEY_NODE can be required to be present
 *    for a cluster to be viable. RGP_KEY_NODE can be set to RGP_NULL_NODE
 *    to imply that no specific node is required to be present.  The
 *    routine returns the index of the best cluster and -1 if none of
 *    the clusters is viable (that is, does not include the key node).
 *
 ************************************************************************/
_priv _resident int
rgp_select_cluster(cluster_t cluster_choices[], int num_clusters)
{
    node_t key_node;
    if (RGP_KEY_NODE == RGP_NULL_NODE) {
        key_node = RGP_NULL_NODE;
    } else {
        key_node = INT_NODE(RGP_KEY_NODE);
    }
    return rgp_select_cluster_ex(cluster_choices , num_clusters, key_node);
}


#ifdef LCU
/************************************************************************
 * rgp_msgsys_work
 * ===============
 *
 * Description:
 *
 *    LCU-specific routine that implements broadcasting of packets by
 *    sending them serially.
 *
 *    This routine is called from rgp_broadcast() to initiate new sends.
 *    It is also the packet send completion interrupt handler (callback
 *    routine), invoked by the LCU message system when the packet buffer
 *    can be reused.
 *
 * Parameters:
 *
 *    lcumsg_t *lcumsgp -
 *       pointer to lcu message if called from the transport's send
 *       completion interrupt handler; NULL if called from
 *       rgp_broadcast() to send a new packet.
 *
 *    int status -
 *       the message completion status if called from the transport's
 *       send completion interrupt handler; 0 if called from
 *       rgp_broadcast() to send a new packet.
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    If called from the send completion interrupt, the routine checks
 *    to see if the packet buffer needs to be refreshed. This is true
 *    if the appropriate bit in the rgp_msgsys struct is set. If so,
 *    the buffer is updated with the current info (using an update
 *    macro). This update is relevant to regroup status packets and
 *    poison packets, but not to IamAlives packets whose contents are
 *    always the same. The bit is cleared after the packet is updated.
 *
 *    Next, the routine checks if there are more destinations to send
 *    the packet to. If so, it finds the next higher numbered node to
 *    send to, issues a send and returns.
 *
 *    If invoked from rgp_broadcast() to start a new broadcast, the
 *    routine first checks to see if the previous broadcast of the
 *    same packet is complete. This is indicated by the tag field in
 *    the message struct. The tag is NULL if the broadcast has
 *    completed or has not been initiated. In this case, the tag is
 *    set to a non-NULL value and a new broadcast initiated, with
 *    this routine specified as the callback routine.
 *
 *    If the previous broadcast has not completed, nothing needs to
 *    be done. The completion interrupt will cause the buffer to be
 *    refreshed and the broadcast to be continued. The broadcast
 *    will then include new targets that may be included in this
 *    new request.
 *
 ************************************************************************/
_priv _resident void
rgp_msgsys_work(lcumsg_t *lcumsgp, int status)
{
   rgp_unseq_pkt_t   *packet;
   cluster_t         *sending_cluster;
   node_t            node;

   if (lcumsgp == NULL)
   {
      /* New work requested. Only one type of work is requested at
       * a time.
       */

      if (rgp->rgp_msgsys_p->sendrgppkts)
      {

         /* Have new regroup status packets to send. First check
          * if the last regroup status send completed. If so,
          * we can update the packet and initiate a new send.
          * If not, we must defer to the completion interrupt
          * (invocation of this routine with a non-NULL lcumsgp).
          */

         lcumsgp = rgp->OS_specific_control.lcumsg_regroup_p;
         if (lcumsgp->lcu_tag == NULL)
         {
            /* Last send completed. Initiate new send. */

            rgp_update_regroup_packet;
            rgp->rgp_msgsys_p->sendrgppkts = 0;

            for (node = 0; node < rgp->num_nodes; node++)
            {
               if (ClusterMember(rgp->rgp_msgsys_p->regroup_nodes, node))
               {
                  ClusterDelete(rgp->rgp_msgsys_p->regroup_nodes, node);
                  lcumsgp->lcu_node = node;
                  lcumsgp->lcu_tag = &(rgp->rgp_msgsys_p->regroup_nodes);
                  if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
                     ELCU_OK)
                     RGP_ERROR(RGP_INTERNAL_ERROR);
                  break; /* can send only to one node at a time */
               }
            }
         }
      }

      else if (rgp->rgp_msgsys_p->sendiamalives)
      {
         /* Need to send IamAlives again. First check if the last
          * IamAlive send completed. If so, we can initiate a new send.
          * If not, we must defer to the completion interrupt
          * (invocation of this routine with a non-NULL lcumsgp).
          */

         lcumsgp = rgp->OS_specific_control.lcumsg_iamalive_p;
         if (lcumsgp->lcu_tag == NULL)
         {
            /* Last send completed. Initiate new send. */

            rgp->rgp_msgsys_p->sendiamalives = 0;

            for (node = 0; node < rgp->num_nodes; node++)
            {
               if (ClusterMember(rgp->rgp_msgsys_p->iamalive_nodes, node))
               {
                  ClusterDelete(rgp->rgp_msgsys_p->iamalive_nodes, node);
                  lcumsgp->lcu_node = node;
                  lcumsgp->lcu_tag = &(rgp->rgp_msgsys_p->iamalive_nodes);
                  if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
                     ELCU_OK)
                     RGP_ERROR(RGP_INTERNAL_ERROR);
                  break; /* can send only to one node at a time */
               }
            }
         }
      }

      else if (rgp->rgp_msgsys_p->sendpoisons)
      {
         /* Have new poison packets to send. First check
          * if the last poison packet send completed. If so,
          * we can update the packet and initiate a new send.
          * If not, we must defer to the completion interrupt
          * (invocation of this routine with a non-NULL lcumsgp).
          */

         lcumsgp = rgp->OS_specific_control.lcumsg_poison_p;
         if (lcumsgp->lcu_tag == NULL)
         {
            /* Last send completed. Initiate new send. */

            rgp_update_poison_packet;
            rgp->rgp_msgsys_p->sendpoisons = 0;

            for (node = 0; node < rgp->num_nodes; node++)
            {
               if (ClusterMember(rgp->rgp_msgsys_p->poison_nodes, node))
               {
                  ClusterDelete(rgp->rgp_msgsys_p->poison_nodes, node);
                  lcumsgp->lcu_node = node;
                  lcumsgp->lcu_tag = &(rgp->rgp_msgsys_p->poison_nodes);
                  if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
                     ELCU_OK)
                     RGP_ERROR(RGP_INTERNAL_ERROR);
                  break; /* can send only to one node at a time */
               }
            }
         }
      }

   } /* new work */

   else
   {
      /* Send completion interrupt; continue the broadcast if
       * there are targets remaining.
       */

      RGP_LOCK;

      /* Find what type of packet completed; send the same type. */

      packet = (rgp_unseq_pkt_t *) lcumsgp->lcu_reqmbuf.lcu_ctrlbuf;

      switch (packet->pktsubtype)
      {
         case RGP_UNACK_REGROUP :

            /* Check if packet needs to be updated. */
            if (rgp->rgp_msgsys_p->sendrgppkts)
            {
               rgp_update_regroup_packet;
               rgp->rgp_msgsys_p->sendrgppkts = 0;
            }
            break;

         case RGP_UNACK_IAMALIVE :
            break;

         case RGP_UNACK_POISON :

            /* Check if packet needs to be updated. */
            if (rgp->rgp_msgsys_p->sendpoisons)
            {
               rgp_update_poison_packet;
               rgp->rgp_msgsys_p->sendpoisons = 0;
            }
            break;
      }

      /* Check if there is any more node to send the same packet
       * type to. If not, set the tag to NULL and return.
       */
      sending_cluster = (cluster_t *) (lcumsgp->lcu_tag);
      if (ClusterNumMembers(*sending_cluster) == 0)
      {
         lcumsgp->lcu_tag = NULL; /* indicate that broadcast is complete. */
         return;
      }

      /* There is at least one more node to send to. Start with
       * the node with the next higher number than the node we
       * just finished sending to.
       *
       * The loop terminates after posting a send to the next
       * node to send to. We know there is at least one such node.
       */
      for (node = lcumsgp->lcu_node + 1; node < rgp->num_nodes + 1; node++)
      {
         if (node == rgp->num_nodes)
            node = 0;  /* continue the search starting at node 0 */
         if (ClusterMember(*sending_cluster, node))
         {
            ClusterDelete(*sending_cluster, node);
            lcumsgp->lcu_node = node;
            if (lcuxprt_msg_send(lcumsgp, NULL, rgp_msgsys_work, 0) !=
               ELCU_OK)
               RGP_ERROR(RGP_INTERNAL_ERROR);
            break; /* can send only to one node at a time */
         }
      }

      RGP_UNLOCK;
   }
}
#endif /* LCU */

/*---------------------------------------------------------------------------*/

#if defined(LCU) || defined(UNIX) || defined(NT)

/*---------------------------------------------------------------------------*/
void
rgp_hold_all_io(void)
/* Simulates the TNet services routine to pause IO. */
{
#if defined (NT)
   (*(rgp->OS_specific_control.HoldIOCallback))();
#endif
   RGP_TRACE( "RGP Hold all IO ", 0, 0, 0, 0);
}
/*---------------------------------------------------------------------------*/
void
rgp_resume_all_io(void)
/* Simulates the TNet services routine to resume IO. */
{
#if defined (NT)
   (*(rgp->OS_specific_control.ResumeIOCallback))();
#endif
   RGP_TRACE( "RGP Resume IO   ", 0, 0, 0, 0);
}
/*---------------------------------------------------------------------------*/
void
RGP_ERROR_EX (uint16 halt_code, char* fname, DWORD lineno)
/* Halt node with error code. */
{
   char *halt_string;
   node_t node = RGP_NULL_NODE;
#if defined( NT )
   char halt_buffer[ 256 ];
   DWORD eventMsgId;
   BOOL skipFormatting = FALSE;

   //
   // If a user initiated a shutdown, (s)he wants to see the node
   // to go down and wait for an explicit start command.
   //
   // We map RGP_RELOADFAILED to SHUTDOWN_DURING_REGROUP_ERROR since
   // HaltCallback does a graceful stop for the latter one.
   // SCM won't restart the node after a graceful stop unless
   // it is explicitly told to do so
   //
   if (halt_code == RGP_RELOADFAILED &&
       rgp->OS_specific_control.ShuttingDown)
   {
      halt_code = RGP_SHUTDOWN_DURING_RGP;
   }
#endif

   if (halt_code == RGP_RELOADFAILED) {
      halt_string = "[RGP] Node %d: REGROUP WARNING: reload failed.";
      eventMsgId = MM_EVENT_RELOAD_FAILED;
   }
   else if (halt_code ==  RGP_INTERNAL_ERROR) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: consistency check failed in file %s, line %u.";
      eventMsgId = MM_EVENT_INTERNAL_ERROR;
      skipFormatting = TRUE;

      _snprintf(halt_buffer, sizeof( halt_buffer ) - 1,
                halt_string,
                EXT_NODE(rgp->mynode),
                fname,
                lineno);
   }
   else if (halt_code ==  RGP_MISSED_POLL_TO_SELF) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: cannot talk to self.";
      eventMsgId = NM_EVENT_MEMBERSHIP_HALT;
   }
#if !defined(NT)
   else if (halt_code ==  RGP_AVOID_SPLIT_BRAIN) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: commiting suicide to avoid split brain.";
   }
#endif
   else if (halt_code ==  RGP_PRUNED_OUT) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: pruned out due to communication failure.";
      eventMsgId = MM_EVENT_PRUNED_OUT;
   }
   else if ((halt_code >=  RGP_PARIAH_FIRST) && (halt_code <= RGP_PARIAH_LAST)) {
       halt_string = "[RGP] Node %d: REGROUP ERROR: poison packet received from node %d.";
       eventMsgId = MM_EVENT_PARIAH;
       node = (node_t)(halt_code - RGP_PARIAH);
   }
   else if (halt_code ==  RGP_ARBITRATION_FAILED) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: arbitration failed.";
      eventMsgId = MM_EVENT_ARBITRATION_FAILED;
   }
   else if (halt_code ==  RGP_ARBITRATION_STALLED) {
      halt_string = "[RGP] Node %d: REGROUP ERROR: arbitration stalled.";
      eventMsgId = MM_EVENT_ARBITRATION_STALLED;
   }
   else if (halt_code ==  RGP_SHUTDOWN_DURING_RGP) {
      halt_string = "[RGP] Node %d: REGROUP INFO: regroup engine requested immediate shutdown.";
      eventMsgId = MM_EVENT_SHUTDOWN_DURING_RGP;
   }
   else {
      halt_string = "[RGP] Node %d: REGROUP ERROR: unknown halt code (%d).";
      eventMsgId = NM_EVENT_MEMBERSHIP_HALT;
      node = halt_code;  // get it printed out by borrowing node
   }

#if defined(UNIX)
   printf(halt_string, EXT_NODE(rgp->mynode), node);
   fflush(stdout);
   /* Simulate a halt by dumping core and exiting the process. */
   abort();

#elif defined(NT)

   if ( !skipFormatting ) {
       _snprintf(halt_buffer, sizeof( halt_buffer ) - 1,
                 halt_string,
                 EXT_NODE(rgp->mynode),
                 node);
   }

#if CLUSTER_BETA
     ClRtlLogPrint(LOG_CRITICAL, "%1!hs!\t%2!hs!:%3!d!\n", halt_buffer, fname, lineno);
#else
     ClRtlLogPrint(LOG_CRITICAL, "%1!hs!\n", halt_buffer );
#endif

     if ((halt_code >=  RGP_PARIAH_FIRST) && (halt_code <= RGP_PARIAH_LAST)) {
         WCHAR  nodeString[ 16 ];
         PWCHAR nodeName;

         _snwprintf( nodeString, sizeof( nodeString ) / sizeof ( WCHAR ), L"%d", node );
         nodeName = RgpGetNodeNameFromId( node );
         CsLogEvent2( LOG_CRITICAL, eventMsgId, nodeString, nodeName );
         if ( nodeName != NULL ) {
             LocalFree( nodeName );
         }
     }
     else if ( eventMsgId == NM_EVENT_MEMBERSHIP_HALT ) {
         WCHAR  haltString[ 16 ];

         _snwprintf( haltString, sizeof( haltString ) / sizeof ( WCHAR ), L"%d", halt_code );
         CsLogEvent1( LOG_CRITICAL, eventMsgId, haltString );
     }
     else {
         CsLogEvent( LOG_CRITICAL, eventMsgId );
     }

   /* we rely on RGP_ERROR_EX to kill the node immediately 

      rgp_cleanup() can potentially slow us down.
      435977 showed that it can take upto 25 seconds, if we
      have a lot IP addr activity.

      since in the end of the function we execute HaltCallback which kills the cluster,
      we can safely omit doing rgp_cleanup and rgp_cleanup_OS

      If JoinFailedCallback will be ever enabled, the fate of rgp_cleanup and rgp_cleanup_OS
      should be reevaluated.
   */

#if 0
   rgp_cleanup();
   rgp_cleanup_OS();
   if (halt_code == RGP_RELOADFAILED)
           (*(rgp->OS_specific_control.JoinFailedCallback))();
   else
#endif
           (*(rgp->OS_specific_control.HaltCallback))(halt_code); // does not return */

#else
   cmn_err(CE_PANIC, halt_string, EXT_NODE(rgp->mynode), node);
#endif /* UNIX */
}
/*---------------------------------------------------------------------------*/
void
rgp_start_phase1_cleanup(void)
/* Tells the OS to start cleanup actions for all failed nodes. */
{
#if defined (NT)
    node_t i;
    //
    // On NT we saved the nodes to be downed bitmask in NeedsNodeDownCallback.
    //
    for ( i=0; i < (node_t) rgp->num_nodes; i++)
    {
        if ( ClusterMember( rgp->OS_specific_control.NeedsNodeDownCallback, i ) )
        {
            (*(rgp->OS_specific_control.MsgCleanup1Callback))(EXT_NODE(i));
        }
    }
#endif
   RGP_TRACE( "RGP Ph1 cleanup ", 0, 0, 0, 0);
   rgp_event_handler(RGP_EVT_PHASE1_CLEANUP_DONE, RGP_NULL_NODE);
}
/*---------------------------------------------------------------------------*/
void
rgp_start_phase2_cleanup(void)
/* The equivalent of NSK's regroupstage4action(). */
{
#if defined (NT)
    BITSET bitset;
    node_t i;
    //
    // On NT we saved the nodes to be downed bitmask in NeedsNodeDownCallback.
    //
    BitsetInit(bitset);
    for ( i=0; i < (node_t) rgp->num_nodes; i++)
    {
        if ( ClusterMember( rgp->OS_specific_control.NeedsNodeDownCallback, i ) )
        {
            BitsetAdd(bitset, EXT_NODE(i));
        }
    }

    (*(rgp->OS_specific_control.MsgCleanup2Callback))(bitset);
#endif
   RGP_TRACE( "RGP Ph2 cleanup ", 0, 0, 0, 0);
   rgp_event_handler(RGP_EVT_PHASE2_CLEANUP_DONE, RGP_NULL_NODE);
}
/*---------------------------------------------------------------------------*/
void
rgp_cleanup_complete(void)
/* The equivalent of NSK's regroupstage5action(). */
{
#if defined(NT)
#endif
   RGP_TRACE( "RGP completed   ", 0, 0, 0, 0);
}
/*---------------------------------------------------------------------------*/

#endif /* LCU || UNIX || NT */

#if defined(NT)

/************************************************************************
 * NT_timer_callback
 * =================
 *
 * Description:
 *
 *    This routine is the callback function that gets invoked whenever a
 *        timer pops.  The routine will call rgp_periodic_check.  This function
 *        is defined by the Win32 TimerProc procedure.
 *
 * Parameters:
 *
 *        See below.  We don't use any of them.
 *
 * Returns:
 *
 *    none.
 *
 * Algorithm:
 *
 *    This routine just calls rgp_periodic_check.  The existense of this
 *        routine is solely due to a fixed format callback defined by
 *        Microsoft.
 *
 ************************************************************************/
VOID CALLBACK NT_timer_callback(
        VOID
        )
{
#if defined(TDM_DEBUG)
    if ( !(rgp->OS_specific_control.debug.timer_frozen) &&
         !(rgp->OS_specific_control.debug.frozen) )
#endif
        rgp_periodic_check( );

    // Do the Clussvc to clusnet heartbeating stuff here iff enabled.
    if(MmStartClussvcToClusnetHeartbeat && (NmClusnetHandle != NULL)) {

        if (MmCheckSystemHealthTick <= 0) {
            // Reseed the tick count.
            // Mimic hardware watchdog timers and use one quarter of the timeout.
            MmCheckSystemHealthTick = ((NmClusSvcHeartbeatTimeout * 1000)/RGP_CLOCK_PERIOD)/4;

            // Send the heartbeat ioctl.
            ClusnetIamalive(NmClusnetHandle);
        }
        else {
            MmCheckSystemHealthTick--;
        }
    }

}

 /************************************************************************
 * NT_timer_thread
 * ===============
 *
 * Description:
 *
 *    This routine is executed as a separate thread in the Windows NT
 *    implementation.  This thread controls generates periodic regroup
 *    clock ticks. It is signalled via an event whenever the rate changes
 *    or to cause termination.
 *
 * Parameters:
 *
 *    None.
 *
 * Returns:
 *
 *    This thread should not go away.
 *
 * Algorithm:
 *
 *    This routine is run as a separate thread.  It sets up a timer to pop
 *        every <time_interval> * 10 milliseconds.
 *
 ************************************************************************/
void NT_timer_thread( void  )
{
    BOOL Success;
    LARGE_INTEGER DueTime;
    DWORD Error, MyHandleIndex;
    HANDLE MyHandles[2]; /* for use by WaitForMultiple */
    DWORD status;
    DWORD msDueTime;

#define MyHandleSignalIx 0
#define MyHandleTimerIx  1

    MyHandles[MyHandleSignalIx] = rgp->OS_specific_control.TimerSignal; /* Event signals HB rate change */

    rgp->OS_specific_control.RGPTimer = CreateWaitableTimer(
                                            NULL,      // no security
                                            FALSE,     // Initial State FALSE
                                            NULL
                                            );     // No name

    if (rgp->OS_specific_control.RGPTimer == NULL) {
        Error = GetLastError();
        RGP_ERROR(RGP_INTERNAL_ERROR);
    }

    status = MmSetThreadPriority();

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[MM] Unable to set timer thread priority, status %1!u!\n",
            status
            );

        RGP_ERROR((uint16) status);
        ExitThread(status);
    }

    MyHandles[MyHandleTimerIx] = rgp->OS_specific_control.RGPTimer;

    while (TRUE)
    {
        MyHandleIndex = WaitForMultipleObjects (
                            2,                /* Number of Events */
                            MyHandles,        /* Handle Array */
                            FALSE,            /* Wait for ANY event */
                            INFINITE );       /* Wait forever */

        if (MyHandleIndex == MyHandleSignalIx)  // Timer Change Signal Event
        {
            // RGP rate has changed
            CancelWaitableTimer ( rgp->OS_specific_control.RGPTimer );
            if ( rgp->rgpinfo.a_tick == 0 ) // Time to quit
            {
                CloseHandle ( rgp->OS_specific_control.RGPTimer );
                rgp->OS_specific_control.RGPTimer = 0;
                ExitThread ( 0 );
            }

            // a_tick has new RGP rate in milliseconds.
            msDueTime = rgp->rgpinfo.a_tick;
            DueTime.QuadPart = Int32x32To64(-10000, msDueTime);
            Success = SetWaitableTimer(
                          rgp->OS_specific_control.RGPTimer,
                          &DueTime,
                          rgp->rgpinfo.a_tick,
                          NULL,
                          NULL,
                          FALSE);

            if (!Success) {
                Error = GetLastError();
                RGP_ERROR(RGP_INTERNAL_ERROR);
            }

        } // Timer Change Signal
        else
        {   // RGP Timer Tick
            NT_timer_callback();

            // Removed - bug 742297. NM now has its own timer thread.
            // NmTimerTick(msDueTime);
        }
    } // while
}


PWCHAR
RgpGetNodeNameFromId(
    node_t NodeID
    )

/*++

Routine Description:

    given a node ID, issue a get name node control to get the computer name of
    the node. Returned buffer to be freed by caller.

Arguments:

    NodeID - ID ( 1, 2, 3, ..) of the node

Return Value:

    pointer to buffer containing name

--*/

{
    PWCHAR      buffer;
    DWORD       bufferSize = MAX_COMPUTERNAME_LENGTH * sizeof( WCHAR );
    DWORD       bytesReturned;
    DWORD       bytesRequired;
    PNM_NODE    node;

    buffer = LocalAlloc( LMEM_FIXED, bufferSize );
    if ( buffer != NULL ) {
        node = NmReferenceNodeById( NodeID );
        if ( node != NULL ) {
            NmNodeControl(node,
                          NULL,                     // HostNode OPTIONAL,
                          CLUSCTL_NODE_GET_NAME,
                          NULL,                     // InBuffer,
                          0,                        // InBufferSize,
                          (PUCHAR)buffer,
                          bufferSize,
                          &bytesReturned,
                          &bytesRequired);

            OmDereferenceObject( node );
        }
    }

    return buffer;
}

#endif /* NT */

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.2*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\mmapi.c ===
/* ---------------------- MMapi.c ----------------------- */

/* This module contains cluster Membership Manager (MM) functions.
 *
 * These functions are for the sole use of the ClusterManager (CM).
 * All are privileged and local; no user can call them. Security is
 * not checked.  The module is not thread-aware; only a single thread
 * can use these functions at a time. Higher levels must ensure this
 * before the calls.
 *
 *
 * All nodes of the cluster must know their own unique nodenumber
 * within that cluster (a small int in the range 1..some_max). This
 * number is defined for the node at configuration time (either by the
 * user or by the setup code; this module doesn't care which) and is
 * essentially permanent.  (The node number allows indexing and
 * bitmask operations easily, where names and non-small ints don't).
 * There is no code in MM to detect illegal use of nodenumber, staleness
 * of node number, etc.
 *
 * Clusters may also be named and/or numbered. Nodes are named. This
 * module makes no use of such facilities; it is based entirely on
 * node-number.
 *
 * It is assumed that all use of routines here is done on nodes which
 * agree to be members of the same cluster. This module does not check
 * such things.
 *
 * Cluster network connectivity must also be provided:
 *
 * - A node N must specify the various paths by which it can
 *   communicate with every other node; each other node must define
 *   its communication paths back to N. Full connectivity must be
 *   guaranteed; each node must be able to talk directly to every
 *   other node (and the reverse); for fault-tolerance, communication
 *   paths must not only be replicated (minimally, duplicated) but
 *   must also use entirely independent wiring and drivers. TCP/IP
 *   lans and async connections are suggested.  Heartbeat traffic
 *   (which establishes cluster membership) may travel on any or all
 *   of the connectivity paths.  [Cluster management traffic may
 *   travel on any or all of the connectivity paths, but may be
 *   restricted to high-performance paths (eg, tcp/ip)].
 *
 * - A node must know the address of the cluster as a whole. This is
 *   an IP address which failsover (or a netbios name which fails
 *   over.. TBD) such that connecting to that cluster address provides
 *   a way to talk to a valid active member of the cluster, here
 *   called the PCM.
 *
 * Note that cluster connectivity is not defined by this interface;
 * it is assumed to be in a separate module. This module deals only in
 * communication to the cluster or communication to a nodenumber
 * within that cluster; it does not care about the details of how such
 * communcation is done.
 *
 * Cluster connectivity must be known to all nodes in the cluster
 * and to a joining node, before the join attempt is made.
 *
 */
#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#if defined (TDM_DEBUG)
#include <mmapi.h>
#else // WOLFPACK
#include <service.h>
#endif

//#include <windows.h>
#include <wrgp.h>

#include <clmsg.h>

// #define INCONSISTENT_REGROUP_MONITOR_FAILED 
// #define INCONSISTENT_REGROUP_ADD_FAILED 
// #define INCONSISTENT_REGROUP_IGNORE_JOINER 3

void
rgp_receive_events( rgp_msgbuf *rgpbuf );

void
MMiNodeDownCallback(IN cluster_t failed_nodes);


/************************************************************************
 *
 * MMInit
 * ======
 *
 * Description:
 *
 *     This initialises various local MM data structures. It should be
 *     called at CM startup time on every node. It sends no messages; the
 *     node need not have connectivity defined yet.
 *
 * Parameters:
 *
 *     mynode -
 *         is the node# of this node within the cluster.  This is
 *         assumed to be unique (but cannot be checked here to be so).
 *
 *     UpDownCallback -
 *         a function which will be called in this Up node
 *         whenever the MM declares another node Up or Down. The CM may then
 *         initiate failovers, device ownership changes, user node status
 *         events, etc. This routine must be quick and must not block
 *         (acceptible time TBD).  Note that this will happen on all nodes
 *         of the cluster; it is up to the CM design to decide whether to
 *         issue events from only the PCM or from each CM node.
 *
 *
 *     QuorumCallback -
 *         This is a callback to deal with the special case where only
 *         2 members of the cluster existed, and a Regroup incident occurred
 *         such that only one member now survives OR there is a partition
 *         and both members survive (but cannot know that). The intent of the
 *         Quorum function is to determine whether the other node is alive
 *         or not, using mechanisms other than the normal heartbeating over
 *         the normal comm links (eg, to do so by using non-heartbeat
 *         communication paths, such as SCSI reservations). This function is
 *         called only in the case of where cluster membership was previously
 *         exactly two nodes; and is called on any surviving node of these
 *         two (which might mean it is called on one node or on both
 *         partitioned nodes).
 *
 *         If this routine returns TRUE, then the calling node stays in the
 *         cluster. If the quorum algorithm determines that this node must
 *         die (because the other cluster member exists), then this function
 *         should return FALSE;this will initiate an orderly shutdown of the
 *         cluster services.
 *
 *         In the case of a true partition, exactly one node should
 *         return TRUE.
 *
 *         This routine may block and take a long time to execute (>2 secs).
 *
 *     HoldIOCallback -
 *         This routine is called early (prior to Stage 1) in a Regroup
 *         incident. It suspends all cluster IO (to all cluster-owned
 *         devices), and any relevant intra-cluster messages, until resumed
 *         (or until this node dies).
 *
 *     ResumeIOCallback -
 *         This is called during Regroup after the new cluster membership
 *         has been determined, when it is known that this node will remain
 *         a member of the cluster (early in Stage 4). All IO previously
 *         suspended by MMHoldAllIO should be resumed.
 *
 *     MsgCleanup1Callback -
 *         This is called as the first part of intra-cluster message system
 *         cleanup (in stage 4). It cancels all incoming messages from a
 *         failed node. In the case where multiple nodes are evicted from
 *         the cluster, this function is called repeatedly, once for each node.
 *
 *         This routine is synchronous and Regroup is suspended until it
 *         returns. It must execute quickly.
 *
 *     MsgCleanup2Callback -
 *         This is the second phase of message system cleanup (in stage 5). It
 *         cancels all outgoing messages to dead nodes. Characteristics are
 *         as for Cleanup1.
 *
 *     HaltCallback -
 *         This function is called whenever the MM detects that this node
 *         should immediately leave the cluster (eg, on receipt of a poison
 *         packet or at some impossible error situation). The HALT function
 *         should immediately initiate Cluster Management shutdown. No MM
 *         functions should be called after this, other than MMShutdown.
 *
 *         The parameter "haltcode" is a number identifying the halt reason.
 *
 *     JoinFailedCallback -
 *         This is called on a node being joined into the cluster when the
 *         join attempt in the PCM fails. Following this callback, the node
 *         may petition to join again, after cleaning up via a call to
 *         MMLeave.
 *
 *
 * Returns:
 *
 *     MM_OK        Success.
 *
 *     MM_FAULT     Something impossible happened.
 *
 ************************************************************************/


DWORD MMInit(
    IN DWORD             mynode,
    IN DWORD             MaxNodes,
    IN MMNodeChange      UpDownCallback,
    IN MMQuorumSelect    QuorumCallback,
    IN MMHoldAllIO       HoldIOCallback,
    IN MMResumeAllIO     ResumeIOCallback,
    IN MMMsgCleanup1     MsgCleanup1Callback,
    IN MMMsgCleanup2     MsgCleanup2Callback,
    IN MMHalt            HaltCallback,
    IN MMJoinFailed      JoinFailedCallback,
    IN MMNodesDown       NodesDownCallback
    )
{
#if !defined (TDM_DEBUG)
    DWORD            status;
    DWORD            dwValue;
#endif
    rgp_msgsys_t    *rgp_msgsys_ptr;
    rgp_control_t   *rgp_buffer_p;
    int              rgp_buffer_len;

    //
    // allocate/clear storage for the message system area
    //
    rgp_msgsys_ptr = ( rgp_msgsys_t *) calloc(1, sizeof(rgp_msgsys_t) );
    if ( rgp_msgsys_ptr == NULL ) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] Unable to allocate msgsys_ptr.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset( rgp_msgsys_ptr, 0, sizeof(rgp_msgsys_t) );

    //
    // ask regroup how much memory it needs and then allocate/clear it.
    //
    rgp_buffer_len = rgp_estimate_memory();
    rgp_buffer_p = (rgp_control_t *) calloc( 1, rgp_buffer_len );
    if ( rgp_buffer_p == NULL ) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] Unable to allocate buffer_p.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset(rgp_buffer_p, 0, rgp_buffer_len);

    //
    // let the regroup engine allocate and initialize its data structures.
    //
    rgp_init( (node_t)mynode,
              MaxNodes,
              (void *)rgp_buffer_p,
              rgp_buffer_len,
              rgp_msgsys_ptr );

#if !defined (TDM_DEBUG)
    //
    // Initialize message system
    //
    status = ClMsgInit(mynode);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] Unable to initialize comm interface, status %1!u!.\n",
            status
            );
        return(status);
    }
#endif // TDM_DEBUG


    if( ERROR_SUCCESS == DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT,
                 &dwValue, NULL) )
    {
        MmQuorumArbitrationTimeout = dwValue;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmQuorumArbitrationTimeout %1!d!.\n", dwValue);
    }

    if( ERROR_SUCCESS == DmQueryDword(
                 DmClusterParametersKey,
                 CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER,
                 &dwValue, NULL) )
    {
        MmQuorumArbitrationEqualizer = dwValue;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmQuorumArbitrationEqualizer %1!d!.\n", dwValue);
    }

    //
    // Save the user's callback entrypoints
    //
    rgp->OS_specific_control.UpDownCallback = UpDownCallback;
    rgp->OS_specific_control.QuorumCallback = QuorumCallback;
    rgp->OS_specific_control.HoldIOCallback = HoldIOCallback;
    rgp->OS_specific_control.ResumeIOCallback = ResumeIOCallback;
    rgp->OS_specific_control.MsgCleanup1Callback = MsgCleanup1Callback;
    rgp->OS_specific_control.MsgCleanup2Callback = MsgCleanup2Callback;
    rgp->OS_specific_control.HaltCallback = HaltCallback;
    rgp->OS_specific_control.JoinFailedCallback = JoinFailedCallback;
    rgp->OS_specific_control.NodesDownCallback = NodesDownCallback;

    return MM_OK;
}

/************************************************************************
 * JoinNodeDelete
 * ==============
 *
 *
 * Internal MM procedure to assist in Join failure recovery.
 *
 *
 * Parameters:
 *
 *                              Node which failed to join.
 *
 * Returns:
 *                              none.
 *
 ************************************************************************/
void JoinNodeDelete ( joinNode)
{
    rgp_msgbuf  rgpbuf;
    node_t i;
    int status;
#if 1
    RGP_LOCK;
    rgp_event_handler( RGP_EVT_BANISH_NODE, (node_t) joinNode );
    RGP_UNLOCK;
#else
    // [HACKHACK] Remove this when you feel confident that
    // banishing is much better than the following code

    rgpbuf.event = RGP_EVT_REMOVE_NODE;
    rgpbuf.data.node = (node_t)joinNode;

    for ( i=0; i < (node_t) rgp->num_nodes; i++ )
    {
        if ( rgp->node_states[i].status == RGP_NODE_ALIVE)
        {
            if ( i == rgp->mynode )
                rgp_receive_events( &rgpbuf );    // take the quick route
            else
            {
                status = ClSend( EXT_NODE(i),
                                 (void *)&rgpbuf,
                                 sizeof(rgp_msgbuf),
                                 RGP_ACKMSG_TIMEOUT);

                if ( status ) RGP_TRACE( "ClSend failed to send Remove Node msg",
                                  rgp->rgppkt.stage,
                                  (uint32) EXT_NODE(i),
                                  (uint32) status,
                                  0 );
            }
        }
    }
#endif
}

/************************************************************************
 *
 * MMJoin
 * ======
 *
 * Description:
 *
 *     This causes the specified node to join the active cluster.
 *
 *     This routine should be issued by only one node of the cluster (the
 *     PCM); all join attempts must be single-threaded (by code outside
 *     this module).
 *
 *      [Prior to this being called:
 *         - joiningNode has communicated to the PCM of the cluster
 *           that it wants to join.
 *         - checks on validity of clustername, nodenumber, etc have been
 *           made; any security checks have been done;
 *         - connectivity paths have been established to/from the cluster
 *           and joiningNode.
 *         - the Registry etc has been downloaded.
 *      ]
 *
 * Parameters:
 *
 *     joiningNode
 *         is the node number of the node being brought into
 *         the cluster.
 *
 *         If joiningNode = self (as passed in via MMinit), then the node
 *         will become the first member of a new cluster; if not, the node
 *         will be brought into the existing cluster.
 *
 *     clockPeriod, sendRate, and rcvRate
 *         can only be set by the first call (ie
 *         when the cluster is formed); later calls (from joining members)
 *         inherit the original cluster values. The entire cluster therefore operates
 *         with the same values.
 *
 *     clockPeriod
 *         is the basic clock interval which drives all internal
 *         MM activities, such as the various stages
 *         of membership reconfiguration, and eventually user-perceived
 *         recovery time. Unit= ms. This must be between the min and max
 *         allowed (values TBD; current best setting = 300ms).  Note that
 *         clockperiod is path independent and node independent. All
 *         cluster members regroup at the same rate over any/all available
 *         paths; all periods are identical in all nodes.
 *         A value of 0 implies default setting (currently 300ms).
 *
 *     sendHBRate
 *         is the multiple of clockPeriod at which heartbeats are sent. This
 *         must be between the min and max allowed (values TBD; current best setting = 4).
 *         A value of 0 implies default setting (currently 4).
 *
 *     rcvHBRate
 *         is the multiple of sendRate during which a heartbeat must arrive, or the
 *         node initiates a Regroup (probably resulting in some node leaving the cluster).
 *         This must be between min and max; (values TBD; current best setting = 2).
 *         A value of 0 implies default setting (currently 2);
 *
 *     JoinTimeout
 *         is an overall timer in milliseconds on the entire Join attempt. If the
 *         node has not achieved full cluster membership in this time, the
 *         attempt is abandoned.
 *
 * Returns:
 *
 *     MM_OK        Success; cluster joined. The CM is then safe to
 *                  assign ownership to cluster-owned devices on this
 *                  node, and to start failover/failback processing.
 *
 *                  Note: this routine establishes cluster membership.
 *                  However, it is usually inadvisable to start high
 *                  level CM failbacks immediately, because other
 *                  cluster members are often still joining. The CM
 *                  should typically wait a while to see whether other
 *                  nodes arrive in the cluster soon.
 *
 *     MM_ALREADY   The node is already a cluster member. This can
 *                  happen if a node reboots (or a CM is restarted)
 *                  and rejoins even before the cluster determines
 *                  that it has disappeared.  The CM should Leave and
 *                  reJoin.
 *
 *     MM_FAULT     Permanent failure; something is very bad:  the
 *                  node# is duplicated; some parameter is some
 *                  entirely illegal value.  The CM is in deep weeds.
 *
 *     MM_TRANSIENT Transient failure. The cluster state changed
 *                  during the operation (eg a node left the cluster).
 *                  The operation should be retried.
 *
 *     MM_TIMEOUT   Timeout; cluster membership not achieved in time.
 *
 *
 *     more
 *      TBD
 *
 ************************************************************************/

DWORD MMJoin(
    IN DWORD  joiningNode,
    IN DWORD  clockPeriod,
    IN DWORD  sendHBRate,
    IN DWORD  rcvHBRate,
    IN DWORD  joinTimeout
           )
{
    node_t      my_reloadee_num = INT_NODE(joiningNode); // internal node #
    rgp_msgbuf  rgpbuf;                             // buffer to send messages
    node_t      i;
    rgpinfo_t   rgpinfo;
    int         status;
    BOOL        joinfailed = FALSE;
    uint32      myseqnum;

#if defined(TDM_DEBUG)
    int         randNode1,randNode2;
#endif
#if defined(INCONSISTENT_REGROUP_IGNORE_JOINER)
    extern int  IgnoreJoinerNodeUp;
#endif



    if ( my_reloadee_num >= (node_t) rgp->num_nodes )
            return MM_FAULT;

    //
    // If the caller is the joining node then we assume this is the
    // first member of the cluster.
    //
    if ( my_reloadee_num == rgp->mynode )
    {
        //
        // Set clockPeriod into the regroup information.
        //
        do {
            status = rgp_getrgpinfo( &rgpinfo );
        }
        while ( status == -1 /* regroup is perturbed */ );

        rgpinfo.a_tick = (uint16)clockPeriod;
        rgpinfo.iamalive_ticks = (uint16) sendHBRate;
        rgpinfo.check_ticks = (uint16) rcvHBRate;
        rgpinfo.Min_Stage1_ticks = (uint16) (sendHBRate * rcvHBRate);

        if ( rgp_setrgpinfo( &rgpinfo ) == -1 )
            RGP_ERROR( RGP_INTERNAL_ERROR );        // for now??

        //
        // Regroup can now start monitoring
        //
        rgp_start( MMiNodeDownCallback, RGP_NULL_PTR );
        MmSetRegroupAllowed(TRUE);

        return MM_OK;
    }

    //
    // Not the first system up.
    //
    if ( (rgp->node_states[my_reloadee_num].status == RGP_NODE_ALIVE) ||
         (rgp->node_states[my_reloadee_num].status == RGP_NODE_COMING_UP)
       )
       return MM_ALREADY;

    RGP_LOCK;
    myseqnum = rgp->rgppkt.seqno; // save rgp seq number to check for new rgp incident
    //
    // If regroup is perturbed wait until it stablizes.
    //

    while ( rgp_is_perturbed() )
    {
        RGP_UNLOCK;
        Sleep( 1 );             // wait a millisecond

        if ( --joinTimeout <= 0 )
            return MM_TIMEOUT;

        RGP_LOCK;
        myseqnum = rgp->rgppkt.seqno;
    }
    RGP_UNLOCK;


    //
    // First, we must tell all running nodes about the reloadee.
    //

    rgpbuf.event = RGP_EVT_ADD_NODE;
    rgpbuf.data.node = (node_t)joiningNode;

#if defined(TDM_DEBUG)
    randNode1 = rand() % MAX_CLUSTER_SIZE;
    randNode2 = rand() % MAX_CLUSTER_SIZE;
#endif

    for ( i=0; i < (node_t) rgp->num_nodes; i++ )
    {
#if defined(TDM_DEBUG)
        if (rgp->OS_specific_control.debug.MyTestPoints.TestPointBits.joinfailADD)
        {
            if ((node_t) randNode1 == i)
                rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t) randNode2);
        }
#endif
        if (myseqnum != rgp->rgppkt.seqno)
        {
                joinfailed = TRUE;
                break;
        }
        else if ( rgp->node_states[i].status == RGP_NODE_ALIVE )
        {
            if ( i == rgp->mynode )
               rgp_receive_events( &rgpbuf ); // take the quick route
            else
            {
#if defined(INCONSISTENT_REGROUP_ADD_FAILED)
                if (i != my_reloadee_num) {
                    joinfailed = TRUE;
                    break;
                }
#endif
                status = ClSend( EXT_NODE(i), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
                if ( status )
                {
                    RGP_TRACE( "ClSend failed to send Add Node msg",
                               rgp->rgppkt.stage,
                               (uint32) EXT_NODE(i),
                               (uint32) status,
                               0 );
                    joinfailed = TRUE;
                    break;
                }
            }
        }
    }

    if (joinfailed)
    {
        JoinNodeDelete (joiningNode);
        return MM_TRANSIENT;
    }

    //
    // Next, we must tell the reloadee to come up.
    //

    rgpbuf.event = RGP_EVT_SETRGPINFO;
    do {
        status = rgp_getrgpinfo( &rgpbuf.data.rgpinfo );
    }
    while ( status == -1 /* regroup is perturbed */ );
    
#if defined(INCONSISTENT_REGROUP_IGNORE_JOINER)
    IgnoreJoinerNodeUp = INCONSISTENT_REGROUP_IGNORE_JOINER;
#endif
    
    status = ClSend( EXT_NODE(my_reloadee_num), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
    if ( status )
    {
        RGP_TRACE( "ClSend failed to send Set Regroup Info msg",
                   rgp->rgppkt.stage,
                   (uint32) EXT_NODE(my_reloadee_num),
                   (uint32) status,
                   0 );
        JoinNodeDelete(joiningNode);
        return MM_FAULT;
    }
    // Wait until the reloadee has sent us the first IamAlive message
    // which changes the reloadee state to RGP_NODE_ALIVE.

    while (rgp->node_states[my_reloadee_num].status != RGP_NODE_ALIVE)
    {
        // The regroup messages will be handled by the message thread.  This
        // thread has nothing to do until the reloadee comes alive.

        Sleep( 1 );             // snooze for 1 millisecond

        // Check if timeout exceeded
        if ( --joinTimeout <= 0 )
        {
            // Reloadee hasn't started sending I'm alives.  Tell all the nodes
            // to remove it.
            JoinNodeDelete ( joiningNode);
            return MM_TIMEOUT;
        }

        if (myseqnum != rgp->rgppkt.seqno)
        {
            JoinNodeDelete ( joiningNode);
            return MM_TRANSIENT;
        }
    }

    //
    // Next, we must tell all running nodes that the reloadee is up.
    //

    rgpbuf.event = RGP_EVT_MONITOR_NODE;
    rgpbuf.data.node = (node_t)joiningNode;

    for ( i=0; i < (node_t) rgp->num_nodes; i++ )
    {
#if defined(TDM_DEBUG)
        if (rgp->OS_specific_control.debug.MyTestPoints.TestPointBits.joinfailMON)
        {
            if ((node_t) randNode1 == i)
                rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t) randNode2);
        }
#endif
        if (myseqnum != rgp->rgppkt.seqno)
        {
            joinfailed = TRUE;
            break;
        }
        else if ( rgp->node_states[i].status == RGP_NODE_ALIVE )
        {
            if ( i == rgp->mynode )
                rgp_receive_events( &rgpbuf );         // take the quick route
            else
            {
#if defined(INCONSISTENT_REGROUP_MONITOR_FAILED)
                if (i != my_reloadee_num) {
                    joinfailed = TRUE;
                    break;
                }
#endif

                status = ClSend( EXT_NODE(i), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
                if ( status )
                {
                    RGP_TRACE( "ClSend failed to send Monitor Node msg",
                               rgp->rgppkt.stage,
                               (uint32) EXT_NODE(i),
                               (uint32) status,
                               0 );
                    joinfailed = TRUE;
                    break;
                }
            }
        }
    }

    if (joinfailed)
    {
        JoinNodeDelete (joiningNode);
        return MM_TRANSIENT;
    }

    //
    // Next, we must tell the reloadee that reload is complete.
    //

    rgpbuf.event = RGP_EVT_START;
    rgpbuf.data.node = (node_t)joiningNode;
    status = ClSend( EXT_NODE(my_reloadee_num), (void *)&rgpbuf, sizeof(rgp_msgbuf), joinTimeout );
    if ( status )
    {
        RGP_TRACE( "ClSend failed to send Start msg",
                   rgp->rgppkt.stage,
                   (uint32) EXT_NODE(my_reloadee_num),
                   (uint32) status,
                   0 );
        JoinNodeDelete(joiningNode);
        return MM_FAULT;
    }

    return MM_OK;
}

/************************************************************************
 *
 * MMLeave
 * =======
 *
 * Description:
 *     This function causes the current node to leave the active cluster (go to
 *     Down state). The node no longer sends Regroup or Heartbeats to other cluster members.
 *     A NodeDown event will not be generated in this node. A Regroup is triggered in the
 *     remaining nodes (if this node was a member of the cluster).
 *     A node-down callback will occur on all remaining cluster members.
 *
 *     This initiates a clean, voluntary, leave operation.  For safety, prior to this,
 *     the calling node's CM should arrange to lose ownership of all cluster-owned
 *     devices assigned to this node (and so cause failovers, etc).
 *
 *     This routine returns normally. The caller (the CM) should then shutdown
 *     the cluster. MMShutdown or MMHalt may occur after this call, or
 *     the node may be re-joined to the cluster. All apply-to-the-PCM-to-join
 *     attempts by a node must be preceded by a call to MMleave().
 *
 *     This routine may block.
 *

 *
 * Parameters:
 *              -
 *
 * Returns:
 *
 *    MM_OK        :  Elvis has left the cluster (but has been reportedly
 *                                        sighted on numerous occasions).
 *
 *    MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 ************************************************************************/


DWORD  MMLeave( void )
{
    if (!rgp) {
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MMLeave is called when rgp=NULL.\n");
        return MM_FAULT;
    }
    
    if (! ClusterMember (rgp->OS_specific_control.CPUUPMASK, rgp->mynode) )
        return MM_NOTMEMBER;

    RGP_LOCK; // to ensure that we don't send in response to incoming pkt
    rgp_event_handler (MM_EVT_LEAVE, EXT_NODE(rgp->mynode));
    rgp_cleanup();
    rgp_cleanup_OS();
    RGP_UNLOCK;

    return MM_OK;
}


DWORD  MMForceRegroup( IN DWORD NodeId )
{
    if (! ClusterMember (rgp->OS_specific_control.CPUUPMASK, (node_t)NodeId) )
    {
        ClRtlLogPrint(LOG_CRITICAL,
                "[MM] MMForceRegroup: NodeId %1!u! is not a clustermember\r\n",
                NodeId);
        return MM_NOTMEMBER;
        }
    rgp_event_handler(RGP_EVT_LATEPOLLPACKET, (node_t)NodeId);


    return MM_OK;
}

/************************************************************************
 *
 * MMNodeUnreachable
 * =================
 *
 * Description:
 *
 *     This should be called by the CM's messaging module when a node
 *     becomes unreachable from this node via all paths. It allows quicker
 *     detection of failures, but is otherwise equivalent to discovering
 *     that the node has disappeared as a result of lost heartbeats.
 *
 * Parameters:
 *
 *     node -
 *         specifies the node that is unreachable.
 *
 * Returns:
 *
 *   Always MM_OK
 *
 ************************************************************************/

DWORD MMNodeUnreachable( DWORD node )
{
    rgp_event_handler( RGP_EVT_NODE_UNREACHABLE, (node_t) node );

    return MM_OK;
}

/************************************************************************
 *
 * MMPowerOn
 * =========
 *
 * Description:
 *
 *     This routine is used on systems which support power-fail
 *     ride-throughs. When power is restored, this function should be
 *     called by the CM (on each node).
 *
 *     Power-on normally occurs on multiple nodes at about the same time.
 *     This routine temporarily changes the cluster integrity handling so
 *     that the cluster can better survive transient loss of heartbeats
 *     which accompany power-fail; in normal cases, the cluster will
 *     survive power-fails without cluster members being
 *     evicted because of lack of timely response.
 *
 * Parameters:
 *
 *     None.
 *
 * Returns:
 *
 *     Always MM_OK
 *
 ************************************************************************/

DWORD MMPowerOn( void )
{
   rgp_event_handler( RGP_EVT_POWERFAIL, EXT_NODE(rgp->mynode) );

   return MM_OK;
}

/************************************************************************
 *
 * MMClusterInfo
 * =============
 *
 * Description:
 *
 *     Returns the current cluster information.
 *
 *     This can be called in nodes which are not members of the cluster;
 *     such calls always return NumActiveNodes = 0, because Down nodes
 *     have no knowledge of current cluster membership.
 *
 * Parameters:
 *
 *     clinfo
 *         pointer to CLUSTERINFO structure that receives the cluster
 *         information.
 *
 * Returns:
 *
 *     Always MM_OK
 *
 ************************************************************************/

DWORD
MMClusterInfo(
    OUT  LPCLUSTERINFO clinfo
    )
{
    node_t i,j;
    cluster_t MyCluster;

    RGP_LOCK;
    clinfo->clockPeriod = rgp->rgpinfo.a_tick;
    clinfo->sendHBRate = rgp->rgpinfo.iamalive_ticks;
    clinfo->rcvHBRate = rgp->rgpinfo.check_ticks;

    ClusterCopy(MyCluster,rgp->OS_specific_control.CPUUPMASK);
    RGP_UNLOCK;

    for ( i=0,j=0; i < MAX_CLUSTER_SIZE; i++ )
    {
        if ( ClusterMember (MyCluster, i) )
        {
            if (clinfo->UpNodeList != RGP_NULL_PTR)
                clinfo->UpNodeList[j] = (DWORD)i;
            j++;
        }
    }
    clinfo->NumActiveNodes = j;

    return MM_OK;
}

/************************************************************************
 *
 * MMShutdown
 * ==========
 *
 * Description:
 *     This shuts down the MM and Regroup services. Prior to this, the node should
 *     voluntarily have left the cluster. Following this, all membership services
 *     are non-functional; no further MM call may occur.
 *
 *     THIS CALL MUST BE PRECEDED BY INCOMING MESSAGE CALLBACK SHUTDOWN.
 *
 * Parameters:
 *     None.
 *
 * Returns:
 *     None.
 *
 ************************************************************************/
void MMShutdown (void)
{
    rgp_cleanup();
    rgp_cleanup_OS();

    // terminate timer thread
    rgp->rgpinfo.a_tick = 0; // special value indicates exit request
    SetEvent( rgp->OS_specific_control.TimerSignal); // wake up Timer Thread

    // wait for timer thread to exit; clean up associated handles for good measure
    WaitForSingleObject( rgp->OS_specific_control.TimerThread, INFINITE );
    rgp->OS_specific_control.TimerThread = 0;

    if ( rgp->OS_specific_control.RGPTimer ) {
        CloseHandle ( rgp->OS_specific_control.RGPTimer );
        rgp->OS_specific_control.RGPTimer = 0;
    }

    if (rgp->OS_specific_control.TimerSignal) {
        CloseHandle ( rgp->OS_specific_control.TimerSignal );
        rgp->OS_specific_control.TimerSignal = 0;
    }

#if !defined (TDM_DEBUG)
    //
    // Uninitialize message system
    //
    ClMsgCleanup();

#endif // TDM_DEBUG

    // delete regroup's critical section object
    DeleteCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );

    // delete calloc'd space
    free (rgp->rgp_msgsys_p);
    free (rgp);
    rgp = NULL;
}


/************************************************************************
 *
 * MMEject
 * =======
 *
 * Description:
 *
 *     This function causes the specified node to be ejected from the
 *     active cluster. The targetted node will be sent a poison packet and
 *     will enter its MMHalt code. A Regroup incident will be initiated. A
 *     node-down callback will occur on all remaining cluster members.
 *
 *     Note that the targetted node is Downed before that node has
 *     a chance to call any remove-ownership or voluntary failover code. As
 *     such, this is very dangerous. This call is provided only as a last
 *     resort in removing an insane node from the cluster; normal removal
 *     of a node from the cluster should occur by CM-CM communication,
 *     followed by the node itself doing a voluntary Leave on itself.
 *
 *     This routine returns when the node has been told to die. Completion
 *     of the removal occurs asynchronously, and a NodeDown event will be
 *     generated when successful.
 *
 *     This routine may block.
 *
 * Parameters:
 *
 *     Node Number.
 *
 * Returns:
 *
 *     MM_OK        :  The node has been told to leave the cluster.
 *
 *     MM_NOTMEMBER :  the node is not currently a cluster member.
 *
 *     MM_TRANSIENT :  My node state is in transition. OK to retry.
 *
 ************************************************************************/
DWORD MMEject( IN DWORD node )
{
    int i;
    RGP_LOCK;

    if (! ClusterMember (
              rgp->OS_specific_control.CPUUPMASK,
              (node_t) INT_NODE(node))
       )
    {
        RGP_UNLOCK;

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmEject failed. %1!u! is not a member of %2!04X!.\n",
            node, rgp->OS_specific_control.CPUUPMASK
            );

        return MM_NOTMEMBER;
    }

    if ( !ClusterMember (
             rgp->outerscreen,
             INT_NODE(node) )
       || ClusterMember(rgp->OS_specific_control.Banished, INT_NODE(node) )
       )
    {
        int perturbed = rgp_is_perturbed();

        RGP_UNLOCK;

        if (perturbed) {
           ClRtlLogPrint(LOG_UNUSUAL, 
               "[MM] MMEject: %1!u!, banishing is already in progress.\n",
               node
               );
        } else {
           ClRtlLogPrint(LOG_UNUSUAL, 
               "[MM] MmEject: %1!u! is already banished.\n",
               node
               );
        }

        return MM_OK;
    }

    //
    // Adding a node to a rgp->OS_specific_control.Banished mask
    // will cause us to send a poison packet as a reply to any
    // regroup packet coming from Banishee
    //
    ClusterInsert(rgp->OS_specific_control.Banished, (node_t)INT_NODE(node));

    if ( !ClusterMember(rgp->ignorescreen, (node_t)INT_NODE(node)) ) {
        //
        // It doesn't matter in what stage of the regroup
        // we are. If the node needs to be banished we have to
        // initiate a new regroup
        //
        rgp_event_handler( RGP_EVT_BANISH_NODE, (node_t) node );
        RGP_UNLOCK;
    } else {
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmEject: %1!u! is already being ignored.\n",
            node
            );
    }


    RGP_TRACE( "RGP Poison sent ", node, 0, 0, 0 );
    fflush( stdout );
    //
    // Send 3 poison packets with half a second interval in between.
    // We hope that at least one of the will get through
    //
    ClusnetSendPoisonPacket( NmClusnetHandle, node );
    Sleep(500);
    ClusnetSendPoisonPacket( NmClusnetHandle, node );
    Sleep(500);
    ClusnetSendPoisonPacket( NmClusnetHandle, node );

    return MM_OK;
}

/************************************************************************
 * MMIsNodeUp
 * ==========
 *
 *
 * Returns true iff the node is a member of the current cluster.
 *
 * *** debugging and test only.
 *
 * Parameters:
 *     Node Number of interest.
 *
 * Returns:
 *     TRUE if Node is member of cluster else FALSE.
 *
 ************************************************************************/

BOOL MMIsNodeUp(IN DWORD node)
{
    return (ClusterMember(
                rgp->OS_specific_control.CPUUPMASK,
                (node_t) INT_NODE(node)
                )
           );
}

/************************************************************************
 *
 * MMDiag
 * ======
 *
 * Description:
 *
 *     Handles "diagnostic" messages.  Some of these messages will
 *     have responses that are returned.  This function is typically
 *     called by the Cluster Manager with connection oriented
 *     messages from CLI.
 *
 *
 * Parameters:
 *
 *     messageBuffer
 *             (IN) pointer to a buffer that contains the diagnostic message.
 *             (OUT) response to the diagnostic message
 *
 *     maximumLength
 *             maximum number of bytes to return in messageBuffer
 *
 *     ActualLength
 *             (IN) length of diagnostic message
 *             (OUT) length of response
 *
 * Returns:
 *
 *     Always MM_OK
 *
 ************************************************************************/

DWORD
MMDiag(
    IN OUT  LPCSTR  messageBuffer,  // Diagnostic message
    IN      DWORD   maximumLength,  // maximum size of buffer to return
    IN OUT  LPDWORD ActualLength    // length of messageBuffer going in and coming out
    )
{
    // ??? need to return info in the future

    rgp_receive_events( (rgp_msgbuf *)messageBuffer );

    return MM_OK;
}

/************************************************************************
 *
 * rgp_receive_events
 * ==================
 *
 * Description:
 *
 *     This routine is called from MMDiag and from the Cluster Manager
 *     message thread (via our callback) to handle regroup messages
 *     and diagnostic messages.
 *
 * Parameters:
 *
 *     rgpbuf
 *         the message that needs to be handled.
 *
 * Returns:
 *
 *   none
 *
 ************************************************************************/

void
rgp_receive_events(
    IN rgp_msgbuf *rgpbuf
    )
{
    int           event;
    rgpinfo_t     rgpinfo;
    poison_pkt_t  poison_pkt;  /* poison packet sent from stack */
    DWORD         status;

#if defined(TDM_DEBUG)
    extern  BOOL  GUIfirstTime;
    extern  HANDLE gGUIEvent;
#endif

    event = rgpbuf->event;

#if defined(TDM_DEBUG)
    if ( (rgp->OS_specific_control.debug.frozen) && (event != RGP_EVT_THAW) )
       return;  /* don't do anything if the node is frozen */
#endif

    if ( event == RGP_EVT_RECEIVED_PACKET )
    {
        //
        // Go handle the regroup packet.
        //
        rgp_received_packet(rgpbuf->data.node,
                            (void *) &(rgpbuf->unseq_pkt),
                            sizeof(rgpbuf->unseq_pkt) );
    }

    else if (event < RGP_EVT_FIRST_DEBUG_EVENT)
    {
        //
        // "regular" regroup message
        //
        rgp_event_handler(event, rgpbuf->data.node);
    }

    else
    {
        //
        // Debugging message
        //
        RGP_TRACE( "RGP Debug event ", event, rgpbuf->data.node, 0, 0 );

        switch (event)
        {
        case RGP_EVT_START          :
        {
           rgp_start( MMiNodeDownCallback, RGP_NULL_PTR );
           break;
        }
        case RGP_EVT_ADD_NODE       :
        {
           rgp_add_node( rgpbuf->data.node );
           break;
        }
        case RGP_EVT_MONITOR_NODE   :
        {
           rgp_monitor_node( rgpbuf->data.node );
           break;
        }
        case RGP_EVT_REMOVE_NODE    :
        {
           rgp_remove_node( rgpbuf->data.node );
           break;
        }
        case RGP_EVT_GETRGPINFO     :
        {
           rgp_getrgpinfo( &rgpinfo );
           RGP_TRACE( "RGP GetRGPInfo  ",
                      rgpinfo.version,                 /* TRACE */
                      rgpinfo.seqnum,                  /* TRACE */
                      rgpinfo.iamalive_ticks,          /* TRACE */
                      GetCluster( rgpinfo.cluster ) ); /* TRACE */
           break;
        }
        case RGP_EVT_SETRGPINFO     :
        {
           rgp_setrgpinfo( &(rgpbuf->data.rgpinfo) );

           /* This event is traced in rgp_setrgpinfo(). */

           break;
        }
        case RGP_EVT_HALT :
        {
           exit( 1 );
           break;
        }

#if defined(TDM_DEBUG)

        case RGP_EVT_FREEZE :
        {
           rgp->OS_specific_control.debug.frozen = 1;
           break;
        }
        case RGP_EVT_THAW :
        {
           rgp->OS_specific_control.debug.frozen = 0;
                        break;
        }
        case RGP_EVT_STOP_SENDING :
        {
            ClusterInsert( rgp->OS_specific_control.debug.stop_sending,
                       INT_NODE(rgpbuf->data.node) );
            /* Generate a node unreachable event to indicate that
             * we cannot send to this node.
             */
            rgp_event_handler( RGP_EVT_NODE_UNREACHABLE, rgpbuf->data.node );
            break;
        }
        case RGP_EVT_RESUME_SENDING :
        {
            ClusterDelete(rgp->OS_specific_control.debug.stop_sending,
                     INT_NODE(rgpbuf->data.node));
            break;
        }
        case RGP_EVT_STOP_RECEIVING :
        {
            ClusterInsert(rgp->OS_specific_control.debug.stop_receiving,
                          INT_NODE(rgpbuf->data.node));
            break;
        }
        case RGP_EVT_RESUME_RECEIVING :
        {
            ClusterDelete(rgp->OS_specific_control.debug.stop_receiving,
                          INT_NODE(rgpbuf->data.node));
            break;
        }
        case RGP_EVT_SEND_POISON :
        {
            poison_pkt.pktsubtype = RGP_UNACK_POISON;
            poison_pkt.seqno = rgp->rgppkt.seqno;
            poison_pkt.reason = rgp->rgppkt.reason;
            poison_pkt.activatingnode = rgp->rgppkt.activatingnode;
            poison_pkt.causingnode = rgp->rgppkt.causingnode;
            ClusterCopy(poison_pkt.initnodes, rgp->initnodes);
            ClusterCopy(poison_pkt.endnodes, rgp->endnodes);
            rgp_send( rgpbuf->data.node, (char *)&poison_pkt, POISONPKTLEN );
            break;
        }
        case RGP_EVT_STOP_TIMER_POPS :
        {
            rgp->OS_specific_control.debug.timer_frozen = 1;
            break;
        }
        case RGP_EVT_RESUME_TIMER_POPS :
        {
            rgp->OS_specific_control.debug.timer_frozen = 0;
            break;
        }
        case RGP_EVT_RELOAD :
        {

            if (rgp->OS_specific_control.debug.reload_in_progress)
            {
                RGP_TRACE( "RGP Rld in prog ", 0, 0, 0, 0 );
                return;
            }

            rgp->OS_specific_control.debug.reload_in_progress = 1;

            if (rgpbuf->data.node == RGP_NULL_NODE)
            {
                RGP_TRACE( "RGP Invalid join parms ", -1, 0, 0, 0 );
                return;
                // Not supported since this server doesn't know which ones
                // are currently running.
                /* Reload all down nodes */
                //for (i = 0; i < rgp->num_nodes; i++)
                    //MMJoin( EXT_NODE(i), 0 /*use default*/, -1 /*???*/ );
            }
            else
            {
               /* Reload the specified node */
               status = MMJoin( rgpbuf->data.node /* joiningNode */,
                                0 /* use default clockPeriod */,
                                0 /* use default sendHBRate */,
                                0 /* use default rcvHBRate */,
                                500 /*millisecond timeout*/ );
               if ( status != MM_OK )
               {
                   RGP_TRACE( "RGP Join Failed ",
                              rgpbuf->data.node,
                              status, 0, 0 );
                   Sleep( 1000 );        // stablize regroup for reload * case - testing purposes
               }
           }

           rgp->OS_specific_control.debug.reload_in_progress = 0;

           break;
        }
        case RGP_EVT_TRACING :
        {
            rgp->OS_specific_control.debug.doing_tracing =
                ( rgpbuf->data.node ? 1 : 0 );

            if (!rgp->OS_specific_control.debug.doing_tracing)
            {
                GUIfirstTime = TRUE;
                SetEvent( gGUIEvent );
            }
            break;
        }
#endif // TDM_DEFINED

        case RGP_EVT_INFO:
           // nop for now
           break;
        case MM_EVT_LEAVE:
            status = MMLeave(); // (self) leave cluster
            break;
        case MM_EVT_EJECT:
            status = MMEject (rgpbuf->data.node); // eject other node
            break;

#if defined(TDM_DEBUG)
        case MM_EVT_INSERT_TESTPOINTS:
            rgp->OS_specific_control.debug.MyTestPoints.TestPointWord =
                            rgpbuf->data.node;
            break;
#endif

        default :
        {
           RGP_TRACE( "RGP Unknown evt ", event, 0, 0, 0 );
           break;
        }
        } /* end switch */
    }
}

/************************************************************************
 *
 * rgp_send
 * ========
 *
 * Description:
 *
 *     This routine is called to send an unacknowledged message to
 *     the specified node.
 *
 * Parameters:
 *
 *     node
 *             node number to send the message to.
 *
 *     data
 *             pointer to the data to send
 *
 *     datasize
 *             number of bytes to send
 *
 * Returns:
 *
 *   none.
 *
 ************************************************************************/

void
rgp_send(
    IN node_t node,
    IN void *data,
    IN int datasize
    )
{
    rgp_msgbuf   rgpbuf;
    DWORD        status;

    if (rgp->node_states[rgp->mynode].status != RGP_NODE_ALIVE)
        return;  // suppress sending if we're not alive

#if defined(TDM_DEBUG)
    if ( ClusterMember( rgp->OS_specific_control.debug.stop_sending,
                        INT_NODE(node) ) )
        return;  /* don't send to this node */
#endif

    rgpbuf.event = RGP_EVT_RECEIVED_PACKET;
    rgpbuf.data.node = EXT_NODE(rgp->mynode);
    memmove( &(rgpbuf.unseq_pkt), data, datasize);

    switch (rgpbuf.unseq_pkt.pktsubtype) {
    case RGP_UNACK_REGROUP  :

        status = ClMsgSendUnack( node, (void *)&rgpbuf, sizeof(rgp_msgbuf) );

        if ( status && (status != WSAENOTSOCK) )
            {
                RGP_TRACE( "ClMsgSendUnack failed",
                           rgp->rgppkt.stage,
                           (uint32) node,
                           (uint32) status,
                           0 );

                fflush(stdout);
            }
        break;

    case RGP_UNACK_IAMALIVE :
        break;

    case RGP_UNACK_POISON   :
        RGP_TRACE( "RGP Poison sent ", node, 0, 0, 0 );
        fflush( stdout );
        ClusnetSendPoisonPacket( NmClusnetHandle, node );
        break;

    default                 :
        break;
    }
}

/************************************************************************
 *
 * SetMulticastReachable
 * ===============
 *
 * Description:
 *
 *              This routine is called by the message.c to update
 *              the info of which nodes are reachable thru multicast.
 *
 * Parameters:
 *
 *              none
 *
 * Returns:
 *
 *              none
 *
 ************************************************************************/
void SetMulticastReachable(uint32 mask)
{
    *(PUSHORT)rgp->OS_specific_control.MulticastReachable = (USHORT)mask;
}


/************************************************************************
 *
 * rgp_msgsys_work
 * ===============
 *
 * Description:
 *
 *              This routine is called by the regroup engine to broadcast
 *              messages.
 *
 * Parameters:
 *
 *              none
 *
 * Returns:
 *
 *              none
 *
 ************************************************************************/

void
rgp_msgsys_work( )
{
    node_t i;

    do  /* do while more regroup work to do */
    {
        if (rgp->rgp_msgsys_p->sendrgppkts)
        { /* broadcast regroup packets */
            rgp->rgp_msgsys_p->sendrgppkts = 0;
            if ( ClusterNumMembers(rgp->OS_specific_control.MulticastReachable) >= 1) 
            {
                cluster_t tmp;
                ClusterCopy(tmp, rgp->rgp_msgsys_p->regroup_nodes);
                ClusterDifference(rgp->rgp_msgsys_p->regroup_nodes, 
                               rgp->rgp_msgsys_p->regroup_nodes, 
                               rgp->OS_specific_control.MulticastReachable);

                RGP_TRACE( "RGP Multicast",
                    GetCluster(rgp->OS_specific_control.MulticastReachable),
                    GetCluster(tmp),
                    GetCluster(rgp->rgp_msgsys_p->regroup_nodes),
                    0);
                rgp_send( 0,
                          rgp->rgp_msgsys_p->regroup_data,
                          rgp->rgp_msgsys_p->regroup_datalen
                          );
            }    
            for (i = 0; i < (node_t) rgp->num_nodes; i++)
                if (ClusterMember(rgp->rgp_msgsys_p->regroup_nodes, i))
                {
                    ClusterDelete(rgp->rgp_msgsys_p->regroup_nodes, i);
                    RGP_TRACE( "RGP Unicast", EXT_NODE(i), 0,0,0);
                    rgp_send( EXT_NODE(i),
                              rgp->rgp_msgsys_p->regroup_data,
                              rgp->rgp_msgsys_p->regroup_datalen
                              );
                }
        } /* broadcast regroup packets */

        if (rgp->rgp_msgsys_p->sendiamalives)
        { /* broadcast iamalive packets */
            rgp->rgp_msgsys_p->sendiamalives = 0;
            for (i = 0; i < (node_t) rgp->num_nodes; i++)
                if (ClusterMember(rgp->rgp_msgsys_p->iamalive_nodes, i))
                {
                    ClusterDelete(rgp->rgp_msgsys_p->iamalive_nodes, i);
                    rgp_send( EXT_NODE(i),
                              rgp->rgp_msgsys_p->iamalive_data,
                              rgp->rgp_msgsys_p->iamalive_datalen
                              );
                }
        } /* broadcast iamalive packets */

        if (rgp->rgp_msgsys_p->sendpoisons)
        { /* send poison packets */
            rgp->rgp_msgsys_p->sendpoisons = 0;
            for (i = 0; i < (node_t) rgp->num_nodes; i++)
                if (ClusterMember(rgp->rgp_msgsys_p->poison_nodes, i))
                {
                    ClusterDelete(rgp->rgp_msgsys_p->poison_nodes, i);
                    rgp_send( EXT_NODE(i),
                              rgp->rgp_msgsys_p->poison_data,
                              rgp->rgp_msgsys_p->poison_datalen
                              );
                }
        } /* send poison packets */

    } while ((rgp->rgp_msgsys_p->sendrgppkts) ||
             (rgp->rgp_msgsys_p->sendiamalives) ||
             (rgp->rgp_msgsys_p->sendpoisons)
            );

}


DWORD
MMMapStatusToDosError(
    IN DWORD MMStatus
    )
{
    DWORD dosStatus;


    switch(MMStatus) {
    case MM_OK:
        dosStatus = ERROR_SUCCESS;
        break;

    case MM_TIMEOUT:
        dosStatus = ERROR_TIMEOUT;
        break;

    case MM_TRANSIENT:
        dosStatus = ERROR_RETRY;
        break;

    case MM_FAULT:
        dosStatus = ERROR_INVALID_PARAMETER;
        break;

    case MM_ALREADY:
        dosStatus = ERROR_SUCCESS;
        break;

    case MM_NOTMEMBER:
        dosStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
        break;
    }

    return(dosStatus);

}  // MMMapStatusToDosError

DWORD
MMMapHaltCodeToDosError(
    IN DWORD HaltCode
    )
{
    DWORD dosStatus;

    switch(HaltCode) {
    case RGP_SHUTDOWN_DURING_RGP:
    case RGP_RELOADFAILED:
        dosStatus = ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE;
        break;
    default:        
        dosStatus = ERROR_CLUSTER_MEMBERSHIP_HALT;
    }

    return(dosStatus);

}  // MMMapHaltCodeToDosError

/* ----------------------------  */

DWORD MmSetRegroupAllowed( IN BOOL allowed )
 /* This function can be used to allow/disallow regroup participation
  * for the current node.
  *
  * Originally regroup was allowed immediately after receiving RGP_START
  * event. Since this happens before join is complete 
  * joiner can arbitrate and win, leaving
  * the other side without a quorum device.
  *
  * It is required to add MmSetRegroupAllowed(TRUE) at the very end
  * of the ClusterJoin. The node doesn't need to call MmSetRegroupAllowed(TRUE)
  * for ClusterForm, since MMJoin will call
  * MmSetRegroupAllowed(TRUE) for the cluster forming node
  *
  * MmSetRegroupAllowed(FALSE) can be used to disable regroup
  * participation during shutdown.
  *
  *
  * Errors:
  *
  *   MM_OK        : successful completition
  *
  *   MM_TRANSIENT : disallowing regroup when regroup is in progress
  *
  *   MM_ALREADY   : node is already in the desired condition
  *
  *
  */
{
   DWORD status;

   if (rgp) {

       RGP_LOCK;

       if (allowed) {
          if (rgp->rgppkt.stage == RGP_COLDLOADED) {
             rgp->rgppkt.stage = RGP_STABILIZED;
             status = MM_OK;
          } else {
             status = MM_ALREADY;
          }
       } else {
          if (rgp->rgppkt.stage == RGP_STABILIZED) {
             rgp->rgppkt.stage = RGP_COLDLOADED;
             status = MM_OK;
          } else if (rgp->rgppkt.stage == RGP_COLDLOADED) {
             status = MM_ALREADY;
          } else {
             //
             // Regroup is already in progress. Kill this node.
             //
             RGP_ERROR(RGP_SHUTDOWN_DURING_RGP);
          }
       }

       RGP_UNLOCK;

   } else if (allowed) {
      ClRtlLogPrint(LOG_UNUSUAL, 
          "[MM] SetRegroupAllowed(%1!u!) is called when rgp=NULL.\n",
          allowed
          );
      status = MM_FAULT;
   } else {
     // if rgp is null and the caller wants to disable regroup.
     status = MM_ALREADY;
   }

   return status;
}

DWORD MMSetQuorumOwner(
    IN DWORD NodeId,
    IN BOOL Block,
    OUT PDWORD pdwSelQuoOwnerId
    
    )
/*++

Routine Description:

    Inform Membership engine about changes in ownership of
    the quorum resource.

Arguments:

    NodeId - Node number to be set as a quorum owner.
             Code assumes that Node is either equal to MyNodeId.
             In this case the current node is about to become a
             quorum owner or it has a value MM_INVALID_NODE, when
             the owner decides to relinquish the quorum ownership

    Block -  if the quorum owner needs to relinquish the 
             quorum immediately no matter what (RmTerminate, RmFail),
             this parameter should be set to FALSE and to TRUE otherwise.

    pdwSelQuoOwnerId - if this was invoked while a regroup was in progress
            then this contains the id of the node that was chosen to 
            arbitrate for the quorum in that last regroup else it contains
            MM_INVALID_NODE.                

Return Value:

    ERROR_SUCCESS - QuorumOwner variable is set to specified value
    ERROR_RETRY - Regroup was in progress when this function
      was called and regroup engine decision conflicts with current assignment.

Comments:

 This function needs to be called before calls to
 RmArbitrate, RmOnline, RmOffline, RmTerminate, RmFailResource

 Depending on the result, the caller should either proceed with 
 Arbitrate/Online or Offline or return an error if MM_TRANSIENT is returned.

 If Block is set to TRUE, the call will block until the end of the regroup if
 the regroup was in progress on the moment of the call
 */
{
    DWORD MyNode;

    if (pdwSelQuoOwnerId)
    {
        *pdwSelQuoOwnerId = MM_INVALID_NODE;
    }        
    
    ClRtlLogPrint(LOG_NOISE, 
        "[MM] MmSetQuorumOwner(%1!u!,%2!u!), old owner %3!u!.\n", NodeId, Block, QuorumOwner
        );
    if (!rgp) {
        // we are called on the form path before MM was initialized
        QuorumOwner = NodeId;
        return ERROR_SUCCESS;
    }
    MyNode = (DWORD)EXT_NODE(rgp->mynode);
    RGP_LOCK
    if ( !rgp_is_perturbed() ) {
        QuorumOwner = NodeId;
        RGP_UNLOCK;
	    return ERROR_SUCCESS;
    }
    //
    // we have a regroup in progress
    if (!Block) {
        // caller doesn't want to wait //
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: regroup is in progress, forcing the new value in.\n"
            );
        QuorumOwner = NodeId;
        RGP_UNLOCK;
        return ERROR_RETRY;
    }
    do {
        if(rgp->OS_specific_control.ArbitrationInProgress && NodeId == MyNode ) {
            // This is when MmSetQuorumOwner is called from within the regroup Arbitrate //
            QuorumOwner = MyNode;
            RGP_UNLOCK;
	        return ERROR_SUCCESS;
         }
         RGP_UNLOCK
         ClRtlLogPrint(LOG_UNUSUAL, 
             "[MM] MmSetQuorumOwner: regroup is in progress, wait until it ends\n"
                 );
         WaitForSingleObject(rgp->OS_specific_control.Stabilized, INFINITE);
         RGP_LOCK
    } while ( rgp_is_perturbed() );

    // Now we are in the stablilized state with RGP_LOCK held//
    // And we were blocked while regroup was in progress //
    // somebody else might become an owner of the quorum //
    // ArbitratingNode variable contains this information //
    // or it has MM_INVALID_NODE if there was no arbitration during the regroup //
    if (pdwSelQuoOwnerId)
    {
        *pdwSelQuoOwnerId = rgp->OS_specific_control.ArbitratingNode;
    }
    if (rgp->OS_specific_control.ArbitratingNode == MM_INVALID_NODE) {
        // No arbitration was done during  the last regroup
        QuorumOwner = NodeId;
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: no arbitration was done\n"
                );
        return ERROR_SUCCESS;
    }

    // Somebody arbitrated for the quorum
    if (rgp->OS_specific_control.ArbitratingNode == MyNode 
     && NodeId == MM_INVALID_NODE) {
        // We were asked to bring the quorum offline, 
        // but during the the regroup, we were arbitrating and won the quorum.
        // Let's fail offline request
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: offline request denied\n"
                );
	    return ERROR_RETRY;
    } else if (rgp->OS_specific_control.ArbitratingNode != MyNode
            && NodeId == MyNode ) {
        // We were going take bring the quorum online, but
        // during the regroup somebody else got the disk
        // Online. Let's fail online call in this case
        RGP_UNLOCK;
        ClRtlLogPrint(LOG_UNUSUAL, 
            "[MM] MmSetQuorumOwner: online request denied, %1!u! has the quorum.\n", 
            rgp->OS_specific_control.ArbitratingNode
            );
	    return ERROR_RETRY;

    }
    QuorumOwner = NodeId;
    RGP_UNLOCK;
    ClRtlLogPrint(LOG_UNUSUAL, 
        "[MM] MmSetQuorumOwner: new quorum owner is %1!u!.\n", 
        NodeId
        );
    return ERROR_SUCCESS;
}

DWORD MMGetArbitrationWinner(
    OUT PDWORD NodeId
    )
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    or MM_INVALID_NODE if there was no arbitration performed.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    ERROR_SUCCESS - success
    ERROR_RETRY - Regroup was in progress when this function
      was called. 
      
 */
{
    DWORD status;
    CL_ASSERT(NodeId != 0);
    RGP_LOCK
    
    *NodeId = rgp->OS_specific_control.ArbitratingNode;
    status = rgp_is_perturbed() ? ERROR_RETRY : ERROR_SUCCESS;

    RGP_UNLOCK;
    return status;
}

VOID MMBlockIfRegroupIsInProgress(
    VOID
    )
/*++

Routine Description:

    The call will block if the regroup is in progress.
  */
{
    RGP_LOCK;
    while ( rgp_is_perturbed() ) {
         RGP_UNLOCK
         ClRtlLogPrint(LOG_UNUSUAL, 
             "[MM] MMBlockIfRegroupIsInProgress: regroup is in progress, wait until it ends\n"
                 );
         WaitForSingleObject(rgp->OS_specific_control.Stabilized, INFINITE);
         RGP_LOCK;
    }
    RGP_UNLOCK;
}

VOID MMApproxArbitrationWinner(
    OUT PDWORD NodeId
    )
/*++

Routine Description:

    Returns the node that won the arbitration during the last regroup
    that was doing arbitration.

    The call will block if the regroup is in progress.
    
Arguments:

    NodeId - a pointer to a variable that receives nodeid of 
             arbitration winner.
             
Return Value:

    none
 */
{
    if (!rgp) {
        // we are called on the form path before MM was initialized
        *NodeId = MM_INVALID_NODE;
        return;
    }
    RGP_LOCK;
    while ( rgp_is_perturbed() ) {
         RGP_UNLOCK
         ClRtlLogPrint(LOG_UNUSUAL, 
             "[MM] MMApproxArbitrationWinner: regroup is in progress, wait until it ends\n"
                 );
         WaitForSingleObject(rgp->OS_specific_control.Stabilized, INFINITE);
         RGP_LOCK;
    }

    // Now we are in the stablilized state with RGP_LOCK held//
    
    *NodeId = rgp->OS_specific_control.ApproxArbitrationWinner;
    RGP_UNLOCK;
}

VOID MMStartClussvcClusnetHb(
    VOID
    )
/*++

Routine Description:

    This routine would start clussvc to clusnet heartbeating.

Arguments:

Return Value:

    none
*/
{
    MmStartClussvcToClusnetHeartbeat = TRUE;
}

VOID MMStopClussvcClusnetHb(
    VOID
    )
/*++

Routine Description:

    This routine would stop clussvc to clusnet heartbeating.

Arguments:

Return Value:

    none
*/
{
    MmStartClussvcToClusnetHeartbeat = FALSE;
}

#ifdef __cplusplus
}
#endif /* __cplusplus */

/* -------------------------- end ------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\srgpif.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgpif.c - T9050 - interface routines for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgpif.c) contains all the external interface routines
 * of Regroup.
 *---------------------------------------------------------------------------*/


#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>


/************************************************************************
 * rgp_estimate_memory
 * ===================
 *
 * Description:
 *
 *    Routine to find the number of bytes of memory needed by regroup.
 *    The only global memory used by Regroup is for the rgp_control structure.
 *    The caller must allocate and zero out a chunk of this much memory
 *    and then call rgp_init() with a pointer to this memory.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    int - number of bytes of locked down and initialized (to 0) memory
 *          needed by Regroup. The memory must be 4-byte aligned.
 *
 * Algorithm:
 *
 *    Uses the size of the rgp_control_t to calculate the number of
 *    bytes needed.
 *
 ************************************************************************/
_priv _resident int
RGP_ESTIMATE_MEMORY(void)
{
   return(sizeof(rgp_control_t));
}


/************************************************************************
 * rgp_init
 * ========
 *
 * Description:
 *
 *    Routine to initialize the global Regroup data structures.
 *
 * Parameters:
 *
 *    node_t this_node -
 *       node number of local node; regroup uses bit masks to represent
 *       nodes in the cluster and starts numbering nodes from 0. The OS
 *       starts numbering at LOWEST_NODENUM. This transformation is
 *       maintained in all the regroup interfaces to the OS.
 *
 *    unsigned int num_nodes -
 *       number of nodes in the configured node number space =
 *       (largest configured node number - LOWEST_NODENUM + 1).
 *
 *    void *rgp_buffer -
 *       pointer to a block of locked down memory initialized to 0; this is
 *       for use by Regroup as its global memory; must be 4-byte aligned
 *
 *    int rgp_buflen -
 *       length in bytes of the locked down buffer *rgp_buffer; must be equal
 *       to or greater than the number returned by rgp_estimate_memory()
 *
 *    rgp_msgsys_p rgp_msgsys_p -
 *       pointer to a common struct used by the message system and
 *       Regroup to co-ordinate regroup related work
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Initializes the Regroup global data structure with default initial
 *    values and the parameters passed in.
 *
 ************************************************************************/
_priv _resident void
RGP_INIT(node_t this_node, unsigned int num_nodes,
         void *rgp_buffer, int rgp_buflen,
         rgp_msgsys_p rgp_msgsys_p)
{
   this_node = INT_NODE(this_node); /* adjust the node number by the offset */

   if ((num_nodes > MAX_CLUSTER_SIZE) ||
       (this_node >= (node_t) num_nodes) ||
       (rgp_buflen < rgp_estimate_memory()) /* buffer too small */ ||
       ((ULONG_PTR)rgp_buffer % 4) /* buffer not 4-byte aligned */
      )
      RGP_ERROR(RGP_INTERNAL_ERROR);

#ifdef NSK
   /* In NSK, the caller must set up the global rgp pointer. */
#else
   rgp = (rgp_control_t *) rgp_buffer;
#endif /* NSK */

   rgp->num_nodes = num_nodes; /* # of nodes configured */

   rgp->rgp_msgsys_p = rgp_msgsys_p; /* ptr to struct shared with Msgsys */

   rgp->mynode = this_node;

#if defined (NT)
    /* Initialize RGP_LOCK, the CRITICALSECTION object that will be used
         * to synchronize access within the regroup procedures */
   InitializeCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );
#endif

   RGP_CLEANUP();

   /* We place a bit pattern in the IamAlive packet. This bit
    * pattern toggles all the bits.
    */
   rgp->iamalive_pkt.testpattern.words[0]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[1]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[2]  = 0x718E49F0;
   rgp->iamalive_pkt.testpattern.words[3]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[4]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[5]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[6]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[7]  = 0x718E49F0;
   rgp->iamalive_pkt.testpattern.words[8]  = 0x92CC33E3;
   rgp->iamalive_pkt.testpattern.words[9]  = 0x0055FF6D;
   rgp->iamalive_pkt.testpattern.words[10] = 0x55AA55AA;
   rgp->iamalive_pkt.testpattern.words[11] = 0x55AA55AA;
   rgp->iamalive_pkt.testpattern.words[12] = 0x55AA55AA;

   rgp->poison_pkt.pktsubtype = RGP_UNACK_POISON;

   rgp_init_OS();  /* OS-specific initializations */

   rgp_cleanup_OS(); /* OS-specific cleanup */

   /* Trace the call after the data structures have been initialized. */
   RGP_TRACE( "RGP Init called ", EXT_NODE(this_node), num_nodes,
              PtrToUlong(rgp_buffer), PtrToUlong(rgp_msgsys_p) ); /* TRACE */
}




/**************************************************************************
 * rgp_cleanup
 * ===========
 * Description:
 *
 *    This function cleans up the RGP structure such that this node is
 *    virtually returned to the state following RGP_INIT and ready to be
 *    "join"ed into the cluster.
 *
 * Parameters:
 *
 *      None
 *
 * Returns:
 *
 *      None
 **************************************************************************/
 _priv _resident void
RGP_CLEANUP(void)
{
   node_t i;

   RGP_LOCK;

/* Initialize the state of all possible nodes in the cluster. */
   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      rgp->node_states[i].status = RGP_NODE_DEAD;
      rgp->node_states[i].pollstate = AWAITING_IAMALIVE;
      rgp->node_states[i].lostHBs = 0;

#if defined( NT )
      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( i ),
                                    ClusnetNodeStateDead);
#endif // NT
   }
   for (i = (node_t)rgp->num_nodes; i < MAX_CLUSTER_SIZE; i++)
   {
      rgp->node_states[i].status = RGP_NODE_NOT_CONFIGURED;
      rgp->node_states[i].pollstate = AWAITING_IAMALIVE;
      rgp->node_states[i].lostHBs = 0;

#if defined( NT )
      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( i ),
                                    ClusnetNodeStateNotConfigured);
#endif // NT
   }

   rgp->rgpinfo.version = RGP_VERSION;
   rgp->rgpinfo.seqnum = RGP_INITSEQNUM;
   rgp->rgpinfo.iamalive_ticks = RGP_IAMALIVE_TICKS;
   rgp->rgpinfo.check_ticks = RGP_CHECK_TICKS;
   rgp->rgpinfo.Min_Stage1_ticks = RGP_MIN_STAGE1_TICKS;
   rgp->rgpinfo.a_tick = RGP_INACTIVE_PERIOD;

   ClusterInit(rgp->rgpinfo.cluster);

   rgp->rgppkt.stage = RGP_COLDLOADED;
   rgp->rgpcounter = 0;
   rgp->restartcount = 0;

   rgp->tiebreaker = rgp->mynode;

   /* Initialize the unacknowledged packet buffers */

   rgp->rgppkt.pktsubtype = RGP_UNACK_REGROUP;
   rgp->rgppkt.seqno = rgp->rgpinfo.seqnum;
   rgp->last_stable_seqno = rgp->rgpinfo.seqnum;

   ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);
   ClusterCopy(rgp->outerscreen,           rgp->rgpinfo.cluster);
#if defined( NT )
   ClusnetSetOuterscreen( NmClusnetHandle, (ULONG)*((PUSHORT)rgp->outerscreen) );
#endif
   ClusterCopy(rgp->innerscreen,           rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage1,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage2,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage3,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage4,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.knownstage5,    rgp->rgpinfo.cluster);
   ClusterCopy(rgp->rgppkt.pruning_result, rgp->rgpinfo.cluster);
   MatrixInit(rgp->rgppkt.connectivity_matrix);

   rgp->rgppkt_to_send.pktsubtype = RGP_UNACK_REGROUP;

   rgp->iamalive_pkt.pktsubtype = RGP_UNACK_IAMALIVE;

   RGP_UNLOCK;
}

/***************************************************************************
 * rgp_sequence_number
 * ===================
 * Description:
 *
 *    This function returns the regroup sequence number.
 *
 *    This provides only a subset of the functionality provided by
 *    rgp_getrgpinfo(), but is a simpler function and has no structure
 *    parameters, making it easier to call from PTAL.
 *
 *    A regroup incident could be in progress when this routine is
 *    called.
 *
 * Parameters:
 *
 *      None
 *
 * Returns:
 *
 *     uint32 - the current regroup sequence number; this reflects
 *              how many regroup incidents have happened since
 *              the system came up. Since one incident can result in
 *              upto RGP_RESTART_MAX restarts each resulting in the
 *              sequence # being bumped, this number does not always
 *              equal the number of regroup incidents.
 *
 ***************************************************************************/
_priv _resident uint32
RGP_SEQUENCE_NUMBER(void)
{
    return(rgp->rgpinfo.seqnum);
}


/************************************************************************
 * rgp_getrgpinfo
 * ==============
 *
 * Description:
 *
 *    Routine to get Regroup parameters.
 *
 * Parameters:
 *
 *    rgpinfo_t *rgpinfo - pointer to struct to be filled with Regroup
 *                         parameters.
 *
 * Returns:
 *
 *    int - 0 if successful; -1 if Regroup is perturbed.
 *
 * Algorithm:
 *
 *    Copies the rgpinfo struct from the Regroup global memory into the
 *    struct passed in by the caller.
 *
 ************************************************************************/
_priv _resident int
RGP_GETRGPINFO(rgpinfo_t *rgpinfo)
{
   int error = 0;

   /* If no rgpinfo structure is passed OR rgp_init() has not been called
    * earlier, halt.
    */

   if ((rgpinfo == RGP_NULL_PTR) || (rgp == RGP_NULL_PTR))
      RGP_ERROR( RGP_INTERNAL_ERROR );

   RGP_LOCK;

   if (rgp_is_perturbed())
      error = -1;
   else
      /* Copy the rgpinfo structure from regroup's internal struct. */
      *rgpinfo = rgp->rgpinfo;

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_setrgpinfo
 * ==============
 *
 * Description:
 *
 *    Routine to set Regroup parameters. This routine is to be called on
 *    newly booting nodes to set the Regroup parameters to the values
 *    in the master or reloading node. The parameters to be updated
 *    include Regroup timing parameters and the cluster membership;
 *    that is, the current set of nodes in the system.
 *
 *    This routine can also be called on the first node to boot to
 *    modify the Regroup timing parameters which are set to the default
 *    values when rgp_init() is called. Such modification has to be done
 *    before other nodes are added to the system.
 *
 * Parameters:
 *
 *    rgpinfo_t *rgpinfo - pointer to struct with Regroup parameters to
 *                         be modified.
 *
 * Returns:
 *
 *    int - 0 if successful; -1 if there is more than one node in the
 *    cluster. This is to prevent modification of timing parameters
 *    after the second node is added to the system.
 *
 * Algorithm:
 *
 *    Copies the contents of the user-passed struct into the one in the
 *    Regroup global memory and updates related parameters.
 *
 ************************************************************************/
_priv _resident int
RGP_SETRGPINFO(rgpinfo_t *rgpinfo)
{
   int error = 0;
   node_t i;

   /* If no rgpinfo structure is passed OR the version # of the
    * structure is not understood OR rgp_init() has not been called,
    * halt.
    */

   if ((rgpinfo == RGP_NULL_PTR) ||
       (rgpinfo->version != RGP_VERSION) ||
       (rgp == RGP_NULL_PTR))
      RGP_ERROR( RGP_INTERNAL_ERROR );

   RGP_LOCK;

   /* The following checks must be made before proceeding:
    *
    * 1. Regroup must not be perturbed.
    *
    * 2. If rgp_start() has been called (regroup is in the
    *    RGP_STABILIZED state), only the local node must be in the
    *    cluster when this routine is called.
    *
    * 3. If rgp_start() has been called, this routine can be used
    *    only to modify the timing parameters and not to specify the
    *    cluster.
    *
    * If these restrictions are not followed, return -1.
    */

   RGP_TRACE( "RGP SetRGPInfo  ",
              rgpinfo->version,                /* TRACE */
              rgpinfo->seqnum,                 /* TRACE */
              rgpinfo->iamalive_ticks,         /* TRACE */
              GetCluster( rgpinfo->cluster ) );/* TRACE */

   if (  rgp_is_perturbed() ||
         (  (rgp->rgppkt.stage == RGP_STABILIZED) &&
            (  (ClusterNumMembers(rgp->rgpinfo.cluster) > 1) ||
               !ClusterCompare(rgp->rgpinfo.cluster,rgpinfo->cluster)
            )
         )
      )
      error = -1;
   else
   {
      /* Copy the rgpinfo structure into regroup's internal struct. */
      rgp->rgpinfo = *rgpinfo;

      /* If iamalive_ticks is set to 0, use the default value instead. */        /*F40:KSK06102.2*/
      if (rgpinfo->iamalive_ticks == 0)                                          /*F40:KSK06102.3*/
         rgp->rgpinfo.iamalive_ticks = RGP_IAMALIVE_TICKS;                       /*F40:KSK06102.4*/
                                                                                 /*F40:KSK06102.5*/
          if (rgpinfo->check_ticks == 0)
          {
                 rgp->rgpinfo.check_ticks = RGP_CHECK_TICKS;
          }

          if (rgpinfo->Min_Stage1_ticks == 0)
                 rgp->rgpinfo.Min_Stage1_ticks =
                  (rgp->rgpinfo.iamalive_ticks * rgp->rgpinfo.check_ticks);

          if (rgpinfo->a_tick == 0)
                 rgp->rgpinfo.a_tick = RGP_CLOCK_PERIOD;

          // Tell Timer thread to restart RGP timer
          SetEvent (rgp->OS_specific_control.TimerSignal);


      /* The cluster should include the local node even if the cluster
       * field in the rgpinfo structure does not include it.
       */
      ClusterInsert(rgp->rgpinfo.cluster, rgp->mynode);

      /* Copy the sequence number into the regroup packet area. */
      rgp->rgppkt.seqno = rgp->rgpinfo.seqnum;

      /* Give the event epoch number and rgp sequence number to clusnet. */
      ClusnetRegroupFinished(NmClusnetHandle, 
                             rgp->OS_specific_control.EventEpoch,
                             rgp->rgpinfo.seqnum);

      /* If nodes have been added in the cluster field, they must be
       * added to all the screens and their status must be set to
       * alive.
       */

      ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);
      ClusterCopy(rgp->outerscreen,           rgp->rgpinfo.cluster);
#if defined( NT )
      ClusnetSetOuterscreen( NmClusnetHandle, (ULONG)*((PUSHORT)rgp->outerscreen) );
      ClusterComplement(rgp->ignorescreen, rgp->outerscreen);
#endif
      ClusterCopy(rgp->innerscreen,           rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage1,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage2,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage3,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage4,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.knownstage5,    rgp->rgpinfo.cluster);
      ClusterCopy(rgp->rgppkt.pruning_result, rgp->rgpinfo.cluster);
      rgp->tiebreaker = rgp_select_tiebreaker(rgp->rgpinfo.cluster);

      for (i = 0; i < (node_t) rgp->num_nodes; i++)
      {
         if (ClusterMember(rgp->rgpinfo.cluster, i))
         {
            rgp->node_states[i].pollstate = IAMALIVE_RECEIVED;
            rgp->node_states[i].status = RGP_NODE_ALIVE;

#if defined( NT )
            ClusnetSetNodeMembershipState(NmClusnetHandle,
                                          EXT_NODE( i ),
                                          ClusnetNodeStateAlive);
#endif // NT
         }
      }
      /* Reset the clock counter so that IamAlives are sent when
       * the next timer tick arrives.
       */
      rgp->clock_ticks = 0;
   }

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_start
 * =========
 *
 * Description:
 *
 *    This routine signals the end of node integration into the cluster.
 *    The node can now start participating in the Regroup algorithm.
 *
 * Parameters:
 *
 *    void (*rgp_node_failed)()
 *       pointer to a routine to be called when a node failure is
 *       detected.
 *
 *    int (*rgp_select_cluster)()
 *       pointer to an optional routine to be called when link failures
 *       cause multiple alternative clusters to be formed. This routine
 *       should select one from a list of suggested clusters.
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Installs the callback routines in the global data structure and
 *    changes the Regroup state to RGP_STABILIZED.
 *
 ************************************************************************/
_priv _resident void
RGP_START(void (*nodedown_callback)(cluster_t failed_nodes),
          int (*select_cluster)(cluster_t cluster_choices[], int num_clusters)
         )
{
   if (rgp == RGP_NULL_PTR)
      RGP_ERROR( RGP_INTERNAL_ERROR );

   RGP_LOCK;

   RGP_TRACE( "RGP Start called",
              rgp->rgppkt.stage,                /* TRACE */
              PtrToUlong(nodedown_callback),    /* TRACE */
              PtrToUlong(select_cluster),       /* TRACE */
              0 );                              /* TRACE */

   /* Install callback routines for node failure notification and cluster
    * selection. If no routine is given by the caller, use default ones.
    */

   if (nodedown_callback == RGP_NULL_PTR)
   {
#ifdef NSK
      /* In NSK, rgp_start() is called from pTAL code and passing routine
       * addresses is cumbersome. So, RGP_NULL_PTR is passed and we
       * call the routine rgp_node_failed() which must be supplied by
       * the message system.
       */
      rgp->nodedown_callback = rgp_node_failed; /* hardcoded name */
#else
      /* A node down callback routine must be supplied. */
      RGP_ERROR( RGP_INTERNAL_ERROR );
#endif /* NSK */
   }
   else
      rgp->nodedown_callback = nodedown_callback;
#if 0
   /* The select cluster routine is optional. */
   if (select_cluster == RGP_NULL_PTR)
      rgp->select_cluster = rgp_select_cluster; /* supplied by regroup */
   else
#endif
   //
   // Calling rgp_select_cluster is
   // not a good idea since it doesn't take into the consideration
   // quorum owner node. 
   // If rgp->select_cluster == RGP_NULL_PTR, then  srgpsm.c uses
   //   rgp_select_cluster_ex, that will try to select the group
   // that contain the current quorum owner node

   rgp->select_cluster = select_cluster;

#if defined(NT)
   /* Call the node up callback.  This is where the local node gets
    * the node up callback for itself coming up.  Other nodes call
    * the callback, for this node coming up, in rgp_monitor_node.
    */

   ClusterInsert(rgp->rgpinfo.cluster, rgp->mynode);
   ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);

   if ( rgp->OS_specific_control.UpDownCallback != RGP_NULL_PTR )
   {
      (*(rgp->OS_specific_control.UpDownCallback))(
          EXT_NODE(rgp->mynode),
          NODE_UP
          );
   }
#endif  /* NT */

   RGP_UNLOCK;

}

/************************************************************************
 * rgp_add_node
 * ============
 *
 * Description:
 *
 *    Called to add a newly booting node to the regroup masks. This prevents
 *    Regroup from sending poison packets to the new node when it tries to
 *    contact our node by sending IamAlive messages.
 *
 * Parameters:
 *
 *    node_t node - node to be added to the recognition masks
 *
 * Returns:
 *
 *    int - 0 on success and -1 on failure. The routine fails only if a
 *    regroup incident is in progress.
 *
 * Algorithm:
 *
 *    The node is added to all the recognition masks and its state is
 *    changed to RGP_NODE_COMING_UP.
 *
 ************************************************************************/
_priv _resident int
RGP_ADD_NODE(node_t node)
{
   int error = 0;

   RGP_LOCK;

   RGP_TRACE( "RGP Add node    ", node, rgp->rgppkt.stage,
              GetCluster(rgp->outerscreen),                 /* TRACE */
              GetCluster(rgp->rgpinfo.cluster) );           /* TRACE */

   /* Cannot add a node while regroup is perturbed. Return -1 in that case.
    * The new node booting should fail due to the regroup incident anyway.
    */
   if (rgp_is_perturbed())
      error = -1;
   else
   {
      node = INT_NODE(node); /* adjust the node number by the offset */

      ClusterInsert(rgp->outerscreen,           node);
#if defined( NT )
      ClusnetSetOuterscreen( NmClusnetHandle, (ULONG)*((PUSHORT)rgp->outerscreen) );
#endif
      ClusterInsert(rgp->innerscreen,           node);
      ClusterInsert(rgp->rgppkt.knownstage1,    node);
      ClusterInsert(rgp->rgppkt.knownstage2,    node);
      ClusterInsert(rgp->rgppkt.knownstage3,    node);
      ClusterInsert(rgp->rgppkt.knownstage4,    node);
      ClusterInsert(rgp->rgppkt.knownstage5,    node);
      ClusterInsert(rgp->rgppkt.pruning_result, node);
      rgp->node_states[node].pollstate = AWAITING_IAMALIVE;
      rgp->node_states[node].status = RGP_NODE_COMING_UP;
      rgp->node_states[node].lostHBs = 0;

#if defined( NT )
      ClusterDelete( rgp->OS_specific_control.Banished, node );

      //
      // Remove joining node from ignore screen
      //

      ClusterDelete( rgp->ignorescreen,                 node );
      PackIgnoreScreen(&rgp->rgppkt, rgp->ignorescreen);

      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( node ),
                                    ClusnetNodeStateJoining);
#endif // NT
   }

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_monitor_node
 * ================
 *
 * Description:
 *
 *    Called by all running nodes to change the status of a newly booted node
 *    to UP. Can be called by the new node also; it is a no-op in this case.
 *
 * Parameters:
 *
 *    node_t node - number of node being declared up
 *
 * Returns:
 *
 *    int - 0 on success and -1 on failure. The routine fails only if the
 *    state of the node is neither RGP_NODE_COMING_UP nor RGP_NODE_ALIVE.
 *
 * Algorithm:
 *
 *    If the node is marked coming up, its state is changed to
 *    RGP_NODE_ALIVE. If the node has already been marked up,
 *    nothing is done.
 *
 ************************************************************************/
_priv _resident int
RGP_MONITOR_NODE(node_t node)
{
   int error = 0;

   RGP_LOCK;

   RGP_TRACE( "RGP Monitor node", node, rgp->rgppkt.stage,
              GetCluster(rgp->outerscreen),                 /* TRACE */
              GetCluster(rgp->rgpinfo.cluster) );           /* TRACE */

   node = INT_NODE(node); /* adjust the node number by the offset */

   /* Accept the request only if the state of the node is COMING_UP or UP. */

   if (rgp->node_states[node].status == RGP_NODE_COMING_UP)
   {
      ClusterInsert(rgp->rgpinfo.cluster, node);
      rgp->tiebreaker = rgp_select_tiebreaker(rgp->rgpinfo.cluster);
      rgp->node_states[node].pollstate = IAMALIVE_RECEIVED;
      rgp->node_states[node].status = RGP_NODE_ALIVE;
#if defined(NT)
      ClusterCopy(rgp->OS_specific_control.CPUUPMASK, rgp->rgpinfo.cluster);

      ClusnetSetNodeMembershipState(NmClusnetHandle,
                                    EXT_NODE( node ),
                                    ClusnetNodeStateAlive);

      /* A node came up.  Call the node up callback. */
      if ( rgp->OS_specific_control.UpDownCallback != RGP_NULL_PTR )
      {
         (*(rgp->OS_specific_control.UpDownCallback))(
             EXT_NODE(node),
             NODE_UP
             );
      }
#endif  /* NT */

   }
   else if (rgp->node_states[node].status != RGP_NODE_ALIVE)
      /* Perhaps the booting node failed and regroup has already marked
       * it down. The cluster manager may have invoked a global update
       * resulting in this call before regroup reporetd the failure
       * of the node.
       */
      error = -1;

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_remove_node
 * ===============
 *
 * Description:
 *
 *    Called by the cluster manager to force out a booting node if booting
 *    fails. Regroup may or may not have already removed the booting node
 *    from the masks and declared it down, depending on what stage the
 *    booting is in and when the booting node failed.
 *
 *    Regroup can remove the node from the masks of all nodes in the cluster
 *    by simply starting a new incident of regroup with any event code. This
 *    will force all nodes to come to an agreement on cluster membership
 *    that excludes the booting node. If the booting node is alive, it will
 *    commit suicide since it will be in the incompetent (RGP_COLDLOADED)
 *    state.
 *
 *    Removing the new node from our masks is not necessary since regroup
 *    will detect the node failure and adjust the masks. If we do remove it
 *    from our masks BEFORE initiating regroup, regroup may complete quicker
 *    since we will not wait in stage 1 for the node to check in. Also, this
 *    could allow a node to be removed even after it is fully integrated.
 *    This is because our node will send a poison packet to the removed node
 *    if it tries to contact us.
 *
 *    But this "enhancement" is not implemented because it requires a new
 *    regroup event code which is examined by all nodes and processed
 *    specially. Currently, the regroup event code is used only for
 *    debugging info. Also, there is no guarantee that all nodes see the
 *    same regroup reason code. For instance, some may see a missing
 *    IamAlive while others may see a power failure.
 *
 * Parameters:
 *
 *    node_t node - node to be removed from the recognition masks
 *                  (in external format).
 *
 * Returns:
 *
 *    int - 0 on success and -1 on failure. The routine fails if a
 *    regroup incident is in progress or rgp_start() has not been
 *    called (as in a new node where the booting is not complete).
 *
 * Algorithm:
 *
 *    If the node is still in the recognition masks, a new regroup incident
 *    is started. This incident will result in all nodes declaring the node
 *    dead and removing it from the recognition masks.
 *
 ************************************************************************/
_priv _resident int
RGP_REMOVE_NODE(node_t node)
{
   int error = 0;

   RGP_LOCK;

   RGP_TRACE( "RGP Remove node ", node, rgp->rgppkt.stage,
              GetCluster(rgp->outerscreen),                 /* TRACE */
              GetCluster(rgp->rgpinfo.cluster) );           /* TRACE */

   if (rgp->rgppkt.stage == RGP_STABILIZED)
   {
      if (ClusterMember(rgp->outerscreen, INT_NODE(node)))
      {
         /* Node is currently in our screen. The node may have never come up
          * after rgp_add_node() was called OR regroup may not have figured
          * out yet that the node is down. In either case, the node must
          * be forced out and all nodes in the cluster notified (by a regroup
          * incident). If the node is still running, it will commit suicide
          * when this regroup incident starts.
          */

         rgp_event_handler(RGP_EVT_LATEPOLLPACKET, node);
      }
      else
      {
         /* Either the node was not added to the cluster OR regroup has
          * already figured out that the node is dead and reported this.
          * In either case, there is nothing more to do.
          */
      }
   }
   else
      error = -1;

   RGP_UNLOCK;

   return(error);
}


/************************************************************************
 * rgp_is_perturbed
 * ================
 *
 * Description:
 *
 *    Function to check if a regroup incident is in progress.
 *
 * Parameters:
 *
 *    None.
 *
 * Returns:
 *
 *    int - 0 if no regroup is quiescent; non-zero if a regroup incident
 *    is in progress.
 *
 * Algorithm:
 *
 *    Looks at the current state of the Regroup algorithm.
 *
 ************************************************************************/
_priv _resident int
RGP_IS_PERTURBED(void)
{
   uint8 stage = rgp->rgppkt.stage;

   return((stage != RGP_STABILIZED) && (stage != RGP_COLDLOADED));
}


/************************************************************************
 * rgp_periodic_check
 * ==================
 *
 * Description:
 *
 *    This routine is invoked every RGP_CLOCK_PERIOD by the timer interrupt
 *    handler of the native OS. It performs Regroups's periodic operations.
 *
 * Parameters:
 *
 *    None
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    This routine requests Iamalive packets to be sent, checks if
 *    IamAlives have been received (and calls rgp_event_handler() if
 *    not) and sends a clock tick to the regroup algorithm if it is in
 *    progress.
 *
 *    IamAlives are checked at twice the IamAlive period. The regroup
 *    global variable clock_ticks is incremented in each call. After
 *    the IamAlives are checked, clock_ticks is reset to 0. Thus, the
 *    ticker counts time modulo twice the IamAlive ticks.
 *
 ************************************************************************/
_priv _resident void
RGP_PERIODIC_CHECK(void)
{
   node_t  node;

   RGP_LOCK;

   /* If regroup is active, give it a shot at each regroup clock tick. */

   if ((rgp->rgppkt.stage != RGP_STABILIZED) &&
       (rgp->rgppkt.stage != RGP_COLDLOADED))
      rgp_event_handler(RGP_EVT_CLOCK_TICK, RGP_NULL_NODE);

#if !defined( NT )
   /* Send IamAlive messages at appropriate intervals. */

   if ( (rgp->clock_ticks == 0) ||
        (rgp->clock_ticks == rgp->rgpinfo.iamalive_ticks) )
   {
      rgp_broadcast(RGP_UNACK_IAMALIVE);
      rgp->clock_ticks++;
   }

   /* Check for missing IamAlives at IamAlive sending period,
    * But flag an error (LATE_POLL) only if "check_ticks" IamAlives missed.
    * The checking is offset from the sending by one clock tick.
    */

   else if ( rgp->clock_ticks >= (rgp->rgpinfo.iamalive_ticks - 1) )
   { /* check all nodes for IamAlives received */

      for (node = 0; node < (node_t) rgp->num_nodes; node++)
      {
         if (rgp->node_states[node].status == RGP_NODE_ALIVE)
         {
            if ( rgp->node_states[node].pollstate == IAMALIVE_RECEIVED )
            {  /* checked in in time */
#if defined(TDM_DEBUG)
               if ( rgp->OS_specific_control.debug.doing_tracing )
               {
                  printf ("Node %d: Node %d is alive. My rgp state=%d\n",
                     EXT_NODE(rgp->mynode), EXT_NODE(node), rgp->rgppkt.stage );
               }
#endif
               rgp->node_states[node].pollstate = AWAITING_IAMALIVE;
               rgp->node_states[node].lostHBs = 0;
            }
            else if ( rgp->node_states[node].lostHBs++ < rgp->rgpinfo.check_ticks )
               ;// allow upto (check_ticks-1) IamAlives to be lost.
            else
            {
               /* missing IamAlives */
               if (node == rgp->mynode) /* missed my own packets */
               {
                  /* We should be lenient if we just had a power failure.
                   */
                  if (rgp->pfail_state == 0) /* no recent power failure */
                     RGP_ERROR( RGP_MISSED_POLL_TO_SELF );
               }
               else
                  rgp_event_handler(RGP_EVT_LATEPOLLPACKET, EXT_NODE(node));
            }
         }
      }

      /* Reset the regroup tick counter after checking for IamAlives. */
      rgp->clock_ticks = 0;

   } /* check all nodes for IamAlives received */

   else
      rgp->clock_ticks++;

   /* rgp->pfail_state is set to a non-zero value when a pfail event
    * is reported to regroup. It is decremented at every regroup clock
    * tick till it reaches zero. While this number is non-zero, missing
    * self IamAlives are ignored and do not cause the node to halt.
    * This gives the sending hardware some time to recover from power
    * failures before self IamAlives are checked.
    */
   if (rgp->pfail_state)
      rgp->pfail_state--;

#endif // NT

   RGP_UNLOCK;

}  /* rgp_periodic_check */


/************************************************************************
 * rgp_received_packet
 * ===================
 *
 * Description:
 *
 *    Routine to be called by the message system when an unacknowledged
 *    packet sent by the Regroup module is received from any node. These
 *    packets include IamAlive packets, regroup status packets and poison
 *    packets.
 *
 * Parameters:
 *
 *    node_t node      - node from which a packet has been received
 *
 *    void   *packet   - address of the received packet data
 *
 *    int    packetlen - length in bytes of the received packet data
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Does different things based on the packet subtype.
 *
 ************************************************************************/
_priv _resident void
RGP_RECEIVED_PACKET(node_t node, void *packet, int packetlen)
{
   rgp_unseq_pkt_t *unseq_pkt = (rgp_unseq_pkt_t *) packet;

   node = INT_NODE(node);

   /* If the packet is from a node that cannot be in our cluster,
    * simply ignore it.
    */
   if (node >= (node_t) rgp->num_nodes)
      return;

   /* If the sending node is excluded by the outer screen, then it is
    * not part of the current (most recently known) configuration.
    * Therefore the packet should not be honored, and a poison message
    * should be sent to try to kill this renegade processor unless
    * it is sending US a poison packet. If it is sending us a poison
    * packet, we cannot send it a poison in return because that results
    * in an infinite loop. In this case, we just halt because this
    * situation implies that there is a split brain situation and our
    * split brain avoidance algorithm has failed.
    */

   /* NT Notes
    *
    * even with poison pkts being sent and recv'ed in the kernel, we still
    * want to make these checks since clusnet doesn't have the regroup stage
    * info and regroup packets themselves find there way in here.
    */

   if (!ClusterMember(rgp->outerscreen, node)
#if defined( NT )
       ||
       ClusterMember(rgp->OS_specific_control.Banished, node)
#endif
      )
   {
       if (rgp->rgppkt.stage == RGP_COLDLOADED)
       {
           // We are doing this check in srgpsm.c
           // No need to do it here
           // RGP_ERROR(RGP_RELOADFAILED);
           //
       }
       else if (unseq_pkt->pktsubtype == RGP_UNACK_POISON)
       {
           RGP_ERROR((uint16) (RGP_PARIAH + EXT_NODE(node)));
       } else {
           /* Must send a poison packet to the sender.
            */
           ClusterInsert(rgp->poison_targets, node);
           rgp_broadcast(RGP_UNACK_POISON);
       }
       return;
   }

   switch (unseq_pkt->pktsubtype)
   {
      case RGP_UNACK_IAMALIVE :
      {
         /* Count the number of IamAlives received */
         if ( node == rgp->mynode )
             RGP_INCREMENT_COUNTER( RcvdLocalIAmAlive );
         else
             RGP_INCREMENT_COUNTER( RcvdRemoteIAmAlive );

         if (rgp->node_states[node].status == RGP_NODE_ALIVE)
            rgp->node_states[node].pollstate = IAMALIVE_RECEIVED;

         else if (rgp->node_states[node].status == RGP_NODE_COMING_UP)
         {
            /* If the node has not yet been marked fully up, it is time to
             * do so.
             */
            rgp_monitor_node(EXT_NODE(node));

            /* We must tell the OS that the new node is up in case the
             * OS needs the IamAlives to figure that out.
             */
            rgp_newnode_online(EXT_NODE(node));
         }
         else
            /* If the node state is neither alive nor coming up, it
             * must not be in our outerscreen. The outerscreen check
             * above must have passed and we should not get here.
             */
            RGP_ERROR(RGP_INTERNAL_ERROR);

         break;
      }
      case RGP_UNACK_REGROUP  :
      {
         /* Count the number of regroup status packets received. */
         RGP_INCREMENT_COUNTER( RcvdRegroup );

         /* Any good packet can be treated as an IamAlive packet. */
         rgp->node_states[node].pollstate = IAMALIVE_RECEIVED;

         RGP_EVENT_HANDLER_EX (RGP_EVT_RECEIVED_PACKET, EXT_NODE(node), (void*)unseq_pkt);
         break;
      }
      case RGP_UNACK_POISON   :
      {
         /* If our node is in RGP_PRUNING stage and have been pruned out,
          * the poison packet probably implies that the sender has gone
          * into the next stage and declared us down. In this case, use
          * the more appropriate RGP_PRUNED_OUT halt code. Otherwise,
          * use the poison packet halt code. In either case, we must halt.
          */
          if ( (rgp->rgppkt.stage == RGP_PRUNING) &&
               !ClusterMember(rgp->rgppkt.pruning_result, rgp->mynode) )
              RGP_ERROR(RGP_PRUNED_OUT);
          else
          {
              if (rgp->rgppkt.stage == RGP_COLDLOADED)
                  {
                      RGP_ERROR(RGP_RELOADFAILED);
                      return;
                  }
                  else
                      RGP_ERROR((uint16) (RGP_PARIAH + EXT_NODE(node)));
          }
          break;
      }
      default                   :
      {
         /* Ignore the unknown packet type. */
         break;
      }
   }
}
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.6*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\wrgpos.h ===
#ifndef  _WRGPOS_H_
#define  _WRGPOS_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "wrgpos.h - T9050 - OS-dependent external decs for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (wrgpos.h) contains OS-specific declarations used by
 * srgpos.c.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


/*-----------------------------------NSK section-----------------------------*/
#ifdef NSK

#include <dmilli.h>
#include <jmsgtrc.h>
#define QUEUESEND        _send_queued_()

/* Regroup tracing macro */
/* In NSK, regroup uses the trace buffer and macro provided by the
 * message system. Regroup puts TR_NODATA for the trace type.
 */
#define RGP_TRACE( str,            parm1, parm2, parm3, parm4 ) \
        TRACE_L1 ( str, TR_NODATA, parm1, parm2, parm3, parm4 )

/* Regroup counters */
/* In NSK, regroup uses the counter buffer and macro provided by the
 * message system.
 */
#define RGP_INCREMENT_COUNTER    TCount

/* Macros to lock and unlock the regroup data structure to prevent
 * access by interrupt handlers or other processors (in SMP nodes).
 */

/* On NSK with uniprocessor nodes, these macros must mask off the
 * interrupt handlers that can access the regroup structure, namely,
 * the IPC and timer interrupts.
 *
 * To avoid complexities due to nesting of MUTEXes, the regroup locks
 * are defined to be no-ops. The NSK caller of all regroup routines
 * (except the inquiry routines rgp_estimate_memory, rgp_sequence_number
 * and rgp_is_perturbed) must ensure that IPC and timer interrupts are
 * disabled before calling the regroup routine.
 */
#define RGP_LOCK      /* null; NSK must ensure that timer and IPC interrupts
                         are disabled before calling regroup routines. */
#define RGP_UNLOCK    /* null; NSK must ensure that timer and IPC interrupts
                         are disabled before calling regroup routines. */

#ifdef __TANDEM
#pragma fieldalign shared8 OS_specific_rgp_control
#endif /* __TANDEM */

typedef struct OS_specific_rgp_control
{
   uint32 filler; /* no special fields needed for NSK */
} OS_specific_rgp_control_t;

#endif /* NSK */
/*-----------------------------end of NSK section----------------------------*/


/*-----------------------------------LCU section-----------------------------*/
#ifdef LCU

#include <lcuxprt.h>
#define LCU_RGP_PORT     0           /* pick up from appropriate file */
#define HZ             100           /* pick up from appropriate file */
#define plstr            0           /* pick up from appropriate file */
#define TO_PERIODIC      0           /* pick up from appropriate file */
#define CE_PANIC         3           /* pick up from appropriate file */

#define LCU_RGP_FLAGS    (LCUF_SENDMSG || LCUF_NOSLEEP) /* msg alloc flags */

extern void rgp_msgsys_work(lcumsg_t *lcumsgp, int status);
#define QUEUESEND        rgp_msgsys_work(NULL, 0)

/* Regroup tracing macro */
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 ) /* empty for now */

/* Regroup counters */
typedef struct
{
   uint32   QueuedIAmAlive;
   uint32   RcvdLocalIAmAlive;
   uint32   RcvdRemoteIAmAlive;
   uint32   RcvdRegroup;
} rgp_counter_t;
#define RGP_INCREMENT_COUNTER( field ) rgp->OS_specific_control.counter.field++

/* Regroup locks */

typedef struct rgp_lock
{
   uint32 var1;
   uint32 var2;
} rgp_lock_t;

/* Macros to lock and unlock the regroup data structure to prevent
 * access by interrupt handlers or other processors (in SMP nodes)
 */

#define RGP_LOCK      /* null for now; need to be filled in */
#define RGP_UNLOCK    /* null for now; need to be filled in */

typedef struct
{
   rgp_lock_t rgp_lock;         /* to serialize access               */

   rgp_counter_t counter;       /* to count events                   */

   lcumsg_t *lcumsg_regroup_p;  /* pointer to regroup status message */
   lcumsg_t *lcumsg_iamalive_p; /* pointer to iamalive message       */
   lcumsg_t *lcumsg_poison_p;   /* pointer to poison message         */

   sysnum_t my_sysnum;          /* local system number               */
} OS_specific_rgp_control_t;

#endif /* LCU */
/*-----------------------------end of LCU section----------------------------*/


/*----------------------------------UNIX section-----------------------------*/
#ifdef UNIX

extern void rgp_msgsys_work(void);
#define QUEUESEND  rgp_msgsys_work();

#include <jrgp.h>
#include <wrgp.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
#include <stdio.h>

extern int errno;

#define MSG_FLAGS      0     /* flags for message send/receive */
#define RGP_PORT_BASE  5757  /* for use with sockets */

typedef struct
{
   int event;
   union
   {
      node_t node;
      rgpinfo_t rgpinfo;
   } data;                /* depends on the event */
   rgp_unseq_pkt_t unseq_pkt;
} rgp_msgbuf;

#define BUFLEN sizeof(rgp_msgbuf)

/* Additional events created for testing regroup using process-level
 * simulation.
 */
#define RGP_EVT_START                   10
#define RGP_EVT_ADD_NODE                11
#define RGP_EVT_MONITOR_NODE            12
#define RGP_EVT_REMOVE_NODE             13
#define RGP_EVT_GETRGPINFO              14
#define RGP_EVT_SETRGPINFO              15

#define RGP_EVT_HALT                    16
#define RGP_EVT_FREEZE                  17
#define RGP_EVT_THAW                    18
#define RGP_EVT_STOP_SENDING            19
#define RGP_EVT_RESUME_SENDING          20
#define RGP_EVT_STOP_RECEIVING          21
#define RGP_EVT_RESUME_RECEIVING        22
#define RGP_EVT_SEND_POISON             23
#define RGP_EVT_STOP_TIMER_POPS         24
#define RGP_EVT_RESUME_TIMER_POPS       25
#define RGP_EVT_RELOAD                  26

#define RGP_EVT_FIRST_EVENT              1
#define RGP_EVT_FIRST_DEBUG_EVENT       10
#define RGP_EVT_LAST_EVENT              26

/* Regroup tracing macro */
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 )                  \
   do                                                                 \
   {                                                                  \
      printf("Node %3d: %16s: 0x%8X, 0x%8X, 0x%8X, 0x%8X.\n",         \
             EXT_NODE(rgp->mynode), str, parm1, parm2, parm3, parm4); \
      fflush(stdout);                                                 \
   } while (0)

/* Regroup counters */
typedef struct
{
   uint32   QueuedIAmAlive;
   uint32   RcvdLocalIAmAlive;
   uint32   RcvdRemoteIAmAlive;
   uint32   RcvdRegroup;
} rgp_counter_t;
#define RGP_INCREMENT_COUNTER( field ) rgp->OS_specific_control.counter.field++

/* Macros to lock and unlock the regroup data structure to prevent
 * access by interrupt handlers or other processors (in SMP nodes)
 */
#define RGP_LOCK      /* null; all access done from one thread */
#define RGP_UNLOCK    /* null; all access done from one thread */

/* This struct keeps some debugging info. */
typedef struct rgpdebug
{
   uint32 frozen              :  1; /* node is frozen; ignore all events except
                                       the thaw command */
   uint32 reload_in_progress  :  1; /* reload in progess; if set, refuse
                                       new reload command */
   uint32 unused              : 30;
   cluster_t stop_sending;   /* stop sending to these nodes */
   cluster_t stop_receiving; /* stop receiving from these nodes */
} rgp_debug_t;

typedef struct
{
   rgp_counter_t    counter;     /* to count events                    */
   rgp_debug_t      debug;       /* for debugging purposes             */
} OS_specific_rgp_control_t;

/* Variables and routines provided by the srgpsvr.c driver program */

extern unsigned int alarm_period;

extern void alarm_handler(void);
extern void (*alarm_callback)();
extern void rgp_send(node_t node, void *data, int datasize);
extern void rgp_msgsys_work();

#endif /* UNIX */
/*----------------------------end of UNIX section----------------------------*/

/*----------------------------------NT section-----------------------------*/
#ifdef NT

extern void rgp_msgsys_work(void);
#define QUEUESEND  rgp_msgsys_work();

#if !defined (TDM_DEBUG)
#define LOG_CURRENT_MODULE LOG_MODULE_MM
#include <service.h>
#include <winsock2.h>
#else //TDM_DEBUG
#define _WIN32_WINNT 0x0400
#include <mmapi.h>
#include <time.h>
extern int errno;
#endif

#include <jrgp.h>
#include <wrgp.h>
#include <stdlib.h>
#include <sys/types.h>
#include <errno.h>
#include <stdio.h>
#include <windows.h>
#include <clmsg.h>

#undef small	// otherwise we have to change a bunch of our code


typedef struct
{
   int event;
   union
   {
      node_t node;
      rgpinfo_t rgpinfo;
   } data;                /* depends on the event */
   rgp_unseq_pkt_t unseq_pkt;
} rgp_msgbuf;

#define BUFLEN sizeof(rgp_msgbuf)

/* Additional events created for testing regroup using process-level
 * simulation.
 */
#define RGP_EVT_START                   10
#define RGP_EVT_ADD_NODE                11
#define RGP_EVT_MONITOR_NODE            12
#define RGP_EVT_REMOVE_NODE             13
#define RGP_EVT_GETRGPINFO              14
#define RGP_EVT_SETRGPINFO              15

#define RGP_EVT_HALT                    16
#define RGP_EVT_FREEZE                  17
#define RGP_EVT_THAW                    18
#define RGP_EVT_STOP_SENDING            19
#define RGP_EVT_RESUME_SENDING          20
#define RGP_EVT_STOP_RECEIVING          21
#define RGP_EVT_RESUME_RECEIVING        22
#define RGP_EVT_SEND_POISON             23
#define RGP_EVT_STOP_TIMER_POPS         24
#define RGP_EVT_RESUME_TIMER_POPS       25
#define RGP_EVT_RELOAD                  26
#define RGP_EVT_TRACING					27
#define RGP_EVT_INFO					28

// MM events

#define MM_EVT_EJECT					29
#define MM_EVT_LEAVE					30
#define MM_EVT_INSERT_TESTPOINTS		31

#define RGP_EVT_FIRST_EVENT              1
#define RGP_EVT_FIRST_DEBUG_EVENT       10
#define RGP_EVT_LAST_EVENT              31


/* internal timeout for acknowledged messages */
#define RGP_ACKMSG_TIMEOUT			  500    // 0.5 seconds


/* Regroup tracing macro */
#if defined (TDM_DEBUG)
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 )                  \
 if ( rgp->OS_specific_control.debug.doing_tracing )				  \
   do                                                                 \
   {                                                                  \
      printf("Node %3d: %16hs: 0x%8X, 0x%8X, 0x%8X, 0x%8X.\n",         \
             EXT_NODE(rgp->mynode), str, parm1, parm2, parm3, parm4); \
      fflush(stdout);                                                 \
   } while (0)
#else  // WOLFPACK
#define RGP_TRACE( str, parm1, parm2, parm3, parm4 )                    \
    ClRtlLogPrint(LOG_NOISE,                                               \
               "[RGP] Node %1!d!: %2!16hs!: 0x%3!x!, 0x%4!x!, 0x%5!x!, 0x%6!x!.\n",  \
               EXT_NODE(rgp->mynode), str, parm1, parm2, parm3, parm4)
#endif

/* Regroup counters */
typedef struct
{
   uint32   QueuedIAmAlive;
   uint32   RcvdLocalIAmAlive;
   uint32   RcvdRemoteIAmAlive;
   uint32   RcvdRegroup;
} rgp_counter_t;
#define RGP_INCREMENT_COUNTER( field ) rgp->OS_specific_control.counter.field++

/* Macros to lock and unlock the regroup data structure to prevent
 * access from other concurrent threads.
 */
#define RGP_LOCK	EnterCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );
#define RGP_UNLOCK	LeaveCriticalSection( &rgp->OS_specific_control.RgpCriticalSection );

#if defined(TDM_DEBUG)
typedef union {
		struct {
			uint32	joinfailADD		:	1;
			uint32	joinfailMON		:	1;
			uint32	description3	:	1;
			uint32	description4	:	1;
			uint32	description5	:	1;
			uint32	description6	:	1;
			uint32	description7	:	1;
			uint32	description8	:	1;
			uint32	description9	:	1;
			uint32	description10	:	1;
			uint32	description11	:	1;
			uint32	description12	:	1;
			uint32	description13	:	1;
			uint32	description14	:	1;
			uint32	description15	:	1;
			uint32	description16	:	1;
			uint32	morebits	:	16;	
		} TestPointBits;
		uint32	TestPointWord;
}TestPointInfo;

/* This struct keeps some debugging info. */
typedef struct rgpdebug
{
   uint32 frozen              :  1; /* node is frozen; ignore all events except
                                       the thaw command */
   uint32 reload_in_progress  :  1; /* reload in progess; if set, refuse
                                       new reload command */
   uint32 timer_frozen		  :  1; /* timer pops are ignored */
   uint32 doing_tracing		  :  1; /* whether or not RGP_TRACE is a nop */
   uint32 unused              : 28;
   cluster_t stop_sending;   /* stop sending to these nodes */
   cluster_t stop_receiving; /* stop receiving from these nodes */
   TestPointInfo MyTestPoints; /* Controls test points for error/other insertion */
} rgp_debug_t;

#endif // TDM_DEBUG

typedef struct
{
   rgp_counter_t    counter;     /* to count events                    */
   HANDLE			TimerThread; /* HANDLE of HeartBeat timer thread */
   DWORD			TimerThreadId;/* Thread ID of HeartBeat timer thread */
   HANDLE			TimerSignal; /* Event used to change HB rate and cause Terminate */
   HANDLE			RGPTimer; /* Regroup Timer - Used by timer thread */
   CRITICAL_SECTION	RgpCriticalSection; /* CriticalSection object for regroup activities */
   ULONG            EventEpoch; /* used to detect stale events from clusnet */
   MMNodeChange		UpDownCallback; /*Callback to announce node up and node down event*/
   MMQuorumSelect   QuorumCallback; /*Callback to check if Quorum disk accessible - split brain avoidance */
   MMHoldAllIO		HoldIOCallback; /*Callback to suspend all IO and message activity during early regroup */
   MMResumeAllIO	ResumeIOCallback; /*Callback to resume all IO and message activity after PRUNING stage */
   MMMsgCleanup1	MsgCleanup1Callback; /*Callback for Phase1 Message system cleanup from down node */
   MMMsgCleanup2	MsgCleanup2Callback; /*Callback for Phase2 Message system cleanup to down node */
   MMHalt			HaltCallback; /*Callback to announce internal error or Poison packet or cluster ejection */
   MMJoinFailed		JoinFailedCallback; /*Callback to announce failure to join cluster. Retry required */
   MMNodesDown      NodesDownCallback; /* Callback to announce failure of one or more nodes.*/
   cluster_t		CPUUPMASK;   /* Bitmask of UP Nodes for consistent Info api */
   cluster_t		NeedsNodeDownCallback;	/* node(s) went down, need to do UpDown callback */
   cluster_t        Banished; /* mask of banished nodes */

   HANDLE           Stabilized; /* event which is set when the regroup is not active */
   BOOL             ArbitrationInProgress; /* it is set to True while regroup waits for arbitate callback to return */
   DWORD            ArbitratingNode; /* MM_INVALID_NODE or the arbitrating node (last regroup)*/
   DWORD            ApproxArbitrationWinner; /* Like ArbitratingNode, but spans multiple regroups */
   BOOL             ShuttingDown; /* indicate that a node is shutting done */
   cluster_t          MulticastReachable; /* indicate which nodes can be reachable via mcast */

#if defined( TDM_DEBUG )
   rgp_debug_t      debug;       /* for debugging purposes             */
#endif

} OS_specific_rgp_control_t;

extern DWORD  QuorumOwner;  /* updated by SetQuorumOwner and successful arbitrator*/
  /* this variable can be set by the first node coming up before Mm is initialized */

/* Variables and routines provided by the srgpsvr.c driver program */

extern unsigned int alarm_period;

//extern void alarm_handler(void);
//extern void (*alarm_callback)();
extern void rgp_send(node_t node, void *data, int datasize);
extern void rgp_msgsys_work();

#endif /* NT */
/*----------------------------end of NT section----------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------

#endif    /* 0 - change descriptions */


#endif  /* _WRGPOS_H_ defined */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\wrgp.h ===
#ifndef  _WRGP_H_
#define  _WRGP_H_

#ifdef __TANDEM
#pragma columns 79
#pragma page "wrgp.h - T9050 - internal declarations for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (wrgp.h) contains the cluster_t data type and types used for the
 * node pruning algorithm and declares the routines exported by the Cluster
 * data type and the node pruning algorithm.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <jrgp.h>
#include <wrgpos.h>
#include <bitset.h>

#define RGP_VERSION               1          /* version # of data structures */
#define RGP_INITSEQNUM            0          /* starting seq# # of regroup   */


#define RGPPKTLEN sizeof(rgp_pkt_t)          /* byte length of regroup pkts  */
#define IAMALIVEPKTLEN sizeof(iamalive_pkt_t)/* byte length of IamAlive pkts */
#define POISONPKTLEN sizeof(poison_pkt_t)    /* byte length of poison pkts   */


/*-------------------------------------------------------*/
/* The following are the stages of the regroup algorithm */
/*-------------------------------------------------------*/

#define   RGP_COLDLOADED               0
#define   RGP_ACTIVATED                1
#define   RGP_CLOSING                  2
#define   RGP_PRUNING                  3
#define   RGP_PHASE1_CLEANUP           4
#define   RGP_PHASE2_CLEANUP           5
#define   RGP_STABILIZED               6


/*--------------------------------------------------------------------*/
/* Macros to transform node numbers used by the OS to node numbers    */
/* used by the Regroup module and vice versa. Regroup's internal node */
/* numbers start at 0 while the OS starts node numbers at             */
/* LOWEST_NODENUM.                                                    */
/*--------------------------------------------------------------------*/
#define EXT_NODE(int_node) ((node_t)(int_node + LOWEST_NODENUM))
#define INT_NODE(ext_node) ((node_t)(ext_node - LOWEST_NODENUM))


/*----------------------------------------*/
/* Defines for the node pruning algorithm */
/*----------------------------------------*/

/* The data type "cluster_t" is a bit array of size equal to the maximum
 * number of nodes in the cluster. The bit array is implemented as an
 * array of uint8s.
 *
 * Given a node#, its bit position in the bit array is computed by first
 * locating the byte in the array (node# / BYTEL) and then the bit in
 * the byte. Bits in the byte are numbered 0..7 (from left to right).
 * Thus, node 0 is placed in byte 0, bit 0, which is the left-most bit
 * in the bit array.
 */
#define BYTE(cluster, node) ( (cluster)[(node) / BYTEL] ) /* byte# in array */
#define BIT(node)           ( (node) % BYTEL )            /* bit# in byte   */


/* The connectivity matrix is an array of elements of type cluster_t.
 * cluster_t is equivalent to a bit array with one bit per node. Thus the
 * matrix is equivalent to a two-dimensional bit array, with each
 * dimension being MAX_CLUSTER_SIZE large. A bit value of 1 for matrix[i][j]
 * represents a unidirectional connection between nodes i and j (a
 * regroup packet received on node i from node j).
 */

typedef cluster_t  connectivity_matrix_t[MAX_CLUSTER_SIZE];


#define connected(i,j) (ClusterMember(c[(int)i],j) && \
                        ClusterMember(c[(int)j],i))  /* bidirectional */

/* Should a node that cannot receive its own regroup packets be considered
 * dead? Not necessarily. It may be able to send packets to others and
 * be considered alive by everyone. There is no real need for the ability
 * to send to yourself on the network. Software bugs could result in
 * such a situation. Therefore, the correct way to check if a node is
 * alive would be to check if there is a non-zero bit in either the row
 * or column corresponding to the node; that is, if the node has
 * received regroup packets from or sent regroup packets to any node,
 * it may be considered alive. But for simplicity, we will assume in
 * the following macro that a node that does not receive its own
 * regroup packets will be considered dead.
 */

#define node_considered_alive(i)   ClusterMember(c[(int)i],i)

/* The upper bound on the number of potential fully-connected groups is
 * the lower of 2**N and 2**D where N is the number of live nodes and
 * D is the number of disconnects. If this number exceeds MAX_GROUPS,
 * do not attempt to exhaustively generate all possible groups;
 * just return an arbitrary fully-connected group which includes a
 * node selected by the cluster manager.
 */
#define MAX_GROUPS      256  /* if more than these, pick arbitrary group */
#define LOG2_MAX_GROUPS   8  /* log (base 2) of MAX_GROUPS               */

#define too_many_groups(nodes, disconnects) \
        ((nodes > LOG2_MAX_GROUPS) && (disconnects > LOG2_MAX_GROUPS))

/* The disconnect array is an array of (i,j) pairs which represent a
 * break in connectivity between nodes i and j.
 */

typedef node_t disconnect_array [LOG2_MAX_GROUPS * (LOG2_MAX_GROUPS-1)/2] [2];


/*---------------------------------------------------------------------------*/
/* Following are templates for three kinds of unacknowledged datagrams sent  */
/* by the regroup module (regroup pkts, IamAlive pkts and poison pkts).      */
/*---------------------------------------------------------------------------*/

//
// We already hand packed all on the wire structures.
// packon will instruct the compiler not to mess with field alignment (kind of)
//
#include <packon.h>

/************************************************************************
 * rgp_pkt_t (regroup status packet)
 * ---------------------------------
 * This structure is used to send the current state of the regroup state
 * machine to other nodes.
 *
 *      ___________________________________________________________
 * wd0 |  pktsubtype |  stage        |      reason   | Low8 ignscr |
 *     |_____________|_______________|_____________________________|
 * wd1 |                         seqno                             |
 *     |_____________________________|_____________________________|
 * wd2 |   activa-   | causingnode   |       quorumowner           |
 *     |   tingnode  |  Hi8  ignscr  |     (was hadpowerfail)      |
 *     |_____________|_______________|_____________________________|
 * wd3 |   knownstage1               |    knownstage2              |
 *     |_____________________________|_____________________________|
 * wd4 |   knownstage3               |    knownstage4              |
 *     |_____________________________|_____________________________|
 * wd5 |   knownstage5               |    pruning_result           |
 *     |_____________________________|_____________________________|
 * wd6 :                                                           :
 *     |               connectivity_matrix                         |
 *     :                                                           :
 * wd13|___________________________________________________________|
 *
 *
 * pktsubtype            - packet subtype = RGP_UNACK_REGROUP
 * stage                 - current stage (state) of the regroup algorithm
 * reason                - reason for the activation of regroup
 * seqno                 - sequence number of current regroup incident
 * activatingnode        - node that calls for a regroup incident
 * causingnode           - node whose poll packet was missed or which
 *                         had a power failure or otherwise caused
 *                         a regroup incident being called for
 * quorumowner           - mask of nodes that think they own the quorum resrc
 * knownstage1           - mask of nodes known to have entered stage 1
 * knownstage2           - mask of nodes known to have entered stage 2
 * knownstage3           - mask of nodes known to have entered stage 3
 * knownstage4           - mask of nodes known to have entered stage 4
 * knownstage5           - mask of nodes known to have entered stage 5
 * pruning_result        - result of node pruning by tie-breaker node
 * connectivity_matrix   - current connectivity info for entire cluster
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 rgp_pkt
#endif /* __TANDEM */

typedef struct rgp_pkt
{
   uint8                   pktsubtype;
   uint8                   stage;
   uint16                  reason;
   uint32                  seqno;
   uint8                   activatingnode;
   uint8                   causingnode;
   cluster_t               quorumowner;
   cluster_t               knownstage1;
   cluster_t               knownstage2;
   cluster_t               knownstage3;
   cluster_t               knownstage4;
   cluster_t               knownstage5;
   cluster_t               pruning_result;
   connectivity_matrix_t   connectivity_matrix;
} rgp_pkt_t;

/************************************************************************
 * iamalive_pkt_t
 * --------------
 * This structure is used by a node to indicate to another node that it
 * is alive and well.
 *
 *      ___________________________________________________________
 * wd0 |  pktsubtype |     filler                                  |
 *     |_____________|_____________________________________________|
 * wd1 :                                                           :
 *     |                   testpattern                             |
 *     :                                                           :
 * wd13|___________________________________________________________|
 *
 *
 * pktsubtype            - packet subtype = RGP_UNACK_IAMALIVE
 * testpattern           - a bit pattern used for testing
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 iamalive_pkt
#endif /* __TANDEM */

typedef struct iamalive_pkt
{
   uint8   pktsubtype;
   uint8   filler[3];
   union
   {
      uint8   bytes[RGP_UNACK_PKTLEN - 4];
      uint32  words[(RGP_UNACK_PKTLEN - 4)/4];
   } testpattern;
} iamalive_pkt_t;


/************************************************************************
 * poison_pkt_t
 * ------------
 * This structure is used to send a poison packet to another node to
 * force the other node to halt.
 *
 *      ___________________________________________________________
 * wd0 |  pktsubtype |  unused1      |      reason                 |
 *     |_____________|_______________|_____________________________|
 * wd1 |                         seqno                             |
 *     |_____________________________|_____________________________|
 * wd2 |   activa-   | causingnode   |                             |
 *     |   tingnode  |               |      unused2                |
 *     |_____________|_______________|_____________________________|
 * wd3 |   initnodes                 |      endnodes               |
 *     |_____________________________|_____________________________|
 *
 *
 * pktsubtype            - packet subtype = RGP_UNACK_POISON
 * reason                - reason for the last activation of regroup
 * seqno                 - current regroup sequence number
 *                         (sequence number of last regroup incident)
 * activatingnode        - node which called for last regroup incident
 * causingnode           - node whose poll packet was missed or which
 *                         had a power failure or otherwise caused
 *                         the last regroup incident being called for
 * initnodes             - mask of nodes at beginning of last regroup
 * endnodes              - mask of nodes at end of last regroup
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 poison_pkt
#endif /* __TANDEM */

typedef struct poison_pkt
{
   uint8         pktsubtype;
   uint8         unused1;
   uint16        reason;
   uint32        seqno;
   uint8         activatingnode;
   uint8         causingnode;
   uint16        unused2;
   cluster_t     initnodes;
   cluster_t     endnodes;
} poison_pkt_t;

#include <packoff.h>

//
// There is no room for a 16 bit ignorescreen mask
// in rgp_pkt_t structure. We use a few bit from several
// fields to store the ignore screen.
// The following routines do packing and unpacking
// of ignorescreen from/into the packet
//

extern void PackIgnoreScreen(rgp_pkt_t* to, cluster_t from);
extern void UnpackIgnoreScreen(rgp_pkt_t* from, cluster_t to);
extern void SetMulticastReachable(uint32 mask);

/*---------------------------------------------------------------------------*/
/* This struct is keeps track of the state of each node in the cluster.      */
/*---------------------------------------------------------------------------*/
typedef struct
{
   uint16 status;        /* state of node - alive, dead etc.           */
   uint16 pollstate;     /* whether I'm alives have been received      */
   uint16 lostHBs;       /* tracks the number of consecutive I'm alives lost */
} node_state_t;

/* The status and pollstate fields of the node_state_t struct can have the
 * following values.
 */

/* Node status of nodes */

#define RGP_NODE_ALIVE            1          /* node is considered alive     */
#define RGP_NODE_COMING_UP        2          /* node is coming up            */
#define RGP_NODE_DEAD             3          /* node has failed              */
#define RGP_NODE_NOT_CONFIGURED   4          /* node is not even configured  */

/* IamAlive status codes of nodes */

#define AWAITING_IAMALIVE         1          /* awaiting IamAlives           */
#define IAMALIVE_RECEIVED         2          /* got IamAlive                 */

#define RGP_IAMALIVE_THRESHOLD  100          /* after getting this many Iam- *
                                              * Alives, we check if every    *
                                              * node has sent at least one   */


/************************************************************************
 * rgp_control_t (regroup's only global data structure)
 * ----------------------------------------------------
 * This structure holds all the Regroup state and other info.
 * This is the only global data structure used by Regroup.
 *
 * NOTE: The word offsets shown in this picture assume that
 *       MAX_CLUSTER_SIZE is 16.
 *
 *      ___________________________________________________________
 * wd0 |                                                           |
 *     :                    rgpinfo structure                      :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd3 |   mynode                    |    tiebreaker               |
 *     |_____________________________|_____________________________|
 * wd4 |                    num_nodes                              |
 *     |___________________________________________________________|
 * wd5 |   clock_ticks               |    rgpcounter               |
 *     |_____________________________|_____________________________|
 * wd6 |   restartcount              |    pruning_ticks            |
 *     |_____________________________|_____________________________|
 * wd7 |   pfail_state               |    flags                    |
 *     |_____________________________|_____________________________|
 * wd8 |   outerscreen               |    innerscreen              |
 *     |_____________________________|_____________________________|
 * wd9 |   status_targets            |    poison_targets           |
 *     |_____________________________|_____________________________|
 * wd10|   initnodes                 |    endnodes                 |
 *     |_____________________________|_____________________________|
 * wd11|   unreachable_nodes         |    arbitration_ticks        |
 *     |_____________________________|_____________________________|
 * wd12|   ignorescreen              |    filler[0]                |
 *     |_____________________________|_____________________________|
 * wd13|   filler[1]                 |    filler[2]                |
 *     |_____________________________|_____________________________|
 * wd14|                                                           |
 *     :                    node_states[MAX_CLUSTER_SIZE]          :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd30|                    *nodedown_callback()                   |
 *     |___________________________________________________________|
 * wd31|                    *select_cluster()                      |
 *     |___________________________________________________________|
 * wd32|                    *rgp_msgsys_p                          |
 *     |___________________________________________________________|
 * wd33|                    *received_pktaddr                      |
 *     |___________________________________________________________|
 * wd34|                                                           |
 *     :                    rgppkt                                 :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd48|                                                           |
 *     :                    rgppkt_to_send                         :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd62|                                                           |
 *     :                    iamalive_pkt                           :
 *     :                                                           :
 *     |___________________________________________________________|
 * wd76|                                                           |
 *     :                    poison_pkt                             :
 *     |___________________________________________________________|
 * wd80|                                                           |
 *     :                                                           :
 *     :                    potential_groups[MAX_GROUPS]           :
 *     :                                                           :
 *     |___________________________________________________________|
 *wd208|                                                           |
 *     :                    last_stable_seqno                      :
 *     |___________________________________________________________|
 *wd212|                                                           |
 *     :                    internal_connectivity_matrix           :
 *     |___________________________________________________________|
 *wdyyy|                                                           |
 *     :                    OS_specific_control                    :
 *wdxxx|___________________________________________________________|
 *
 *
 * rgpinfo    - contains regroup timing parameters and mask of
 *              fully-integrated cluster (to send IamAlives and monitor)
 *
 * mynode     - node number of local node
 *
 * tiebreaker - node selected to act as a tie-breaker in the
 *              split-brain avoidance algorithm and to run the
 *              pruning algorithm
 *
 * num_nodes  - number of nodes configured in the system, including
 *              any unused node numbers in the middle; this is equal
 *              to (the largest configured node# in the system -
 *              lowest possible node # + 1).
 *
 * clock_ticks- regroup's internal clock used for checking if it is
 *              time to send IamAlive packets and to check if IamAlives
 *              have been received. It is incremented every
 *              RGP_CLOCK_PERIOD and reset to 0 after checking
 *              for IamAlives.
 *
 * rgpcounter - counts regroup clock ticks in a regroup incident in
 *              order to detect if the algorithm is stalling.
 *              This is reset when a new regroup incident begins and
 *              is incremented at each regroup clock tick while
 *              regroup is perturbed.
 *
 * restartcount - counts # of regroup algorithm restarts in each regroup
 *                incident; the node is halted if there are too many
 *                restarts.
 *
 * pruning_ticks - number of regroup clock ticks after the tie-breaker
 *                 has been selected; if there are disconnects, the
 *                 tie-breaker should wait a fixed number of ticks
 *                 before running the pruning algorithm.
 *
 * pfail_state  - set to a +ve value when a pfail event is reported
 *                to regroup. It is decremented at every regroup
 *                clock tick till it reaches zero. While this number
 *                is +ve, missing self IamAlives are ignored and
 *                do not cause the node to halt. This gives the
 *                sending hardware some time to recover from power
 *                failures before self IamAlives are checked.
 *
 * outerscreen - outer recognition mask: nodes not in this mask are
 *               considered dead or outcasts; if they try to contact
 *               us, send them poison packets to make sure they stay down
 *
 * innerscreen - inner recognition mask: nodes not in this mask are
 *               considered tardy. Regroup packts from them will be
 *               ignored. They may survive if they can find some
 *               node which hasn't eliminated them from this screen.
 *
 * status_targets  - nodes to send regroup status packets to
 *
 * poison_targets  - nodes to send poison packets to
 *
 * initnodes   - nodes alive at the beginning of last regroup incident
 *
 * endnodes    - nodes alive at the end of last regroup incident
 *
 * unreachable_nodes - stores unreachable_node events till the events
 *                     can be processed
 *
 * arbitration_ticks     - number of regroup clock ticks after the arbitration
 *                         started. If arbitration_ticks counter exceeds
 *                         RGP_ARBITRATION_TIMEOUT number of ticks,
 *                         the arbitrating node will shoot itself, and the rest
 *                         of the group will restart the regroup ignoring stalled
 *                         arbitrator
 *
 * ignorescreen          - this is a local copy of ignorescreen passed as
 *                         a part of the regroup packet. The packets from
 *                         the nodes in this screen are ignored and no wait
 *                         for the nodes in ignorescreen is performed in stage 1
 *
 * last_stable_seqno      - this is a sequence number of the last successful regroup.
 *                         It allows to detect really outdated packets
 *
 * flags:
 *
 * cautiousmode          - need to be "cautious"; wait longer in stage 1
 *
 * sendstage             - This flag is used to indicate whether the
 *                         regroup status packets should indicate we
 *                         are in the current stage. When we enter the
 *                         cleanup stages, we don't let others know we
 *                         are in the stage until the cleanup actions
 *                         are completed.
 *
 *                         This flag is set when a new regroup incident
 *                         is started. It is then cleared when we enter
 *                         a cleanup stage and set again when the
 *                         cleanup operations are completed.
 *
 * tiebreaker_selected   - set in stage 2 after tie-breaker is selected
 *
 * has_unreachable_nodes - set when a node_unreachable event is detected
 *                         in stages 1 or 2. checked in stage 3.
 *
 * flags_unused          - 11 unused bits
 *
 * node_states[MAX_CLUSTER_SIZE] - state of all the nodes
 *
 * *nodedown_callback() - registered callback routine to be invoked
 *                        to report node failure
 *
 * *select_cluster()    - registered callback routine to be invoked
 *                        when multiple cluster options exist
 *
 * *rgp_msgsys_p - pointer to struct shared by regroup and message system
 *
 * *received_pktaddr - address of rgp packet received
 *
 * rgp_lock - lock to serialize access to this struct
 *
 * rgppkt       - regroup status in the form of a packet
 *
 * rgppkt_to_send - regroup packet to be broadcast
 *
 * iamalive_pkt - I am alive packet to be broadcast
 *
 * poison_pkt   - poison packet to be sent
 *
 * potential_groups[MAX_GROUPS] - scratch pad for pruning algorithm
 *
 */

#ifdef __TANDEM
#pragma fieldalign shared8 rgp_control
#endif /* __TANDEM */

typedef struct rgp_control
{
   /* timing parameters and cluster membership */
   rgpinfo_t rgpinfo;

   /* node numbers */
   node_t mynode;
   node_t tiebreaker;
   uint32 num_nodes;

   /* various counters counting clock ticks */
   uint16 clock_ticks;
   uint16 rgpcounter;
   uint16 restartcount;
   uint16 pruning_ticks;
   uint16 pfail_state;

   /* rgpflags */
   uint16 cautiousmode          :  1;
   uint16 sendstage             :  1;
   uint16 tiebreaker_selected   :  1;
   uint16 has_unreachable_nodes :  1;
   uint16 arbitration_started   :  1;
   uint16 flags_unused          : 11;

   /* cluster masks */
   cluster_t outerscreen;
   cluster_t innerscreen;
   cluster_t status_targets;
   cluster_t poison_targets;
   cluster_t initnodes;
   cluster_t endnodes;
   cluster_t unreachable_nodes;

   uint16    arbitration_ticks;
   cluster_t ignorescreen;

   uint16 filler[3]; /* for alignment and future use */

   /* node states */
   node_state_t node_states[MAX_CLUSTER_SIZE];

   /* callback routines */
   void (*nodedown_callback)(cluster_t failed_nodes);
   int  (*select_cluster)(cluster_t cluster_choices[], int num_clusters);

   /* pointers to other structures */
   rgp_msgsys_p rgp_msgsys_p;
   rgp_pkt_t *received_pktaddr;

   /* current status in the form of a regroup packet */
   rgp_pkt_t      rgppkt;

   /* packets to be sent */
   rgp_pkt_t      rgppkt_to_send;
   iamalive_pkt_t iamalive_pkt;
   poison_pkt_t   poison_pkt;

   /* scratch pad for node pruning algorithm */
   cluster_t potential_groups[MAX_GROUPS];

   /* The rest of the struct is an OS-specific substruct
    * (defined in wrgpos.h).
    */
   uint32 last_stable_seqno;

   /* temporary place to collect connectivity information
    * while send_stage = 0. (Can't use rgp_pkt conn.matrix,
    * because we don't want to see our info until we get
    * the first timer tick */

   connectivity_matrix_t internal_connectivity_matrix;
   OS_specific_rgp_control_t OS_specific_control;

} rgp_control_t;

/*---------------------------------------------------------------------------*/
/* Procedures exported by the Cluster type implementation */

_priv _resident extern void
ClusterInit(cluster_t c);
_priv _resident extern void
ClusterUnion(cluster_t dst, cluster_t src1, cluster_t src2);
_priv _resident extern void
ClusterIntersection(cluster_t dst, cluster_t src1, cluster_t src2);
_priv _resident extern void
ClusterDifference(cluster_t dst, cluster_t src1, cluster_t src2);
_priv _resident extern int
ClusterCompare(cluster_t c1, cluster_t c2);
_priv _resident extern int
ClusterSubsetOf(cluster_t big, cluster_t small);
_priv _resident extern void
ClusterComplement(cluster_t dst, cluster_t src);
_priv _resident extern int
ClusterMember(cluster_t c, node_t i);
_priv _resident extern void
ClusterInsert(cluster_t c, node_t i);
_priv _resident extern void
ClusterDelete(cluster_t c, node_t i);
_priv _resident extern void
ClusterCopy(cluster_t dst, cluster_t src);
_priv _resident extern void
ClusterSwap(cluster_t c1, cluster_t c2);
_priv _resident extern int
ClusterNumMembers(cluster_t c);
extern int 
ClusterEmpty(cluster_t c);


/*---------------------------------------------------------------------------*/
/* Function to select the tie-breaker node used in both the split-brain
 * avoidance and node pruning algorithms
 */
_priv _resident extern node_t
rgp_select_tiebreaker(cluster_t cluster);


/*---------------------------------------------------------------------------*/
/* Procedures exported by the node pruning algorithm */

_priv _resident extern void MatrixInit(connectivity_matrix_t c);
/* Initialize the matrix c to show 0 connectivity. */

_priv _resident extern void
MatrixSet(connectivity_matrix_t c, int row, int column);
/* Set c[row,column] to 1. */

_priv _resident extern void
MatrixOr(connectivity_matrix_t t, connectivity_matrix_t s);
/* OR in s into t. */

_priv _resident extern int connectivity_complete(connectivity_matrix_t c);
/* Returns 1 if all live nodes are connected to all other live nodes
 * and 0 if there is at least one disconnect.
 */

_priv _resident extern int
find_all_fully_connected_groups(connectivity_matrix_t c,
                                node_t selected_node,
                                cluster_t groups[]);
/* Analyzes the connectivity matrix and comes up with the list of
 * all maximal, fully-connected groups. Returns the number of
 * such groups found. 0 is returned iff there are no live nodes.
 */

/*---------------------------------------------------------------------------*/
/* Declaration of Regroup's global data structure */

#ifdef NSK
#include <wmsgsac.h>
#define rgp ((rgp_control_t *) MSGROOT->RegroupControlAddr)
#else
extern rgp_control_t *rgp;
#endif /* NSK */
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.1*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------

#endif    /* 0 - change descriptions */


#endif /* _WRGP_H_ defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\connsink.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    connsink.c

Abstract:

    Implements a COM sink object on which to receive connection folder
    events

Author:

    CharlWi (Charlie Wickham) 11/30/98 - heavily ripped off from
        net\config\shell\folder\notify.cpp, originally authored by
        ShaunCo (Shaun Cox)


Revision History:

--*/

#define UNICODE 1

#include "connsink.h"
#include <iaccess.h>

extern "C" {
#include "nmp.h"

VOID
ProcessNameChange(
    GUID * GuidId,
    LPCWSTR NewName
    );
}

EXTERN_C const CLSID CLSID_ConnectionManager;
EXTERN_C const IID IID_INetConnectionNotifySink;

#define INVALID_COOKIE  -1

CComModule _Module;
DWORD AdviseCookie = INVALID_COOKIE;

//static
HRESULT
CConnectionNotifySink::CreateInstance (
    REFIID  riid,
    VOID**  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Initialize the output parameter.
    //
    *ppv = NULL;

    CConnectionNotifySink* pObj;
    pObj = new CComObject <CConnectionNotifySink>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    if ( FAILED( hr )) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Unable to create Net Connection Manager advise sink "
                    "object, status %08X.\n",
                    hr);
    }

    return hr;
} // CConnectionNotifySink::CreateInstance

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionNotifySink::~CConnectionNotifySink
//
//  Purpose:    Clean up the sink object
//
//  Arguments:
//      (none)
//
//  Returns:
//

CConnectionNotifySink::~CConnectionNotifySink()
{
}

//
// all we really care about are renaming events hence the rest of the routines
// are stubbed out
//
HRESULT
CConnectionNotifySink::ConnectionAdded (
    const NETCON_PROPERTIES_EX*    pPropsEx)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::ConnectionBandWidthChange (
    const GUID* pguidId)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::ConnectionDeleted (
    const GUID* pguidId)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::ConnectionModified (
    const NETCON_PROPERTIES_EX* pPropsEx)
{
    ProcessNameChange(const_cast<GUID *>(&(pPropsEx->guidId)), pPropsEx->bstrName );
    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionRenamed (
    const GUID* GuidId,
    LPCWSTR     NewName)
{

    ProcessNameChange(( GUID *)GuidId, NewName );
    return S_OK;
} // CConnectionNotifySink::ConnectionRenamed

HRESULT
CConnectionNotifySink::ConnectionStatusChange (
    const GUID*     pguidId,
    NETCON_STATUS   Status)
{
    return E_NOTIMPL;
}

HRESULT
CConnectionNotifySink::RefreshAll ()
{
    return E_NOTIMPL;
}

HRESULT CConnectionNotifySink::ConnectionAddressChange (
    const GUID* pguidId )
{
    return E_NOTIMPL;
}

HRESULT CConnectionNotifySink::ShowBalloon(
    IN const GUID* pguidId, 
    IN const BSTR szCookie, 
    IN const BSTR szBalloonText)
{
    return E_NOTIMPL;
}


HRESULT CConnectionNotifySink::DisableEvents(
    IN const BOOL  fDisable,
    IN const ULONG ulDisableTimeout)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetNotifyConPoint
//
//  Purpose:    Common code for getting the connection point for use in
//              NotifyAdd and NotifyRemove
//
//  Arguments:
//      ppConPoint [out]    Return ptr for IConnectionPoint
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrGetNotifyConPoint(
    IConnectionPoint **             ppConPoint)
{
    HRESULT                     hr;
    IConnectionPointContainer * pContainer  = NULL;

    CL_ASSERT(ppConPoint);

    // Get the debug interface from the connection manager
    //
    hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                          CLSCTX_LOCAL_SERVER,
                          IID_IConnectionPointContainer,
                          (LPVOID*)&pContainer);

    if (SUCCEEDED(hr)) {
        IConnectionPoint * pConPoint    = NULL;

        // Get the connection point itself and fill in the return param
        // on success
        //
        hr = pContainer->FindConnectionPoint(
            IID_INetConnectionNotifySink,
            &pConPoint);

        if (SUCCEEDED(hr)) {

            //
            // set up a proxy on the connection point interface that will
            // identify ourselves as ourselves.
            //
            hr = CoSetProxyBlanket(pConPoint,
                                   RPC_C_AUTHN_WINNT,      // use NT default security
                                   RPC_C_AUTHZ_NONE,       // use NT default authentication
                                   NULL,                   // must be null if default
                                   RPC_C_AUTHN_LEVEL_CALL, // call
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   NULL,                   // use process token
                                   EOAC_NONE);

            if (SUCCEEDED(hr)) {
                *ppConPoint = pConPoint;
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                           "[NM] Couldn't set proxy blanket on Net Connection "
                            "point, status %1!08X!.\n",
                            hr);
                pConPoint->Release();
            }
        } else {
            ClRtlLogPrint(LOG_CRITICAL,
                       "[NM] Couldn't find notify sink connection point on Net Connection "
                        "Manager, status %1!08X!.\n",
                        hr);
        }

        pContainer->Release();
    } else {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Couldn't establish connection point with Net Connection "
                    "Manager, status %1!08X!.\n",
                    hr);
    }

    return hr;
}

EXTERN_C {

HRESULT	
NmpGrantAccessToNotifySink(
    VOID
    )

/*++

Routine Description:

    allow localsystem, cluster service account and backup operators group access to make callbacks
    into the service.

    stolen from private\admin\snapin\netsnap\remrras\server\remrras.cpp and
    code reviewed by SajiA

 Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything went ok.

--*/

{
    IAccessControl*             pAccessControl = NULL;     
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID                        pSystemSid = NULL;
    HANDLE                      processToken = NULL;
    ULONG                       tokenUserSize;
    PTOKEN_USER                 processTokenUser = NULL;
    DWORD                       status;
    PSID                        pBackupOperatorsSid = NULL;
    PSID                        pAdminGroupSid = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DCOMAccessControl,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IAccessControl,
                                  (void**)&pAccessControl);

    if( FAILED( hr ) ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Couldn't create access control class object "
                    "status 0x%1!08X!.\n",
                    hr);
    	goto Error;
    }

    //
    // Setup the property list. We use the NULL property because we are trying
    // to adjust the security of the object itself
    //
    ACTRL_ACCESSW access;
    ACTRL_PROPERTY_ENTRYW propEntry;
    access.cEntries = 1;
    access.pPropertyAccessList = &propEntry;

    ACTRL_ACCESS_ENTRY_LISTW entryList;
    propEntry.lpProperty = NULL;
    propEntry.pAccessEntryList = &entryList;
    propEntry.fListFlags = 0;

    //
    // Setup the access control list for the default property
    //
    ACTRL_ACCESS_ENTRYW entry[3];
    entryList.cEntries = 3;
    entryList.pAccessList = entry;

    //
    // Setup the access control entry for localsystem
    //
    entry[0].fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry[0].Access = COM_RIGHTS_EXECUTE;
    entry[0].ProvSpecificAccess = 0;
    entry[0].Inheritance = NO_INHERITANCE;
    entry[0].lpInheritProperty = NULL;

    //
    // NT requires the system account to have access (for launching)
    //
    entry[0].Trustee.pMultipleTrustee = NULL;
    entry[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    entry[0].Trustee.TrusteeType = TRUSTEE_IS_USER;

    //
    // allocate and init the SYSTEM sid
    //
    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSystemSid ) ) {
        status = GetLastError();
        hr = HRESULT_FROM_WIN32( status );
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Failed in allocating and initializing system SID, status %1!u!.\n",
                    status);
        goto Error;
    }

    entry[0].Trustee.ptstrName = ( PWCHAR ) pSystemSid;

#if 0
    //
    // Setup the access control entry for cluster service account
    //
    entry[1].fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry[1].Access = COM_RIGHTS_EXECUTE;
    entry[1].ProvSpecificAccess = 0;
    entry[1].Inheritance = NO_INHERITANCE;
    entry[1].lpInheritProperty = NULL;

    entry[1].Trustee.pMultipleTrustee = NULL;
    entry[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    entry[1].Trustee.TrusteeType = TRUSTEE_IS_USER;

    status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY,
                &processToken
                );

    if ( !NT_SUCCESS( status ) ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Failed in opening cluster service process token, status 0x%1!08lx!.\n",
                    status);
        hr = HRESULT_FROM_NT( status );
        goto Error;
    }

    //
    // find out the size of token, allocate and requery to get info
    //
    status = NtQueryInformationToken(
                processToken,
                TokenUser,
                NULL,
                0,
                &tokenUserSize
                );

    CL_ASSERT( status == STATUS_BUFFER_TOO_SMALL );
    
    if ( status != STATUS_BUFFER_TOO_SMALL ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Failed in querying cluster service process token info, status 0x%1!08lx!.\n",
                    status);
        hr = HRESULT_FROM_NT( status );
        goto Error;
    }

    processTokenUser = (PTOKEN_USER) LocalAlloc( 0, tokenUserSize );

    if (( processToken == NULL ) || ( processTokenUser == NULL ) ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Failed in memory alloc for cluster service process token, status 0x%1!08lx!.\n",
                    status);
        hr = HRESULT_FROM_NT( status );
        goto Error;
    }

    status = NtQueryInformationToken(
                processToken,
                TokenUser,
                processTokenUser,
                tokenUserSize,
                &tokenUserSize
                );

    if ( !NT_SUCCESS( status ) ) {
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Failed in querying cluster service process token info with alloced buffer, status 0x%1!08lx!.\n",
                    status);
        hr = HRESULT_FROM_NT( status );
        goto Error;
    }

    entry[1].Trustee.ptstrName = (PWCHAR)processTokenUser->User.Sid;
#else
    //
    // Setup the access control entry for administrators group
    //
    entry[1].fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry[1].Access = COM_RIGHTS_EXECUTE;
    entry[1].ProvSpecificAccess = 0;
    entry[1].Inheritance = NO_INHERITANCE;
    entry[1].lpInheritProperty = NULL;

    entry[1].Trustee.pMultipleTrustee = NULL;
    entry[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    entry[1].Trustee.TrusteeType = TRUSTEE_IS_USER;

    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pAdminGroupSid ) ) {
        status = GetLastError();
        hr = HRESULT_FROM_WIN32( status );
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Failed in allocating and initializing admin group SID, status %1!u!.\n",
                    status);
        goto Error;
    }

    entry[1].Trustee.ptstrName = ( PWCHAR ) pAdminGroupSid;  
#endif
    //
    // Setup the access control entry for backup operators
    //
    entry[2].fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry[2].Access = COM_RIGHTS_EXECUTE;
    entry[2].ProvSpecificAccess = 0;
    entry[2].Inheritance = NO_INHERITANCE;
    entry[2].lpInheritProperty = NULL;

    entry[2].Trustee.pMultipleTrustee = NULL;
    entry[2].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    entry[2].Trustee.TrusteeType = TRUSTEE_IS_USER;

    if ( !AllocateAndInitializeSid( &siaNtAuthority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_BACKUP_OPS,
                                    0, 0, 0, 0, 0, 0,
                                    &pBackupOperatorsSid ) ) {
        status = GetLastError();
        hr = HRESULT_FROM_WIN32( status );
        ClRtlLogPrint(LOG_CRITICAL,
                   "[NM] Failed in allocating and initializing backup operators SID, status %1!u!.\n",
                    status);
        goto Error;
    }

    entry[2].Trustee.ptstrName = ( PWCHAR ) pBackupOperatorsSid;   

    //
    // grant access to this mess
    //
    hr = pAccessControl->GrantAccessRights(&access);

    if( SUCCEEDED(hr) )
	{
        hr = CoInitializeSecurity(pAccessControl,
                                  -1,
                                  NULL,
                                  NULL, 
                                  RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IDENTIFY, 
                                  NULL,
                                  EOAC_ACCESS_CONTROL,
                                  NULL);
    }

Error:
    if( pAccessControl ) {
	    pAccessControl->Release();
    }

    if ( processTokenUser != NULL ) {
        LocalFree( processTokenUser );
    }

    if ( processToken != NULL ) {
        NtClose( processToken );
    }

    if( pSystemSid != NULL ) {
        FreeSid( pSystemSid );
    }

    if ( pBackupOperatorsSid != NULL ) {
        FreeSid( pBackupOperatorsSid );
    }

    if ( pAdminGroupSid != NULL ) {
        FreeSid( pAdminGroupSid );
    }

    return hr;
}

HRESULT
NmpInitializeConnectoidAdviseSink(
    VOID
    )

/*++

Routine Description:

    Get an instance pointer to the conn mgr's connection point object and hook
    up our advice sink so we can catch connectoid rename events

Arguments:

    None

Return Value:

    ERROR_SUCCESS if everything worked...

--*/

{
    HRESULT                     hr              = S_OK; // Not returned, but used for debugging
    IConnectionPoint *          pConPoint       = NULL;
    INetConnectionNotifySink *  pSink           = NULL;
    PSECURITY_DESCRIPTOR        sinkSD;

    hr = NmpGrantAccessToNotifySink();
    if ( SUCCEEDED( hr )) {

        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr)) {
            // Create the notify sink
            //
            hr = CConnectionNotifySink::CreateInstance(
                IID_INetConnectionNotifySink,
                (LPVOID*)&pSink);

            if (SUCCEEDED(hr)) {
                CL_ASSERT(pSink);

                hr = pConPoint->Advise(pSink, &AdviseCookie);

                if ( !SUCCEEDED( hr )) {
                    ClRtlLogPrint(LOG_UNUSUAL,
                               "[NM] Couldn't initialize Net Connection Manager advise "
                                "sink, status %1!08X!\n",
                                hr);
                }

                pSink->Release();
            } else {
                hr = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                           "[NM] Couldn't create sink instance, status %1!08X!\n",
                            hr);
            }

            pConPoint->Release();
        }

    } else {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[NM] CoInitializeSecurity failed, status %1!08X!\n",
                    hr);
    }

    if ( FAILED( hr )) {
        ClRtlLogPrint(LOG_UNUSUAL,
                   "[NM] Couldn't initialize Net Connection Manager advise "
                    "sink, status %1!08X!\n",
                    hr);
        AdviseCookie = INVALID_COOKIE;
    }

    return hr;
} // NmpInitializeConnectoidAdviseSink

VOID
NmCloseConnectoidAdviseSink(
    VOID
    )

/*++

Routine Description:

    close down the conn mgr event sink. this routine is public since it is
    called prior to CoUninitialize in ClusterShutdown()

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT             hr          = S_OK;
    IConnectionPoint *  pConPoint   = NULL;

    if ( AdviseCookie != INVALID_COOKIE ) {
        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr)) {
            // Unadvise
            //
            hr = pConPoint->Unadvise(AdviseCookie);
            AdviseCookie = INVALID_COOKIE;
            pConPoint->Release();
        }

        if ( FAILED( hr )) {
            ClRtlLogPrint(LOG_UNUSUAL,
                       "[NM] Couldn't close Net Connection Manager advise sink, status %1!08X!\n",
                        hr);
        }
    }
} // NmCloseConnectoidAdviseSink


VOID
ProcessNameChange(
    GUID * GuidId,
    LPCWSTR NewName
    )

/*++

Routine Description:

    wrapper that enums the net interfaces

Arguments:

    GuidId - pointer to connectoid that changed

    NewName - pointer to new name of connectoid

Return Value:

    None

--*/

{
    RPC_STATUS   rpcStatus;
    LPWSTR       connectoidId = NULL;


    CL_ASSERT(GuidId);
    CL_ASSERT(NewName);

    rpcStatus = UuidToString( (GUID *) GuidId, &connectoidId);

    if ( rpcStatus == RPC_S_OK ) {
        PNM_INTERFACE     netInterface;
        DWORD             status;
        PLIST_ENTRY       entry;

        ClRtlLogPrint(LOG_NOISE,
                   "[NM] Received notification that name for connectoid %1!ws! was changed "
                    "to '%2!ws!'\n",
                    connectoidId,
                    NewName);

        NmpAcquireLock();

        //
        // enum the interfaces, looking for the connectoid GUID as the
        // adapter ID
        //
        for (entry = NmpInterfaceList.Flink;
             entry != &NmpInterfaceList;
             entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);

            if ( lstrcmpiW( connectoidId , netInterface->AdapterId ) == 0 ) {
                PNM_NETWORK network = netInterface->Network;
                LPWSTR      networkName = (LPWSTR) OmObjectName( network );
                BOOL        nameMatch = (lstrcmpW( networkName, NewName ) == 0);

                // Ignore this callback if there is a pending GUM update
                // with a different network name.
                if (NmpIsNetworkNameChangePending(network)) {
                	if (nameMatch) {
                		// Assume this is the callback we're waiting for.
                		// Clear the pending flag and the timer.
                		network->Flags &= ~NM_FLAG_NET_NAME_CHANGE_PENDING;
                		NmpStartNetworkNameChangePendingTimer(network, 0);
                	} else {
                		// Ignore.
                		NmpReleaseLock();
                		ClRtlLogPrint(LOG_NOISE,
                			"[NM] Ignoring notification that name for "
                			"connectoid %1!ws! was changed to '%2!ws!' "
                			"because a network name global update "
                			"is pending for network %3!ws!.\n",
                			connectoidId, NewName, networkName
                			);
                		break;
                	}
                }

                if ( !nameMatch ) {
                    NM_NETWORK_INFO netInfo;

                    //
                    // For some reason, OmReferenceObject causes a compiler
                    // error here. Likely a header ordering problem. The
                    // function has been wrappered as a  workaround.
                    //
                    NmpReferenceNetwork(network);

                    NmpReleaseLock();

                    netInfo.Id = (LPWSTR) OmObjectId( network );
                    netInfo.Name = (LPWSTR) NewName;

                    status = NmpSetNetworkName( &netInfo );

                    if ( status != ERROR_SUCCESS ) {
                        ClRtlLogPrint( LOG_UNUSUAL, 
                            "[NM] Couldn't rename network '%1!ws!' to '%2!ws!', status %3!u!\n",
                            networkName,
                            NewName,
                            status
                            );
                    
                        //If the error condition is due to the object
                        //already existing revert back to the old name.
                        if(status == ERROR_OBJECT_ALREADY_EXISTS) {
                            DWORD tempStatus = ERROR_SUCCESS;
                            INetConnection *connectoid;

                            ClRtlLogPrint(LOG_UNUSUAL, 
                                "[NM] Reverting back network name to '%1!ws!', from '%2!ws!\n",
                                networkName,
                                NewName
                                );

                            connectoid = ClRtlFindConnectoidByGuid(connectoidId);

                            if(connectoid != NULL){
                                tempStatus = ClRtlSetConnectoidName(
                                    connectoid,
                                    networkName);
                            }

                            if((tempStatus != ERROR_SUCCESS) ||
                               (connectoid == NULL)) {
                                ClRtlLogPrint(LOG_UNUSUAL, 
                                "[NM] Failed to set name of network connection"
                                "%1!ws!, status %2!u!\n",
                                networkName,
                                tempStatus);
                            }
                        }
                    }
                    NmpDereferenceNetwork(network);
                }
                else {
                    NmpReleaseLock();
                }

                break;
            }
        }

        if ( entry == &NmpInterfaceList ) {
            NmpReleaseLock();

            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Couldn't find net interface for connectoid '%1!ws!'\n",
                connectoidId
                );
        }

        RpcStringFree( &connectoidId );
    }

    return;

} // ProcessNameChange

} // EXTERN_C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\mm\srgputl.c ===
#ifdef __TANDEM
#pragma columns 79
#pragma page "srgputl.c - T9050 - utility routines for Regroup Module"
#endif

/* @@@ START COPYRIGHT @@@
**  Tandem Confidential:  Need to Know only
**  Copyright (c) 1995, Tandem Computers Incorporated
**  Protected as an unpublished work.
**  All Rights Reserved.
**
**  The computer program listings, specifications, and documentation
**  herein are the property of Tandem Computers Incorporated and shall
**  not be reproduced, copied, disclosed, or used in whole or in part
**  for any reason without the prior express written permission of
**  Tandem Computers Incorporated.
**
** @@@ END COPYRIGHT @@@
**/

/*---------------------------------------------------------------------------
 * This file (srgputl.c) contains the cluster_t data type implementation
 * and the node pruning algorithm used by Regroup.
 *---------------------------------------------------------------------------*/

#ifdef __cplusplus
   extern "C" {
#endif /* __cplusplus */


#include <wrgp.h>

/************************************************************************
 * ClusterInit,
 * ClusterUnion,
 * ClusterIntersection,
 * ClusterDifference,
 * ClusterCompare,
 * ClusterSubsetOf,
 * ClusterComplement,
 * ClusterMember,
 * ClusterInsert,
 * ClusterDelete,
 * ClusterCopy,
 * ClusterSwap,
 * ClusterNumMembers
 * =================
 *
 * Description:
 *
 *    Functions that implement operations on the cluster_t type.
 *
 * Algorithm:
 *
 *    Operates on the byte array that is the cluster_t type.
 *
 ************************************************************************/
_priv _resident void
ClusterInit(cluster_t c)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      c[i] = 0;
}

_priv _resident void
ClusterUnion(cluster_t dst, cluster_t src1, cluster_t src2)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src1[i] | src2[i];
}

_priv _resident void
ClusterIntersection(cluster_t dst, cluster_t src1, cluster_t src2)
{
   int i;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src1[i] & src2[i];
}

_priv _resident void
ClusterDifference(cluster_t dst, cluster_t src1, cluster_t src2)
{
   int i;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src1[i] & (~src2[i]);
}

_priv _resident int ClusterCompare(cluster_t c1, cluster_t c2)
{
   int identical, i;

   identical = 1;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if (c1[i] != c2[i])
      {
         identical = 0;
         break;
      }
   }
   return(identical);
}

_priv _resident int ClusterSubsetOf(cluster_t big, cluster_t small)
/* Returns 1 if set small = set big or small is a subset of big. */
{
   int subset, i;

   subset = 1;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if ( (big[i] != small[i]) && ((big[i] ^ small[i]) & small[i]) )
      {
         subset = 0;
         break;
      }
   }
   return(subset);
}

_priv _resident void ClusterComplement(cluster_t dst, cluster_t src)
{
   int i;
   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = ~src[i];
}

_priv _resident int ClusterMember(cluster_t c, node_t i)
{
   return((BYTE(c,i) >> (BYTEL-1-BIT(i))) & 1);
}

_priv _resident void ClusterInsert(cluster_t c, node_t i)
{
   BYTE(c, i) |= (1 << (BYTEL-1-BIT(i)));
}

_priv _resident void ClusterDelete(cluster_t c, node_t i)
{
   BYTE(c, i) &= ~(1 << (BYTEL-1-BIT(i)));
}

_priv _resident void ClusterCopy(cluster_t dst, cluster_t src)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
      dst[i] = src[i];
}

_priv _resident void ClusterSwap(cluster_t c1, cluster_t c2)
{
   int i;
   unsigned char temp;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      temp  = c1[i];
      c1[i] = c2[i];
      c2[i] = temp;
   }
}

_priv _resident int  ClusterNumMembers(cluster_t c)
/* Returns the number of nodes in the cluster. */
{
   int num_members = 0, i, j;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if (c[i])
      {
         for (j = 0; j < BYTEL; j++)
            if (c[i] & (1 << j))
               num_members++;
      }
   }
   return(num_members);
}

/************************************************************************
 * ClusterEmpty
 * =================
 *
 * Description:
 *
 *    Checks that a cluster has no members
 *
 * Parameters:
 *
 *    cluster_t c
 *       cluster to be examined
 *
 * Returns:
 *
 *    0 - cluster contains at least one node
 *    1 - cluster is empty
 *
 * Comment:
 *
 *    The proper place for this function is in srgputl.c
 *
 ************************************************************************/
int ClusterEmpty(cluster_t c)
{
   int i;

   for (i = 0; i < BYTES_IN_CLUSTER; i++)
   {
      if (c[i])
      {
         return 0;
      }
   }
   return 1;
}


/************************************************************************
 * rgp_select_tiebreaker
 * =====================
 *
 * Description:
 *
 *    Simple algorithm to select the tie-breaker.
 *
 * Parameters:
 *
 *    cluster_t cluster -
 *       cluster from which a tie-breaker is to be selected
 *
 * Returns:
 *
 *    node_t - the node number of the selected tie-breaker
 *
 * Algorithm:
 *
 *    The tie-breaker is defined as the lowest numbered node in the
 *    cluster.
 *
 ************************************************************************/
_priv _resident node_t
rgp_select_tiebreaker(cluster_t cluster)
{
   node_t i;

   for (i = 0; (i < (node_t) rgp->num_nodes) && !ClusterMember(cluster, i); i++);

   /* If the cluster does not have any members, we have a problem! */
   if (i >= (node_t) rgp->num_nodes)
      RGP_ERROR(RGP_INTERNAL_ERROR);

   return(i);
}


/*---------------------------------------------------------------------------
 * Node pruning algorithm used by Regroup.
 *---------------------------------------------------------------------------
 */

/************************************************************************
 * group_exists
 * ============
 *
 * Description:
 *
 *    Check if a specific group already exists or is a subset of a
 *    group that already exists.
 *
 * Parameters:
 *
 *    cluster_t groups[] -
 *       array of groups to examine
 *
 *    int numgroups -
 *       number of groups discovered so far
 *
 *    cluster_t g -
 *       specific group to check
 *
 * Returns:
 *
 *    int - 1 if the specified group exists in the array; 0 therwise.
 *
 * Algorithm:
 *
 *    Goes through the array and calls ClusterSubsetOf to check if the
 *    specified group g is a subset of the the array element.
 *
 ************************************************************************/
#if !defined(NT)
_priv _resident static
int
#endif
group_exists(cluster_t groups[], int numgroups, cluster_t g)
{
   int exists, i;

   exists = 0;
   for (i = 0; i < numgroups; i++)
   {
      if (ClusterSubsetOf(groups[i],g))
      {
         exists = 1;
         break;
      }
   }
   return(exists);
}


/************************************************************************
 * prune
 * =====
 *
 * Description:
 *
 *    Algorithm to find all fully connected groups based on # of
 *    disconnects in the matrix.
 *
 * Parameters:
 *
 *    disconnect_array disconnects -
 *       input : array of disconnects
 *
 *    int D -
 *       input : size of disconnects array
 *
 *    cluster_t live_nodes -
 *       input : set of all live nodes
 *
 *    cluster_t groups[] -
 *       output: array of fully-connected groups
 *
 * Returns:
 *
 *    int - the number of groups made;  0 if no groups or other error
 *
 * Algorithm:
 *
 *    Start with one group that contains the set of live nodes.
 *    More groups will be generated as disconnects are examined.
 *
 *    Process each disconnect in the disconnects array by applying
 *    the disconnect to the current set of fully-connected groups.
 *
 *    The effect of a disconnect on a fully-conncted group depends on
 *    whether the end points of the disconnect are in the group or not.
 *
 *    If the group contains neither or only one of the endpoints of
 *    the disconnect, the disconnect has no effect on the group.
 *
 *    If both endpoints of the disconnect are in the group, then the
 *    group is split into two groups - the original group without
 *    endpoint 1 and the original group without endpoint 2.
 *    New groups so generated should be discarded if they already
 *    exist or are subsets of currently existing groups.
 *
 *    After every disconnect is processed, we end up with the final
 *    set of fully-connected groups.
 *
 ************************************************************************/
#if !defined(NT)
_priv _resident static
#endif
int
prune(
   disconnect_array   disconnects,
   int                D,
   cluster_t          live_nodes,
   cluster_t          groups[])
{
   int  numgroups = 1, i, j;

   ClusterCopy(groups[0], live_nodes);

   for (i = 0; i < D; i ++)
   {
      for (j = 0; j < numgroups; j++)
      {
         /* Split a group that has both ends of the disconnect. */
         if (ClusterMember(groups[j],disconnects[i][0]) &&
             ClusterMember(groups[j],disconnects[i][1]))
         {
            /* Correct current group in place.
             * Add new group at the end of the array.
             */
            numgroups++;
            ClusterCopy(groups[numgroups-1], groups[j]);
            ClusterDelete(groups[j], disconnects[i][0]);
            ClusterDelete(groups[numgroups-1], disconnects[i][1]);

            /* Check if the new groups already exist or are subgroups
             * of existing groups.
             */

            /* First, check the group added at the end of the array. */
            if (group_exists(groups, numgroups-1, groups[numgroups-1]))
               numgroups--;

            /* Next, check the modified group at j.
             * To simplify the checking, switch it with the last element
             * of the array. If the group already exists, it should be
             * removed. Since the group is now the last element of the
             * array, removal requires only decrementing the array count.
             */
            ClusterSwap(groups[j], groups[numgroups-1]);
            if (group_exists(groups, numgroups-1, groups[numgroups-1]))
               numgroups--;
            j--; /* The j-th entry has been switched with the last entry;
                    it has to be examined again */
         }
      }
   }

   return(numgroups);
}


/************************************************************************
 * select_group_with_designated_node
 * =================================
 *
 * Description:
 *
 *    Function to pick an arbitrary fully connected group that
 *    includes a specified node.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c -
 *       input : cluster's connectivity info
 *
 *    node_t selected_node -
 *       input : just find a fully-connected group that includes this node
 *
 *    cluster_t *group -
 *       output: group that includes selected_node
 *
 * Returns:
 *
 *    int - returns 1 if the specified node is alive and 0 if it is not
 *
 * Algorithm:
 *
 *    Start with a group that includes just the selected node.
 *    Then, examine nodes starting with node 0 and go up till the
 *    largest node number. If a node is alive, include it in the group
 *    if and only if it is connected to all current members of the
 *    group.
 *
 *    When all nodes are examined, we get a fully-connected group that
 *    includes the selected node. This is only one of potentially many
 *    fully-connected groups and is not necessarily the largest
 *    solution.
 *
 *    This order of examining nodes gives higher priority to lower
 *    numbered nodes.
 *
 ************************************************************************/
#if !defined(NT)
_priv _resident static
#endif
int
select_group_with_designated_node(
   connectivity_matrix_t   c,
   node_t                  selected_node,
   cluster_t               *group)
{
   node_t i, j;

   if (!node_considered_alive(selected_node))
      return(0);
   else
   {
      ClusterInit(*group);
      ClusterInsert(*group, selected_node);
      for (i = 0; i < (node_t) rgp->num_nodes; i++)
      {
         if ((i != selected_node) &&
             node_considered_alive(i) &&
             connected(i, selected_node)
            )
         {
            /* Check if i is connected to all members of the group
             * built so far.
             */
            for (j = 0; j < i; j++)
            {
               if (ClusterMember(*group, j) && !connected(j, i))
                  break;
            }
            if (j == i)  /* i is connected to all current members*/
               ClusterInsert(*group, i);
         }
      }
      return(1);
   }
}


/************************************************************************
 * MatrixInit
 * ==========
 *
 * Description:
 *
 *    Initialize the matrix c to show 0 connectivity.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c - matrix to be set to 0s.
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls ClusterInit to initialize the clusters in the matrix.
 *
 ************************************************************************/
_priv _resident void
MatrixInit(connectivity_matrix_t c)
{
   int i;

   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      ClusterInit(c[i]);
   }
}


/************************************************************************
 * MatrixSet
 * =========
 *
 * Description:
 *
 *    Set matrix[row,column] to 1.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c - matrix to be modified
 *
 *    int row - row number
 *
 *    int column - column number
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls ClusterInsert to set the appropriate bit (column) in the
 *    appropriate cluster (row) in the matrix.
 *
 ************************************************************************/
_priv _resident void
MatrixSet(connectivity_matrix_t c, int row, int column)
{
   ClusterInsert(c[row], (node_t) column);
}


/************************************************************************
 * MatrixOr
 * ========
 *
 * Description:
 *
 *    matrix t := t OR s
 *
 * Parameters:
 *
 *    connectivity_matrix_t  t - target matrix
 *
 *    connectivity_matrix_t  s - source matrix to be ORed into target
 *
 * Returns:
 *
 *    void - no return value
 *
 * Algorithm:
 *
 *    Calls ClusterUnion to OR the appropriate clusters (rows) in the
 *    matrices.
 *
 ************************************************************************/
_priv _resident void
MatrixOr(connectivity_matrix_t t, connectivity_matrix_t s)
{
   int i;

   for (i = 0; i < (node_t) rgp->num_nodes; i++)
      ClusterUnion(t[i], s[i], t[i]);
}


/************************************************************************
 * connectivity_complete
 * =====================
 *
 * Description:
 *
 *    Boolean function that checks if a given connectivity matrix implies
 *    full connectivity (all nodes can talk to all others).
 *
 * Parameters:
 *
 *    connectivity_matrix_t c - connectivity matrix of the cluster
 *
 * Returns:
 *
 *    int - 0 if there are disconnects in the cluster; 1 if it has full
 *    connectivity.
 *
 * Algorithm:
 *
 *    Checks to see if there is any live node in the cluster that cannot
 *    communicate to another live node in the cluster. Node i is
 *    considered alive if c[i,i] is set. Nodes i and j are deemed to
 *    be able to communicate if c[i,j] and c[j,i] are both set.
 *
 ************************************************************************/
_priv _resident int
connectivity_complete(connectivity_matrix_t c)
{
   node_t i, j;

   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      if (node_considered_alive(i))
      {
         for (j = 0; j < i; j++)
         {
            if (node_considered_alive(j) && !connected(i, j))
            {
               /* i and j are a pair of live nodes which are not
                  connected. Thus, there is at least one disconnect.
                  Return 0. */
               return(0);
            }
         }
      }
   }

   /* No disconnects found; return 1. */
   return(1);
}


/************************************************************************
 * find_all_fully_connected_groups
 * ===============================
 *
 * Description:
 *
 *    Function to find all fully connected groups in a graph specified
 *    by a connectivity matrix. An optional "selected_node" can be
 *    used to simplify the search in case of too large a number of
 *    possibilities. In that case, a fully-connected group that
 *    includes selected_node is returned.
 *
 * Parameters:
 *
 *    connectivity_matrix_t c -
 *       input : cluster's connectivity info
 *
 *    node_t selected_node -
 *       input : if there are too many potential groups, just find one
 *       that includes this node; if all groups can be listed, ignore this.
 *
 *    cluster_t groups[] -
 *       output: array of potential clusters
 *
 * Returns:
 *
 *    int - the number of groups made;  0 if no groups or other error
 *
 * Algorithm:
 *
 *    First the set of live nodes and the set of disconnects in the
 *    cluster are evaluated. Then, if the number of live nodes and
 *    disconnects indicates a potentially large number of
 *    possibilities, select_group_with_designated_node() is called to
 *    limit the search to a group including the specified node.
 *    Otherwise, prune() is called to get the list of all possible
 *    fully-connected groups.
 *
 ************************************************************************/
_priv _resident int
find_all_fully_connected_groups(
   connectivity_matrix_t   c,
   node_t                  selected_node,
   cluster_t               groups[])
{
   disconnect_array disconnects;
   cluster_t live_nodes;
   int num_livenodes = 0, num_disconnects = 0;
   node_t i, j;

   ClusterInit(live_nodes);
   for (i = 0; i < (node_t) rgp->num_nodes; i++)
   {
      if (node_considered_alive(i))
      {
         ClusterInsert(live_nodes, i);
         num_livenodes++;
         for (j = 0; j < i; j++)
         {
            if (node_considered_alive(j) && !connected(i, j))
            {
               /* i and j are a pair of live nodes which are not
                  connected. */
               disconnects[num_disconnects][0] = i;
               disconnects[num_disconnects][1] = j;
               num_disconnects++;
            }
         }
         if (too_many_groups(num_livenodes, num_disconnects))
         {
            RGP_TRACE( "RGP Too many dis",
                       num_livenodes,                           /* TRACE */
                       num_disconnects,                         /* TRACE */
                       0, 0 );                                  /* TRACE */
            /* There may be too many choices to consider in reasonable
             * time/space. Just return a fully-connected group that
             * includes the selected node.
             */
            return(select_group_with_designated_node(c,selected_node,groups));
         }
      }
   }

   if (num_livenodes == 0)
      return(0);
   else
      return(prune(disconnects, num_disconnects, live_nodes, groups));
}
/*---------------------------------------------------------------------------*/

#ifdef __cplusplus
}
#endif /* __cplusplus */


#if 0

History of changes to this file:
-------------------------------------------------------------------------
1995, December 13                                           F40:KSK0610          /*F40:KSK06102.2*/

This file is part of the portable Regroup Module used in the NonStop
Kernel (NSK) and Loosely Coupled UNIX (LCU) operating systems. There
are 10 files in the module - jrgp.h, jrgpos.h, wrgp.h, wrgpos.h,
srgpif.c, srgpos.c, srgpsm.c, srgputl.c, srgpcli.c and srgpsvr.c.
The last two are simulation files to test the Regroup Module on a
UNIX workstation in user mode with processes simulating processor nodes
and UDP datagrams used to send unacknowledged datagrams.

This file was first submitted for release into NSK on 12/13/95.
------------------------------------------------------------------------------
This change occurred on 19 Jan 1996                                              /*F40:MB06458.1*/
Changes for phase IV Sierra message system release. Includes:                    /*F40:MB06458.2*/
 - Some cleanup of the code                                                      /*F40:MB06458.3*/
 - Increment KCCB counters to count the number of setup messages and             /*F40:MB06458.4*/
   unsequenced messages sent.                                                    /*F40:MB06458.5*/
 - Fixed some bugs                                                               /*F40:MB06458.6*/
 - Disable interrupts before allocating broadcast sibs.                          /*F40:MB06458.7*/
 - Change per-packet-timeout to 5ms                                              /*F40:MB06458.8*/
 - Make the regroup and powerfail broadcast use highest priority                 /*F40:MB06458.9*/
   tnet services queue.                                                          /*F40:MB06458.10*/
 - Call the millicode backdoor to get the processor status from SP               /*F40:MB06458.11*/
 - Fixed expand bug in msg_listen_ and msg_readctrl_                             /*F40:MB06458.12*/
 - Added enhancement to msngr_sendmsg_ so that clients do not need               /*F40:MB06458.13*/
   to be unstoppable before calling this routine.                                /*F40:MB06458.14*/
 - Added new steps in the build file called                                      /*F40:MB06458.15*/
   MSGSYS_C - compiles all the message system C files                            /*F40:MB06458.16*/
   MSDRIVER - compiles all the MSDriver files                                    /*F40:MB06458.17*/
   REGROUP  - compiles all the regroup files                                     /*F40:MB06458.18*/
 - remove #pragma env libspace because we set it as a command line               /*F40:MB06458.19*/
   parameter.                                                                    /*F40:MB06458.20*/
-----------------------------------------------------------------------          /*F40:MB06458.21*/

#endif    /* 0 - change descriptions */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\connsink.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . H
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "netconp.h"

class ATL_NO_VTABLE CConnectionNotifySink :
    public CComObjectRootEx <CComMultiThreadModel>,
    public INetConnectionNotifySink
{
private:
//    LPITEMIDLIST    m_pidlFolder;

public:
    BEGIN_COM_MAP(CConnectionNotifySink)
        COM_INTERFACE_ENTRY(INetConnectionNotifySink)
    END_COM_MAP()

    CConnectionNotifySink() { /*m_pidlFolder = NULL;*/ };
    ~CConnectionNotifySink();

    // INetConnectionNotifySink
    STDMETHOD(ConnectionAdded) (
        const NETCON_PROPERTIES_EX*    pPropsEx);

    STDMETHOD(ConnectionBandWidthChange) (
        const GUID* pguidId);

    STDMETHOD(ConnectionDeleted) (
        const GUID* pguidId);

    STDMETHOD(ConnectionModified) (
        const NETCON_PROPERTIES_EX* pPropsEx);

    STDMETHOD(ConnectionRenamed) (
        const GUID* pguidId,
        LPCWSTR     pszwNewName);

    STDMETHOD(ConnectionStatusChange) (
        const GUID*     pguidId,
        NETCON_STATUS   Status);

    STDMETHOD(RefreshAll) ();
    
    STDMETHOD(ConnectionAddressChange) (
        const GUID* pguidId );

    STDMETHOD(ShowBalloon) (
        IN const GUID* pguidId, 
        IN const BSTR  szCookie, 
        IN const BSTR  szBalloonText); 

    STDMETHOD(DisableEvents) (
        IN const BOOL  fDisable,
        IN const ULONG ulDisableTimeout);

public:
    static HRESULT CreateInstance (
        REFIID  riid,
        VOID**  ppv);
};

// Helper functions for external modules
//
HRESULT HrGetNotifyConPoint(
    IConnectionPoint **             ppConPoint);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\ioctl.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Node control functions.

Author:

    John Vert (jvert) 2-Mar-1997

Revision History:

--*/

#include "nmp.h"


#define SECURITY_WIN32
#include <Security.h>

//
// Node Common properties.
//

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNodeCommonProperties[] = {
    { CLUSREG_NAME_NODE_DESC, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, 0 },
    { CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION, NULL, CLUSPROP_FORMAT_DWORD, 1, 0, 1, 0},
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpNodeROCommonProperties[] = {
    { CLUSREG_NAME_NODE_NAME, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { CLUSREG_NAME_NODE_HIGHEST_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { CLUSREG_NAME_NODE_LOWEST_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY },
    { CLUSREG_NAME_NODE_MAJOR_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { CLUSREG_NAME_NODE_MINOR_VERSION, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { CLUSREG_NAME_NODE_BUILD_NUMBER, NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { CLUSREG_NAME_NODE_CSDVERSION, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_READ_ONLY},
    { NULL, NULL, 0, 0, 0, 0, 0 } };

//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
NmpClusterRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    NULL,
    NULL,
    NULL
};


//
// Local Function Prototypes
//

DWORD
NmpNodeControl(
    IN PNM_NODE Node,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required,
    IN BOOLEAN AllowForwarding
    );

DWORD
NmpNodeEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeGetCommonProperties(
    IN PNM_NODE Node,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeValidateCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeSetCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeEnumPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeGetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeValidatePrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeSetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpNodeGetFlags(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpNodeGetClusterServiceAccountName(
    IN PNM_NODE Node,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required,
    IN BOOLEAN AllowForwarding
    );


/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by other nodes
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcNodeControl(
    IN handle_t IDL_handle,
    IN LPCWSTR NodeId, 
    IN DWORD ControlCode,
    IN UCHAR *InBuffer,
    IN DWORD InBufferSize,
    OUT UCHAR *OutBuffer,
    IN DWORD OutBufferSize,
    OUT DWORD *BytesReturned,
    OUT DWORD *Required
    )
/*++

Routine Description:

    Server-side routine for handling forwarded node control requests.

Arguments:

    IDL_handle - RPC binding handle. Not used.
    
    NodeId - Supplies the ID of the node to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the node control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.
            
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    PNM_NODE  node;
    DWORD     status;
    

    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process forwarded NodeControl "
            "request.\n"
            );

        return ERROR_NODE_NOT_AVAILABLE;
    }

    node = OmReferenceObjectById(ObjectTypeNode, NodeId);

    if (node != NULL) {
        status = NmpNodeControl(
                     node,
                     ControlCode,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required,
                     FALSE           // Prohibit forwarding to another node
                     );

        OmDereferenceObject(node);
    }
    else {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[NM] s_NmRpcNodeControl: Node %1!ws! does not exist.\n",
            NodeId
            );
    }

    NmpLeaveApi();

    return status;
    
}// s_NmRpcNodeControl()


/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
NmNodeControl(
    IN PNM_NODE Node,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    Node - Supplies the node to be controlled.

    HostNode - Supplies the host node on which the resource control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.
        
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes: 

    This routine assumes that a reference has been placed on the object 
    specified by the Node argument. 
    
--*/

{
    DWORD   status;



    if (NmpEnterApi(NmStateOnline)) {
        
        status = NmpNodeControl(
                     Node,
                     ControlCode,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required,
                     TRUE            // Permit forwarding to another node
                     );

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process NodeControl request.\n"
            );
    }

    return(status);

} // NmNodeControl


/////////////////////////////////////////////////////////////////////////////
//
// Local routines
//
/////////////////////////////////////////////////////////////////////////////


DWORD
NmpRpcNodeControlWrapper(
    IN PNM_NODE TargetNode,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    This routine is a wrapper of routine NmRpcNodeControl. 
    
        Verifies that the state of TargetNode is UP or PAUSED. 
        Call NmRpcNodeControl.
        Translate return status code of NmRpcNodeControl based on 
        whether TargetNode is up or down.
        
    
Arguments:
  
    TargetNode - A pointer to the object for the node that was the 
        target of the remote call.

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.
        
Return Value:

    The translated status code of NmRpcNodeControl.
    
--*/

{
    DWORD   returnStatus;


    ClRtlLogPrint(
        LOG_NOISE, 
        "[NM] Forwarding request for node control code (%1!u!) "
        "to node %2!u!.\n",
        ControlCode,
        TargetNode->NodeId
        );
    
    NmpAcquireLock();

    if (NM_NODE_UP(TargetNode)) {

        NmpReleaseLock();

        CL_ASSERT(Session[TargetNode->NodeId] != NULL);

        returnStatus = NmRpcNodeControl(
                         Session[TargetNode->NodeId], 
                         OmObjectId(TargetNode),   
                         ControlCode,
                         InBuffer,
                         InBufferSize,
                         OutBuffer,
                         OutBufferSize,
                         BytesReturned,
                         Required
                         );

        if (returnStatus != RPC_S_OK) {
            //
            // Translate the status for return to the 
            // cluster API client.
            //

            NmpAcquireLock();
        
            if (!NM_NODE_UP(TargetNode)) {  
        
                //
                // The node is down. 
                //
                switch ( returnStatus ) {
                    //
                    // These constants are copied from ReconnectCluster() in file 
                    // clusapi\reconect.c
                    //
                    case RPC_S_CALL_FAILED:
                    case RPC_S_INVALID_BINDING:
                    case RPC_S_SERVER_UNAVAILABLE:
                    case RPC_S_SERVER_TOO_BUSY:
                    case RPC_S_UNKNOWN_IF:
                    case RPC_S_CALL_FAILED_DNE:
                    case RPC_X_SS_IN_NULL_CONTEXT:
                    case RPC_S_UNKNOWN_AUTHN_SERVICE:
                        returnStatus = ERROR_HOST_NODE_NOT_AVAILABLE;
                        break;
               
                    default:
                        //
                        // Don't translate
                        //
                        break;
                } // switch                            
            }
            else {
                //
                // The node is up. Return the status as is. If the status is 
                // RPC_S_CALL_FAILED, RPC_S_INVALID_BINDING, or 
                // RPC_S_UNKNOWN_AUTHN_SERVICE, then the cluster API client will 
                // go through the reconnect procedure when it receives the status.
                // For now, that seems to be the right thing to do, even though the
                // client is talking to the local node, which is up. It is not clear
                // what alternate status codes we would map these to otherwise.
                //
            }
            
            NmpReleaseLock();
        } //  if (returnStatus != RPC_S_OK)
    } //  if (NM_NODE_UP(Node))
    else
    {
        NmpReleaseLock();

        ClRtlLogPrint(
            LOG_NOISE, 
            "[NM] Node %1!u! is not up. Cannot forward request "
            "for node control code (%2!u!) to that node.\n",
            TargetNode->NodeId,
            ControlCode
            );
        returnStatus = ERROR_HOST_NODE_NOT_AVAILABLE;
    }

    return(returnStatus);

} // NmpRpcNodeControlWrapper





DWORD
NmpNodeControl(
    IN PNM_NODE Node,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required,
    IN BOOLEAN AllowForwarding
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    Node - Supplies the node to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the node control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.
            
    AllowForwarding - Indicates whether the request may be forwarded to 
                      another node for execution. This is a safety check to 
                      prevent the accidental introduction of cycles.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes: 

    This routine assumes that a reference has been placed on the object 
    specified by the Node argument. 
    
--*/

{
    DWORD   status;
    HDMKEY  nodeKey;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;
    BOOLEAN success;


    //
    // Cluster service ioctls were designed to have access modes, e.g.
    // read-only, read-write, etc. These access modes are not implemented.
    // If eventually they are implemented, an access mode check should be
    // placed here.
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_NODE ) {
        return(ERROR_INVALID_FUNCTION);
    }

    nodeKey = DmOpenKey( DmNodesKey,
                         OmObjectId( Node ),
                         MAXIMUM_ALLOWED
                        );
    if ( nodeKey == NULL ) {
        return(GetLastError());
    }

    switch ( ControlCode ) {

    case CLUSCTL_NODE_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_NODE_GET_NAME:
        if ( OmObjectName( Node ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectName( Node ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectName( Node ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_GET_CLUSTER_SERVICE_ACCOUNT_NAME:
        status = NmpNodeGetClusterServiceAccountName(
                     Node,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required,
                     AllowForwarding
                     );
        break;
    
    case CLUSCTL_NODE_GET_ID:
        if ( OmObjectId( Node ) == NULL ) {
            return(ERROR_NOT_READY);
        }
        props.pb = OutBuffer;
        bufSize = (lstrlenW( OmObjectId( Node ) ) + 1) * sizeof(WCHAR);
        if ( bufSize > OutBufferSize ) {
            *Required = bufSize;
            *BytesReturned = 0;
            status = ERROR_MORE_DATA;
        } else {
            lstrcpyW( props.psz, OmObjectId( Node ) );
            *BytesReturned = bufSize;
            *Required = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_ENUM_COMMON_PROPERTIES:
        status = NmpNodeEnumCommonProperties( OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES:
        status = NmpNodeGetCommonProperties( Node,
                                             TRUE, // ReadOnly
                                             nodeKey,
                                             OutBuffer,
                                             OutBufferSize,
                                             BytesReturned,
                                             Required );
        break;

    case CLUSCTL_NODE_GET_COMMON_PROPERTIES:
        status = NmpNodeGetCommonProperties( Node,
                                             FALSE, // ReadOnly
                                             nodeKey,
                                             OutBuffer,
                                             OutBufferSize,
                                             BytesReturned,
                                             Required );
        break;

    case CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES:
        status = NmpNodeValidateCommonProperties( Node,
                                                  nodeKey,
                                                  InBuffer,
                                                  InBufferSize );
        break;

    case CLUSCTL_NODE_SET_COMMON_PROPERTIES:
        status = NmpNodeSetCommonProperties( Node,
                                             nodeKey,
                                             InBuffer,
                                             InBufferSize );
        break;

    case CLUSCTL_NODE_ENUM_PRIVATE_PROPERTIES:
        status = NmpNodeEnumPrivateProperties( Node,
                                               nodeKey,
                                               OutBuffer,
                                               OutBufferSize,
                                               BytesReturned,
                                               Required );
        break;

    case CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_GET_PRIVATE_PROPERTIES:
        status = NmpNodeGetPrivateProperties( Node,
                                              nodeKey,
                                              OutBuffer,
                                              OutBufferSize,
                                              BytesReturned,
                                              Required );
        break;

    case CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES:
        status = NmpNodeValidatePrivateProperties( Node,
                                                   nodeKey,
                                                   InBuffer,
                                                   InBufferSize );
        break;

    case CLUSCTL_NODE_SET_PRIVATE_PROPERTIES:
        status = NmpNodeSetPrivateProperties( Node,
                                              nodeKey,
                                              InBuffer,
                                              InBufferSize );
        break;

    case CLUSCTL_NODE_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NODE_GET_FLAGS:
        status = NmpNodeGetFlags( Node,
                                  nodeKey,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    DmCloseKey( nodeKey );

    return(status);

} // NmpNodeControl



DWORD
NmpNodeEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given node.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties( NmpNodeCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // NmpNodeEnumCommonProperties



DWORD
NmpNodeGetCommonProperties(
    IN PNM_NODE Node,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given node.

Arguments:

    Node - Supplies the node.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    RegistryKey - Supplies the registry key for this node.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                   status;
    PRESUTIL_PROPERTY_ITEM  propertyTable;

    if ( ReadOnly ) {
        propertyTable = NmpNodeROCommonProperties;
    } else {
        propertyTable = NmpNodeCommonProperties;
    }

    //
    // Get the common properties.
    //
    status = ClRtlGetProperties( RegistryKey,
                                 &NmpClusterRegApis,
                                 propertyTable,
                                 OutBuffer,
                                 OutBufferSize,
                                 BytesReturned,
                                 Required );

    return(status);

} // NmpNodeGetCommonProperties



DWORD
NmpNodeValidateCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the common properties for a given node.

Arguments:

    Node - Supplies the node object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( NmpNodeCommonProperties,
                                       NULL,     // Reserved
                                       FALSE,    // Don't allow unknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL,
                    "[NM] ValidateCommonProperties, error in verify routine.\n");
    }

    return(status);

} // NmpNodeValidateCommonProperties



DWORD
NmpNodeSetCommonProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given node.

Arguments:

    Node - Supplies the node object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD   status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPropertyTable( NmpNodeCommonProperties,
                                       NULL,    // Reserved
                                       FALSE,   // Don't allow unknowns
                                       InBuffer,
                                       InBufferSize,
                                       NULL );

    if ( status == ERROR_SUCCESS ) {

        status = ClRtlSetPropertyTable( NULL, 
                                        RegistryKey,
                                        &NmpClusterRegApis,
                                        NmpNodeCommonProperties,
                                        NULL,    // Reserved
                                        FALSE,   // Don't allow unknowns
                                        InBuffer,
                                        InBufferSize,
                                        FALSE,   // bForceWrite
                                        NULL );
        if ( status != ERROR_SUCCESS ) {
            ClRtlLogPrint( LOG_CRITICAL,
                       "[NM] SetCommonProperties, error in set routine.\n");
        }
    } else {
        ClRtlLogPrint( LOG_CRITICAL,
                    "[NM] SetCommonProperties, error in verify routine.\n");
    }

    return(status);

} // NmpNodeSetCommonProperties



DWORD
NmpNodeEnumPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given node.

Arguments:

    Node - Supplies the node object.

    RegistryKey - Registry key for the node.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster node parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Enum the private properties for the node.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &NmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNodeEnumPrivateProperties



DWORD
NmpNodeGetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given node.

Arguments:

    Node - Supplies the node object.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster node parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the node.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &NmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpNodeGetPrivateProperties



DWORD
NmpNodeValidatePrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given node.

Arguments:

    Node - Supplies the node object.

    RegistryKey - Registry key for the node.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // NmpNodeValidatePrivateProperties



DWORD
NmpNodeSetPrivateProperties(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given node.

Arguments:

    Node - Supplies the node object.

    RegistryKey - Registry key for the node.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster node\xx\parameters key
        //
        parametersKey = DmOpenKey( RegistryKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   MAXIMUM_ALLOWED );
        if ( parametersKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                parametersKey = DmCreateKey( RegistryKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             0,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &disposition );
                if ( parametersKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              parametersKey,
                                              &NmpClusterRegApis,
                                              InBuffer,
                                              InBufferSize );

        DmCloseKey( parametersKey );
    }

    return(status);

} // NmpNodeSetPrivateProperties



DWORD
NmpNodeGetFlags(
    IN PNM_NODE Node,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given node.

Arguments:

    Node - Supplies the node.

    RegistryKey - Registry key for the node.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the node.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // NmpNodeGetFlags


DWORD
NmpNodeGetClusterServiceAccountName(
    IN PNM_NODE Node,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required,
    IN BOOLEAN AllowForwarding
    )
/*++

Routine Description:

    Processes a node control request to obtain the name of the user account 
    under which the cluster service is running on the specified node.

Arguments:

    Node - Supplies the node to be controlled.

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.
            
    AllowForwarding - Indicates whether the request may be forwarded to 
                      another node for execution. This is a safety check to 
                      prevent the accidental introduction of cycles.
                      
Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

Notes: 

    This routine assumes that a reference has been placed on the object 
    specified by the Node argument. 
    
--*/
{
    DWORD status;


    if ( Node->NodeId != NmLocalNodeId ) 
    {
        //
        // Need to forward to the subject node for execution.
        //
        if (AllowForwarding) 
        {

            status = NmpRpcNodeControlWrapper(    Node,
                                                  CLUSCTL_NODE_GET_CLUSTER_SERVICE_ACCOUNT_NAME,
                                                  InBuffer,
                                                  InBufferSize,
                                                  OutBuffer,
                                                  OutBufferSize,
                                                  BytesReturned,
                                                  Required
                                                  );
        }
        else
        {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] Not allowed to forward request for the cluster service "
                "account name to node %1!u! - possible cycle.\n",
                Node->NodeId
                );
            status = ERROR_INVALID_FUNCTION;

            //
            // Currently, this path should never be taken. 
            // If it is taken, then a cycle was probably introduced.
            //
            CL_ASSERT(AllowForwarding != FALSE);
        }
    }
    else {
        //
        // The local node is the subject of the query, so  
        // we can execute this request locally.
        //
        BOOLEAN success;


        ClRtlLogPrint(
            LOG_NOISE, 
            "[NM] Processing request for the cluster service account name.\n"
            );

        *BytesReturned = OutBufferSize/sizeof(WCHAR);

        success = GetUserNameExW( 
                      NameUserPrincipal,
                      (LPWSTR)OutBuffer,
                      BytesReturned 
                      );     

        *BytesReturned = *BytesReturned * sizeof(WCHAR);

        if ( success ) {
            status = ERROR_SUCCESS;
        } else {
            *Required = *BytesReturned;
            *BytesReturned = 0;
            status = GetLastError();
        }
    }

    return status;

} // NmpNodeGetClusterServiceAccountName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\ifioctl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ifioctl.c

Abstract:

    Network interface control functions.

Author:

    John Vert (jvert) 2-Mar-1997

Revision History:

--*/

#include "nmp.h"

//
// Read-Write Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpInterfaceCommonProperties[] =
    {
        {
            CLUSREG_NAME_NETIFACE_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Description)
        },
        { 0 }
    };

//
// Read-Only Common Properties.
//
RESUTIL_PROPERTY_ITEM
NmpInterfaceROCommonProperties[] =
    {
        { CLUSREG_NAME_NETIFACE_NAME, NULL, CLUSPROP_FORMAT_SZ,
          0, 0, 0,
          RESUTIL_PROPITEM_READ_ONLY,
          FIELD_OFFSET(NM_INTERFACE_INFO2, Name)
        },
        {
            CLUSREG_NAME_NETIFACE_NODE, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NodeId)
        },
        {
            CLUSREG_NAME_NETIFACE_NETWORK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NetworkId)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterName)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_ID, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterId)
        },
        {
            CLUSREG_NAME_NETIFACE_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            RESUTIL_PROPITEM_READ_ONLY,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Address)
        },
        { 0 }
    };

//
// Cluster registry API function pointers.
// defined in ioctl.c
//
extern CLUSTER_REG_APIS NmpClusterRegApis;


//
// Local Functions
//

DWORD
NmpInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceGetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceValidateCommonProperties(
    IN PNM_INTERFACE Interface,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PNM_INTERFACE_INFO2 InterfaceInfo  OPTIONAL
    );

DWORD
NmpInterfaceSetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpInterfaceEnumPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceGetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );

DWORD
NmpInterfaceValidatePrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpInterfaceSetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    );

DWORD
NmpInterfaceGetFlags(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    );


DWORD
WINAPI
NmInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN PNM_NODE HostNode OPTIONAL,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    Interface - Supplies the network interface to be controlled.

    HostNode - Supplies the host node on which the resource control should
           be delivered. If this is NULL, the local node is used. Not honored!

    ControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer..

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource..

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource..

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;

    //
    // Cluster service ioctls were designed to have access modes, e.g.
    // read-only, read-write, etc. These access modes are not implemented.
    // If eventually they are implemented, an access mode check should be
    // placed here.
    //
    if ( CLUSCTL_GET_CONTROL_OBJECT( ControlCode ) != CLUS_OBJECT_NETINTERFACE ) {
        return(ERROR_INVALID_FUNCTION);
    }

    if (NmpEnterApi(NmStateOnline)) {
        status = NmpInterfaceControl(
                     Interface,
                     ControlCode,
                     InBuffer,
                     InBufferSize,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process InterfaceControl request.\n"
            );
    }

    return(status);

} // NmInterfaceControl



DWORD
NmpInterfaceControl(
    IN PNM_INTERFACE Interface,
    IN DWORD ControlCode,
    IN PUCHAR InBuffer,
    IN DWORD InBufferSize,
    OUT PUCHAR OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    Interface - Supplies the network interface to be controlled.

    ControlCode- Supplies the control code that defines the
        structure and action of the network interface control.
        Values of ControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    InBuffer- Supplies a pointer to the input buffer to be passed
        to the network interface.

    InBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    OutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network interface.

    OutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    BytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network interface.

    Required - Returns the number of bytes if the OutBuffer is not big
        enough.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD   status;
    HDMKEY  InterfaceKey;
    CLUSPROP_BUFFER_HELPER props;
    DWORD   bufSize;

    InterfaceKey = DmOpenKey(
                       DmNetInterfacesKey,
                       OmObjectId( Interface ),
                       MAXIMUM_ALLOWED
                       );

    if ( InterfaceKey == NULL ) {
        return(GetLastError());
    }

    switch ( ControlCode ) {

    case CLUSCTL_NETINTERFACE_UNKNOWN:
        *BytesReturned = 0;
        status = ERROR_SUCCESS;
        break;

    case CLUSCTL_NETINTERFACE_GET_NAME:
        NmpAcquireLock();
        if ( OmObjectName( Interface ) != NULL ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Interface ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Interface ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_GET_ID:
        NmpAcquireLock();
        if ( OmObjectId( Interface ) != NULL ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectId( Interface ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectId( Interface ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_GET_NODE:
        NmpAcquireLock();
        if ( (Interface->Node != NULL) && (OmObjectName( Interface->Node ) != NULL) ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Interface->Node ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Interface->Node ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_GET_NETWORK:
        NmpAcquireLock();
        if ( (Interface->Network != NULL) && (OmObjectName( Interface->Network ) != NULL) ) {
            props.pb = OutBuffer;
            bufSize = (lstrlenW( OmObjectName( Interface->Network ) ) + 1) * sizeof(WCHAR);
            if ( bufSize > OutBufferSize ) {
                *Required = bufSize;
                *BytesReturned = 0;
                status = ERROR_MORE_DATA;
            } else {
                lstrcpyW( props.psz, OmObjectName( Interface->Network ) );
                *BytesReturned = bufSize;
                *Required = 0;
                status = ERROR_SUCCESS;
            }
        } else {
            status = ERROR_NOT_READY;
        }
        NmpReleaseLock();
        break;

    case CLUSCTL_NETINTERFACE_ENUM_COMMON_PROPERTIES:
        status = NmpInterfaceEnumCommonProperties(
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES:
        status = NmpInterfaceGetCommonProperties(
                     Interface,
                     TRUE, // ReadOnly
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES:
        status = NmpInterfaceGetCommonProperties(
                     Interface,
                     FALSE, // ReadOnly
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES:
        status = NmpInterfaceValidateCommonProperties(
                     Interface,
                     InBuffer,
                     InBufferSize,
                     NULL
                     );
        break;

    case CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES:
        status = NmpInterfaceSetCommonProperties(
                     Interface,
                     InterfaceKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_RO_PRIVATE_PROPERTIES:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            LPDWORD ptrDword = (LPDWORD) OutBuffer;
            *ptrDword = 0;
            *BytesReturned = sizeof(DWORD);
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES:
        status = NmpInterfaceGetPrivateProperties(
                     Interface,
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_VALIDATE_PRIVATE_PROPERTIES:
        status = NmpInterfaceValidatePrivateProperties(
                     Interface,
                     InterfaceKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETINTERFACE_SET_PRIVATE_PROPERTIES:
        status = NmpInterfaceSetPrivateProperties(
                     Interface,
                     InterfaceKey,
                     InBuffer,
                     InBufferSize
                     );
        break;

    case CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS:
        if ( OutBufferSize < sizeof(DWORD) ) {
            *BytesReturned = 0;
            *Required = sizeof(DWORD);
            if ( OutBuffer == NULL ) {
                status = ERROR_SUCCESS;
            } else {
                status = ERROR_MORE_DATA;
            }
        } else {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
        break;

    case CLUSCTL_NETINTERFACE_GET_FLAGS:
        status = NmpInterfaceGetFlags(
                     Interface,
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    case CLUSCTL_NETINTERFACE_ENUM_PRIVATE_PROPERTIES:
        status = NmpInterfaceEnumPrivateProperties(
                     Interface,
                     InterfaceKey,
                     OutBuffer,
                     OutBufferSize,
                     BytesReturned,
                     Required
                     );
        break;

    default:
        status = ERROR_INVALID_FUNCTION;
        break;
    }

    DmCloseKey( InterfaceKey );

    return(status);

} // NmpInterfaceControl



DWORD
NmpInterfaceEnumCommonProperties(
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the common property names for a given network interface.

Arguments:

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Get the common properties.
    //
    status = ClRtlEnumProperties( NmpInterfaceCommonProperties,
                                  OutBuffer,
                                  OutBufferSize,
                                  BytesReturned,
                                  Required );

    return(status);

} // NmpInterfaceEnumCommonProperties



DWORD
NmpInterfaceGetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN BOOL ReadOnly,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the common properties for a given network interface.

Arguments:

    Interface - Supplies the network interface.

    ReadOnly - TRUE if the read-only properties should be read. FALSE otherwise.

    RegistryKey - Supplies the registry key for this network interface.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                    status;
    NM_INTERFACE_INFO2       interfaceInfo;
    PRESUTIL_PROPERTY_ITEM   propertyTable;
    DWORD                    outBufferSize = OutBufferSize;


    //
    // Fetch the properties from the object
    //
    ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

    NmpAcquireLock();

    status = NmpGetInterfaceObjectInfo(Interface, &interfaceInfo);

    if (status != ERROR_SUCCESS) {
        NmpReleaseLock();
        return(status);
    }

    if ( ReadOnly ) {
        LPCWSTR   name;
        DWORD     nameLength;


        propertyTable = NmpInterfaceROCommonProperties;

        //
        // Replace the network ID with a name
        //
        name = OmObjectName(Interface->Network);
        nameLength = NM_WCSLEN(name);
        MIDL_user_free(interfaceInfo.NetworkId);

        interfaceInfo.NetworkId = MIDL_user_allocate(nameLength);

        if (interfaceInfo.NetworkId != NULL) {
            wcscpy(interfaceInfo.NetworkId, name);

            //
            // Replace the node ID with a name
            //
            name = OmObjectName(Interface->Node);
            nameLength = NM_WCSLEN(name);
            MIDL_user_free(interfaceInfo.NodeId);

            interfaceInfo.NodeId = MIDL_user_allocate(nameLength);

            if (interfaceInfo.NodeId != NULL) {
                wcscpy(interfaceInfo.NodeId, name);
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {
        //
        // Construct a property list from the parameter block
        // for the read-write properties.
        //
        propertyTable = NmpInterfaceCommonProperties;
    }

    NmpReleaseLock();

    if (status == ERROR_SUCCESS) {
        status = ClRtlPropertyListFromParameterBlock(
                     propertyTable,
                     OutBuffer,
                     &outBufferSize,
                     (LPBYTE) &interfaceInfo,
                     BytesReturned,
                     Required
                     );
    }

    ClNetFreeInterfaceInfo(&interfaceInfo);

    return(status);

} // NmpInterfaceGetCommonProperties



DWORD
NmpInterfaceValidateCommonProperties(
    IN PNM_INTERFACE         Interface,
    IN PVOID                 InBuffer,
    IN DWORD                 InBufferSize,
    OUT PNM_INTERFACE_INFO2  InterfaceInfo  OPTIONAL
    )

/*++

Routine Description:

    Validates the common properties for a given network interface.

Arguments:

    Interface - Supplies the Interface object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

    InterfaceInfo - An optional pointer to an interface information structure
                    to be filled in with the updated property set.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                 status;
    NM_INTERFACE_INFO2    infoBuffer;
    PNM_INTERFACE_INFO2   interfaceInfo;
    LPCWSTR               interfaceId = OmObjectId(Interface);


    //
    // Check if there is input data.
    //
    if ( (InBuffer == NULL) ||
         (InBufferSize < sizeof(DWORD)) ) {
        return(ERROR_INVALID_DATA);
    }

    if (InterfaceInfo != NULL) {
        interfaceInfo = InterfaceInfo;
    }
    else {
        interfaceInfo = &infoBuffer;
    }

    ZeroMemory(interfaceInfo, sizeof(NM_INTERFACE_INFO2));

    //
    // Get a copy of the current interface parameters.
    //
    NmpAcquireLock();

    status = NmpGetInterfaceObjectInfo(Interface, interfaceInfo);

    if ( status != ERROR_SUCCESS ) {
        goto error_exit;
    }

    //
    // Validate the property list and update the parameter block.
    //
    status = ClRtlVerifyPropertyTable(
                 NmpInterfaceCommonProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InBuffer,
                 InBufferSize,
                 (LPBYTE) interfaceInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL, 
            "[NM] ValidateCommonProperties, error in verify routine.\n"
            );
        goto error_exit;
    }

    //
    // The change is valid.
    //

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    NmpReleaseLock();

    if ((status != ERROR_SUCCESS) || (interfaceInfo == &infoBuffer)) {
        ClNetFreeInterfaceInfo(interfaceInfo);
    }

    return(status);


} // NmpInterfaceValidateCommonProperties



DWORD
NmpInterfaceSetCommonProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the common properties for a given Interface.

Arguments:

    Interface - Supplies the Interface object.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD     status;
    LPCWSTR   interfaceId = OmObjectId(Interface);


    ClRtlLogPrint(LOG_NOISE, 
        "[NM] Setting common properties for interface %1!ws!.\n",
        interfaceId
        );

    //
    // Issue a global update
    //
    status = GumSendUpdateEx(
                 GumUpdateMembership,
                 NmUpdateSetInterfaceCommonProperties,
                 3,
                 NM_WCSLEN(interfaceId),
                 interfaceId,
                 InBufferSize,
                 InBuffer,
                 sizeof(InBufferSize),
                 &InBufferSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] Global update to set common properties for interface %1!ws! failed, status %2!u!.\n",
            interfaceId,
            status
            );
    }


    return(status);

} // NmpInterfaceSetCommonProperties



DWORD
NmpInterfaceEnumPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Enumerates the private property names for a given network interface.

Arguments:

    Interface - Supplies the Interface object.

    RegistryKey - Registry key for the Interface.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster Interface parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }
        return(status);
    }

    //
    // Get private properties for the interface.
    //
    status = ClRtlEnumPrivateProperties( parametersKey,
                                         &NmpClusterRegApis,
                                         OutBuffer,
                                         OutBufferSize,
                                         BytesReturned,
                                         Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpInterfaceEnumPrivateProperties



DWORD
NmpInterfaceGetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the private properties for a given network interface.

Arguments:

    Interface - Supplies the Interface object.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       totalBufferSize = 0;

    *BytesReturned = 0;
    *Required = 0;

    //
    // Clear the output buffer
    //
    ZeroMemory( OutBuffer, OutBufferSize );

    //
    // Open the cluster Interface parameters key.
    //
    parametersKey = DmOpenKey( RegistryKey,
                               CLUSREG_KEYNAME_PARAMETERS,
                               MAXIMUM_ALLOWED );
    if ( parametersKey == NULL ) {
        status = GetLastError();
        if ( status == ERROR_FILE_NOT_FOUND ) {
            //
            // If we don't have a parameters key, then return an
            // item count of 0 and an endmark.
            //
            totalBufferSize = sizeof(DWORD) + sizeof(CLUSPROP_SYNTAX);
            if ( OutBufferSize < totalBufferSize ) {
                *Required = totalBufferSize;
                status = ERROR_MORE_DATA;
            } else {
                // This is somewhat redundant since we zero the
                // buffer above, but it's here for clarity.
                CLUSPROP_BUFFER_HELPER buf;
                buf.pb = OutBuffer;
                buf.pList->nPropertyCount = 0;
                buf.pdw++;
                buf.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;
                *BytesReturned = totalBufferSize;
                status = ERROR_SUCCESS;
            }
        }
        return(status);
    }

    //
    // Get private properties for the network interface.
    //
    status = ClRtlGetPrivateProperties( parametersKey,
                                        &NmpClusterRegApis,
                                        OutBuffer,
                                        OutBufferSize,
                                        BytesReturned,
                                        Required );

    DmCloseKey( parametersKey );

    return(status);

} // NmpInterfaceGetPrivateProperties



DWORD
NmpInterfaceValidatePrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Validates the private properties for a given Interface.

Arguments:

    Interface - Supplies the Interface object.

    RegistryKey - Registry key for the Interface.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    return(status);

} // NmpInterfaceValidatePrivateProperties



DWORD
NmpInterfaceSetPrivateProperties(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    IN PVOID InBuffer,
    IN DWORD InBufferSize
    )

/*++

Routine Description:

    Sets the private properties for a given Interface.

Arguments:

    Interface - Supplies the Interface object.

    RegistryKey - Registry key for the Interface.

    InBuffer - Supplies the input buffer.

    InBufferSize - Supplies the size of the input buffer.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;
    HDMKEY      parametersKey;
    DWORD       disposition;

    //
    // Validate the property list.
    //
    status = ClRtlVerifyPrivatePropertyList( InBuffer,
                                             InBufferSize );

    if ( status == ERROR_SUCCESS ) {

        //
        // Open the cluster Interface\xx\parameters key
        //
        parametersKey = DmOpenKey( RegistryKey,
                                   CLUSREG_KEYNAME_PARAMETERS,
                                   MAXIMUM_ALLOWED );
        if ( parametersKey == NULL ) {
            status = GetLastError();
            if ( status == ERROR_FILE_NOT_FOUND ) {
                //
                // Try to create the parameters key.
                //
                parametersKey = DmCreateKey( RegistryKey,
                                             CLUSREG_KEYNAME_PARAMETERS,
                                             0,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &disposition );
                if ( parametersKey == NULL ) {
                    status = GetLastError();
                    return(status);
                }
            }
        }

        status = ClRtlSetPrivatePropertyList( NULL, // IN HANDLE hXsaction
                                              parametersKey,
                                              &NmpClusterRegApis,
                                              InBuffer,
                                              InBufferSize );
        DmCloseKey( parametersKey );
    }

    return(status);

} // NmpInterfaceSetPrivateProperties



DWORD
NmpInterfaceGetFlags(
    IN PNM_INTERFACE Interface,
    IN HDMKEY RegistryKey,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned,
    OUT LPDWORD Required
    )

/*++

Routine Description:

    Gets the flags for a given Interface.

Arguments:

    Interface - Supplies the Interface.

    RegistryKey - Registry key for the Interface.

    OutBuffer - Supplies the output buffer.

    OutBufferSize - Supplies the size of the output buffer.

    BytesReturned - The number of bytes returned in OutBuffer.

    Required - The required number of bytes if OutBuffer is too small.

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD       status;

    *BytesReturned = 0;

    if ( OutBufferSize < sizeof(DWORD) ) {
        *Required = sizeof(DWORD);
        if ( OutBuffer == NULL ) {
            status = ERROR_SUCCESS;
        } else {
            status = ERROR_MORE_DATA;
        }
    } else {
        DWORD       valueType;

        //
        // Read the Flags value for the Interface.
        //
        *BytesReturned = OutBufferSize;
        status = DmQueryValue( RegistryKey,
                               CLUSREG_NAME_FLAGS,
                               &valueType,
                               OutBuffer,
                               BytesReturned );
        if ( status == ERROR_FILE_NOT_FOUND ) {
            *BytesReturned = sizeof(DWORD);
            *(LPDWORD)OutBuffer = 0;
            status = ERROR_SUCCESS;
        }
    }

    return(status);

} // NmpInterfaceGetFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\interfac.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    interface.c

Abstract:

    Implements the Node Manager network interface management routines.

Author:

    Mike Massa (mikemas) 7-Nov-1996


Revision History:

--*/


#include "nmp.h"
#include <iphlpapi.h>
#include <iprtrmib.h>
#include <ntddndis.h>
#include <ndispnp.h>


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////
#define    NM_MAX_IF_PING_ENUM_SIZE      10
#define    NM_MAX_UNION_PING_ENUM_SIZE    5


LIST_ENTRY          NmpInterfaceList = {NULL, NULL};
LIST_ENTRY          NmpDeletedInterfaceList = {NULL, NULL};
DWORD               NmpInterfaceCount = 0;
WCHAR               NmpUnknownString[] = L"<Unknown>";
WCHAR               NmpNullString[] = L"";


RESUTIL_PROPERTY_ITEM
NmpInterfaceProperties[] =
    {
        {
            L"Id", NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Id)
        },
        {
            CLUSREG_NAME_NETIFACE_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Name)
        },
        {
            CLUSREG_NAME_NETIFACE_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Description)
        },
        {
            CLUSREG_NAME_NETIFACE_NODE, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NodeId)
        },
        {
            CLUSREG_NAME_NETIFACE_NETWORK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, NetworkId)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterName)
        },
        {
            CLUSREG_NAME_NET_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, Address)
        },
        {
            CLUSREG_NAME_NETIFACE_ENDPOINT, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, ClusnetEndpoint)
        },
        {
            CLUSREG_NAME_NETIFACE_STATE, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, 0xFFFFFFFF,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, State)
        },
        {
            CLUSREG_NAME_NETIFACE_ADAPTER_ID, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_INTERFACE_INFO2, AdapterId)
        },
        {
            0
        }
    };


/////////////////////////////////////////////////////////////////////////////
//
// Initialization & cleanup routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpInitializeInterfaces(
    VOID
    )
/*++

Routine Description:

    Initializes network interface resources.

Arguments:

    None.

Return Value:

   A Win32 status value.

--*/

{
    DWORD                       status;
    OM_OBJECT_TYPE_INITIALIZE   objectTypeInitializer;


    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing network interfaces.\n");

    //
    // Create the network interface object type
    //
    ZeroMemory(&objectTypeInitializer, sizeof(OM_OBJECT_TYPE_INITIALIZE));
    objectTypeInitializer.ObjectSize = sizeof(NM_INTERFACE);
    objectTypeInitializer.Signature = NM_INTERFACE_SIG;
    objectTypeInitializer.Name = L"Network Interface";
    objectTypeInitializer.DeleteObjectMethod = &NmpDestroyInterfaceObject;

    status = OmCreateType(ObjectTypeNetInterface, &objectTypeInitializer);

    if (status != ERROR_SUCCESS) {
        WCHAR  errorString[12];
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create network interface object type, %1!u!\n",
            status
            );
    }

    return(status);

}  // NmpInitializeInterfaces


VOID
NmpCleanupInterfaces(
    VOID
    )
/*++

Routine Description:

    Destroys all existing network interface resources.

Arguments:

    None.

Return Value:

   None.

--*/

{
    PNM_INTERFACE  netInterface;
    PLIST_ENTRY    entry;
    DWORD          status;


    ClRtlLogPrint(
        LOG_NOISE,
        "[NM] Interface cleanup starting...\n"
        );

    //
    // Now clean up all the interface objects.
    //
    NmpAcquireLock();

    while (!IsListEmpty(&NmpInterfaceList)) {

        entry = RemoveHeadList(&NmpInterfaceList);

        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);
        CL_ASSERT(NM_OM_INSERTED(netInterface));

        NmpDeleteInterfaceObject(netInterface, FALSE);
    }

    NmpReleaseLock();

    ClRtlLogPrint(LOG_NOISE,"[NM] Network interface cleanup complete\n");

    return;

}  // NmpCleanupInterfaces


/////////////////////////////////////////////////////////////////////////////
//
// Top-level routines called during network configuration
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateInterface(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD   status;


    CL_ASSERT(InterfaceInfo->NetIndex == NmInvalidInterfaceNetIndex);

    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to do the dirty work.
        //
        status = NmRpcCreateInterface2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     InterfaceInfo
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        HLOCALXSACTION   xaction;

        //
        // We are forming a cluster. Add the definition directly to the
        // database. The corresponding object will be created later in
        // the form process.
        //

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpCreateInterfaceDefinition(InterfaceInfo, xaction);

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalCreateInterface(InterfaceInfo);

        NmpReleaseLock();
    }

    return(status);

}  // NmpCreateInterface


DWORD
NmpSetInterfaceInfo(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD   status;


    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to do the dirty work.
        //
        status = NmRpcSetInterfaceInfo2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     InterfaceInfo
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        //
        // We are forming a cluster. Update the database directly.
        //
        HLOCALXSACTION   xaction;


        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpSetInterfaceDefinition(InterfaceInfo, xaction);

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalSetInterfaceInfo(InterfaceInfo);

        NmpReleaseLock();
    }

    return(status);

}  // NmpSetInterfaceInfo


DWORD
NmpDeleteInterface(
    IN     RPC_BINDING_HANDLE   JoinSponsorBinding,
    IN     LPWSTR               InterfaceId,
    IN     LPWSTR               NetworkId,
    IN OUT PBOOLEAN             NetworkDeleted
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD                status;


    *NetworkDeleted = FALSE;

    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to perform the update.
        //
        status = NmRpcDeleteInterface(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     InterfaceId,
                     NetworkDeleted
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        //
        // We are forming a cluster. Update the database directly.
        //
        HLOCALXSACTION  xaction;

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        //
        // Delete the interface from the database.
        //
        status = DmLocalDeleteTree(xaction, DmNetInterfacesKey, InterfaceId);

        if (status == ERROR_SUCCESS) {
            PNM_INTERFACE_ENUM2   interfaceEnum = NULL;

            //
            // If this interface was the last one defined for the associated
            // network, delete the network.
            //
            status = NmpEnumInterfaceDefinitions(&interfaceEnum);

            if (status == ERROR_SUCCESS) {
                BOOLEAN              deleteNetwork = TRUE;
                PNM_INTERFACE_INFO2  interfaceInfo;
                DWORD                i;


                for (i=0; i<interfaceEnum->InterfaceCount; i++) {
                    interfaceInfo = &(interfaceEnum->InterfaceList[i]);

                    if (wcscmp(interfaceInfo->NetworkId, NetworkId) == 0) {
                        deleteNetwork = FALSE;
                        break;
                    }
                }

                if (deleteNetwork) {
                    status = DmLocalDeleteTree(
                                 xaction,
                                 DmNetworksKey,
                                 NetworkId
                                 );

                    if (status == ERROR_SUCCESS) {
                        *NetworkDeleted = TRUE;
                    }
                }

                ClNetFreeInterfaceEnum(interfaceEnum);
            }
        }

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalDeleteInterface(
                     InterfaceId,
                     NetworkDeleted
                     );

        NmpReleaseLock();
    }

    return(status);

} // NmpDeleteInterface


/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by active member nodes
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcReportInterfaceConnectivity(
    IN PRPC_ASYNC_STATE            AsyncState,
    IN handle_t                    IDL_handle,
    IN LPWSTR                      InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    )
{
    PNM_INTERFACE  netInterface;
    DWORD          status = ERROR_SUCCESS;
    RPC_STATUS     tempStatus;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           InterfaceId
                           );

        if (netInterface != NULL) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Received connectivity report from node %1!u! (interface %2!u!) for network %3!ws! (%4!ws!).\n",
                netInterface->Node->NodeId,
                netInterface->NetIndex,
                OmObjectId(netInterface->Network),
                OmObjectName(netInterface->Network)
                );

            NmpProcessInterfaceConnectivityReport(
                netInterface,
                ConnectivityVector
                );

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Received connectivity report from unknown interface %1!ws!.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process connectivity report.\n"
            );
    }

    NmpReleaseLock();

    tempStatus = RpcAsyncCompleteCall(AsyncState, &status);

    if(tempStatus != RPC_S_OK)
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] s_NmRpcReportInterfaceConnectivity(), Error Completing Async RPC call, status %1!u!\n",
            tempStatus
            );

    return(status);

} // s_NmRpcReportInterfaceConnectivity


error_status_t
s_NmRpcGetInterfaceOnlineAddressEnum(
    IN handle_t             IDL_handle,
    IN LPWSTR               InterfaceId,
    OUT PNM_ADDRESS_ENUM *  OnlineAddressEnum
    )
{
    PNM_INTERFACE  netInterface;
    DWORD          status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received request to get online address enum for interface %1!ws!.\n",
        InterfaceId
        );

    *OnlineAddressEnum = NULL;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        netInterface = OmReferenceObjectById(ObjectTypeNetInterface, InterfaceId);

        if (netInterface != NULL) {
            status = NmpBuildInterfaceOnlineAddressEnum(
                         netInterface,
                         OnlineAddressEnum
                         );

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] GetInterfaceOnlineAddressEnum: interface %1!ws! doesn't exist.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process GetInterfaceOnlineAddressEnum request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcGetInterfaceOnlineAddressEnum


error_status_t
s_NmRpcGetInterfacePingAddressEnum(
    IN handle_t             IDL_handle,
    IN LPWSTR               InterfaceId,
    IN PNM_ADDRESS_ENUM     OnlineAddressEnum,
    OUT PNM_ADDRESS_ENUM *  PingAddressEnum
    )
{
    PNM_INTERFACE  netInterface;
    DWORD          status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received request to get ping address enum for interface %1!ws!.\n",
        InterfaceId
        );

    *PingAddressEnum = NULL;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        netInterface = OmReferenceObjectById(ObjectTypeNetInterface, InterfaceId);

        if (netInterface != NULL) {
            status = NmpBuildInterfacePingAddressEnum(
                         netInterface,
                         OnlineAddressEnum,
                         PingAddressEnum
                         );

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] GetInterfacePingAddressEnum: interface %1!ws! doesn't exist.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process GetInterfacePingAddressEnum request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcGetInterfacePingAddressEnum


//
// Note: s_NmRpcDoInterfacePing returns void rather than CallStatus
//       due to a MIDL compiler error in an early beta of W2K. Since
//       the CallStatus is the final parameter, the format on the
//       wire is the same; however, the call works in its current
//       format, so there is no point in changing it now.
//
void
s_NmRpcDoInterfacePing(
    IN  PRPC_ASYNC_STATE     AsyncState,
    IN  handle_t             IDL_handle,
    IN  LPWSTR               InterfaceId,
    IN  PNM_ADDRESS_ENUM     PingAddressEnum,
    OUT BOOLEAN *            PingSucceeded,
    OUT error_status_t *     CallStatus
    )
{
    DWORD          status = ERROR_SUCCESS;
    RPC_STATUS     tempStatus;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received request to ping targets for interface %1!ws!.\n",
        InterfaceId
        );

    *PingSucceeded = FALSE;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                          ObjectTypeNetInterface,
                                          InterfaceId
                                          );

        if (netInterface != NULL) {
            PNM_NETWORK    network = netInterface->Network;

            if ( (network->LocalInterface == netInterface) &&
                 NmpIsNetworkRegistered(network)
               )
            {
                NmpReleaseLock();

                status = NmpDoInterfacePing(
                             netInterface,
                             PingAddressEnum,
                             PingSucceeded
                             );

                NmpAcquireLock();
            }
            else {
                status = ERROR_INVALID_PARAMETER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] RpcDoInterfacePing: interface %1!ws! isn't local.\n",
                    InterfaceId
                    );
            }

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] RpcDoInterfacePing: interface %1!ws! doesn't exist.\n",
                InterfaceId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process RpcDoInterfacePing request.\n"
            );
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Finished pinging targets for interface %1!ws!.\n",
        InterfaceId
        );

    NmpReleaseLock();

    *CallStatus = status;

    tempStatus = RpcAsyncCompleteCall(AsyncState, NULL);

    if(tempStatus != RPC_S_OK)
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] s_NmRpcDoInterfacePing() Failed to complete Async RPC call, status %1!u!\n",
            tempStatus
            );


    return;

}  // s_NmRpcDoInterfacePing

/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by joining nodes
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcCreateInterface(
    IN handle_t            IDL_handle,
    IN DWORD               JoinSequence,  OPTIONAL
    IN LPWSTR              JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO  InterfaceInfo1
    )
{
    DWORD                status;
    NM_INTERFACE_INFO2   interfaceInfo2;

    //
    // Translate and call the V2.0 procedure.
    //
    CopyMemory(&interfaceInfo2, InterfaceInfo1, sizeof(NM_INTERFACE_INFO));

    //
    // The NetIndex isn't used in this call.
    //
    interfaceInfo2.NetIndex = NmInvalidInterfaceNetIndex;

    //
    // Use the unknown string for the adapter ID.
    //
    interfaceInfo2.AdapterId = NmpUnknownString;

    status = s_NmRpcCreateInterface2(
                 IDL_handle,
                 JoinSequence,
                 JoinerNodeId,
                 &interfaceInfo2
                 );

    return(status);

}  // s_NmRpcCreateInterface


error_status_t
s_NmRpcCreateInterface2(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,  OPTIONAL
    IN LPWSTR               JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO2  InterfaceInfo2
    )
{
    DWORD  status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Processing request to create new interface %1!ws! for joining node.\n",
            InterfaceInfo2->Id
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] CreateInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] CreateInterface call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            CL_ASSERT(InterfaceInfo2->NetIndex == NmInvalidInterfaceNetIndex);
            //
            // Just to be safe
            //
            InterfaceInfo2->NetIndex = NmInvalidInterfaceNetIndex;

            status = NmpGlobalCreateInterface(InterfaceInfo2);

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;

                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] CreateInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process CreateInterface request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcCreateInterface2


error_status_t
s_NmRpcSetInterfaceInfo(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,  OPTIONAL
    IN LPWSTR               JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO   InterfaceInfo1
    )
{
    DWORD                status;
    NM_INTERFACE_INFO2   interfaceInfo2;

    //
    // Translate and call the V2.0 procedure.
    //
    CopyMemory(&interfaceInfo2, InterfaceInfo1, sizeof(NM_INTERFACE_INFO));

    //
    // The NetIndex is not used in this call.
    //
    interfaceInfo2.NetIndex = NmInvalidInterfaceNetIndex;

    //
    // Use the unknown string for the adapter ID.
    //
    interfaceInfo2.AdapterId = NmpUnknownString;

    status = s_NmRpcSetInterfaceInfo2(
                 IDL_handle,
                 JoinSequence,
                 JoinerNodeId,
                 &interfaceInfo2
                 );

    return(status);

}  // s_NmRpcSetInterfaceInfo


error_status_t
s_NmRpcSetInterfaceInfo2(
    IN handle_t              IDL_handle,
    IN DWORD                 JoinSequence,  OPTIONAL
    IN LPWSTR                JoinerNodeId,  OPTIONAL
    IN PNM_INTERFACE_INFO2   InterfaceInfo2
    )
{
    DWORD      status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Processing request to set info for interface %1!ws! for joining node.\n",
            InterfaceInfo2->Id
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] SetInterfaceInfo call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] SetInterfaceInfo call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            status = NmpGlobalSetInterfaceInfo(InterfaceInfo2);

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;

                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] SetInterfaceInfo call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process SetInterfaceInfo request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcSetInterfaceInfo2


error_status_t
s_NmRpcDeleteInterface(
    IN  handle_t   IDL_handle,
    IN  DWORD      JoinSequence,  OPTIONAL
    IN  LPWSTR     JoinerNodeId,  OPTIONAL
    IN  LPWSTR     InterfaceId,
    OUT BOOLEAN *  NetworkDeleted
    )
{
    DWORD           status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Processing request to delete interface %1!ws! for joining node.\n",
            InterfaceId
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] DeleteInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] DeleteInterface call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {

            status = NmpGlobalDeleteInterface(
                         InterfaceId,
                         NetworkDeleted
                         );

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;
                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] DeleteInterface call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process DeleteInterface request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcDeleteInterface


error_status_t
NmpEnumInterfaceDefinitionsForJoiner(
    IN  DWORD                  JoinSequence,   OPTIONAL
    IN  LPWSTR                 JoinerNodeId,   OPTIONAL
    OUT PNM_INTERFACE_ENUM  *  InterfaceEnum1,
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum2
    )
{
    DWORD     status = ERROR_SUCCESS;
    PNM_NODE  joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Supplying interface information to joining node.\n"
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] EnumInterfaceDefinitions call for joining node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] EnumInterfaceDefinitions call for joining node %1!ws! failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            if (InterfaceEnum1 != NULL) {
                status = NmpEnumInterfaceObjects1(InterfaceEnum1);
            }
            else {
                CL_ASSERT(InterfaceEnum2 != NULL);
                status = NmpEnumInterfaceObjects(InterfaceEnum2);
            }

            if (joinerNode != NULL) {
                if (status == ERROR_SUCCESS) {
                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;
                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NMJOIN] EnumInterfaceDefinitions failed, status %1!u!.\n",
                        status
                        );

                    //
                    // Abort the join
                    //
                    NmpJoinAbort(status, joinerNode);
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process EnumInterfaceDefinitions request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmpEnumInterfaceDefinitionsForJoiner


error_status_t
s_NmRpcEnumInterfaceDefinitions(
    IN  handle_t              IDL_handle,
    IN  DWORD                 JoinSequence,   OPTIONAL
    IN  LPWSTR                JoinerNodeId,   OPTIONAL
    OUT PNM_INTERFACE_ENUM *  InterfaceEnum1
    )
{
    error_status_t  status;

    status = NmpEnumInterfaceDefinitionsForJoiner(
                 JoinSequence,
                 JoinerNodeId,
                 InterfaceEnum1,
                 NULL
                 );

    return(status);

}  // s_NmRpcEnumInterfaceDefinitions

error_status_t
s_NmRpcEnumInterfaceDefinitions2(
    IN  handle_t               IDL_handle,
    IN  DWORD                  JoinSequence,   OPTIONAL
    IN  LPWSTR                 JoinerNodeId,   OPTIONAL
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum2
    )
{
    error_status_t  status;

    status = NmpEnumInterfaceDefinitionsForJoiner(
                 JoinSequence,
                 JoinerNodeId,
                 NULL,
                 InterfaceEnum2
                 );

    return(status);

}  // s_NmRpcEnumInterfaceDefinitions2


error_status_t
s_NmRpcReportJoinerInterfaceConnectivity(
    IN handle_t                    IDL_handle,
    IN DWORD                       JoinSequence,
    IN LPWSTR                      JoinerNodeId,
    IN LPWSTR                      InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    )
{
    DWORD status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)){
        PNM_NODE joinerNode = OmReferenceObjectById(
                                  ObjectTypeNode,
                                  JoinerNodeId
                                  );

        if (joinerNode != NULL) {
            //
            // If the node is still joining, forward the report to the
            // leader. Note that reports may race with the node transitioning
            // to the up state, so accept reports from up nodes as well.
            //
            if ( ( (JoinSequence == NmpJoinSequence) &&
                   (NmpJoinerNodeId == joinerNode->NodeId) &&
                   (NmpSponsorNodeId == NmLocalNodeId) &&
                   !NmpJoinAbortPending
                 )
                 ||
                 NM_NODE_UP(joinerNode)
               )
            {
                PNM_INTERFACE  netInterface = OmReferenceObjectById(
                                                  ObjectTypeNetInterface,
                                                  InterfaceId
                                                  );

                if (netInterface != NULL) {
                    PNM_NETWORK   network = netInterface->Network;
                    LPCWSTR       networkId = OmObjectId(network);

                    if (NmpLeaderNodeId == NmLocalNodeId) {
                        //
                        // This node is the leader. Process the report.
                        //
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Processing connectivity report from joiner"
                            "node %1!ws! for network %2!ws!.\n",
                            JoinerNodeId,
                            networkId
                            );

                        NmpProcessInterfaceConnectivityReport(
                            netInterface,
                            ConnectivityVector
                            );
                    }
                    else {

                        //
                        // Forward the report to the leader.
                        //
                        RPC_BINDING_HANDLE  binding;

                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Forwarding connectivity report from joiner "
                            "node %1!ws! for network %2!ws! to leader.\n",
                            JoinerNodeId,
                            networkId
                            );

                        binding = Session[NmpLeaderNodeId];
                        CL_ASSERT(binding != NULL);

                        OmReferenceObject(network);

                        status = NmpReportInterfaceConnectivity(
                                     binding,
                                     InterfaceId,
                                     ConnectivityVector,
                                     (LPWSTR) networkId
                                     );

                        if (status != ERROR_SUCCESS) {
                            ClRtlLogPrint(LOG_UNUSUAL,
                                "[NM] Failed to forward connectivity report "
                                "from joiner node %1!ws! for network %2!ws!"
                                "to leader, status %3!u!\n",
                                JoinerNodeId,
                                networkId,
                                status
                                );
                        }

                        OmDereferenceObject(network);
                    }

                    OmDereferenceObject(netInterface);
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] Rejecting connectivity report from joining "
                        "node %1!ws! because interface %2!ws! does not "
                        "exist.\n",
                        JoinerNodeId,
                        InterfaceId
                        );
                    status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
                }
            }
            else {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] Ignoring connectivity report from joining "
                    "node %1!ws! because the join was aborted.\n",
                    JoinerNodeId
                    );
            }

            OmDereferenceObject(joinerNode);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] Ignoring connectivity report from joining node "
                "%1!ws! because the joiner is not a member of the cluster.\n",
                JoinerNodeId
                );
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process connectivity report "
            "from joiner node %1!ws!.\n",
            JoinerNodeId
            );
    }

    NmpReleaseLock();

    return(status);

} // s_NmRpcReportJoinerInterfaceConnectivity


/////////////////////////////////////////////////////////////////////////////
//
// Routines used to make global configuration changes when the node
// is online.
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpGlobalCreateInterface(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD  status;
    DWORD  interfacePropertiesSize;
    PVOID  interfaceProperties;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Issuing global update to create interface %1!ws!.\n",
        InterfaceInfo->Id
        );

    //
    // Marshall the info structures into property lists.
    //
    status = NmpMarshallObjectInfo(
                 NmpInterfaceProperties,
                 InterfaceInfo,
                 &interfaceProperties,
                 &interfacePropertiesSize
                 );

    if (status == ERROR_SUCCESS) {

        NmpReleaseLock();

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateCreateInterface,
                     2,
                     interfacePropertiesSize,
                     interfaceProperties,
                     sizeof(interfacePropertiesSize),
                     &interfacePropertiesSize
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Global update to create interface %1!ws! failed, status %2!u!.\n",
                InterfaceInfo->Id,
                status
                );
        }

        MIDL_user_free(interfaceProperties);

        NmpAcquireLock();
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to marshall properties for new interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
    }

    return(status);

}  // NmpGlobalCreateInterface


DWORD
NmpGlobalSetInterfaceInfo(
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD      status = ERROR_SUCCESS;
    DWORD      interfacePropertiesSize;
    PVOID      interfaceProperties;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Issuing global update to set info for interface %1!ws!.\n",
        InterfaceInfo->Id
        );

    //
    // Marshall the info structures into property lists.
    //
    status = NmpMarshallObjectInfo(
                 NmpInterfaceProperties,
                 InterfaceInfo,
                 &interfaceProperties,
                 &interfacePropertiesSize
                 );

    if (status == ERROR_SUCCESS) {
        NmpReleaseLock();

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateSetInterfaceInfo,
                     2,
                     interfacePropertiesSize,
                     interfaceProperties,
                     sizeof(interfacePropertiesSize),
                     &interfacePropertiesSize
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Global update to set properties for interface %1!ws! failed, status %2!u!.\n",
                InterfaceInfo->Id,
                status
                );
        }

        MIDL_user_free(interfaceProperties);

        NmpAcquireLock();
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to marshall properties for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
    }

    return(status);

}  // NmpGlobalSetInterfaceInfo


DWORD
NmpGlobalDeleteInterface(
    IN     LPWSTR    InterfaceId,
    IN OUT PBOOLEAN  NetworkDeleted
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD           status = ERROR_SUCCESS;
    PNM_INTERFACE   netInterface;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Issuing global update to delete interface %1!ws!.\n",
        InterfaceId
        );

    //
    // Find the interface object
    //
    netInterface = OmReferenceObjectById(ObjectTypeNetInterface, InterfaceId);

    if (netInterface != NULL) {
        NmpReleaseLock();

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateDeleteInterface,
                     1,
                     (lstrlenW(InterfaceId)+1) * sizeof(WCHAR),
                     InterfaceId
                     );

        NmpAcquireLock();

        if (status == ERROR_SUCCESS) {
            //
            // Check if the network was deleted too
            //
            if (netInterface->Network->Flags & NM_FLAG_DELETE_PENDING) {
                *NetworkDeleted = TRUE;
            }
            else {
                *NetworkDeleted = FALSE;
            }
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Global update to delete interface %1!ws! failed, status %2!u!.\n",
                InterfaceId,
                status
                );
        }

        OmDereferenceObject(netInterface);
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to find interface %1!ws!.\n",
            InterfaceId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
    }

    return(status);

}  // NmpGlobalDeleteInterface


/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETINTERFACE_STATE
NmGetInterfaceState(
    IN  PNM_INTERFACE  Interface
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NETINTERFACE_STATE  state;


    NmpAcquireLock();

    state = Interface->State;

    NmpReleaseLock();

    return(state);

} // NmGetInterfaceState


DWORD
NmGetInterfaceForNodeAndNetwork(
    IN     LPCWSTR    NodeName,
    IN     LPCWSTR    NetworkName,
    OUT    LPWSTR *   InterfaceName
    )
/*++

Routine Description:

    Returns the name of the interface which connects a specified node
    to a specified network.

Arguments:

    NodeName - A pointer to the unicode name of the node.

    NetworkName - A pointer to the unicode name of the network.

    InterfaceName - On output, contains a pointer to the unicode name of the
                    interface.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

--*/
{
    DWORD      status;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE   node = OmReferenceObjectByName(ObjectTypeNode, NodeName);

        if (node != NULL) {
            PNM_NETWORK   network = OmReferenceObjectByName(
                                        ObjectTypeNetwork,
                                        NetworkName
                                        );

            if (network != NULL) {
                PLIST_ENTRY     entry;
                PNM_INTERFACE   netInterface;


                status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;

                for (entry = node->InterfaceList.Flink;
                     entry != &(node->InterfaceList);
                     entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NodeLinkage
                                       );

                    if (netInterface->Network == network) {
                        LPCWSTR  interfaceId = OmObjectName(netInterface);
                        DWORD    nameLength = NM_WCSLEN(interfaceId);

                        *InterfaceName = MIDL_user_allocate(nameLength);

                        if (*InterfaceName != NULL) {
                            lstrcpyW(*InterfaceName, interfaceId);
                            status = ERROR_SUCCESS;
                        }
                        else {
                            status = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }

                OmDereferenceObject(network);
            }
            else {
                status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
            }

            OmDereferenceObject(node);
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_FOUND;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process GetInterfaceForNodeAndNetwork request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmGetInterfaceForNodeAndNetwork


/////////////////////////////////////////////////////////////////////////////
//
// Handlers for global updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpUpdateCreateInterface(
    IN BOOL     IsSourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    )
/*++

Routine Description:

    Global update handler for creating a new interface. The interface
    definition is read from the cluster database, and a corresponding
    object is instantiated. The cluster transport is also updated if
    necessary.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine must not be called with the NM lock held.

--*/
{
    DWORD                  status = ERROR_SUCCESS;
    NM_INTERFACE_INFO2     interfaceInfo;
    BOOLEAN                lockAcquired = FALSE;
    HLOCALXSACTION         xaction = NULL;
    PNM_INTERFACE          netInterface = NULL;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process CreateInterface update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

    //
    // Unmarshall the property list.
    //
    status = NmpConvertPropertyListToInterfaceInfo(
                 InterfacePropertyList,
                 *InterfacePropertyListSize,
                 &interfaceInfo
                 );

    if (status == ERROR_SUCCESS) {
        //
        // Fake missing V2 fields
        //
        if (interfaceInfo.AdapterId == NULL) {
            interfaceInfo.AdapterId = NmpUnknownString;
        }

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Received update to create interface %1!ws!.\n",
            interfaceInfo.Id
            );

        //
        // Start a transaction - this must be done before acquiring
        //                       the NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction != NULL) {

            NmpAcquireLock(); lockAcquired = TRUE;

            status = NmpCreateInterfaceDefinition(&interfaceInfo, xaction);

            if (status == ERROR_SUCCESS) {
                CL_NODE_ID             joinerNodeId;


                joinerNodeId = NmpJoinerNodeId;

                NmpReleaseLock();

                netInterface = NmpCreateInterfaceObject(
                                   &interfaceInfo,
                                   TRUE  // Do retry on failure
                                   );

                NmpAcquireLock();

                if (netInterface != NULL) {
                    //
                    // If a node happens to be joining right now, flag
                    // the fact that it is now out of synch with the
                    // cluster config.
                    //
                    if ( ( (joinerNodeId != ClusterInvalidNodeId) &&
                           (netInterface->Node->NodeId != joinerNodeId)
                         ) ||
                         ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
                           (netInterface->Node->NodeId != NmpJoinerNodeId)
                         )
                       )
                    {
                        NmpJoinerOutOfSynch = TRUE;
                    }

                    ClusterEvent(
                        CLUSTER_EVENT_NETINTERFACE_ADDED,
                        netInterface
                        );
                }
                else {
                    status = GetLastError();
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NM] Failed to create object for interface %1!ws!, "
                        "status %2!u!.\n",
                        interfaceInfo.Id,
                        status
                        );
                }
            }
            else {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to write definition for interface %1!ws!, "
                    "status %2!u!.\n",
                    interfaceInfo.Id,
                    status
                    );
            }
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to begin a transaction, status %1!u!\n",
                status
                );
        }

        //
        // Remove faked V2 fields
        //
        if (interfaceInfo.AdapterId == NmpUnknownString) {
            interfaceInfo.AdapterId = NULL;
        }

        ClNetFreeInterfaceInfo(&interfaceInfo);
    }
    else {
        ClRtlLogPrint( LOG_CRITICAL,
            "[NM] Failed to unmarshall properties for new interface, "
            "status %1!u!.\n",
            status
            );
    }

    if (lockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (netInterface != NULL) {
        //
        // Remove the reference put on by
        // NmpCreateInterfaceObject.
        //
        OmDereferenceObject(netInterface);
    }

    return(status);

} // NmpUpdateCreateInterface


DWORD
NmpUpdateSetInterfaceInfo(
    IN BOOL     IsSourceNode,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    )
/*++

Routine Description:

    Global update handler for setting the properties of an interface.
    This update is issued in response to interface property changes that
    are detected internally.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    InterfacePropertyList - A pointer to a property list that encodes the
                            new properties for the interface. All of the
                            string properties must be present, except those
                            noted in the code below.

    InterfacePropertyListSize - A pointer to a variable containing the size,
                                in bytes, of the property list described
                                by the InterfacePropertyList parameter.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD                status;
    NM_INTERFACE_INFO2   interfaceInfo;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetInterfaceInfo update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Unmarshall the property list so we can extract the interface ID.
    //
    status = NmpConvertPropertyListToInterfaceInfo(
                 InterfacePropertyList,
                 *InterfacePropertyListSize,
                 &interfaceInfo
                 );

    if (status == ERROR_SUCCESS) {
        PNM_INTERFACE  netInterface;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Received update to set properties for interface %1!ws!.\n",
            interfaceInfo.Id
            );

        //
        // Fake missing V2 fields
        //
        if (interfaceInfo.AdapterId == NULL) {
            interfaceInfo.AdapterId = NmpUnknownString;
        }

        //
        // Find the interface object
        //
        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           interfaceInfo.Id
                           );

        if (netInterface != NULL) {
            HLOCALXSACTION   xaction;

            //
            // Begin a transaction - this must be done before acquiring the
            //                       NM lock.
            //
            xaction = DmBeginLocalUpdate();

            if (xaction != NULL) {

                NmpAcquireLock();

                //
                // Process the changes
                //
                status = NmpLocalSetInterfaceInfo(
                             netInterface,
                             &interfaceInfo,
                             xaction
                             );

                NmpReleaseLock();

                //
                // Complete the transaction - this must be done after
                //                            releasing the NM lock.
                //
                if (status == ERROR_SUCCESS) {
                    DmCommitLocalUpdate(xaction);
                }
                else {
                    DmAbortLocalUpdate(xaction);
                }
            }
            else {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to begin a transaction, status %1!u!\n",
                    status
                    );
            }

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Unable to find interface %1!ws!.\n",
                interfaceInfo.Id
                );
        }

        //
        // Remove faked V2 fields
        //
        if (interfaceInfo.AdapterId == NmpUnknownString) {
            interfaceInfo.AdapterId = NULL;
        }

        ClNetFreeInterfaceInfo(&interfaceInfo);
    }
    else {
        ClRtlLogPrint( LOG_CRITICAL,
            "[NM] Failed to unmarshall properties for interface update, "
            "status %1!u!.\n",
            status
            );
    }

    NmpLeaveApi();

    return(status);

} // NmpUpdateSetInterfaceInfo


DWORD
NmpUpdateSetInterfaceCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    )
/*++

Routine Description:

    Global update handler for setting the common properties of a interface.
    This update is issued in response to a property change request made
    through the cluster API.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    InterfaceId - A pointer to a unicode string containing the ID of the
                  interface to update.

    PropertyList - A pointer to a property list that encodes the
                   new properties for the interface. The list might contain
                   only a partial property set for the object.

    PropertyListLength - A pointer to a variable containing the size,
                         in bytes, of the property list described
                         by the PropertyList parameter.



Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_INTERFACE  netInterface;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetInterfaceCommonProperties "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to set common properties for "
        "interface %1!ws!.\n",
        InterfaceId
        );

    //
    // Find the interface's object
    //
    netInterface = OmReferenceObjectById(
                       ObjectTypeNetInterface,
                       InterfaceId
                       );

    if (netInterface != NULL) {
        HLOCALXSACTION   xaction;

        //
        // Begin a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction != NULL) {
            NM_INTERFACE_INFO2      interfaceInfo;


            ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

            NmpAcquireLock();

            //
            // Validate the property list and convert it to an
            // interface info struct. Properties that are not present
            // in the property list will be copied from the interface
            // object.
            //
            status = NmpInterfaceValidateCommonProperties(
                         netInterface,
                         PropertyList,
                         *PropertyListLength,
                         &interfaceInfo
                         );

            if (status == ERROR_SUCCESS) {
                //
                // Fake missing V2 fields
                //
                if (interfaceInfo.AdapterId == NULL) {
                    interfaceInfo.AdapterId = NmpUnknownString;
                }

                //
                // Apply the changes
                //
                status = NmpLocalSetInterfaceInfo(
                             netInterface,
                             &interfaceInfo,
                             xaction
                             );

                NmpReleaseLock();

                //
                // Remove faked V2 fields
                //
                if (interfaceInfo.AdapterId == NmpUnknownString) {
                    interfaceInfo.AdapterId = NULL;
                }

                ClNetFreeInterfaceInfo(&interfaceInfo);
            }
            else {
                NmpReleaseLock();

                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Update to set common properties for interface "
                    "%1!ws! failed because property list validation failed "
                    "with status %2!u!.\n",
                    InterfaceId,
                    status
                    );
            }

            //
            // Complete the transaction - this must be done after releasing
            //                            the NM lock.
            //
            if (status == ERROR_SUCCESS) {
                DmCommitLocalUpdate(xaction);
            }
            else {
                DmAbortLocalUpdate(xaction);
            }
        }
        else {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to begin a transaction, status %1!u!\n",
                status
                );
        }

        OmDereferenceObject(netInterface);
    }
    else {
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to find interface %1!ws!.\n",
            InterfaceId
            );
    }

    NmpLeaveApi();

    return(status);

} // NmpUpdateSetInterfaceCommonProperties


DWORD
NmpUpdateDeleteInterface(
    IN BOOL     IsSourceNode,
    IN LPWSTR   InterfaceId
    )
/*++

Routine Description:

    Global update handler for deleting an interface. The corresponding
    object is deleted. The cluster transport is also updated if
    necessary.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    InterfaceId - A pointer to a unicode string containing the ID of the
                  interface to delete.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD            status;
    PNM_INTERFACE    netInterface;
    HLOCALXSACTION   xaction;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process DeleteInterface update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update request to delete interface %1!ws!.\n",
        InterfaceId
        );

    xaction = DmBeginLocalUpdate();

    if (xaction != NULL) {
        //
        // Find the interface object
        //
        netInterface = OmReferenceObjectById(
                           ObjectTypeNetInterface,
                           InterfaceId
                           );

        if (netInterface != NULL) {
            BOOLEAN      deleteNetwork = FALSE;
            PNM_NETWORK  network;
            LPCWSTR      networkId;

            NmpAcquireLock();

            network = netInterface->Network;
            networkId = OmObjectId(network);

            //
            // Delete the interface definition from the database.
            //
            status = DmLocalDeleteTree(
                         xaction,
                         DmNetInterfacesKey,
                         InterfaceId
                         );

            if (status == ERROR_SUCCESS) {
                if (network->InterfaceCount == 1) {
                    //
                    // This is the last interface on the network.
                    // Delete the network too.
                    //
                    deleteNetwork = TRUE;

                    status = DmLocalDeleteTree(
                                 xaction,
                                 DmNetworksKey,
                                 networkId
                                 );

                    if (status != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_CRITICAL,
                            "[NM] Failed to delete definition for network "
                            "%1!ws!, status %2!u!.\n",
                            networkId,
                            status
                            );
                    }
                }
            }
            else {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to delete definition for interface %1!ws!, "
                    "status %2!u!.\n",
                    InterfaceId,
                    status
                    );
            }

            if (status == ERROR_SUCCESS) {
                NmpDeleteInterfaceObject(netInterface, TRUE);

                if (deleteNetwork) {
                    NmpDeleteNetworkObject(network, TRUE);
                }
                else if (NmpIsNetworkRegistered(network)) {
                    //
                    // Schedule a connectivity report.
                    //
                    NmpScheduleNetworkConnectivityReport(network);
                }

                //
                // If a node happens to be joining right now, flag the
                // fact that it is now out of synch with the cluster
                // config.
                //
                if ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
                     (netInterface->Node->NodeId != NmpJoinerNodeId)
                   )
                {
                    NmpJoinerOutOfSynch = TRUE;
                }
            }

            NmpReleaseLock();

            OmDereferenceObject(netInterface);
        }
        else {
            status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Unable to find interface %1!ws!.\n",
                InterfaceId
                );
        }

        //
        // Complete the transaction
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
    }

    NmpLeaveApi();

    return(status);

} // NmpUpdateDeleteInterface


/////////////////////////////////////////////////////////////////////////////
//
// Update helper routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpLocalSetInterfaceInfo(
    IN  PNM_INTERFACE         Interface,
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    IN  HLOCALXSACTION        Xaction
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD          status = ERROR_SUCCESS;
    PNM_NETWORK    network = Interface->Network;
    LPCWSTR        interfaceId = OmObjectId(Interface);
    HDMKEY         interfaceKey = NULL;
    BOOLEAN        updateClusnet = FALSE;
    BOOLEAN        propertyChanged = FALSE;
    BOOLEAN        nameChanged = FALSE;
    LPWSTR         descString = NULL;
    LPWSTR         adapterNameString = NULL;
    LPWSTR         adapterIdString = NULL;
    LPWSTR         addressString = NULL;
    LPWSTR         endpointString = NULL;
    DWORD          size;
    ULONG          ifAddress;


    //
    // Open the interface's database key
    //
    interfaceKey = DmOpenKey(DmNetInterfacesKey, interfaceId, KEY_WRITE);

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open database key for interface %1!ws!, "
            "status %2!u!\n",
            interfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Check if the description changed.
    //
    if (wcscmp(Interface->Description, InterfaceInfo->Description) != 0) {
        size = NM_WCSLEN(InterfaceInfo->Description);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_DESC,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->Description,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of name value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        descString = MIDL_user_allocate(size);

        if (descString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(descString, InterfaceInfo->Description);

        propertyChanged = TRUE;
    }

    //
    // Check if the adapter name changed.
    //
    if (wcscmp(Interface->AdapterName, InterfaceInfo->AdapterName) != 0) {
        size = NM_WCSLEN(InterfaceInfo->AdapterName);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ADAPTER_NAME,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->AdapterName,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of adapter name value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        adapterNameString = MIDL_user_allocate(size);

        if (adapterNameString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(adapterNameString, InterfaceInfo->AdapterName);

        propertyChanged = TRUE;
    }

    //
    // Check if the adapter Id changed.
    //
    if (wcscmp(Interface->AdapterId, InterfaceInfo->AdapterId) != 0) {
        size = NM_WCSLEN(InterfaceInfo->AdapterId);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ADAPTER_ID,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->AdapterId,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of adapter Id value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        adapterIdString = MIDL_user_allocate(size);

        if (adapterIdString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(adapterIdString, InterfaceInfo->AdapterId);

        propertyChanged = TRUE;
    }

    //
    // Check if the address changed.
    //
    if (wcscmp(Interface->Address, InterfaceInfo->Address) != 0) {

        status = ClRtlTcpipStringToAddress(
                     InterfaceInfo->Address,
                     &ifAddress
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert interface address string %1!ws! to "
                "binary, status %2!u!.\n",
                InterfaceInfo->Address,
                status
                );
            goto error_exit;
        }

        size = NM_WCSLEN(InterfaceInfo->Address);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ADDRESS,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->Address,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of address value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        addressString = MIDL_user_allocate(size);

        if (addressString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(addressString, InterfaceInfo->Address);

        updateClusnet = TRUE;
        propertyChanged = TRUE;
    }

    //
    // Check if the clusnet endpoint changed.
    //
    if (wcscmp(
            Interface->ClusnetEndpoint,
            InterfaceInfo->ClusnetEndpoint
            ) != 0
       )
    {
        size = NM_WCSLEN(InterfaceInfo->ClusnetEndpoint);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_ENDPOINT,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->ClusnetEndpoint,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of endpoint value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        //
        // Allocate new memory resources. The object will be updated when the
        // transaction commits.
        //
        endpointString = MIDL_user_allocate(size);

        if (endpointString == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory\n");
            goto error_exit;
        }

        wcscpy(endpointString, InterfaceInfo->ClusnetEndpoint);

        updateClusnet = TRUE;
        propertyChanged = TRUE;
    }

    //
    // Check if the object name changed.
    //
    if (wcscmp(OmObjectName(Interface), InterfaceInfo->Name) != 0) {
        size = NM_WCSLEN(InterfaceInfo->Name);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     Xaction,
                     interfaceKey,
                     CLUSREG_NAME_NETIFACE_NAME,
                     REG_SZ,
                     (CONST BYTE *) InterfaceInfo->Name,
                     size
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of name value failed for interface %1!ws!, "
                "status %2!u!.\n",
                interfaceId,
                status
                );
            goto error_exit;
        }

        nameChanged = TRUE;
        propertyChanged = TRUE;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmSetInterfaceInfoAbort) {
        status = 999999;
        goto error_exit;
    }
#endif

    //
    // Commit the changes
    //
    if (nameChanged) {
        status = OmSetObjectName(Interface, InterfaceInfo->Name);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to change name for interface %1!ws!, "
                "status %2!u!\n",
                interfaceId,
                status
                );
            goto error_exit;
        }
    }

    if (descString != NULL) {
        MIDL_user_free(Interface->Description);
        Interface->Description = descString;
    }

    if (adapterNameString != NULL) {
        MIDL_user_free(Interface->AdapterName);
        Interface->AdapterName = adapterNameString;
    }

    if (adapterIdString != NULL) {
        MIDL_user_free(Interface->AdapterId);
        Interface->AdapterId = adapterIdString;
    }

    if (addressString != NULL) {
        MIDL_user_free(Interface->Address);
        Interface->Address = addressString;
        Interface->BinaryAddress = ifAddress;
    }

    if (endpointString != NULL) {
        MIDL_user_free(Interface->ClusnetEndpoint);
        Interface->ClusnetEndpoint = endpointString;
    }

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
        interfaceKey = NULL;
    }

    //
    // Update the cluster transport if this network is active and the local
    // node is attached to it.
    //
    // This operation is not reversible. Failure is fatal for this node.
    //
    network = Interface->Network;

    if (updateClusnet && NmpIsNetworkRegistered(network)) {
        PNM_NODE     node = Interface->Node;
        LPCWSTR      networkId = OmObjectId(network);


        if (Interface == network->LocalInterface) {
            //
            // This is the local node's interface to the network.
            // We must deregister and then re-register the entire network.
            //
            NmpDeregisterNetwork(network);

            status = NmpRegisterNetwork(
                         network,
                         TRUE  // Do retry on failure
                         );
        }
        else {
            //
            // This is another node's interface to the network.
            // Deregister and then re-register the interface.
            //
            NmpDeregisterInterface(Interface);

            status = NmpRegisterInterface(
                         Interface,
                         TRUE   // Do retry on failure
                         );
        }

#ifdef CLUSTER_TESTPOINT
        TESTPT(TpFailNmSetInterfaceInfoHalt) {
            status = 999999;
        }
#endif

        if (status != ERROR_SUCCESS) {
            //
            // This is fatal.
            //
            CsInconsistencyHalt(status);
        }
    }

    if (propertyChanged) {
        ClusterEvent(CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE, Interface);

        //
        // If a node happens to be joining right now, flag the fact
        // that it is now out of synch with the cluster config.
        //
        if ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
             (Interface->Node->NodeId != NmpJoinerNodeId)
           )
        {
            NmpJoinerOutOfSynch = TRUE;
        }
    }

    return(ERROR_SUCCESS);

error_exit:

    if (descString != NULL) {
        MIDL_user_free(descString);
    }

    if (adapterNameString != NULL) {
        MIDL_user_free(adapterNameString);
    }

    if (adapterIdString != NULL) {
        MIDL_user_free(adapterIdString);
    }

    if (addressString != NULL) {
        MIDL_user_free(addressString);
    }

    if (endpointString != NULL) {
        MIDL_user_free(endpointString);
    }

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

} // NmpLocalSetInterfaceInfo


/////////////////////////////////////////////////////////////////////////////
//
// Database management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateInterfaceDefinition(
    IN PNM_INTERFACE_INFO2   InterfaceInfo,
    IN HLOCALXSACTION        Xaction
    )
/*++

Routine Description:

    Creates a new network interface definition in the cluster database.

Arguments:

    InterfaceInfo - A structure containing the interface's definition.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    interfaceKey = NULL;
    DWORD     valueLength;
    DWORD     disposition;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating database entry for interface %1!ws!\n",
        InterfaceInfo->Id
        );

    CL_ASSERT(InterfaceInfo->Id != NULL);

    interfaceKey = DmLocalCreateKey(
                        Xaction,
                        DmNetInterfacesKey,
                        InterfaceInfo->Id,
                        0,
                        KEY_WRITE,
                        NULL,
                        &disposition
                        );

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create key for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
        return(status);
    }

    CL_ASSERT(disposition == REG_CREATED_NEW_KEY);

    //
    // Write the network ID value for this interface.
    //
    valueLength = NM_WCSLEN(InterfaceInfo->NetworkId);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NETWORK,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->NetworkId,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Write of interface network ID failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the node ID value for this interface.
    //
    valueLength = NM_WCSLEN(InterfaceInfo->NodeId);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NODE,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->NodeId,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Write of interface node ID failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the rest of the parameters
    //
    status = NmpSetInterfaceDefinition(InterfaceInfo, Xaction);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to set database definition for interface %1!ws!, status %2!u!.\n",
            InterfaceInfo->Id,
            status
            );
    }

error_exit:

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

} // NmpCreateInterfaceDefinition



DWORD
NmpGetInterfaceDefinition(
    IN  LPWSTR               InterfaceId,
    OUT PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network interface from the
    cluster database and fills in a structure describing it.

Arguments:

    InterfaceId - A pointer to a unicode string containing the ID of the
                  interface to query.

    InterfaceInfo - A pointer to the structure to fill in with node
                    information. The ID, NetworkId, and NodeId fields of the
                    structure must already be filled in.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD      status;
    HDMKEY     interfaceKey = NULL;
    DWORD      valueLength, valueSize;


    CL_ASSERT(InterfaceId != NULL);

    ZeroMemory(InterfaceInfo, sizeof(NM_INTERFACE_INFO2));

    interfaceKey = DmOpenKey(DmNetInterfacesKey, InterfaceId, KEY_READ);

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open key for interface %1!ws!, status %2!u!\n",
            InterfaceId,
            status
            );
        return(status);
    }

    //
    // Copy the ID string
    //
    InterfaceInfo->Id = MIDL_user_allocate(NM_WCSLEN(InterfaceId));

    if (InterfaceInfo->Id == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory for interface %1!ws!.\n",
            InterfaceId
            );
        goto error_exit;
    }

    wcscpy(InterfaceInfo->Id, InterfaceId);

    //
    // Read the Name for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NAME,
                 REG_SZ,
                 &(InterfaceInfo->Name),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of network interface name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the Description for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_DESC,
                 REG_SZ,
                 &(InterfaceInfo->Description),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of network interface description failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the Network ID for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NETWORK,
                 REG_SZ,
                 &(InterfaceInfo->NetworkId),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of network id for interface %1!ws! failed, status %2!u!.\n",
            InterfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Read the Node ID for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NODE,
                 REG_SZ,
                 &(InterfaceInfo->NodeId),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of node Id for interface %1!ws! failed, status %2!u!.\n",
            InterfaceId,
            status
            );
        goto error_exit;
    }

    //
    // Read the adapter name value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_NAME,
                 REG_SZ,
                 &(InterfaceInfo->AdapterName),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of network interface adapter name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the adapter Id value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_ID,
                 REG_SZ,
                 &(InterfaceInfo->AdapterId),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Query of network interface adapter Id failed, status %1!u!.\n",
            status
            );

        InterfaceInfo->AdapterId = midl_user_allocate(
                                       NM_WCSLEN(NmpUnknownString)
                                       );

        if (InterfaceInfo->AdapterId == NULL) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to allocate memory for adapter Id.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        lstrcpyW(InterfaceInfo->AdapterId, NmpUnknownString);
    }

    //
    // Read the address value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADDRESS,
                 REG_SZ,
                 &(InterfaceInfo->Address),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Query of network interface address failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Read the ClusNet endpoint value for this interface.
    //
    valueLength = 0;

    status = NmpQueryString(
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ENDPOINT,
                 REG_SZ,
                 &(InterfaceInfo->ClusnetEndpoint),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Query of ClusNet endpoint value for network interface failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    InterfaceInfo->State = ClusterNetInterfaceUnavailable;
    InterfaceInfo->NetIndex = NmInvalidInterfaceNetIndex;

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (status != ERROR_SUCCESS) {
        ClNetFreeInterfaceInfo(InterfaceInfo);
    }

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

}  // NmpGetInterfaceDefinition



DWORD
NmpSetInterfaceDefinition(
    IN PNM_INTERFACE_INFO2  InterfaceInfo,
    IN HLOCALXSACTION       Xaction
    )
/*++

Routine Description:

    Updates information for a network interface in the cluster database.

Arguments:

    InterfaceInfo - A pointer to a structure containing the
                    interface's definition.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    interfaceKey = NULL;
    DWORD     valueLength;


    CL_ASSERT(InterfaceInfo->Id != NULL);

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Setting database entry for interface %1!ws!\n",
        InterfaceInfo->Id
        );

    interfaceKey = DmOpenKey(
                       DmNetInterfacesKey,
                       InterfaceInfo->Id,
                       KEY_WRITE
                       );

    if (interfaceKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open key for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
        return(status);
    }

    //
    // Write the name value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->Name) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_NAME,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->Name,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Update of interface name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the description value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->Description) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_DESC,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->Description,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Update of interface description failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the adapter name value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->AdapterName) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_NAME,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->AdapterName,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Update of interface adapter name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the adapter Id value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->AdapterId) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADAPTER_ID,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->AdapterId,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Update of interface adapter Id failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the address value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->Address) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ADDRESS,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->Address,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Update of interface address failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the ClusNet endpoint value for this interface.
    //
    valueLength = (wcslen(InterfaceInfo->ClusnetEndpoint) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 interfaceKey,
                 CLUSREG_NAME_NETIFACE_ENDPOINT,
                 REG_SZ,
                 (CONST BYTE *) InterfaceInfo->ClusnetEndpoint,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Update of interface endpoint name failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (interfaceKey != NULL) {
        DmCloseKey(interfaceKey);
    }

    return(status);

}  // NmpSetInterfaceDefinition



DWORD
NmpEnumInterfaceDefinitions(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    )
/*++

Routine Description:

    Reads interface information from the cluster database and
    fills in an enumeration structure.

Arguments:

    InterfaceEnum -  A pointer to the variable into which to place a
                     pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD                status;
    PNM_INTERFACE_ENUM2  interfaceEnum = NULL;
    PNM_INTERFACE_INFO2  interfaceInfo;
    WCHAR                interfaceId[CS_NETINTERFACE_ID_LENGTH + 1];
    DWORD                i;
    DWORD                valueLength;
    DWORD                numInterfaces;
    DWORD                ignored;
    FILETIME             fileTime;


    *InterfaceEnum = NULL;

    //
    // First count the number of interfaces.
    //
    status = DmQueryInfoKey(
                 DmNetInterfacesKey,
                 &numInterfaces,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to query NetworkInterfaces key information, status %1!u!\n",
            status
            );
        return(status);
    }

    if (numInterfaces == 0) {
        valueLength = sizeof(NM_INTERFACE_ENUM2);

    }
    else {
        valueLength = sizeof(NM_INTERFACE_ENUM2) +
                      (sizeof(NM_INTERFACE_INFO2) * (numInterfaces-1));
    }

    valueLength = sizeof(NM_INTERFACE_ENUM2) +
                  (sizeof(NM_INTERFACE_INFO2) * (numInterfaces-1));

    interfaceEnum = MIDL_user_allocate(valueLength);

    if (interfaceEnum == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceEnum, valueLength);

    for (i=0; i < numInterfaces; i++) {
        interfaceInfo = &(interfaceEnum->InterfaceList[i]);

        valueLength = sizeof(interfaceId);

        status = DmEnumKey(
                     DmNetInterfacesKey,
                     i,
                     &(interfaceId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to enumerate interface key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetInterfaceDefinition(interfaceId, interfaceInfo);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        interfaceEnum->InterfaceCount++;
    }

    *InterfaceEnum = interfaceEnum;

    return(ERROR_SUCCESS);


error_exit:

    if (interfaceEnum != NULL) {
        ClNetFreeInterfaceEnum(interfaceEnum);
    }

    return(status);

}  // NmpEnumInterfaceDefinitions


/////////////////////////////////////////////////////////////////////////////
//
// Object management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateInterfaceObjects(
    IN PNM_INTERFACE_ENUM2    InterfaceEnum
    )
/*++

Routine Description:

    Processes an interface enumeration and creates interface objects.

Arguments:

    InterfaceEnum - A pointer to an interface enumeration structure.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD                status = ERROR_SUCCESS;
    PNM_INTERFACE_INFO2  interfaceInfo;
    PNM_INTERFACE        netInterface;
    DWORD                i;


    for (i=0; i < InterfaceEnum->InterfaceCount; i++) {
        interfaceInfo = &(InterfaceEnum->InterfaceList[i]);

        netInterface = NmpCreateInterfaceObject(
                           interfaceInfo,
                           FALSE    // Don't retry on failure
                           );

        if (netInterface == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to create interface %1!ws!, status %2!u!.\n",
                interfaceInfo->Id,
                status
                );
            break;
        }
        else {
            OmDereferenceObject(netInterface);
        }
    }

    return(status);

}  // NmpCreateInterfaceObjects


PNM_INTERFACE
NmpCreateInterfaceObject(
    IN PNM_INTERFACE_INFO2   InterfaceInfo,
    IN BOOLEAN               RetryOnFailure
    )
/*++

Routine Description:

    Creates an interface object.

Arguments:

    InterfacInfo - A pointer to a structure containing the definition for
                   the interface to create.

    RegisterWithClusterTransport - TRUE if this interface should be registered
                                   with the cluster transport.
                                   FALSE otherwise.

    IssueEvent - TRUE if an INTERFACE_ADDED event should be issued when this
                 object is created. FALSE otherwise.

Return Value:

    A pointer to the new interface object on success.
    NULL on failure.

--*/
{
    DWORD                        status;
    PNM_NETWORK                  network = NULL;
    PNM_NODE                     node = NULL;
    PNM_INTERFACE                netInterface = NULL;
    BOOL                         created = FALSE;
    PNM_CONNECTIVITY_MATRIX      matrixEntry;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating object for interface %1!ws! (%2!ws!).\n",
        InterfaceInfo->Id,
        InterfaceInfo->Name
        );

    status = NmpPrepareToCreateInterface(
                 InterfaceInfo,
                 &network,
                 &node
                 );

    if (status != ERROR_SUCCESS) {
        SetLastError(status);
        return(NULL);
    }

    //
    // Create the interface object.
    //
    netInterface = OmCreateObject(
                       ObjectTypeNetInterface,
                       InterfaceInfo->Id,
                       InterfaceInfo->Name,
                       &created
                       );

    if (netInterface == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for interface %1!ws!, status %2!u!\n",
            InterfaceInfo->Id,
            status
            );
        goto error_exit;
    }

    CL_ASSERT(created == TRUE);

    //
    // Initialize the interface object.
    //
    ZeroMemory(netInterface, sizeof(NM_INTERFACE));

    netInterface->Network = network;
    netInterface->Node = node;
    netInterface->State = ClusterNetInterfaceUnavailable;

    netInterface->Description = MIDL_user_allocate(
                                    NM_WCSLEN(InterfaceInfo->Description)
                                    );

    if (netInterface->Description == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->Description, InterfaceInfo->Description);

    netInterface->AdapterName = MIDL_user_allocate(
                                 (wcslen(InterfaceInfo->AdapterName) + 1) *
                                     sizeof(WCHAR)
                                 );

    if (netInterface->AdapterName == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->AdapterName, InterfaceInfo->AdapterName);

    netInterface->AdapterId = MIDL_user_allocate(
                               (wcslen(InterfaceInfo->AdapterId) + 1) *
                                   sizeof(WCHAR)
                               );

    if (netInterface->AdapterId == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->AdapterId, InterfaceInfo->AdapterId);

    netInterface->Address = MIDL_user_allocate(
                             (wcslen(InterfaceInfo->Address) + 1) *
                                 sizeof(WCHAR)
                             );

    if (netInterface->Address == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->Address, InterfaceInfo->Address);

    status = ClRtlTcpipStringToAddress(
                 InterfaceInfo->Address,
                 &(netInterface->BinaryAddress)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert interface address string %1!ws! to binary, status %2!u!.\n",
            InterfaceInfo->Address,
            status
            );
        goto error_exit;
    }

    netInterface->ClusnetEndpoint =
        MIDL_user_allocate(
            (wcslen(InterfaceInfo->ClusnetEndpoint) + 1) * sizeof(WCHAR)
            );

    if (netInterface->ClusnetEndpoint == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory.\n"
            );
        goto error_exit;
    }

    wcscpy(netInterface->ClusnetEndpoint, InterfaceInfo->ClusnetEndpoint);

    NmpAcquireLock();

    //
    // Assign an index into the network's connectivity vector.
    //
    if (InterfaceInfo->NetIndex == NmInvalidInterfaceNetIndex) {
        //
        // Need to pick an index for this interface. Search for a free
        // entry in the network's connectivity vector.
        //
        DWORD  i;
        PNM_CONNECTIVITY_VECTOR vector = network->ConnectivityVector;


        for ( i=0; i<vector->EntryCount; i++) {
            if ( vector->Data[i] ==
                 (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
               )
            {
                break;
            }
        }

        netInterface->NetIndex = i;

        ClRtlLogPrint(LOG_NOISE,
        "[NM] Assigned index %1!u! to interface %2!ws!.\n",
        netInterface->NetIndex,
        InterfaceInfo->Id
        );

    }
    else {
        //
        // Use the index that was already assigned by our peers.
        //
        netInterface->NetIndex = InterfaceInfo->NetIndex;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Using preassigned index %1!u! for interface %2!ws!.\n",
            netInterface->NetIndex,
            InterfaceInfo->Id
            );
    }

    if (netInterface->NetIndex >= network->ConnectivityVector->EntryCount) {
        //
        // Grow the connectivity vector by the required number of entries.
        //
        PNM_STATE_ENTRY              oldMatrixEntry, newMatrixEntry;
        DWORD                        i;
        PNM_CONNECTIVITY_VECTOR      oldConnectivityVector =
                                         network->ConnectivityVector;
        PNM_CONNECTIVITY_VECTOR      newConnectivityVector;
        PNM_STATE_WORK_VECTOR        oldStateVector = network->StateWorkVector;
        PNM_STATE_WORK_VECTOR        newStateVector;
        PNM_CONNECTIVITY_MATRIX      newMatrix;
        DWORD                        oldVectorSize =
                                         oldConnectivityVector->EntryCount;
        DWORD                        newVectorSize = netInterface->NetIndex + 1;


        //
        // Note that one vector entry is included
        // in sizeof(NM_CONNECTIVITY_VECTOR).
        //
        newConnectivityVector = LocalAlloc(
                                    LMEM_FIXED,
                                    ( sizeof(NM_CONNECTIVITY_VECTOR) +
                                      ( (newVectorSize - 1) *
                                        sizeof(NM_STATE_ENTRY)
                                      )
                                    ));

        if (newConnectivityVector == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            NmpReleaseLock();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to allocate memory for connectivity vector\n"
                );
            goto error_exit;
        }

        //
        // Initialize the new vector
        //
        newConnectivityVector->EntryCount = newVectorSize;

        CopyMemory(
            &(newConnectivityVector->Data[0]),
            &(oldConnectivityVector->Data[0]),
            oldVectorSize * sizeof(NM_STATE_ENTRY)
            );

        FillMemory(
            &(newConnectivityVector->Data[oldVectorSize]),
            (newVectorSize - oldVectorSize) * sizeof(NM_STATE_ENTRY),
            (UCHAR) ClusterNetInterfaceStateUnknown
            );

        //
        // Grow the state work vector
        //
        newStateVector = LocalAlloc(
                             LMEM_FIXED,
                             newVectorSize * sizeof(NM_STATE_WORK_ENTRY)
                             );

        if (newStateVector == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            NmpReleaseLock();
            LocalFree(newConnectivityVector);
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to allocate memory for state work vector\n"
                );
            goto error_exit;
        }

        CopyMemory(
            &(newStateVector[0]),
            &(oldStateVector[0]),
            oldVectorSize * sizeof(NM_STATE_WORK_ENTRY)
            );

        for (i=oldVectorSize; i<newVectorSize; i++) {
            newStateVector[i].State =
                (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown;
        }

        //
        // Grow the network connecivitity matrix
        //
        newMatrix = LocalAlloc(
                        LMEM_FIXED,
                        NM_SIZEOF_CONNECTIVITY_MATRIX(newVectorSize)
                        );

        if (newMatrix == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            NmpReleaseLock();
            LocalFree(newConnectivityVector);
            LocalFree(newStateVector);
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to allocate memory for connectivity matrix\n"
                );
            goto error_exit;
        }

        //
        // Initialize the new matrix
        //
        FillMemory(
            newMatrix,
            NM_SIZEOF_CONNECTIVITY_MATRIX(newVectorSize),
            (UCHAR) ClusterNetInterfaceStateUnknown
            );

        oldMatrixEntry = network->ConnectivityMatrix;
        newMatrixEntry = newMatrix;

        for (i=0; i<oldVectorSize; i++) {
            CopyMemory(
                newMatrixEntry,
                oldMatrixEntry,
                oldVectorSize * sizeof(NM_STATE_ENTRY)
                );

            //
            // Move the pointers to the next vector
            //
            oldMatrixEntry = NM_NEXT_CONNECTIVITY_MATRIX_ROW(
                                 oldMatrixEntry,
                                 oldVectorSize
                                 );

            newMatrixEntry = NM_NEXT_CONNECTIVITY_MATRIX_ROW(
                                 newMatrixEntry,
                                 newVectorSize
                                 );
        }

        //
        // Swap the pointers
        //
        LocalFree(network->ConnectivityVector);
        network->ConnectivityVector = newConnectivityVector;

        LocalFree(network->StateWorkVector);
        network->StateWorkVector = newStateVector;

        LocalFree(network->ConnectivityMatrix);
        network->ConnectivityMatrix = newMatrix;
    }

    //
    // Initialize the connectivity data for this interface
    //
    NmpSetInterfaceConnectivityData(
        network,
        netInterface->NetIndex,
        ClusterNetInterfaceUnavailable
        );

    //
    // Link the interface object onto the various object lists
    //
    InsertTailList(&(node->InterfaceList), &(netInterface->NodeLinkage));
    node->InterfaceCount++;

    InsertTailList(&(network->InterfaceList), &(netInterface->NetworkLinkage));
    network->InterfaceCount++;

    InsertTailList(&NmpInterfaceList, &(netInterface->Linkage));
    NmpInterfaceCount++;

    OmInsertObject(netInterface);
    netInterface->Flags |= NM_FLAG_OM_INSERTED;

    //
    // Remember the interface for the local node.
    //
    if (node == NmLocalNode) {
        network->LocalInterface = netInterface;
    }

    //
    // Register with the cluster transport if needed.
    //
    if (NmpIsNetworkEnabledForUse(network)) {
        if (node == NmLocalNode) {
            //
            // This is the local node. Register the network and all
            // its interfaces with the cluster transport.
            //
            status = NmpRegisterNetwork(network, RetryOnFailure);

            if (status != ERROR_SUCCESS) {
                NmpReleaseLock();
                goto error_exit;
            }
        }
        else if (NmpIsNetworkRegistered(network)) {
            //
            // Just register this interface.
            //
            status = NmpRegisterInterface(netInterface, RetryOnFailure);

            if (status != ERROR_SUCCESS) {
                NmpReleaseLock();
                goto error_exit;
            }
        }
    }

    //
    // Put an additional reference on the object for the caller.
    //
    OmReferenceObject(netInterface);

    NmpReleaseLock();

    return(netInterface);

error_exit:

    if (netInterface != NULL) {
        NmpAcquireLock();
        NmpDeleteInterfaceObject(netInterface, FALSE);
        NmpReleaseLock();
    }

    SetLastError(status);

    return(NULL);

}  // NmpCreateInterfaceObject



DWORD
NmpGetInterfaceObjectInfo1(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO   InterfaceInfo1
    )
/*++

Routine Description:

    Reads information about a defined cluster network interface from the
    interface object and fills in a structure describing it.

Arguments:

    Interface     - A pointer to the interface object to query.

    InterfaceInfo - A pointer to the structure to fill in with node
                    information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with NmpLock held.

--*/

{
    DWORD               status;
    NM_INTERFACE_INFO2  interfaceInfo2;


    //
    // Call the V2.0 routine and translate.
    //
    ZeroMemory(&interfaceInfo2, sizeof(interfaceInfo2));
    status = NmpGetInterfaceObjectInfo(Interface, &interfaceInfo2);

    if (status == ERROR_SUCCESS) {
        CopyMemory(InterfaceInfo1, &interfaceInfo2, sizeof(NM_INTERFACE_INFO));
    }

    //
    // Free the unused V2 fields
    //
    midl_user_free(interfaceInfo2.AdapterId);

    return(status);

}  // NmpGetInterfaceObjectInfo1



DWORD
NmpGetInterfaceObjectInfo(
    IN     PNM_INTERFACE        Interface,
    IN OUT PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network interface from the
    interface object and fills in a structure describing it.

Arguments:

    Interface     - A pointer to the interface object to query.

    InterfaceInfo - A pointer to the structure to fill in with node
                    information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with NmpLock held.

--*/

{
    LPWSTR     tmpString = NULL;
    LPWSTR     interfaceId = (LPWSTR) OmObjectId(Interface);
    LPWSTR     interfaceName = (LPWSTR) OmObjectName(Interface);
    LPWSTR     nodeId = (LPWSTR) OmObjectId(Interface->Node);
    LPWSTR     networkId = (LPWSTR) OmObjectId(Interface->Network);


    tmpString = MIDL_user_allocate(NM_WCSLEN(interfaceId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, interfaceId);
    InterfaceInfo->Id = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(interfaceName));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, interfaceName);
    InterfaceInfo->Name = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->Description));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->Description);
    InterfaceInfo->Description = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(nodeId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, nodeId);
    InterfaceInfo->NodeId = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(networkId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, networkId);
    InterfaceInfo->NetworkId = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->AdapterName));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->AdapterName);
    InterfaceInfo->AdapterName = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->AdapterId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->AdapterId);
    InterfaceInfo->AdapterId = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->Address));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->Address);
    InterfaceInfo->Address = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Interface->ClusnetEndpoint));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Interface->ClusnetEndpoint);
    InterfaceInfo->ClusnetEndpoint = tmpString;

    InterfaceInfo->State = Interface->State;
    InterfaceInfo->NetIndex = Interface->NetIndex;

    return(ERROR_SUCCESS);


error_exit:

    ClNetFreeInterfaceInfo(InterfaceInfo);

    return(ERROR_NOT_ENOUGH_MEMORY);

}  // NmpGetInterfaceObjectInfo2


VOID
NmpDeleteInterfaceObject(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        IssueEvent
    )
/*++

Notes:

    Called with NM global lock held.

--*/
{
    LPWSTR       interfaceId = (LPWSTR) OmObjectId(Interface);
    PNM_NETWORK  network = Interface->Network;


    if (NM_DELETE_PENDING(Interface)) {
        CL_ASSERT(!NM_OM_INSERTED(Interface));
        return;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] deleting object for interface %1!ws!\n",
        interfaceId
        );

    Interface->Flags |= NM_FLAG_DELETE_PENDING;

    if (NM_OM_INSERTED(Interface)) {
        //
        // Remove the interface from the various object lists.
        //
        DWORD   status = OmRemoveObject(Interface);
        CL_ASSERT(status == ERROR_SUCCESS);

        RemoveEntryList(&(Interface->Linkage));
        CL_ASSERT(NmpInterfaceCount > 0);
        NmpInterfaceCount--;

        RemoveEntryList(&(Interface->NetworkLinkage));
        CL_ASSERT(network->InterfaceCount > 0);
        network->InterfaceCount--;

        RemoveEntryList(&(Interface->NodeLinkage));
        CL_ASSERT(Interface->Node->InterfaceCount > 0);
        Interface->Node->InterfaceCount--;

        Interface->Flags &= ~NM_FLAG_OM_INSERTED;
    }

    //
    // Place the object on the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedInterfaceList.Flink;
              entry != &NmpDeletedInterfaceList;
              entry = entry->Flink
            )
        {
            if (entry == &(Interface->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry != &(Interface->Linkage));
    }
#endif DBG

    InsertTailList(&NmpDeletedInterfaceList, &(Interface->Linkage));

    if (network != NULL) {
        if ( (Interface->Node != NULL) &&
             NmpIsNetworkEnabledForUse(network)
           )
        {
            DWORD status;

            //
            // Deregister the interface from the cluster transport
            //
            if ( (network->LocalInterface == Interface) &&
                 NmpIsNetworkRegistered(network)
               )
            {
                //
                // Deregister the network and all of its interfaces
                //
                NmpDeregisterNetwork(network);
            }
            else if (NmpIsInterfaceRegistered(Interface)) {
                //
                // Just deregister this interface
                //
                NmpDeregisterInterface(Interface);
            }
        }

        //
        // Invalidate the connectivity data for the interface.
        //
        NmpSetInterfaceConnectivityData(
            network,
            Interface->NetIndex,
            ClusterNetInterfaceStateUnknown
            );

        if (network->LocalInterface == Interface) {
            network->LocalInterface = NULL;
            network->Flags &= ~NM_NET_IF_WORK_FLAGS;
        }

        //
        // If this is not the last interface on the network,
        // then update the network state.
        //
        if ((network->InterfaceCount != 0) &&
            (NmpLeaderNodeId == NmLocalNodeId)) {
                NmpScheduleNetworkStateRecalc(network);
        }
    }

    if (IssueEvent) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Issuing interface deleted event for interface %1!ws!.\n",
            interfaceId
            );

        ClusterEvent(CLUSTER_EVENT_NETINTERFACE_DELETED, Interface);
    }

    //
    // Remove the initial reference so the object can be destroyed.
    //
    OmDereferenceObject(Interface);

    return;

}  // NmpDeleteInterfaceObject


BOOL
NmpDestroyInterfaceObject(
    PNM_INTERFACE  Interface
    )
{
    DWORD  status;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] destroying object for interface %1!ws!\n",
        (LPWSTR) OmObjectId(Interface)
        );

    CL_ASSERT(NM_DELETE_PENDING(Interface));
    CL_ASSERT(!NM_OM_INSERTED(Interface));

    //
    // Remove the interface from the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedInterfaceList.Flink;
              entry != &NmpDeletedInterfaceList;
              entry = entry->Flink
            )
        {
            if (entry == &(Interface->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry == &(Interface->Linkage));
    }
#endif DBG

    RemoveEntryList(&(Interface->Linkage));

    //
    // Dereference the node and network objects
    //
    if (Interface->Node != NULL) {
        OmDereferenceObject(Interface->Node);
    }

    if (Interface->Network != NULL) {
        OmDereferenceObject(Interface->Network);
    }

    //
    // Free storage used by the object fields.
    //
    NM_FREE_OBJECT_FIELD(Interface, Description);
    NM_FREE_OBJECT_FIELD(Interface, AdapterName);
    NM_FREE_OBJECT_FIELD(Interface, AdapterId);
    NM_FREE_OBJECT_FIELD(Interface, Address);
    NM_FREE_OBJECT_FIELD(Interface, ClusnetEndpoint);

    return(TRUE);

}  // NmpDestroyInterfaceObject



DWORD
NmpEnumInterfaceObjects1(
    OUT PNM_INTERFACE_ENUM *  InterfaceEnum1
    )
/*++

Routine Description:

    Reads interface information for all defined cluster networks
    and fills in an enumeration structure.

Arguments:

    InterfaceEnum1 -  A pointer to the variable into which to place a
                      pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                status = ERROR_SUCCESS;
    PNM_INTERFACE_ENUM   interfaceEnum1 = NULL;
    DWORD                i;
    DWORD                valueLength;
    PLIST_ENTRY          entry;
    PNM_INTERFACE        netInterface;


    *InterfaceEnum1 = NULL;

    if (NmpInterfaceCount == 0) {
        valueLength = sizeof(NM_INTERFACE_ENUM);
    }
    else {
        valueLength =
            sizeof(NM_INTERFACE_ENUM) +
            (sizeof(NM_INTERFACE_INFO) * (NmpInterfaceCount - 1));
    }

    interfaceEnum1 = MIDL_user_allocate(valueLength);

    if (interfaceEnum1 == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceEnum1, valueLength);

    for (entry = NmpInterfaceList.Flink, i=0;
         entry != &NmpInterfaceList;
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);

        status = NmpGetInterfaceObjectInfo1(
                     netInterface,
                     &(interfaceEnum1->InterfaceList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeInterfaceEnum1(interfaceEnum1);
            return(status);
        }
    }

    interfaceEnum1->InterfaceCount = NmpInterfaceCount;
    *InterfaceEnum1 = interfaceEnum1;

    return(ERROR_SUCCESS);

}  // NmpEnumInterfaceObjects1



DWORD
NmpEnumInterfaceObjects(
    OUT PNM_INTERFACE_ENUM2 *  InterfaceEnum
    )
/*++

Routine Description:

    Reads interface information for all defined cluster networks
    and fills in an enumeration structure.

Arguments:

    InterfaceEnum -  A pointer to the variable into which to place a
                     pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                 status = ERROR_SUCCESS;
    PNM_INTERFACE_ENUM2   interfaceEnum = NULL;
    DWORD                 i;
    DWORD                 valueLength;
    PLIST_ENTRY           entry;
    PNM_INTERFACE         netInterface;


    *InterfaceEnum = NULL;

    if (NmpInterfaceCount == 0) {
        valueLength = sizeof(NM_INTERFACE_ENUM2);
    }
    else {
        valueLength =
            sizeof(NM_INTERFACE_ENUM2) +
            (sizeof(NM_INTERFACE_INFO2) * (NmpInterfaceCount - 1));
    }

    interfaceEnum = MIDL_user_allocate(valueLength);

    if (interfaceEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceEnum, valueLength);

    for (entry = NmpInterfaceList.Flink, i=0;
         entry != &NmpInterfaceList;
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);

        status = NmpGetInterfaceObjectInfo(
                     netInterface,
                     &(interfaceEnum->InterfaceList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeInterfaceEnum((PNM_INTERFACE_ENUM2) interfaceEnum);
            return(status);
        }
    }

    interfaceEnum->InterfaceCount = NmpInterfaceCount;
    *InterfaceEnum = interfaceEnum;

    return(ERROR_SUCCESS);

}  // NmpEnumInterfaceObjects


DWORD
NmpEnumInterfaceObjectStates(
    OUT PNM_INTERFACE_STATE_ENUM *  InterfaceStateEnum
    )
/*++

Routine Description:

    Reads state information for all defined cluster network interfaces
    and fills in an enumeration structure.

Arguments:

    InterfaceStateEnum -  A pointer to the variable into which to place a
                          pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                      status = ERROR_SUCCESS;
    PNM_INTERFACE_STATE_ENUM   interfaceStateEnum = NULL;
    PNM_INTERFACE_STATE_INFO   interfaceStateInfo;
    DWORD                      i;
    DWORD                      valueLength;
    PLIST_ENTRY                entry;
    PNM_INTERFACE              netInterface;
    LPWSTR                     interfaceId;


    *InterfaceStateEnum = NULL;

    if (NmpInterfaceCount == 0) {
        valueLength = sizeof(NM_INTERFACE_STATE_ENUM);
    }
    else {
        valueLength =
            sizeof(NM_INTERFACE_STATE_ENUM) +
            (sizeof(NM_INTERFACE_STATE_INFO) * (NmpInterfaceCount - 1));
    }

    interfaceStateEnum = MIDL_user_allocate(valueLength);

    if (interfaceStateEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(interfaceStateEnum, valueLength);

    for (entry = NmpInterfaceList.Flink, i=0;
         entry != &NmpInterfaceList;
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, Linkage);
        interfaceId = (LPWSTR) OmObjectId(netInterface);
        interfaceStateInfo = &(interfaceStateEnum->InterfaceList[i]);

        interfaceStateInfo->State = netInterface->State;

        interfaceStateInfo->Id = MIDL_user_allocate(NM_WCSLEN(interfaceId));

        if (interfaceStateInfo->Id == NULL) {
            NmpFreeInterfaceStateEnum(interfaceStateEnum);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyW(interfaceStateInfo->Id, interfaceId);
    }

    interfaceStateEnum->InterfaceCount = NmpInterfaceCount;
    *InterfaceStateEnum = interfaceStateEnum;

    return(ERROR_SUCCESS);

}  // NmpEnumInterfaceObjectStates


/////////////////////////////////////////////////////////////////////////////
//
// State Management routines
//
/////////////////////////////////////////////////////////////////////////////
VOID
NmpSetInterfaceConnectivityData(
    PNM_NETWORK                  Network,
    DWORD                        InterfaceNetIndex,
    CLUSTER_NETINTERFACE_STATE   State
    )
{
    PNM_CONNECTIVITY_MATRIX   matrixEntry;


    Network->ConnectivityVector->Data[InterfaceNetIndex] =
        (NM_STATE_ENTRY) State;

    Network->StateWorkVector[InterfaceNetIndex].State =
        (NM_STATE_ENTRY) State;

    matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                      Network->ConnectivityMatrix,
                      InterfaceNetIndex,
                      InterfaceNetIndex,
                      Network->ConnectivityVector->EntryCount
                      );

    *matrixEntry = (NM_STATE_ENTRY)State;

    return;

}  // NmpSetInterfaceConnectivityData


VOID
NmpReportLocalInterfaceStateEvent(
    IN CL_NODE_ID     NodeId,
    IN CL_NETWORK_ID  NetworkId,
    IN DWORD          NewState
    )
{
    PNM_INTERFACE  netInterface;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnlinePending)){
        netInterface = NmpGetInterfaceForNodeAndNetworkById(
                           NodeId,
                           NetworkId
                           );

        if (netInterface != NULL) {
            NmpProcessLocalInterfaceStateEvent(netInterface, NewState);
        }

        NmpLockedLeaveApi();
    }

    NmpReleaseLock();

    return;

} // NmReportLocalInterfaceStateEvent


VOID
NmpProcessLocalInterfaceStateEvent(
    IN PNM_INTERFACE                Interface,
    IN CLUSTER_NETINTERFACE_STATE   NewState
    )
/*+

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD                     status;
    PNM_NETWORK               network = Interface->Network;
    LPCWSTR                   interfaceId = OmObjectId(Interface);
    LPCWSTR                   networkId = OmObjectId(network);
    LPCWSTR                   networkName = OmObjectName(network);
    PNM_NODE                  node = Interface->Node;
    LPCWSTR                   nodeName = OmObjectName(node);
    PNM_CONNECTIVITY_VECTOR   vector = network->ConnectivityVector;
    DWORD                     ifNetIndex = Interface->NetIndex;


    //
    // Filter out stale reports for dead nodes.
    //
    if ((node == NmLocalNode) || (node->State != ClusterNodeDown)) {
        CL_ASSERT(
            vector->Data[ifNetIndex] !=
            (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
            );

        //
        // Apply the change to the local connectivity vector.
        //
        vector->Data[ifNetIndex] = (NM_STATE_ENTRY) NewState;

        //
        // Log an event
        //
        switch (NewState) {

        case ClusterNetInterfaceUp:
            //
            // A local interface is now operational, or a remote interface
            // is now reachable. Schedule an immediate connectivity report,
            // since this event may avert failure of resources that depend
            // on the interface.
            //
            if (node != NmLocalNode) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Communication was (re)established with "
                    "interface %1!ws! (node: %2!ws!, network: %3!ws!)\n",
                    interfaceId,
                    nodeName,
                    networkName
                    );

                CsLogEvent2(
                    LOG_NOISE,
                    NM_EVENT_NETINTERFACE_UP,
                    nodeName,
                    networkName
                    );
            }

            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader. Call the handler routine
                // directly.
                //
                NmpReportNetworkConnectivity(network);
            }
            else {
                //
                // We need to report to the leader.
                // Defer to a worker thread.
                //
                NmpScheduleNetworkConnectivityReport(network);
            }

            break;

        case ClusterNetInterfaceUnreachable:
            //
            // A remote interface is unreachable.
            //
            if (node != NmLocalNode) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Communication was lost with interface "
                    "%1!ws! (node: %2!ws!, network: %3!ws!)\n",
                    interfaceId,
                    nodeName,
                    networkName
                    );

                CsLogEvent2(
                    LOG_UNUSUAL,
                    NM_EVENT_NETINTERFACE_UNREACHABLE,
                    nodeName,
                    networkName
                    );
            }

            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader. Call the handler routine
                // directly.
                //
                NmpReportNetworkConnectivity(network);
            }
            else {
                //
                // Schedule a delayed connectivity report in order to
                // aggregate multiple failures.
                //
                NmpStartNetworkConnectivityReportTimer(network);
            }

            break;

        case ClusterNetInterfaceFailed:
            //
            // A local interface has failed. Schedule an immediate
            // connectivity report.
            //
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Local interface %1!ws! on network %2!ws! "
                "has failed\n",
                interfaceId,
                networkName
                );
            CsLogEvent1(
                LOG_UNUSUAL,
                NM_EVENT_NETINTERFACE_FAILED,
                networkName
                );

            if (NmpLeaderNodeId == NmLocalNodeId) {
                //
                // This node is the leader. Call the handler routine
                // directly.
                //
                NmpReportNetworkConnectivity(network);
            }
            else {
                //
                // We need to report to the leader. Defer to a worker thread.
                //
                NmpScheduleNetworkConnectivityReport(network);
            }

            break;

        default:
            break;
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Ignoring stale report from clusnet for interface %1!ws! (node: %2!ws!, network: %3!ws!).\n",
            interfaceId,
            nodeName,
            networkName
            );
    }

    return;

} // NmpProcessLocalInterfaceStateEvent


DWORD
NmpReportInterfaceConnectivity(
    IN RPC_BINDING_HANDLE       RpcBinding,
    IN LPWSTR                   InterfaceId,
    IN PNM_CONNECTIVITY_VECTOR  ConnectivityVector,
    IN LPWSTR                   NetworkId
    )
/*++

Routine Description:

    Sends a network connectivity report to the leader node via RPC.

Arguments:

    RpcBinding - The RPC binding handle to use in the call to the leader.

    InterfaceId - A pointer to a string that identifies the interface
                  to which the report applies.

    ConnectivityVector - A pointer to the connectivity vector to be included
                         in the report.

    NetworkId - A pointer to a string that identifies the network with
                which the interface is associated.

Return Value:

    A Win32 status code.

Notes:

   Called with NM lock held.
   Releases & reacquires NM lock during processing.

--*/
{
    RPC_ASYNC_STATE                  rpcAsyncState;
    DWORD                            status;
    PNM_CONNECTIVITY_REPORT_CONTEXT  context;
    PNM_LEADER_CHANGE_WAIT_ENTRY     waitEntry = NULL;
    BOOL                             result;



    ClRtlLogPrint(LOG_NOISE,
        "[NM] Reporting connectivity to leader for network %1!ws!.\n",
        NetworkId
        );

    //
    // Allocate a context block for this report
    //
    context = LocalAlloc(
                  (LMEM_FIXED | LMEM_ZEROINIT),
                  sizeof(NM_CONNECTIVITY_REPORT_CONTEXT)
                  );

    if (context == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate connectivity report context, "
            "status %1!u!.\n",
            status
            );
        return(status);
    }

    context->ConnectivityReportEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (context->ConnectivityReportEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create event for connectivity report, "
            "status %1!u!\n",
            status
            );
        goto error_exit;
    }

    waitEntry = &(context->LeaderChangeWaitEntry);

    waitEntry->LeaderChangeEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (waitEntry->LeaderChangeEvent == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create event for connectivity report, "
            "status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Initialize the status block for the async RPC call
    //
    status = RpcAsyncInitializeHandle(
                 &rpcAsyncState,
                 sizeof(rpcAsyncState)
                 );

    if (status != RPC_S_OK) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to initialize RPC status block for connectivity "
            "report, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    rpcAsyncState.NotificationType = RpcNotificationTypeEvent;
    rpcAsyncState.u.hEvent = context->ConnectivityReportEvent;
    result = ResetEvent(context->ConnectivityReportEvent);
    CL_ASSERT(result != 0);

    //
    // Hook changes in the node leadership.
    //
    result = ResetEvent(waitEntry->LeaderChangeEvent);
    CL_ASSERT(result != 0);
    InsertTailList(&NmpLeaderChangeWaitList, &(waitEntry->Linkage));

    NmpReleaseLock();

    //
    // Send the report to the leader
    //
    status = NmRpcReportInterfaceConnectivity(
                 &rpcAsyncState,
                 RpcBinding,
                 InterfaceId,
                 ConnectivityVector
                 );

    if (status == RPC_S_OK) {
        //
        // The call is pending.
        //
        HANDLE  waitHandles[2];
        DWORD   rpcStatus;


        //
        // Wait for the call to complete or a leadership change.
        //
        waitHandles[0] = context->ConnectivityReportEvent;
        waitHandles[1] = waitEntry->LeaderChangeEvent;

        status = WaitForMultipleObjects(
                     2,
                     waitHandles,
                     FALSE,
                     INFINITE
                     );

        if (status != WAIT_OBJECT_0) {
            //
            // The leadership changed. Cancel the RPC call.
            //
            // We would also go through this path if the wait failed for
            // some reason, but that really should not happen. Either way,
            // we should cancel the call.
            //
            CL_ASSERT(status == (WAIT_OBJECT_0 + 1));

            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Leadership changed. Cancelling connectivity report for "
                "network %1!ws!.\n",
                NetworkId
                );

            rpcStatus = RpcAsyncCancelCall(&rpcAsyncState, TRUE);
            CL_ASSERT(rpcStatus == RPC_S_OK);

            //
            // Wait for the call to complete.
            //
            status = WaitForSingleObject(
                         context->ConnectivityReportEvent,
                         INFINITE
                         );
            CL_ASSERT(status == WAIT_OBJECT_0);
        }

        //
        // At this point, the call should be complete. Get the completion
        // status. Any RPC error will be returned in 'rpcStatus'. If there
        // was no RPC error, then any application error will be returned
        // in 'status'.
        //
        rpcStatus = RpcAsyncCompleteCall(&rpcAsyncState, &status);

        if (rpcStatus != RPC_S_OK) {
            //
            // Either the call was cancelled or an RPC error
            // occurred. The application status is irrelevant.
            //
            status = rpcStatus;
        }

        if (status == RPC_S_OK) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Connectivity report completed successfully "
                "for network %1!ws!.\n",
                NetworkId
                );
        }
        else if (status == RPC_S_CALL_CANCELLED) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Connectivity report was cancelled for "
                "network %1!ws!.\n",
                NetworkId
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Connectivity report failed for network "
                "%1!ws!, status %2!u!.\n",
                NetworkId,
                status
                );

            CL_ASSERT(status != RPC_S_ASYNC_CALL_PENDING);
        }
    }
    else {
        //
        // A synchronous error was returned.
        //
        CL_ASSERT(status != RPC_S_ASYNC_CALL_PENDING);

        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Connectivity report failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
    }

    NmpAcquireLock();

error_exit:

    //
    // Free the context block
    //
    if (context != NULL) {
        if (context->ConnectivityReportEvent != NULL) {
            CloseHandle(context->ConnectivityReportEvent);
        }

        if (waitEntry != NULL && waitEntry->LeaderChangeEvent != NULL) {
            //
            // Remove our leadership change notification hook.
            //
            if (waitEntry->Linkage.Flink != NULL) {
                RemoveEntryList(&(waitEntry->Linkage));
            }

            CloseHandle(waitEntry->LeaderChangeEvent);
        }

        LocalFree(context);
    }

    return(status);

} // NmpReportInterfaceConnectivity


VOID
NmpProcessInterfaceConnectivityReport(
    IN PNM_INTERFACE               SourceInterface,
    IN PNM_CONNECTIVITY_VECTOR     ConnectivityVector
    )
/*+

Notes:

    Called with NmpLock held.

--*/
{
    PNM_NETWORK              network = SourceInterface->Network;
    PNM_CONNECTIVITY_MATRIX  matrix = network->ConnectivityMatrix;
    DWORD                    entryCount;
    PNM_NODE                 node = SourceInterface->Node;
    PNM_CONNECTIVITY_VECTOR  vector = network->ConnectivityVector;
    DWORD                    ifNetIndex = SourceInterface->NetIndex;


    //
    // Filter out stale reports from dead nodes and for
    // disabled/deleted networks.
    //
    if ( ((node == NmLocalNode) || (node->State != ClusterNodeDown)) &&
         NmpIsNetworkEnabledForUse(network) &&
         !NM_DELETE_PENDING(network)
       )
    {
        //
        // Update the network's connectivity matrix
        //
        if (network->ConnectivityVector->EntryCount <= vector->EntryCount) {
            entryCount = network->ConnectivityVector->EntryCount;
        }
        else {
            //
            // An interface must have been added while this
            // call was in flight. Ignore the missing data.
            //
            entryCount = ConnectivityVector->EntryCount;
        }

        CopyMemory(
            NM_GET_CONNECTIVITY_MATRIX_ROW(
                matrix,
                ifNetIndex,
                entryCount
                ),
            &(ConnectivityVector->Data[0]),
            entryCount * sizeof(NM_STATE_ENTRY)
            );

        //
        // If this is the leader node, and no NT4 nodes are in the cluster,
        // schedule a state recalculation.
        //
        if (NmpLeaderNodeId == NmLocalNodeId) {
            NmpStartNetworkStateRecalcTimer(
                network,
                NM_NET_STATE_RECALC_TIMEOUT
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Ignoring stale connectivity report from interface %1!ws!.\n",
            OmObjectId(SourceInterface)
            );
    }

    return;

} // NmpProcessInterfaceConnectivityReport


VOID
NmpFreeInterfaceStateEnum(
    PNM_INTERFACE_STATE_ENUM   InterfaceStateEnum
    )
{
    PNM_INTERFACE_STATE_INFO  interfaceStateInfo;
    DWORD                     i;


    for (i=0; i<InterfaceStateEnum->InterfaceCount; i++) {
        interfaceStateInfo = &(InterfaceStateEnum->InterfaceList[i]);

        if (interfaceStateInfo->Id != NULL) {
            MIDL_user_free(interfaceStateInfo->Id);
        }
    }

    MIDL_user_free(InterfaceStateEnum);

    return;

} // NmpFreeInterfaceStateEnum


BOOL
NmpIsAddressInAddressEnum(
    ULONGLONG           Address,
    PNM_ADDRESS_ENUM    AddressEnum
    )
{
    DWORD    i;


    for (i=0; i<AddressEnum->AddressCount; i++) {
        if (AddressEnum->AddressList[i] == Address) {
            return(TRUE);
        }
    }

    return(FALSE);

}  // NmpIsAddressInAddressEnum


DWORD
NmpBuildInterfaceOnlineAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM *  OnlineAddressEnum
    )
/*++

    Called with NmpLock held and Interface referenced.

--*/
{
    DWORD                       status = ERROR_SUCCESS;
    PNM_ADDRESS_ENUM            onlineAddressEnum = NULL;
    DWORD                       onlineAddressEnumSize;
    PCLRTL_NET_ADAPTER_ENUM     adapterEnum = NULL;
    PCLRTL_NET_ADAPTER_INFO     adapterInfo = NULL;
    PCLRTL_NET_INTERFACE_INFO   adapterIfInfo = NULL;
    PNM_ADDRESS_ENUM            onlineEnum = NULL;
    DWORD                       onlineEnumSize;


    *OnlineAddressEnum = NULL;

    //
    // Get the local network configuration.
    //
    adapterEnum = ClRtlEnumNetAdapters();

    if (adapterEnum == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to obtain local network configuration, status %1!u!.\n",
            status
            );
        return(status);
    }

    //
    // Find the adapter for this interface
    //
    adapterInfo = ClRtlFindNetAdapterById(
                      adapterEnum,
                      Interface->AdapterId
                      );

    if (adapterInfo == NULL) {
        status = ERROR_NOT_FOUND;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to find adapter for interface %1!ws!, status %2!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Allocate an address enum structure.
    //
    if (adapterInfo->InterfaceCount == 0) {
        onlineEnumSize = sizeof(NM_ADDRESS_ENUM);
    }
    else {
        onlineEnumSize = sizeof(NM_ADDRESS_ENUM) +
                         ( (adapterInfo->InterfaceCount - 1) *
                           sizeof(ULONGLONG)
                         );
    }

    onlineEnum = midl_user_allocate(onlineEnumSize);

    if (onlineEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate memory for ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    onlineEnum->AddressSize = sizeof(ULONG);
    onlineEnum->AddressCount = 0;

    for (adapterIfInfo = adapterInfo->InterfaceList;
         adapterIfInfo != NULL;
         adapterIfInfo = adapterIfInfo->Next
        )
    {
        //
        // Skip invalid addresses (0.0.0.0)
        //
        if (adapterIfInfo->InterfaceAddress != 0) {
            onlineEnum->AddressList[onlineEnum->AddressCount++] =
                (ULONGLONG) adapterIfInfo->InterfaceAddress;

                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Found address %1!ws! for interface %2!ws!.\n",
                    adapterIfInfo->InterfaceAddressString,
                    OmObjectId(Interface)
                    );
        }
    }

    *OnlineAddressEnum = onlineEnum;
    status = ERROR_SUCCESS;

error_exit:

    if (adapterEnum != NULL) {
        ClRtlFreeNetAdapterEnum(adapterEnum);
    }

    return(status);

} // NmpBuildInterfaceOnlineAddressEnum


DWORD
NmpBuildInterfacePingAddressEnum(
    IN  PNM_INTERFACE       Interface,
    IN  PNM_ADDRESS_ENUM    OnlineAddressEnum,
    OUT PNM_ADDRESS_ENUM *  PingAddressEnum
    )
/*++

    Called with NmpLock held and Interface referenced.

--*/
{
    DWORD                       status = ERROR_SUCCESS;
    PNM_NETWORK                 network = Interface->Network;
    PMIB_IPFORWARDTABLE         ipForwardTable = NULL;
    PMIB_IPFORWARDROW           ipRow, ipRowLimit;
    PMIB_TCPTABLE               tcpTable = NULL;
    PMIB_TCPROW                 tcpRow, tcpRowLimit;
    ULONG                       netAddress, netMask;
    DWORD                       allocSize, tableSize;
    BOOL                        duplicate;
    DWORD                       i;
    PNM_ADDRESS_ENUM            pingEnum = NULL;
    DWORD                       pingEnumSize;


    *PingAddressEnum = NULL;

    //
    // Convert the network address & mask strings to binary
    //
    status = ClRtlTcpipStringToAddress(network->Address, &netAddress);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address string %1!ws! to binary, status %2!u!.\n",
            network->Address,
            status
            );
        return(status);
    }

    status = ClRtlTcpipStringToAddress(network->AddressMask, &netMask);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert network address mask string %1!ws! to binary, status %2!u!.\n",
            network->AddressMask,
            status
            );
        return(status);
    }

    //
    // We don't need the lock for the rest of the function.
    //
    NmpReleaseLock();

    //
    // Allocate a ping enum structure
    //
    pingEnumSize = sizeof(NM_ADDRESS_ENUM) +
                   ((NM_MAX_IF_PING_ENUM_SIZE - 1) * sizeof(ULONGLONG));

    pingEnum = midl_user_allocate(pingEnumSize);

    if (pingEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate memory for ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    pingEnum->AddressSize = sizeof(ULONG);
    pingEnum->AddressCount = 0;

    //
    // Fetch the IP Route Table
    //
    allocSize = sizeof(MIB_IPFORWARDTABLE) + (sizeof(MIB_IPFORWARDROW) * 20);

    do {
        if (ipForwardTable != NULL) {
            LocalFree(ipForwardTable);
        }

        ipForwardTable = LocalAlloc(LMEM_FIXED, allocSize);

        if (ipForwardTable == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate memory for IP route table.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        tableSize = allocSize;

        status = GetIpForwardTable(
                     ipForwardTable,
                     &tableSize,
                     FALSE
                     );

        allocSize = tableSize;

    } while (status == ERROR_INSUFFICIENT_BUFFER);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[ClNet] Failed to obtain IP route table, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Add the IP route entries to the ping list.
    //
    for ( ipRow = &(ipForwardTable->table[0]),
            ipRowLimit = ipRow + ipForwardTable->dwNumEntries;
          ipRow < ipRowLimit;
          ipRow++
        )
    {
        if ((ipRow->dwForwardNextHop & netMask) == netAddress) {
            //
            // Make sure this address isn't in the online address enum.
            //
            duplicate = NmpIsAddressInAddressEnum(
                            (ULONGLONG) ipRow->dwForwardNextHop,
                            OnlineAddressEnum
                            );

            if (!duplicate) {
                //
                // Make sure this address isn't already in the ping enum.
                //
                duplicate = NmpIsAddressInAddressEnum(
                                (ULONGLONG) ipRow->dwForwardNextHop,
                                pingEnum
                                );

                if (!duplicate) {
                    pingEnum->AddressList[pingEnum->AddressCount++] =
                        (ULONGLONG) ipRow->dwForwardNextHop;

                    if (pingEnum->AddressCount == NM_MAX_IF_PING_ENUM_SIZE) {
                        LocalFree(ipForwardTable);
                        *PingAddressEnum = pingEnum;
                        NmpAcquireLock();

                        return(ERROR_SUCCESS);
                    }
                }
            }
        }
    }

    LocalFree(ipForwardTable); ipForwardTable = NULL;

    //
    // Fetch the TCP Connection Table
    //
    allocSize = sizeof(MIB_TCPTABLE) + (sizeof(MIB_TCPROW) * 20);

    do {
        if (tcpTable != NULL) {
            LocalFree(tcpTable);
        }

        tcpTable = LocalAlloc(LMEM_FIXED, allocSize);

        if (tcpTable == NULL) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate memory for TCP conn table.\n"
                );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        tableSize = allocSize;

        status = GetTcpTable(
                     tcpTable,
                     &tableSize,
                     FALSE
                     );

        allocSize = tableSize;

    } while (status == ERROR_INSUFFICIENT_BUFFER);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[ClNet] Failed to obtain TCP conn table, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Add the TCP remote addresses to the ping list.
    //
    for ( tcpRow = &(tcpTable->table[0]),
            tcpRowLimit = tcpRow + tcpTable->dwNumEntries;
          tcpRow < tcpRowLimit;
          tcpRow++
        )
    {
        if ((tcpRow->dwRemoteAddr & netMask) == netAddress) {
            //
            // Make sure this address isn't in the online address enum.
            //
            duplicate = NmpIsAddressInAddressEnum(
                            (ULONGLONG) tcpRow->dwRemoteAddr,
                            OnlineAddressEnum
                            );

            if (!duplicate) {
                //
                // Make sure this address isn't already in the ping enum.
                //
                duplicate = NmpIsAddressInAddressEnum(
                                (ULONGLONG) tcpRow->dwRemoteAddr,
                                pingEnum
                                );

                if (!duplicate) {
                    pingEnum->AddressList[pingEnum->AddressCount++] =
                        (ULONGLONG) tcpRow->dwRemoteAddr;

                    if (pingEnum->AddressCount == NM_MAX_IF_PING_ENUM_SIZE) {
                        break;
                    }
                }
            }
        }
    }

    *PingAddressEnum = pingEnum; pingEnum = NULL;

error_exit:

    if (pingEnum != NULL) {
        midl_user_free(pingEnum);
    }

    if (ipForwardTable != NULL) {
        LocalFree(ipForwardTable);
    }

    if (tcpTable != NULL) {
        LocalFree(tcpTable);
    }

    NmpAcquireLock();

    return(status);

} // NmpBuildInterfacePingAddressEnum


NmpGetInterfaceOnlineAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM *  OnlineAddressEnum
    )
/*++

Notes:

    Called with NmpLock held and Interface referenced. Releases and
    reacquires NmpLock.

--*/
{
    DWORD               status;
    LPCWSTR             interfaceId = OmObjectId(Interface);
    PNM_NODE            node = Interface->Node;
    RPC_BINDING_HANDLE  rpcBinding = node->IsolateRpcBinding;


    if (node == NmLocalNode) {
        //
        // Call the internal routine directly
        //
        status = NmpBuildInterfaceOnlineAddressEnum(
                     Interface,
                     OnlineAddressEnum
                     );
    }
    else {
        OmReferenceObject(node);

        NmpReleaseLock();

        CL_ASSERT(rpcBinding != NULL);

        NmStartRpc(node->NodeId);
        status = NmRpcGetInterfaceOnlineAddressEnum(
                     rpcBinding,
                     (LPWSTR) interfaceId,
                     OnlineAddressEnum
                     );
        NmEndRpc(node->NodeId);
        if(status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(status);
        }

        NmpAcquireLock();

        OmDereferenceObject(node);
    }

    if (status == ERROR_SUCCESS) {
        if ((*OnlineAddressEnum)->AddressSize != sizeof(ULONG)) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Online enum address size is invalid for interface %1!ws!\n",
                interfaceId
                );
            status = ERROR_INCORRECT_ADDRESS;
            midl_user_free(*OnlineAddressEnum);
            *OnlineAddressEnum = NULL;
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Online enum for interface %1!ws! contains %2!u! addresses\n",
                interfaceId,
                (*OnlineAddressEnum)->AddressCount
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get online address enum for interface %1!ws!, status %2!u!\n",
            interfaceId,
            status
            );
    }

    return(status);

}  // NmpGetInterfaceOnlineAddressEnum


NmpGetInterfacePingAddressEnum(
    PNM_INTERFACE       Interface,
    PNM_ADDRESS_ENUM    OnlineAddressEnum,
    PNM_ADDRESS_ENUM *  PingAddressEnum
    )
/*++

Notes:

    Called with NmpLock held and Interface referenced. Releases and
    reacquires NmpLock.

--*/
{
    DWORD               status;
    LPCWSTR             interfaceId = OmObjectId(Interface);
    PNM_NODE            node = Interface->Node;
    RPC_BINDING_HANDLE  rpcBinding = node->IsolateRpcBinding;


    if (node == NmLocalNode) {
        //
        // Call the internal routine directly
        //
        status = NmpBuildInterfacePingAddressEnum(
                     Interface,
                     OnlineAddressEnum,
                     PingAddressEnum
                     );
    }
    else {
        OmReferenceObject(node);

        NmpReleaseLock();

        CL_ASSERT(rpcBinding != NULL);

        NmStartRpc(node->NodeId);
        status = NmRpcGetInterfacePingAddressEnum(
                     rpcBinding,
                     (LPWSTR) interfaceId,
                     OnlineAddressEnum,
                     PingAddressEnum
                     );
        NmEndRpc(node->NodeId);
        if(status != RPC_S_OK) {
            NmDumpRpcExtErrorInfo(status);
        }

        NmpAcquireLock();

        OmDereferenceObject(node);
    }

    if (status == ERROR_SUCCESS) {
        if ((*PingAddressEnum)->AddressSize != sizeof(ULONG)) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Ping enum address size is invalid for interface %1!ws!\n",
                interfaceId
                );
            status = ERROR_INCORRECT_ADDRESS;
            midl_user_free(*PingAddressEnum);
            *PingAddressEnum = NULL;
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Ping enum for interface %1!ws! contains %2!u! addresses\n",
                interfaceId,
                (*PingAddressEnum)->AddressCount
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to get ping address enum for interface %1!ws!, status %2!u!\n",
            interfaceId,
            status
            );
    }

    return(status);

}  // NmpGetInterfacePingAddressEnum


DWORD
NmpDoInterfacePing(
    IN  PNM_INTERFACE     Interface,
    IN  PNM_ADDRESS_ENUM  PingAddressEnum,
    OUT BOOLEAN *         PingSucceeded
    )
/*++

Notes:

    Called with Interface referenced.

--*/
{
    DWORD     status = ERROR_SUCCESS;
    LPCWSTR   interfaceId = OmObjectId(Interface);
    LPWSTR    addressString;
    DWORD     maxAddressStringLength;
    DWORD     i;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Pinging targets for interface %1!ws!.\n",
        interfaceId
        );

    *PingSucceeded = FALSE;

    if (PingAddressEnum->AddressSize != sizeof(ULONG)) {
        return(ERROR_INCORRECT_ADDRESS);
    }

    ClRtlQueryTcpipInformation(
        &maxAddressStringLength,
        NULL,
        NULL
        );

    addressString = LocalAlloc(
                        LMEM_FIXED,
                        (maxAddressStringLength + 1) * sizeof(WCHAR)
                        );

    if (addressString == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate memory for address string.\n"
            );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    for (i=0; i<PingAddressEnum->AddressCount; i++) {
        status = ClRtlTcpipAddressToString(
                     (ULONG) PingAddressEnum->AddressList[i],
                     &addressString
                     );

        if (status == ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Pinging host %1!ws!\n",
                addressString
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to convert address %1!x! to string %2!u!.\n",
                (ULONG) PingAddressEnum->AddressList[i],
                status
                );
        }

        if ( ClRtlIsDuplicateTcpipAddress(
                 (ULONG) PingAddressEnum->AddressList[i])
           )
        {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Ping of host %1!ws! succeeded.\n",
                addressString
                );
            *PingSucceeded = TRUE;
            break;
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Ping of host %1!ws! failed.\n",
                addressString
                );
        }
    }

    LocalFree(addressString);

    return(status);

} // NmpDoInterfacePing


DWORD
NmpTestInterfaceConnectivity(
    PNM_INTERFACE  Interface1,
    PBOOLEAN       Interface1HasConnectivity,
    PNM_INTERFACE  Interface2,
    PBOOLEAN       Interface2HasConnectivity
    )
/*++

Notes:

    Called with NmpLock held. This routine releases and reacquires the
    NmpLock. It must be called with references on the target interfaces.

--*/
{
    DWORD               status, status1, status2;
    PNM_NETWORK         network = Interface1->Network;
    PNM_INTERFACE       localInterface = network->LocalInterface;
    LPCWSTR             networkId = OmObjectId(network);
    LPCWSTR             interface1Id = OmObjectId(Interface1);
    LPCWSTR             interface2Id = OmObjectId(Interface2);
    ULONG               interface1Address, interface2Address;
    PNM_ADDRESS_ENUM    pingEnum1 = NULL, pingEnum2 = NULL;
    PNM_ADDRESS_ENUM    onlineEnum1 = NULL, onlineEnum2 = NULL;
    PNM_ADDRESS_ENUM    unionPingEnum = NULL, unionOnlineEnum = NULL;
    DWORD               addressCount;
    RPC_ASYNC_STATE     async1, async2;
    HANDLE              event1 = NULL, event2 = NULL;
    RPC_BINDING_HANDLE  rpcBinding1 = NULL, rpcBinding2 = NULL;
    DWORD               i1, i2;
    BOOL                duplicate;


    //
    // Reference the nodes associated with the target interfaces so they
    // can't go away during this process.
    //
    OmReferenceObject(Interface1->Node);
    OmReferenceObject(Interface2->Node);

    if (localInterface != NULL) {
        OmReferenceObject(localInterface);
    }

    *Interface1HasConnectivity = *Interface2HasConnectivity = FALSE;

    //
    // Convert the interface address strings to binary form.
    //
    status = ClRtlTcpipStringToAddress(
                 Interface1->Address,
                 &interface1Address
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert interface address string %1!ws! to binary, status %2!u!.\n",
            Interface1->Address,
            status
            );
        goto error_exit;
    }

    status = ClRtlTcpipStringToAddress(
                 Interface2->Address,
                 &interface2Address
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to convert interface address string %1!ws! to binary, status %2!u!.\n",
            Interface2->Address,
            status
            );
        goto error_exit;
    }

    //
    // Fetch the online address list from each of the interfaces.
    // The NmpLock will be released when querying a remote interface.
    //
    status = NmpGetInterfaceOnlineAddressEnum(
                 Interface1,
                 &onlineEnum1
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpGetInterfaceOnlineAddressEnum(
                 Interface2,
                 &onlineEnum2
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Bail out if either of the interfaces was deleted while the NmpLock
    // was released.
    //
    if ((NM_DELETE_PENDING(Interface1) || NM_DELETE_PENDING(Interface2))) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Aborting interface connectivity test on network %1!ws! "
            "because an interface was deleted.\n",
            networkId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        goto error_exit;
    }

    //
    // Take the union of the two online lists
    //
    addressCount = onlineEnum1->AddressCount + onlineEnum2->AddressCount;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Total online address count for network %1!ws! is %2!u!\n",
        networkId,
        addressCount
        );

    if (addressCount == 0) {
        unionOnlineEnum = LocalAlloc(LMEM_FIXED, sizeof(NM_ADDRESS_ENUM));
    }
    else {
        unionOnlineEnum = LocalAlloc(
                            LMEM_FIXED,
                            sizeof(NM_ADDRESS_ENUM) +
                                ((addressCount - 1) * sizeof(ULONGLONG))
                            );
    }

    if (unionOnlineEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate memory for union ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    unionOnlineEnum->AddressSize = sizeof(ULONG);
    unionOnlineEnum->AddressCount = 0;

    if (onlineEnum1->AddressCount != 0) {
        CopyMemory(
            &(unionOnlineEnum->AddressList[0]),
            &(onlineEnum1->AddressList[0]),
            onlineEnum1->AddressCount * sizeof(ULONGLONG)
            );
        unionOnlineEnum->AddressCount = onlineEnum1->AddressCount;
    }

    if (onlineEnum2->AddressCount != 0) {
        CopyMemory(
            &(unionOnlineEnum->AddressList[unionOnlineEnum->AddressCount]),
            &(onlineEnum2->AddressList[0]),
            onlineEnum2->AddressCount * sizeof(ULONGLONG)
            );
        unionOnlineEnum->AddressCount += onlineEnum2->AddressCount;
    }

    midl_user_free(onlineEnum1); onlineEnum1 = NULL;
    midl_user_free(onlineEnum2); onlineEnum2 = NULL;

    //
    // Fetch the ping target list from each of the interfaces.
    // The NmpLock will be released when querying a remote interface.
    //
    status = NmpGetInterfacePingAddressEnum(
                 Interface1,
                 unionOnlineEnum,
                 &pingEnum1
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpGetInterfacePingAddressEnum(
                 Interface2,
                 unionOnlineEnum,
                 &pingEnum2
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    //
    // Bail out if either of the interfaces was deleted while the NmpLock
    // was released.
    //
    if ((NM_DELETE_PENDING(Interface1) || NM_DELETE_PENDING(Interface2))) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Aborting interface connectivity test on network %1!ws! "
            "because an interface was deleted.\n",
            networkId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
        goto error_exit;
    }

    NmpReleaseLock();

    //
    // Take the union of the two ping lists
    //
    addressCount = pingEnum1->AddressCount + pingEnum2->AddressCount;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Total ping address count for network %1!ws! is %2!u!\n",
        networkId,
        addressCount
        );

    if (addressCount == 0) {
        status = ERROR_SUCCESS;
        goto error_lock_and_exit;
    }

    unionPingEnum = LocalAlloc(
                        LMEM_FIXED,
                        sizeof(NM_ADDRESS_ENUM) +
                            ( (NM_MAX_UNION_PING_ENUM_SIZE - 1) *
                              sizeof(ULONGLONG)
                            )
                        );


    if (unionPingEnum == NULL) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate memory for union ping list.\n"
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_lock_and_exit;
    }

    unionPingEnum->AddressSize = sizeof(ULONG);
    unionPingEnum->AddressCount = 0;

    i1 = 0; i2 = 0;

    while (TRUE) {
        while (i1 < pingEnum1->AddressCount) {
            duplicate = NmpIsAddressInAddressEnum(
                            pingEnum1->AddressList[i1],
                            unionPingEnum
                            );

            if (!duplicate) {
                unionPingEnum->AddressList[unionPingEnum->AddressCount++] =
                    pingEnum1->AddressList[i1++];
                break;
            }
            else {
                i1++;
            }
        }

        if (unionPingEnum->AddressCount == NM_MAX_UNION_PING_ENUM_SIZE) {
            break;
        }

        while (i2 < pingEnum2->AddressCount) {
            duplicate = NmpIsAddressInAddressEnum(
                            pingEnum2->AddressList[i2],
                            unionPingEnum
                            );

            if (!duplicate) {
                unionPingEnum->AddressList[unionPingEnum->AddressCount++] =
                    pingEnum2->AddressList[i2++];
                break;
            }
            else {
                i2++;
            }
        }

        if ( (unionPingEnum->AddressCount == NM_MAX_UNION_PING_ENUM_SIZE) ||
             ( (i1 == pingEnum1->AddressCount) &&
               (i2 == pingEnum2->AddressCount)
             )
           )
        {
            break;
        }
    }

    midl_user_free(pingEnum1); pingEnum1 = NULL;
    midl_user_free(pingEnum2); pingEnum2 = NULL;

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Union ping list for network %1!ws! contains %2!u! addresses\n",
        networkId,
        unionPingEnum->AddressCount
        );

    //
    // Ask each interface to ping the list of targets using async RPC calls
    //

    //
    // Allocate resources for the async RPC calls
    //
    if (Interface1 != localInterface) {
        event1 = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (event1 == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate event for async rpc, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        status = RpcAsyncInitializeHandle(&async1, sizeof(async1));

        if (status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize RPC async state, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        async1.NotificationType = RpcNotificationTypeEvent;
        async1.u.hEvent = event1;

        rpcBinding1 = Interface1->Node->IsolateRpcBinding;
    }

    if (Interface2 != localInterface) {
        event2 = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (event2 == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to allocate event for async rpc, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        status = RpcAsyncInitializeHandle(&async2, sizeof(async2));

        if (status != RPC_S_OK) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to initialize RPC async state, status %1!u!.\n",
                status
                );
            goto error_lock_and_exit;
        }

        async2.NotificationType = RpcNotificationTypeEvent;
        async2.u.hEvent = event2;

        rpcBinding2 = Interface2->Node->IsolateRpcBinding;
    }

    if (rpcBinding1 != NULL) {
        //
        // Issue the RPC for interface1 first. Then deal with interface2
        //

        //
        // We need the try-except until a bug is fixed in MIDL
        //
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Issuing RpcDoInterfacePing for interface %1!ws!\n",
            interface1Id
            );

        status = ERROR_SUCCESS;

        try {
            NmRpcDoInterfacePing(
                &async1,
                rpcBinding1,
                (LPWSTR) interface1Id,
                unionPingEnum,
                Interface1HasConnectivity,
                &status1
                );
        } except(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = GetExceptionCode();
        }

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
                interface1Id,
                status
                );
            goto error_lock_and_exit;
        }

        if (rpcBinding2 != NULL) {
            //
            // Issue the RPC for interface2.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Issuing RpcDoInterfacePing for interface %1!ws!\n",
                interface2Id
                );

            status = ERROR_SUCCESS;

            try {
                NmRpcDoInterfacePing(
                    &async2,
                    rpcBinding2,
                    (LPWSTR) interface2Id,
                    unionPingEnum,
                    Interface2HasConnectivity,
                    &status2
                    );
            } except(I_RpcExceptionFilter(RpcExceptionCode())) {
                status = GetExceptionCode();
            }

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
                    interface1Id,
                    status
                    );
                goto error_lock_and_exit;
            }

            //
            // Wait for the RPC for interface2 to complete
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Waiting for RpcDoInterfacePing for interface %1!ws! to complete\n",
                interface2Id
                );

            status = WaitForSingleObjectEx(event2, INFINITE, FALSE);
            CL_ASSERT(status == WAIT_OBJECT_0);

            status = RpcAsyncCompleteCall(
                         &async2,
                         &status2
                         );

            CL_ASSERT(status == RPC_S_OK);

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Wait for RpcDoInterfacePing for interface %1!ws! completed.\n",
                interface2Id
                );
        }
        else {
            //
            // Call the local routine for interface2.
            //
            status2 = NmpDoInterfacePing(
                          Interface2,
                          unionPingEnum,
                          Interface2HasConnectivity
                          );
        }

        //
        // Wait for the RPC for interface1 to complete
        //
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Waiting for RpcDoInterfacePing for interface %1!ws! to complete\n",
            interface1Id
            );

        status = WaitForSingleObjectEx(event1, INFINITE, FALSE);
        CL_ASSERT(status == WAIT_OBJECT_0);

        status = RpcAsyncCompleteCall(
                     &async1,
                     &status1
                     );

        CL_ASSERT(status == RPC_S_OK);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Wait for RpcDoInterfacePing for interface %1!ws! completed.\n",
            interface1Id
            );
    }
    else {
        //
        // Send the RPC to interface2 first. Then call the local
        // routine for interface1
        //
        CL_ASSERT(rpcBinding2 != NULL);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Issuing RpcDoInterfacePing for interface %1!ws!\n",
            interface2Id
            );

        status = ERROR_SUCCESS;

        try {
            NmRpcDoInterfacePing(
                &async2,
                rpcBinding2,
                (LPWSTR) interface2Id,
                unionPingEnum,
                Interface2HasConnectivity,
                &status2
                );
        } except(I_RpcExceptionFilter(RpcExceptionCode())) {
            status = GetExceptionCode();
        }

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
                interface1Id,
                status
                );
            goto error_lock_and_exit;
        }

        status1 = NmpDoInterfacePing(
                      Interface1,
                      unionPingEnum,
                      Interface1HasConnectivity
                      );

        //
        // Wait for the RPC for interface2 to complete
        //
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Waiting for RpcDoInterfacePing for interface %1!ws! to complete\n",
            interface2Id
            );

        status = WaitForSingleObject(event2, INFINITE);
        CL_ASSERT(status == WAIT_OBJECT_0);

        status = RpcAsyncCompleteCall(
                     &async2,
                     &status2
                     );

        CL_ASSERT(status == RPC_S_OK);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Wait for RpcDoInterfacePing for interface %1!ws! completed.\n",
            interface2Id
            );
    }

    if (status1 != RPC_S_OK) {
        status = status1;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
            interface1Id,
            status
            );
        goto error_lock_and_exit;
    }

    if (status2 != RPC_S_OK) {
        status = status2;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] DoPing RPC failed for interface %1!ws!, status %2!u!.\n",
            interface2Id,
            status
            );
        goto error_lock_and_exit;

    }

error_lock_and_exit:

    NmpAcquireLock();

    if ( (status == ERROR_SUCCESS) &&
         (NM_DELETE_PENDING(Interface1) || NM_DELETE_PENDING(Interface2))
       )
    {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Aborting interface connectivity test on network %1!ws! "
            "because an interface was deleted.\n",
            networkId
            );
        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
    }

error_exit:

    OmDereferenceObject(Interface1->Node);
    OmDereferenceObject(Interface2->Node);

    if (localInterface != NULL) {
        OmDereferenceObject(localInterface);
    }

    if (onlineEnum1 != NULL) {
        midl_user_free(onlineEnum1);
    }

    if (onlineEnum2 != NULL) {
        midl_user_free(onlineEnum2);
    }

    if (unionOnlineEnum != NULL) {
        LocalFree(unionOnlineEnum);
    }

    if (pingEnum1 != NULL) {
        midl_user_free(pingEnum1);
    }

    if (pingEnum2 != NULL) {
        midl_user_free(pingEnum2);
    }

    if (unionPingEnum != NULL) {
        LocalFree(unionPingEnum);
    }

    if (event1 != NULL) {
        CloseHandle(event1);
    }

    if (event2 != NULL) {
        CloseHandle(event2);
    }

    return(status);

} // NmpTestInterfaceConnectivity


/////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpRegisterInterface(
    IN PNM_INTERFACE  Interface,
    IN BOOLEAN        RetryOnFailure
    )
/*++

    Called with the NmpLock held.

--*/
{
    DWORD            status;
    LPWSTR           interfaceId = (LPWSTR) OmObjectId(Interface);
    PNM_NETWORK      network = Interface->Network;
    PVOID            tdiAddress = NULL;
    ULONG            tdiAddressLength = 0;
    NDIS_MEDIA_STATE mediaStatus;


    CL_ASSERT(!NmpIsInterfaceRegistered(Interface));

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Registering interface %1!ws! (%2!ws!) with cluster transport, "
        "addr %3!ws!, endpoint %4!ws!.\n",
        interfaceId,
        OmObjectName(Interface),
        Interface->Address,
        Interface->ClusnetEndpoint
        );

    status = ClRtlBuildTcpipTdiAddress(
                 Interface->Address,
                 Interface->ClusnetEndpoint,
                 &tdiAddress,
                 &tdiAddressLength
                 );

    if (status == ERROR_SUCCESS) {
        status = ClusnetRegisterInterface(
                     NmClusnetHandle,
                     Interface->Node->NodeId,
                     Interface->Network->ShortId,
                     0,
                     Interface->AdapterId,
                     wcslen(Interface->AdapterId) * sizeof(WCHAR),
                     tdiAddress,
                     tdiAddressLength,
                     (PULONG) &mediaStatus
                     );

        LocalFree(tdiAddress);

        if (status == ERROR_SUCCESS) {
            Interface->Flags |= NM_FLAG_IF_REGISTERED;
            network->RegistrationRetryTimeout = 0;

            //
            // If this is a local interface, and if its media status
            // indicates that it is connected, schedule a worker thread to
            // deliver an interface up notification. Clusnet does not
            // deliver interface up events for local interfaces.
            //
            if (network->LocalInterface == Interface) {
                if (mediaStatus == NdisMediaStateConnected) {
                    network->Flags |= NM_FLAG_NET_REPORT_LOCAL_IF_UP;
                    NmpScheduleNetworkConnectivityReport(network);
                } else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Local interface %1!ws! reported "
                        "disconnected.\n",
                        interfaceId,
                        status
                        );
                    network->Flags |= NM_FLAG_NET_REPORT_LOCAL_IF_FAILED;
                    NmpScheduleNetworkConnectivityReport(network);
                }
            }
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to register interface %1!ws! with cluster "
                "transport, status %2!u!.\n",
                interfaceId,
                status
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to build TDI bind address for interface %1!ws!, "
            "status %2!u!.\n",
            interfaceId,
            status
            );
    }

    if (status != ERROR_SUCCESS) {
        WCHAR  string[16];

        wsprintfW(&(string[0]), L"%u", status);

        CsLogEvent3(
            LOG_UNUSUAL,
            NM_EVENT_REGISTER_NETINTERFACE_FAILED,
            OmObjectName(Interface->Node),
            OmObjectName(Interface->Network),
            string
            );

        //
        // Retry if the error is transient
        //
        if ( RetryOnFailure &&
             ( (status == ERROR_INVALID_NETNAME) ||
               (status == ERROR_NOT_ENOUGH_MEMORY) ||
               (status == ERROR_NO_SYSTEM_RESOURCES)
             )
           )
        {
            NmpStartNetworkRegistrationRetryTimer(network);

            status = ERROR_SUCCESS;
        }
    }

    return(status);

}  // NmpRegisterInterface


VOID
NmpDeregisterInterface(
    IN  PNM_INTERFACE   Interface
    )
/*++

Routine Description:

    Deregisters an interface from the cluster transport.

Arguments:

    Interface - A pointer to the interface to deregister.

Return Value:

    None.

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD status;


    CL_ASSERT(NmpIsInterfaceRegistered(Interface));

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Deregistering interface %1!ws! (%2!ws!) from cluster "
        "transport.\n",
        OmObjectId(Interface),
        OmObjectName(Interface)
        );

    status = ClusnetDeregisterInterface(
                 NmClusnetHandle,
                 Interface->Node->NodeId,
                 Interface->Network->ShortId
                 );

    CL_ASSERT(
        (status == ERROR_SUCCESS) ||
        (status == ERROR_CLUSTER_NETINTERFACE_NOT_FOUND)
        );

    Interface->Flags &= ~NM_FLAG_IF_REGISTERED;

    return;

} // NmpDeregisterNetwork


DWORD
NmpPrepareToCreateInterface(
    IN  PNM_INTERFACE_INFO2   InterfaceInfo,
    OUT PNM_NETWORK *         Network,
    OUT PNM_NODE *            Node
    )
{
    DWORD          status;
    PNM_INTERFACE  netInterface = NULL;
    PNM_NODE       node = NULL;
    PNM_NETWORK    network = NULL;
    PLIST_ENTRY    entry;


    *Node = NULL;
    *Network = NULL;

    //
    // Verify that the associated node and network objects exist.
    //
    network = OmReferenceObjectById(
                  ObjectTypeNetwork,
                  InterfaceInfo->NetworkId
                  );

    if (network == NULL) {
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Network %1!ws! does not exist. Cannot create "
            "interface %2!ws!\n",
            InterfaceInfo->NetworkId,
            InterfaceInfo->Id
            );
        goto error_exit;
    }

    node = OmReferenceObjectById(ObjectTypeNode, InterfaceInfo->NodeId);

    if (node == NULL) {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Node %1!ws! does not exist. Cannot create interface %2!ws!\n",
            InterfaceInfo->NodeId,
            InterfaceInfo->Id
            );
        goto error_exit;
    }

    //
    // Verify that the interface doesn't already exist.
    //
    NmpAcquireLock();

    for ( entry = node->InterfaceList.Flink;
          entry != &(node->InterfaceList);
          entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NodeLinkage);

        if (netInterface->Network == network) {
            status = ERROR_CLUSTER_NETINTERFACE_EXISTS;
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] An interface already exists for node %1!ws! on network %2!ws!\n",
                InterfaceInfo->NodeId,
                InterfaceInfo->NetworkId
                );
            NmpReleaseLock();
            goto error_exit;
        }
    }

    NmpReleaseLock();

    //
    // Verify that the specified interface ID is unique.
    //
    netInterface = OmReferenceObjectById(
                       ObjectTypeNetInterface,
                       InterfaceInfo->Id
                       );

    if (netInterface != NULL) {
        OmDereferenceObject(netInterface);
        status = ERROR_CLUSTER_NETINTERFACE_EXISTS;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] An interface with ID %1!ws! already exists\n",
            InterfaceInfo->Id
            );
        goto error_exit;
    }

    *Node = node;
    *Network = network;

    return(ERROR_SUCCESS);


error_exit:

    if (network != NULL) {
        OmDereferenceObject(network);
    }

    if (node != NULL) {
        OmDereferenceObject(node);
    }

    return(status);

}  // NmpPrepareToCreateInterface


PNM_INTERFACE
NmpGetInterfaceForNodeAndNetworkById(
    IN  CL_NODE_ID     NodeId,
    IN  CL_NETWORK_ID  NetworkId
    )

/*++

Routine Description:

    Give the node Id and network short Id, return a pointer to
    the intersecting interface object

Arguments:

    NodeId - The ID of the node associated with this interface

    NetworkId - The short Id of the network associated with this interface

Return Value:

    A pointer to the interface object if successful.

    NULL if unsuccessful. Extended error information is available from
    GetLastError().

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD      status;
    PNM_NODE   node = NmpIdArray[NodeId];


    if (node != NULL) {
        PLIST_ENTRY     entry;
        PNM_INTERFACE   netInterface;

        //
        // run down the list of interfaces associated with this node,
        // looking for one whose network matches the specified short ID
        //

        for (entry = node->InterfaceList.Flink;
             entry != &(node->InterfaceList);
             entry = entry->Flink
             )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NodeLinkage
                               );

            if (netInterface->Network->ShortId == NetworkId) {
                return(netInterface);
            }
        }

        status = ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
    }
    else {
        status = ERROR_CLUSTER_NODE_NOT_FOUND;
    }

    SetLastError(status);

    return(NULL);

}  // NmpGetInterfaceForNodeAndNetworkById


DWORD
NmpConvertPropertyListToInterfaceInfo(
    IN PVOID              InterfacePropertyList,
    IN DWORD              InterfacePropertyListSize,
    PNM_INTERFACE_INFO2   InterfaceInfo
    )
{
    DWORD  status;

    //
    // Unmarshall the property list.
    //
    ZeroMemory(InterfaceInfo, sizeof(NM_INTERFACE_INFO2));

    status = ClRtlVerifyPropertyTable(
                 NmpInterfaceProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InterfacePropertyList,
                 InterfacePropertyListSize,
                 (LPBYTE) InterfaceInfo
                 );

    if (status == ERROR_SUCCESS) {
        InterfaceInfo->NetIndex = NmInvalidInterfaceNetIndex;
    }

    return(status);

} // NmpConvertPropertyListToInterfaceInfo


BOOLEAN
NmpVerifyLocalInterfaceConnected(
    IN  PNM_INTERFACE     Interface
    )
/*++

Routine Description:

    Queries local interface adapter for current media
    status using an NDIS ioctl.

Arguments:

    Interface - interface object for local adapter to query

Return value:

    TRUE if media status is connected or cannot be determined
    FALSE if media status is disconnected

Notes:

    Called and returns with NM lock acquired.

--*/
{
    PWCHAR             adapterDevNameBuffer = NULL;
    PWCHAR             adapterDevNamep, prefix, brace;
    DWORD              prefixSize, allocSize, adapterIdSize;
    DWORD              status = ERROR_SUCCESS;
    UNICODE_STRING     adapterDevName;
    NIC_STATISTICS     ndisStats;
    BOOLEAN            mediaConnected = TRUE;

    // verify parameters
    if (Interface == NULL || Interface->AdapterId == NULL) {
        return TRUE;
    }

    // the adapter device name is of the form
    //
    //     \Device\{AdapterIdGUID}
    //
    // the AdapterId field in the NM_INTERFACE structure is
    // currently not enclosed in braces, but we handle the
    // case where it is.

    // set up the adapter device name prefix
    prefix = L"\\Device\\";
    prefixSize = wcslen(prefix) * sizeof(WCHAR);

    // allocate a buffer for the adapter device name.
    adapterIdSize = wcslen(Interface->AdapterId) * sizeof(WCHAR);
    allocSize = prefixSize + adapterIdSize + sizeof(UNICODE_NULL);
    brace = L"{";
    if (*((PWCHAR)Interface->AdapterId) != *brace) {
        allocSize += 2 * sizeof(WCHAR);
    }
    adapterDevNameBuffer = LocalAlloc(LMEM_FIXED, allocSize);
    if (adapterDevNameBuffer == NULL) {
        ClRtlLogPrint(
            LOG_UNUSUAL,
            "[NM] Failed to allocate device name buffer for "
            "adapter %1!ws!. Assuming adapter is connected.\n",
            Interface->AdapterId
            );
        return(TRUE);
    }

    // build the adapter device name from the adapter ID
    ZeroMemory(adapterDevNameBuffer, allocSize);

    adapterDevNamep = adapterDevNameBuffer;

    CopyMemory(adapterDevNamep, prefix, prefixSize);

    adapterDevNamep += prefixSize / sizeof(WCHAR);

    if (*((PWCHAR)Interface->AdapterId) != *brace) {
        *adapterDevNamep = *brace;
        adapterDevNamep++;
    }

    CopyMemory(adapterDevNamep, Interface->AdapterId, adapterIdSize);

    if (*((PWCHAR)Interface->AdapterId) != *brace) {
        brace = L"}";
        adapterDevNamep += adapterIdSize / sizeof(WCHAR);
        *adapterDevNamep = *brace;
    }

    RtlInitUnicodeString(&adapterDevName, (LPWSTR)adapterDevNameBuffer);

    // query the adapter for NDIS statistics
    ZeroMemory(&ndisStats, sizeof(ndisStats));
    ndisStats.Size = sizeof(ndisStats);

    if (!NdisQueryStatistics(&adapterDevName, &ndisStats)) {

        status = GetLastError();
        ClRtlLogPrint(
            LOG_UNUSUAL,
            "[NM] NDIS statistics query to adapter %1!ws! failed, "
            "error %2!u!. Assuming adapter is connected.\n",
            Interface->AdapterId, status
            );

    } else {

        if (ndisStats.MediaState == MEDIA_STATE_DISCONNECTED) {
            mediaConnected = FALSE;
        }
    }

    LocalFree(adapterDevNameBuffer);

    return(mediaConnected);

} // NmpVerifyLocalInterfaceConnected
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\nmfixup.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    node.c

Abstract:

    Fix up Routines for Upgrade and Rolling Upgrades

Author:

    Sunita Shrivastava(sunitas) 18-Mar-1998


Revision History:

--*/
/****
@doc    EXTERNAL INTERFACES CLUSSVC DM
****/

#define UNICODE 1

#include "nmp.h"

//
// Cluster registry API function pointers.
//
CLUSTER_REG_APIS
NmpFixupRegApis = {
    (PFNCLRTLCREATEKEY) DmRtlCreateKey,
    (PFNCLRTLOPENKEY) DmRtlOpenKey,
    (PFNCLRTLCLOSEKEY) DmCloseKey,
    (PFNCLRTLSETVALUE) DmSetValue,
    (PFNCLRTLQUERYVALUE) DmQueryValue,
    (PFNCLRTLENUMVALUE) DmEnumValue,
    (PFNCLRTLDELETEVALUE) DmDeleteValue,
    (PFNCLRTLLOCALCREATEKEY) DmRtlLocalCreateKey,
    (PFNCLRTLLOCALSETVALUE) DmLocalSetValue,
    (PFNCLRTLLOCALDELETEVALUE) DmLocalDeleteValue,
};

//
// Data
//
RESUTIL_PROPERTY_ITEM
NmJoinFixupSDProperties[]=
{
    {
        CLUSREG_NAME_CLUS_SD, NULL, CLUSPROP_FORMAT_BINARY,
        0, 0, 0,
        0,
        0
    },
    {
        0
    }
};

// Fixup Table for WINS
RESUTIL_PROPERTY_ITEM
NmJoinFixupWINSProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_IS_ALIVE, CLUS_RESTYPE_NAME_WINS , CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_IS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE ,
                0,
                0
            },

            {
                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,CLUS_RESTYPE_NAME_WINS ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE ,
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_WINS ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_NAME,CLUS_RESTYPE_NAME_WINS ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+sizeof(LPWSTR*)
            },

            {
                CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS,CLUS_RESTYPE_NAME_WINS,CLUSPROP_FORMAT_MULTI_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+2*sizeof(LPWSTR*)
            },

            {
                0
            }
}; //NmJoinFixupWINSProperties

//Fixup Table for DHCP
RESUTIL_PROPERTY_ITEM
NmJoinFixupDHCPProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_IS_ALIVE, CLUS_RESTYPE_NAME_DHCP , CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_IS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE ,
                0,
                0
            },

            {
                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,CLUS_RESTYPE_NAME_DHCP ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE ,
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_DHCP ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_NAME,CLUS_RESTYPE_NAME_DHCP ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+sizeof(LPWSTR*)
            },

            {
                CLUSREG_NAME_RESTYPE_ADMIN_EXTENSIONS,CLUS_RESTYPE_NAME_DHCP,CLUSPROP_FORMAT_MULTI_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+2*sizeof(LPWSTR*)
            },

            {
                0
            }
};//NmJoinFixupDHCPProperties


RESUTIL_PROPERTY_ITEM
NmJoinFixupNewMSMQProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_IS_ALIVE, CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_IS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE ,
                0,
                0
            },

            {
                CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_DWORD,
                0,CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE ,CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE ,
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_RESTYPE_NAME,CLUS_RESTYPE_NAME_NEW_MSMQ,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                2*sizeof(DWORD)+sizeof(LPWSTR*)
            },

            {
                0
            }
};//NmJoinFixupNewMSMQProperties


//Fixup Table for changing thr dl name of MSDTC resource type
RESUTIL_PROPERTY_ITEM
NmJoinFixupMSDTCProperties[]=
{
            {
                CLUSREG_NAME_RESTYPE_DLL_NAME,CLUS_RESTYPE_NAME_MSDTC,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                0
            },

            {
                0
            }

};//NmJoinFixupMSDTCProperties


//Fixup table for node version info

RESUTIL_PROPERTY_ITEM
NmFixupVersionInfo[]=
{
            {
                CLUSREG_NAME_NODE_MAJOR_VERSION,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                0
            },

            {
                CLUSREG_NAME_NODE_MINOR_VERSION,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                sizeof(DWORD)
            },

            {
                CLUSREG_NAME_NODE_BUILD_NUMBER,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                2*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_NODE_CSDVERSION,NULL,CLUSPROP_FORMAT_SZ,
                0,0,0,
                0,
                3*sizeof(DWORD)
            },

            {
                CLUSREG_NAME_NODE_PRODUCT_SUITE,NULL,CLUSPROP_FORMAT_DWORD,
                0,0,((DWORD)-1),
                0,
                3*sizeof(DWORD) + sizeof(LPWSTR*)
            },

            {
                0
            }

}; //NmFixupVersionInfo

RESUTIL_PROPERTY_ITEM
NmFixupClusterProperties[] =
    {
        {
            CLUSREG_NAME_ADMIN_EXT, NULL, CLUSPROP_FORMAT_MULTI_SZ,
            0, 0, 0,
            0,
            0
        },
        {
            0
        }
    };







//Used by NmUpdatePerformFixups update
RESUTIL_PROPERTY_ITEM
NmpJoinFixupProperties[] =
    {
        {
            CLUSREG_NAME_CLUS_SD, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            0,
            0
        },
        {
            0
        }
    };


RESUTIL_PROPERTY_ITEM
NmpFormFixupProperties[] =
    {
        {
            CLUSREG_NAME_CLUS_SD, NULL, CLUSPROP_FORMAT_BINARY,
            0, 0, 0,
            0,
            0
        },
        {
            0
        }
    };

NM_FIXUP_CB_RECORD FixupTable[]=
{
   { ApiFixupNotifyCb, NM_FORM_FIXUP|NM_JOIN_FIXUP}
};

// Fixup Table used for NmUpdatePerformFixups2 update type
NM_FIXUP_CB_RECORD2 FixupTable2[]=
{
   { ApiFixupNotifyCb, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmpJoinFixupProperties},
   { FmBuildWINS, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupWINSProperties,},
   { FmBuildDHCP, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupDHCPProperties},
   { FmBuildNewMSMQ, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupNewMSMQProperties},
   { FmBuildMSDTC, NM_FORM_FIXUP|NM_JOIN_FIXUP, NmJoinFixupMSDTCProperties},
   { NmpBuildVersionInfo, NM_JOIN_FIXUP|NM_FORM_FIXUP, NmFixupVersionInfo},
   { FmBuildClusterProp, NM_FORM_FIXUP|NM_JOIN_FIXUP,NmFixupClusterProperties}
};


NM_POST_FIXUP_CB PostFixupCbTable[]=
{
    NULL,
    FmFixupNotifyCb,
    FmFixupNotifyCb,
    FmFixupNotifyCb,
    FmFixupNotifyCb,
    NmFixupNotifyCb,
    NULL
};




/****
@func       DWORD | NmPerformFixups| This is called when a cluster is being
            formed/or joining. Issues NmUpdateperforfixups GUM update
            for registry fixups of SECURITY_DESCRIPTOR  when NT5 node joins
            NT4 node.Also issues NmUpdateperforfixups2 GUM update for
            WINS and DHCP fixups when NT5 joins NT4. This update type can
            be extended in future to do more fixups for postNT5 and NT5 scenario.
            If later it is guaranteed that there is no NT4 node in cluster,
            NmUpdatePerformFixups update type won't be needed and hence can
            be taken out.

@comm       The first time the cluster service forms a cluster after an
            upgrade, it might have registry fixups it wants to make to the
            existing cluster registry.  Also, when an uplevel node
            joins a downlevel node, join fixups can be performed.
            Note that this is called on every form/join

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmpUpdatePerformFixups> <f NmpUpdatePerformFixups2>
****/

DWORD NmPerformFixups(
    IN DWORD dwFixupType)
{

    DWORD               dwCount = sizeof(FixupTable)/sizeof(NM_FIXUP_CB_RECORD);
    DWORD               dwStatus = ERROR_SUCCESS;
    PNM_FIXUP_CB_RECORD pFixupCbRec;
    PNM_FIXUP_CB_RECORD2 pFixupCbRec2;
    PVOID               pPropertyList = NULL;
    DWORD               dwPropertyListSize;
    DWORD               i,j;
    DWORD               dwSize;
    DWORD               Required;
    LPWSTR              szKeyName=NULL;
    LPBYTE              pBuffer=NULL;
    PRESUTIL_PROPERTY_ITEM pPropertyItem;

    ClRtlLogPrint(LOG_NOISE,"[NM] NmPerformFixups Entry, dwFixupType=%1!u!\r\n",
        dwFixupType);

    // using old gum update handler - this is needed to maintain compataility
    // with NT4, can be discarded later. See comments above.
    //

    for (i=0; i < dwCount ; i++)
    {

        pFixupCbRec = &FixupTable[i];

        //if this fixup doesnt need to be applied, skip it
        if (!(pFixupCbRec->dwFixupMask & dwFixupType))
            continue;

        dwStatus = (pFixupCbRec->pfnFixupNotifyCb)(dwFixupType, &pPropertyList,
                                         &dwPropertyListSize,&szKeyName);

        if (dwStatus != ERROR_SUCCESS)
        {
            goto FnExit;
        }
        if (pPropertyList && dwPropertyListSize)
        {
            //
            // Issue a global update
            //
            dwStatus = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdatePerformFixups,
                         2,
                         dwPropertyListSize,
                         pPropertyList,
                         sizeof(DWORD),
                         &dwPropertyListSize
                         );

            LocalFree(pPropertyList);
            pPropertyList = NULL;
            if(szKeyName)
            {
                LocalFree(szKeyName);
                szKeyName=NULL;
            }
        }

       if (dwStatus != ERROR_SUCCESS)
            goto FnExit;
    }


// Rohit (rjain): introduced new update type to fix the registry and
// in-memory structures after a node with a higher version of clustering
// service joins a node with a lower version. To make it extensible in future
// all the information needed for a fixup is passed as arguments to the fixup
// function. Any new fix can be added by adding suitable record to FixupTable2 and
// a postfixup function callback to PostfixupCbTable.

    dwCount= sizeof(FixupTable2)/sizeof(NM_FIXUP_CB_RECORD2);
    for (i=0; i < dwCount ; i++)
    {

        pFixupCbRec2 = &FixupTable2[i];

        //if this fixup doesnt need to be applied, skip it
        if (!(pFixupCbRec2->dwFixupMask & dwFixupType))
            continue;

        dwStatus = (pFixupCbRec2->pfnFixupNotifyCb)(dwFixupType, &pPropertyList,
                                         &dwPropertyListSize,&szKeyName);

        if (dwStatus != ERROR_SUCCESS)
        {
            goto FnExit;
        }
        if (pPropertyList && dwPropertyListSize)
        {
            // Marshall PropertyTable into byte array
            Required=sizeof(DWORD);
        AllocMem:
            pBuffer=(LPBYTE)LocalAlloc(LMEM_FIXED,Required);
            if (pBuffer==NULL)
            {
                dwStatus=GetLastError();
                goto FnExit;
            }
            dwSize=Required;
            dwStatus=ClRtlMarshallPropertyTable(pFixupCbRec2->pPropertyTable,dwSize,pBuffer,&Required);
            if(dwStatus!= ERROR_SUCCESS)
            {
                LocalFree(pBuffer);
                pBuffer=NULL;
              //  ClRtlLogPrint(LOG_NOISE,"[NM] NmPerformFixups - Memory Required=%1!u!\r\n",
              //          Required);
                goto AllocMem;
            }
            //
            // Issue a global update
            //
            dwStatus = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdatePerformFixups2,
                         5,
                         dwPropertyListSize,
                         pPropertyList,
                         sizeof(DWORD),
                         &dwPropertyListSize,
                         sizeof(DWORD),
                         &i,
                         (lstrlenW(szKeyName)+1)*sizeof(WCHAR),
                         szKeyName,
                         Required,
                         pBuffer
                         );

            LocalFree(pPropertyList);
            pPropertyList = NULL;
            LocalFree(pBuffer);
            pBuffer= NULL;
            if(szKeyName)
            {
                LocalFree(szKeyName);
                szKeyName= NULL;
            }
        }

       if (dwStatus != ERROR_SUCCESS)
            break;
    }


FnExit:
    if(szKeyName)
    {
        LocalFree(szKeyName);
        szKeyName=NULL;
    }
     ClRtlLogPrint(LOG_NOISE,"[NM] NmPerformFixups Exit, dwStatus=%1!u!\r\n",
        dwStatus);

    return(dwStatus);

} //NmPerformFixups



/****
@func       DWORD | NmpUpdatePerformFixups| The gum update handler for
            doing the registry fixups.

@parm       IN DWORD | IsSourceNode| If the gum request originated at this
node.

@parm       IN PVOID| pPropertyList| Pointer to a property list structure.

@parm       IN DWORD | pdwPropertyListSize | A pointer to a DWORD containing
            the size of the property list structure.

@comm       The gum update handler commits this fixup to the cluster registry
            as a transaction.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmJoinFixup> <f NmFormFixup>
****/
DWORD NmpUpdatePerformFixups(
    IN BOOL     IsSourceNode,
    IN PVOID    pPropertyList,
    IN LPDWORD  pdwPropertyListSize
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    HLOCALXSACTION  hXaction;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process PerformFixups update. "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Begin a transaction
    //
    hXaction = DmBeginLocalUpdate();

    if (hXaction != NULL) {
        dwStatus = ClRtlSetPropertyTable(
                       hXaction,
                       DmClusterParametersKey,
                       &NmpFixupRegApis,
                       NmpJoinFixupProperties,
                       NULL,
                       FALSE,
                       pPropertyList,
                       *pdwPropertyListSize,
                       FALSE /*bForceWrite*/,
                       NULL
                       );

        if (dwStatus == ERROR_SUCCESS) {
            DmCommitLocalUpdate(hXaction);
        }
        else {
            DmAbortLocalUpdate(hXaction);
        }
    }
    else {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to begin a transaction "
            "to perform fixups, status %1!u!\n",
            dwStatus
            );
    }

    NmpLeaveApi();

    return(dwStatus);

} // NmpUpdatePerformFixups


/****
@func       DWORD | NmpUpdatePerformFixups2| The gum update handler for
            doing the registry fixups and updating in-memory fixups.New fixups
            can be added by adding suitable record to FixupTable2. However,
            for these new fixups only registry fixup will be carried out.

@parm       IN DWORD | IsSourceNode| If the gum request originated at this node.

@parm       IN PVOID| pPropertyList| Pointer to a property list structure.

@parm       IN DWORD | pdwPropertyListSize | Pointer to a DWORD containing
            the size of the property list structure.

@parm       IN LPDWORD | lpdeFixupNum | Pointer to DWORD which specifies the
            the index in NmpJoinFixupProperties table.
@parm       IN PVOID | lpKeyName | Registry Key which needs to be updated

@parm       IN PVOID  | pPropertyBuffer| Registry update table in marshalled form

@comm       The gum update handler commits this fixup to the cluster registry
            as a transaction.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f NmJoinFixup> <f NmFormFixup> <f PostFixupCbTable>
****/

DWORD NmpUpdatePerformFixups2(
    IN BOOL     IsSourceNode,
    IN PVOID    pPropertyList,
    IN LPDWORD  pdwPropertyListSize,
    IN LPDWORD  lpdwFixupNum,
    IN PVOID    lpKeyName,
    IN PVOID    pPropertyBuffer
    )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    HLOCALXSACTION  hXaction = NULL;
    HDMKEY          hdmKey = NULL;
    PRESUTIL_PROPERTY_ITEM  pPropertyTable=NULL;
    PRESUTIL_PROPERTY_ITEM  propertyItem;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE, 
            "[NM] Not in valid state to process PerformFixups2 update. "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    if(pPropertyBuffer == NULL)
    {
       ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] NmpUpdatePerformJoinFixups2: Bad Arguments\n"
                );
        dwStatus = ERROR_BAD_ARGUMENTS;
        goto FnExit;
     }

    // Begin a transaction
    //
    hXaction = DmBeginLocalUpdate();

    if (hXaction == NULL) {
        dwStatus = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL, 
            "[NM] NmpUpdatePerformJoinFixups2: Failed to begin a transaction, "
            "status %1!u!\n",
            dwStatus
            );
        goto FnExit;
    }

    // special case - if fixup is for the property of key "Cluster"
    if(!lstrcmpW((LPCWSTR)lpKeyName,CLUSREG_KEYNAME_CLUSTER))
    {
        hdmKey=DmClusterParametersKey;
    }
    else
    {
        hdmKey=DmOpenKey(DmClusterParametersKey,
                         (LPCWSTR)lpKeyName,
                         KEY_ALL_ACCESS
                         );
        if (hdmKey == NULL)
        {
            dwStatus = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL, 
                "[NM] NmpUpdatePerformJoinFixups2: DmOpenKey failed to "
                "open key %1!ws! : error %2!u!\n",
                lpKeyName,dwStatus);
            goto FnExit;
        }
    }

    //unmarshall pPropertyBuffer into a RESUTIL_PROPERTY_ITEM table
    //
    dwStatus=ClRtlUnmarshallPropertyTable(&pPropertyTable,pPropertyBuffer);

    if(dwStatus != ERROR_SUCCESS)
        goto FnExit;

    dwStatus=ClRtlSetPropertyTable(
                            hXaction,
                            hdmKey,
                            &NmpFixupRegApis,
                            pPropertyTable,
                            NULL,
                            FALSE,
                            pPropertyList,
                            *pdwPropertyListSize,
                            FALSE, // bForceWrite
                            NULL
                            );

   if (dwStatus != ERROR_SUCCESS) {
       goto FnExit;
   }

   // callback function to update in-memory structures
   // for any new fixup introduced in later version,
   // the in-memory fixups will not be applied.
   if (*lpdwFixupNum < (sizeof(PostFixupCbTable)/sizeof(NM_POST_FIXUP_CB)))
   {
       if (PostFixupCbTable[*lpdwFixupNum] !=NULL){
           dwStatus=(PostFixupCbTable[*lpdwFixupNum])();
           ClRtlLogPrint(LOG_UNUSUAL, 
                "[NM] NmpUpdatePerformJoinFixups2: called postfixup "
                "notifycb function with  status %1!u!\n",
                dwStatus
                );
       }
   }

FnExit:
    if (hXaction != NULL)
    {
        if (dwStatus == ERROR_SUCCESS){
            DmCommitLocalUpdate(hXaction);
        }
        else {
            DmAbortLocalUpdate(hXaction);
        }
    }

    if((hdmKey!= DmClusterParametersKey) && (hdmKey!= NULL)) {
        DmCloseKey(hdmKey);
    }

    if (pPropertyTable != NULL) {
        // Free pPropertyTable structure
        propertyItem=pPropertyTable;

        if(propertyItem!=NULL){
            while(propertyItem->Name != NULL)
            {
                LocalFree(propertyItem->Name);
                if(propertyItem->KeyName!=NULL)
                    LocalFree(propertyItem->KeyName);
                propertyItem++;
            }

            LocalFree(pPropertyTable);
        }
    }

    NmpLeaveApi();

    return(dwStatus);

} // NmpUpdatePerformFixups2



DWORD NmFixupNotifyCb(VOID)
{

    ClRtlLogPrint(LOG_NOISE, 
        "[NM] NmFixupNotifyCb: Calculating Cluster Node Limit\r\n");
    //update the product suite information
    //when the node objects are created we assume that the suite
    //type is Enterprise.
    //Here after a node has joined and informed us about its suite
    //type by making fixups to the registry, we read the registry
    //and update the node structure
    NmpRefreshNodeObjects();
    //recalc the cluster node limit
    NmpResetClusterNodeLimit();

    //SS: This is ugly---we should pass in the product suits early on
    //also the fixup interface needs to to be richer so that the postcallback
    //function nodes whether it is a form fixup or a join fixup and if it 
    //is a join fixup, which node is joining.  This could certainly optimize
    //some of the fixup processing

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\service\nm\network.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Implements the Node Manager's network management routines.

Author:

    Mike Massa (mikemas) 7-Nov-1996


Revision History:

--*/


#include "nmp.h"


/////////////////////////////////////////////////////////////////////////////
//
// Data
//
/////////////////////////////////////////////////////////////////////////////

ULONG                  NmpNextNetworkShortId = 0;
LIST_ENTRY             NmpNetworkList = {NULL, NULL};
LIST_ENTRY             NmpInternalNetworkList = {NULL, NULL};
LIST_ENTRY             NmpDeletedNetworkList = {NULL, NULL};
DWORD                  NmpNetworkCount = 0;
DWORD                  NmpInternalNetworkCount = 0;
DWORD                  NmpClientNetworkCount = 0;
BOOLEAN                NmpIsConnectivityReportWorkerRunning = FALSE;
BOOLEAN                NmpNeedConnectivityReport = FALSE;
CLRTL_WORK_ITEM        NmpConnectivityReportWorkItem;


RESUTIL_PROPERTY_ITEM
NmpNetworkProperties[] =
    {
        {
            L"Id", NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Id)
        },
        {
            CLUSREG_NAME_NET_NAME, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Name)
        },
        {
            CLUSREG_NAME_NET_DESC, NULL, CLUSPROP_FORMAT_SZ,
            (DWORD_PTR) NmpNullString, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Description)
        },
        {
            CLUSREG_NAME_NET_ROLE, NULL, CLUSPROP_FORMAT_DWORD,
            ClusterNetworkRoleClientAccess,
            ClusterNetworkRoleNone,
            ClusterNetworkRoleInternalAndClient,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Role)
        },
        {
            CLUSREG_NAME_NET_PRIORITY, NULL, CLUSPROP_FORMAT_DWORD,
            0, 0, 0xFFFFFFFF,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Priority)
        },
        {
            CLUSREG_NAME_NET_TRANSPORT, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Transport)
        },
        {
            CLUSREG_NAME_NET_ADDRESS, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, Address)
        },
        {
            CLUSREG_NAME_NET_ADDRESS_MASK, NULL, CLUSPROP_FORMAT_SZ,
            0, 0, 0,
            0,
            FIELD_OFFSET(NM_NETWORK_INFO, AddressMask)
        },
        {
            0
        }
    };

/////////////////////////////////////////////////////////////////////////////
//
// Initialization & cleanup routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpInitializeNetworks(
    VOID
    )
/*++

Routine Description:

    Initializes network resources.

Arguments:

    None.

Return Value:

   A Win32 status value.

--*/

{
    DWORD                       status;
    OM_OBJECT_TYPE_INITIALIZE   networkTypeInitializer;


    ClRtlLogPrint(LOG_NOISE,"[NM] Initializing networks.\n");

    //
    // Create the network object type
    //
    ZeroMemory(&networkTypeInitializer, sizeof(OM_OBJECT_TYPE_INITIALIZE));
    networkTypeInitializer.ObjectSize = sizeof(NM_NETWORK);
    networkTypeInitializer.Signature = NM_NETWORK_SIG;
    networkTypeInitializer.Name = L"Network";
    networkTypeInitializer.DeleteObjectMethod = &NmpDestroyNetworkObject;

    status = OmCreateType(ObjectTypeNetwork, &networkTypeInitializer);

    if (status != ERROR_SUCCESS) {
        WCHAR  errorString[12];
        wsprintfW(&(errorString[0]), L"%u", status);
        CsLogEvent1(LOG_CRITICAL, CS_EVENT_ALLOCATION_FAILURE, errorString);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to create network object type, status %1!u!\n",
            status
            );
        return(status);
    }

    return(status);

}  // NmpInitializeNetworks


VOID
NmpCleanupNetworks(
    VOID
    )
/*++

Routine Description:

    Destroys all existing network resources.

Arguments:

    None.

Return Value:

   None.

--*/

{
    PNM_NETWORK  network;
    PLIST_ENTRY  entry;
    DWORD        status;


    ClRtlLogPrint(LOG_NOISE,"[NM] Network cleanup starting...\n");

    //
    // Now clean up all the network objects.
    //
    NmpAcquireLock();

    while (!IsListEmpty(&NmpNetworkList)) {

        entry = NmpNetworkList.Flink;

        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

        CL_ASSERT(NM_OM_INSERTED(network));

        NmpDeleteNetworkObject(network, FALSE);
    }

    NmpMulticastCleanup();

    NmpReleaseLock();

    ClRtlLogPrint(LOG_NOISE,"[NM] Network cleanup complete\n");

    return;

}  // NmpCleanupNetworks


/////////////////////////////////////////////////////////////////////////////
//
// Top-level routines called during network configuration
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNetwork(
    IN RPC_BINDING_HANDLE    JoinSponsorBinding,
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD            status;


    if (JoinSponsorBinding != NULL) {
        //
        // We are joining a cluster. Ask the sponsor to add the definition
        // to the cluster database. The sponsor will also prompt all active
        // nodes to instantiate a corresponding object. The object will be
        // instantiated locally later in the join process.
        //
        status = NmRpcCreateNetwork2(
                     JoinSponsorBinding,
                     NmpJoinSequence,
                     NmLocalNodeIdString,
                     NetworkInfo,
                     InterfaceInfo
                     );
    }
    else if (NmpState == NmStateOnlinePending) {
        HLOCALXSACTION   xaction;

        //
        // We are forming a cluster. Add the definitions to the database.
        // The corresponding object will be created later in
        // the form process.
        //

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpCreateNetworkDefinition(NetworkInfo, xaction);

        if (status == ERROR_SUCCESS) {
            status = NmpCreateInterfaceDefinition(InterfaceInfo, xaction);
        }

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is a PnP update.
        //
        NmpAcquireLock();

        status = NmpGlobalCreateNetwork(NetworkInfo, InterfaceInfo);

        NmpReleaseLock();
    }

    return(status);

}  // NmpCreateNetwork

DWORD
NmpSetNetworkName(
    IN PNM_NETWORK_INFO     NetworkInfo
    )
/*++

Notes:

    Must not be called with NM lock held.

--*/
{
    DWORD            status;


    if (NmpState == NmStateOnlinePending) {
        HLOCALXSACTION   xaction;

        //
        // We are forming a cluster. The local connectoid name has
        // precedence. Fix the cluster network name stored in the
        // cluster database.
        //

        //
        // Start a transaction - this must be done before acquiring the
        //                       NM lock.
        //
        xaction = DmBeginLocalUpdate();

        if (xaction == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to start a transaction, status %1!u!\n",
                status
                );
            return(status);
        }

        status = NmpSetNetworkNameDefinition(NetworkInfo, xaction);

        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }
    else {
        //
        // We are online. This is either a PnP update or we were called
        // back to indicate that a local connectoid name changed.
        // Issue a global update to set the cluster network name accordingly.
        //
        status = NmpGlobalSetNetworkName( NetworkInfo );
    }

    return(status);

}  // NmpSetNetworkName

/////////////////////////////////////////////////////////////////////////////
//
// Remote procedures called by joining nodes.
//
/////////////////////////////////////////////////////////////////////////////
error_status_t
s_NmRpcCreateNetwork(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,   OPTIONAL
    IN LPWSTR               JoinerNodeId,   OPTIONAL
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN PNM_INTERFACE_INFO   InterfaceInfo1
    )
{
    DWORD                 status;
    NM_INTERFACE_INFO2    interfaceInfo2;


    //
    // Translate and call the V2.0 procedure. The NetIndex isn't used in this call.
    //
    CopyMemory(&interfaceInfo2, InterfaceInfo1, sizeof(NM_INTERFACE_INFO));
    interfaceInfo2.AdapterId = NmpUnknownString;
    interfaceInfo2.NetIndex = NmInvalidInterfaceNetIndex;

    status = s_NmRpcCreateNetwork2(
                 IDL_handle,
                 JoinSequence,
                 JoinerNodeId,
                 NetworkInfo,
                 &interfaceInfo2
                 );

    return(status);

}  // s_NmRpcCreateNetwork


error_status_t
s_NmRpcCreateNetwork2(
    IN handle_t              IDL_handle,
    IN DWORD                 JoinSequence,   OPTIONAL
    IN LPWSTR                JoinerNodeId,   OPTIONAL
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Received request to create new network %1!ws! for "
        "joining node.\n",
        NetworkInfo->Id
        );

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] CreateNetwork call for joining node %1!ws! "
                        "failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] CreateNetwork call for joining node %1!ws! "
                    "failed because the node is not a member of the "
                    "cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {

            status = NmpGlobalCreateNetwork(NetworkInfo, InterfaceInfo);

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;
                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] CreateNetwork call for joining node %1!ws! "
                        "failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process CreateNetwork request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcCreateNetwork2


error_status_t
s_NmRpcSetNetworkName(
    IN handle_t             IDL_handle,
    IN DWORD                JoinSequence,   OPTIONAL
    IN LPWSTR               JoinerNodeId,   OPTIONAL
    IN PNM_NETWORK_INFO     NetworkInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    ClRtlLogPrint(LOG_NOISE,
        "[NMJOIN] Received request to set name of network %1!ws! from "
        "joining node %2!ws!.\n",
        NetworkInfo->Id,
        JoinerNodeId
        );

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE joinerNode = NULL;

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] SetNetworkName call for joining node "
                        "%1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] SetNetworkName call for joining node %1!ws! "
                    "failed because the node is not a member of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {

            status = NmpGlobalSetNetworkName( NetworkInfo );

            if (joinerNode != NULL) {
                //
                // Verify that the join is still in progress
                //
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId)
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpSponsorNodeId == NmLocalNodeId);
                    CL_ASSERT(NmpJoinTimer == 0);
                    CL_ASSERT(NmpJoinAbortPending == FALSE);

                    if (status == ERROR_SUCCESS) {
                        //
                        // Restart the join timer.
                        //
                        NmpJoinTimer = NM_JOIN_TIMEOUT;
                    }
                    else {
                        //
                        // Abort the join
                        //
                        NmpJoinAbort(status, joinerNode);
                    }
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] SetNetworkName call for joining node "
                        "%1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process SetNetworkName request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcSetNetworkName

error_status_t
s_NmRpcEnumNetworkDefinitions(
    IN  handle_t            IDL_handle,
    IN  DWORD               JoinSequence,   OPTIONAL
    IN  LPWSTR              JoinerNodeId,   OPTIONAL
    OUT PNM_NETWORK_ENUM *  NetworkEnum
    )
{
    DWORD    status = ERROR_SUCCESS;
    PNM_NODE joinerNode = NULL;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Supplying network information to joining node.\n"
            );

        if (lstrcmpW(JoinerNodeId, NmpInvalidJoinerIdString) != 0) {
            joinerNode = OmReferenceObjectById(
                             ObjectTypeNode,
                             JoinerNodeId
                             );

            if (joinerNode != NULL) {
                if ( (JoinSequence == NmpJoinSequence) &&
                     (NmpJoinerNodeId == joinerNode->NodeId) &&
                     (NmpSponsorNodeId == NmLocalNodeId) &&
                     !NmpJoinAbortPending
                   )
                {
                    CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                    CL_ASSERT(NmpJoinerUp == FALSE);
                    CL_ASSERT(NmpJoinTimer != 0);

                    //
                    // Suspend the join timer while we are working on
                    // behalf of the joiner. This precludes an abort
                    // from occuring as well.
                    //
                    NmpJoinTimer = 0;
                }
                else {
                    status = ERROR_CLUSTER_JOIN_ABORTED;
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NMJOIN] EnumNetworkDefinitions call for joining "
                        "node %1!ws! failed because the join was aborted.\n",
                        JoinerNodeId
                        );
                }
            }
            else {
                status = ERROR_CLUSTER_NODE_NOT_MEMBER;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] EnumNetworkDefinitions call for joining "
                    "node %1!ws! failed because the node is not a member "
                    "of the cluster.\n",
                    JoinerNodeId
                    );
            }
        }

        if (status == ERROR_SUCCESS) {
            status = NmpEnumNetworkObjects(NetworkEnum);

            if (joinerNode != NULL) {
                if (status == ERROR_SUCCESS) {
                    //
                    // Restart the join timer.
                    //
                    NmpJoinTimer = NM_JOIN_TIMEOUT;

                }
                else {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NMJOIN] Failed to enumerate network definitions, "
                        "status %1!u!.\n",
                        status
                        );

                    //
                    // Abort the join
                    //
                    NmpJoinAbort(status, joinerNode);
                }
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process EnumNetworkDefinitions "
            "request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcEnumNetworkDefinitions


error_status_t
s_NmRpcEnumNetworkAndInterfaceStates(
    IN  handle_t                    IDL_handle,
    IN  DWORD                       JoinSequence,
    IN  LPWSTR                      JoinerNodeId,
    OUT PNM_NETWORK_STATE_ENUM *    NetworkStateEnum,
    OUT PNM_INTERFACE_STATE_ENUM *  InterfaceStateEnum
    )
{
    DWORD     status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        PNM_NODE  joinerNode = OmReferenceObjectById(
                                   ObjectTypeNode,
                                   JoinerNodeId
                                   );

        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Supplying network and interface state information "
            "to joining node.\n"
            );

        if (joinerNode != NULL) {
            if ( (JoinSequence != NmpJoinSequence) ||
                 (NmpJoinerNodeId != joinerNode->NodeId) ||
                 (NmpSponsorNodeId != NmLocalNodeId) ||
                 NmpJoinAbortPending
               )
            {
                status = ERROR_CLUSTER_JOIN_ABORTED;
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NMJOIN] EnumNetworkAndInterfaceStates call for "
                    "joining node %1!ws! failed because the join was "
                    "aborted.\n",
                    JoinerNodeId
                    );
            }
            else {
                CL_ASSERT(joinerNode->State == ClusterNodeJoining);
                CL_ASSERT(NmpJoinerUp);
                CL_ASSERT(NmpJoinTimer == 0);
            }
        }
        else {
            status = ERROR_CLUSTER_NODE_NOT_MEMBER;
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NMJOIN] EnumNetworkAndInterfaceStates call for joining "
                "node %1!ws! failed because the node is not a member of "
                "the cluster.\n",
                JoinerNodeId
                );
        }

        if (status == ERROR_SUCCESS) {

            status = NmpEnumNetworkObjectStates(NetworkStateEnum);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NMJOIN] EnumNetworkAndInterfaceStates failed, "
                    "status %1!u!.\n",
                    status
                    );

                //
                // Abort the join
                //
                NmpJoinAbort(status, joinerNode);
            }

            status = NmpEnumInterfaceObjectStates(InterfaceStateEnum);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NMJOIN] EnumNetworkAndInterfaceStates failed, "
                    "status %1!u!.\n",
                    status
                    );

                //
                // Abort the join
                //
                NmpJoinAbort(status, joinerNode);

                NmpFreeNetworkStateEnum(*NetworkStateEnum);
                *NetworkStateEnum = NULL;
            }
        }

        if (joinerNode != NULL) {
            OmDereferenceObject(joinerNode);
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Not in valid state to process "
            "EnumNetworkAndInterfaceStates request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // s_NmRpcEnumNetworkAndInterfaceStates


error_status_t
s_NmRpcGetNetworkMulticastKey(
    IN  PRPC_ASYNC_STATE            AsyncState,
    IN  handle_t                    IDL_handle,
    IN  LPWSTR                      JoinerNodeId,
    IN  LPWSTR                      NetworkId,
    OUT PNM_NETWORK_MULTICASTKEY  * NetworkMulticastKey
    )
{
    DWORD              status = ERROR_SUCCESS;
    RPC_STATUS         tempStatus;


    *NetworkMulticastKey = NULL;

    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline))
    {
        PNM_NODE  joinerNode;


        ClRtlLogPrint(LOG_NOISE,
            "[NMJOIN] Supplying multicast key for network %1!ws! "
            "to joining node %2!ws!.\n",
            NetworkId,
            JoinerNodeId
            );


        joinerNode = OmReferenceObjectById(ObjectTypeNode,
                                           JoinerNodeId
                                           );

       if (joinerNode == NULL) {
           ClRtlLogPrint(LOG_UNUSUAL,
               "[NMJOIN] s_NmRpcGetNetworkMulticastKey call for joining "
               "node %1!ws! failed because the node is not a member of "
               "the cluster.\n",
               JoinerNodeId
               );
           status = ERROR_CLUSTER_NODE_NOT_MEMBER;
       }
       else
       {
           status = NmpGetNetworkMulticastKey(NetworkId,
                                              NetworkMulticastKey);
           if (status != ERROR_SUCCESS)
           {
               ClRtlLogPrint(LOG_UNUSUAL,
                   "[NMJOIN] NmpGetNetworkMulticastKey failed, "
                   "status %1!u!.\n",
                   status
                   );
           }

           OmDereferenceObject(joinerNode);

       }

       NmpLockedLeaveApi();
    }
    else
    {
       ClRtlLogPrint(LOG_UNUSUAL,
           "[NMJOIN] Not in valid state to process "
           "NmRpcGetNetworkMulticastKey request.\n"
           );
       status = ERROR_NODE_NOT_AVAILABLE;
    }

    NmpReleaseLock();

    tempStatus = RpcAsyncCompleteCall(AsyncState, &status);

    if(tempStatus != RPC_S_OK)
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] s_NmRpcGetNetworkMulticastKey, Error Completing "
            "Async RPC call, status %1!u!\n",
            tempStatus
            );

    return(status);


}   //  s_NmRpcGetNetworkMulticastKey


/////////////////////////////////////////////////////////////////////////////
//
// Routines used to make global configuration changes when the node
// is online.
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpGlobalCreateNetwork(
    IN PNM_NETWORK_INFO      NetworkInfo,
    IN PNM_INTERFACE_INFO2   InterfaceInfo
    )
/*++

Notes:

    Called with the NmpLock held.

--*/
{
    DWORD  status = ERROR_SUCCESS;
    DWORD  networkPropertiesSize;
    PVOID  networkProperties;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Issuing global update to create network %1!ws! and "
        "interface %2!ws!.\n",
        NetworkInfo->Id,
        InterfaceInfo->Id
        );

    //
    // Marshall the info structures into property lists.
    //
    status = NmpMarshallObjectInfo(
                 NmpNetworkProperties,
                 NetworkInfo,
                 &networkProperties,
                 &networkPropertiesSize
                 );

    if (status == ERROR_SUCCESS) {
        DWORD  interfacePropertiesSize;
        PVOID  interfaceProperties;

        status = NmpMarshallObjectInfo(
                     NmpInterfaceProperties,
                     InterfaceInfo,
                     &interfaceProperties,
                     &interfacePropertiesSize
                     );

        if (status == ERROR_SUCCESS) {
            NmpReleaseLock();

            //
            // Issue a global update to create the network
            //
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateCreateNetwork,
                         4,
                         networkPropertiesSize,
                         networkProperties,
                         sizeof(networkPropertiesSize),
                         &networkPropertiesSize,
                         interfacePropertiesSize,
                         interfaceProperties,
                         sizeof(interfacePropertiesSize),
                         &interfacePropertiesSize
                         );

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Global update to create network %1!ws! failed, "
                    "status %2!u!.\n",
                    NetworkInfo->Id,
                    status
                    );
            }

            NmpAcquireLock();

            MIDL_user_free(interfaceProperties);
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to marshall properties for new interface "
                "%1!ws!, status %2!u!\n",
                InterfaceInfo->Id,
                status
                );
        }

        MIDL_user_free(networkProperties);
    }
    else {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to marshall properties for new network %1!ws!, "
            "status %2!u!\n",
            NetworkInfo->Id,
            status
            );
    }

    return(status);

} // NmpGlobalCreateNetwork


DWORD
NmpGlobalSetNetworkName(
    IN PNM_NETWORK_INFO NetworkInfo
    )

/*++

Routine Description:

    Changes the name of a network defined for the cluster.

Arguments:

    NetworkInfo - A pointer to info about the network to be modified.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Must not be called with NM lock held.

--*/

{
    DWORD  status = ERROR_SUCCESS;

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Processing request to set name for network %1!ws! "
            "to '%2!ws!'.\n",
            NetworkInfo->Id,
            NetworkInfo->Name
            );

        //
        // Issue a global update
        //
        status = GumSendUpdateEx(
                     GumUpdateMembership,
                     NmUpdateSetNetworkName,
                     2,
                     NM_WCSLEN(NetworkInfo->Id),
                     NetworkInfo->Id,
                     NM_WCSLEN( NetworkInfo->Name ),
                     NetworkInfo->Name
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Global update to set name of network %1!ws! "
                "failed, status %2!u!.\n",
                NetworkInfo->Id,
                status
                );
        }
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] New name parameter supplied for network %1!ws! is invalid\n",
            NetworkInfo->Id
            );
    }

    return(status);

}  // NmpGlobalSetNetworkName


DWORD
NmpGlobalSetNetworkAndInterfaceStates(
    PNM_NETWORK             Network,
    CLUSTER_NETWORK_STATE   NewNetworkState
    )
/*++

Notes:

    Called with NmpLock held and the Network referenced.

--*/
{
    DWORD            status;
    DWORD            i;
    LPCWSTR          networkId = OmObjectId(Network);
    DWORD            entryCount = Network->ConnectivityVector->EntryCount;
    DWORD            vectorSize = sizeof(NM_STATE_ENTRY) * entryCount;
    PNM_STATE_ENTRY  ifStateVector;


    ifStateVector = LocalAlloc(LMEM_FIXED, vectorSize);

    if (ifStateVector != NULL ) {

        for (i=0; i< entryCount; i++) {
            ifStateVector[i] = Network->StateWorkVector[i].State;
        }

        // DavidDio 8/16/2001
        // Bug 456951: Check the NmpGumUpdateHandlerRegistered flag
        // rather than the NmState to determine whether a GUM
        // update or a local routine should be used to set the
        // state.
        if (NmpGumUpdateHandlerRegistered) {
            //
            // Issue a global state update for this network.
            //
            NmpReleaseLock();

            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateSetNetworkAndInterfaceStates,
                         4,
                         NM_WCSLEN(networkId),
                         networkId,
                         sizeof(NewNetworkState),
                         &NewNetworkState,
                         vectorSize,
                         ifStateVector,
                         sizeof(entryCount),
                         &entryCount
                         );

            NmpAcquireLock();
        }
        else {
            CL_ASSERT(NmpState == NmStateOnlinePending);
            //
            // We're still in the form process. Bypass GUM.
            //
            NmpSetNetworkAndInterfaceStates(
                Network,
                NewNetworkState,
                ifStateVector,
                entryCount
                );

            status = ERROR_SUCCESS;
        }

        LocalFree(ifStateVector);
    }
    else {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return(status);

} // NmpGlobalSetNetworkAndInterfaceStates


/////////////////////////////////////////////////////////////////////////////
//
// Routines called by other cluster service components
//
/////////////////////////////////////////////////////////////////////////////
CLUSTER_NETWORK_STATE
NmGetNetworkState(
    IN  PNM_NETWORK  Network
    )
/*++

Routine Description:



Arguments:



Return Value:


Notes:

   Because the caller must have a reference on the object and the
   call is so simple, there is no reason to put the call through the
   EnterApi/LeaveApi dance.

--*/
{
    CLUSTER_NETWORK_STATE  state;


    NmpAcquireLock();

    state = Network->State;

    NmpReleaseLock();

    return(state);

} // NmGetNetworkState


DWORD
NmSetNetworkName(
    IN PNM_NETWORK   Network,
    IN LPCWSTR       Name
    )
/*++

Routine Description:

    Changes the name of a network defined for the cluster.

Arguments:

    Network - A pointer to the object for the network to be modified.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    The network object must be referenced by the caller.

--*/

{
    DWORD  status = ERROR_SUCCESS;


    if (NmpEnterApi(NmStateOnline)) {
        LPCWSTR   networkId = OmObjectId(Network);
        DWORD     nameLength;


        //
        // Validate the name
        //
        try {
            nameLength = lstrlenW(Name);

            if (nameLength == 0) {
                status = ERROR_INVALID_PARAMETER;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = ERROR_INVALID_PARAMETER;
        }

        if (status == ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Processing request to set name for network %1!ws! "
                "to %2!ws!.\n",
                networkId,
                Name
                );

            //
            // Issue a global update
            //
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateSetNetworkName,
                         2,
                         NM_WCSLEN(networkId),
                         networkId,
                         (nameLength + 1) * sizeof(WCHAR),
                         Name
                         );

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Global update to set name of network %1!ws! "
                    "failed, status %2!u!.\n",
                    networkId,
                    status
                    );
            }
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] New name parameter supplied for network %1!ws! "
                "is invalid\n",
                networkId
                );
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetNetworkName request.\n"
            );
    }

    return(status);

}  // NmSetNetworkName


DWORD
NmSetNetworkPriorityOrder(
    IN DWORD     NetworkCount,
    IN LPWSTR *  NetworkIdList
    )
/*++

Routine Description:

    Sets the priority ordering of internal networks.

Arguments:

    NetworkCount - Contains the count of items in NetworkIdList.

    NetworkIdList - A pointer to an array of pointers to unicode strings.
                    Each string contains the ID of one internal network.
                    The array is sorted in priority order. The highest
                    priority network is listed first in the array.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD  status = ERROR_SUCCESS;


    if (NetworkCount == 0) {
        return(ERROR_INVALID_PARAMETER);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received request to set network priority order.\n"
        );

    if (NmpEnterApi(NmStateOnline)) {
        DWORD     i;
        DWORD     multiSzLength = 0;
        PVOID     multiSz = NULL;

        //
        // Marshall the network ID list into a MULTI_SZ.
        //
        for (i=0; i< NetworkCount; i++) {
            multiSzLength += NM_WCSLEN(NetworkIdList[i]);
        }

        multiSzLength += sizeof(UNICODE_NULL);

        multiSz = MIDL_user_allocate(multiSzLength);

        if (multiSz != NULL) {
            LPWSTR  tmp = multiSz;

            for (i=0; i< NetworkCount; i++) {
                lstrcpyW(tmp, NetworkIdList[i]);
                tmp += lstrlenW(NetworkIdList[i]) + 1;
            }

            *tmp = UNICODE_NULL;

            //
            // Issue a global update
            //
            status = GumSendUpdateEx(
                         GumUpdateMembership,
                         NmUpdateSetNetworkPriorityOrder,
                         1,
                         multiSzLength,
                         multiSz
                         );

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Global update to reprioritize networks failed, "
                    "status %1!u!.\n",
                    status
                    );
            }

            MIDL_user_free(multiSz);
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }

        NmpLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process a request to set the "
            "network priority order.\n"
            );
    }

    return(status);

}  // NmSetNetworkPriorityOrder


DWORD
NmEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    )
/*++

Routine Description:

    Returns a prioritized list of networks that are eligible to
    carry internal communication.

Arguments:

    NetworkCount - On output, contains the number of items in NetworkList.

    NetworkList - On output, points to an array of pointers to network
                  objects. The highest priority network is first in the
                  array. Each pointer in the array must be dereferenced
                  by the caller. The storage for the array must be
                  deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD  status;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {

        status = NmpEnumInternalNetworks(NetworkCount, NetworkList);

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process EnumInternalNetworks "
            "request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

}  // NmEnumInternalNetworks


DWORD
NmpEnumInternalNetworks(
    OUT LPDWORD         NetworkCount,
    OUT PNM_NETWORK *   NetworkList[]
    )
/*++

Routine Description:

    Returns a prioritized list of networks that are eligible to
    carry internal communication.

Arguments:

    NetworkCount - On output, contains the number of items in NetworkList.

    NetworkList - On output, points to an array of pointers to network
                  objects. The highest priority network is first in the
                  array. Each pointer in the array must be dereferenced
                  by the caller. The storage for the array must be
                  deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

Notes:

    Called with NM Lock held.

--*/
{
    DWORD  status = ERROR_SUCCESS;


    if (NmpInternalNetworkCount > 0) {
        PNM_NETWORK *  networkList = LocalAlloc(
                                         LMEM_FIXED,
                                         ( sizeof(PNM_NETWORK) *
                                           NmpInternalNetworkCount)
                                         );

        if (networkList != NULL) {
            PNM_NETWORK   network;
            PLIST_ENTRY   entry;
            DWORD         networkCount = 0;

            //
            // The internal network list is sorted in priority order.
            // The highest priority network is at the head of the list.
            //
            for (entry = NmpInternalNetworkList.Flink;
                 entry != &NmpInternalNetworkList;
                 entry = entry->Flink
                )
            {
                network = CONTAINING_RECORD(
                              entry,
                              NM_NETWORK,
                              InternalLinkage
                              );

                CL_ASSERT(NmpIsNetworkForInternalUse(network));
                OmReferenceObject(network);
                networkList[networkCount++] = network;
            }

            CL_ASSERT(networkCount == NmpInternalNetworkCount);
            *NetworkCount = networkCount;
            *NetworkList = networkList;
        }
        else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {
        *NetworkCount = 0;
        *NetworkList = NULL;
    }

    return(status);

}  // NmpEnumInternalNetworks


DWORD
NmEnumNetworkInterfaces(
    IN  PNM_NETWORK       Network,
    OUT LPDWORD           InterfaceCount,
    OUT PNM_INTERFACE *   InterfaceList[]
    )
/*++

Routine Description:

    Returns the list of interfaces associated with a specified network.

Arguments:

    Network - A pointer to the network object for which to enumerate
              interfaces.

    InterfaceCount - On output, contains the number of items in InterfaceList.

    InterfaceList - On output, points to an array of pointers to interface
                    objects. Each pointer in the array must be dereferenced
                    by the caller. The storage for the array must be
                    deallocated by the caller.

Return Value:

    ERROR_SUCCESS if the routine is successful.

    A Win32 error code othewise.

--*/
{
    DWORD  status = ERROR_SUCCESS;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        if (Network->InterfaceCount > 0) {
            PNM_INTERFACE *  interfaceList = LocalAlloc(
                                                 LMEM_FIXED,
                                                 ( sizeof(PNM_INTERFACE) *
                                                   Network->InterfaceCount)
                                                 );

            if (interfaceList != NULL) {
                PNM_INTERFACE  netInterface;
                PLIST_ENTRY    entry;
                DWORD          i;

                for (entry = Network->InterfaceList.Flink, i=0;
                     entry != &(Network->InterfaceList);
                     entry = entry->Flink, i++
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    OmReferenceObject(netInterface);
                    interfaceList[i] = netInterface;
                }

                *InterfaceCount = Network->InterfaceCount;
                *InterfaceList = interfaceList;
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else {
            *InterfaceCount = 0;
            *InterfaceList = NULL;
        }

        NmpLockedLeaveApi();
    }
    else {
        status = ERROR_NODE_NOT_AVAILABLE;
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Not in valid state to process EnumNetworkInterfaces "
            "request.\n"
            );
    }

    NmpReleaseLock();

    return(status);

} // NmEnumNetworkInterfaces


/////////////////////////////////////////////////////////////////////////////
//
// Handlers for global updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpUpdateCreateNetwork(
    IN BOOL     IsSourceNode,
    IN PVOID    NetworkPropertyList,
    IN LPDWORD  NetworkPropertyListSize,
    IN PVOID    InterfacePropertyList,
    IN LPDWORD  InterfacePropertyListSize
    )
/*++

Routine Description:

    Global update handler for creating a new network. The network
    definition is read from the cluster database, and a corresponding
    object is instantiated. The cluster transport is also updated if
    necessary.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine must not be called with NM lock held.

--*/
{
    DWORD                  status;
    NM_NETWORK_INFO        networkInfo;
    NM_INTERFACE_INFO2     interfaceInfo;
    PNM_NETWORK            network = NULL;
    PNM_INTERFACE          netInterface = NULL;
    HLOCALXSACTION         xaction = NULL;
    BOOLEAN                isInternalNetwork = FALSE;
    BOOLEAN                isLockAcquired = FALSE;
    CL_NODE_ID             joinerNodeId;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process CreateNetwork update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    //
    // Unmarshall the property lists.
    //
    ZeroMemory(&networkInfo, sizeof(networkInfo));
    ZeroMemory(&interfaceInfo, sizeof(interfaceInfo));

    status = ClRtlVerifyPropertyTable(
                 NmpNetworkProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 NetworkPropertyList,
                 *NetworkPropertyListSize,
                 (LPBYTE) &networkInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL,
            "[NM] Failed to unmarshall properties for new network, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    status = ClRtlVerifyPropertyTable(
                 NmpInterfaceProperties,
                 NULL,    // Reserved
                 FALSE,   // Don't allow unknowns
                 InterfacePropertyList,
                 *InterfacePropertyListSize,
                 (LPBYTE) &interfaceInfo
                 );

    if ( status != ERROR_SUCCESS ) {
        ClRtlLogPrint( LOG_CRITICAL,
            "[NM] Failed to unmarshall properties for new interface, "
            "status %1!u!.\n",
            status
            );
        goto error_exit;
    }


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to create network %1!ws! & interface %2!ws!.\n",
        networkInfo.Id,
        interfaceInfo.Id
        );

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    //
    // Fix up the network's priority, if needed.
    //
    if (networkInfo.Role & ClusterNetworkRoleInternalUse) {
        CL_ASSERT(networkInfo.Priority == 0xFFFFFFFF);

        //
        // The network's priority is one greater than that of the lowest
        // priority network already in the internal network list.
        //
        if (IsListEmpty(&NmpInternalNetworkList)) {
            networkInfo.Priority = 1;
        }
        else {
            PNM_NETWORK lastnet = CONTAINING_RECORD(
                                      NmpInternalNetworkList.Blink,
                                      NM_NETWORK,
                                      InternalLinkage
                                      );

            CL_ASSERT(lastnet->Priority != 0);
            CL_ASSERT(lastnet->Priority != 0xFFFFFFFF);

            networkInfo.Priority = lastnet->Priority + 1;
        }

        isInternalNetwork = TRUE;
    }

    //
    // Update the database.
    //
    status = NmpCreateNetworkDefinition(&networkInfo, xaction);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = NmpCreateInterfaceDefinition(&interfaceInfo, xaction);

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    joinerNodeId = NmpJoinerNodeId;

    NmpReleaseLock(); isLockAcquired = FALSE;

    network = NmpCreateNetworkObject(&networkInfo);

    if (network == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for network %1!ws!, "
            "status %2!u!.\n",
            networkInfo.Id,
            status
            );
        goto error_exit;
    }

    netInterface = NmpCreateInterfaceObject(
                       &interfaceInfo,
                       TRUE   // Do retry on failure
                       );

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmCreateNetwork) {
        NmpAcquireLock();
        NmpDeleteInterfaceObject(netInterface, FALSE); netInterface = NULL;
        NmpReleaseLock();
        SetLastError(999999);
    }
#endif

    NmpAcquireLock(); isLockAcquired = TRUE;

    if (netInterface == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for interface %1!ws!, "
            "status %2!u!.\n",
            interfaceInfo.Id,
            status
            );

        NmpDeleteNetworkObject(network, FALSE);
        OmDereferenceObject(network);

        goto error_exit;
    }

    //
    // If a node happens to be joining right now, flag the fact that
    // it is now out of synch with the cluster config.
    //
    if ( ( (joinerNodeId != ClusterInvalidNodeId) &&
           (netInterface->Node->NodeId != joinerNodeId)
         ) ||
         ( (NmpJoinerNodeId != ClusterInvalidNodeId) &&
           (netInterface->Node->NodeId != NmpJoinerNodeId)
         )
       )
    {
        NmpJoinerOutOfSynch = TRUE;
    }

    ClusterEvent(CLUSTER_EVENT_NETWORK_ADDED, network);
    ClusterEvent(CLUSTER_EVENT_NETINTERFACE_ADDED, netInterface);

    if (isInternalNetwork) {
        NmpIssueClusterPropertyChangeEvent();
    }

    OmDereferenceObject(netInterface);
    OmDereferenceObject(network);

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    ClNetFreeNetworkInfo(&networkInfo);
    ClNetFreeInterfaceInfo(&interfaceInfo);

    return(status);

} // NmpUpdateCreateNetwork


DWORD
NmpUpdateSetNetworkName(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN LPWSTR   NewNetworkName
    )
/*++

Routine Description:

    Global update handler for setting the name of a network.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    NetworkId - A pointer to a unicode string containing the ID of the
                  network to update.

    NewNetworkName - A pointer to a unicode string containing the new network name.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    This routine must not be called with NM lock held.

--*/
{
    DWORD             status;
    DWORD             i;
    PLIST_ENTRY       entry;
    HLOCALXSACTION    xaction = NULL;
    HDMKEY            networkKey;
    HDMKEY            netInterfaceKey;
    PNM_NETWORK       network = NULL;
    PNM_INTERFACE     netInterface;
    LPCWSTR           netInterfaceId;
    LPCWSTR           netInterfaceName;
    LPCWSTR           networkName;
    LPCWSTR           nodeName;
    LPWSTR            oldNetworkName = NULL;
    LPWSTR *          oldNameVector = NULL;
    LPWSTR *          newNameVector = NULL;
    BOOLEAN           isLockAcquired = FALSE;
    DWORD             interfaceCount;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetNetworkName update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to set the name for network %1!ws! "
        "to '%2!ws!'.\n",
        NetworkId,
        NewNetworkName
        );

    //
    // Find the network's object
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

    if (network == NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to find network %1!ws!.\n",
            NetworkId
            );
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    //
    // compare the names. If the same, return success
    //
    if ( ClRtlStrICmp( OmObjectName( network ), NewNetworkName ) == 0 ) {
        ClRtlLogPrint(LOG_NOISE, "[NM] Network name does not need changing.\n");

        status = ERROR_SUCCESS;
        goto error_exit;
    }

    networkName = OmObjectName(network);

    oldNetworkName = LocalAlloc(LMEM_FIXED, NM_WCSLEN(networkName));

    if (oldNetworkName == NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory for network %1!ws! name change!\n",
            NetworkId
            );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    wcscpy(oldNetworkName, networkName);

    //
    // Update the database.
    //
    // This processing can always be undone on error.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open database key for network %1!ws!, "
            "status %2!u!\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    status = DmLocalSetValue(
                 xaction,
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 (CONST BYTE *) NewNetworkName,
                 NM_WCSLEN(NewNetworkName)
                 );

    DmCloseKey(networkKey);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of name value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Update the names of all of the interfaces on this network
    //
    interfaceCount = network->InterfaceCount;

    oldNameVector = LocalAlloc(
                        LMEM_FIXED | LMEM_ZEROINIT,
                        interfaceCount * sizeof(LPWSTR)
                        );

    newNameVector = LocalAlloc(
                        LMEM_FIXED | LMEM_ZEROINIT,
                        interfaceCount * sizeof(LPWSTR)
                        );

    if ((oldNameVector == NULL) || (newNameVector == NULL)) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory for net interface name change.\n"
            );
        goto error_exit;
    }

    for (entry = network->InterfaceList.Flink, i = 0;
         entry != &(network->InterfaceList);
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);
        netInterfaceId = OmObjectId(netInterface);
        netInterfaceName = OmObjectName(netInterface);
        nodeName = OmObjectName(netInterface->Node);

        oldNameVector[i] = LocalAlloc(
                               LMEM_FIXED,
                               NM_WCSLEN(netInterfaceName)
                               );

        newNameVector[i] = ClNetMakeInterfaceName(
                               NULL,
                               (LPWSTR) nodeName,
                               NewNetworkName
                               );

        if ((oldNameVector[i] == NULL) || (newNameVector[i] == NULL)) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to allocate memory for net interface name "
                "change.\n"
                );
            goto error_exit;
        }

        wcscpy(oldNameVector[i], netInterfaceName);

        netInterfaceKey = DmOpenKey(
                              DmNetInterfacesKey,
                              netInterfaceId,
                              KEY_WRITE
                              );

        if (netInterfaceKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to open database key for net interface "
                "%1!ws!, status %2!u!\n",
                netInterfaceId,
                status
                );
            goto error_exit;
        }

        status = DmLocalSetValue(
                     xaction,
                     netInterfaceKey,
                     CLUSREG_NAME_NETIFACE_NAME,
                     REG_SZ,
                     (CONST BYTE *) newNameVector[i],
                     NM_WCSLEN(newNameVector[i])
                     );

        DmCloseKey(netInterfaceKey);

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of name value failed for net interface %1!ws!, "
                "status %2!u!.\n",
                netInterfaceId,
                status
                );
            goto error_exit;
        }
    }

    //
    // Update the in-memory objects.
    //
    // This processing may not be undoable on error.
    //

    //
    // Update name of the network
    //
    status = OmSetObjectName(network, NewNetworkName);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to change name for network %1!ws!, status %2!u!\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Update the names of all of the interfaces on the network.
    //
    for (entry = network->InterfaceList.Flink, i = 0;
         entry != &(network->InterfaceList);
         entry = entry->Flink, i++
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);
        netInterfaceId = OmObjectId(netInterface);

        status = OmSetObjectName(netInterface, newNameVector[i]);

        if (status != ERROR_SUCCESS) {
            //
            // Try to undo what has already been done. If we fail, we must
            // commit suicide to preserve consistency.
            //
            DWORD        j;
            PLIST_ENTRY  entry2;
            DWORD        undoStatus;

            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to change name for net interface %1!ws!, "
                "status %2!u!\n",
                netInterfaceId,
                status
                );

            //
            // Undo the update of the network name
            //
            undoStatus = OmSetObjectName(network, oldNetworkName);

            if (undoStatus != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to undo change of name for network %1!ws!, "
                    "status %2!u!\n",
                    NetworkId,
                    undoStatus
                    );
                CsInconsistencyHalt(undoStatus);
            }

            //
            // Undo update of network interface names
            //
            for (j = 0, entry2 = network->InterfaceList.Flink;
                 j < i;
                 j++, entry2 = entry2->Flink
                )
            {
                netInterface = CONTAINING_RECORD(
                                   entry2,
                                   NM_INTERFACE,
                                   NetworkLinkage
                                   );

                netInterfaceId = OmObjectId(netInterface);

                undoStatus = OmSetObjectName(netInterface, oldNameVector[i]);

                if (undoStatus != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NM] Failed to undo change of name for net "
                        "interface %1!ws!, status %2!u!\n",
                        netInterfaceId,
                        undoStatus
                        );
                    CsInconsistencyHalt(undoStatus);
                }
            }

            goto error_exit;
        }
    }

    //
    // Set the corresponding connectoid object name if necessary.
    //
    if (network->LocalInterface != NULL) {
        INetConnection *  connectoid;
        LPWSTR            connectoidName;
        DWORD             tempStatus;

        connectoid = ClRtlFindConnectoidByGuid(
                         network->LocalInterface->AdapterId
                         );

        if (connectoid != NULL) {
            connectoidName = ClRtlGetConnectoidName(connectoid);

            if (connectoidName != NULL) {
                if (lstrcmpW(connectoidName, NewNetworkName) != 0) {
                    tempStatus = ClRtlSetConnectoidName(
                                     connectoid,
                                     NewNetworkName
                                     );

                    if (tempStatus != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NM] Failed to set name of Network Connection "
                            "Object for interface on cluster network %1!ws! "
                            "(%2!ws!), status %3!u!\n",
                            oldNetworkName,
                            NetworkId,
                            tempStatus
                            );
                    } else {

                        // We expect to see a callback from the Network
                        // Connection Object with the name we just set.
                        // To avoid endless feedback loops, we need to
                        // ignore any other Network Connection Object
                        // callbacks until that one.
                        network->Flags |= NM_FLAG_NET_NAME_CHANGE_PENDING;

                        // We don't want to absolutely rely on the callback
                        // from the Network Connection Object, so we will
                        // set a timeout to clear the flag.
                        NmpStartNetworkNameChangePendingTimer(
                            network,
                            NM_NET_NAME_CHANGE_PENDING_TIMEOUT
                            );
                    }
                }
            }
            else {
                tempStatus = GetLastError();
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Failed to query name of Network Connection Object "
                    "for interface on cluster network %1!ws! (%2!ws!), "
                    "status %3!u!\n",
                    oldNetworkName,
                    NetworkId,
                    tempStatus
                    );
            }

            INetConnection_Release( connectoid );
        }
        else {
            tempStatus = GetLastError();
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Failed to find Network Connection Object for "
                "interface on cluster network %1!ws! (%2!ws!), "
                "status %3!u!\n",
                oldNetworkName,
                NetworkId,
                tempStatus
                );
        }
    }

    //
    // Issue property change events.
    //
    ClusterEvent(CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE, network);

    for (entry = network->InterfaceList.Flink;
         entry != &(network->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(entry, NM_INTERFACE, NetworkLinkage);

        ClusterEvent(
            CLUSTER_EVENT_NETINTERFACE_PROPERTY_CHANGE,
            netInterface
            );
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (network != NULL) {
        OmDereferenceObject(network);

        if (oldNetworkName != NULL) {
            LocalFree(oldNetworkName);
        }

        if (oldNameVector != NULL) {
            for (i=0; i < interfaceCount; i++) {
                if (oldNameVector[i] == NULL) {
                    break;
                }

                LocalFree(oldNameVector[i]);
            }

            LocalFree(oldNameVector);
        }

        if (newNameVector != NULL) {
            for (i=0; i < interfaceCount; i++) {
                if (newNameVector[i] == NULL) {
                    break;
                }

                LocalFree(newNameVector[i]);
            }

            LocalFree(newNameVector);
        }
    }

    return(status);

} // NmpUpdateSetNetworkName


DWORD
NmpUpdateSetNetworkPriorityOrder(
    IN BOOL      IsSourceNode,
    IN LPCWSTR   NetworkIdList
    )
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK       network;
    PLIST_ENTRY       entry;
    DWORD             matchCount=0;
    DWORD             networkCount=0;
    PNM_NETWORK *     networkList=NULL;
    DWORD             i;
    DWORD             multiSzLength;
    LPCWSTR           networkId;
    HLOCALXSACTION    xaction = NULL;
    BOOLEAN           isLockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetNetworkPriorityOrder "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to set network priority order.\n"
        );

    //
    // Unmarshall the MULTI_SZ
    //
    try {
        multiSzLength = ClRtlMultiSzLength(NetworkIdList);

        for (i=0; ; i++) {
            networkId = ClRtlMultiSzEnum(
                            NetworkIdList,
                            multiSzLength,
                            i
                            );

            if (networkId == NULL) {
                break;
            }

            networkCount++;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Hit exception while parsing network ID list for "
            "priority change\n"
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    if (networkCount == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    networkList = LocalAlloc(
                      LMEM_ZEROINIT| LMEM_FIXED,
                      networkCount * sizeof(PNM_NETWORK)
                      );

    if (networkList == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to start a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Cannot set network priority order because a node is "
            "joining the cluster.\n"
            );
        goto error_exit;
    }

    for (i=0; i<networkCount; i++) {
        networkId = ClRtlMultiSzEnum(
                        NetworkIdList,
                        multiSzLength,
                        i
                        );

        CL_ASSERT(networkId != NULL);

        networkList[i] = OmReferenceObjectById(
                             ObjectTypeNetwork,
                             networkId
                             );

        if (networkList[i] == NULL) {
            goto error_exit;
        }
    }

    //
    // Verify that all of the networks specified are internal, and
    // that all of the internal networks are specified.
    //
    if (networkCount != NmpInternalNetworkCount) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Supplied network count %1!u! doesn't match internal "
            "network count %2!u!\n",
            networkCount,
            NmpInternalNetworkCount
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    for (entry = NmpInternalNetworkList.Flink, matchCount = 0;
         entry != &NmpInternalNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, InternalLinkage);

        if (NmpIsNetworkForInternalUse(network)) {
            for (i=0; i<networkCount; i++) {
                if (network == networkList[i]) {
                    matchCount++;
                    break;
                }
            }

            if (i == networkCount) {
                //
                // This network is not in the list.
                //
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Internal use network %1!ws! is not in priority "
                    "list\n",
                    (LPWSTR) OmObjectId(network)
                    );
                status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
    }

    if (matchCount != networkCount) {
        //
        // Some of the specified networks are not internal use.
        //
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Some non-internal use networks are in priority list\n"
            );
        status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // The list is kosher. Set the priorities.
    //
    status = NmpSetNetworkPriorityOrder(networkCount, networkList, xaction);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (status == ERROR_SUCCESS) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    if (networkList != NULL) {
        for (i=0; i<networkCount; i++) {
            if (networkList[i] != NULL) {
                OmDereferenceObject(networkList[i]);
            }
        }

        LocalFree(networkList);
    }

    return(status);

}  // NmpUpdateSetNetworkPriorityOrder


DWORD
NmpSetNetworkPriorityOrder(
    IN DWORD           NetworkCount,
    IN PNM_NETWORK *   NetworkList,
    IN HLOCALXSACTION  Xaction
    )
/*++

Notes:

    Called with NM Lock held.

--*/
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK       network;
    DWORD             i;
    LPCWSTR           networkId;
    HDMKEY            networkKey;
    DWORD             priority;


    //
    // Update the database first.
    //
    for (i=0, priority = 1; i<NetworkCount; i++, priority++) {
        network = NetworkList[i];
        networkId = OmObjectId(network);

        CL_ASSERT(NmpIsNetworkForInternalUse(network));

        if (network->Priority != priority) {
            networkKey = DmOpenKey(DmNetworksKey, networkId, KEY_WRITE);

            if (networkKey == NULL) {
                status = GetLastError();
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Failed to open database key for network %1!ws!, "
                    "status %2!u!\n",
                    networkId,
                    status
                    );
                return(status);
            }

            status = DmLocalSetValue(
                         Xaction,
                         networkKey,
                         CLUSREG_NAME_NET_PRIORITY,
                         REG_DWORD,
                         (CONST BYTE *) &priority,
                         sizeof(priority)
                         );

            DmCloseKey(networkKey);

            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[NM] Set of priority value failed for network %1!ws!, "
                    "status %2!u!.\n",
                    networkId,
                    status
                    );
                return(status);
            }
        }
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmSetNetworkPriorityOrder) {
        status = 999999;
        return(status);
    }
#endif

    //
    // Update the in-memory representation
    //
    InitializeListHead(&NmpInternalNetworkList);

    for (i=0, priority = 1; i<NetworkCount; i++, priority++) {
        network = NetworkList[i];
        networkId = OmObjectId(network);

        InsertTailList(
            &NmpInternalNetworkList,
            &(network->InternalLinkage)
            );

        if (network->Priority != priority) {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Set priority for network %1!ws! to %2!u!.\n",
                networkId,
                priority
                );

            network->Priority = priority;

            //
            // If the local node is attached to this network, set its
            // priority in the cluster transport
            //
            if (NmpIsNetworkRegistered(network)) {
                status = ClusnetSetNetworkPriority(
                             NmClusnetHandle,
                             network->ShortId,
                             network->Priority
                             );

#ifdef CLUSTER_TESTPOINT
                TESTPT(TpFailNmSetNetworkPriorityOrder2) {
                    status = 999999;
                }
#endif
                if (status != ERROR_SUCCESS) {
                    //
                    // We can't easily abort here. We must either continue
                    // or commit suicide. We choose to continue and log an
                    // event.
                    //
                    WCHAR  string[16];

                    wsprintfW(&(string[0]), L"%u", status);

                    CsLogEvent2(
                        LOG_UNUSUAL,
                        NM_EVENT_SET_NETWORK_PRIORITY_FAILED,
                        OmObjectName(network),
                        string
                        );

                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NM] Cluster transport failed to set priority for "
                        "network %1!ws!, status %2!u!\n",
                        networkId,
                        status
                        );

                    status = ERROR_SUCCESS;
                }
            }
        }
    }

    CL_ASSERT(status == ERROR_SUCCESS);

    //
    // Issue a cluster property change event.
    //
    NmpIssueClusterPropertyChangeEvent();

    return(ERROR_SUCCESS);

} // NmpSetNetworkPriorityOrder


DWORD
NmpUpdateSetNetworkCommonProperties(
    IN BOOL     IsSourceNode,
    IN LPWSTR   NetworkId,
    IN UCHAR *  PropertyList,
    IN LPDWORD  PropertyListLength
    )
/*++

Routine Description:

    Global update handler for setting the common properties of a network.

Arguments:

    IsSourceNode  - Set to TRUE if this node is the source of the update.
                    Set to FALSE otherwise.

    NetworkId - A pointer to a unicode string containing the ID of the
                  network to update.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/
{
    DWORD                    status = ERROR_SUCCESS;
    NM_NETWORK_INFO          networkInfo;
    PNM_NETWORK              network = NULL;
    HLOCALXSACTION           xaction = NULL;
    HDMKEY                   networkKey = NULL;
    DWORD                    descSize = 0;
    LPWSTR                   descBuffer = NULL;
    BOOLEAN                  propertyChanged = FALSE;
    BOOLEAN                  isLockAcquired = FALSE;


    if (!NmpEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetNetworkCommonProperties "
            "update.\n"
            );
        return(ERROR_NODE_NOT_AVAILABLE);
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Received update to set common properties for network %1!ws!.\n",
        NetworkId
        );

    ZeroMemory(&networkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Find the network's object
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

    if (network == NULL) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Unable to find network %1!ws!.\n",
            NetworkId
            );
        status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        goto error_exit;
    }

    //
    // Open the network's database key
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open database key for network %1!ws!, "
            "status %2!u!\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Start a transaction - this must be done before acquiring the NM lock.
    //
    xaction = DmBeginLocalUpdate();

    if (xaction == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to begin a transaction, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    NmpAcquireLock(); isLockAcquired = TRUE;

    if (NmpJoinerNodeId != ClusterInvalidNodeId) {
        status = ERROR_CLUSTER_JOIN_IN_PROGRESS;
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Cannot set network common properties because a node is "
            "joining the cluster.\n"
            );
        goto error_exit;
    }

    //
    // Validate the property list and convert it to a network params struct.
    //
    status = NmpNetworkValidateCommonProperties(
                 network,
                 PropertyList,
                 *PropertyListLength,
                 &networkInfo
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Property list validation failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(network->Priority == networkInfo.Priority);
    CL_ASSERT(wcscmp(NetworkId, networkInfo.Id) == 0);
    CL_ASSERT(wcscmp(OmObjectName(network), networkInfo.Name) == 0);
    CL_ASSERT(wcscmp(network->Transport, networkInfo.Transport) == 0);
    CL_ASSERT(wcscmp(network->Address, networkInfo.Address) == 0);
    CL_ASSERT(wcscmp(network->AddressMask, networkInfo.AddressMask) == 0);

    //
    // Check if the network's description has changed.
    //
    if (wcscmp(network->Description, networkInfo.Description) != 0) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Setting description for network %1!ws! to %2!ws!.\n",
            NetworkId,
            networkInfo.Description
            );

        //
        // Allocate a buffer for the description string
        //
        descSize = NM_WCSLEN(networkInfo.Description);

        descBuffer = MIDL_user_allocate(descSize);

        if (descBuffer == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        RtlMoveMemory(descBuffer, networkInfo.Description, descSize);

        //
        // Update the database
        //
        status = DmLocalSetValue(
                     xaction,
                     networkKey,
                     CLUSREG_NAME_NET_DESC,
                     REG_SZ,
                     (CONST BYTE *) networkInfo.Description,
                     descSize
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Set of description value failed for network %1!ws!, "
                "status %2!u!.\n",
                NetworkId,
                status
                );
            goto error_exit;
        }

        //
        // Updating the network object is deferred until the transaction
        // commits.
        //

        propertyChanged = TRUE;
    }

#ifdef CLUSTER_TESTPOINT
    TESTPT(TpFailNmSetNetworkCommonProperties) {
        status = 999999;
        goto error_exit;
    }
#endif

    //
    // Check if the network's role has changed.
    //
    //
    // NOTE: This operation is not guaranteed to be reversible, so it must
    //       be the last thing we do in this routine. If it succeeds, the
    //       update must be committed.
    //
    if ( network->Role != ((CLUSTER_NETWORK_ROLE) networkInfo.Role) ) {
        status = NmpSetNetworkRole(
                     network,
                     networkInfo.Role,
                     xaction,
                     networkKey
                     );

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        propertyChanged = TRUE;
    }

    if (propertyChanged) {
        //
        // Commit the updates to the network object in memory
        //
        if (descBuffer != NULL) {
            MIDL_user_free(network->Description);
            network->Description = descBuffer;
            descBuffer = NULL;
        }

        //
        // Issue a network property change event.
        //
        if (propertyChanged && (status == ERROR_SUCCESS)) {
            ClusterEvent(CLUSTER_EVENT_NETWORK_PROPERTY_CHANGE, network);
        }
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (isLockAcquired) {
        NmpLockedLeaveApi();
        NmpReleaseLock();
    }
    else {
        NmpLeaveApi();
    }

    if (xaction != NULL) {
        //
        // Complete the transaction - this must be done after releasing
        //                            the NM lock.
        //
        if (propertyChanged && (status == ERROR_SUCCESS)) {
            DmCommitLocalUpdate(xaction);
        }
        else {
            DmAbortLocalUpdate(xaction);
        }
    }

    ClNetFreeNetworkInfo(&networkInfo);

    if (descBuffer != NULL) {
        MIDL_user_free(descBuffer);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    if (network != NULL) {
        OmDereferenceObject(network);
    }

    return(status);

} // NmpUpdateSetNetworkCommonProperties


DWORD
NmpUpdateSetNetworkAndInterfaceStates(
    IN BOOL                        IsSourceNode,
    IN LPWSTR                      NetworkId,
    IN CLUSTER_NETWORK_STATE *     NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN LPDWORD                     InterfaceStateVectorSize
    )
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK       network;


    NmpAcquireLock();

    if (NmpLockedEnterApi(NmStateOnline)) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Received update to set state for network %1!ws!.\n",
            NetworkId
            );

        //
        // Find the network's object
        //
        network = OmReferenceObjectById(ObjectTypeNetwork, NetworkId);

        if (network != NULL) {
            NmpSetNetworkAndInterfaceStates(
                network,
                *NewNetworkState,
                InterfaceStateVector,
                *InterfaceStateVectorSize
                );

            OmDereferenceObject(network);
        }
        else {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Unable to find network %1!ws!.\n",
                NetworkId
                );
            status = ERROR_CLUSTER_NETWORK_NOT_FOUND;
        }
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Not in valid state to process SetNetworkAndInterfaceStates "
            "update.\n"
            );
        status = ERROR_NODE_NOT_AVAILABLE;
    }

    NmpLockedLeaveApi();

    NmpReleaseLock();

    return(status);

} // NmpUpdateSetNetworkAndInterfaceStates


/////////////////////////////////////////////////////////////////////////////
//
// Helper routines for updates
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpSetNetworkRole(
    PNM_NETWORK            Network,
    CLUSTER_NETWORK_ROLE   NewRole,
    HLOCALXSACTION         Xaction,
    HDMKEY                 NetworkKey
    )
/*++

    Called with the NmpLock acquired.

    This operation is not guaranteed to be reversible, so this
    function is coded such that it either succeeds and makes the update
    or it fails and no update is made.

--*/
{
    DWORD                        status = ERROR_SUCCESS;
    CLUSTER_NETWORK_ROLE         oldRole = Network->Role;
    DWORD                        dwordNewRole = (DWORD) NewRole;
    LPCWSTR                      networkId = OmObjectId(Network);
    DWORD                        oldPriority = Network->Priority;
    DWORD                        newPriority = oldPriority;
    BOOLEAN                      internalNetworkListChanged = FALSE;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Changing role for network %1!ws! to %2!u!\n",
        networkId,
        NewRole
        );

    CL_ASSERT(NewRole != oldRole);
    CL_ASSERT(
        NmpValidateNetworkRoleChange(Network, NewRole) == ERROR_SUCCESS
        );

    //
    // First, make any registry updates since these can be
    // aborted by the caller.
    //

    //
    // Update the role property.
    //
    status = DmLocalSetValue(
                 Xaction,
                 NetworkKey,
                 CLUSREG_NAME_NET_ROLE,
                 REG_DWORD,
                 (CONST BYTE *) &dwordNewRole,
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of role value failed for network %1!ws!, "
            "status %2!u!.\n",
            networkId,
            status
            );
        return(status);
    }

    //
    // Update the priority property, if needed.
    //
    if (oldRole & ClusterNetworkRoleInternalUse) {
        if (!(NewRole & ClusterNetworkRoleInternalUse)) {
            //
            // This network is no longer used for internal communication.
            // Invalidate its priority value.
            //
            newPriority = 0xFFFFFFFF;
            internalNetworkListChanged = TRUE;
        }
    }
    else if (NewRole & ClusterNetworkRoleInternalUse) {
        //
        // This network is now used for internal communication.
        // The network's priority is one greater than that of the lowest
        // (numerically highest) priority network already in the list.
        //
        if (IsListEmpty(&NmpInternalNetworkList)) {
            newPriority = 1;
        }
        else {
            PNM_NETWORK network = CONTAINING_RECORD(
                                      NmpInternalNetworkList.Blink,
                                      NM_NETWORK,
                                      InternalLinkage
                                      );

            CL_ASSERT(network->Priority != 0);
            CL_ASSERT(network->Priority != 0xFFFFFFFF);

            newPriority = network->Priority + 1;
        }

        internalNetworkListChanged = TRUE;
    }

    if (newPriority != oldPriority) {
        status = DmLocalSetValue(
                     Xaction,
                     NetworkKey,
                     CLUSREG_NAME_NET_PRIORITY,
                     REG_DWORD,
                     (CONST BYTE *) &newPriority,
                     sizeof(newPriority)
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to set priority value for network %1!ws!, "
                "status %2!u!.\n",
                networkId,
                status
                );
            return(status);
        }
    }

    //
    // Update the network object. Some of the subsequent subroutine calls
    // depend on this.
    //
    Network->Role = NewRole;
    Network->Priority = newPriority;

    //
    // Do other housekeeping based on the change.
    //
    // Note that the housekeeping work is coded such that none of it needs
    // to be reversed if an error occurs.
    //
    if (NewRole == ClusterNetworkRoleNone) {
        PLIST_ENTRY              entry;
        PNM_INTERFACE            netInterface;

        //
        // Case 1: This network is no longer used for clustering.
        //
        if (NmpIsNetworkRegistered(Network)) {
            //
            // Delete the network from the cluster transport.
            // This will delete all of its interfaces as well.
            //
            NmpDeregisterNetwork(Network);

            ClRtlLogPrint(LOG_NOISE,
                "[NM] No longer hearbeating on network %1!ws!.\n",
                networkId
                );
        }

        //
        // Invalidate the connectivity data for all interfaces on
        // the network.
        //
        for ( entry = Network->InterfaceList.Flink;
              entry != &(Network->InterfaceList);
              entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NetworkLinkage
                               );

            NmpSetInterfaceConnectivityData(
                Network,
                netInterface->NetIndex,
                ClusterNetInterfaceUnavailable
                );
        }

        //
        // Clean up tracking data.
        //
        if (oldRole & ClusterNetworkRoleInternalUse) {
            RemoveEntryList(&(Network->InternalLinkage));
            CL_ASSERT(NmpInternalNetworkCount > 0);
            NmpInternalNetworkCount--;
        }

        if (oldRole & ClusterNetworkRoleClientAccess) {
            CL_ASSERT(NmpClientNetworkCount > 0);
            NmpClientNetworkCount--;
        }

        //
        // Use the NT5 state logic.
        //
        if (NmpLeaderNodeId == NmLocalNodeId) {
            //
            // Schedule an immediate state update.
            //
            NmpScheduleNetworkStateRecalc(Network);
        }

        //
        // Stop multicast configuration.
        //
        NmpStopMulticast(Network);

    }
    else if (oldRole == ClusterNetworkRoleNone) {
        //
        // Case 2: This network is now used for clustering.
        //
        if (Network->LocalInterface != NULL) {
            //
            // Register this network with the cluster transport.
            //
            // Note that this action will trigger a connectivity report,
            // which will in turn trigger a state update under the NT5 logic.
            //
            status = NmpRegisterNetwork(
                         Network,
                         TRUE  // Do retry on failure
                         );

            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Now heartbeating on network %1!ws!.\n",
                networkId
                );
        }
        else if (NmpLeaderNodeId == NmLocalNodeId) {
            //
            // Schedule a delayed state update in case none of the other
            // nodes attached to this network are up right now.
            //
            NmpStartNetworkStateRecalcTimer(
                Network,
                NM_NET_STATE_RECALC_TIMEOUT
                );
        }

        //
        // Update tracking data.
        //
        if (NewRole & ClusterNetworkRoleInternalUse) {
            InsertTailList(
                &NmpInternalNetworkList,
                &(Network->InternalLinkage)
                );
            NmpInternalNetworkCount++;
        }

        if (NewRole & ClusterNetworkRoleClientAccess) {
            NmpClientNetworkCount++;
        }

        //
        // Start multicast.
        //
        NmpStartMulticast(Network, NmStartMulticastDynamic);
    }
    else {
        //
        // Case 3: We are using the network in a different way now.
        //         Note that the network is already registered with
        //         the cluster transport and will remain so. As a result,
        //         there is no need to perform a state update.
        //

        //
        //         First, examine the former and new use of the
        //         network for internal communication, and make any
        //         necessary updates to the cluster transport.
        //
        if (oldRole & ClusterNetworkRoleInternalUse) {
            if (!(NewRole & ClusterNetworkRoleInternalUse)) {
                //
                // This network is no longer used for internal communication.
                // It is used for client access.
                //
                CL_ASSERT(NewRole & ClusterNetworkRoleClientAccess);

                if (NmpIsNetworkRegistered(Network)) {
                    //
                    // Restrict the network to heartbeats only.
                    //
                    status = ClusnetSetNetworkRestriction(
                                 NmClusnetHandle,
                                 Network->ShortId,
                                 TRUE,  // Network is restricted
                                 0
                                 );

                    if (status != ERROR_SUCCESS) {
                        ClRtlLogPrint(LOG_CRITICAL,
                            "[NM] Failed to restrict network %1!ws!, "
                            "status %2!u!.\n",
                            networkId,
                            status
                            );
                        goto error_exit;
                    }
                }

                //
                // Update tracking data
                //
                RemoveEntryList(&(Network->InternalLinkage));
                CL_ASSERT(NmpInternalNetworkCount > 0);
                NmpInternalNetworkCount--;
            }
        }
        else {
            //
            // The network is now used for internal communication.
            //
            CL_ASSERT(NewRole & ClusterNetworkRoleInternalUse);

            if (NmpIsNetworkRegistered(Network)) {
                //
                // Clear the restriction and set the priority.
                //
                status = ClusnetSetNetworkRestriction(
                             NmClusnetHandle,
                             Network->ShortId,
                             FALSE,      // Network is not restricted
                             newPriority
                             );

                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_CRITICAL,
                        "[NM] Failed to unrestrict network %1!ws!, "
                        "status %2!u!.\n",
                        networkId,
                        status
                        );
                    goto error_exit;
                }
            }

            //
            // Update the tracking data
            //
            InsertTailList(
                &NmpInternalNetworkList,
                &(Network->InternalLinkage)
                );
            NmpInternalNetworkCount++;
        }

        //
        // Now update the remaining tracking data based on former and
        // current use of the network for client access.
        //

        if (oldRole & ClusterNetworkRoleClientAccess) {
            if (!(NewRole & ClusterNetworkRoleClientAccess)) {
                //
                // This network is no longer used for client access.
                //
                CL_ASSERT(NmpClientNetworkCount > 0);
                NmpClientNetworkCount--;
            }
        }
        else {
            //
            // This network is now used for client access.
            //
            CL_ASSERT(NewRole & ClusterNetworkRoleClientAccess);
            NmpClientNetworkCount++;
        }
    }

    if (internalNetworkListChanged) {
        NmpIssueClusterPropertyChangeEvent();
    }

    return(ERROR_SUCCESS);

error_exit:

    //
    // Undo the updates to the network object.
    //
    Network->Role = oldRole;
    Network->Priority = oldPriority;

    return(status);

}   // NmpSetNetworkRole


VOID
NmpSetNetworkAndInterfaceStates(
    IN PNM_NETWORK                 Network,
    IN CLUSTER_NETWORK_STATE       NewNetworkState,
    IN PNM_STATE_ENTRY             InterfaceStateVector,
    IN DWORD                       VectorSize
    )
/*++

Notes:

    Called with NmpLock held.

    Because NM_STATE_ENTRY is an unsigned type, while
    CLUSTER_NETINTERFACE_STATE is a signed type, and
    ClusterNetInterfaceStateUnknown is defined to be -1, we cannot cast
    from NM_STATE_ENTRY to CLUSTER_NETINTERFACE_STATE and preserve the
    value of ClusterNetInterfaceStateUnknown.

--*/
{
    PLIST_ENTRY     entry;
    PNM_INTERFACE   netInterface;
    PNM_NODE        node;
    DWORD           logLevel, logCode;
    DWORD           ifNetIndex;
    LPCWSTR         netInterfaceId;
    LPCWSTR         nodeName;
    LPCWSTR         networkName = OmObjectName(Network);
    LPCWSTR         networkId = OmObjectId(Network);


    //
    // Examine each interface on this network to see if its state
    // has changed.
    //
    for ( entry = Network->InterfaceList.Flink;
          entry != &(Network->InterfaceList);
          entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NetworkLinkage
                           );

        ifNetIndex = netInterface->NetIndex;
        netInterfaceId = OmObjectId(netInterface);
        node = netInterface->Node;
        nodeName = OmObjectName(node);

        if ( (ifNetIndex < VectorSize) &&
             (InterfaceStateVector[ifNetIndex] !=
              (NM_STATE_ENTRY) netInterface->State
             )
           )
        {
            BOOLEAN          logEvent = FALSE;
            CLUSTER_EVENT    eventCode = 0;
            NM_STATE_ENTRY   newState = InterfaceStateVector[ifNetIndex];


            if (newState == (NM_STATE_ENTRY) ClusterNetInterfaceUnavailable) {
                //
                // Either the node has gone down or the network has been
                // disabled.
                //
                netInterface->State = ClusterNetInterfaceUnavailable;
                eventCode = CLUSTER_EVENT_NETINTERFACE_UNAVAILABLE;

                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Interface %1!ws! is unavailable (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if (newState == (NM_STATE_ENTRY) ClusterNetInterfaceUp) {
                netInterface->State = ClusterNetInterfaceUp;
                eventCode = CLUSTER_EVENT_NETINTERFACE_UP;
                logCode = NM_EVENT_CLUSTER_NETINTERFACE_UP;
                logLevel = LOG_NOISE;
                logEvent = TRUE;

                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Interface %1!ws! is up (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if ( newState ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceUnreachable
                    )
            {
                netInterface->State = ClusterNetInterfaceUnreachable;
                eventCode = CLUSTER_EVENT_NETINTERFACE_UNREACHABLE;
                logCode = NM_EVENT_CLUSTER_NETINTERFACE_UNREACHABLE;
                logLevel = LOG_UNUSUAL;
                logEvent = TRUE;

                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Interface %1!ws! is unreachable (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if (newState == (NM_STATE_ENTRY) ClusterNetInterfaceFailed) {
                netInterface->State = ClusterNetInterfaceFailed;
                eventCode = CLUSTER_EVENT_NETINTERFACE_FAILED;
                logCode = NM_EVENT_CLUSTER_NETINTERFACE_FAILED;
                logLevel = LOG_UNUSUAL;
                logEvent = TRUE;

                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Interface %1!ws! failed (node: %2!ws!, "
                    "network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else if ( newState ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
                    )
            {
                //
                // This case can happen if a create update races with a
                // state update. This will be the new interface. Just
                // ignore it. Another state update will arrive shortly.
                //
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] State for interface %1!ws! is unknown "
                    "(node: %2!ws!, network: %3!ws!).\n",
                    netInterfaceId,
                    nodeName,
                    networkName
                    );
            }
            else {
                ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] UpdateInterfaceState: Invalid state %1!u! "
                    "specified for interface %2!ws!\n",
                    newState,
                    netInterfaceId
                    );
                CL_ASSERT(FALSE);
            }

            if (eventCode != 0) {
                ClusterEvent(eventCode, netInterface);
            }

            if (logEvent && (NmpLeaderNodeId == NmLocalNodeId)) {
                CsLogEvent2(
                    logLevel,
                    logCode,
                    nodeName,
                    networkName
                    );
            }
        }
    }

    if (Network->State != NewNetworkState) {
        BOOLEAN          logEvent = FALSE;
        CLUSTER_EVENT    eventCode = 0;


        if (NewNetworkState == ClusterNetworkUnavailable) {
            Network->State = ClusterNetworkUnavailable;
            eventCode = CLUSTER_EVENT_NETWORK_UNAVAILABLE;
        }
        else if (NewNetworkState == ClusterNetworkUp) {
            Network->State = ClusterNetworkUp;
            eventCode = CLUSTER_EVENT_NETWORK_UP;
            logCode = NM_EVENT_CLUSTER_NETWORK_UP;
            logLevel = LOG_NOISE;
            logEvent = TRUE;

            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Network %1!ws! (%2!ws!) is up.\n",
                networkId,
                networkName
                );
        }
        else if (NewNetworkState == ClusterNetworkDown) {
            Network->State = ClusterNetworkDown;
            eventCode = CLUSTER_EVENT_NETWORK_DOWN;
            logCode = NM_EVENT_CLUSTER_NETWORK_DOWN;
            logLevel = LOG_UNUSUAL;
            logEvent = TRUE;

            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Network %1!ws! (%2!ws!) is down.\n",
                networkId,
                networkName
                );
        }
        else if (NewNetworkState == ClusterNetworkPartitioned) {
            Network->State = ClusterNetworkPartitioned;
            eventCode = CLUSTER_EVENT_NETWORK_PARTITIONED;
            logCode = NM_EVENT_CLUSTER_NETWORK_PARTITIONED;
            logLevel = LOG_UNUSUAL;
            logEvent = TRUE;

            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Network %1!ws! (%2!ws!) is partitioned.\n",
                networkId,
                networkName
                );
        }
        else {
            ClRtlLogPrint(LOG_UNUSUAL,
                "[NM] Invalid state %1!u! for network %2!ws!\n",
                Network->State,
                networkId
                );
            CL_ASSERT(FALSE);
        }

        if (eventCode != 0) {
            ClusterEvent(eventCode, Network);
        }

        if (logEvent && (NmpLeaderNodeId == NmLocalNodeId)) {
            CsLogEvent1(
                logLevel,
                logCode,
                networkName
                );
        }
    }

    return;

} // NmpSetNetworkAndInterfaceStates


/////////////////////////////////////////////////////////////////////////////
//
// Network state management routines
//
/////////////////////////////////////////////////////////////////////////////
VOID
NmpRecomputeNT5NetworkAndInterfaceStates(
    VOID
    )
{
    PNM_NETWORK   network;
    PLIST_ENTRY   entry;


    for (entry = NmpNetworkList.Flink;
         entry != &NmpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(
                      entry,
                      NM_NETWORK,
                      Linkage
                      );

        NmpStartNetworkStateRecalcTimer(
            network,
            NM_NET_STATE_RECALC_TIMEOUT_AFTER_REGROUP
            );
    }

    return;

} // NmpRecomputeNT5NetworkAndInterfaceStates


BOOLEAN
NmpComputeNetworkAndInterfaceStates(
    IN  PNM_NETWORK               Network,
    IN  BOOLEAN                   IsolateFailure,
    OUT CLUSTER_NETWORK_STATE *   NewNetworkState
    )
/*++

Routine Description:

    Computes the state of a network and all of its interfaces based on
    connectivity reports from each constituent interface. Attempts
    to distinguish between failures of individual interfaces and
    failure of an entire network.

Arguments:

    Network - A pointer to the network object to be processed.

    IsolateFailure - Triggers failure isolation analysis if set to true.

    NewNetworkState - A pointer to a variable that, upon return, contains
                      the new state of the network.

Return Value:

    TRUE if either the state of the network or the state of at least one
    of its constituent interfaces changed. FALSE otherwise.

Notes:

    Called with NmpLock held and the network object referenced.

--*/
{
    DWORD                       numIfUnavailable = 0;
    DWORD                       numIfFailed = 0;
    DWORD                       numIfUnreachable = 0;
    DWORD                       numIfUp = 0;
    DWORD                       numIfReachable = 0;
    PNM_CONNECTIVITY_MATRIX     matrix = Network->ConnectivityMatrix;
    PNM_CONNECTIVITY_MATRIX     matrixEntry;
    PNM_STATE_WORK_VECTOR       workVector = Network->StateWorkVector;
    DWORD                       entryCount =
                                    Network->ConnectivityVector->EntryCount;
    DWORD                       reporter, ifNetIndex;
    BOOLEAN                     stateChanged = FALSE;
    LPCWSTR                     networkId = OmObjectId(Network);
    LPCWSTR                     netInterfaceId;
    PLIST_ENTRY                 entry;
    PNM_INTERFACE               netInterface;
    NM_STATE_ENTRY              state;
    BOOLEAN                     selfDeclaredFailure = FALSE;
    DWORD                       interfaceFailureTimeout = 0;
    BOOLEAN                     abortComputation = FALSE;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Beginning phase 1 of state computation for network %1!ws!.\n",
        networkId
        );

    //
    // Phase 1 - Compute the state of each interface from the data
    //           in the connectivity matrix.
    //
    for ( entry = Network->InterfaceList.Flink;
          entry != &(Network->InterfaceList);
          entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NetworkLinkage
                           );

        netInterfaceId = OmObjectId(netInterface);
        ifNetIndex = netInterface->NetIndex;
        workVector[ifNetIndex].ReachableCount = 0;

        if (NmpIsNetworkEnabledForUse(Network)) {
            //
            // First, check what the interface thinks its own state is
            //
            matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                              matrix,
                              ifNetIndex,
                              ifNetIndex,
                              entryCount
                              );

            if ( *matrixEntry ==
                 (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
               )
            {
                //
                // This case should never happen.
                //
                // An existing interface cannot think its own state is
                // unknown. The reflexive entry is always initialized to
                // Unavailable whenever an interface is created.
                //
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] No data for interface %1!u! (%2!ws!) on network "
                    "%3!ws!\n",
                    ifNetIndex,
                    netInterfaceId,
                    networkId
                    );

                CL_ASSERT(
                    *matrixEntry !=
                     (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown
                     );

                state = ClusterNetInterfaceUnavailable;
                numIfUnavailable++;
            }
            else if ( *matrixEntry ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceUnavailable
                    )
            {
                if (NM_NODE_UP(netInterface->Node)) {
                    //
                    // The node is up, but its connectivity report has
                    // not been received yet. This case may happen while a
                    // node is joining. It can also happen if this node has
                    // just become the new leader.
                    //
                    // Abort the state computation.
                    //
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Data is not yet valid for interface %1!u! "
                        "(%2!ws!) on network %3!ws!.\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );

                    abortComputation = TRUE;
                    break;
                }
                else {
                    //
                    // The owning node is down or joining.
                    // The interface is in the unavailable state.
                    //
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Node is down for interface %1!u! (%2!ws!) on "
                        "network %3!ws!\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );

                    state = ClusterNetInterfaceUnavailable;
                    numIfUnavailable++;
                }
            }
            else if ( *matrixEntry ==
                      (NM_STATE_ENTRY) ClusterNetInterfaceFailed
                    )
            {
                //
                // The node declared its own interface as failed.
                // The interface is in the failed state.
                //
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Interface %1!u! (%2!ws!) has failed on network "
                    "%3!ws!\n",
                    ifNetIndex,
                    netInterfaceId,
                    networkId
                    );

                state = ClusterNetInterfaceFailed;
                numIfFailed++;
                if (netInterface->State == ClusterNetInterfaceUp) {
                    selfDeclaredFailure = TRUE;
                }
            }
            else {
                CL_ASSERT(
                    *matrixEntry == (NM_STATE_ENTRY) ClusterNetInterfaceUp
                    );
                //
                // The owning node thinks its interface is Up.
                //
                // If there are no other operational interfaces on the
                // network, then the interface is in the Up state.
                //
                // If there are other operational interfaces on the
                // network, but all of their reports are not yet valid,
                // then we defer calculating a new state for the interface.
                //
                // If there are other operational interfaces on the network,
                // and all of their reports are valid, then if at least one
                // of the operational interfaces reports that the interface
                // is unreachable, then then the interface is in the
                // Unreachable state. If all of the other operational
                // interfaces report that the interface is reachable, then
                // the interface is in the Up state.
                //
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Examining connectivity data for interface %1!u! "
                    "(%2!ws!) on network %3!ws!.\n",
                    ifNetIndex,
                    netInterfaceId,
                    networkId
                    );

                //
                // Assume that the interface is Up until proven otherwise.
                //
                state = ClusterNetInterfaceUp;

                //
                // Examine the reports from other interfaces -
                // i.e. scan the matrix column - to see if any node with
                // an operational interface reports this interface to
                // be unreachable.
                //
                for (reporter=0; reporter<entryCount; reporter++) {

                    if (reporter == ifNetIndex) {
                        continue;
                    }

                    //
                    // First, see if the reporting interface is operational
                    // by checking what the repoerter thinks of its own
                    // interface.
                    //
                    matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                                      matrix,
                                      reporter,
                                      reporter,
                                      entryCount
                                      );

                    if (*matrixEntry == ClusterNetInterfaceUp) {
                        PNM_CONNECTIVITY_MATRIX   matrixEntry2;

                        //
                        // Both the reporter and the reportee believe that
                        // their respective interfaces are operational.
                        // Check if they agree on the state of their
                        // connectivity before going any further.
                        // ClusNet guarantees that eventually they will
                        // agree.
                        //
                        matrixEntry = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                                          matrix,
                                          reporter,
                                          ifNetIndex,
                                          entryCount
                                          );

                        matrixEntry2 = NM_GET_CONNECTIVITY_MATRIX_ENTRY(
                                           matrix,
                                           ifNetIndex,
                                           reporter,
                                           entryCount
                                           );

                        if (*matrixEntry == *matrixEntry2) {
                            //
                            // The two interfaces agree on the state of
                            // their connectivity. Check what they agree on.
                            //
                            if (*matrixEntry == ClusterNetInterfaceUp) {
                                //
                                // The interface is reported to be up.
                                //
                                ClRtlLogPrint(LOG_NOISE,
                                    "[NM] Interface %1!u! reports interface "
                                    "%2!u! is up on network %3!ws!\n",
                                    reporter,
                                    ifNetIndex,
                                    networkId
                                    );

                                workVector[ifNetIndex].ReachableCount++;
                            }
                            else if ( *matrixEntry ==
                                      ClusterNetInterfaceUnreachable
                                    )
                            {
                                //
                                // The interface is reported to be
                                // unreachable.
                                //
                                ClRtlLogPrint(LOG_NOISE,
                                    "[NM] Interface %1!u! reports interface "
                                    "%2!u! is unreachable on network %3!ws!\n",
                                    reporter,
                                    ifNetIndex,
                                    networkId
                                    );

                                state = ClusterNetInterfaceUnreachable;

                                //
                                // If this interface is already in failed state do fault isolation immediately.
                                //
                                if(workVector[ifNetIndex].State == ClusterNetInterfaceFailed)
                                    IsolateFailure = TRUE;
                            }
                            else {
                                CL_ASSERT(
                                    *matrixEntry != ClusterNetInterfaceFailed
                                    );
                                //
                                // The interface report is not valid yet.
                                // Abort the computation.
                                //
                                ClRtlLogPrint(LOG_NOISE,
                                    "[NM] Report from interface %1!u! for "
                                    "interface %2!u! is not valid yet on "
                                    "network %3!ws!.\n",
                                    reporter,
                                    ifNetIndex,
                                    networkId
                                    );
                                abortComputation = TRUE;
                                break;
                            }
                        }
                        else {
                            //
                            // The two interfaces do not yet agree on
                            // their connectivity. Abort the computation.
                            //
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] Interface %1!u! and interface %2!u! do "
                                "not agree on their connectivity on network "
                                "%3!ws!\n",
                                reporter,
                                ifNetIndex,
                                networkId
                                );
                            abortComputation = TRUE;
                            break;
                        }
                    }
                    else {
                        //
                        // The reporter does not think its own interface is
                        // operational.
                        //
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] The report from interface %1!u! is not "
                            "valid on network %2!ws!.\n",
                            reporter,
                            networkId
                            );
                    }
                } // end of connectivity matrix scan loop

                if (abortComputation) {
                    //
                    // Abort Phase 1 computation.
                    //
                    break;
                }

                if (state == ClusterNetInterfaceUp) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Interface %1!u! (%2!ws!) is up on network "
                        "%3!ws!.\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );
                    numIfUp++;
                }
                else {
                    CL_ASSERT(state == ClusterNetInterfaceUnreachable);

                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Interface %1!u! (%2!ws!) is unreachable on "
                        "network %3!ws!\n",
                        ifNetIndex,
                        netInterfaceId,
                        networkId
                        );
                    numIfUnreachable++;
                }
            }
        }
        else {
            //
            // The network is disabled. It is in the Unavailable state.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Interface %1!u! (%2!ws!) is unavailable because "
                "network %3!ws! is disabled. \n",
                ifNetIndex,
                netInterfaceId,
                networkId
                );
            state = ClusterNetInterfaceUnavailable;
            numIfUnavailable++;
        }

        workVector[ifNetIndex].State = state;

        //
        // Keep track of how many interfaces on the network are
        // reachable by at least one peer.
        //
        if ( (state == ClusterNetInterfaceUp) ||
             (workVector[ifNetIndex].ReachableCount > 0)
           ) {
            numIfReachable++;
        }

        if (netInterface->State != state) {
            stateChanged = TRUE;
        }

    } // end of phase one interface loop

    if (!abortComputation && !IsolateFailure && selfDeclaredFailure) {

        interfaceFailureTimeout =
            NmpGetNetworkInterfaceFailureTimerValue(networkId);

        if (interfaceFailureTimeout > 0) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Delaying state computation for network %1!ws! "
                "for %2!u! ms to damp self-declared failure event.\n",
                networkId, interfaceFailureTimeout
                );

            NmpStartNetworkFailureIsolationTimer(
                Network,
                interfaceFailureTimeout
                );

            abortComputation = TRUE;
        }
    }

    if (abortComputation) {

        if (interfaceFailureTimeout == 0) {

            ClRtlLogPrint(LOG_NOISE,
                "[NM] Aborting state computation for network %1!ws! "
                " until connectivity data is valid.\n",
                networkId
                );
        }

        //
        // Undo any changes we made to the work vector.
        //
        for ( entry = Network->InterfaceList.Flink;
              entry != &(Network->InterfaceList);
              entry = entry->Flink
            )
        {
            netInterface = CONTAINING_RECORD(
                               entry,
                               NM_INTERFACE,
                               NetworkLinkage
                               );

            ifNetIndex = netInterface->NetIndex;
            workVector[ifNetIndex].State = (NM_STATE_ENTRY)
                                           netInterface->State;
        }

        *NewNetworkState = Network->State;

        return(FALSE);
    }

    //
    // Phase 2
    //
    // Try to determine the scope of any failures and recompute the
    // interface states. There are two cases in which we can isolate
    // failures.
    //
    //     Case 1: Three or more interfaces are operational. At least two
    //             interfaces can communicate with a peer. One or more
    //             interfaces cannot communicate with any peer.
    //             Those that cannot communicate at all have failed.
    //
    //     Case 2: Exactly two interfaces are operational and they cannot
    //             communicate with one another. If one interface can
    //             communicate with an external host while the other
    //             cannot communicate with any external host, then the one
    //             that cannot communicate has failed.
    //
    // In any other situation, we do nothing.
    //
    ClRtlLogPrint(LOG_NOISE,
        "[NM] Completed phase 1 of state computation for network "
        "%1!ws!.\n",
        networkId
        );

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Unavailable=%1!u!, Failed = %2!u!, Unreachable=%3!u!, "
        "Reachable=%4!u!, Up=%5!u! on network %6!ws! \n",
        numIfUnavailable,
        numIfFailed,
        numIfUnreachable,
        numIfReachable,
        numIfUp,
        networkId
        );

    if (numIfUnreachable > 0) {
        //
        // Some interfaces are unreachable.
        //
        if ( ((numIfUp + numIfUnreachable) >= 3)  && (numIfReachable >= 2) ) {
            if (IsolateFailure) {
                //
                // Case 1.
                //
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Trying to determine scope of connectivity failure "
                    "for >3 interfaces on network %1!ws!.\n",
                    networkId
                    );

                //
                // Any operational interface that cannot communicate with at
                // least one other operational interface has failed.
                //
                for ( entry = Network->InterfaceList.Flink;
                      entry != &(Network->InterfaceList);
                      entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    ifNetIndex = netInterface->NetIndex;
                    netInterfaceId = OmObjectId(netInterface);

                    if ( ( workVector[ifNetIndex].State ==
                           ClusterNetInterfaceUnreachable
                         )
                         &&
                         (workVector[ifNetIndex].ReachableCount == 0)
                       )
                    {
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Interface %1!u! (%2!ws!) has failed on "
                            "network %3!ws!\n",
                            ifNetIndex,
                            netInterfaceId,
                            networkId
                            );
                        workVector[ifNetIndex].State =
                            ClusterNetInterfaceFailed;
                        numIfUnreachable--;
                        numIfFailed++;
                    }
                }

                //
                // If any interface, whose state is still unreachable, can see
                // all other reachable interfaces, change its state to up.
                //
                for ( entry = Network->InterfaceList.Flink;
                      entry != &(Network->InterfaceList);
                      entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    ifNetIndex = netInterface->NetIndex;

                    if ( ( workVector[ifNetIndex].State ==
                           ClusterNetInterfaceUnreachable
                         )
                         &&
                         ( workVector[ifNetIndex].ReachableCount ==
                           (numIfUp + numIfUnreachable - 1)
                         )
                       )
                    {
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Interface %1!u! (%2!ws!) is up on network "
                            "%3!ws!\n",
                            ifNetIndex,
                            netInterfaceId,
                            networkId
                            );
                        workVector[ifNetIndex].State = ClusterNetInterfaceUp;
                        numIfUnreachable--;
                        numIfUp++;
                    }
                }

                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Connectivity failure scope determination complete "
                    "for network %1!ws!.\n",
                    networkId
                    );

            }
            else {
                //
                // Schedule a failure isolation calculation to run later.
                // Declaring a failure can affect cluster resources, so we
                // don't want to do it unless we are sure. Delaying for a
                // while reduces the risk of a false positive.
                //
                NmpStartNetworkFailureIsolationTimer(Network,
                    NM_NET_STATE_FAILURE_ISOLATION_TIMEOUT);

            }
        }
        else if ((numIfUnreachable == 2) && (numIfUp == 0)) {
            if (IsolateFailure) {
                //
                // Case 2.
                //
                PNM_INTERFACE  interface1 = NULL;
                BOOLEAN        interface1HasConnectivity;
                LPCWSTR        interfaceId1;
                PNM_INTERFACE  interface2 = NULL;
                BOOLEAN        interface2HasConnectivity;
                LPCWSTR        interfaceId2;
                DWORD          status;


                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Trying to determine scope of connectivity failure "
                    "for 2 interfaces on network %1!ws!.\n",
                    networkId
                    );

                for ( entry = Network->InterfaceList.Flink;
                      entry != &(Network->InterfaceList);
                      entry = entry->Flink
                    )
                {
                    netInterface = CONTAINING_RECORD(
                                       entry,
                                       NM_INTERFACE,
                                       NetworkLinkage
                                       );

                    ifNetIndex = netInterface->NetIndex;

                    if ( workVector[ifNetIndex].State ==
                         ClusterNetInterfaceUnreachable
                       )
                    {
                        if (interface1 == NULL) {
                            interface1 = netInterface;
                            interfaceId1 = OmObjectId(interface1);

                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] Unreachable interface 1 = %1!ws! on "
                                "network %2!ws!\n",
                                interfaceId1,
                                networkId
                                );
                        }
                        else {
                            interface2 = netInterface;
                            interfaceId2 = OmObjectId(interface2);

                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] Unreachable interface 2 = %1!ws! on "
                                "network %2!ws!\n",
                                interfaceId2,
                                networkId
                                );
                            break;
                        }
                    }
                }

                //
                // NmpTestInterfaceConnectivity releases and reacquires
                // the NmpLock. We must reference the interface objects
                // to ensure that they are still valid upon return from
                // that routine.
                //
                OmReferenceObject(interface1);
                OmReferenceObject(interface2);

                status = NmpTestInterfaceConnectivity(
                             interface1,
                             &interface1HasConnectivity,
                             interface2,
                             &interface2HasConnectivity
                             );

                if (status == ERROR_SUCCESS) {
                    if ( interface1HasConnectivity &&
                         !interface2HasConnectivity
                       )
                    {
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Interface %1!u! (%2!ws!) has Failed on "
                            "network %3!ws!\n",
                            interface2->NetIndex,
                            interfaceId2,
                            networkId
                            );

                        workVector[interface2->NetIndex].State =
                            ClusterNetInterfaceFailed;
                        numIfUnreachable--;
                        numIfFailed++;

                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Interface %1!u! (%2!ws!) is Up on network "
                            "%3!ws!\n",
                            interface1->NetIndex,
                            interfaceId1,
                            networkId
                            );

                        workVector[interface1->NetIndex].State =
                            ClusterNetInterfaceUp;
                        numIfUnreachable--;
                        numIfUp++;
                    }
                    else if ( !interface1HasConnectivity &&
                              interface2HasConnectivity
                            )
                    {
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Interface %1!u! (%2!ws!) has Failed on "
                            "network %3!ws!\n",
                            interface1->NetIndex,
                            interfaceId1,
                            networkId
                            );

                        workVector[interface1->NetIndex].State =
                            ClusterNetInterfaceFailed;
                        numIfUnreachable--;
                        numIfFailed++;

                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Interface %1!u! (%2!ws!) is Up on network "
                            "%3!ws!\n",
                            interface2->NetIndex,
                            interfaceId2,
                            networkId
                            );

                        workVector[interface2->NetIndex].State =
                            ClusterNetInterfaceUp;
                        numIfUnreachable--;
                        numIfUp++;
                    }
                    else {
                        ClRtlLogPrint(LOG_UNUSUAL,
                            "[NM] Network %1!ws! state is indeterminate, Scheduling"
                            " Failure Isolation poll\n",
                            networkId
                            );
                        NmpStartNetworkFailureIsolationTimer(Network,
                            NmpGetIsolationPollTimerValue());
                    }
                }
                else {
                    ClRtlLogPrint(LOG_UNUSUAL,
                    "[NM] Error in Interface Connectivity test for Network %1!ws!"
                    ", Scheduling Failure Isolation poll\n",
                    networkId
                    );
                    NmpStartNetworkFailureIsolationTimer(Network,
                        NmpGetIsolationPollTimerValue());
                }

                OmDereferenceObject(interface1);
                OmDereferenceObject(interface2);

                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Connectivity failure scope determination complete "
                    "for network %1!ws!.\n",
                    networkId
                    );
            }
            else {
                //
                // Schedule a failure isolation calculation to run later.
                // Declaring a failure can affect cluster resources, so we
                // don't want to do it unless we are sure. Delaying for a
                // while reduces the risk of a false positive.
                //
                NmpStartNetworkFailureIsolationTimer(Network,
                    NM_NET_STATE_FAILURE_ISOLATION_TIMEOUT);
            }
        }
        else {
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Cannot determine scope of connectivity failure on "
                "network %1!ws!.\n",
                networkId
                );
        }
    }
    else {
        //
        // No unreachable interfaces. Disable the failure isolation timer,
        // if it is running.
        //
        Network->FailureIsolationTimer = 0;
        Network->Flags &= ~NM_FLAG_NET_ISOLATE_FAILURE;
    }

    //
    // Phase 3 - Compute the new network state.
    //
    if (numIfUnavailable == Network->InterfaceCount) {
        //
        // All interfaces are unavailable.
        //
        *NewNetworkState = ClusterNetworkUnavailable;
    }
    else if (numIfUnreachable > 0) {
        //
        // Some operational interfaces have experienced
        // a loss of connectivity, but the fault could not be
        // isolated to them.
        //
        if (numIfReachable > 0) {
            CL_ASSERT(numIfReachable >= 2);
            //
            // At least two interfaces can still communicate
            // with each other, so the network is not completely down.
            //
            *NewNetworkState = ClusterNetworkPartitioned;
        }
        else {
            CL_ASSERT(numIfUp == 0);
            //
            // None of the operational interfaces can communicate
            //
            *NewNetworkState = ClusterNetworkDown;
        }
    }
    else if (numIfUp > 0) {
        //
        // Some interfaces are Up, all others are Failed or Unavailable
        //
        *NewNetworkState = ClusterNetworkUp;
    }
    else {
        //
        // Some interfaces are Unavailable, rest are Failed.
        //
        *NewNetworkState = ClusterNetworkDown;
    }

    if (Network->State != *NewNetworkState) {
        stateChanged = TRUE;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Network %1!ws! is now in state %2!u!\n",
            networkId,
            *NewNetworkState
            );
    }

    return(stateChanged);

} // NmpComputeNetworkAndInterfaceStates


DWORD
NmpGetIsolationPollTimerValue(
    VOID
    )
/*--
 * Reads the IsolationPollTimerValue Parameter from the registry if it's there
 * else returns default value.
 */
{

    DWORD value;
    DWORD type;
    DWORD len = sizeof(value);
    DWORD status;

	// Release NM Lock to avoid deadlock with DM lock
    NmpReleaseLock();

    status = DmQueryValue(
                DmClusterParametersKey,
                L"IsolationPollTimerValue",
                &type,
                (LPBYTE)&value,
                &len
                );

	NmpAcquireLock();
    if((status != ERROR_SUCCESS) || (type != REG_DWORD) ||
       (value < 10) || (value > 600000)) {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to read IsolationPollTimerValue or value out of range,"
            "status %1!u! using default %2!u! ms\n",
            status,
            NM_NET_STATE_FAILURE_ISOLATION_POLL
            );
        return NM_NET_STATE_FAILURE_ISOLATION_POLL;
    }
    else {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] IsolationPollTimerValue = %1!u!\n",
            value
            );
        return value;
    }
}

DWORD
NmpGetNetworkInterfaceFailureTimerValue(
    IN LPCWSTR   NetworkId
    )
/*++

Routine Description:

    Reads InterfaceFailure timer value from registry.
    If a value is located in the network key, it is used.
    Otherwise the cluster parameters key is checked.
    If no value is present, returns default.

Arguments:

    NetworkId - id of network whose timer value to determine

Return value:

    InterfaceFailure timer value

Notes:

    Called with NM lock held (from NmpComputeNetworkAndInterfaceStates).

    This routine queries the cluster database; hence, it drops the
    NM lock. Since NmpComputeNetworkAndInterfaceStates is always called
    in the context of the NmpWorkerThread, the Network is always
    referenced during execution of this routine.

--*/
{
    HDMKEY  networkKey, paramKey;
    DWORD   status;
    DWORD   type;
    DWORD   value = NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT;
    DWORD   len = sizeof(value);
    BOOLEAN found = FALSE;

    //
    // To avoid deadlock, the DM lock must be acquired before the
    // NM lock. Hence, release the NM lock prior to querying the
    // cluster database.
    //
    NmpReleaseLock();

    //
    // First check the network key
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_READ);
    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to open key for network %1!ws!, "
            "status %1!u!\n",
            NetworkId, status
            );
    }
    else {
        paramKey = DmOpenKey(networkKey, L"Parameters", KEY_READ);
        if (paramKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to find Parameters key "
                "for network %1!ws!, status %2!u!. Checking "
                "cluster parameters ...\n",
                NetworkId, status
                );
        }
        else {
            status = DmQueryValue(
                         paramKey,
                         L"InterfaceFailureTimeout",
                         &type,
                         (LPBYTE) &value,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Failed to read InterfaceFailureTimeout "
                    "for network %1!ws!, status %2!u!. Checking "
                    "cluster parameters ...\n",
                    NetworkId, status
                    );
            }
            else if (type != REG_DWORD) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Unexpected type (%1!u!) for network "
                    "%2!ws! InterfaceFailureTimeout, status %3!u!. "
                    "Checking cluster parameters ...\n",
                    type, NetworkId, status
                    );
            }
            else {
                found = TRUE;
            }

            DmCloseKey(paramKey);
        }

        DmCloseKey(networkKey);
    }


    //
    // If no value was found under the network key, check the
    // cluster parameters key.
    //
    if (!found) {

        paramKey = DmOpenKey(DmClusterParametersKey, L"Parameters", KEY_READ);
        if (paramKey == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_NOISE,
                "[NM] Failed to find cluster Parameters key, status %1!u!.\n",
                status
                );
        }
        else {
            status = DmQueryValue(
                         paramKey,
                         L"InterfaceFailureTimeout",
                         &type,
                         (LPBYTE) &value,
                         &len
                         );
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Failed to read cluster "
                    "InterfaceFailureTimeout, status %1!u!. "
                    "Using default value ...\n",
                    status
                    );
                value = NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT;
            }
            else if (type != REG_DWORD) {
                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Unexpected type (%1!u!) for cluster "
                    "InterfaceFailureTimeout, status %2!u!. "
                    "Using default value ...\n",
                    type, status
                    );
                value = NM_NET_STATE_INTERFACE_FAILURE_TIMEOUT;
            }

            DmCloseKey(paramKey);
        }
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Using InterfaceFailureTimeout of %1!u! ms "
        "for network %2!ws!.\n",
        value, NetworkId
        );

    //
    // Reacquire NM lock.
    //
    NmpAcquireLock();

    return(value);
}

VOID
NmpConnectivityReportWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker routine for deferred operations on network objects.
    Invoked to process items placed in the cluster delayed work queue.

Arguments:

    WorkItem - Ignored.

    Status - Ignored.

    BytesTransferred - Ignored.

    IoContext - Ignored.

Return Value:

    None.

Notes:

    This routine is run in an asynchronous worker thread.
    The NmpActiveThreadCount was incremented when the thread was
    scheduled.

--*/
{
    BOOLEAN       rescheduled = FALSE;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Connectivity report worker thread running.\n"
        );

    CL_ASSERT(NmpIsConnectivityReportWorkerRunning == TRUE);
    CL_ASSERT(NmpNeedConnectivityReport == TRUE);

    if (NmpState >= NmStateOnlinePending) {
        PNM_NETWORK  network;
        LPCWSTR      networkId;
        PLIST_ENTRY  entry;
        DWORD        status;

        while(TRUE) {

            NmpNeedConnectivityReport = FALSE;

            for (entry = NmpNetworkList.Flink;
                 entry != &NmpNetworkList;
                 entry = entry->Flink
                )
            {
                network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

                if (!NM_DELETE_PENDING(network)) {
                    networkId = OmObjectId(network);

                    //
                    // Deliver an InterfaceFailed event for the local interface
                    // if needed.
                    //
                    if (network->Flags & NM_FLAG_NET_REPORT_LOCAL_IF_FAILED) {
                        network->Flags &= ~NM_FLAG_NET_REPORT_LOCAL_IF_FAILED;

                        if (NmpIsNetworkRegistered(network)) {
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] Processing local interface failed "
                                " event for network %1!ws!.\n",
                                networkId
                                );

                            NmpProcessLocalInterfaceStateEvent(
                                network->LocalInterface,
                                ClusterNetInterfaceFailed
                                );
                        }
                    }

                    //
                    // Deliver an InterfaceUp event for the local interface
                    // if needed.
                    //
                    if (network->Flags & NM_FLAG_NET_REPORT_LOCAL_IF_UP) {
                        network->Flags &= ~NM_FLAG_NET_REPORT_LOCAL_IF_UP;

                        if (NmpIsNetworkRegistered(network)) {
                            ClRtlLogPrint(LOG_NOISE,
                                "[NM] Processing local interface up event "
                                "for network %1!ws!.\n",
                                networkId
                                );

                            NmpProcessLocalInterfaceStateEvent(
                                network->LocalInterface,
                                ClusterNetInterfaceUp
                                );
                        }
                    }

                    //
                    // Send a connectivity report if needed.
                    //
                    if (network->Flags & NM_FLAG_NET_REPORT_CONNECTIVITY) {
                        CL_NODE_ID   leaderNodeId = NmpLeaderNodeId;

                        network->Flags &= ~NM_FLAG_NET_REPORT_CONNECTIVITY;

                        //
                        // Report our connectivity to the leader.
                        //
                        status = NmpReportNetworkConnectivity(network);

                        if (status == ERROR_SUCCESS) {
                            //
                            // Clear the report retry count.
                            //
                            network->ConnectivityReportRetryCount = 0;
                        }
                        else {
                            if (NmpLeaderNodeId == leaderNodeId) {
                                if (network->ConnectivityReportRetryCount++ <
                                    NM_CONNECTIVITY_REPORT_RETRY_LIMIT
                                   )
                                {
                                    //
                                    // Try again in 500ms.
                                    //
                                    network->ConnectivityReportTimer = 500;
                                }
                                else {
                                    //
                                    // We have failed to communicate with
                                    // the leader for too long. Mutiny.
                                    //
                                    NmpAdviseNodeFailure(
                                        NmpIdArray[NmpLeaderNodeId],
                                        status
                                        );

                                    network->ConnectivityReportRetryCount = 0;
                                }
                            }
                            else {
                                //
                                // New leader, clear the retry count. We
                                // already scheduled another connectivity
                                // report in the node down handling.
                                //
                                network->ConnectivityReportRetryCount = 0;
                            }
                        }
                    }
                }
            } // end network for loop

            if (NmpNeedConnectivityReport == FALSE) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // More work to do. Resubmit the work item. We do this instead
            // of looping so we don't hog the worker thread. If
            // rescheduling fails, we will loop again in this thread.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] More connectivity reports to send. Rescheduling "
                "worker thread.\n"
                );

            status = NmpScheduleConnectivityReportWorker();

            if (status == ERROR_SUCCESS) {
                rescheduled = TRUE;
                break;
            }
        } // end while(TRUE)
    }

    if (!rescheduled) {
        NmpIsConnectivityReportWorkerRunning = FALSE;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Connectivity report worker thread finished.\n"
        );

    //
    // Decrement active thread reference count.
    //
    NmpLockedLeaveApi();

    NmpReleaseLock();

    return;

} // NmpConnectivityReportWorker


VOID
NmpNetworkWorker(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Worker routine for deferred operations on network objects.
    Invoked to process items placed in the cluster delayed work queue.

Arguments:

    WorkItem - A pointer to a work item structure that identifies the
               network for which to perform work.

    Status - Ignored.

    BytesTransferred - Ignored.

    IoContext - Ignored.

Return Value:

    None.

Notes:

    This routine is run in an asynchronous worker thread.
    The NmpActiveThreadCount was incremented when the thread was
    scheduled. The network object was also referenced.

--*/
{
    PNM_NETWORK   network = (PNM_NETWORK) WorkItem->Context;
    LPCWSTR       networkId = OmObjectId(network);
    BOOLEAN       rescheduled = FALSE;


    NmpAcquireLock();

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Worker thread processing network %1!ws!.\n",
        networkId
        );

    if ((NmpState >= NmStateOnlinePending) && !NM_DELETE_PENDING(network)) {
        DWORD     status;

        while(TRUE) {
            CL_ASSERT(network->Flags & NM_FLAG_NET_WORKER_RUNNING);

            //
            // Register the network if needed.
            //
            if (network->Flags & NM_FLAG_NET_NEED_TO_REGISTER) {
                network->Flags &= ~NM_FLAG_NET_NEED_TO_REGISTER;

                if (network->LocalInterface != NULL) {
                    (VOID) NmpRegisterNetwork(
                               network,
                               TRUE    // Do retry on failure
                               );
                }
            }

            //
            // Isolate a network failure if needed.
            //
            if (network->Flags & NM_FLAG_NET_ISOLATE_FAILURE) {

                BOOLEAN                stateChanged;
                CLUSTER_NETWORK_STATE  newNetworkState;

                network->Flags &= ~NM_FLAG_NET_ISOLATE_FAILURE;

                //
                // Turn off the state recalc timer and flag, since we will
                // do a recalc here.
                //
                network->Flags &= ~NM_FLAG_NET_RECALC_STATE;
                network->StateRecalcTimer = 0;

                CL_ASSERT(NmpLeaderNodeId == NmLocalNodeId);

                //
                // Recompute the interface and network states
                // with failure isolation enabled.
                //
                stateChanged = NmpComputeNetworkAndInterfaceStates(
                                    network,
                                    TRUE,
                                    &newNetworkState
                                    );

                if (stateChanged) {
                    //
                    // Broadcast the new network and interface states to
                    // all nodes
                    //
                    status = NmpGlobalSetNetworkAndInterfaceStates(
                                    network,
                                    newNetworkState
                                    );

                    if (status != ERROR_SUCCESS) {
                        //
                        // Try again in 1 second.
                        //
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] Global update failed for network %1!ws!, "
                            "status %2!u! - restarting failure isolation "
                            "timer.\n",
                            networkId,
                            status
                            );

                        network->FailureIsolationTimer = 1000;
                    }
                }
            }

            //
            // Recalculate the network and interface states if needed.
            //
            if (network->Flags & NM_FLAG_NET_RECALC_STATE) {
                BOOLEAN                stateChanged;
                CLUSTER_NETWORK_STATE  newNetworkState;

                network->Flags &= ~NM_FLAG_NET_RECALC_STATE;

                CL_ASSERT(NmpLeaderNodeId == NmLocalNodeId);

                //
                // Recompute the interface and network states
                // with failure isolation disabled. It will be
                // enabled if needed.
                //
                stateChanged = NmpComputeNetworkAndInterfaceStates(
                                    network,
                                    FALSE,
                                    &newNetworkState
                                    );

                if (stateChanged) {
                    //
                    // Broadcast the new network and interface states to
                    // all nodes
                    //
                    status = NmpGlobalSetNetworkAndInterfaceStates(
                                    network,
                                    newNetworkState
                                    );

                    if (status != ERROR_SUCCESS) {
                        //
                        // Try again in 500ms.
                        //
                        ClRtlLogPrint(LOG_NOISE,
                            "[NM] NetworkStateUpdateWorker failed issue "
                            "global update for network %1!ws!, status "
                            "%2!u! - restarting update timer.\n",
                            networkId,
                            status
                            );

                        network->StateRecalcTimer = 500;
                    }
                }
            }

            //
            // Refresh the network multicast configurtion if needed.
            //
            if (network->Flags & NM_FLAG_NET_REFRESH_MCAST) {
                network->Flags &= ~NM_FLAG_NET_REFRESH_MCAST;

                status = NmpRefreshMulticastConfiguration(network);
                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Failed to refresh multicast "
                        "configuration for network %1!ws!, "
                        "status %2!u!.\n",
                        networkId, status
                        );
                }

            }

            if (!(network->Flags & NM_NET_WORK_FLAGS)) {
                //
                // No more work to do - break out of loop.
                //
                break;
            }

            //
            // More work to do. Resubmit the work item. We do this instead
            // of looping so we don't hog the worker thread. If
            // rescheduling fails, we will loop again in this thread.
            //
            ClRtlLogPrint(LOG_NOISE,
                "[NM] More work to do for network %1!ws!. Rescheduling "
                "worker thread.\n",
                networkId
                );

            status = NmpScheduleNetworkWorker(network);

            if (status == ERROR_SUCCESS) {
                rescheduled = TRUE;
                break;
            }
        }
    }
    else {
        network->Flags &= ~NM_NET_WORK_FLAGS;
    }

    if (!rescheduled) {
        network->Flags &= ~NM_FLAG_NET_WORKER_RUNNING;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Worker thread finished processing network %1!ws!.\n",
        networkId
        );

    NmpLockedLeaveApi();

    NmpReleaseLock();

    OmDereferenceObject(network);

    return;

}  // NmpNetworkWorker


VOID
NmpNetworkTimerTick(
    IN DWORD  MsTickInterval
    )
/*++

Routine Description:

    Called by NM periodic timer to decrement network timers.

Arguments:

    MsTickInterval - The number of milliseconds that have passed since
                     the last timer tick.

Return Value:

    None.

Notes:

    Called with NmpLock held.

--*/
{
    if (NmpLockedEnterApi(NmStateOnlinePending)) {
        PLIST_ENTRY   entry;
        PNM_NETWORK   network;



        //
        // Walk thru the list of networks and decrement any running timers.
        //
        for ( entry = NmpNetworkList.Flink;
              entry != &NmpNetworkList;
              entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

            //
            // Network registration retry timer.
            //
            if (network->RegistrationRetryTimer != 0) {
                if (network->RegistrationRetryTimer > MsTickInterval) {
                    network->RegistrationRetryTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to register the network.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Registration retry timer expired for "
                        "network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleNetworkRegistration(network);
                }
            }

            //
            // Connectivity report generation timer.
            //
            if (network->ConnectivityReportTimer != 0) {
                if (network->ConnectivityReportTimer > MsTickInterval) {
                    network->ConnectivityReportTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to deliver a connectivity report.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Connectivity report timer expired for "
                        "network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleNetworkConnectivityReport(network);
                }
            }

            //
            // Network state recalculation timer.
            //
            if (network->StateRecalcTimer != 0) {
                if (network->StateRecalcTimer > MsTickInterval) {
                    network->StateRecalcTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to recalculate the state of the network.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] State recalculation timer expired for "
                        "network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleNetworkStateRecalc(network);
                }
            }

            //
            // Network multicast address renewal timer.
            //
            if (network->McastAddressRenewTimer != 0) {
                if (network->McastAddressRenewTimer > MsTickInterval) {
                    network->McastAddressRenewTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to renew the network's multicast address.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Multicast address lease renewal timer "
                        "expired for network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleMulticastAddressRenewal(network);
                }
            }

            //
            // Network multicast address release timer.
            //
            if (network->McastAddressReleaseRetryTimer != 0) {
                if (network->McastAddressReleaseRetryTimer > MsTickInterval) {
                    network->McastAddressReleaseRetryTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to release the network's multicast address.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Multicast address release timer "
                        "expired for network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleMulticastAddressRelease(network);
                }
            }

            //
            // Network multicast reconfiguration timer.
            //
            if (network->McastAddressReconfigureRetryTimer != 0) {
                if (network->McastAddressReconfigureRetryTimer > MsTickInterval) {
                    network->McastAddressReconfigureRetryTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to recreate the network's multicast configuration.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Multicast reconfiguration timer "
                        "expired for network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleMulticastReconfiguration(network);
                }
            }

            //
            // Network multicast configuration refresh timer.
            //
            if (network->McastAddressRefreshRetryTimer != 0) {
                if (network->McastAddressRefreshRetryTimer > MsTickInterval) {
                    network->McastAddressRefreshRetryTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to refresh the network's multicast configuration.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Multicast address refresh timer "
                        "expired for network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleMulticastRefresh(network);
                }
            }

            //
            // Network failure isolation timer.
            //
            if (network->FailureIsolationTimer != 0) {
                if (network->FailureIsolationTimer > MsTickInterval) {
                    network->FailureIsolationTimer -= MsTickInterval;
                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to perform failure isolation on the network.
                    //
                    DWORD     status = ERROR_SUCCESS;
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Failure isolation timer expired for network "
                        "%1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    if (!NmpIsNetworkWorkerRunning(network)) {
                        status = NmpScheduleNetworkWorker(network);
                    }

                    //
                    // Zero out the timer if we succeeded in scheduling a
                    // worker thread. If we failed, leave the timer value
                    // non-zero and we'll try again on the next tick.
                    //
                    if (status == ERROR_SUCCESS) {
                        network->FailureIsolationTimer = 0;
                        network->Flags |= NM_FLAG_NET_ISOLATE_FAILURE;
                    }
                }
            }

            //
            // Network name change pending timer.
            //
            if (network->NameChangePendingTimer != 0) {
                if (network->NameChangePendingTimer > MsTickInterval) {
                    network->NameChangePendingTimer -= MsTickInterval;
                }
                else {
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);

                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Name change pending timer expired for network "
                        "%1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    // Clear the name change pending flag
                    network->Flags &= ~NM_FLAG_NET_NAME_CHANGE_PENDING;
                }
            }


            //
            // Network multicast key regenerate timer.
            //
            if (network->McastKeyRegenerateTimer != 0) {
                if (network->McastKeyRegenerateTimer > MsTickInterval) {

                    // test
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);
                    // test

                    network->McastKeyRegenerateTimer -= MsTickInterval;

                }
                else {
                    //
                    // The timer has expired. Schedule a worker thread
                    // to regenerate the network's multicast key.
                    //
                    LPCWSTR   networkId = OmObjectId(network);
                    LPCWSTR   networkName = OmObjectName(network);


                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Multicast key regenerate timer "
                        "expired for network %1!ws! (%2!ws!).\n",
                        networkId,
                        networkName
                        );

                    NmpScheduleMulticastKeyRegeneration(network);
                }
            }
        }

        NmpLockedLeaveApi();
    }

    return;

} // NmpNetworkTimerTick


VOID
NmpStartNetworkConnectivityReportTimer(
    PNM_NETWORK Network
    )
/*++

Routine Description:

    Starts the connectivity report timer for a network. Connectivity
    reports are delayed in order to aggregate events when a failure
    occurs that affects multiple nodes.

Arguments:

    Network - A pointer to the network for which to start the timer.

Return Value

    None.

Notes:

    Called with NM lock held.

--*/
{
    //
    // Check if the timer is already running.
    //
    if (Network->ConnectivityReportTimer == 0) {
        //
        // Check how many nodes are attached to this network.
        //
        if (Network->InterfaceCount <= 2) {
            //
            // There is no point in waiting to aggregate reports when
            // only two nodes are connected to the network.
            // Just schedule a worker thread to deliver the report.
            //
            NmpScheduleNetworkConnectivityReport(Network);
        }
        else {
            //
            // More than two nodes are connected to this network.
            // Start the timer.
            //
            LPCWSTR   networkId = OmObjectId(Network);
            LPCWSTR   networkName = OmObjectName(Network);

            Network->ConnectivityReportTimer =
                NM_NET_CONNECTIVITY_REPORT_TIMEOUT;

                ClRtlLogPrint(LOG_NOISE,
                    "[NM] Started connectivity report timer (%1!u!ms) for "
                    "network %2!ws! (%3!ws!)\n",
                    Network->ConnectivityReportTimer,
                    networkId,
                    networkName
                    );
        }
    }

    return;

} // NmpStartNetworkConnectivityReportTimer


VOID
NmpStartNetworkStateRecalcTimer(
    PNM_NETWORK  Network,
    DWORD        Timeout
    )
{
    LPCWSTR   networkId = OmObjectId(Network);
    LPCWSTR   networkName = OmObjectName(Network);

    if (Network->StateRecalcTimer == 0) {
        Network->StateRecalcTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Started state recalculation timer (%1!u!ms) for "
            "network %2!ws! (%3!ws!)\n",
            Network->StateRecalcTimer,
            networkId,
            networkName
            );
    }

    return;

} // NmpStartNetworkStateRecalcTimer


VOID
NmpStartNetworkFailureIsolationTimer(
    PNM_NETWORK Network,
    DWORD Timeout
    )
{

    if (Network->FailureIsolationTimer == 0) {
        Network->FailureIsolationTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Started failure isolation timer (%1!u!ms) for "
            "network %2!ws! (%3!ws!)\n",
            Network->FailureIsolationTimer,
            OmObjectId(Network),
            OmObjectName(Network)
            );
    }

    return;

} // NmpStartNetworkFailureIsolationTimer


VOID
NmpStartNetworkRegistrationRetryTimer(
    PNM_NETWORK   Network
    )
{
    if (Network->RegistrationRetryTimer == 0) {
        if (Network->RegistrationRetryTimeout == 0) {
            Network->RegistrationRetryTimeout =
                NM_NET_MIN_REGISTRATION_RETRY_TIMEOUT;
        }
        else {
            //
            // Exponential backoff
            //
            Network->RegistrationRetryTimeout *= 2;

            if ( Network->RegistrationRetryTimeout >
                 NM_NET_MAX_REGISTRATION_RETRY_TIMEOUT
               )
            {
                Network->RegistrationRetryTimeout =
                    NM_NET_MAX_REGISTRATION_RETRY_TIMEOUT;
            }
        }

        Network->RegistrationRetryTimer = Network->RegistrationRetryTimeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Started registration retry timer (%1!u!ms) for "
            "network %2!ws! (%3!ws!)\n",
            Network->RegistrationRetryTimer,
            OmObjectId(Network),
            OmObjectName(Network)
            );
    }

    return;

} // NmpStartNetworkRegistrationRetryTimer


VOID
NmpStartNetworkNameChangePendingTimer(
    IN PNM_NETWORK Network,
    IN DWORD       Timeout
    )
{
    if (Network->NameChangePendingTimer != Timeout) {
        Network->NameChangePendingTimer = Timeout;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] %1!ws! name change pending timer (%2!u!ms) for "
            "network %3!ws! (%4!ws!)\n",
            ((Timeout != 0) ? L"Started" : L"Cleared"),
            Network->NameChangePendingTimer,
            OmObjectId(Network),
            OmObjectName(Network)
            );
    }

    return;

} // NmpStartNetworkNameChangePendingTimer

VOID
NmpScheduleNetworkConnectivityReport(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to deliver a connectivity report to
    the leader node for the specified network. Called when the
    ConnectivityReport timer expires for a network. Also called
    directly in some cases.

Arguments:

    A pointer to the network object for which to generate a report.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled.
    //
    if (!NmpIsConnectivityReportWorkerRunning) {
        status = NmpScheduleConnectivityReportWorker();
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // ConnectivityReport timer and set the work flag to generate
        // a report.
        //
        Network->ConnectivityReportTimer = 0;
        Network->Flags |= NM_FLAG_NET_REPORT_CONNECTIVITY;
        NmpNeedConnectivityReport = TRUE;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the
        // ConnecivityReport timer to expire on the next tick, so we
        // can try again.
        //
        Network->ConnectivityReportTimer = 1;
    }

    return;

}  // NmpScheduleNetworkConnectivityReport


VOID
NmpScheduleNetworkStateRecalc(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to recalculate the state of the
    specified network and all of the network's interface. A network
    state recalculation can be triggered by the arrival of a connectivity
    report, the joining/death of a node, or a network role change.

Arguments:

    A pointer to the network object whose state is to be recalculated.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkWorkerRunning(Network)) {
        status = NmpScheduleNetworkWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // StateRecalc timer and set the state recalculation work flag.
        //
        Network->StateRecalcTimer = 0;
        Network->Flags |= NM_FLAG_NET_RECALC_STATE;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the StateRecalc
        // timer to expire on the next tick, so we can try again.
        //
        Network->ConnectivityReportTimer = 1;
    }

    return;

} // NmpScheduleNetworkStateRecalc


VOID
NmpScheduleNetworkRegistration(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedules a worker thread to register a network with the cluster
    transport.

Arguments:

    A pointer to the network to register.

Return Value:

    None.

Notes:

    This routine is called with the NM lock held.

--*/
{
    DWORD     status = ERROR_SUCCESS;

    //
    // Check if a worker thread is already scheduled to
    // service this network.
    //
    if (!NmpIsNetworkWorkerRunning(Network)) {
        status = NmpScheduleNetworkWorker(Network);
    }

    if (status == ERROR_SUCCESS) {
        //
        // We succeeded in scheduling a worker thread. Stop the
        // retry timer and set the registration work flag.
        //
        Network->RegistrationRetryTimer = 0;
        Network->Flags |= NM_FLAG_NET_NEED_TO_REGISTER;
    }
    else {
        //
        // We failed to schedule a worker thread. Set the retry
        // timer to expire on the next tick, so we can try again.
        //
        Network->RegistrationRetryTimer = 1;
    }

    return;

} // NmpScheduleNetworkRegistration


DWORD
NmpScheduleConnectivityReportWorker(
    VOID
    )
/*++

Routine Description:

    Schedule a worker thread to deliver network connectivity reports.

Arguments:

    None.

Return Value:

    A Win32 status code.

Notes:

    Called with the NM global lock held.

--*/
{
    DWORD     status;


    ClRtlInitializeWorkItem(
        &NmpConnectivityReportWorkItem,
        NmpConnectivityReportWorker,
        NULL
        );

    status = ClRtlPostItemWorkQueue(
                 CsDelayedWorkQueue,
                 &NmpConnectivityReportWorkItem,
                 0,
                 0
                 );

    if (status == ERROR_SUCCESS) {
        NmpActiveThreadCount++;
        NmpIsConnectivityReportWorkerRunning = TRUE;

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Scheduled network connectivity report worker thread.\n"
            );
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to schedule network connectivity report worker "
            "thread, status %1!u!\n",
            status
            );
    }

    return(status);

}  // NmpScheduleConnectivityReportWorker


DWORD
NmpScheduleNetworkWorker(
    PNM_NETWORK   Network
    )
/*++

Routine Description:

    Schedule a worker thread to service this network

Arguments:

    Network - Pointer to the network for which to schedule a worker thread.

Return Value:

    A Win32 status code.

Notes:

    Called with the NM global lock held.

--*/
{
    DWORD     status;
    LPCWSTR   networkId = OmObjectId(Network);


    ClRtlInitializeWorkItem(
        &(Network->WorkItem),
        NmpNetworkWorker,
        (PVOID) Network
        );

    status = ClRtlPostItemWorkQueue(
                 CsDelayedWorkQueue,
                 &(Network->WorkItem),
                 0,
                 0
                 );

    if (status == ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Scheduled worker thread to service network %1!ws!.\n",
            networkId
            );

        NmpActiveThreadCount++;
        Network->Flags |= NM_FLAG_NET_WORKER_RUNNING;
        OmReferenceObject(Network);
    }
    else {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to schedule worker thread to service network "
            "%1!ws!, status %2!u!\n",
            networkId,
            status
            );
    }

    return(status);

} // NmpScheduleNetworkWorker


DWORD
NmpReportNetworkConnectivity(
    IN PNM_NETWORK    Network
    )
/*+

Notes:

    Called with the NmpLock held.
    May be called by asynchronous worker threads.

--*/
{
    DWORD                    status = ERROR_SUCCESS;
    LPCWSTR                  networkId = OmObjectId(Network);


    //
    // Since this routine is called by asynchronous worker threads,
    // check if the report is still valid.
    //
    if (NmpIsNetworkRegistered(Network)) {
        PNM_CONNECTIVITY_VECTOR  vector = Network->ConnectivityVector;
        PNM_INTERFACE            localInterface = Network->LocalInterface;

        //
        // Record the information in our local data structures.
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Updating local connectivity info for network %1!ws!.\n",
            networkId
            );

        NmpProcessInterfaceConnectivityReport(
            localInterface,
            vector
            );

        if (NmpLeaderNodeId != NmLocalNodeId) {
            //
            // Send the report to the leader via RPC.
            //
            PNM_CONNECTIVITY_VECTOR  tmpVector;
            DWORD                    vectorSize;
            LPCWSTR                  localInterfaceId =
                                         OmObjectId(localInterface);

            //
            // Allocate a temporary connectivity vector, since the
            // one in the network object can be resized during the
            // RPC call.
            //
            vectorSize = sizeof(NM_CONNECTIVITY_VECTOR) +
                         ((vector->EntryCount - 1) * sizeof(NM_STATE_ENTRY));

            tmpVector = LocalAlloc(LMEM_FIXED, vectorSize);

            if (tmpVector != NULL) {
                CopyMemory(tmpVector, vector, vectorSize);

                OmReferenceObject(Network);
                OmReferenceObject(localInterface);

                if (NM_NODE_UP(NmLocalNode) && (NmpState == NmStateOnline)) {
                    //
                    // This node is fully operational. Send the report
                    // directly to the leader.
                    //
                    PNM_NODE            node = NmpIdArray[NmpLeaderNodeId];
                    RPC_BINDING_HANDLE  rpcBinding = node->ReportRpcBinding;

                    OmReferenceObject(node);

                    status = NmpReportInterfaceConnectivity(
                                 rpcBinding,
                                 (LPWSTR) localInterfaceId,
                                 tmpVector,
                                 (LPWSTR) networkId
                                 );

                    OmDereferenceObject(node);
                }
                else if (CsJoinSponsorBinding != NULL) {
                    //
                    // This node is joining. Forward the report to the
                    // sponsor.
                    //
                    ClRtlLogPrint(LOG_UNUSUAL,
                        "[NM] Reporting connectivity to sponsor for "
                        "network %1!ws!.\n",
                        networkId
                        );

                    NmpReleaseLock();

                    status = NmRpcReportJoinerInterfaceConnectivity(
                                 CsJoinSponsorBinding,
                                 NmpJoinSequence,
                                 NmLocalNodeIdString,
                                 (LPWSTR) localInterfaceId,
                                 tmpVector
                                 );

                    NmpAcquireLock();
                }
                else {
                    //
                    // This node must be shutting down
                    //
                    CL_ASSERT(NmpState == NmStateOfflinePending);
                    status = ERROR_SUCCESS;
                }

                if (status != ERROR_SUCCESS) {
                    ClRtlLogPrint(LOG_NOISE,
                        "[NM] Failed to report connectivity for network "
                        "%1!ws!, status %2!u!.\n",
                        networkId,
                        status
                        );
                }

                LocalFree(tmpVector);

                OmDereferenceObject(localInterface);
                OmDereferenceObject(Network);
            }
            else {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    return(status);

} // NmpReportNetworkConnectivity


VOID
NmpUpdateNetworkConnectivityForDownNode(
    PNM_NODE  Node
    )
/*++

Notes:

   Called with NmpLock held.

--*/
{
    PLIST_ENTRY              entry;
    PNM_NETWORK              network;
    LPCWSTR                  networkId;
    PNM_INTERFACE            netInterface;
    DWORD                    entryCount;
    DWORD                    i;
    PNM_CONNECTIVITY_MATRIX  matrixEntry;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Cleaning up network and interface states for dead node %1!u!\n",
        Node->NodeId
        );

    //
    // Walk the dead node's interface list and clean up the network and
    // interface states.
    //
    for (entry = Node->InterfaceList.Flink;
         entry != &(Node->InterfaceList);
         entry = entry->Flink
        )
    {
        netInterface = CONTAINING_RECORD(
                           entry,
                           NM_INTERFACE,
                           NodeLinkage
                           );

        network = netInterface->Network;
        networkId = OmObjectId(network);

        ClRtlLogPrint(LOG_NOISE,
            "[NM] Cleaning up state of network %1!ws!\n",
            networkId
            );

        //
        // Invalidate the connectivity data for this interface.
        //
        NmpSetInterfaceConnectivityData(
            network,
            netInterface->NetIndex,
            ClusterNetInterfaceUnavailable
            );

        //
        // If the local node is attached to the network, schedule a
        // connectivity report to the new leader.
        //
        if (NmpIsNetworkRegistered(network)) {
            NmpScheduleNetworkConnectivityReport(network);
        }

        //
        // If the local node is the (possibly new) leader, schedule
        // a state update. We explicitly enable this timer here in case
        // there are no active nodes attached to the network.
        //
        if (NmpLeaderNodeId == NmLocalNodeId) {
            NmpStartNetworkStateRecalcTimer(
                network,
                NM_NET_STATE_RECALC_TIMEOUT_AFTER_REGROUP
                );
        }
    }

    return;

}  // NmpUpdateNetworkConnectivityForDownNode


VOID
NmpFreeNetworkStateEnum(
    PNM_NETWORK_STATE_ENUM   NetworkStateEnum
    )
{
    PNM_NETWORK_STATE_INFO  networkStateInfo;
    DWORD                   i;


    for (i=0; i<NetworkStateEnum->NetworkCount; i++) {
        networkStateInfo = &(NetworkStateEnum->NetworkList[i]);

        if (networkStateInfo->Id != NULL) {
            MIDL_user_free(networkStateInfo->Id);
        }
    }

    MIDL_user_free(NetworkStateEnum);

    return;

}  // NmpFreeNetworkStateEnum


/////////////////////////////////////////////////////////////////////////////
//
// Database management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNetworkDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    )
/*++

Routine Description:

    Creates a new network definition in the cluster database.

Arguments:

    NetworkInfo - A pointer to the information structure describing the
                  network to create.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    networkKey = NULL;
    DWORD     valueLength;
    DWORD     disposition;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating database entry for network %1!ws!\n",
        NetworkInfo->Id
        );

    networkKey = DmLocalCreateKey(
                     Xaction,
                     DmNetworksKey,
                     NetworkInfo->Id,
                     0,
                     KEY_WRITE,
                     NULL,
                     &disposition
                     );

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create network key, status %1!u!\n",
            status
            );
        return(status);
    }

    CL_ASSERT(disposition == REG_CREATED_NEW_KEY);

    //
    // Write the name value for this network
    //
    valueLength = (wcslen(NetworkInfo->Name) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Name,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network name value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the description value for this network
    //
    valueLength = (wcslen(NetworkInfo->Description) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_DESC,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Description,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network description value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the role value for this network
    //
    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_ROLE,
                 REG_DWORD,
                 (CONST BYTE *) &(NetworkInfo->Role),
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network role value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the priority value for this network
    //
    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_PRIORITY,
                 REG_DWORD,
                 (CONST BYTE *) &(NetworkInfo->Priority),
                 sizeof(DWORD)
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network priority value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the transport value for this network
    //
    valueLength = (wcslen(NetworkInfo->Transport) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_TRANSPORT,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Transport,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network transport value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the address value for this network
    //
    valueLength = (wcslen(NetworkInfo->Address) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Address,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network address value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the address mask value for this network
    //
    valueLength = (wcslen(NetworkInfo->AddressMask) + 1) * sizeof(WCHAR);

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS_MASK,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->AddressMask,
                 valueLength
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network address mask value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpCreateNetworkDefinition


DWORD
NmpSetNetworkNameDefinition(
    IN PNM_NETWORK_INFO     NetworkInfo,
    IN HLOCALXSACTION       Xaction
    )

/*++

Routine Description:

    Changes the network name in the local database

Arguments:

    NetworkInfo - A pointer to the information structure describing the
                  network to create.

Return Value:

    ERROR_SUCCESS if successful.
    A Win32 error code otherwise.

--*/
{
    DWORD     status;
    HDMKEY    networkKey = NULL;
    DWORD     disposition;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Changing network name database entry for network %1!ws!\n",
        NetworkInfo->Id
        );

    //
    // Open the network's key.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkInfo->Id, KEY_WRITE);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open network key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Write the name value for this network
    //

    status = DmLocalSetValue(
                 Xaction,
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 (CONST BYTE *) NetworkInfo->Name,
                 NM_WCSLEN( NetworkInfo->Name )
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Set of network name value failed, status %1!u!.\n",
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpSetNetworkNameDefinition


DWORD
NmpGetNetworkDefinition(
    IN  LPWSTR            NetworkId,
    OUT PNM_NETWORK_INFO  NetworkInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network from the cluster
    database and fills in a structure describing it.

Arguments:

    NetworkId   - A pointer to a unicode string containing the ID of the
                  network to query.

    NetworkInfo - A pointer to the network info structure to fill in.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD                    status;
    HDMKEY                   networkKey = NULL;
    DWORD                    valueLength, valueSize;
    DWORD                    i;


    ZeroMemory(NetworkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Open the network's key.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_READ);

    if (networkKey == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to open network key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Copy the ID value.
    //
    NetworkInfo->Id = MIDL_user_allocate(NM_WCSLEN(NetworkId));

    if (NetworkInfo->Id == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    wcscpy(NetworkInfo->Id, NetworkId);

    //
    // Read the network's name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 &(NetworkInfo->Name),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of name value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the description value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_DESC,
                 REG_SZ,
                 &(NetworkInfo->Description),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of description value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the role value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_ROLE,
                 &(NetworkInfo->Role),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of role value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the priority value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_PRIORITY,
                 &(NetworkInfo->Priority),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of priority value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS,
                 REG_SZ,
                 &(NetworkInfo->Address),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of address value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address mask.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS_MASK,
                 REG_SZ,
                 &(NetworkInfo->AddressMask),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of address mask value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the transport name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_TRANSPORT,
                 REG_SZ,
                 &(NetworkInfo->Transport),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Query of transport value failed for network %1!ws!, "
            "status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    CL_ASSERT(status == ERROR_SUCCESS);

error_exit:

    if (status != ERROR_SUCCESS) {
        ClNetFreeNetworkInfo(NetworkInfo);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpGetNetworkDefinition


DWORD
NmpEnumNetworkDefinitions(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    )
/*++

Routine Description:

    Reads information about defined cluster networks from the cluster
    database. and builds an enumeration structure to hold the information.

Arguments:

    NetworkEnum -  A pointer to the variable into which to place a pointer to
                   the allocated network enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD              status;
    PNM_NETWORK_ENUM   networkEnum = NULL;
    PNM_NETWORK_INFO   networkInfo;
    WCHAR              networkId[CS_NETWORK_ID_LENGTH + 1];
    DWORD              i;
    DWORD              valueLength;
    DWORD              numNetworks;
    DWORD              ignored;
    FILETIME           fileTime;


    *NetworkEnum = NULL;

    //
    // First count the number of networks.
    //
    status = DmQueryInfoKey(
                 DmNetworksKey,
                 &numNetworks,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to query Networks key information, status %1!u!\n",
            status
            );
        return(status);
    }

    if (numNetworks == 0) {
        valueLength = sizeof(NM_NETWORK_ENUM);

    }
    else {
        valueLength = sizeof(NM_NETWORK_ENUM) +
                      (sizeof(NM_NETWORK_INFO) * (numNetworks-1));
    }

    valueLength = sizeof(NM_NETWORK_ENUM) +
                  (sizeof(NM_NETWORK_INFO) * (numNetworks-1));

    networkEnum = MIDL_user_allocate(valueLength);

    if (networkEnum == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkEnum, valueLength);

    for (i=0; i < numNetworks; i++) {
        networkInfo = &(networkEnum->NetworkList[i]);

        valueLength = sizeof(networkId);

        status = DmEnumKey(
                     DmNetworksKey,
                     i,
                     &(networkId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to enumerate network key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetNetworkDefinition(networkId, networkInfo);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }


        networkEnum->NetworkCount++;
    }

    *NetworkEnum = networkEnum;

    return(ERROR_SUCCESS);


error_exit:

    if (networkEnum != NULL) {
        ClNetFreeNetworkEnum(networkEnum);
    }

    return(status);
}


/////////////////////////////////////////////////////////////////////////////
//
// Object management routines
//
/////////////////////////////////////////////////////////////////////////////
DWORD
NmpCreateNetworkObjects(
    IN  PNM_NETWORK_ENUM    NetworkEnum
    )
/*++

Routine Description:

    Processes a network information enumeration and creates network objects.

Arguments:

    NetworkEnum - A pointer to a network information enumeration structure.

Return Value:

    ERROR_SUCCESS if the routine completes successfully.
    A Win32 error code otherwise.

--*/
{
    DWORD             status = ERROR_SUCCESS;
    PNM_NETWORK_INFO  networkInfo;
    PNM_NETWORK       network;
    DWORD             i;


    for (i=0; i < NetworkEnum->NetworkCount; i++) {
        networkInfo = &(NetworkEnum->NetworkList[i]);

        network = NmpCreateNetworkObject(networkInfo);

        if (network == NULL) {
            status = GetLastError();
            ClRtlLogPrint(LOG_CRITICAL,
                "[NM] Failed to create network %1!ws!, status %2!u!.\n",
                networkInfo->Id,
                status
                );
            break;
        }
        else {
            OmDereferenceObject(network);
        }
    }

    return(status);

}  // NmpCreateNetworkObjects



PNM_NETWORK
NmpCreateNetworkObject(
    IN  PNM_NETWORK_INFO   NetworkInfo
    )
/*++

Routine Description:

    Instantiates a cluster network object.

Arguments:

    NetworkInfo - A pointer to a structure describing the network to create.

Return Value:

    A pointer to the new network object on success.
    NULL on failure.

--*/
{
    DWORD           status;
    PNM_NETWORK     network = NULL;
    BOOL            created = FALSE;
    DWORD           i;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] Creating object for network %1!ws! (%2!ws!).\n",
        NetworkInfo->Id,
        NetworkInfo->Name
        );

    //
    // Make sure that an object with the same name doesn't already exist.
    //
    network = OmReferenceObjectById(ObjectTypeNetwork, NetworkInfo->Id);

    if (network != NULL) {
        OmDereferenceObject(network);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] A network object named %1!ws! already exists. Cannot "
            "create a new network with the same name.\n",
            NetworkInfo->Id
            );
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
        return(NULL);
    }

    //
    // Ensure that the IP (sub)network is unique in the cluster. Two
    // nodes can race to create a new network in some cases.
    //
    // [RajDas] Need to check mask too for uniqueness.
    network = NmpReferenceNetworkByAddress(
                  NetworkInfo->Address,
                  NetworkInfo->AddressMask
                  );

    if (network != NULL) {
        OmDereferenceObject(network);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] A network object already exists for IP network %1!ws!. "
            "Cannot create a new network with the same address.\n",
            NetworkInfo->Address
            );
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
        return(NULL);
    }

    //
    // Create a network object.
    //
    network = OmCreateObject(
                 ObjectTypeNetwork,
                 NetworkInfo->Id,
                 NetworkInfo->Name,
                 &created
                 );

    if (network == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to create object for network %1!ws! (%2!ws!), status %3!u!\n",
            NetworkInfo->Id,
            NetworkInfo->Name,
            status
            );
        goto error_exit;
    }

    CL_ASSERT(created == TRUE);

    //
    // Initialize the network object
    //
    ZeroMemory(network, sizeof(NM_NETWORK));

    network->ShortId = InterlockedIncrement(&NmpNextNetworkShortId);
    network->State = ClusterNetworkUnavailable;
    network->Role = NetworkInfo->Role;
    network->Priority = NetworkInfo->Priority;
    network->Description = NetworkInfo->Description;
    NetworkInfo->Description = NULL;
    network->Transport = NetworkInfo->Transport;
    NetworkInfo->Transport = NULL;
    network->Address = NetworkInfo->Address;
    NetworkInfo->Address = NULL;
    network->AddressMask = NetworkInfo->AddressMask;
    NetworkInfo->AddressMask = NULL;


    InitializeListHead(&(network->InterfaceList));
    InitializeListHead(&(network->McastAddressReleaseList));

    //
    // Allocate an initial connectivity vector.
    // Note that we get one vector entry as part of
    // the NM_CONNECTIVITY_VECTOR structure.
    //
#define NM_INITIAL_VECTOR_SIZE   2

    network->ConnectivityVector = LocalAlloc(
                                      LMEM_FIXED,
                                      ( sizeof(NM_CONNECTIVITY_VECTOR) +
                                        ( ((NM_INITIAL_VECTOR_SIZE) - 1) *
                                          sizeof(NM_STATE_ENTRY)
                                        )
                                      ));

    if (network->ConnectivityVector == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory for connectivity vector\n"
            );
        goto error_exit;
    }

    network->ConnectivityVector->EntryCount = NM_INITIAL_VECTOR_SIZE;

    FillMemory(
        &(network->ConnectivityVector->Data[0]),
        NM_INITIAL_VECTOR_SIZE * sizeof(NM_STATE_ENTRY),
        (UCHAR) ClusterNetInterfaceStateUnknown
        );

    //
    // Allocate a state work vector
    //
    network->StateWorkVector = LocalAlloc(
                                   LMEM_FIXED,
                                   (NM_INITIAL_VECTOR_SIZE) *
                                     sizeof(NM_STATE_WORK_ENTRY)
                                   );

    if (network->StateWorkVector == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory for state work vector\n"
            );
        goto error_exit;
    }

    //
    // Initialize the state work vector
    //
    for (i=0; i<NM_INITIAL_VECTOR_SIZE; i++) {
        network->StateWorkVector[i].State =
            (NM_STATE_ENTRY) ClusterNetInterfaceStateUnknown;
    }

    //
    // Put a reference on the object for the caller.
    //
    OmReferenceObject(network);

    NmpAcquireLock();

    //
    // Allocate the corresponding connectivity matrix
    //
    network->ConnectivityMatrix =
        LocalAlloc(
            LMEM_FIXED,
            NM_SIZEOF_CONNECTIVITY_MATRIX(NM_INITIAL_VECTOR_SIZE)
            );

    if (network->ConnectivityMatrix == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        NmpReleaseLock();
        OmDereferenceObject(network);
        ClRtlLogPrint(LOG_CRITICAL,
            "[NM] Failed to allocate memory for connectivity matrix\n"
            );
        goto error_exit;
    }

    //
    // Initialize the matrix
    //
    FillMemory(
        network->ConnectivityMatrix,
        NM_SIZEOF_CONNECTIVITY_MATRIX(NM_INITIAL_VECTOR_SIZE),
        (UCHAR) ClusterNetInterfaceStateUnknown
        );

    //
    // Make the network object available.
    //
    InsertTailList(&NmpNetworkList, &(network->Linkage));
    NmpNetworkCount++;

    if (NmpIsNetworkForInternalUse(network)) {
        NmpInsertInternalNetwork(network);
        NmpInternalNetworkCount++;
    }

    if (NmpIsNetworkForClientAccess(network)) {
        NmpClientNetworkCount++;
    }

    network->Flags |= NM_FLAG_OM_INSERTED;
    OmInsertObject(network);

    NmpReleaseLock();

    return(network);

error_exit:

    if (network != NULL) {
        NmpAcquireLock();
        NmpDeleteNetworkObject(network, FALSE);
        NmpReleaseLock();
    }

    SetLastError(status);

    return(NULL);

}  // NmpCreateNetworkObject



DWORD
NmpGetNetworkObjectInfo(
    IN  PNM_NETWORK        Network,
    OUT PNM_NETWORK_INFO   NetworkInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network from the
    network object and fills in a structure describing it.

Arguments:

    Network     - A pointer to the network object to query.

    NetworkInfo - A pointer to the structure to fill in with network
                    information.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with NmpLock held.

--*/

{
    DWORD      status = ERROR_NOT_ENOUGH_MEMORY;
    LPWSTR     tmpString = NULL;
    LPWSTR     networkId = (LPWSTR) OmObjectId(Network);
    LPWSTR     networkName = (LPWSTR) OmObjectName(Network);


    ZeroMemory(NetworkInfo, sizeof(NM_NETWORK_INFO));

    tmpString = MIDL_user_allocate(NM_WCSLEN(networkId));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, networkId);
    NetworkInfo->Id = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(networkName));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, networkName);
    NetworkInfo->Name = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->Description));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->Description);
    NetworkInfo->Description = tmpString;

    NetworkInfo->Role = Network->Role;
    NetworkInfo->Priority = Network->Priority;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->Transport));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->Transport);
    NetworkInfo->Transport = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->Address));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->Address);
    NetworkInfo->Address = tmpString;

    tmpString = MIDL_user_allocate(NM_WCSLEN(Network->AddressMask));
    if (tmpString == NULL) {
        goto error_exit;
    }
    wcscpy(tmpString, Network->AddressMask);
    NetworkInfo->AddressMask = tmpString;

    return(ERROR_SUCCESS);

error_exit:

    ClNetFreeNetworkInfo(NetworkInfo);

    return(status);

}  // NmpGetNetworkObjectInfo


VOID
NmpDeleteNetworkObject(
    IN PNM_NETWORK  Network,
    IN BOOLEAN      IssueEvent
    )
/*++

Routine Description:

    Deletes a cluster network object.

Arguments:

    Network - A pointer to the network object to delete.

    IssueEvent - TRUE if a NETWORK_DELETED event should be issued when this
                 object is created. FALSE otherwise.

Return Value:

    None.

Notes:

    Called with NM global lock held.

--*/
{
    DWORD           status;
    PLIST_ENTRY     entry;
    LPWSTR          networkId = (LPWSTR) OmObjectId(Network);
    BOOLEAN         wasInternalNetwork = FALSE;


    if (NM_DELETE_PENDING(Network)) {
        CL_ASSERT(!NM_OM_INSERTED(Network));
        return;
    }

    ClRtlLogPrint(LOG_NOISE,
        "[NM] Deleting object for network %1!ws!.\n",
        networkId
        );

    CL_ASSERT(IsListEmpty(&(Network->InterfaceList)));

    Network->Flags |= NM_FLAG_DELETE_PENDING;

    //
    // Remove from the object lists
    //
    if (NM_OM_INSERTED(Network)) {
        status = OmRemoveObject(Network);
        CL_ASSERT(status == ERROR_SUCCESS);

        Network->Flags &= ~NM_FLAG_OM_INSERTED;

        RemoveEntryList(&(Network->Linkage));
        CL_ASSERT(NmpNetworkCount > 0);
        NmpNetworkCount--;

        if (NmpIsNetworkForInternalUse(Network)) {
            RemoveEntryList(&(Network->InternalLinkage));
            CL_ASSERT(NmpInternalNetworkCount > 0);
            NmpInternalNetworkCount--;
            wasInternalNetwork = TRUE;
        }

        if (NmpIsNetworkForClientAccess(Network)) {
            CL_ASSERT(NmpClientNetworkCount > 0);
            NmpClientNetworkCount--;
        }
    }

    //
    // Place the object on the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedNetworkList.Flink;
              entry != &NmpDeletedNetworkList;
              entry = entry->Flink
            )
        {
            if (entry == &(Network->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry != &(Network->Linkage));
    }
#endif DBG

    InsertTailList(&NmpDeletedNetworkList, &(Network->Linkage));

    if (NmpIsNetworkEnabledForUse(Network)) {
        //
        // Deregister the network from the cluster transport
        //
        NmpDeregisterNetwork(Network);
    }

    //
    // Issue an event if needed
    //
    if (IssueEvent) {
        ClRtlLogPrint(LOG_NOISE,
            "[NM] Issuing network deleted event for network %1!ws!.\n",
            networkId
            );

        ClusterEvent(CLUSTER_EVENT_NETWORK_DELETED, Network);

        //
        // Issue a cluster property change event if this network was
        // used for internal communication. The network priority list
        // was changed.
        //
        if (wasInternalNetwork) {
            NmpIssueClusterPropertyChangeEvent();
        }
    }

    //
    // Remove the initial reference so the object can be destroyed.
    //
    OmDereferenceObject(Network);

    return;

}  // NmpDeleteNetworkObject


BOOL
NmpDestroyNetworkObject(
    PNM_NETWORK  Network
    )
{
    DWORD  status;


    ClRtlLogPrint(LOG_NOISE,
        "[NM] destroying object for network %1!ws!\n",
        OmObjectId(Network)
        );

    CL_ASSERT(NM_DELETE_PENDING(Network));
    CL_ASSERT(!NM_OM_INSERTED(Network));
    CL_ASSERT(Network->InterfaceCount == 0);

    //
    // Remove the network from the deleted list
    //
#if DBG
    {
        PLIST_ENTRY  entry;

        for ( entry = NmpDeletedNetworkList.Flink;
              entry != &NmpDeletedNetworkList;
              entry = entry->Flink
            )
        {
            if (entry == &(Network->Linkage)) {
                break;
            }
        }

        CL_ASSERT(entry == &(Network->Linkage));
    }
#endif DBG

    RemoveEntryList(&(Network->Linkage));

    NM_FREE_OBJECT_FIELD(Network, Description);
    NM_FREE_OBJECT_FIELD(Network, Transport);
    NM_FREE_OBJECT_FIELD(Network, Address);
    NM_FREE_OBJECT_FIELD(Network, AddressMask);

    if (Network->ConnectivityVector != NULL) {
        LocalFree(Network->ConnectivityVector);
        Network->ConnectivityVector = NULL;
    }

    if (Network->StateWorkVector != NULL) {
        LocalFree(Network->StateWorkVector);
        Network->StateWorkVector = NULL;
    }

    if (Network->ConnectivityMatrix != NULL) {
        LocalFree(Network->ConnectivityMatrix);
        Network->ConnectivityMatrix = NULL;
    }

    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastAddress);
    if (Network->EncryptedMulticastKey != NULL) {
        LocalFree(Network->EncryptedMulticastKey);
        Network->EncryptedMulticastKey = NULL;
    }
    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastLeaseServer);
    NM_MIDL_FREE_OBJECT_FIELD(Network, MulticastLeaseRequestId.ClientUID);

    NmpFreeMulticastAddressReleaseList(Network);

    return(TRUE);

}  // NmpDestroyNetworkObject


DWORD
NmpEnumNetworkObjects(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    )
/*++

Routine Description:

    Reads information about defined cluster networks from the cluster
    objects and builds an enumeration structure to hold the information.

Arguments:

    NetworkEnum -  A pointer to the variable into which to place a pointer to
                   the allocated network enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD              status = ERROR_SUCCESS;
    PNM_NETWORK_ENUM   networkEnum = NULL;
    DWORD              i;
    DWORD              valueLength;
    PLIST_ENTRY        entry;
    PNM_NETWORK        network;


    *NetworkEnum = NULL;

    if (NmpNetworkCount == 0) {
        valueLength = sizeof(NM_NETWORK_ENUM);

    }
    else {
        valueLength = sizeof(NM_NETWORK_ENUM) +
                      (sizeof(NM_NETWORK_INFO) * (NmpNetworkCount - 1));
    }

    networkEnum = MIDL_user_allocate(valueLength);

    if (networkEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkEnum, valueLength);

    for (entry = NmpNetworkList.Flink, i=0;
         entry != &NmpNetworkList;
         entry = entry->Flink, i++
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);

        status = NmpGetNetworkObjectInfo(
                     network,
                     &(networkEnum->NetworkList[i])
                     );

        if (status != ERROR_SUCCESS) {
            ClNetFreeNetworkEnum(networkEnum);
            return(status);
        }
    }

    networkEnum->NetworkCount = NmpNetworkCount;
    *NetworkEnum = networkEnum;
    networkEnum = NULL;

    return(ERROR_SUCCESS);

}  // NmpEnumNetworkObjects


DWORD
NmpEnumNetworkObjectStates(
    OUT PNM_NETWORK_STATE_ENUM *  NetworkStateEnum
    )
/*++

Routine Description:

    Reads state information for all defined cluster networks
    and fills in an enumeration structure.

Arguments:

    NetworkStateEnum -  A pointer to the variable into which to place a
                        pointer to the allocated interface enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/

{
    DWORD                      status = ERROR_SUCCESS;
    PNM_NETWORK_STATE_ENUM     networkStateEnum = NULL;
    PNM_NETWORK_STATE_INFO     networkStateInfo;
    DWORD                      i;
    DWORD                      valueLength;
    PLIST_ENTRY                entry;
    PNM_NETWORK                network;
    LPWSTR                     networkId;


    *NetworkStateEnum = NULL;

    if (NmpNetworkCount == 0) {
        valueLength = sizeof(NM_NETWORK_STATE_ENUM);
    }
    else {
        valueLength =
            sizeof(NM_NETWORK_STATE_ENUM) +
            (sizeof(NM_NETWORK_STATE_INFO) * (NmpNetworkCount - 1));
    }

    networkStateEnum = MIDL_user_allocate(valueLength);

    if (networkStateEnum == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkStateEnum, valueLength);

    for (entry = NmpNetworkList.Flink, i=0;
         entry != &NmpNetworkList;
         entry = entry->Flink, i++
        )
    {
        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);
        networkId = (LPWSTR) OmObjectId(network);
        networkStateInfo = &(networkStateEnum->NetworkList[i]);

        networkStateInfo->State = network->State;

        networkStateInfo->Id = MIDL_user_allocate(NM_WCSLEN(networkId));

        if (networkStateInfo->Id == NULL) {
            NmpFreeNetworkStateEnum(networkStateEnum);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyW(networkStateInfo->Id, networkId);
    }

    networkStateEnum->NetworkCount = NmpNetworkCount;
    *NetworkStateEnum = networkStateEnum;

    return(ERROR_SUCCESS);

}  // NmpEnumNetworkObjectStates



DWORD
NmpGetNetworkMulticastKey(
    IN  LPWSTR                      NetworkId,
    OUT PNM_NETWORK_MULTICASTKEY  * NetworkMulticastKey
    )

/*++

Routine Description:

    Reads network multicast key for networt NetworkId.

Arguments:

    NetworkId - Id of the network whose multicast key should be read.

    NetworkMulticastKey -  A pointer to the variable into which to place
                           the network multicast key.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

Notes:

    Called with the NmpLock held.

--*/
{
    PNM_NETWORK_MULTICASTKEY   networkMulticastKey;
    PLIST_ENTRY        entry;
    PNM_NETWORK        network;
    PVOID              MulticastKey = NULL;
    DWORD              MulticastKeyLength;
    DWORD              status = ERROR_SUCCESS;
    LPWSTR    networkId;
    PVOID     EncryptionKey = NULL;
    DWORD     EncryptionKeyLength;
    PBYTE     Salt = NULL;
    PBYTE     EncryptedMulticastKey = NULL;
    DWORD     EncryptedMulticastKeyLength;
    PBYTE     MAC = NULL;
    DWORD     MACLength;
    BOOL      found = FALSE;



    networkMulticastKey  = MIDL_user_allocate(sizeof(NM_NETWORK_MULTICASTKEY));
    if (networkMulticastKey == NULL)
    {
        ClRtlLogPrint(LOG_UNUSUAL,
            "[NM] Failed to allocate %1!u! bytes to marshall "
            "encrypted multicast key.\n",
            sizeof(NM_NETWORK_MULTICASTKEY)
            );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkMulticastKey, sizeof(NM_NETWORK_MULTICASTKEY));


    for (entry = NmpNetworkList.Flink;
         entry != &NmpNetworkList;
         entry = entry->Flink
        )
    {

        network = CONTAINING_RECORD(entry, NM_NETWORK, Linkage);
        networkId = (LPWSTR) OmObjectId(network);


        if (wcscmp(NetworkId, networkId) == 0)
        {

            found = TRUE;

            if (network->EncryptedMulticastKey != NULL)
            {


                //
                // Set MulticastKeyExpires
                //
                networkMulticastKey->MulticastKe