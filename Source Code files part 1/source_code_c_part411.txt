monReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(HashAlgorithmError)     // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Calculate the length of an enveloped message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSize;
    DWORD cb;

    CMSG_CONTENT_ENCRYPT_INFO ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);
    CmsRecipientInfos recipientInfos; ZEROSTRUCT(recipientInfos);
#ifdef OSS_CRYPT_ASN1
    int version = 0;
#else
    ASN1int32_t version = 0;
#endif  // OSS_CRYPT_ASN1

    ASN1error_e Asn1Err;
    ASN1encoding_t pEnc = ICM_GetEncoder();
    PBYTE pbEncoded = NULL;
    DWORD cbEncoded;

    assert(pemei->cbSize >= STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO,
        rgpRecipients));
#ifdef CMS_PKCS7
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients))
#else
    assert(0 != pemei->cRecipients);
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients) ||
            0 == pemei->cRecipients)
#endif  // CMS_PKCS7
        goto InvalidArg;

    // version
    cbSize = 1 + 1 + 1;

    // originatorInfo OPTIONAL
    //
    // unprotectedAttrs OPTIONAL
    if (pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO)) {
        DWORD cbOriginator = 0;
        DWORD cbTmp;
        DWORD i;
        PCERT_BLOB pCert;
        PCRL_BLOB pCrl;
        cbOriginator = 0;

        for (i = pemei->cCertEncoded, pCert = pemei->rgCertEncoded, cbTmp=0;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
        for (i = pemei->cAttrCertEncoded, pCert = pemei->rgAttrCertEncoded;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
        if (cbTmp) {
            ICM_GetLengthOctets(cbTmp, NULL, &cb);
            cbOriginator += 1 + cb + cbTmp;     // [0] IMPLICIT Certificates
        }

        for (i = pemei->cCrlEncoded, pCrl = pemei->rgCrlEncoded, cbTmp=0;
                i > 0;
                i--, pCrl++)
            cbTmp += pCrl->cbData;
        if (cbTmp) {
            ICM_GetLengthOctets(cbTmp, NULL, &cb);
            cbOriginator += 1 + cb + cbTmp;     // [1] IMPLICIT Crls
        }

        if (cbOriginator) {
            ICM_GetLengthOctets(cbOriginator, NULL, &cb);
            cbSize += 1 + cb + cbOriginator; // [0] IMPLICIT OriginatorInfo
        }

        if (0 < pemei->cUnprotectedAttr) {
            if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                                NULL,
                                NULL,
                                pemei->cUnprotectedAttr,
                                pemei->rgUnprotectedAttr,
                                NULL,
                                FALSE)))
                goto UnprotectedAttrError;
            cbSize += cb;
        }
    }

    // recipientInfos
    if (!ICM_InitializeContentEncryptInfo(pemei, &ContentEncryptInfo))
        goto InitializeContentEncryptInfoError;
    ContentEncryptInfo.dwEncryptFlags |=
        CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG;
    if (!ICM_FillOssCmsRecipientInfos(
            &ContentEncryptInfo,
            &recipientInfos,
            &version
            ))
        goto FillOssCmsRecipientInfosError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &recipientInfos,
            CmsRecipientInfos_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeCmsRecipientInfosError;
    cbSize += cbEncoded;

    // encryptedContentInfo
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedContentInfo(
                    ContentEncryptInfo.hContentEncryptKey,
                    &ContentEncryptInfo.ContentEncryptionAlgorithm,
                    pszInnerContentObjID,
                    cbData)))
        goto LengthEncryptedContentInfoError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // CmsEnvelopedData seq

CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_FreeContentEncryptInfo(pemei, &ContentEncryptInfo);
    ICM_FreeOssCmsRecipientInfos(&recipientInfos);

    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(UnprotectedAttrError)
TRACE_ERROR(InitializeContentEncryptInfoError)
TRACE_ERROR(FillOssCmsRecipientInfosError)
SET_ERROR_VAR(EncodeCmsRecipientInfosError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(LengthEncryptedContentInfoError)
}
#else


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedKey encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN DWORD                        dwEncryptFlags)
{
    DWORD cbSize;
    // rgcbEncryptedKey[1] contains dwEncryptFlags
    DWORD rgcbEncryptedKey[2];
    DWORD cb;

    rgcbEncryptedKey[1] = dwEncryptFlags;

    // Length only export calculation
    if (!ICM_ExportEncryptKey(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            NULL,               // pbData
            rgcbEncryptedKey) || 0 == rgcbEncryptedKey[0])
        goto ExportKeyError;

    // Add bytes for ASN.1 tag and length
    ICM_GetLengthOctets(rgcbEncryptedKey[0], NULL, &cb);
    cbSize = rgcbEncryptedKey[0] + cb + 1;       // OCTET STRING

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(ExportKeyError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the RecipientInfos encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthRecipientInfos(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN DWORD                        cRecipients,
    IN PCERT_INFO                   *rgpRecipients,
    IN DWORD                        dwEncryptFlags)
{
    DWORD       cbSize;
    DWORD       cbRecipient;
    DWORD       cbRecipientS;
    DWORD       cb;
    PCERT_INFO  *ppCertInfo;
    DWORD       i;

    for (i=cRecipients, ppCertInfo=rgpRecipients, cbRecipientS=0;
            i>0;
            i--, ppCertInfo++) {
        cbRecipient = 1 + 1 + 1;                // version
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthIssuerAndSerialNumber( *ppCertInfo)))
            goto IssuerAndSerialNumberError;
        cbRecipient += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier(
                            &(*ppCertInfo)->SubjectPublicKeyInfo.Algorithm)))
            goto SubjectPublicKeyInfoAlgorithmError;
        cbRecipient += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedKey(
                            hCryptProv,
                            hEncryptKey,
                            &(*ppCertInfo)->SubjectPublicKeyInfo,
                            dwEncryptFlags)))
            goto EncryptedKeyError;
        cbRecipient += cb;
        ICM_GetLengthOctets( cbRecipient, NULL, &cb);
        cbRecipientS += cbRecipient + cb + 1;   // RecipientInfo
    }
    ICM_GetLengthOctets( cbRecipientS, NULL, &cb);
    cbSize = cbRecipientS + cb + 1;             // RecipientInfos seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(IssuerAndSerialNumberError)             // error already set
TRACE_ERROR(SubjectPublicKeyInfoAlgorithmError)     // error already set
TRACE_ERROR(EncryptedKeyError)                      // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of an enveloped message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSize;
    DWORD       cb;
    HCRYPTPROV  hCryptProv;
    HCRYPTKEY   hEncryptKey = NULL;

    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    PBYTE                       pbEncryptParameters = NULL;

    // rgcbEncryptParameters[1] contains dwEncryptFlags
    DWORD                       rgcbEncryptParameters[2];

    // version
    cbSize = 1 + 1 + 1;

    if (0 == pemei->cRecipients)
        goto InvalidArg;
    hCryptProv = pemei->hCryptProv;

    ContentEncryptionAlgorithm = pemei->ContentEncryptionAlgorithm;
    rgcbEncryptParameters[0] = 0;
    rgcbEncryptParameters[1] = 0;   // dwEncryptFlags
    if (!ICM_GenEncryptKey(
            &hCryptProv,
            &ContentEncryptionAlgorithm,
            pemei->pvEncryptionAuxInfo,
            &pemei->rgpRecipients[0]->SubjectPublicKeyInfo,
            ICM_Alloc,
            &hEncryptKey,
            &pbEncryptParameters,
            rgcbEncryptParameters))
        goto GenKeyError;
    if (rgcbEncryptParameters[0] && pbEncryptParameters) {
        ContentEncryptionAlgorithm.Parameters.pbData = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.cbData = rgcbEncryptParameters[0];
    }

    // recipientInfos
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthRecipientInfos(
                    hCryptProv,
                    hEncryptKey,
                    pemei->cRecipients,
                    pemei->rgpRecipients,
                    rgcbEncryptParameters[1])))     // dwEncryptFlags
        goto LengthRecipientInfosError;
    cbSize += cb;

    // encryptedContentInfo
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedContentInfo(
                    hEncryptKey,
                    &ContentEncryptionAlgorithm,
                    pszInnerContentObjID,
                    cbData)))
        goto LengthEncryptedContentInfoError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // EnvelopedData seq

CommonReturn:
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    ICM_Free(pbEncryptParameters);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(LengthRecipientInfosError)
TRACE_ERROR(LengthEncryptedContentInfoError)
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Calculate the length of a signed message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSigned(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent)
{
    DWORD                       cbSize;
    DWORD                       cbSignedData;
    DWORD                       cbTmp;
    DWORD                       cb;
    DWORD                       i;
    PCERT_BLOB                  pCert;
    PCRL_BLOB                   pCrl;

#ifdef CMS_PKCS7
    DWORD                       cAttrCertEncoded;
    BOOL                        fHasCmsSignerId = FALSE;
#endif  // CMS_PKCS7

    cbSignedData = 1 + 1 + 1;           // version

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthSignedDigestAlgorithms(
                    psmei->cSigners,
                    psmei->rgSigners)))
        goto LengthSignedDigestAlgorithmsError;
    cbSignedData += cb;

#ifdef CMS_PKCS7
    if (psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
            rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        if (cAttrCertEncoded)
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else
        cAttrCertEncoded = 0;
#endif  // CMS_PKCS7

    // Do this before the ContentInfo. Need to know if we need to
    // encapsulate the content for KeyId Signers.
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthSignerInfos(
                    psmei->cSigners,
                    psmei->rgSigners,
                    pszInnerContentObjID
#ifdef CMS_PKCS7
                    ,
                    &fHasCmsSignerId
#endif  // CMS_PKCS7
                    )))
        goto SignerInfosError;
    cbSignedData += cb;
#ifdef CMS_PKCS7
    if (fHasCmsSignerId)
        dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthContentInfo(
                    dwFlags,
                    pszInnerContentObjID,
                    cbData,
                    NULL)))
        goto LengthContentInfoError;
    cbSignedData += cb;

    for (i = psmei->cCertEncoded, pCert = psmei->rgCertEncoded, cbTmp=0;
            i > 0;
            i--, pCert++)
        cbTmp += pCert->cbData;

#ifdef CMS_PKCS7
    if (cAttrCertEncoded) {
        for (i = cAttrCertEncoded, pCert = psmei->rgAttrCertEncoded;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
    }
#endif  // CMS_PKCS7

    if (cbTmp) {
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbSignedData += 1 + cb + cbTmp;     // [0] IMPLICIT Certificates
    }

    for (i = psmei->cCrlEncoded, pCrl = psmei->rgCrlEncoded, cbTmp=0;
            i > 0;
            i--, pCrl++)
        cbTmp += pCrl->cbData;
    if (cbTmp) {
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbSignedData += 1 + cb + cbTmp;     // [1] IMPLICIT Crls
    }

    if (pcbContent)
        *pcbContent = cbSignedData;

    ICM_GetLengthOctets( cbSignedData, NULL, &cb);
    cbSize = 1 + cb + cbSignedData;     // SignedData seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthSignedDigestAlgorithmsError)  // error already set
TRACE_ERROR(LengthContentInfoError)             // error already set
TRACE_ERROR(SignerInfosError)                   // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of a digested message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthDigested(
    IN PCMSG_HASHED_ENCODE_INFO pdmei,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent)
{
    DWORD       cbSize;
    DWORD       cb;

    cbSize = 1 + 1 + 1;             // version

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &pdmei->HashAlgorithm)))
        goto HashAlgorithmError;
    cbSize += cb;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthContentInfo(
                    dwFlags,
                    pszInnerContentObjID,
                    cbData,
                    NULL)))
        goto LengthContentInfoError;
    cbSize += cb;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthDigest( pdmei->hCryptProv, &pdmei->HashAlgorithm)))
        goto DigestError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;               // DigestedData seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(HashAlgorithmError)     // error already set
TRACE_ERROR(LengthContentInfoError) // error already set
TRACE_ERROR(DigestError)            // error already set
}

//+-------------------------------------------------------------------------
//  Calculate the length of an encoded cryptographic message.
//
//  Calculates the length of the encoded message given the
//  message type, encoding parameters and total length of
//  the data to be updated. Note, this might not be the exact length.
//  However, it will always be greater than or equal to the actual length.
//--------------------------------------------------------------------------
DWORD
WINAPI
CryptMsgCalculateEncodedLength(
    IN DWORD            dwEncodingType,
    IN DWORD            dwFlags,
    IN DWORD            dwMsgType,
    IN void const       *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN DWORD            cbData)
{
    DWORD   cbSize = INVALID_ENCODING_SIZE;
    LPSTR   pszContentType = NULL;
    DWORD   cb;
    DWORD   cbContent = 0;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncoding;

    switch (dwMsgType) {
    case CMSG_DATA:
        if (NULL != pvMsgEncodeInfo)
            goto InvalidEncodeInfo;
        cbContent = cbData;
        ICM_GetLengthOctets( cbData, NULL, &cb);
        cbSize = 1 + cb + cbData;       // OCTET STRING
        pszContentType = pszObjIdDataType;
        break;

    case CMSG_SIGNED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthSigned(
                                (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthSignedError;
        pszContentType = szOID_RSA_signedData;
        break;

    case CMSG_ENVELOPED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthEnveloped(
                                (PCMSG_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthEnvelopedError;
        pszContentType = szOID_RSA_envelopedData;
        break;

    case CMSG_HASHED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthDigested(
                                (PCMSG_HASHED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthDigestedError;
        pszContentType = szOID_RSA_digestedData;
        break;

    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (0 == (dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthContentInfo(
                            0,                      // dwFlags
                            pszContentType,
                            cbSize,
                            &cbContent)))
            goto LengthContentInfoError;
    }

CommonReturn:
    return (cbSize == INVALID_ENCODING_SIZE) ? 0 :
           ((dwFlags & CMSG_CONTENTS_OCTETS_FLAG) ? cbContent : cbSize);

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidEncoding,E_INVALIDARG)
SET_ERROR(InvalidEncodeInfo,E_INVALIDARG)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(LengthSignedError)              // error already set
TRACE_ERROR(LengthEnvelopedError)           // error already set
TRACE_ERROR(LengthDigestedError)            // error already set
TRACE_ERROR(LengthContentInfoError)         // error already set
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\pkcs.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#ifndef _PKCS_Module_H_
#define _PKCS_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1open_t SignerInfosNC_Set;

typedef ASN1open_t SetOfAny_Set;

typedef ASN1open_t AttributeSetValueNC_Set;

typedef ASN1open_t AttributeSetValue_Set;

typedef ASN1objectidentifier2_t ObjectID;
#define ObjectID_PDU 0
#define SIZE_PKCS_Module_PDU_0 sizeof(ObjectID)

typedef ASN1open_t Any;

typedef ObjectID ObjectIdentifierType;
#define ObjectIdentifierType_PDU 1
#define SIZE_PKCS_Module_PDU_1 sizeof(ObjectIdentifierType)

typedef ASN1octetstring_t OctetStringType;
#define OctetStringType_PDU 2
#define SIZE_PKCS_Module_PDU_2 sizeof(OctetStringType)

typedef ASN1int32_t IntegerType;
#define IntegerType_PDU 3
#define SIZE_PKCS_Module_PDU_3 sizeof(IntegerType)

typedef ASN1intx_t HugeIntegerType;
#define HugeIntegerType_PDU 4
#define SIZE_PKCS_Module_PDU_4 sizeof(HugeIntegerType)

typedef ASN1bitstring_t BitStringType;

typedef ASN1octetstring_t Digest;

typedef ASN1open_t CertificateRevocationList;

typedef ASN1open_t CertificateRevocationListNC;

typedef HugeIntegerType CertificateSerialNumber;

typedef ASN1open_t Name;

typedef ASN1open_t Certificate;

typedef ASN1open_t CertificateNC;

typedef ASN1open_t AlgorithmIdentifierNC;

typedef AlgorithmIdentifierNC DigestAlgorithmIdentifierNC;

typedef ASN1open_t AttributeNC;

typedef AlgorithmIdentifierNC ContentEncryptionAlgIdNC;

typedef ObjectID ContentType;

typedef ASN1octetstring_t Data;

typedef ASN1open_t DigestAlgorithmBlob;

typedef ASN1octetstring_t EncryptedDigest;

typedef ASN1octetstring_t EncryptedDigestNC;

typedef ASN1octetstring_t EncryptedContent;

typedef OctetStringType EncryptedKey;

typedef ASN1open_t CertIdentifierNC;

typedef OctetStringType SubjectKeyIdentifier;

typedef OctetStringType UserKeyingMaterial;

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define AlgorithmIdentifier_parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;
#define AlgorithmIdentifier_PDU 5
#define SIZE_PKCS_Module_PDU_5 sizeof(AlgorithmIdentifier)

typedef struct AlgorithmIdentifierNC2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define AlgorithmIdentifierNC2_parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifierNC2;
#define AlgorithmIdentifierNC2_PDU 6
#define SIZE_PKCS_Module_PDU_6 sizeof(AlgorithmIdentifierNC2)

typedef AlgorithmIdentifier DigestAlgorithmIdentifier;

typedef struct AlgorithmIdentifiers {
    ASN1uint32_t count;
    struct AlgorithmIdentifier *value;
} AlgorithmIdentifiers;
#define AlgorithmIdentifiers_PDU 7
#define SIZE_PKCS_Module_PDU_7 sizeof(AlgorithmIdentifiers)

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    AttributeSetValue_Set *value;
} AttributeSetValue;
#define AttributeSetValue_PDU 8
#define SIZE_PKCS_Module_PDU_8 sizeof(AttributeSetValue)

typedef struct AttributeSetValueNC {
    ASN1uint32_t count;
    AttributeSetValueNC_Set *value;
} AttributeSetValueNC;
#define AttributeSetValueNC_PDU 9
#define SIZE_PKCS_Module_PDU_9 sizeof(AttributeSetValueNC)

typedef struct SetOfAny {
    ASN1uint32_t count;
    SetOfAny_Set *value;
} SetOfAny;
#define SetOfAny_PDU 10
#define SIZE_PKCS_Module_PDU_10 sizeof(SetOfAny)

typedef struct Attribute {
    ObjectID attributeType;
    AttributeSetValue attributeValue;
} Attribute;

typedef struct AttributeNC2 {
    ObjectID attributeType;
    AttributeSetValueNC attributeValue;
} AttributeNC2;
#define AttributeNC2_PDU 11
#define SIZE_PKCS_Module_PDU_11 sizeof(AttributeNC2)

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 12
#define SIZE_PKCS_Module_PDU_12 sizeof(Attributes)

typedef struct AttributesNC {
    ASN1uint32_t count;
    AttributeNC *value;
} AttributesNC;
#define AttributesNC_PDU 13
#define SIZE_PKCS_Module_PDU_13 sizeof(AttributesNC)

typedef struct AttributesNC2 {
    ASN1uint32_t count;
    struct AttributeNC2 *value;
} AttributesNC2;
#define AttributesNC2_PDU 14
#define SIZE_PKCS_Module_PDU_14 sizeof(AttributesNC2)

typedef struct Crls {
    ASN1uint32_t count;
    CertificateRevocationList *value;
} Crls;

typedef struct CrlsNC {
    ASN1uint32_t count;
    CertificateRevocationListNC *value;
} CrlsNC;
#define CrlsNC_PDU 15
#define SIZE_PKCS_Module_PDU_15 sizeof(CrlsNC)

typedef AlgorithmIdentifier ContentEncryptionAlgId;

typedef AlgorithmIdentifier DigestEncryptionAlgId;

typedef AlgorithmIdentifierNC2 DigestEncryptionAlgIdNC;

typedef struct Certificates {
    ASN1uint32_t count;
    Certificate *value;
} Certificates;

typedef struct CertificatesNC {
    ASN1uint32_t count;
    CertificateNC *value;
} CertificatesNC;
#define CertificatesNC_PDU 16
#define SIZE_PKCS_Module_PDU_16 sizeof(CertificatesNC)

typedef struct IssuerAndSerialNumber {
    Name issuer;
    CertificateSerialNumber serialNumber;
} IssuerAndSerialNumber;
#define IssuerAndSerialNumber_PDU 17
#define SIZE_PKCS_Module_PDU_17 sizeof(IssuerAndSerialNumber)

typedef AlgorithmIdentifier KeyEncryptionAlgId;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define ContentInfo_content_present 0x80
    ASN1open_t content;
} ContentInfo;
#define ContentInfo_PDU 18
#define SIZE_PKCS_Module_PDU_18 sizeof(ContentInfo)

typedef struct ContentInfoNC {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define ContentInfoNC_content_present 0x80
    ASN1open_t content;
} ContentInfoNC;
#define ContentInfoNC_PDU 19
#define SIZE_PKCS_Module_PDU_19 sizeof(ContentInfoNC)

typedef struct DigestAlgorithmIdentifiers {
    ASN1uint32_t count;
    DigestAlgorithmIdentifier *value;
} DigestAlgorithmIdentifiers;

typedef struct DigestAlgorithmIdentifiersNC {
    ASN1uint32_t count;
    DigestAlgorithmIdentifierNC *value;
} DigestAlgorithmIdentifiersNC;
#define DigestAlgorithmIdentifiersNC_PDU 20
#define SIZE_PKCS_Module_PDU_20 sizeof(DigestAlgorithmIdentifiersNC)

typedef struct SignerInfos {
    ASN1uint32_t count;
    struct SignerInfo *value;
} SignerInfos;
#define SignerInfos_PDU 21
#define SIZE_PKCS_Module_PDU_21 sizeof(SignerInfos)

typedef struct DigestAlgorithmBlobs {
    ASN1uint32_t count;
    DigestAlgorithmBlob *value;
} DigestAlgorithmBlobs;
#define DigestAlgorithmBlobs_PDU 22
#define SIZE_PKCS_Module_PDU_22 sizeof(DigestAlgorithmBlobs)

typedef struct SignerInfosNC {
    ASN1uint32_t count;
    SignerInfosNC_Set *value;
} SignerInfosNC;
#define SignerInfosNC_PDU 23
#define SIZE_PKCS_Module_PDU_23 sizeof(SignerInfosNC)

typedef struct SignerInfoWithAABlobs {
    ASN1uint32_t count;
    struct SignerInfoWithAABlob *value;
} SignerInfoWithAABlobs;
#define SignerInfoWithAABlobs_PDU 24
#define SIZE_PKCS_Module_PDU_24 sizeof(SignerInfoWithAABlobs)

typedef struct SignerInfoWithAABlob {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1open_t version;
    ASN1open_t sid;
    ASN1open_t digestAlgorithm;
    ASN1open_t authenticatedAttributes;
    ASN1open_t digestEncryptionAlgorithm;
    ASN1open_t encryptedDigest;
#   define dummyUAAs_present 0x80
    AttributesNC dummyUAAs;
} SignerInfoWithAABlob;
#define SignerInfoWithAABlob_PDU 25
#define SIZE_PKCS_Module_PDU_25 sizeof(SignerInfoWithAABlob)

typedef struct SignerInfoWithAttrBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1open_t version;
    ASN1open_t sid;
    ASN1open_t digestAlgorithm;
#   define SignerInfoWithAttrBlobs_authAttributes_present 0x80
    AttributesNC authAttributes;
    DigestEncryptionAlgIdNC digestEncryptionAlgorithm;
    ASN1open_t encryptedDigest;
#   define SignerInfoWithAttrBlobs_unauthAttributes_present 0x40
    AttributesNC unauthAttributes;
} SignerInfoWithAttrBlobs;
#define SignerInfoWithAttrBlobs_PDU 26
#define SIZE_PKCS_Module_PDU_26 sizeof(SignerInfoWithAttrBlobs)

typedef struct SignerInfoWithBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    CertIdentifierNC sid;
    DigestAlgorithmIdentifierNC digestAlgorithm;
#   define SignerInfoWithBlobs_authAttributes_present 0x80
    AttributesNC2 authAttributes;
    DigestEncryptionAlgIdNC digestEncryptionAlgorithm;
    EncryptedDigestNC encryptedDigest;
#   define SignerInfoWithBlobs_unauthAttributes_present 0x40
    AttributesNC2 unauthAttributes;
} SignerInfoWithBlobs;
#define SignerInfoWithBlobs_PDU 27
#define SIZE_PKCS_Module_PDU_27 sizeof(SignerInfoWithBlobs)

typedef struct RecipientInfos {
    ASN1uint32_t count;
    struct RecipientInfo *value;
} RecipientInfos;
#define RecipientInfos_PDU 28
#define SIZE_PKCS_Module_PDU_28 sizeof(RecipientInfos)

typedef struct EncryptedContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
    ContentEncryptionAlgId contentEncryptionAlgorithm;
#   define encryptedContent_present 0x80
    EncryptedContent encryptedContent;
} EncryptedContentInfo;
#define EncryptedContentInfo_PDU 29
#define SIZE_PKCS_Module_PDU_29 sizeof(EncryptedContentInfo)

typedef struct RecipientInfo {
    ASN1int32_t version;
    IssuerAndSerialNumber issuerAndSerialNumber;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} RecipientInfo;
#define RecipientInfo_PDU 30
#define SIZE_PKCS_Module_PDU_30 sizeof(RecipientInfo)

typedef struct SignedAndEnvelopedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    RecipientInfos recipientInfos;
    DigestAlgorithmIdentifiers digestAlgorithms;
    EncryptedContentInfo encryptedContentInfo;
#   define SignedAndEnvelopedData_certificates_present 0x80
    Certificates certificates;
#   define SignedAndEnvelopedData_crls_present 0x40
    Crls crls;
    SignerInfos signerInfos;
} SignedAndEnvelopedData;
#define SignedAndEnvelopedData_PDU 31
#define SIZE_PKCS_Module_PDU_31 sizeof(SignedAndEnvelopedData)

typedef struct DigestedData {
    ASN1int32_t version;
    DigestAlgorithmIdentifier digestAlgorithm;
    ContentInfo contentInfo;
    Digest digest;
} DigestedData;
#define DigestedData_PDU 32
#define SIZE_PKCS_Module_PDU_32 sizeof(DigestedData)

typedef struct EncryptedData {
    ASN1int32_t version;
    EncryptedContentInfo encryptedContentInfo;
} EncryptedData;
#define EncryptedData_PDU 33
#define SIZE_PKCS_Module_PDU_33 sizeof(EncryptedData)

typedef struct CertIdentifier {
    ASN1choice_t choice;
    union {
#	define CertIdentifier_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define CertIdentifier_subjectKeyIdentifier_chosen 2
	SubjectKeyIdentifier subjectKeyIdentifier;
    } u;
} CertIdentifier;
#define CertIdentifier_PDU 34
#define SIZE_PKCS_Module_PDU_34 sizeof(CertIdentifier)

typedef struct OriginatorInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OriginatorInfo_certificates_present 0x80
    Certificates certificates;
#   define OriginatorInfo_crls_present 0x40
    Crls crls;
} OriginatorInfo;
#define OriginatorInfo_PDU 35
#define SIZE_PKCS_Module_PDU_35 sizeof(OriginatorInfo)

typedef struct OriginatorInfoNC {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OriginatorInfoNC_certificates_present 0x80
    CertificatesNC certificates;
#   define OriginatorInfoNC_crls_present 0x40
    CrlsNC crls;
} OriginatorInfoNC;
#define OriginatorInfoNC_PDU 36
#define SIZE_PKCS_Module_PDU_36 sizeof(OriginatorInfoNC)

typedef struct CmsRecipientInfos {
    ASN1uint32_t count;
    struct CmsRecipientInfo *value;
} CmsRecipientInfos;
#define CmsRecipientInfos_PDU 37
#define SIZE_PKCS_Module_PDU_37 sizeof(CmsRecipientInfos)

typedef struct KeyTransRecipientInfo {
    ASN1int32_t version;
    CertIdentifier rid;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} KeyTransRecipientInfo;
#define KeyTransRecipientInfo_PDU 38
#define SIZE_PKCS_Module_PDU_38 sizeof(KeyTransRecipientInfo)

typedef struct OriginatorPublicKey {
    AlgorithmIdentifier algorithm;
    BitStringType publicKey;
} OriginatorPublicKey;

typedef struct RecipientEncryptedKeys {
    ASN1uint32_t count;
    struct RecipientEncryptedKey *value;
} RecipientEncryptedKeys;

typedef struct OtherKeyAttribute {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID keyAttrId;
#   define keyAttr_present 0x80
    ASN1open_t keyAttr;
} OtherKeyAttribute;

typedef struct MailListKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    OctetStringType kekIdentifier;
#   define MailListKeyIdentifier_date_present 0x80
    ASN1generalizedtime_t date;
#   define MailListKeyIdentifier_other_present 0x40
    OtherKeyAttribute other;
} MailListKeyIdentifier;

typedef struct DigestInfo {
    DigestAlgorithmIdentifier digestAlgorithm;
    Digest digest;
} DigestInfo;
#define DigestInfo_PDU 39
#define SIZE_PKCS_Module_PDU_39 sizeof(DigestInfo)

typedef struct SignedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    DigestAlgorithmIdentifiers digestAlgorithms;
    ContentInfo contentInfo;
#   define SignedData_certificates_present 0x80
    Certificates certificates;
#   define SignedData_crls_present 0x40
    Crls crls;
    SignerInfos signerInfos;
} SignedData;
#define SignedData_PDU 40
#define SIZE_PKCS_Module_PDU_40 sizeof(SignedData)

typedef struct SignerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    CertIdentifier sid;
    DigestAlgorithmIdentifier digestAlgorithm;
#   define authenticatedAttributes_present 0x80
    Attributes authenticatedAttributes;
    DigestEncryptionAlgId digestEncryptionAlgorithm;
    EncryptedDigest encryptedDigest;
#   define SignerInfo_unauthAttributes_present 0x40
    Attributes unauthAttributes;
} SignerInfo;
#define SignerInfo_PDU 41
#define SIZE_PKCS_Module_PDU_41 sizeof(SignerInfo)

typedef struct SignedDataWithBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    DigestAlgorithmIdentifiersNC digestAlgorithms;
    ContentInfoNC contentInfo;
#   define SignedDataWithBlobs_certificates_present 0x80
    CertificatesNC certificates;
#   define SignedDataWithBlobs_crls_present 0x40
    CrlsNC crls;
    SignerInfosNC signerInfos;
} SignedDataWithBlobs;
#define SignedDataWithBlobs_PDU 42
#define SIZE_PKCS_Module_PDU_42 sizeof(SignedDataWithBlobs)

typedef struct EnvelopedData {
    ASN1int32_t version;
    RecipientInfos recipientInfos;
    EncryptedContentInfo encryptedContentInfo;
} EnvelopedData;
#define EnvelopedData_PDU 43
#define SIZE_PKCS_Module_PDU_43 sizeof(EnvelopedData)

typedef struct CmsEnvelopedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
#   define originatorInfo_present 0x80
    OriginatorInfo originatorInfo;
    CmsRecipientInfos recipientInfos;
    EncryptedContentInfo encryptedContentInfo;
#   define unprotectedAttrs_present 0x40
    Attributes unprotectedAttrs;
} CmsEnvelopedData;
#define CmsEnvelopedData_PDU 44
#define SIZE_PKCS_Module_PDU_44 sizeof(CmsEnvelopedData)

typedef struct OriginatorIdentifierOrKey {
    ASN1choice_t choice;
    union {
#	define OriginatorIdentifierOrKey_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define OriginatorIdentifierOrKey_subjectKeyIdentifier_chosen 2
	SubjectKeyIdentifier subjectKeyIdentifier;
#	define originatorKey_chosen 3
	OriginatorPublicKey originatorKey;
    } u;
} OriginatorIdentifierOrKey;

typedef struct RecipientKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectKeyIdentifier subjectKeyIdentifier;
#   define RecipientKeyIdentifier_date_present 0x80
    ASN1generalizedtime_t date;
#   define RecipientKeyIdentifier_other_present 0x40
    OtherKeyAttribute other;
} RecipientKeyIdentifier;

typedef struct MailListRecipientInfo {
    ASN1int32_t version;
    MailListKeyIdentifier mlid;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} MailListRecipientInfo;
#define MailListRecipientInfo_PDU 45
#define SIZE_PKCS_Module_PDU_45 sizeof(MailListRecipientInfo)

typedef struct KeyAgreeRecipientInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    OriginatorIdentifierOrKey originator;
#   define ukm_present 0x80
    UserKeyingMaterial ukm;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    RecipientEncryptedKeys recipientEncryptedKeys;
} KeyAgreeRecipientInfo;
#define KeyAgreeRecipientInfo_PDU 46
#define SIZE_PKCS_Module_PDU_46 sizeof(KeyAgreeRecipientInfo)

typedef struct RecipientIdentifier {
    ASN1choice_t choice;
    union {
#	define RecipientIdentifier_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define rKeyId_chosen 2
	RecipientKeyIdentifier rKeyId;
    } u;
} RecipientIdentifier;

typedef struct CmsRecipientInfo {
    ASN1choice_t choice;
    union {
#	define keyTransRecipientInfo_chosen 1
	KeyTransRecipientInfo keyTransRecipientInfo;
#	define keyAgreeRecipientInfo_chosen 2
	KeyAgreeRecipientInfo keyAgreeRecipientInfo;
#	define mailListRecipientInfo_chosen 3
	MailListRecipientInfo mailListRecipientInfo;
    } u;
} CmsRecipientInfo;
#define CmsRecipientInfo_PDU 47
#define SIZE_PKCS_Module_PDU_47 sizeof(CmsRecipientInfo)

typedef struct RecipientEncryptedKey {
    RecipientIdentifier rid;
    EncryptedKey encryptedKey;
} RecipientEncryptedKey;


extern ASN1module_t PKCS_Module;
extern void ASN1CALL PKCS_Module_Startup(void);
extern void ASN1CALL PKCS_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PKCS_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\pkcs.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#pragma warning(push,3)

#include <windows.h>
#include "pkcs.h"

#pragma warning (pop)

// unreferenced inline function has been removed
#pragma warning (disable: 4514)

// unreferenced formal parameter
#pragma warning (disable: 4100)

// assignment within conditional expression
#pragma warning (disable: 4706)

ASN1module_t PKCS_Module = NULL;

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifierNC2(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifiers *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_AttributeSetValueNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValueNC *val);
static int ASN1CALL ASN1Enc_SetOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SetOfAny *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_AttributeNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributeNC2 *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_AttributesNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC *val);
static int ASN1CALL ASN1Enc_AttributesNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC2 *val);
static int ASN1CALL ASN1Enc_Crls(ASN1encoding_t enc, ASN1uint32_t tag, Crls *val);
static int ASN1CALL ASN1Enc_CrlsNC(ASN1encoding_t enc, ASN1uint32_t tag, CrlsNC *val);
static int ASN1CALL ASN1Enc_ContentEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_DigestEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_DigestEncryptionAlgIdNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val);
static int ASN1CALL ASN1Enc_Certificates(ASN1encoding_t enc, ASN1uint32_t tag, Certificates *val);
static int ASN1CALL ASN1Enc_CertificatesNC(ASN1encoding_t enc, ASN1uint32_t tag, CertificatesNC *val);
static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Enc_KeyEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, KeyEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_ContentInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoNC *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiersNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val);
static int ASN1CALL ASN1Enc_SignerInfos(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfos *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmBlobs(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmBlobs *val);
static int ASN1CALL ASN1Enc_SignerInfosNC(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfosNC *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAABlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlobs *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAABlob(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlob *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAttrBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val);
static int ASN1CALL ASN1Enc_SignerInfoWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithBlobs *val);
static int ASN1CALL ASN1Enc_RecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfos *val);
static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Enc_RecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfo *val);
static int ASN1CALL ASN1Enc_SignedAndEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedAndEnvelopedData *val);
static int ASN1CALL ASN1Enc_DigestedData(ASN1encoding_t enc, ASN1uint32_t tag, DigestedData *val);
static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Enc_CertIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, CertIdentifier *val);
static int ASN1CALL ASN1Enc_OriginatorInfo(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfo *val);
static int ASN1CALL ASN1Enc_OriginatorInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfoNC *val);
static int ASN1CALL ASN1Enc_CmsRecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfos *val);
static int ASN1CALL ASN1Enc_KeyTransRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyTransRecipientInfo *val);
static int ASN1CALL ASN1Enc_OriginatorPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorPublicKey *val);
static int ASN1CALL ASN1Enc_RecipientEncryptedKeys(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKeys *val);
static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Enc_MailListKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, MailListKeyIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_SignedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedData *val);
static int ASN1CALL ASN1Enc_SignerInfo(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfo *val);
static int ASN1CALL ASN1Enc_SignedDataWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignedDataWithBlobs *val);
static int ASN1CALL ASN1Enc_EnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, EnvelopedData *val);
static int ASN1CALL ASN1Enc_CmsEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, CmsEnvelopedData *val);
static int ASN1CALL ASN1Enc_OriginatorIdentifierOrKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorIdentifierOrKey *val);
static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Enc_MailListRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, MailListRecipientInfo *val);
static int ASN1CALL ASN1Enc_KeyAgreeRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyAgreeRecipientInfo *val);
static int ASN1CALL ASN1Enc_RecipientIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientIdentifier *val);
static int ASN1CALL ASN1Enc_CmsRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfo *val);
static int ASN1CALL ASN1Enc_RecipientEncryptedKey(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKey *val);
static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifierNC2(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifiers *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_AttributeSetValueNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValueNC *val);
static int ASN1CALL ASN1Dec_SetOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SetOfAny *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_AttributeNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributeNC2 *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_AttributesNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC *val);
static int ASN1CALL ASN1Dec_AttributesNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC2 *val);
static int ASN1CALL ASN1Dec_Crls(ASN1decoding_t dec, ASN1uint32_t tag, Crls *val);
static int ASN1CALL ASN1Dec_CrlsNC(ASN1decoding_t dec, ASN1uint32_t tag, CrlsNC *val);
static int ASN1CALL ASN1Dec_ContentEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_DigestEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_DigestEncryptionAlgIdNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val);
static int ASN1CALL ASN1Dec_Certificates(ASN1decoding_t dec, ASN1uint32_t tag, Certificates *val);
static int ASN1CALL ASN1Dec_CertificatesNC(ASN1decoding_t dec, ASN1uint32_t tag, CertificatesNC *val);
static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Dec_KeyEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, KeyEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_ContentInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoNC *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiersNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val);
static int ASN1CALL ASN1Dec_SignerInfos(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfos *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmBlobs(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmBlobs *val);
static int ASN1CALL ASN1Dec_SignerInfosNC(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfosNC *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAABlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlobs *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAABlob(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlob *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAttrBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val);
static int ASN1CALL ASN1Dec_SignerInfoWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithBlobs *val);
static int ASN1CALL ASN1Dec_RecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfos *val);
static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Dec_RecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfo *val);
static int ASN1CALL ASN1Dec_SignedAndEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedAndEnvelopedData *val);
static int ASN1CALL ASN1Dec_DigestedData(ASN1decoding_t dec, ASN1uint32_t tag, DigestedData *val);
static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Dec_CertIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, CertIdentifier *val);
static int ASN1CALL ASN1Dec_OriginatorInfo(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfo *val);
static int ASN1CALL ASN1Dec_OriginatorInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfoNC *val);
static int ASN1CALL ASN1Dec_CmsRecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfos *val);
static int ASN1CALL ASN1Dec_KeyTransRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyTransRecipientInfo *val);
static int ASN1CALL ASN1Dec_OriginatorPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorPublicKey *val);
static int ASN1CALL ASN1Dec_RecipientEncryptedKeys(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKeys *val);
static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Dec_MailListKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, MailListKeyIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_SignedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedData *val);
static int ASN1CALL ASN1Dec_SignerInfo(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfo *val);
static int ASN1CALL ASN1Dec_SignedDataWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignedDataWithBlobs *val);
static int ASN1CALL ASN1Dec_EnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, EnvelopedData *val);
static int ASN1CALL ASN1Dec_CmsEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, CmsEnvelopedData *val);
static int ASN1CALL ASN1Dec_OriginatorIdentifierOrKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorIdentifierOrKey *val);
static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Dec_MailListRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, MailListRecipientInfo *val);
static int ASN1CALL ASN1Dec_KeyAgreeRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyAgreeRecipientInfo *val);
static int ASN1CALL ASN1Dec_RecipientIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientIdentifier *val);
static int ASN1CALL ASN1Dec_CmsRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfo *val);
static int ASN1CALL ASN1Dec_RecipientEncryptedKey(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKey *val);
static void ASN1CALL ASN1Free_ObjectID(ObjectID *val);
static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifierNC2(AlgorithmIdentifierNC2 *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifiers(AlgorithmIdentifiers *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_AttributeSetValueNC(AttributeSetValueNC *val);
static void ASN1CALL ASN1Free_SetOfAny(SetOfAny *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_AttributeNC2(AttributeNC2 *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_AttributesNC(AttributesNC *val);
static void ASN1CALL ASN1Free_AttributesNC2(AttributesNC2 *val);
static void ASN1CALL ASN1Free_Crls(Crls *val);
static void ASN1CALL ASN1Free_CrlsNC(CrlsNC *val);
static void ASN1CALL ASN1Free_ContentEncryptionAlgId(ContentEncryptionAlgId *val);
static void ASN1CALL ASN1Free_DigestEncryptionAlgId(DigestEncryptionAlgId *val);
static void ASN1CALL ASN1Free_DigestEncryptionAlgIdNC(DigestEncryptionAlgIdNC *val);
static void ASN1CALL ASN1Free_Certificates(Certificates *val);
static void ASN1CALL ASN1Free_CertificatesNC(CertificatesNC *val);
static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val);
static void ASN1CALL ASN1Free_KeyEncryptionAlgId(KeyEncryptionAlgId *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_ContentInfoNC(ContentInfoNC *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiers(DigestAlgorithmIdentifiers *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiersNC(DigestAlgorithmIdentifiersNC *val);
static void ASN1CALL ASN1Free_SignerInfos(SignerInfos *val);
static void ASN1CALL ASN1Free_DigestAlgorithmBlobs(DigestAlgorithmBlobs *val);
static void ASN1CALL ASN1Free_SignerInfosNC(SignerInfosNC *val);
static void ASN1CALL ASN1Free_SignerInfoWithAABlobs(SignerInfoWithAABlobs *val);
static void ASN1CALL ASN1Free_SignerInfoWithAABlob(SignerInfoWithAABlob *val);
static void ASN1CALL ASN1Free_SignerInfoWithAttrBlobs(SignerInfoWithAttrBlobs *val);
static void ASN1CALL ASN1Free_SignerInfoWithBlobs(SignerInfoWithBlobs *val);
static void ASN1CALL ASN1Free_RecipientInfos(RecipientInfos *val);
static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val);
static void ASN1CALL ASN1Free_RecipientInfo(RecipientInfo *val);
static void ASN1CALL ASN1Free_SignedAndEnvelopedData(SignedAndEnvelopedData *val);
static void ASN1CALL ASN1Free_DigestedData(DigestedData *val);
static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val);
static void ASN1CALL ASN1Free_CertIdentifier(CertIdentifier *val);
static void ASN1CALL ASN1Free_OriginatorInfo(OriginatorInfo *val);
static void ASN1CALL ASN1Free_OriginatorInfoNC(OriginatorInfoNC *val);
static void ASN1CALL ASN1Free_CmsRecipientInfos(CmsRecipientInfos *val);
static void ASN1CALL ASN1Free_KeyTransRecipientInfo(KeyTransRecipientInfo *val);
static void ASN1CALL ASN1Free_OriginatorPublicKey(OriginatorPublicKey *val);
static void ASN1CALL ASN1Free_RecipientEncryptedKeys(RecipientEncryptedKeys *val);
static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val);
static void ASN1CALL ASN1Free_MailListKeyIdentifier(MailListKeyIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_SignedData(SignedData *val);
static void ASN1CALL ASN1Free_SignerInfo(SignerInfo *val);
static void ASN1CALL ASN1Free_SignedDataWithBlobs(SignedDataWithBlobs *val);
static void ASN1CALL ASN1Free_EnvelopedData(EnvelopedData *val);
static void ASN1CALL ASN1Free_CmsEnvelopedData(CmsEnvelopedData *val);
static void ASN1CALL ASN1Free_OriginatorIdentifierOrKey(OriginatorIdentifierOrKey *val);
static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val);
static void ASN1CALL ASN1Free_MailListRecipientInfo(MailListRecipientInfo *val);
static void ASN1CALL ASN1Free_KeyAgreeRecipientInfo(KeyAgreeRecipientInfo *val);
static void ASN1CALL ASN1Free_RecipientIdentifier(RecipientIdentifier *val);
static void ASN1CALL ASN1Free_CmsRecipientInfo(CmsRecipientInfo *val);
static void ASN1CALL ASN1Free_RecipientEncryptedKey(RecipientEncryptedKey *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[48] = {
    (ASN1EncFun_t) ASN1Enc_ObjectID,
    (ASN1EncFun_t) ASN1Enc_ObjectIdentifierType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_HugeIntegerType,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifier,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifierNC2,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifiers,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValue,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValueNC,
    (ASN1EncFun_t) ASN1Enc_SetOfAny,
    (ASN1EncFun_t) ASN1Enc_AttributeNC2,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_AttributesNC,
    (ASN1EncFun_t) ASN1Enc_AttributesNC2,
    (ASN1EncFun_t) ASN1Enc_CrlsNC,
    (ASN1EncFun_t) ASN1Enc_CertificatesNC,
    (ASN1EncFun_t) ASN1Enc_IssuerAndSerialNumber,
    (ASN1EncFun_t) ASN1Enc_ContentInfo,
    (ASN1EncFun_t) ASN1Enc_ContentInfoNC,
    (ASN1EncFun_t) ASN1Enc_DigestAlgorithmIdentifiersNC,
    (ASN1EncFun_t) ASN1Enc_SignerInfos,
    (ASN1EncFun_t) ASN1Enc_DigestAlgorithmBlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfosNC,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAABlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAABlob,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAttrBlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithBlobs,
    (ASN1EncFun_t) ASN1Enc_RecipientInfos,
    (ASN1EncFun_t) ASN1Enc_EncryptedContentInfo,
    (ASN1EncFun_t) ASN1Enc_RecipientInfo,
    (ASN1EncFun_t) ASN1Enc_SignedAndEnvelopedData,
    (ASN1EncFun_t) ASN1Enc_DigestedData,
    (ASN1EncFun_t) ASN1Enc_EncryptedData,
    (ASN1EncFun_t) ASN1Enc_CertIdentifier,
    (ASN1EncFun_t) ASN1Enc_OriginatorInfo,
    (ASN1EncFun_t) ASN1Enc_OriginatorInfoNC,
    (ASN1EncFun_t) ASN1Enc_CmsRecipientInfos,
    (ASN1EncFun_t) ASN1Enc_KeyTransRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_DigestInfo,
    (ASN1EncFun_t) ASN1Enc_SignedData,
    (ASN1EncFun_t) ASN1Enc_SignerInfo,
    (ASN1EncFun_t) ASN1Enc_SignedDataWithBlobs,
    (ASN1EncFun_t) ASN1Enc_EnvelopedData,
    (ASN1EncFun_t) ASN1Enc_CmsEnvelopedData,
    (ASN1EncFun_t) ASN1Enc_MailListRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_KeyAgreeRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_CmsRecipientInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[48] = {
    (ASN1DecFun_t) ASN1Dec_ObjectID,
    (ASN1DecFun_t) ASN1Dec_ObjectIdentifierType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_HugeIntegerType,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifier,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifierNC2,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifiers,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValue,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValueNC,
    (ASN1DecFun_t) ASN1Dec_SetOfAny,
    (ASN1DecFun_t) ASN1Dec_AttributeNC2,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_AttributesNC,
    (ASN1DecFun_t) ASN1Dec_AttributesNC2,
    (ASN1DecFun_t) ASN1Dec_CrlsNC,
    (ASN1DecFun_t) ASN1Dec_CertificatesNC,
    (ASN1DecFun_t) ASN1Dec_IssuerAndSerialNumber,
    (ASN1DecFun_t) ASN1Dec_ContentInfo,
    (ASN1DecFun_t) ASN1Dec_ContentInfoNC,
    (ASN1DecFun_t) ASN1Dec_DigestAlgorithmIdentifiersNC,
    (ASN1DecFun_t) ASN1Dec_SignerInfos,
    (ASN1DecFun_t) ASN1Dec_DigestAlgorithmBlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfosNC,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAABlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAABlob,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAttrBlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithBlobs,
    (ASN1DecFun_t) ASN1Dec_RecipientInfos,
    (ASN1DecFun_t) ASN1Dec_EncryptedContentInfo,
    (ASN1DecFun_t) ASN1Dec_RecipientInfo,
    (ASN1DecFun_t) ASN1Dec_SignedAndEnvelopedData,
    (ASN1DecFun_t) ASN1Dec_DigestedData,
    (ASN1DecFun_t) ASN1Dec_EncryptedData,
    (ASN1DecFun_t) ASN1Dec_CertIdentifier,
    (ASN1DecFun_t) ASN1Dec_OriginatorInfo,
    (ASN1DecFun_t) ASN1Dec_OriginatorInfoNC,
    (ASN1DecFun_t) ASN1Dec_CmsRecipientInfos,
    (ASN1DecFun_t) ASN1Dec_KeyTransRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_DigestInfo,
    (ASN1DecFun_t) ASN1Dec_SignedData,
    (ASN1DecFun_t) ASN1Dec_SignerInfo,
    (ASN1DecFun_t) ASN1Dec_SignedDataWithBlobs,
    (ASN1DecFun_t) ASN1Dec_EnvelopedData,
    (ASN1DecFun_t) ASN1Dec_CmsEnvelopedData,
    (ASN1DecFun_t) ASN1Dec_MailListRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_KeyAgreeRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_CmsRecipientInfo,
};
static const ASN1FreeFun_t freefntab[48] = {
    (ASN1FreeFun_t) ASN1Free_ObjectID,
    (ASN1FreeFun_t) ASN1Free_ObjectIdentifierType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_HugeIntegerType,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifier,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifierNC2,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifiers,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValue,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValueNC,
    (ASN1FreeFun_t) ASN1Free_SetOfAny,
    (ASN1FreeFun_t) ASN1Free_AttributeNC2,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_AttributesNC,
    (ASN1FreeFun_t) ASN1Free_AttributesNC2,
    (ASN1FreeFun_t) ASN1Free_CrlsNC,
    (ASN1FreeFun_t) ASN1Free_CertificatesNC,
    (ASN1FreeFun_t) ASN1Free_IssuerAndSerialNumber,
    (ASN1FreeFun_t) ASN1Free_ContentInfo,
    (ASN1FreeFun_t) ASN1Free_ContentInfoNC,
    (ASN1FreeFun_t) ASN1Free_DigestAlgorithmIdentifiersNC,
    (ASN1FreeFun_t) ASN1Free_SignerInfos,
    (ASN1FreeFun_t) ASN1Free_DigestAlgorithmBlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfosNC,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAABlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAABlob,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAttrBlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithBlobs,
    (ASN1FreeFun_t) ASN1Free_RecipientInfos,
    (ASN1FreeFun_t) ASN1Free_EncryptedContentInfo,
    (ASN1FreeFun_t) ASN1Free_RecipientInfo,
    (ASN1FreeFun_t) ASN1Free_SignedAndEnvelopedData,
    (ASN1FreeFun_t) ASN1Free_DigestedData,
    (ASN1FreeFun_t) ASN1Free_EncryptedData,
    (ASN1FreeFun_t) ASN1Free_CertIdentifier,
    (ASN1FreeFun_t) ASN1Free_OriginatorInfo,
    (ASN1FreeFun_t) ASN1Free_OriginatorInfoNC,
    (ASN1FreeFun_t) ASN1Free_CmsRecipientInfos,
    (ASN1FreeFun_t) ASN1Free_KeyTransRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_DigestInfo,
    (ASN1FreeFun_t) ASN1Free_SignedData,
    (ASN1FreeFun_t) ASN1Free_SignerInfo,
    (ASN1FreeFun_t) ASN1Free_SignedDataWithBlobs,
    (ASN1FreeFun_t) ASN1Free_EnvelopedData,
    (ASN1FreeFun_t) ASN1Free_CmsEnvelopedData,
    (ASN1FreeFun_t) ASN1Free_MailListRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_KeyAgreeRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_CmsRecipientInfo,
};
static const ULONG sizetab[48] = {
    SIZE_PKCS_Module_PDU_0,
    SIZE_PKCS_Module_PDU_1,
    SIZE_PKCS_Module_PDU_2,
    SIZE_PKCS_Module_PDU_3,
    SIZE_PKCS_Module_PDU_4,
    SIZE_PKCS_Module_PDU_5,
    SIZE_PKCS_Module_PDU_6,
    SIZE_PKCS_Module_PDU_7,
    SIZE_PKCS_Module_PDU_8,
    SIZE_PKCS_Module_PDU_9,
    SIZE_PKCS_Module_PDU_10,
    SIZE_PKCS_Module_PDU_11,
    SIZE_PKCS_Module_PDU_12,
    SIZE_PKCS_Module_PDU_13,
    SIZE_PKCS_Module_PDU_14,
    SIZE_PKCS_Module_PDU_15,
    SIZE_PKCS_Module_PDU_16,
    SIZE_PKCS_Module_PDU_17,
    SIZE_PKCS_Module_PDU_18,
    SIZE_PKCS_Module_PDU_19,
    SIZE_PKCS_Module_PDU_20,
    SIZE_PKCS_Module_PDU_21,
    SIZE_PKCS_Module_PDU_22,
    SIZE_PKCS_Module_PDU_23,
    SIZE_PKCS_Module_PDU_24,
    SIZE_PKCS_Module_PDU_25,
    SIZE_PKCS_Module_PDU_26,
    SIZE_PKCS_Module_PDU_27,
    SIZE_PKCS_Module_PDU_28,
    SIZE_PKCS_Module_PDU_29,
    SIZE_PKCS_Module_PDU_30,
    SIZE_PKCS_Module_PDU_31,
    SIZE_PKCS_Module_PDU_32,
    SIZE_PKCS_Module_PDU_33,
    SIZE_PKCS_Module_PDU_34,
    SIZE_PKCS_Module_PDU_35,
    SIZE_PKCS_Module_PDU_36,
    SIZE_PKCS_Module_PDU_37,
    SIZE_PKCS_Module_PDU_38,
    SIZE_PKCS_Module_PDU_39,
    SIZE_PKCS_Module_PDU_40,
    SIZE_PKCS_Module_PDU_41,
    SIZE_PKCS_Module_PDU_42,
    SIZE_PKCS_Module_PDU_43,
    SIZE_PKCS_Module_PDU_44,
    SIZE_PKCS_Module_PDU_45,
    SIZE_PKCS_Module_PDU_46,
    SIZE_PKCS_Module_PDU_47,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL PKCS_Module_Startup(void)
{
    PKCS_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 48, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x73636b70);
}

void ASN1CALL PKCS_Module_Cleanup(void)
{
    ASN1_CloseModule(PKCS_Module);
    PKCS_Module = NULL;
}

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectID(ObjectID *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
	ASN1octetstring_free(val);
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncS32(enc, tag ? tag : 0x2, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecS32Val(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifierNC2(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifierNC2(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifierNC2(AlgorithmIdentifierNC2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifiers *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AlgorithmIdentifier(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AlgorithmIdentifier *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifiers(AlgorithmIdentifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AlgorithmIdentifier(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AttributeSetValue_Set *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValueNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValueNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValueNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValueNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AttributeSetValueNC_Set *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValueNC(AttributeSetValueNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SetOfAny *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SetOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SetOfAny_Set *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfAny(SetOfAny *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_AttributeNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributeNC2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValueNC(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributeNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValueNC(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeNC2(AttributeNC2 *val)
{
    if (val) {
	ASN1Free_AttributeSetValueNC(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Attribute *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributesNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributesNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AttributeNC *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributesNC(AttributesNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributesNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC2 *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AttributeNC2(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributesNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AttributeNC2 *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_AttributeNC2(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributesNC2(AttributesNC2 *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AttributeNC2(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AttributeNC2(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Crls(ASN1encoding_t enc, ASN1uint32_t tag, Crls *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Crls(ASN1decoding_t dec, ASN1uint32_t tag, Crls *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CertificateRevocationList *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Crls(Crls *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CrlsNC(ASN1encoding_t enc, ASN1uint32_t tag, CrlsNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CrlsNC(ASN1decoding_t dec, ASN1uint32_t tag, CrlsNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CertificateRevocationListNC *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CrlsNC(CrlsNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ContentEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentEncryptionAlgId(ContentEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestEncryptionAlgId(DigestEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestEncryptionAlgIdNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val)
{
    if (!ASN1Enc_AlgorithmIdentifierNC2(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestEncryptionAlgIdNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val)
{
    if (!ASN1Dec_AlgorithmIdentifierNC2(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestEncryptionAlgIdNC(DigestEncryptionAlgIdNC *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifierNC2(val);
    }
}

static int ASN1CALL ASN1Enc_Certificates(ASN1encoding_t enc, ASN1uint32_t tag, Certificates *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Certificates(ASN1decoding_t dec, ASN1uint32_t tag, Certificates *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Certificate *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Certificates(Certificates *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertificatesNC(ASN1encoding_t enc, ASN1uint32_t tag, CertificatesNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatesNC(ASN1decoding_t dec, ASN1uint32_t tag, CertificatesNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CertificateNC *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatesNC(CertificatesNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->issuer))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val)
{
    if (val) {
	ASN1open_free(&(val)->issuer);
	ASN1intx_free(&(val)->serialNumber);
    }
}

static int ASN1CALL ASN1Enc_KeyEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, KeyEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, KeyEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyEncryptionAlgId(KeyEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->content);
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoNC *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoNC(ContentInfoNC *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_DigestAlgorithmIdentifier(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (DigestAlgorithmIdentifier *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiers(DigestAlgorithmIdentifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_DigestAlgorithmIdentifier(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiersNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiersNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (DigestAlgorithmIdentifierNC *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiersNC(DigestAlgorithmIdentifiersNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfos(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SignerInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfos(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SignerInfo *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_SignerInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfos(SignerInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SignerInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SignerInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmBlobs(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmBlobs *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmBlobs(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (DigestAlgorithmBlob *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmBlobs(DigestAlgorithmBlobs *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfosNC(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfosNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfosNC(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfosNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SignerInfosNC_Set *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfosNC(SignerInfosNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAABlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlobs *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SignerInfoWithAABlob(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAABlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SignerInfoWithAABlob *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_SignerInfoWithAABlob(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAABlobs(SignerInfoWithAABlobs *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SignerInfoWithAABlob(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SignerInfoWithAABlob(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAABlob(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlob *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->authenticatedAttributes))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->encryptedDigest))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000001, &(val)->dummyUAAs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAABlob(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlob *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOpenType2(dd, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->authenticatedAttributes))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC(dd, 0x80000001, &(val)->dummyUAAs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAABlob(SignerInfoWithAABlob *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC(&(val)->dummyUAAs);
	}
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAttrBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgIdNC(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->encryptedDigest))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAttrBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOpenType2(dd, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC(dd, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgIdNC(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_AttributesNC(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAttrBlobs(SignerInfoWithAttrBlobs *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC(&(val)->authAttributes);
	}
	ASN1Free_DigestEncryptionAlgIdNC(&(val)->digestEncryptionAlgorithm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AttributesNC(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC2(enc, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgIdNC(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedDigest).length, ((val)->encryptedDigest).value))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AttributesNC2(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC2(dd, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgIdNC(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_AttributesNC2(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithBlobs(SignerInfoWithBlobs *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC2(&(val)->authAttributes);
	}
	ASN1Free_DigestEncryptionAlgIdNC(&(val)->digestEncryptionAlgorithm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AttributesNC2(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_RecipientInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (RecipientInfo *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_RecipientInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientInfos(RecipientInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RecipientInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RecipientInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Enc_ContentEncryptionAlgId(enc, 0, &(val)->contentEncryptionAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->encryptedContent).length, ((val)->encryptedContent).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Dec_ContentEncryptionAlgId(dd, 0, &(val)->contentEncryptionAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->encryptedContent))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val)
{
    if (val) {
	ASN1Free_ContentEncryptionAlgId(&(val)->contentEncryptionAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->encryptedContent);
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->issuerAndSerialNumber))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_IssuerAndSerialNumber(dd, 0, &(val)->issuerAndSerialNumber))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientInfo(RecipientInfo *val)
{
    if (val) {
	ASN1Free_IssuerAndSerialNumber(&(val)->issuerAndSerialNumber);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_SignedAndEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedAndEnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_RecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiers(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfos(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedAndEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedAndEnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_RecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiers(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfos(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedAndEnvelopedData(SignedAndEnvelopedData *val)
{
    if (val) {
	ASN1Free_RecipientInfos(&(val)->recipientInfos);
	ASN1Free_DigestAlgorithmIdentifiers(&(val)->digestAlgorithms);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
	ASN1Free_SignerInfos(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_DigestedData(ASN1encoding_t enc, ASN1uint32_t tag, DigestedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->contentInfo))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestedData(ASN1decoding_t dec, ASN1uint32_t tag, DigestedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->contentInfo))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestedData(DigestedData *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1Free_ContentInfo(&(val)->contentInfo);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val)
{
    if (val) {
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_CertIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, CertIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CertIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, CertIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CertIdentifier(CertIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.subjectKeyIdentifier);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorInfo(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorInfo(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorInfo(OriginatorInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfoNC *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertificatesNC(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CrlsNC(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfoNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertificatesNC(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CrlsNC(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorInfoNC(OriginatorInfoNC *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertificatesNC(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CrlsNC(&(val)->crls);
	}
    }
}

static int ASN1CALL ASN1Enc_CmsRecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_CmsRecipientInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsRecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CmsRecipientInfo *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_CmsRecipientInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsRecipientInfos(CmsRecipientInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CmsRecipientInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CmsRecipientInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_KeyTransRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyTransRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_CertIdentifier(enc, 0, &(val)->rid))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyTransRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyTransRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_CertIdentifier(dd, 0, &(val)->rid))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyTransRecipientInfo(KeyTransRecipientInfo *val)
{
    if (val) {
	ASN1Free_CertIdentifier(&(val)->rid);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_OriginatorPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->publicKey).length, ((val)->publicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString(dd, 0x3, &(val)->publicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorPublicKey(OriginatorPublicKey *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
	ASN1bitstring_free(&(val)->publicKey);
    }
}

static int ASN1CALL ASN1Enc_RecipientEncryptedKeys(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKeys *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RecipientEncryptedKey(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientEncryptedKeys(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKeys *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (RecipientEncryptedKey *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_RecipientEncryptedKey(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientEncryptedKeys(RecipientEncryptedKeys *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RecipientEncryptedKey(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RecipientEncryptedKey(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->keyAttrId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->keyAttrId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->keyAttr);
	}
    }
}

static int ASN1CALL ASN1Enc_MailListKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, MailListKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->kekIdentifier).length, ((val)->kekIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MailListKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, MailListKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->kekIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MailListKeyIdentifier(MailListKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->kekIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_SignedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiers(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->contentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfos(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiers(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->contentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfos(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedData(SignedData *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifiers(&(val)->digestAlgorithms);
	ASN1Free_ContentInfo(&(val)->contentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
	ASN1Free_SignerInfos(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_SignerInfo(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_CertIdentifier(enc, 0, &(val)->sid))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->authenticatedAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgId(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedDigest).length, ((val)->encryptedDigest).value))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Attributes(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfo(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_CertIdentifier(dd, 0, &(val)->sid))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->authenticatedAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgId(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Attributes(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfo(SignerInfo *val)
{
    if (val) {
	ASN1Free_CertIdentifier(&(val)->sid);
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->authenticatedAttributes);
	}
	ASN1Free_DigestEncryptionAlgId(&(val)->digestEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedDigest);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Attributes(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_SignedDataWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignedDataWithBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiersNC(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_ContentInfoNC(enc, 0, &(val)->contentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertificatesNC(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CrlsNC(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfosNC(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedDataWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignedDataWithBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiersNC(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_ContentInfoNC(dd, 0, &(val)->contentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertificatesNC(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CrlsNC(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfosNC(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedDataWithBlobs(SignedDataWithBlobs *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifiersNC(&(val)->digestAlgorithms);
	ASN1Free_ContentInfoNC(&(val)->contentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertificatesNC(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CrlsNC(&(val)->crls);
	}
	ASN1Free_SignerInfosNC(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_EnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, EnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_RecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, EnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_RecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnvelopedData(EnvelopedData *val)
{
    if (val) {
	ASN1Free_RecipientInfos(&(val)->recipientInfos);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_CmsEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, CmsEnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OriginatorInfo(enc, 0x80000000, &(val)->originatorInfo))
	    return 0;
    }
    if (!ASN1Enc_CmsRecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Attributes(enc, 0x80000001, &(val)->unprotectedAttrs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, CmsEnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_OriginatorInfo(dd, 0x80000000, &(val)->originatorInfo))
	    return 0;
    }
    if (!ASN1Dec_CmsRecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Attributes(dd, 0x80000001, &(val)->unprotectedAttrs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsEnvelopedData(CmsEnvelopedData *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OriginatorInfo(&(val)->originatorInfo);
	}
	ASN1Free_CmsRecipientInfos(&(val)->recipientInfos);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Attributes(&(val)->unprotectedAttrs);
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorIdentifierOrKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorIdentifierOrKey *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_OriginatorPublicKey(enc, 0x80000001, &(val)->u.originatorKey))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorIdentifierOrKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorIdentifierOrKey *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 3;
	if (!ASN1Dec_OriginatorPublicKey(dec, 0x80000001, &(val)->u.originatorKey))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorIdentifierOrKey(OriginatorIdentifierOrKey *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.subjectKeyIdentifier);
	    break;
	case 3:
	    ASN1Free_OriginatorPublicKey(&(val)->u.originatorKey);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectKeyIdentifier).length, ((val)->subjectKeyIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->subjectKeyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->subjectKeyIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_MailListRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, MailListRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_MailListKeyIdentifier(enc, 0, &(val)->mlid))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MailListRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, MailListRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_MailListKeyIdentifier(dd, 0, &(val)->mlid))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MailListRecipientInfo(MailListRecipientInfo *val)
{
    if (val) {
	ASN1Free_MailListKeyIdentifier(&(val)->mlid);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_KeyAgreeRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyAgreeRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_OriginatorIdentifierOrKey(enc, 0, &(val)->originator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->ukm).length, ((val)->ukm).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1Enc_RecipientEncryptedKeys(enc, 0, &(val)->recipientEncryptedKeys))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyAgreeRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyAgreeRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_OriginatorIdentifierOrKey(dd0, 0, &(val)->originator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->ukm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1Dec_RecipientEncryptedKeys(dd, 0, &(val)->recipientEncryptedKeys))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyAgreeRecipientInfo(KeyAgreeRecipientInfo *val)
{
    if (val) {
	ASN1Free_OriginatorIdentifierOrKey(&(val)->originator);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->ukm);
	}
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1Free_RecipientEncryptedKeys(&(val)->recipientEncryptedKeys);
    }
}

static int ASN1CALL ASN1Enc_RecipientIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RecipientKeyIdentifier(enc, 0x80000000, &(val)->u.rKeyId))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1Dec_RecipientKeyIdentifier(dec, 0x80000000, &(val)->u.rKeyId))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RecipientIdentifier(RecipientIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1Free_RecipientKeyIdentifier(&(val)->u.rKeyId);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CmsRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfo *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_KeyTransRecipientInfo(enc, 0, &(val)->u.keyTransRecipientInfo))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_KeyAgreeRecipientInfo(enc, 0x80000001, &(val)->u.keyAgreeRecipientInfo))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MailListRecipientInfo(enc, 0x80000002, &(val)->u.mailListRecipientInfo))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CmsRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfo *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_KeyTransRecipientInfo(dec, 0, &(val)->u.keyTransRecipientInfo))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_KeyAgreeRecipientInfo(dec, 0x80000001, &(val)->u.keyAgreeRecipientInfo))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1Dec_MailListRecipientInfo(dec, 0x80000002, &(val)->u.mailListRecipientInfo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CmsRecipientInfo(CmsRecipientInfo *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KeyTransRecipientInfo(&(val)->u.keyTransRecipientInfo);
	    break;
	case 2:
	    ASN1Free_KeyAgreeRecipientInfo(&(val)->u.keyAgreeRecipientInfo);
	    break;
	case 3:
	    ASN1Free_MailListRecipientInfo(&(val)->u.mailListRecipientInfo);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientEncryptedKey(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_RecipientIdentifier(enc, 0, &(val)->rid))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientEncryptedKey(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_RecipientIdentifier(dd, 0, &(val)->rid))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientEncryptedKey(RecipientEncryptedKey *val)
{
    if (val) {
	ASN1Free_RecipientIdentifier(&(val)->rid);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\msgstrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgstrm.cpp
//
//  Contents:   Cryptographic Message Streaming API support
//
//  APIs:       
//
//  History:    20-Feb-97   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"

#define ICMS_NOCRYPT 0

#if (DBG && ICMS_NOCRYPT)
#define CryptEncrypt ICMS_PlainEncrypt
#define CryptDecrypt ICMS_PlainDecrypt

//+-------------------------------------------------------------------------
//  Encrypt a buffer using a NOP algorithm, ie. ciphertext == plaintext
//  Assumes that all but the last block are a multiple of the block
//  size in length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_PlainEncrypt(
    IN HCRYPTKEY    hkeyCrypt,
    IN HCRYPTHASH   hHash,
    IN BOOL         fFinal,
    IN DWORD        dwFlags,
    IN OUT PBYTE    pbData,
    IN OUT PDWORD   pcbData,
    IN DWORD        cbBuf)
{
    BOOL        fRet;
    DWORD       cbBlockLen;
    BOOL        fBlockCipher;
    DWORD       cbCipher;
    DWORD       cbPlain = *pcbData;
    DWORD       cbPad;
    DWORD       i;

    if (!fFinal)
        goto SuccessReturn;

    if (!ICM_GetKeyBlockSize( hkeyCrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;
    if (!fBlockCipher)
        goto SuccessReturn;             // if stream, cipher == plain

    cbCipher  = cbPlain;
    cbCipher += cbBlockLen;
    cbCipher -= cbCipher % cbBlockLen; // make a multiple of block size
    cbPad     = cbCipher - cbPlain;

    if (cbCipher > cbBuf)
        goto BufferTooSmallError;

    // pad the "ciphertext"
    FillMemory( pbData + cbPlain, cbPad, cbPad);
    *pcbData = cbCipher;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
SET_ERROR(BufferTooSmallError, CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Decrypt a buffer using a NOP algorithm, ie. ciphertext == plaintext
//  Assumes all input sizes are multiples of the block size.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_PlainDecrypt(
    IN HCRYPTKEY    hkeyCrypt,
    IN HCRYPTHASH   hHash,
    IN BOOL         fFinal,
    IN DWORD        dwFlags,
    IN OUT PBYTE    pbData,
    IN OUT PDWORD   pcbData)
{
    BOOL        fRet;
    PBYTE       pb;
    DWORD       cbBlockLen;
    BOOL        fBlockCipher;
    DWORD       cbCipher = *pcbData;
    DWORD       cbPlain;
    DWORD       cbPad;

    if (!fFinal)
        goto SuccessReturn;

    if (!ICM_GetKeyBlockSize( hkeyCrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;
    if (!fBlockCipher)
        goto SuccessReturn;             // if stream, cipher == plain

    cbPad = (DWORD)(*(pbData + cbCipher - 1));  // check last byte

    if (cbCipher < cbPad)
        goto CipherTextTooSmallError;

    cbPlain = cbCipher - cbPad;
    *pcbData = cbPlain;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
SET_ERROR(CipherTextTooSmallError,  CRYPT_E_MSG_ERROR)
}
#endif  // (DBG && ICMS_NOCRYPT)


//+-------------------------------------------------------------------------
//  Do a CryptMsgGetParam to a buffer alloc'd by ICM_Alloc
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_AllocGetParam(
    IN HCRYPTMSG    hCryptMsg,
    IN DWORD        dwParamType,
    IN DWORD        dwIndex,
    OUT PBYTE       *ppbData,
    OUT DWORD       *pcbData)
{
    BOOL    fRet;
    DWORD   cb;
    PBYTE   pb = NULL;
    
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            NULL,
            &cb))
        goto GetEncodedSizeError;
    if (NULL == (pb = (PBYTE)ICM_Alloc(cb)))
        goto AllocEncodedError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pb,
            &cb))
        goto GetEncodedError;

    fRet = TRUE;
CommonReturn:
    *ppbData = pb;
    *pcbData = cb;
	return fRet;

ErrorReturn:
    ICM_Free(pb);
    pb = NULL;
    cb = 0;
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetEncodedSizeError)
TRACE_ERROR(AllocEncodedError)
TRACE_ERROR(GetEncodedError)
}


//+-------------------------------------------------------------------------
//  Peel off the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ExtractContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbDER,
    IN DWORD            cbDER,
    OUT PDWORD          pcbContent,
    OUT const BYTE      **ppbContent)
{
    BOOL        fRet;
    LONG        cbSkipped = 0;
    DWORD       cbEntireContent;

    if (!pcmi->fStreamContentExtracted) {
        if (0 > (cbSkipped = Asn1UtilExtractContent(
                                    pbDER,
                                    cbDER,
                                    &cbEntireContent,
                                    ppbContent)))
            goto ExtractContentError;
        pcmi->fStreamContentExtracted = TRUE;
    } else {
        *ppbContent = pbDER;
    }

    *pcbContent = cbDER - cbSkipped;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError, CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Get the next token from the buffer.
//  If the encoding is definite-length, set *pcbContent to be the size of the
//  contents octets.
//
//  Here, a "token" is either identifier/length octets, or the double-NULL
//  terminating an indefinite-length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_GetToken(
    IN PICM_BUFFER      pbuf,
    OUT PDWORD          pdwToken,
    OUT OPTIONAL PDWORD pcbContent)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    DWORD       dwToken;
    LONG        lth;
    DWORD       cbContent = 0;
    const BYTE  *pbContent;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = pbuf->cbUsed - pbuf->cbDead;
    DWORD       cbConsumed = 0;

    if (2 > cbData) {
        dwToken = ICMS_TOKEN_INCOMPLETE;
    } else if (0 == pbData[0] && 0 == pbData[1]) {
        dwToken = ICMS_TOKEN_NULLPAIR;
        cbConsumed = 2;
    } else {
        if (0 > (lth = Asn1UtilExtractContent(
                            pbData,
                            cbData,
                            &cbContent,
                            &pbContent))) {
            if (ASN1UTIL_INSUFFICIENT_DATA != lth)
                goto ExtractContentError;
            dwToken = ICMS_TOKEN_INCOMPLETE;
        } else {
            dwToken = (CMSG_INDEFINITE_LENGTH == cbContent) ?
                      ICMS_TOKEN_INDEFINITE : ICMS_TOKEN_DEFINITE;
            cbConsumed = (DWORD)lth;
        }
    }

    if (ICMS_TOKEN_INCOMPLETE != dwToken)
        pbuf->cbDead += cbConsumed;

    fRet = TRUE;
CommonReturn:
    *pdwToken = dwToken;
    if (pcbContent)
        *pcbContent = cbContent;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    dwToken   = 0;
    cbContent = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError, CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Process incremental content data, for a string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ProcessStringContent(
    IN PICM_BUFFER      pbuf,
    IN OUT PDWORD       paflStream,
    IN OUT PDWORD       pcbPending,
    IN OUT PDWORD       pcLevelIndefiniteInner,
    IN POSTRCALLBACK    postrcbk,
    IN const void       *pvArg)
{
    BOOL        fRet;
    DWORD       dwToken;
    DWORD       cbContent;

    while (TRUE) {
        if (*pcbPending) {
            // *pcbPending bytes need to be processed, so we process
            // as many as possible from the buffer.
            if (!postrcbk( pvArg, pbuf, pcbPending, FALSE))
                goto CallbackError;
        }

        if (0 == *pcbPending) {
            // No bytes currently counted for processing. One of:
            // 1. first time through
            // 2. last time through
            // 3. nested within an indefinite-length encoding
            if (0 == *pcLevelIndefiniteInner) {
                // The first time through, and also when we have processed the
                // entire octet string, we get here. The flag is clear
                // the first time (so we set it after getting a token, which
                // either sets *pcbPending or bumps *pcLevelIndefiniteInner),
                // and set afterwards (so we mark done and bail).
                if (*paflStream & ICMS_PROCESS_CONTENT_BEGUN) {
                    // 2. last time through
                    if (!postrcbk( pvArg, pbuf, pcbPending, TRUE))
                        goto CallbackFinalError;
                    *paflStream |= ICMS_PROCESS_CONTENT_DONE;
                    goto SuccessReturn;                         // All done
                }
            }
            // One of:
            // 1. first time through
            // 3. nested within an indefinite-length encoding
            if (!ICMS_GetToken( pbuf, &dwToken, &cbContent))
                goto GetTokenError;
            switch(dwToken) {
            case ICMS_TOKEN_INDEFINITE: ++*pcLevelIndefiniteInner;  break;
            case ICMS_TOKEN_NULLPAIR:   --*pcLevelIndefiniteInner;  break;
            case ICMS_TOKEN_DEFINITE:   *pcbPending = cbContent;    break;
            case ICMS_TOKEN_INCOMPLETE: goto SuccessReturn;     // need input
            default:                    goto InvalidTokenError;
            }

            *paflStream |= ICMS_PROCESS_CONTENT_BEGUN;
        } else {
            // More definite-length data remains to be copied out, but it
            // is not yet in the buffer.
            break;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidTokenError, CRYPT_E_MSG_ERROR)
TRACE_ERROR(GetTokenError)                     // error already set
TRACE_ERROR(CallbackError)                     // error already set
TRACE_ERROR(CallbackFinalError)                // error already set
}


//+-------------------------------------------------------------------------
//  Queue data to the buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_QueueToBuffer(
    IN PICM_BUFFER      pbuf,
    IN PBYTE            pbData,
    IN DWORD            cbData)
{
    BOOL            fRet;
    DWORD           cbNewSize;
    DWORD           cbNewUsed;

    if (0 == cbData)
        goto SuccessReturn;

    if (pbuf->pbData && pbuf->cbDead) {
        // Move the still-active bytes up to the front of the buffer.
        // NB- Might overlap, so use MoveMemory.
        MoveMemory(
                pbuf->pbData,
                pbuf->pbData + pbuf->cbDead,
                pbuf->cbUsed - pbuf->cbDead);
        pbuf->cbUsed -= pbuf->cbDead;
        pbuf->cbDead  = 0;
    }

    for (cbNewUsed=pbuf->cbUsed + cbData, cbNewSize=pbuf->cbSize;
            cbNewUsed > cbNewSize;
            cbNewSize += ICM_BUFFER_SIZE_INCR)
        ;
    if (cbNewSize > pbuf->cbSize) {
        if (NULL == (pbuf->pbData=(PBYTE)ICM_ReAlloc( pbuf->pbData, cbNewSize)))
            goto ReAllocBufferError;
        pbuf->cbSize = cbNewSize;
    }

    CopyMemory( pbuf->pbData + pbuf->cbUsed, pbData, cbData);
    pbuf->cbUsed += cbData;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ReAllocBufferError)         // error already set
}


//+-------------------------------------------------------------------------
//  Copy out or queue some data eventually destined for the callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_Output(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                    fRet;
    PCMSG_STREAM_INFO       pcsi            = pcmi->pStreamInfo;
    PFN_CMSG_STREAM_OUTPUT  pfnStreamOutput = pcsi->pfnStreamOutput;
    void                    *pvArg          = pcsi->pvArg;
    PICM_BUFFER             pbuf            = &pcmi->bufOutput;

    if (pcmi->fStreamCallbackOutput) {
        if (pbuf->cbUsed) {
            // Copy out the queued data
            if (!pfnStreamOutput( pvArg, pbuf->pbData, pbuf->cbUsed, FALSE))
                goto OutputBufferError;
            pbuf->cbUsed = 0;
        }
        if (cbData || fFinal) {
            if (!pfnStreamOutput( pvArg, pbData, cbData, fFinal))
                goto OutputError;
        }
    } else {
        if (!ICMS_QueueToBuffer( pbuf, pbData, cbData))
            goto QueueOutputError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputBufferError)      // error already set
TRACE_ERROR(QueueOutputError)       // error already set
TRACE_ERROR(OutputError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the pair of NULLs following the contents octets of an indefinite-
//  length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputNullPairs(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            cPairs,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    BYTE                abNULL[8*2];    ZEROSTRUCT(abNULL);

    if (cPairs > (sizeof(abNULL)/2))
        goto CountOfNullPairsTooLargeError;

    if (!ICMS_Output( pcmi, abNULL, cPairs * 2, fFinal))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(CountOfNullPairsTooLargeError, CRYPT_E_MSG_ERROR)
TRACE_ERROR(OutputError)                        // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the encoding preceding the contents octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BYTE             bTag,
    IN DWORD            cbData)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    BYTE                    abPrefix[6];
    DWORD                   cbPrefix;

    abPrefix[0] = bTag;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abPrefix[1] = ICM_LENGTH_INDEFINITE;
        cbPrefix = 1;
    } else {
        cbPrefix = sizeof(abPrefix) - 1;
        ICM_GetLengthOctets( cbData, abPrefix + 1, &cbPrefix);
    }

    if (!ICMS_Output( pcmi, abPrefix, cbPrefix + 1, FALSE))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the ContentInfo encoding preceding
//  the content's content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefixContentInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN LPSTR            pszContentType,
    IN DWORD            cbData,
    IN DWORD            dwFlags = 0)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;
    ObjectID                ossObjID;
    BYTE                    abContentInfo[6];
    DWORD                   cbContentInfo;
    BYTE                    abContent[6];
    DWORD                   cbContent = 0;
    BYTE                    abContentOctetString[6];
    DWORD                   cbContentOctetString = 0;
    DWORD                   cbSize = cbData;

    if (dwFlags & CMSG_DETACHED_FLAG) {
        // NoContent
        if (CMSG_INDEFINITE_LENGTH != cbData)
            cbSize = 0;
    } else {
        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                ) {
            // The content is not already encoded, so encode it as an octet string.
            abContentOctetString[0] = ICM_TAG_OCTETSTRING;
            if (CMSG_INDEFINITE_LENGTH == cbData) {
                abContentOctetString[0] |= ICM_TAG_CONSTRUCTED;
                abContentOctetString[1] = ICM_LENGTH_INDEFINITE;
                cbContentOctetString = 1;
            } else {
                cbContentOctetString = sizeof(abContentOctetString) - 1;
                ICM_GetLengthOctets(
                            cbData,
                            abContentOctetString + 1,
                            &cbContentOctetString);
                cbSize += 1 + cbContentOctetString;
            }
        }

        // content, [0] EXPLICIT
        abContent[0] = ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0;
        if (CMSG_INDEFINITE_LENGTH == cbData) {
            abContent[1] = ICM_LENGTH_INDEFINITE;
            cbContent = 1;
        } else {
            cbContent = sizeof(abContent) - 1;
            ICM_GetLengthOctets( cbSize, abContent + 1, &cbContent);
            cbSize += 1 + cbContent;
        }
    }

    // contentType
    ossObjID.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pszContentType ? pszContentType : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeObjectIdentifierError;
    cbSize += cbEncoded;

    abContentInfo[0] = ICM_TAG_SEQ;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abContentInfo[1] = ICM_LENGTH_INDEFINITE;
        cbContentInfo = 1;
    } else {
        cbContentInfo = sizeof(abContentInfo) - 1;
        ICM_GetLengthOctets( cbSize, abContentInfo + 1, &cbContentInfo);
    }

    if (!ICMS_Output( pcmi, abContentInfo, cbContentInfo + 1, FALSE))
        goto OutputContentInfoError;
    if (!ICMS_Output( pcmi, pbEncoded, cbEncoded, FALSE))
        goto OutputContentTypeError;
    if (0 == (dwFlags & CMSG_DETACHED_FLAG)) {
        if (!ICMS_Output( pcmi, abContent, cbContent + 1, FALSE))
            goto OutputContentError;
        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                ) {
            if (!ICMS_Output( 
                    pcmi,
                    abContentOctetString,
                    cbContentOctetString + 1,
                    FALSE))
                goto OutputContentOctetStringError;
        }
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(ConvToObjectIdentifierError)        // error already set
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputContentTypeError)             // error already set
TRACE_ERROR(OutputContentError)                 // error already set
TRACE_ERROR(OutputContentOctetStringError)      // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the EncryptedContentInfo encoding preceding
//  the content's content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefixEncryptedContentInfo(
    IN PCRYPT_MSG_INFO      pcmi,
    IN LPSTR                pszContentType,
    IN AlgorithmIdentifier  *poaiContentEncryption,
    IN DWORD                cbData)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncodedContentType = NULL;
    DWORD                   cbEncodedContentType;
    PBYTE                   pbEncodedContentEncryptionAlgorithm = NULL;
    DWORD                   cbEncodedContentEncryptionAlgorithm;
    ObjectID                ossObjID;
    BYTE                    abEncryptedContentInfo[6];
    DWORD                   cbEncryptedContentInfo;
    BYTE                    abEncryptedContent[6];
    DWORD                   cbEncryptedContent;
    DWORD                   cbSize = 0;
    DWORD                   cbCipher = cbData;
    DWORD                   cbBlockSize = pcmi->cbBlockSize;

    if (pcmi->fBlockCipher && 0 < cbCipher) {
        cbCipher += cbBlockSize;
        cbCipher -= cbCipher % cbBlockSize;
    }

    // encryptedContent, [0] IMPLICIT
    abEncryptedContent[0] = ICM_TAG_CONTEXT_0;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abEncryptedContent[0] |= ICM_TAG_CONSTRUCTED;
        abEncryptedContent[1] = ICM_LENGTH_INDEFINITE;
        cbEncryptedContent = 1;
    } else {
        // NOTE: for nonData, either encapsulated or the cbData excludes
        // the outer tag and length octets.
        cbEncryptedContent = sizeof(abEncryptedContent) - 1;
        ICM_GetLengthOctets( cbCipher, abEncryptedContent + 1, &cbEncryptedContent);
        cbSize = 1 + cbEncryptedContent + cbCipher;
    }

    // contentType
    ossObjID.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pszContentType ? pszContentType : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncodedContentType,
            &cbEncodedContentType)))
        goto EncodeObjectIdentifierError;
    cbSize += cbEncodedContentType;

    // contentEncryptionAlgorithm
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            poaiContentEncryption,
            AlgorithmIdentifier_PDU,
            &pbEncodedContentEncryptionAlgorithm,
            &cbEncodedContentEncryptionAlgorithm)))
        goto EncodeContentEncryptionAlgorithmError;
    cbSize += cbEncodedContentEncryptionAlgorithm;

    // EncryptedContentInfo
    abEncryptedContentInfo[0] = ICM_TAG_SEQ;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abEncryptedContentInfo[1] = ICM_LENGTH_INDEFINITE;
        cbEncryptedContentInfo = 1;
    } else {
        cbEncryptedContentInfo = sizeof(abEncryptedContentInfo) - 1;
        ICM_GetLengthOctets(
                cbSize,
                abEncryptedContentInfo + 1,
                &cbEncryptedContentInfo);
    }

    // Queue the encoded header
    if (!ICMS_Output(
                pcmi,
                abEncryptedContentInfo,
                cbEncryptedContentInfo + 1,
                FALSE))
        goto OutputContentInfoError;
    if (!ICMS_Output(
                pcmi,
                pbEncodedContentType,
                cbEncodedContentType,
                FALSE))
        goto OutputContentTypeError;
    if (!ICMS_Output(
                pcmi,
                pbEncodedContentEncryptionAlgorithm,
                cbEncodedContentEncryptionAlgorithm,
                FALSE))
        goto OutputContentEncryptionAlgorithmError;
    if (!ICMS_Output(
                pcmi,
                abEncryptedContent,
                cbEncryptedContent + 1,
                FALSE))
        goto OutputEncryptedContentError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentType);
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentEncryptionAlgorithm);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeContentEncryptionAlgorithmError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(ConvToObjectIdentifierError)            // error already set
TRACE_ERROR(OutputContentInfoError)                 // error already set
TRACE_ERROR(OutputContentTypeError)                 // error already set
TRACE_ERROR(OutputContentEncryptionAlgorithmError)  // error already set
TRACE_ERROR(OutputEncryptedContentError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the encoding of an OSS type.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncoded(
    IN PCRYPT_MSG_INFO  pcmi,
    IN int              iPDU,
    IN OPTIONAL BYTE    bTag,
    IN PVOID            pv,
    IN BOOL             fFinal)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            pv,
            iPDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeError;

    if (bTag)
        pbEncoded[0] = bTag;         // poke in the right tag

    if (!ICMS_Output(pcmi, pbEncoded, cbEncoded, fFinal))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(OutputError)                // error already set
}


//+-------------------------------------------------------------------------
//  Create the buffer for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_CreateEnvelopedBuffer(
    IN PCRYPT_MSG_INFO  pcmi)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PBYTE       pbBuffer = NULL;
    DWORD       cbBuffer;
    DWORD       cbAlloc;
    DWORD       cbBlockSize;
    BOOL        fBlockCipher;
    PICM_BUFFER pbuf = &pcmi->bufCrypt;

    if (!ICM_GetKeyBlockSize(
                pcmi->hkeyContentCrypt,
                &cbBlockSize,
                &fBlockCipher))
        goto GetEncryptBlockSizeError;

    pcmi->cbBlockSize  = cbBlockSize;
    pcmi->fBlockCipher = fBlockCipher;

    cbBuffer = min( cbBlockSize * CMSGP_STREAM_CRYPT_BLOCK_COUNT,
                    CMSGP_STREAM_MAX_ENCRYPT_BUFFER);
    if (fBlockCipher) {
        cbBuffer += cbBlockSize;
        cbBuffer -= cbBuffer % cbBlockSize; // make a multiple of block size
    }

    // Add one block for growth during encrypt, and to save during decrypt.
    cbAlloc = cbBuffer + 1 * cbBlockSize;
    // Block ciphers pad the ciphertext, and if the plaintext is a
    // multiple of the block size the padding is one block.
    if (NULL == (pbBuffer = (PBYTE)ICM_Alloc( cbAlloc)))
        goto AllocBufferError;
    pbuf->pbData = pbBuffer;
    pbuf->cbSize = cbBuffer;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbBuffer);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetEncryptBlockSizeError)       // error already set
TRACE_ERROR(AllocBufferError)               // error already set
}




//+-------------------------------------------------------------------------
//  Encode and copy out the part of the data message up to the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeData(
    IN PCRYPT_MSG_INFO          pcmi)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbData = pcmi->pStreamInfo->cbContent;

    if (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG) {
        BYTE bTag;

        if (CMSG_INDEFINITE_LENGTH == cbData)
            bTag = ICM_TAG_OCTETSTRING | ICM_TAG_CONSTRUCTED;
        else
            bTag = ICM_TAG_OCTETSTRING;

        // Output octet string
        if (!ICMS_OutputEncodedPrefix(
                    pcmi,
                    bTag,
                    cbData))
            goto OutputOctetStringError;
    } else {
        // Output ContentInfo
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    NULL,
                    cbData))
            goto OutputContentInfoError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputOctetStringError)             // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the data message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    DWORD       cNullPairs;

    pcmi->fStreamCallbackOutput = TRUE;                 // Enable the callback
    if (!fDefinite) {
        // The content is an indefinite-length octet string encoded by us,
        // so make each output chunk definite-length.
        if (!ICMS_OutputEncodedPrefix(
                    pcmi,
                    ICM_TAG_OCTETSTRING,
                    cbData))
            goto OutputOctetStringError;
    }
    if (!ICMS_Output( pcmi, pbData, cbData, fFinal && fDefinite))
        goto OutputError;
        
    if (fFinal && !fDefinite) {
        // End of indefinite-length encoding, so emit some NULL pairs
        cNullPairs = 1;                 // content
        if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
            cNullPairs += 2;
        if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
            goto OutputNullPairsError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputOctetStringError)             // error already set
TRACE_ERROR(OutputError)                        // error already set
TRACE_ERROR(OutputNullPairsError)               // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the signed message up to the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeSignedData(
    IN PCRYPT_MSG_INFO          pcmi,
    IN PCMSG_SIGNED_ENCODE_INFO psmei)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    SignedData  *psd = (SignedData *)pcmi->pvMsg;
    DWORD       cbData = pcmi->pStreamInfo->cbContent;
    LPSTR       pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD       cbSigned;
    DWORD       cbSignedDataContent;

    // Output ContentInfo, if appropriate
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        cbSigned            = CMSG_INDEFINITE_LENGTH;
        cbSignedDataContent = CMSG_INDEFINITE_LENGTH;
    } else {
        if (INVALID_ENCODING_SIZE == (cbSigned = ICM_LengthSigned(
                psmei,
                pcmi->dwFlags,
                pszInnerContentObjID,
                cbData,
                &cbSignedDataContent)))
            goto LengthSignedError;
    }
    if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    szOID_RSA_signedData,
                    cbSigned))
            goto OutputContentInfoError;
    }
    if (!ICMS_OutputEncodedPrefix(
                pcmi,
                ICM_TAG_SEQ,
                cbSignedDataContent))
        goto OutputSignedDataError;

    // version
    if (!ICMS_OutputEncoded(
                pcmi,
                IntegerType_PDU,
                0,                          // bTag
                &psd->version,
                FALSE))
        goto OutputIntegerError;

    // digestAlgorithms
    if (!ICMS_OutputEncoded(
                pcmi,
                AlgorithmIdentifiers_PDU,
                0,                          // bTag
                &psd->digestAlgorithms,
                FALSE))
        goto OutputAlgorithmIdentifiersError;

    // contentInfo
    if (!ICMS_OutputEncodedPrefixContentInfo(
                pcmi,
                pcmi->pszInnerContentObjID,
                cbData,
                pcmi->dwFlags))
        goto OutputInnerContentInfoError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(LengthSignedError)                  // error already set
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputSignedDataError)              // error already set
TRACE_ERROR(OutputIntegerError)                 // error already set
TRACE_ERROR(OutputAlgorithmIdentifiersError)    // error already set
TRACE_ERROR(OutputInnerContentInfoError)        // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the signed message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    DWORD               dwError = ERROR_SUCCESS;
    SignedData          *psd = (SignedData *)pcmi->pvMsg;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;
    BOOL                fDefinite = (CMSG_INDEFINITE_LENGTH != pcsi->cbContent);
    DWORD               cNullPairs;

    if (pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
            && 0 == (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
            ) {
        if (0 == (pcmi->aflStream & ICMS_PROCESS_CONTENT_DONE)) {
            if (!ICMS_HashContent( pcmi, pbData, cbData))
                goto HashContentError;
        }
    } else {
        if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
            goto UpdateDigestError;
    }

    pcmi->fStreamCallbackOutput = TRUE;             // Enable the callback
    if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) {
        if (!fDefinite && (NULL == pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
                || (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                )) {
            // The content is an indefinite-length octet string encoded by us,
            // so make each output chunk definite-length.
            if (!ICMS_OutputEncodedPrefix(
                        pcmi,
                        ICM_TAG_OCTETSTRING,
                        cbData))
                goto OutputOctetStringError;
        }
        if (!ICMS_Output( pcmi, pbData, cbData, FALSE))
            goto OutputError;
    }
    // else
    //  detached => don't output the detached content to be hashed

    if (fFinal) {
        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;                 // ContentInfo
            if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) {
                cNullPairs++;               // [0] EXPLICIT
                if (NULL == pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
                        || (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                        )
                    cNullPairs++;       // We did the octet string encoding
            }
            // else
            //  detached => no content ([0] EXPLICIT)

            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, FALSE))
                goto OutputNullPairsError;
        }

        if ((psd->bit_mask & certificates_present) &&
                    !ICMS_OutputEncoded(
                            pcmi,
                            SetOfAny_PDU,
                            ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0,
                            &psd->certificates,
                            FALSE))
            goto OutputCertsError;

        if ((psd->bit_mask & crls_present) &&
                    !ICMS_OutputEncoded(
                            pcmi,
                            SetOfAny_PDU,
                            ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1,
                            &psd->crls,
                            FALSE))
            goto OutputCrlsError;

#ifdef CMS_PKCS7
        if (pcmi->rgSignerEncodeDataInfo) {
            if (!ICM_FillSignerEncodeEncryptedDigests(
                            pcmi,
                            fDefinite))         // fMaxLength
                    goto FillSignerEncodeEncryptedDigestsError;
        }
#else
        if (pcmi->pHashList) {
            if (!ICM_FillSignerEncryptedDigest(
                            psd->signerInfos.value,
                            pcmi->pszInnerContentObjID,
                            pcmi->pHashList->Head(),
                            pcmi->dwKeySpec,
                            fDefinite))         // fMaxLength
                goto FillSignerEncryptedDigestError;
        }
#endif  // CMS_PKCS7

        if (!ICMS_OutputEncoded(
                            pcmi,
                            SignerInfos_PDU, 
                            0,                      // bTag
                            &psd->signerInfos,
                            fDefinite))
            goto OutputSignerInfosError;

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;         // SignedData
            if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
                cNullPairs += 2;
            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
                goto OutputNullPairsError;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(HashContentError)                   // error already set
TRACE_ERROR(UpdateDigestError)                  // error already set
TRACE_ERROR(OutputOctetStringError)             // error already set
TRACE_ERROR(OutputError)                        // error already set
TRACE_ERROR(OutputCertsError)                   // error already set
TRACE_ERROR(OutputCrlsError)                    // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(FillSignerEncodeEncryptedDigestsError)  // error already set
#else
TRACE_ERROR(FillSignerEncryptedDigestError)     // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(OutputSignerInfosError)             // error already set
TRACE_ERROR(OutputNullPairsError)               // error already set
}

//+-------------------------------------------------------------------------
//  Encode and copy out the part of the enveloped message up to the inner
//  content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeEnvelopedData(
    IN PCRYPT_MSG_INFO              pcmi,
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
#ifdef CMS_PKCS7
    CmsEnvelopedData   *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
    EnvelopedData   *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    DWORD           cbData = pcmi->pStreamInfo->cbContent;
    LPSTR           pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD           cbEnveloped;
    DWORD           cbEnvelopedDataContent;

    if (!ICMS_CreateEnvelopedBuffer( pcmi))
        goto CreateEnvelopedBufferError;

    // Output ContentInfo, if appropriate
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        cbEnveloped            = CMSG_INDEFINITE_LENGTH;
        cbEnvelopedDataContent = CMSG_INDEFINITE_LENGTH;
    } else {
        // NOTE: for nonData, either encapsulated or cbData excludes the
        // outer tag and length octets.

        if (INVALID_ENCODING_SIZE == (cbEnveloped = ICM_LengthEnveloped(
                pemei,
                pcmi->dwFlags,
                pszInnerContentObjID,
                cbData,
                &cbEnvelopedDataContent)))
            goto LengthEnvelopedError;
    }
    if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    szOID_RSA_envelopedData,
                    cbEnveloped))
            goto OutputContentInfoError;
    }
    if (!ICMS_OutputEncodedPrefix(
                pcmi,
                ICM_TAG_SEQ,
                cbEnvelopedDataContent))
        goto OutputEnvelopedDataError;

    // version
    if (!ICMS_OutputEncoded(
                pcmi,
                IntegerType_PDU,
                0,                          // bTag
                &ped->version,
                FALSE))
        goto OutputIntegerError;

#ifdef CMS_PKCS7
    // originatorInfo OPTIONAL
    if (ped->bit_mask & originatorInfo_present) {
        if (!ICMS_OutputEncoded(
                pcmi,
                OriginatorInfo_PDU,
                ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0,
                &ped->originatorInfo,
                FALSE))
            goto OutputOriginatorInfoError;
    }
#endif  // CMS_PKCS7

    // recipientInfos
    if (!ICMS_OutputEncoded(
                pcmi,
#ifdef CMS_PKCS7
                CmsRecipientInfos_PDU,
#else
                RecipientInfos_PDU,
#endif  // CMS_PKCS7
                0,                          // bTag
                &ped->recipientInfos,
                FALSE))
        goto OutputRecipientInfosError;

    // encryptedContentInfo
    if (!ICMS_OutputEncodedPrefixEncryptedContentInfo(
                pcmi,
                pcmi->pszInnerContentObjID,
                &ped->encryptedContentInfo.contentEncryptionAlgorithm,
                cbData))
        goto OutputInnerContentInfoError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEnvelopedBufferError)     // error already set
TRACE_ERROR(LengthEnvelopedError)           // error already set
TRACE_ERROR(OutputContentInfoError)         // error already set
TRACE_ERROR(OutputEnvelopedDataError)       // error already set
TRACE_ERROR(OutputIntegerError)             // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(OutputOriginatorInfoError)      // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(OutputRecipientInfosError)      // error already set
TRACE_ERROR(OutputInnerContentInfoError)    // error already set
}

//+-------------------------------------------------------------------------
//  Encrypt and copy out some bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_EncodeEncryptAndOutput(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlainOrg,
    IN DWORD            cbPlainOrg,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    BOOL        fBlockCipher = pcmi->fBlockCipher;
    PICM_BUFFER pbufCrypt = &pcmi->bufCrypt;
    PBYTE       pbPlain;
    DWORD       cbPlainRemain;
    DWORD       cb;

    for (cbPlainRemain = cbPlainOrg, pbPlain = (PBYTE)pbPlainOrg;
            cbPlainRemain > 0;) {
        cb = min( cbPlainRemain, pbufCrypt->cbSize - pbufCrypt->cbUsed); // must fit
        CopyMemory(
                pbufCrypt->pbData  + pbufCrypt->cbUsed,
                pbPlain,
                cb);
        pbufCrypt->cbUsed  += cb;
        pbPlain            += cb;
        cbPlainRemain      -= cb;
        if (pbufCrypt->cbSize == pbufCrypt->cbUsed) {
            // Encrypt and copy out the buffer
            cb = pbufCrypt->cbSize;
            if (fBlockCipher) {
                // Leave the last block
                cb -= pcmi->cbBlockSize;
            }
            if (!CryptEncrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        FALSE,                          // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb,
                        pbufCrypt->cbSize + pcmi->cbBlockSize))
                goto EncryptError;
            if (!fDefinite) {
                // The ciphertext is indefinite-length, so make each
                // output chunk definite-length.
                if (!ICMS_OutputEncodedPrefix(
                            pcmi,
                            ICM_TAG_OCTETSTRING,
                            cb))
                    goto OutputOctetStringError;
            }
            if (!ICMS_Output(
                        pcmi,
                        pbufCrypt->pbData,
                        cb,
                        FALSE))                         // fFinal
                goto OutputError;

            if (fBlockCipher) {
                // Move the last block to the beginning of the buffer
                // and reset the count to start after this block.
                // Since we are sure the src and dst do not overlap,
                // use CopyMemory (faster than MoveMemory).
                cb = pbufCrypt->cbSize - pcmi->cbBlockSize;
                CopyMemory(
                    pbufCrypt->pbData,
                    pbufCrypt->pbData + cb,
                    pcmi->cbBlockSize);
                pbufCrypt->cbUsed = pcmi->cbBlockSize;
            } else {
                pbufCrypt->cbUsed = 0;
            }
        }
    }

    if (fFinal) {
#ifdef CMS_PKCS7
        CmsEnvelopedData *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7

        if (cb = pbufCrypt->cbUsed) {
            if (!CryptEncrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        TRUE,                           // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb,
                        pbufCrypt->cbSize + pcmi->cbBlockSize))
                goto FinalEncryptError;
        }
        if (!fDefinite && cb) {
            // The ciphertext is indefinite-length, so make each
            // output chunk definite-length.
            if (!ICMS_OutputEncodedPrefix(
                        pcmi,
                        ICM_TAG_OCTETSTRING,
                        cb))
                goto OutputOctetStringError;
        }
        if (!ICMS_Output(
                    pcmi,
                    pbufCrypt->pbData,
                    cb,
                    fDefinite &&
                        0 == (ped->bit_mask & unprotectedAttrs_present) // fFinal
                    ))
            goto FinalOutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptError)           // error already set
TRACE_ERROR(FinalEncryptError)      // error already set
TRACE_ERROR(OutputOctetStringError) // error already set
TRACE_ERROR(OutputError)            // error already set
TRACE_ERROR(FinalOutputError)       // error already set
}


//+-------------------------------------------------------------------------
//  Encode encrypt callback for octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_EncryptCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (!ICMS_EncodeEncryptAndOutput(
                (PCRYPT_MSG_INFO)pvArg,
                pbData,
                cbData,
                fFinal))
        goto EncodeEncryptAndOutputError;

    pbuf->cbDead += cbData;
    *pcbPending  -= cbData;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeEncryptAndOutputError)        // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the enveloped message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlain,
    IN DWORD            cbPlain,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    DWORD       cNullPairs;

    if (!pcmi->fStreamCallbackOutput) {
        pcmi->fStreamCallbackOutput = TRUE;             // Enable the callback
        if (!ICMS_Output( pcmi, NULL, 0, FALSE))        // Flush the header
            goto FlushOutputError;
    }

    if (pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
            && 0 == (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
            ) {
        if (!ICMS_QueueToBuffer( &pcmi->bufEncode, (PBYTE)pbPlain, cbPlain))
            goto QueueToBufferError;

        if (!ICMS_ProcessStringContent(
                    &pcmi->bufEncode,
                    &pcmi->aflStream,
                    &pcmi->cbDefiniteRemain,
                    &pcmi->cLevelIndefiniteInner,
                    ICMS_EncryptCallback,
                    pcmi))
            goto ProcessContentError;
    } else {
        if (!ICMS_EncodeEncryptAndOutput(
                    pcmi,
                    pbPlain,
                    cbPlain,
                    fFinal))
            goto EncodeEncryptAndOutputError;
    }


    if (fFinal) {
#ifdef CMS_PKCS7
        CmsEnvelopedData *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs,
            // one each for encryptedContent, encryptedContentInfo
            if (!ICMS_OutputNullPairs( pcmi, 2, FALSE))
                goto OutputNullPairsError;
        }

        if (ped->bit_mask & unprotectedAttrs_present) {
#ifdef CMS_PKCS7
            if (!ICMS_OutputEncoded(
                    pcmi,
                    Attributes_PDU,
                    ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1,
                    &ped->unprotectedAttrs,
                    fDefinite))         // fFinal
                goto OutputAttributesError;
#endif  // CMS_PKCS7
        }

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;         // EnvelopedData
            if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
                cNullPairs += 2;
            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
                goto OutputNullPairsError;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FlushOutputError)               // error already set
TRACE_ERROR(QueueToBufferError)             // error already set
TRACE_ERROR(ProcessContentError)            // error already set
TRACE_ERROR(EncodeEncryptAndOutputError)    // error already set
TRACE_ERROR(OutputNullPairsError)           // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(OutputAttributesError)          // error already set
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Decode a PDU from the decode buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePDU(
    IN PCRYPT_MSG_INFO  pcmi,
    IN ASN1decoding_t   pDec,
    IN ASN1uint32_t     pdunum,
    OUT PVOID           *ppvPDU,
    OUT OPTIONAL PDWORD pcbConsumed = NULL)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    PVOID               pvPDU = NULL;
    DWORD               cbBufSizeOrg;
    PBYTE               pbData = pbuf->pbData + pbuf->cbDead;
    DWORD               cbData = pbuf->cbUsed - pbuf->cbDead;

#if DBG && defined(OSS_CRYPT_ASN1)
    DWORD   dwDecodingFlags;

    dwDecodingFlags = ossGetDecodingFlags((OssGlobal *) pDec);
    ossSetDecodingFlags( (OssGlobal *) pDec, RELAXBER); // turn off squirties
#endif

    cbBufSizeOrg = cbData;
    if (0 != (Asn1Err = PkiAsn1Decode2(
            pDec,
            &pvPDU,
            pdunum,
            &pbData,
            &cbData))) {
        if (ASN1_ERR_EOD != Asn1Err)
            goto DecodeError;
    }
#if DBG && defined(OSS_CRYPT_ASN1)
    ossSetDecodingFlags( (OssGlobal *) pDec, dwDecodingFlags);     // restore
#endif

    if (ASN1_ERR_EOD == Asn1Err ||
            (cbData > pbuf->cbUsed - pbuf->cbDead)) {
        PkiAsn1FreeInfo(pDec, pdunum, pvPDU);
        pvPDU = NULL;
        cbData = cbBufSizeOrg;
    }
    pbuf->cbDead += cbBufSizeOrg - cbData;
    if (pcbConsumed)
        *pcbConsumed = cbBufSizeOrg - cbData;

    fRet = TRUE;
CommonReturn:
    *ppvPDU = pvPDU;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (pcbConsumed)
        *pcbConsumed = 0;
    pvPDU = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Decode a ContentInfo prefix
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixContentInfo(
    IN PCRYPT_MSG_INFO      pcmi,
    OUT ObjectIdentifierType **ppooidContentType,
    IN OUT PDWORD           pcTrailingNullPairs,
    IN OUT PDWORD           pafl,
    OUT BOOL                *pfNoContent)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    DWORD                   dwToken;

    // ContentInfo sequence, step into it
    if (0 == (*pafl & ICMS_DECODED_CONTENTINFO_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, &pcmi->cbContentInfo))
            goto ContentInfoGetTokenError;
        switch (dwToken) {
        case ICMS_TOKEN_INDEFINITE:     ++*pcTrailingNullPairs; break;
        case ICMS_TOKEN_DEFINITE:                               break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        *pafl |= ICMS_DECODED_CONTENTINFO_SEQ;
    }

    // contentType, decode it
    if (NULL == *ppooidContentType) {
        DWORD cbConsumed;

        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                ObjectIdentifierType_PDU,
                (void **)ppooidContentType,
                &cbConsumed))
            goto DecodeContentTypeError;

        if (NULL != *ppooidContentType &&
                CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo &&
                cbConsumed == pcmi->cbContentInfo) {
            // Only has contentType. The optional content has
            // been omitted.
            *pfNoContent = TRUE;
            *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
            goto SuccessReturn;
        }
    }
    if (NULL == *ppooidContentType)
        goto SuccessReturn;         // not enough data

    // [0] EXPLICIT, step into it
    if (0 == (*pafl & ICMS_DECODED_CONTENTINFO_CONTENT)) {
        if (CMSG_INDEFINITE_LENGTH == pcmi->cbContentInfo) {
            PICM_BUFFER pbuf = &pcmi->bufDecode;

            if (pbuf->cbUsed > pbuf->cbDead) {
                // Check for trailing Null Pairs (00, 00)
                if (ICM_TAG_NULL == *(pbuf->pbData + pbuf->cbDead)) {
                    // Only has contentType. The optional content has
                    // been omitted.
                    *pfNoContent = TRUE;
                    *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
                    goto SuccessReturn;
                }
            } else
                goto SuccessReturn;         // not enough data
        }

        
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto ContentGetTokenError;
        switch (dwToken) {
        case ICMS_TOKEN_INDEFINITE:     ++*pcTrailingNullPairs; break;
        case ICMS_TOKEN_DEFINITE:                               break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        *pfNoContent = FALSE;
        *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeContentTypeError)             // error already set
TRACE_ERROR(ContentGetTokenError)               // error already set
SET_ERROR(InvalidTokenError, CRYPT_E_MSG_ERROR)
TRACE_ERROR(ContentInfoGetTokenError)           // error already set
}


//+-------------------------------------------------------------------------
//  Consume the NULL pairs which terminate the indefinite-length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ConsumeTrailingNulls(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT PDWORD       pcNullPairs,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    DWORD       dwToken;

    for (; *pcNullPairs; (*pcNullPairs)--) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto GetTokenError;
        if ((ICMS_TOKEN_INCOMPLETE == dwToken) && !fFinal)
            goto SuccessReturn;
        if (ICMS_TOKEN_NULLPAIR != dwToken)
            goto WrongTokenError;
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetTokenError)                      // error already set
SET_ERROR(WrongTokenError, CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL                fRet;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeTrailingNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;

    if (fFinal && (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead))
        goto ExcessDataError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeTrailingNullsError)          // error already set
SET_ERROR(ExcessDataError, CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for a signed message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixSigned(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PSIGNED_DATA_INFO   psdi = pcmi->psdi;
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    CertificatesNC      *pCertificates = NULL;
    CrlsNC              *pCrls = NULL;
    SignerInfosNC       *pSignerInfos = NULL;
    Any                 *pAny;
    DWORD               i;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cInnerNullPairs, fFinal))
        goto ConsumeInnerNullsError;
    if (pcmi->cInnerNullPairs)
        goto SuccessReturn;

    // certificates
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CERTIFICATES)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_0 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [0] IMPLICIT indicating certificates.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        CertificatesNC_PDU,
                        (void **)&pCertificates))
                    goto DecodeCertificatesError;
                if (pCertificates) {
                    for (i=pCertificates->count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pCertificates->certificates;
#else
                                pAny=pCertificates->value;
#endif  // OSS_CRYPT_ASN1
                            i>0;
                            i--, pAny++) {
                        if (!ICM_InsertTailBlob( psdi->pCertificateList, pAny))
                            goto CertInsertTailBlobError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_SIGNED_CERTIFICATES;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_CONSTRUCTED_CONTEXT_0;
                }
            } else {
                // Certificates not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_SIGNED_CERTIFICATES;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CERTIFICATES))
        goto SuccessReturn;


    // crls
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CRLS)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_1 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [1] IMPLICIT indicating crls.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        CrlsNC_PDU,
                        (void **)&pCrls))
                    goto DecodeCrlsError;
                if (pCrls) {
                    for (i=pCrls->count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pCrls->crls;
#else
                                pAny=pCrls->value;
#endif  // OSS_CRYPT_ASN1
                            i>0;
                            i--, pAny++) {
                        if (!ICM_InsertTailBlob( psdi->pCrlList, pAny))
                            goto CrlInsertTailBlobError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_SIGNED_CRLS;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_CONSTRUCTED_CONTEXT_1;
                }
            } else {
                // Crls not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_SIGNED_CRLS;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CRLS))
        goto SuccessReturn;


    // signerInfos
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SIGNERINFOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                SignerInfosNC_PDU,
                (void **)&pSignerInfos))
            goto DecodeSignerInfosError;
        if (pSignerInfos) {
            for (i=pSignerInfos->count, pAny=pSignerInfos->value;
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailSigner( psdi->pSignerList, pAny))
                    goto SignerInfoInsertTailBlobError;
            }
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_SIGNERINFOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SIGNERINFOS))
        goto SuccessReturn;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeEndNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, CertificatesNC_PDU, pCertificates);
    PkiAsn1FreeInfo( pDec, CrlsNC_PDU, pCrls);
    PkiAsn1FreeInfo( pDec, SignerInfosNC_PDU, pSignerInfos);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeInnerNullsError)            // error already set
TRACE_ERROR(DecodeCertificatesError)           // error already set
TRACE_ERROR(CertInsertTailBlobError)           // error already set
TRACE_ERROR(DecodeCrlsError)                   // error already set
TRACE_ERROR(CrlInsertTailBlobError)            // error already set
TRACE_ERROR(DecodeSignerInfosError)            // error already set
TRACE_ERROR(SignerInfoInsertTailBlobError)     // error already set
TRACE_ERROR(ConsumeEndNullsError)              // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixEnveloped(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    Attributes          *pAttributes = NULL;
#ifdef CMS_PKCS7
    CmsEnvelopedData    *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    OSS_DECODE_INFO     odi;
    COssDecodeInfoNode  *pnOssDecodeInfo;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cInnerNullPairs, fFinal))
        goto ConsumeInnerNullsError;
    if (pcmi->cInnerNullPairs)
        goto SuccessReturn;

    // unprotectedAttrs[1] IMPLICIT UnprotectedAttributes OPTIONAL
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ATTR)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_1 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [1] IMPLICIT indicating unprotectedAttrs.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;

                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        Attributes_PDU,
                        (void **)&pAttributes))
                    goto DecodeAttributesError;
                if (pAttributes) {
#ifdef CMS_PKCS7
                    ped->unprotectedAttrs = *pAttributes;
                    ped->bit_mask |= unprotectedAttrs_present;
#endif  // CMS_PKCS7
                    odi.iPDU  = Attributes_PDU;
                    odi.pvPDU = pAttributes;
                    if (NULL == (pnOssDecodeInfo =
                            new COssDecodeInfoNode( &odi))) {
                        PkiAsn1FreeInfo( pDec, odi.iPDU, odi.pvPDU);
                        goto NewOssDecodeInfoNodeError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;
                    pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) =
                        ICM_TAG_CONSTRUCTED_CONTEXT_1;
                }
            } else {
                // unprotectedAttrs not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;
            }
        } else if (fFinal)
            // unprotectedAttrs not present. Mark them as decoded.
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;

    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ATTR))
        goto SuccessReturn;


    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeEndNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;
SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeInnerNullsError)            // error already set
TRACE_ERROR(DecodeAttributesError)             // error already set
SET_ERROR(NewOssDecodeInfoNodeError, E_OUTOFMEMORY)
TRACE_ERROR(ConsumeEndNullsError)              // error already set

}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    switch (pcmi->dwMsgType) {
    case CMSG_DATA:
        fRet = ICMS_DecodeSuffixData( pcmi, fFinal);
        break;
    case CMSG_SIGNED:
        fRet = ICMS_DecodeSuffixSigned( pcmi, fFinal);
        break;
    case CMSG_ENVELOPED:
        fRet = ICMS_DecodeSuffixEnveloped( pcmi, fFinal);
        break;
    case CMSG_HASHED:
        // fRet = ICMS_DecodeSuffixDigested( pcmi, fFinal);
        // break;
    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;
    default:
        goto InvalidMsgType;
    }

    if (!fRet)
        goto ErrorReturn;

CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Decrypt and output pending decode data.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeDecryptAndOutput(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT PICM_BUFFER  pbufDecode,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fBlockCipher = pcmi->fBlockCipher;
    PICM_BUFFER pbufCrypt  = &pcmi->bufCrypt;
    DWORD       cbCipher;
    DWORD       cb;

    for (cbCipher = min( *pcbPending, pbufDecode->cbUsed - pbufDecode->cbDead);
            cbCipher > 0;) {
        cb = min( cbCipher, pbufCrypt->cbSize - pbufCrypt->cbUsed); // must fit
        CopyMemory(
                pbufCrypt->pbData  + pbufCrypt->cbUsed,
                pbufDecode->pbData + pbufDecode->cbDead,
                cb);
        pbufCrypt->cbUsed  += cb;
        pbufDecode->cbDead += cb;
        *pcbPending        -= cb;
        cbCipher           -= cb;
        if (pbufCrypt->cbSize == pbufCrypt->cbUsed) {
            // Decrypt and copy out the buffer
            cb = pbufCrypt->cbSize;
            if (fBlockCipher) {
                // Keep the last block
                cb -= pcmi->cbBlockSize;
            }
            if (!CryptDecrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        FALSE,                          // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb))
                goto DecryptError;
            if (!ICMS_Output(
                        pcmi,
                        pbufCrypt->pbData,
                        cb,
                        FALSE))                         // fFinal
                goto OutputError;

            if (fBlockCipher) {
                // Move the last block to the beginning of the buffer
                // and reset the count to start after this block.
                // Since we are sure the src and dst do not overlap,
                // use CopyMemory (faster than MoveMemory).
                cb = pbufCrypt->cbSize - pcmi->cbBlockSize;
                CopyMemory(
                    pbufCrypt->pbData,
                    pbufCrypt->pbData + cb,
                    pcmi->cbBlockSize);
                pbufCrypt->cbUsed = pcmi->cbBlockSize;
            } else {
                pbufCrypt->cbUsed = 0;
            }
        }
    }

    if (fFinal) {
        if (cb = pbufCrypt->cbUsed) {
            if (!CryptDecrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        TRUE,                           // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb))
                goto FinalDecryptError;
        }
        if (!ICMS_Output(
                    pcmi,
                    pbufCrypt->pbData,
                    cb,
                    TRUE))                          // fFinal
            goto FinalOutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecryptError)           // error already set
TRACE_ERROR(FinalDecryptError)      // error already set
TRACE_ERROR(OutputError)            // error already set
TRACE_ERROR(FinalOutputError)       // error already set
}

//+-------------------------------------------------------------------------
//  Given a key for decryption, prepare for the decryption to proceed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_SetDecryptKey(
    IN PCRYPT_MSG_INFO  pcmi,
    IN HCRYPTKEY        hkeyDecrypt)
{
    BOOL            fRet;
    DWORD           cbPending;
    PICM_BUFFER     pbufPendingCrypt  = &pcmi->bufPendingCrypt;

    if (pcmi->hkeyContentCrypt) {
        SetLastError((DWORD) CRYPT_E_ALREADY_DECRYPTED);
        return FALSE;
    }

    pcmi->hkeyContentCrypt = hkeyDecrypt;

    if (!ICMS_CreateEnvelopedBuffer( pcmi))
        goto CreateEnvelopedBufferError;
    pcmi->bufCrypt.cbSize += pcmi->cbBlockSize; // use whole thing for decode

    // Decrypt any pending ciphertext
    cbPending = pbufPendingCrypt->cbUsed - pbufPendingCrypt->cbDead;
    if (!ICMS_DecodeDecryptAndOutput(
            pcmi,
            pbufPendingCrypt,
            &cbPending,
            0 != (pcmi->aflStream & (ICMS_DECODED_CONTENT | ICMS_FINAL))))
        goto DecryptAndOutputError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    pcmi->hkeyContentCrypt = 0;             // caller closes hkeyDecrypt on
                                            // error
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEnvelopedBufferError)     // error already set
TRACE_ERROR(DecryptAndOutputError)          // error already set
}


//+-------------------------------------------------------------------------
//  Decode callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PCRYPT_MSG_INFO pcmi = (PCRYPT_MSG_INFO)pvArg;
    PBYTE           pbData = pbuf->pbData + pbuf->cbDead;
    DWORD           cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (CMSG_ENVELOPED == pcmi->dwMsgType) {
        if (NULL == pcmi->hkeyContentCrypt) {
            // Allow ciphertext to pile up until the decrypt key is set via
            // CryptMsgControl(... CMSG_CTRL_DECRYPT ...)
            if (!ICMS_QueueToBuffer(&pcmi->bufPendingCrypt, pbData, cbData))
                goto QueuePendingCryptError;

            pbuf->cbDead += cbData;
            *pcbPending  -= cbData;
        } else if (!ICMS_DecodeDecryptAndOutput(
                    pcmi,
                    pbuf,
                    pcbPending,
                    fFinal))
            goto DecryptAndOutputError;
    } else {
        if (cbData && pcmi->pHashList) {
            if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
                goto UpdateDigestError;
        }

        pbuf->cbDead += cbData;
        *pcbPending  -= cbData;
        if (!ICMS_Output( pcmi, pbData, cbData, fFinal))
            goto OutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueuePendingCryptError)         // error already set
TRACE_ERROR(DecryptAndOutputError)          // error already set
TRACE_ERROR(UpdateDigestError)              // error already set
TRACE_ERROR(OutputError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Hash callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_HashCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PBYTE           pbData = pbuf->pbData + pbuf->cbDead;
    DWORD           cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (pvArg) {
        if (!ICM_UpdateListDigest( (CHashList *)pvArg, pbData, cbData))
            goto UpdateDigestError;
    }

    pbuf->cbDead += cbData;
    *pcbPending  -= cbData;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(UpdateDigestError)               // error already set
fFinal;
}


//+-------------------------------------------------------------------------
//  Hash incremental content data to be encoded, for an octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData)
{
    BOOL        fRet;

    if (!ICMS_QueueToBuffer( &pcmi->bufEncode, (PBYTE)pbData, cbData))
        goto QueueToBufferError;

    if (!ICMS_ProcessStringContent(
                &pcmi->bufEncode,
                &pcmi->aflStream,
                &pcmi->cbDefiniteRemain,
                &pcmi->cLevelIndefiniteInner,
                ICMS_HashCallback,
                pcmi->pHashList))
        goto ProcessStringContentError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                // error already set
TRACE_ERROR(ProcessStringContentError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental content data to be decoded, for an octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContentOctetString(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL        fRet;

    if (!ICMS_ProcessStringContent(
                &pcmi->bufDecode,
                &pcmi->aflStream,
                &pcmi->cbDefiniteRemain,
                &pcmi->cLevelIndefiniteInner,
                ICMS_DecodeCallback,
                pcmi))
        goto ProcessStringContentError;

    if (pcmi->aflStream & ICMS_PROCESS_CONTENT_DONE)
        pcmi->aflStream |= ICMS_DECODED_CONTENT;

    if (fFinal &&
            (pcmi->cbDefiniteRemain ||
             pcmi->cLevelIndefiniteInner ||
             (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT)))) {
        goto PrematureFinalError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PrematureFinalError,CRYPT_E_STREAM_INSUFFICIENT_DATA)
TRACE_ERROR(ProcessStringContentError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental content data to be decoded, for a sequence.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContentSequence(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = pbuf->cbUsed - pbuf->cbDead;
    LONG        lSkipped;
    DWORD       cbContent;
    const BYTE  *pbContent;

    if (pcmi->aflStream & ICMS_PROCESS_CONTENT_BEGUN)
        goto MultipleContentSequenceError;

    // Get the tag and length for the inner content
    if (0 > (lSkipped = Asn1UtilExtractContent(
                        pbData,
                        cbData,
                        &cbContent,
                        &pbContent))) {
        if (ASN1UTIL_INSUFFICIENT_DATA != lSkipped)
            goto ExtractContentError;
        else
            goto SuccessReturn;
    }

    if (CMSG_INDEFINITE_LENGTH == cbContent)
        goto IndefiniteLengthInnerContentNotImplemented;

    // Output the tag and length octets for the encoded inner content.
    // Note, not included in the content to be verified in a signature.
    if (!ICMS_Output( pcmi, pbData, (DWORD) lSkipped, FALSE))
        goto OutputError;

    pcmi->aflStream |= ICMS_INNER_OCTETSTRING;
    // Decode as an octet string. Will skip the tag and length octets
    fRet = ICMS_DecodeContentOctetString(pcmi, fFinal);

CommonReturn:
    return fRet;

SuccessReturn:
    fRet = TRUE;
    goto CommonReturn;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MultipleContentSequenceError, CRYPT_E_MSG_ERROR)
SET_ERROR(ExtractContentError, CRYPT_E_MSG_ERROR)
SET_ERROR(IndefiniteLengthInnerContentNotImplemented, E_NOTIMPL)
TRACE_ERROR(OutputError)
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;

    if (pcmi->aflStream & ICMS_RAW_DATA) {
        // Should be able to skip bufDecode for this case.
        if (!ICMS_Output(
                pcmi,
                pbuf->pbData + pbuf->cbDead,
                pbuf->cbUsed - pbuf->cbDead,
                fFinal))
            goto RawOutputError;
        pbuf->cbDead = pbuf->cbUsed;

        if (fFinal)
            pcmi->aflStream |= ICMS_DECODED_CONTENT | ICMS_DECODED_SUFFIX;

    } else if (pcmi->aflStream & ICMS_INNER_OCTETSTRING) {
        if (!ICMS_DecodeContentOctetString( pcmi, fFinal))
            goto DecodeContentOctetStringError;

    } else {
        if (!ICMS_DecodeContentSequence( pcmi, fFinal))
            goto DecodeContentSequenceError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(RawOutputError)                     // error already set
TRACE_ERROR(DecodeContentOctetStringError)      // error already set
TRACE_ERROR(DecodeContentSequenceError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    if (0 ==(pcmi->aflStream & ICMS_NONBARE))
        pcmi->aflStream |= ICMS_RAW_DATA;
    pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_INNER_OCTETSTRING;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for a signed message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixSigned(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD                           dwError = ERROR_SUCCESS;
    BOOL                            fRet;
    ASN1decoding_t                  pDec = ICM_GetDecoder();
    PSIGNED_DATA_INFO               psdi = pcmi->psdi;
    DWORD                           dwToken;
    int                             *piVersion = NULL;
    DigestAlgorithmIdentifiersNC    *pDigestAlgorithms = NULL;
    Any                             *pAny;
    DWORD                           cb;
    DWORD                           i;
    BOOL                            fNoContent;

    if (NULL == psdi) {
        if (NULL == (psdi = (PSIGNED_DATA_INFO)ICM_AllocZero(
                                sizeof(SIGNED_DATA_INFO))))
            goto SdiAllocError;
        pcmi->psdi = psdi;

        if (NULL == (psdi->pAlgidList = new CBlobList))
            goto NewAlgidListError;
        if (NULL == (psdi->pCertificateList = new CBlobList))
            goto NewCertificateListError;
        if (NULL == (psdi->pCrlList = new CBlobList))
            goto NewCrlListError;
        if (NULL == (psdi->pSignerList = new CSignerList))
            goto NewSignerListError;
    }

    // SignedData sequence
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto GetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cEndNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_SIGNED_SEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SEQ))
        goto SuccessReturn;


    // version
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_VERSION)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                IntegerType_PDU,
                (void **)&piVersion))
            goto DecodeVersionError;
        if (piVersion) {
            psdi->version = *piVersion;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_VERSION;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_VERSION))
        goto SuccessReturn;


    // digestAlgorithms
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_DIGESTALGOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                DigestAlgorithmIdentifiersNC_PDU,
                (void **)&pDigestAlgorithms))
            goto DecodeDigestAlgorithmsError;
        if (pDigestAlgorithms) {
            for (i=pDigestAlgorithms->count, pAny=pDigestAlgorithms->value;
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( psdi->pAlgidList, pAny))
                    goto DigestAlgorithmInsertTailBlobError;
            }
            // We have the algorithms. Now create the hash handles.
            if (!ICM_CreateHashList(
                    pcmi->hCryptProv,
                    &pcmi->pHashList,
                    pcmi->psdi->pAlgidList))
                goto CreateHashListError;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_DIGESTALGOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_DIGESTALGOS))
        goto SuccessReturn;


    // contentInfo
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CONTENTINFO)) {
        if (!ICMS_DecodePrefixContentInfo(
                    pcmi,
                    &pcmi->pooid,
                    &pcmi->cInnerNullPairs,
                    &pcmi->aflInner,
                    &fNoContent))
            goto DecodePrefixSignedContentInfoError;
        if (pcmi->aflInner & ICMS_DECODED_CONTENTINFO_CONTENT) {
            // We cracked the whole header.
            // Translate the inner contentType oid into a string.
            if (!PkiAsn1FromObjectIdentifier(
                    pcmi->pooid->count,
                    pcmi->pooid->value,
                    NULL,
                    &cb))
                goto PkiAsn1FromObjectIdentifierSizeError;
            if (NULL == (psdi->pci = (PCONTENT_INFO)ICM_Alloc(
                                        cb + INFO_LEN_ALIGN(sizeof(CONTENT_INFO)))))
                goto AllocContentInfoError;
            psdi->pci->pszContentType = (LPSTR)(psdi->pci) +
                                        INFO_LEN_ALIGN(sizeof(CONTENT_INFO));
            psdi->pci->content.cbData = 0;
            psdi->pci->content.pbData = NULL;
            if (!PkiAsn1FromObjectIdentifier(
                    pcmi->pooid->count,
                    pcmi->pooid->value,
                    psdi->pci->pszContentType,
                    &cb))
                goto PkiAsn1FromObjectIdentifierError;
            PkiAsn1FreeDecoded(pDec, pcmi->pooid, ObjectIdentifierType_PDU);
            pcmi->pooid = NULL;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_CONTENTINFO;

            if (fNoContent) {
                // No content. Output final flag with no content.
                if (!ICMS_Output(pcmi, NULL, 0, TRUE))
                    goto OutputError;
                pcmi->aflStream |= ICMS_DECODED_CONTENT;
            } else {
                if (0 == strcmp( psdi->pci->pszContentType, pszObjIdDataType)
#ifdef CMS_PKCS7
                        || psdi->version >= CMSG_SIGNED_DATA_V3 
#endif  // CMS_PKCS7
                        )
                    pcmi->aflStream |= ICMS_INNER_OCTETSTRING;
            }
            pcmi->aflStream |= ICMS_DECODED_PREFIX;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, IntegerType_PDU, piVersion);
    PkiAsn1FreeInfo( pDec, DigestAlgorithmIdentifiersNC_PDU, pDigestAlgorithms);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    // note, pcmi->psdi and pcmi->pooid are freed in CryptMsgClose
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SdiAllocError)                              // error already set
SET_ERROR(NewAlgidListError, E_OUTOFMEMORY)
SET_ERROR(NewCertificateListError, E_OUTOFMEMORY)
SET_ERROR(NewCrlListError, E_OUTOFMEMORY)
SET_ERROR(NewSignerListError, E_OUTOFMEMORY)
TRACE_ERROR(GetTokenError)                              // error already set
SET_ERROR(InvalidTokenError, CRYPT_E_MSG_ERROR)
TRACE_ERROR(DecodeVersionError)                         // error already set
TRACE_ERROR(DecodeDigestAlgorithmsError)                // error already set
TRACE_ERROR(DigestAlgorithmInsertTailBlobError)         // error already set
TRACE_ERROR(CreateHashListError)                        // error already set
TRACE_ERROR(DecodePrefixSignedContentInfoError)         // error already set
TRACE_ERROR(PkiAsn1FromObjectIdentifierSizeError)       // error already set
TRACE_ERROR(AllocContentInfoError)                      // error already set
TRACE_ERROR(PkiAsn1FromObjectIdentifierError)           // error already set
TRACE_ERROR(OutputError)                                // error already set
}

//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixEnveloped(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
#ifdef CMS_PKCS7
    CmsEnvelopedData    *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
    EnvelopedData       *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    DWORD               dwToken;
    int                 *piVersion = NULL;
#ifdef CMS_PKCS7
    CmsRecipientInfos   *pRecipientInfos = NULL;
#else
    RecipientInfos      *pRecipientInfos = NULL;
#endif  // CMS_PKCS7
    ObjectIdentifierType *pooidContentType = NULL;
    AlgorithmIdentifier *poaidContentEncryption = NULL;
    COssDecodeInfoNode  *pnOssDecodeInfo;
    OSS_DECODE_INFO     odi;
    DWORD               cbConsumed;

#ifdef CMS_PKCS7
    OriginatorInfoNC    *pOriginatorInfo = NULL;
    Any                 *pAny;
    DWORD               i;
#endif  // CMS_PKCS7

    if (NULL == ped) {
#ifdef CMS_PKCS7
        if (NULL == (ped = (CmsEnvelopedData *)ICM_AllocZero(
                                sizeof(CmsEnvelopedData))))
#else
        if (NULL == (ped = (EnvelopedData *)ICM_AllocZero(
                                sizeof(EnvelopedData))))
#endif  // CMS_PKCS7
            goto AllocEnvelopedDataError;
        pcmi->pvMsg = ped;
        if (NULL == (pcmi->plDecodeInfo = new COssDecodeInfoList))
            goto NewCOssDecodeInfoListError;

#ifdef CMS_PKCS7
        if (NULL == (pcmi->pCertificateList = new CBlobList))
            goto NewCertificateListError;
        if (NULL == (pcmi->pCrlList = new CBlobList))
            goto NewCrlListError;
#endif  // CMS_PKCS7
    }

    // EnvelopedData SEQ
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto EnvelopedDataSeqGetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cEndNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_SEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_SEQ))
        goto SuccessReturn;


    // version
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_VERSION)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                IntegerType_PDU,
                (void **)&piVersion))
            goto DecodeVersionError;
        if (piVersion) {
            ped->version = *piVersion;
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_VERSION;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_VERSION))
        goto SuccessReturn;

#ifdef CMS_PKCS7
    // originatorInfo OPTIONAL
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ORIGINATOR)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_0 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [0] IMPLICIT indicating originatorInfo.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SEQ;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        OriginatorInfoNC_PDU,
                        (void **)&pOriginatorInfo))
                    goto DecodeOriginatorInfoError;
                if (pOriginatorInfo) {
                    if (pOriginatorInfo->bit_mask & certificates_present) {
                        for (i=pOriginatorInfo->certificates.count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pOriginatorInfo->certificates.certificates;
#else
                                pAny=pOriginatorInfo->certificates.value;
#endif  // OSS_CRYPT_ASN1
                                i>0;
                                i--, pAny++) {
                            if (!ICM_InsertTailBlob( pcmi->pCertificateList,
                                    pAny))
                                goto CertInsertTailBlobError;
                        }
                    }

                    if (pOriginatorInfo->bit_mask & crls_present) {
                        for (i=pOriginatorInfo->crls.count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pOriginatorInfo->crls.crls;
#else
                                pAny=pOriginatorInfo->crls.value;
#endif  // OSS_CRYPT_ASN1
                                i>0;
                                i--, pAny++) {
                            if (!ICM_InsertTailBlob( pcmi->pCrlList, pAny))
                                goto CrlInsertTailBlobError;
                        }
                    }
                    pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ORIGINATOR;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) =
                        ICM_TAG_CONSTRUCTED_CONTEXT_0;
                }
            } else {
                // originatorInfo not present. Mark as decoded.
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ORIGINATOR;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ORIGINATOR))
        goto SuccessReturn;
#endif  // CMS_PKCS7

    // recipientInfos
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
#ifdef CMS_PKCS7
                CmsRecipientInfos_PDU,
#else
                RecipientInfos_PDU,
#endif  // CMS_PKCS7
                (void **)&pRecipientInfos))
            goto DecodeRecipientInfosError;
        if (pRecipientInfos) {
            ped->recipientInfos = *pRecipientInfos;
#ifdef CMS_PKCS7
            odi.iPDU  = CmsRecipientInfos_PDU;
#else
            odi.iPDU  = RecipientInfos_PDU;
#endif  // CMS_PKCS7
            odi.pvPDU = pRecipientInfos;
            if (NULL == (pnOssDecodeInfo = new COssDecodeInfoNode( &odi))) {
                PkiAsn1FreeInfo( pDec, odi.iPDU, odi.pvPDU);
                goto NewOssDecodeInfoNodeError;
            }
            pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_RECIPINFOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS))
        goto SuccessReturn;


    // encryptedContentInfo SEQ
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECISEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, &pcmi->cbContentInfo))
            goto EncryptedContentInfoSeqGetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cInnerNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECISEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECISEQ))
        goto SuccessReturn;


    // contentType
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECITYPE)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                ObjectIdentifierType_PDU,
                (void **)&pooidContentType,
                &cbConsumed))
            goto DecodeContentTypeError;
        if (pooidContentType) {
            ICM_CopyOssObjectIdentifier(&ped->encryptedContentInfo.contentType,
                pooidContentType);
            // NB- Since ContentType is self-contained and we have saved
            // a copy, we can always free pooidContentType when this 
            // routine exits.
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECITYPE;

            if (CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo) {
                if (cbConsumed > pcmi->cbContentInfo)
                    goto InvalidEncryptedContentInfoLength;
                pcmi->cbContentInfo -= cbConsumed;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECITYPE))
        goto SuccessReturn;


    // contentEncryptionAlgorithm
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                AlgorithmIdentifier_PDU,
                (void **)&poaidContentEncryption,
                &cbConsumed))
            goto DecodeContentEncryptionAlgorithmError;
        if (poaidContentEncryption) {
            ped->encryptedContentInfo.contentEncryptionAlgorithm =
                                                    *poaidContentEncryption;
            odi.iPDU  = AlgorithmIdentifier_PDU;
            odi.pvPDU = poaidContentEncryption;
            if (NULL == (pnOssDecodeInfo = new COssDecodeInfoNode( &odi))) {
                PkiAsn1FreeInfo( pDec, AlgorithmIdentifier_PDU,
                    poaidContentEncryption);
                goto NewOssDecodeInfoNodeError;
            }
            pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECIALGID;

            if (CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo &&
                    cbConsumed == pcmi->cbContentInfo) {
                // The encryptedContent has been omitted
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
                pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_DECODED_CONTENT;

                if (pcmi->hkeyContentCrypt) {
                    if (!ICMS_Output(
                            pcmi,
                            NULL,                           // pbData
                            0,                              // cbData
                            TRUE))                          // fFinal
                        goto FinalOutputError;
                }
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID))
        goto SuccessReturn;


    // encryptedContent [0] IMPLICIT OPTIONAL
    //
    // Only support DATA or encapsulated encrypted content.
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECICONTENT)) {
        BOOL fNoEncryptedContent = FALSE;
        if (pbuf->cbUsed > pbuf->cbDead) {
            BYTE bTag = *(pbuf->pbData + pbuf->cbDead);
            if (ICM_TAG_CONTEXT_0 == (bTag & ~ICM_TAG_CONSTRUCTED)) {
                // Detected the [0] IMPLICIT indicating encryptedContent.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_OCTETSTRING |
                    (bTag & ICM_TAG_CONSTRUCTED);

                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
                // The inner type is always OCTET STRING
                pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_INNER_OCTETSTRING;
            } else
                fNoEncryptedContent = TRUE;
        } else if (fFinal)
            fNoEncryptedContent = TRUE;

        if (fNoEncryptedContent) {
            // The encryptedContent has been omitted
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
            pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_DECODED_CONTENT;

            if (pcmi->hkeyContentCrypt) {
                if (!ICMS_Output(
                        pcmi,
                        NULL,                           // pbData
                        0,                              // cbData
                        TRUE))                          // fFinal
                    goto FinalOutputError;
            }
        }
    }


SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, IntegerType_PDU, piVersion);
#ifdef CMS_PKCS7
    PkiAsn1FreeInfo( pDec, OriginatorInfoNC_PDU, pOriginatorInfo);
#endif  // CMS_PKCS7
    PkiAsn1FreeInfo( pDec, ObjectIdentifierType_PDU, pooidContentType);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EnvelopedDataSeqGetTokenError)              // error already set
TRACE_ERROR(EncryptedContentInfoSeqGetTokenError)       // error already set
SET_ERROR(InvalidTokenError, CRYPT_E_MSG_ERROR)
TRACE_ERROR(DecodeVersionError)                         // error already set
TRACE_ERROR(AllocEnvelopedDataError)                    // error already set
SET_ERROR(NewCOssDecodeInfoListError, E_OUTOFMEMORY)
#ifdef CMS_PKCS7
SET_ERROR(NewCertificateListError, E_OUTOFMEMORY)
SET_ERROR(NewCrlListError, E_OUTOFMEMORY)
TRACE_ERROR(DecodeOriginatorInfoError)                  // error already set
TRACE_ERROR(CertInsertTailBlobError)                    // error already set
TRACE_ERROR(CrlInsertTailBlobError)                     // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(DecodeRecipientInfosError)                  // error already set
TRACE_ERROR(DecodeContentTypeError)                     // error already set
SET_ERROR(InvalidEncryptedContentInfoLength, CRYPT_E_MSG_ERROR)
TRACE_ERROR(DecodeContentEncryptionAlgorithmError)      // error already set
SET_ERROR(NewOssDecodeInfoNodeError, E_OUTOFMEMORY)
TRACE_ERROR(FinalOutputError)                           // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lth;
    BOOL                fNoContent;

    if (0 == pcmi->dwMsgType) {
        pcmi->aflStream |= ICMS_NONBARE;
        if (!ICMS_DecodePrefixContentInfo(
                    pcmi,
                    &pcmi->pooid,
                    &pcmi->cEndNullPairs,
                    &pcmi->aflOuter,
                    &fNoContent))
            goto DecodePrefixContentInfoError;

        if (pcmi->aflOuter & ICMS_DECODED_CONTENTINFO_CONTENT) {
            // We cracked the whole header.
            // Translate the contentType oid into a message type.
            if (0 == (lth = ICM_ObjIdToIndex( pcmi->pooid)))
                goto UnknownContentTypeError;
            pcmi->dwMsgType = (DWORD)lth;
            PkiAsn1FreeDecoded(ICM_GetDecoder(), pcmi->pooid,
                ObjectIdentifierType_PDU);
            pcmi->pooid = NULL;


            // Address case of no content
        }
    }

    switch (pcmi->dwMsgType) {
    case 0:
        if (fFinal)
            goto FinalWithoutMessageTypeError;
        break;
    case CMSG_DATA:
        if (!ICMS_DecodePrefixData( pcmi, fFinal))
            goto DecodePrefixDataError;
        break;
    case CMSG_SIGNED:
        if (!ICMS_DecodePrefixSigned( pcmi, fFinal))
            goto DecodePrefixSignedError;
        break;
    case CMSG_ENVELOPED:
        if (!ICMS_DecodePrefixEnveloped( pcmi, fFinal))
            goto DecodePrefixEnvelopedError;
        break;
    case CMSG_HASHED:
        // if (!ICMS_DecodePrefixDigested( pcmi, fFinal))
        //     goto DecodePrefixDigestedError;
        // break;
    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;
    default:
        goto InvalidMsgType;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(FinalWithoutMessageTypeError,CRYPT_E_STREAM_INSUFFICIENT_DATA)
SET_ERROR(UnknownContentTypeError,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(DecodePrefixContentInfoError)       // error already set
TRACE_ERROR(DecodePrefixDataError)              // error already set
TRACE_ERROR(DecodePrefixSignedError)            // error already set
TRACE_ERROR(DecodePrefixEnvelopedError)         // error already set
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded (work done here).
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecodingInner(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    if (0 == (pcmi->aflStream & ICMS_DECODED_PREFIX)) {
        if (!ICMS_DecodePrefix( pcmi, fFinal))
            goto DecodePrefixError;
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_PREFIX))
        goto SuccessReturn;


    if (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT)) {
        if (!ICMS_DecodeContent( pcmi, fFinal))
            goto DecodeContentError; // NB- Do not trash err from callback!
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT))
        goto SuccessReturn;


    if (0 == (pcmi->aflStream & ICMS_DECODED_SUFFIX)) {
        if (!ICMS_DecodeSuffix( pcmi, fFinal))
            goto DecodeSuffixError;
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_SUFFIX))
        goto SuccessReturn;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodePrefixError)                      // error already set
TRACE_ERROR(DecodeContentError)                     // error already set
TRACE_ERROR(DecodeSuffixError)                      // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded.
//
//  Note, the buffer to be decoded may have some of its tags modified.
//  Therefore, we always need to copy to our own decode buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    pcmi->fStreamCallbackOutput = TRUE;

    if (!ICMS_QueueToBuffer( &pcmi->bufDecode, (PBYTE)pbData, cbData))
        goto QueueToBufferError;

    if (!ICMS_UpdateDecodingInner( pcmi, fFinal))
        goto UpdateDecodingInnerError;

    if (fFinal) {
        if (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead)
            goto ExcessDataError;
        pcmi->aflStream |= ICMS_FINAL;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                     // error already set
TRACE_ERROR(UpdateDecodingInnerError)               // error already set
SET_ERROR(ExcessDataError, CRYPT_E_MSG_ERROR)
}

#if 0
// When we fix the decoding of [0] Certificates and [1] Crls not to modify
// the encoded data we can replace the above with the following:

//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;
    BOOL        fNoCopy;

    pcmi->fStreamCallbackOutput = TRUE;
    if (fFinal && NULL == pbuf->pbData) {
        // We're able to use the input buffer without copying
        fNoCopy = TRUE;
        assert(0 == pbuf->cbSize && 0 == pbuf->cbUsed && 0 == pbuf->cbDead);
        pbuf->pbData = (PBYTE) pbData;
        pbuf->cbSize = cbData;
        pbuf->cbUsed = cbData;
        pbuf->cbDead = 0;
    } else {
        fNoCopy = FALSE;
        if (!ICMS_QueueToBuffer( pbuf, (PBYTE)pbData, cbData))
            goto QueueToBufferError;
    }

    if (!ICMS_UpdateDecodingInner( pcmi, fFinal))
        goto UpdateDecodingInnerError;

    if (fFinal) {
        if (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead)
            goto ExcessDataError;
        pcmi->aflStream |= ICMS_FINAL;
    }

    fRet = TRUE;
CommonReturn:
    if (fNoCopy)
        memset(pbuf, 0, sizeof(*pbuf));
        
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                     // error already set
TRACE_ERROR(UpdateDecodingInnerError)               // error already set
SET_ERROR(ExcessDataError, CRYPT_E_MSG_ERROR)
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\msgasn1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgasn1.h
//
//  Contents:   Conversion APIs to/from ASN.1 data structures
//
//  Functions:  ICM_Asn1ToAttribute
//              ICM_Asn1ToAlgorithmIdentifier
//              ICM_Asn1FromAlgorithmIdentifier
//
//  History:    16-Apr-96   kevinr   created
//
//--------------------------------------------------------------------------

#ifndef __MSGASN1_H__
#define __MSGASN1_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert an CRYPT_ATTRIBUTE to an ASN1 Attribute
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAttribute(
    IN PCRYPT_ATTRIBUTE       patr,
    OUT Attribute       *pAsn1Attr);


//+-------------------------------------------------------------------------
//  Convert an CRYPT_ALGORITHM_IDENTIFIER to an ASN1 AlgorithmIdentifier
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    OUT AlgorithmIdentifier *pAsn1AlgId);


//+-------------------------------------------------------------------------
//  Convert an ASN1 AlgorithmIdentifier to an CRYPT_ALGORITHM_IDENTIFIER
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1FromAlgorithmIdentifier(
    IN AlgorithmIdentifier *pAsn1AlgId,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\msghlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msghlpr.cpp
//
//  Contents:   Cryptographic Message Helper APIs
//
//  APIs:       CryptMsgGetAndVerifySigner
//              CryptMsgSignCTL
//              CryptMsgEncodeAndSignCTL
//
//  History:    02-May-97   philh    created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "pkialloc.h"

void *ICM_AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = ICM_Alloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        ICM_Free(pvData);
        goto GetParamError;
    }

CommonReturn:
    return pvData;
ErrorReturn:
    pvData = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}

#ifdef CMS_PKCS7

BOOL ICM_GetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwSignerIndex,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner
    )
{
    BOOL fResult;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSigner = NULL;
    DWORD dwCertEncodingType;
    DWORD dwVerifyErr = 0;
    HCERTSTORE hCollection = NULL;

    if (NULL == (pSignerId = (PCERT_INFO) ICM_AllocAndGetMsgParam(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            dwSignerIndex
            ))) goto GetSignerError;

    // If no CertEncodingType, then, use the MsgEncodingType
    dwCertEncodingType = ((PCRYPT_MSG_INFO) hCryptMsg)->dwEncodingType;
    if (0 == (dwCertEncodingType & CERT_ENCODING_TYPE_MASK))
        dwCertEncodingType =
            (dwCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;


    if (NULL == (hCollection = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )))
        goto OpenCollectionStoreError;

    if (0 == (dwFlags & CMSG_TRUSTED_SIGNER_FLAG)) {
        HCERTSTORE hMsgCertStore;

        // Open a cert store initialized with certs from the message
        // and add to collection
        if (hMsgCertStore = CertOpenStore(
                CERT_STORE_PROV_MSG,
                dwCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                hCryptMsg               // pvPara
                )) {
            CertAddStoreToCollection(
                    hCollection,
                    hMsgCertStore,
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
            CertCloseStore(hMsgCertStore, 0);
        }
    }

    // Add all the signer stores to the collection
    for ( ; cSignerStore > 0; cSignerStore--, rghSignerStore++) {
        HCERTSTORE hSignerStore = *rghSignerStore;
        if (NULL == hSignerStore)
            continue;

        CertAddStoreToCollection(
                hCollection,
                hSignerStore,
                CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                0                       // dwPriority
                );
    }

    if (pSigner = CertGetSubjectCertificateFromStore(hCollection,
            dwCertEncodingType, pSignerId)) {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
            goto SuccessReturn;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =
        CtrlPara.dwSignerIndex = dwSignerIndex;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSigner;

        if (CryptMsgControl(
                hCryptMsg,
                0,                  // dwFlags
                CMSG_CTRL_VERIFY_SIGNATURE_EX,
                &CtrlPara)) goto SuccessReturn;
        else {
            dwVerifyErr = GetLastError();

            if (CRYPT_E_MISSING_PUBKEY_PARA == dwVerifyErr) {
                PCCERT_CHAIN_CONTEXT pChainContext;
                CERT_CHAIN_PARA ChainPara;

                // Build a chain. Hopefully, the signer inherit's its public key
                // parameters from up the chain

                memset(&ChainPara, 0, sizeof(ChainPara));
                ChainPara.cbSize = sizeof(ChainPara);
                if (CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pSigner,
                        NULL,                   // pTime
                        hCollection,
                        &ChainPara,
                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                        NULL,                   // pvReserved
                        &pChainContext
                        ))
                    CertFreeCertificateChain(pChainContext);


                // Try again. Hopefully the above chain building updated the
                // signer's context property with the missing public key
                // parameters
                if (CryptMsgControl(
                        hCryptMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_VERIFY_SIGNATURE_EX,
                        &CtrlPara)) goto SuccessReturn;
            }
        }
        CertFreeCertificateContext(pSigner);
        pSigner = NULL;
    }

    if (dwVerifyErr)
        goto VerifySignatureError;
    else
        goto NoSignerError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hCollection)
        CertCloseStore(hCollection, 0);
    ICM_Free(pSignerId);
    if (ppSigner)
        *ppSigner = pSigner;
    else if (pSigner)
        CertFreeCertificateContext(pSigner);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenCollectionStoreError)
TRACE_ERROR(GetSignerError)
SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
SET_ERROR_VAR(VerifySignatureError, dwVerifyErr)
}

#else

BOOL ICM_GetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwSignerIndex,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner
    )
{
    BOOL fResult;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSigner = NULL;
    DWORD dwCertEncodingType;
    DWORD dwVerifyErr = 0;

    if (NULL == (pSignerId = (PCERT_INFO) ICM_AllocAndGetMsgParam(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            dwSignerIndex
            ))) goto GetSignerError;

    // If no CertEncodingType, then, use the MsgEncodingType
    dwCertEncodingType = ((PCRYPT_MSG_INFO) hCryptMsg)->dwEncodingType;
    if (0 == (dwCertEncodingType & CERT_ENCODING_TYPE_MASK))
        dwCertEncodingType =
            (dwCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;

    if (0 == (dwFlags & CMSG_TRUSTED_SIGNER_FLAG)) {
        HCERTSTORE hMsgCertStore;

        // Open a cert store initialized with certs from the message
        if (hMsgCertStore = CertOpenStore(
                CERT_STORE_PROV_MSG,
                dwCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                hCryptMsg               // pvPara
                )) {
            pSigner = CertGetSubjectCertificateFromStore(hMsgCertStore,
                dwCertEncodingType, pSignerId);
            CertCloseStore(hMsgCertStore, 0);
        }

        if (pSigner) {
            if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
                goto SuccessReturn;
            if (CryptMsgControl(
                    hCryptMsg,
                    0,                  // dwFlags
                    CMSG_CTRL_VERIFY_SIGNATURE,
                    pSigner->pCertInfo)) goto SuccessReturn;
            else
                dwVerifyErr = GetLastError();
            CertFreeCertificateContext(pSigner);
            pSigner = NULL;
        }
    }

    for ( ; cSignerStore > 0; cSignerStore--, rghSignerStore++) {
        HCERTSTORE hSignerStore = *rghSignerStore;
        if (NULL == hSignerStore)
            continue;
        if (pSigner = CertGetSubjectCertificateFromStore(hSignerStore,
                dwCertEncodingType, pSignerId)) {
            if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
                goto SuccessReturn;
            if (CryptMsgControl(
                    hCryptMsg,
                    0,                  // dwFlags
                    CMSG_CTRL_VERIFY_SIGNATURE,
                    pSigner->pCertInfo)) goto SuccessReturn;
            else
                dwVerifyErr = GetLastError();
            CertFreeCertificateContext(pSigner);
            pSigner = NULL;
        }
    }

    if (dwVerifyErr)
        goto VerifySignatureError;
    else
        goto NoSignerError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    ICM_Free(pSignerId);
    if (ppSigner)
        *ppSigner = pSigner;
    else if (pSigner)
        CertFreeCertificateContext(pSigner);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSignerError)
SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
SET_ERROR_VAR(VerifySignatureError, dwVerifyErr)
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get and verify the signer of a cryptographic message.
//
//  If CMSG_TRUSTED_SIGNER_FLAG is set, then, treat the Signer stores as being
//  trusted and only search them to find the certificate corresponding to the
//  signer's issuer and serial number.  Otherwise, the SignerStores are
//  optionally provided to supplement the message's store of certificates.
//  If a signer certificate is found, its public key is used to verify
//  the message signature. The CMSG_SIGNER_ONLY_FLAG can be set to
//  return the signer without doing the signature verify.
//
//  If CMSG_USE_SIGNER_INDEX_FLAG is set, then, only get the signer specified
//  by *pdwSignerIndex. Otherwise, iterate through all the signers
//  until a signer verifies or no more signers.
//
//  For a verified signature, *ppSigner is updated with certificate context
//  of the signer and *pdwSignerIndex is updated with the index of the signer.
//  ppSigner and/or pdwSignerIndex can be NULL, indicating the caller isn't
//  interested in getting the CertContext and/or index of the signer.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgGetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner,
    IN OUT OPTIONAL DWORD *pdwSignerIndex
    )
{
    BOOL fResult = FALSE;
    DWORD dwSignerCount;
    DWORD dwSignerIndex;

    if (dwFlags & CMSG_USE_SIGNER_INDEX_FLAG) {
        dwSignerCount = 1;
        dwSignerIndex = *pdwSignerIndex;
    } else {
        DWORD cbData;

        dwSignerIndex = 0;
        if (pdwSignerIndex)
            *pdwSignerIndex = 0;
        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 == dwSignerCount)
            goto NoSignerError;
    }

    // Minimum of one iteration
    for ( ; dwSignerCount > 0; dwSignerCount--, dwSignerIndex++) {
        if (fResult = ICM_GetAndVerifySigner(
                hCryptMsg,
                dwSignerIndex,
                cSignerStore,
                rghSignerStore,
                dwFlags,
                ppSigner)) {
            if (pdwSignerIndex && 0 == (dwFlags & CMSG_USE_SIGNER_INDEX_FLAG))
                *pdwSignerIndex = dwSignerIndex;
            break;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    if (ppSigner)
        *ppSigner = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
}

//+-------------------------------------------------------------------------
//  Sign an encoded CTL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgSignCTL(
    IN DWORD dwMsgEncodingType,
    IN BYTE *pbCtlContent,
    IN DWORD cbCtlContent,
    IN PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    IN DWORD dwFlags,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;

    DWORD dwMsgFlags;

#ifdef CMS_PKCS7
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CTL_FLAG)
        dwMsgFlags = CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    else
        dwMsgFlags = 0;
#else
    dwMsgFlags = 0;
#endif  // CMS_PKCS7

    if (NULL == pbEncoded) {
        if (0 == (*pcbEncoded = CryptMsgCalculateEncodedLength(
            dwMsgEncodingType,
            dwMsgFlags,
            CMSG_SIGNED,
            pSignInfo,
            szOID_CTL,
            cbCtlContent))) goto CalculateEncodedLengthError;
        fResult = TRUE;
    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwMsgFlags,
                CMSG_SIGNED,
                pSignInfo,
                szOID_CTL,
                NULL                        // pStreamInfo
                ))) goto OpenToEncodeError;
        if (!CryptMsgUpdate(
                hMsg,
                pbCtlContent,
                cbCtlContent,
                TRUE                        // fFinal
                )) goto UpdateError;

        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncoded,
            pcbEncoded);
    }

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return fResult;
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}


//+-------------------------------------------------------------------------
//  Encode the CTL and create a signed message containing the encoded CTL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgEncodeAndSignCTL(
    IN DWORD dwMsgEncodingType,
    IN PCTL_INFO pCtlInfo,
    IN PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    IN DWORD dwFlags,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    DWORD dwEncodingType;
    LPCSTR lpszStructType;
    DWORD dwEncodeFlags;

    dwEncodingType = (dwMsgEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;
    assert(dwEncodingType != 0);
    if (0 == dwEncodingType)
        goto InvalidArg;

    dwEncodeFlags = CRYPT_ENCODE_ALLOC_FLAG;
    if (dwFlags & CMSG_ENCODE_SORTED_CTL_FLAG) {
        lpszStructType = PKCS_SORTED_CTL;
        if (dwFlags & CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG)
            dwEncodeFlags |=
                CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG;
    } else {
        lpszStructType = PKCS_CTL;
    }


    if (!CryptEncodeObjectEx(
            dwEncodingType,
            lpszStructType,
            pCtlInfo,
            dwEncodeFlags,
            &PkiEncodePara,
            (void *) &pbContent,
            &cbContent
            )) goto EncodeError;

    fResult = CryptMsgSignCTL(
        dwMsgEncodingType,
        pbContent,
        cbContent,
        pSignInfo,
        dwFlags,
        pbEncoded,
        pcbEncoded
        );

CommonReturn:
    PkiFree(pbContent);
    return fResult;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(EncodeError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\wincrmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wincrmsg.cpp
//
//  Contents:   Cryptographic Message APIs
//
//  APIs:
//
//  History:    14-Feb-96   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"

HCRYPTASN1MODULE  ICM_hAsn1Module;

COssDecodeInfoNode::~COssDecodeInfoNode()
{
    PkiAsn1FreeInfo( ICM_GetDecoder(), m_data.iPDU, m_data.pvPDU);
}

CBlobNode::~CBlobNode()
{
    ICM_Free( m_data.pbData);
}

CSignerNode::~CSignerNode()
{
    ICM_Free( m_data.blob.pbData);
    delete m_data.pUnauthAttrList;
}

CHashNode::~CHashNode()
{
    ICM_Free( m_data.HashBlob.pbData);
    if (m_data.hHash)
        CryptDestroyHash( m_data.hHash);
}

inline
BOOL
ICM_IsAddInnerContentOctetWrapper(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
#ifdef CMS_PKCS7
    return NULL == pcmi->pszInnerContentObjID ||
        (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG);
#else
    return NULL == pcmi->pszInnerContentObjID;
#endif  // CMS_PKCS7
}


DWORD
ICM_GetTaggedBlobCount(
    IN CBlobList *pBlobList,
    IN BYTE bTag
    )
{
    DWORD dwCount = 0;
    CBlobNode *pBlobNode;

    for (pBlobNode=pBlobList->Head(); pBlobNode; pBlobNode=pBlobNode->Next()) {
        if (bTag == *(pBlobNode->Data()->pbData))
            dwCount++;
    }

    return dwCount;
}

// Advances index past other Tags
CBlobNode *
ICM_GetTaggedBlobAndAdvanceIndex(
    IN CBlobList *pBlobList,
    IN BYTE bTag,               // 0 => any
    IN OUT DWORD *pdwIndex
    )
{
    DWORD dwIndex = *pdwIndex;
    CBlobNode *pBlobNode;
    DWORD i;

    for (i=dwIndex, pBlobNode=pBlobList->Head();
            pBlobNode;
            pBlobNode=pBlobNode->Next()) {
        if (bTag && bTag != *(pBlobNode->Data()->pbData)) {
            // Advance index past other tags
            dwIndex++;
        } else {
            if (0 == i)
                break;
            else
                i--;
        }
    }

    *pdwIndex = dwIndex;
    return pBlobNode;
}


ObjectID aoidMessages[] = {
    { 7, {1,2,840,113549,1,7,1}}, // data
    { 7, {1,2,840,113549,1,7,2}}, // signed
    { 7, {1,2,840,113549,1,7,3}}, // enveloped
    { 7, {1,2,840,113549,1,7,4}}, // signed and enveloped
    { 7, {1,2,840,113549,1,7,5}}, // digested
    { 7, {1,2,840,113549,1,7,6}}, // encrypted
    { 7, {1,2,840,113549,1,7,7}}  // dual-signed
};
#define  COUNTOF_aoidMessages  (sizeof(aoidMessages)/sizeof(aoidMessages[0]))

ObjectID oidMessageDigest = { 7, {1,2,840,113549,1,9,4}};

const LPSTR apszObjIdPKCS7[] = {
    szOID_RSA_data              ,
    szOID_RSA_signedData        ,
    szOID_RSA_envelopedData     ,
    szOID_RSA_signEnvData       ,
    szOID_RSA_digestedData      ,
    szOID_RSA_encryptedData
};
const DWORD COUNTOF_apszObjIdPKCS7 = (sizeof(apszObjIdPKCS7)/sizeof(apszObjIdPKCS7[0]));
//#if  COUNTOF_apszObjIdPKCS7 - (sizeof(apszObjIdPKCS7)/sizeof(apszObjIdPKCS7[0]))
//#error COUNTOF_apszObjIdPKCS7 wrong
//#endif

const LPSTR pszObjIdDataType        = szOID_RSA_data;
const LPSTR pszObjIdContentType     = szOID_RSA_contentType;
const LPSTR pszObjIdMessageDigest   = szOID_RSA_messageDigest;


int aiPduNum[] = {
    OctetStringType_PDU,
    SignedData_PDU,
#ifdef CMS_PKCS7
    CmsEnvelopedData_PDU,
#else
    EnvelopedData_PDU,
#endif  // CMS_PKCS7
    SignedAndEnvelopedData_PDU,
    DigestedData_PDU,
    EncryptedData_PDU
};

/*
// Should be able to use aiPduNum, but first entry of aiPduNum
// seems to need to be 0. ????
int aiPduNum2[] = {
    OctetStringType_PDU,
    SignedData_PDU,
#ifdef CMS_PKCS7
    CmsEnvelopedData_PDU,
#else
    EnvelopedData_PDU,
#endif  // CMS_PKCS7
    SignedAndEnvelopedData_PDU,
    DigestedData_PDU,
    EncryptedData_PDU
};
*/

typedef struct _CRYPT_ABLOB {
    DWORD               cBlob;
    PCRYPT_DATA_BLOB    pBlob;
} CRYPT_ABLOB, *PCRYPT_ABLOB;


// Here is a table for keeping straight which phases are legal in which
// situations:
//
//          detached    !detached
//  encode  FO,FF       FF
//  decode  FF,SO,SF    FF
//
enum Phases {
    PHASE_FIRST_ONGOING     = 1,
    PHASE_FIRST_FINAL       = 2,
    PHASE_SECOND_ONGOING    = 3,
    PHASE_SECOND_FINAL      = 4
};


BOOL
WINAPI
ICM_GetAnyData(
    IN Any *pAny,
    OUT void *pvData,
    IN OUT DWORD *pcbData);


WINAPI
ICM_GetOssContentInfoData(
    IN ContentInfo *poci,
    OUT void *pvData,
    IN OUT DWORD *pcbData);

BOOL
WINAPI
ICM_GetSignerParamEncoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData);

BOOL
WINAPI
ICM_GetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss,
    OUT void *pvData,
    IN OUT DWORD *pcbData);

//+-------------------------------------------------------------------------
//  Lock and unlock HCRYPTMSG functions
//--------------------------------------------------------------------------
inline
void
ICM_Lock(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
    EnterCriticalSection( &pcmi->CriticalSection);
}
inline
void
ICM_Unlock(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
    LeaveCriticalSection( &pcmi->CriticalSection);
}


//+-------------------------------------------------------------------------
//  allocation and free routines
//--------------------------------------------------------------------------
void *
WINAPI
ICM_Alloc(
    IN size_t cb)
{
    void *pv;
    if (NULL == (pv = malloc(cb)))
        goto mallocError;
ErrorReturn:
    return pv;
SET_ERROR(mallocError,E_OUTOFMEMORY)
}

void *
WINAPI
ICM_AllocZero(
    IN size_t cb)
{
    void *pv;
    // Should map to LocalAlloc( ZERO_INIT).
    if (NULL != (pv = ICM_Alloc(cb)))
        memset( pv, 0, cb);
    return pv;
}

void *
WINAPI
ICM_ReAlloc(
    IN void     *pvOrg,
    IN size_t   cb)
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc( pvOrg, cb) : malloc( cb)))
        goto allocError;
ErrorReturn:
    return pv;
SET_ERROR(allocError,E_OUTOFMEMORY)
}

void
WINAPI
ICM_Free(
    IN void *pv)
{
    if (pv)
        free(pv);
}

// Stack allocations
// NB: Use heap allocs on DBG so we can more easily catch buffer over-runs, etc.
#if DBG
#define ICM_AllocA      ICM_Alloc
#define ICM_FreeA       ICM_Free
#else
#define ICM_AllocA      ICM_Alloc
#define ICM_FreeA       ICM_Free
// The following defines work fine on NT, but seem to have problems on Win95
// REASON: unknown
//#define ICM_AllocA(s)   alloca(((s)+7))
//#define ICM_FreeA(p)   
#endif

void *
WINAPI
ICM_AllocZeroA(
    IN size_t cbBytes)
{
    void *pv;
    if (NULL != (pv = ICM_AllocA(cbBytes)))
        memset( pv, 0, cbBytes);
    return pv;
}

void *ICM_DupMem(
    IN void     *pvIn,
    IN size_t   cb)
{
    void *pv = NULL;
    if (pvIn) {
        if (NULL != (pv = ICM_Alloc(cb)))
            memcpy( pv, pvIn, cb);
    } else {
        SetLastError((DWORD) E_INVALIDARG);
    }
    return pv;
}

size_t ICM_StrLen(const char *pszIn)
{
    return pszIn ? strlen(pszIn) : 0;
}


BOOL
WINAPI
ICM_AppendBlob(
    PCRYPT_DATA_BLOB    pblob,
    const BYTE          *pbIn,
    DWORD               cbIn)
{
    BOOL        fRet;
    PBYTE       pb = NULL;

    if (NULL == (pb = (PBYTE)ICM_ReAlloc(
                                pblob->pbData,
                                pblob->cbData + cbIn)))
        goto AllocError;
    memcpy( pb + pblob->cbData, pbIn, cbIn);
    pblob->pbData = pb;
    pblob->cbData += cbIn;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(AllocError)
}

#ifdef CMS_PKCS7
STATIC
BOOL
WINAPI
ICM_InsertMsgAlloc(
    IN PCRYPT_MSG_INFO pcmi,
    IN void *pv
    )
{
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    CRYPT_DATA_BLOB         blob;

    if (NULL == pcmi->pFreeList) {
        if (NULL == (pcmi->pFreeList = new CBlobList))
            goto OutOfMemory;
    }

    if (NULL == (pnBlob = new CBlobNode))
        goto OutOfMemory;

    blob.cbData = 0;
    blob.pbData = (BYTE *) pv;
    pnBlob->SetData(&blob);
    pcmi->pFreeList->InsertTail(pnBlob);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(OutOfMemory,E_OUTOFMEMORY)
}
#endif  // CMS_PKCS7

// Allocates algorithm parameters and inserts into the message's free
// list before doing the ICM_Asn1ToAlgorithmIdentifier
STATIC
BOOL
WINAPI
ICM_MsgAsn1ToAlgorithmIdentifier(
    IN PCRYPT_MSG_INFO pcmi,
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
#ifdef CMS_PKCS7
    CRYPT_ALGORITHM_IDENTIFIER ai;

    if (pcmi && 0 < pai->Parameters.cbData) {
        ai = *pai;
        if (NULL == (ai.Parameters.pbData = (BYTE *) ICM_DupMem(
                ai.Parameters.pbData, ai.Parameters.cbData)))
            return FALSE;
        if (!ICM_InsertMsgAlloc(pcmi, ai.Parameters.pbData)) {
            ICM_Free(ai.Parameters.pbData);
            return FALSE;
        }
        pai = &ai;
    }
#endif  // CMS_PKCS7

    return ICM_Asn1ToAlgorithmIdentifier(pai, pOssAlgId);
}

//+-------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
STATIC BOOL WINAPI
ICM_PkcsSignerInfoEncode(
    IN DWORD                dwCertEncodingType,
    IN LPCSTR               lpszStructType,
    IN PCMSG_SIGNER_INFO    pInfo,
    OUT PBYTE               pbEncoded,
    IN OUT PDWORD           pcbEncoded);

STATIC BOOL WINAPI
ICM_PkcsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo);

STATIC BOOL WINAPI
ICM_CmsSignerInfoEncode(
    IN DWORD                dwCertEncodingType,
    IN LPCSTR               lpszStructType,
    IN PCMSG_CMS_SIGNER_INFO pInfo,
    OUT PBYTE               pbEncoded,
    IN OUT PDWORD           pcbEncoded);

STATIC BOOL WINAPI
ICM_CmsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_CMS_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo);

#ifdef OSS_CRYPT_ASN1
#define ASN1_OID_OFFSET         10000 +
#define ASN1_OID_PREFIX         "OssCryptAsn1."
#else
#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX
#endif  // OSS_CRYPT_ASN1

STATIC
const
CRYPT_OID_FUNC_ENTRY
ICM_EncodeFuncTable[] = {
    ASN1_OID_OFFSET PKCS7_SIGNER_INFO, ICM_PkcsSignerInfoEncode,
    ASN1_OID_OFFSET CMS_SIGNER_INFO, ICM_CmsSignerInfoEncode,
};

#define ICM_ENCODE_FUNC_COUNT \
    (sizeof(ICM_EncodeFuncTable) / sizeof(ICM_EncodeFuncTable[0]))

STATIC
const
CRYPT_OID_FUNC_ENTRY
ICM_DecodeFuncTable[] = {
    ASN1_OID_OFFSET PKCS7_SIGNER_INFO, ICM_PkcsSignerInfoDecode,
    ASN1_OID_OFFSET CMS_SIGNER_INFO, ICM_CmsSignerInfoDecode,
};

#define ICM_DECODE_FUNC_COUNT \
    (sizeof(ICM_DecodeFuncTable) / sizeof(ICM_DecodeFuncTable[0]))

#ifdef CMS_PKCS7

static HCRYPTOIDFUNCSET hOldStyleGenEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hOldStyleExportEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hOldStyleImportEncryptKeyFuncSet;

static HCRYPTOIDFUNCSET hGenContentEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hExportKeyTransFuncSet;
static HCRYPTOIDFUNCSET hExportKeyAgreeFuncSet;
static HCRYPTOIDFUNCSET hExportMailListFuncSet;
static HCRYPTOIDFUNCSET hImportKeyTransFuncSet;
static HCRYPTOIDFUNCSET hImportKeyAgreeFuncSet;
static HCRYPTOIDFUNCSET hImportMailListFuncSet;

//+-------------------------------------------------------------------------
//  GenContentEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY GenContentEncryptKeyFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultGenContentEncryptKey
};

//+-------------------------------------------------------------------------
//  ExportKeyTrans OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportKeyTransFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportKeyTrans
};

//+-------------------------------------------------------------------------
//  ExportKeyAgree OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportKeyAgreeFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportKeyAgree
};

//+-------------------------------------------------------------------------
//  ExportMailList OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportMailListFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportMailList
};

//+-------------------------------------------------------------------------
//  ImportKeyTrans OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportKeyTransFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportKeyTrans
};

//+-------------------------------------------------------------------------
//  ImportKeyAgree OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyAgree(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportKeyAgreeFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportKeyAgree
};

//+-------------------------------------------------------------------------
//  ImportMailList OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportMailList(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportMailListFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportMailList
};

#else

static HCRYPTOIDFUNCSET hGenEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hExportEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hImportEncryptKeyFuncSet;

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  GenEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

// rgcbEncryptParameters[1] contains the dwEncryptFlags passed to
// ICM_DefaultExportEncryptKey
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2]);

static const CRYPT_OID_FUNC_ENTRY GenEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_DES_EDE3_CBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_RC2CBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_RC4, ICM_DefaultGenEncryptKey
};
#define GEN_ENCRYPT_KEY_FUNC_COUNT (sizeof(GenEncryptKeyFuncTable) / \
                                        sizeof(GenEncryptKeyFuncTable[0]))

//+-------------------------------------------------------------------------
//  ExportEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

// rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2]);

static const CRYPT_OID_FUNC_ENTRY ExportEncryptKeyFuncTable[] = {
    szOID_RSA_RSA, ICM_DefaultExportEncryptKey
};
#define EXPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ExportEncryptKeyFuncTable) / \
                                        sizeof(ExportEncryptKeyFuncTable[0]))

//+-------------------------------------------------------------------------
//  ImportEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

static const CRYPT_OID_FUNC_ENTRY ImportEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_DES_EDE3_CBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_RC2CBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_RC4, ICM_DefaultImportEncryptKey
};
#define IMPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ImportEncryptKeyFuncTable) / \
                                        sizeof(ImportEncryptKeyFuncTable[0]))

#ifdef DEBUG_CRYPT_ASN1_MASTER
static HMODULE hOssCryptDll = NULL;
#endif  // DEBUG_CRYPT_ASN1_MASTER

#ifdef DEBUG_CRYPT_ASN1

#define DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG              0x010
#define DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG      0x020
#define DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG      0x100

static BOOL fGotDebugCryptAsn1Flags = FALSE;
static int iDebugCryptAsn1Flags = 0;

int
WINAPI
ICMTest_GetDebugCryptAsn1Flags();

#endif  // DEBUG_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Function:  CryptMsgDllMain
//
//  Synopsis:  Initialize the CryptMsg module
//
//  Returns:   FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL        fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                ICM_ENCODE_FUNC_COUNT,
                ICM_EncodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                ICM_DECODE_FUNC_COUNT,
                ICM_DecodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

#ifdef CMS_PKCS7
        if (NULL == (hOldStyleGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hOldStyleExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hOldStyleImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hGenContentEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hExportKeyTransFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_KEY_TRANS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportKeyAgreeFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_KEY_AGREE_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportMailListFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_MAIL_LIST_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hImportKeyTransFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_KEY_TRANS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportKeyAgreeFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_KEY_AGREE_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportMailListFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_MAIL_LIST_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
                1,
                GenContentEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_KEY_TRANS_FUNC,
                1,
                ExportKeyTransFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_KEY_AGREE_FUNC,
                1,
                ExportKeyAgreeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_MAIL_LIST_FUNC,
                1,
                ExportMailListFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_KEY_TRANS_FUNC,
                1,
                ImportKeyTransFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_KEY_AGREE_FUNC,
                1,
                ImportKeyAgreeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_MAIL_LIST_FUNC,
                1,
                ImportMailListFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
#else

        if (NULL == (hGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
#endif  // CMS_PKCS7

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GEN_ENCRYPT_KEY_FUNC_COUNT,
                GenEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                EXPORT_ENCRYPT_KEY_FUNC_COUNT,
                ExportEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                IMPORT_ENCRYPT_KEY_FUNC_COUNT,
                ImportEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

#ifdef OSS_CRYPT_ASN1
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(pkcs, 0, NULL)))
            goto CryptInstallAsn1ModuleError;
#else
        PKCS_Module_Startup();
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(
                PKCS_Module, 0, NULL))) {
            PKCS_Module_Cleanup();
            goto CryptInstallAsn1ModuleError;
        }
#endif  // OSS_CRYPT_ASN1

        break;

    case DLL_PROCESS_DETACH:
#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (hOssCryptDll) {
            FreeLibrary(hOssCryptDll);
            hOssCryptDll = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER
        I_CryptUninstallAsn1Module(ICM_hAsn1Module);
#ifndef OSS_CRYPT_ASN1
        PKCS_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInstallAsn1ModuleError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
lpReserved;
hInst;
}

//+-------------------------------------------------------------------------
//  Utility routines
//--------------------------------------------------------------------------
LONG
WINAPI
ICM_PszOidToIndex(
    IN LPSTR pszOID)
{
    LONG    i;

    for (i=COUNTOF_apszObjIdPKCS7; i>0; i--)
        if (0 == strcmp( apszObjIdPKCS7[i-1], pszOID))
            break;

    return i;
}


LONG
WINAPI
ICM_ObjIdToIndex(
    IN ObjectID *poi)
{
    LONG    i;
    LONG    j;

    for (i=COUNTOF_aoidMessages; i>0; i--) {
        if (aoidMessages[i-1].count == poi->count) {
            for (j=poi->count; j>0; j--)
                if (poi->value[j-1] != aoidMessages[i-1].value[j-1])
                    goto next;
            break;
        }
        next:
        ;
    }

    return i;
}


BOOL
WINAPI
ICM_CopyOssObjectIdentifier(
    OUT ObjectID    *poiDst,
    IN  ObjectID    *poiSrc)
{
    USHORT  i;
    ULONG   *pulDst;
    ULONG   *pulSrc;

    poiDst->count = poiSrc->count;
    for (i=poiSrc->count, pulDst=poiDst->value, pulSrc=poiSrc->value;
            i>0;
            i--, pulDst++, pulSrc++)
        *pulDst = *pulSrc;

    return TRUE;
}


BOOL
WINAPI
ICM_IsData(
    IN  LPSTR   pszContentType)
{
    return !pszContentType || (0 == strcmp( pszContentType, pszObjIdDataType));
}


BOOL
WINAPI
ICM_ReverseInPlace(
    IN OUT PBYTE    pbIn,
    IN const ULONG  cbIn)
{
    PBYTE   pbLo;
    PBYTE   pbHi;
    BYTE    bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }

    return TRUE;
}


BOOL
WINAPI
ICM_ReverseCopy(
    OUT PBYTE   pbOut,
    IN PBYTE    pbInOrg,
    IN ULONG    cbIn)
{
    PBYTE   pbIn = pbInOrg + cbIn - 1;

    while (cbIn-- > 0)
        *pbOut++ = *pbIn--;

    return TRUE;
}


//
// return FALSE iff equal
//
BOOL
WINAPI
ICM_ReverseCompare(
    IN PBYTE    pbInOrg1,
    IN PBYTE    pbInOrg2,
    IN ULONG    cb)
{
    PBYTE   pbIn1 = pbInOrg1;
    PBYTE   pbIn2 = pbInOrg2 + cb - 1;

    while (cb-- > 0)
        if (*pbIn1++ != *pbIn2--)
            return TRUE;

    return FALSE;
}


BOOL
WINAPI
ICM_CopyOut(
    IN PBYTE        pbData,
    IN DWORD        cbData,
    OUT PBYTE       pbOut,
    IN OUT PDWORD   pcbOut)
{
    BOOL            fRet = TRUE;

    if (pbOut) {
        if (*pcbOut < cbData) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else {
            memcpy(pbOut, pbData, cbData);
        }
    }
    *pcbOut = cbData;

    return fRet;
}


//+-------------------------------------------------------------------------
//  Copy out the encoding of the length octets for a specified content length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetLengthOctets(
    IN DWORD            cbContent,
    OUT OPTIONAL PBYTE  pbOut,
    IN OUT PDWORD       pcbOut)
{
    BOOL            fRet;
    BYTE            rgbLength[5];
    DWORD           cbLength;

    if (cbContent < 0x80) {
        rgbLength[0] = (BYTE)cbContent;
        cbLength = 0;
    } else {
        if (cbContent > 0xffffff)
            cbLength = 4;
        else if (cbContent > 0xffff)
            cbLength = 3;
        else if (cbContent > 0xff)
            cbLength = 2;
        else
            cbLength = 1;
        if (pbOut) {
            rgbLength[0] = (BYTE)cbLength | 0x80;
            ICM_ReverseCopy( (PBYTE)(rgbLength+1), (PBYTE)&cbContent, cbLength);
        }
    }

    if (pbOut) {
        fRet = ICM_CopyOut( (PBYTE)rgbLength, cbLength+1, pbOut, pcbOut);
    } else {
        fRet = TRUE;
    }
    *pcbOut = cbLength + 1;

    assert(fRet);
    return fRet;
}


//+-------------------------------------------------------------------------
//  Copy out a buffer, prepending the identifier and length octets for a
//  DER encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CopyOutAddDERPrefix(
    IN PBYTE            pbContent,
    IN DWORD            cbContent,
    IN OPTIONAL BYTE    bTag,
    OUT PBYTE           pbOut,
    IN OUT PDWORD       pcbOut)
{
    BOOL            fRet;
    BYTE            rgbLength[5];
    DWORD           cbLength;
    DWORD           cbData;

    cbLength = sizeof(rgbLength);
    if (!ICM_GetLengthOctets( cbContent, (PBYTE)rgbLength, &cbLength))
        goto GetLengthOctetsError;

    fRet = TRUE;
    cbData = 1 + cbLength + cbContent;
    if (pbOut) {
        if (*pcbOut < cbData) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else {
            *pbOut++ = bTag;
            memcpy(pbOut, rgbLength, cbLength);
            pbOut += cbLength;
            memcpy(pbOut, pbContent, cbContent);
        }
    }

CommonReturn:
    *pcbOut = cbData;
    return fRet;

ErrorReturn:
    cbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetLengthOctetsError)    // error already set
}


BOOL
WINAPI
ICM_GetSizeFromExtra(
    IN LONG         lRemainExtra,
    OUT PVOID       pOut,
    IN OUT DWORD    *pcbOut)
{
    BOOL            fRet = TRUE;

    if ((lRemainExtra < 0) && pOut) {
        SetLastError((DWORD) ERROR_MORE_DATA);
        fRet = FALSE;
    }
    *pcbOut = (DWORD)((LONG)*pcbOut - lRemainExtra);

    return fRet;
}


VOID
WINAPI
ICM_SetLastError(
    IN DWORD    dwError)
{
    if (dwError != ERROR_SUCCESS)
        SetLastError( dwError);
}


//+-------------------------------------------------------------------------
//  Encode an OSS struct to a blob, internally allocated
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1Encode(
    ASN1uint32_t            pdunum,
    IN PVOID                pOssInfo,
    OUT PCRYPT_DATA_BLOB    pBlob)
{
    BOOL            fRet;
    PBYTE           pbEncoded = NULL;
    DWORD           cbEncoded;
    ASN1encoding_t  pEnc = ICM_GetEncoder();
    DWORD           dwError = ERROR_SUCCESS;

    if (!PkiAsn1EncodeInfo(
            pEnc,
            pdunum,
            pOssInfo,
            NULL,           // pbEncoded
            &cbEncoded))
        goto EncodeSizeError;
    if (NULL == (pbEncoded = (PBYTE)ICM_Alloc( cbEncoded)))
        goto AllocError;
    if (!PkiAsn1EncodeInfo(
            pEnc,
            pdunum,
            pOssInfo,
            pbEncoded,
            &cbEncoded))
        goto EncodeError;

    fRet = TRUE;
CommonReturn:
    pBlob->pbData = pbEncoded;
    pBlob->cbData = cbEncoded;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(pbEncoded);
    pbEncoded = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeSizeError)    // error already set
TRACE_ERROR(AllocError)         // error already set
TRACE_ERROR(EncodeError)        // error already set
}

//+-------------------------------------------------------------------------
//  Given an OID, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCAPIFromOID(
    IN DWORD                        dwGroupId,
    IN LPSTR                        pszObjId,
    OUT PDWORD                      pdwAlgId)
{
    BOOL            fRet;
    PCCRYPT_OID_INFO pOIDInfo;

    if (NULL == (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pszObjId,
            dwGroupId))) goto NotFoundError;
    *pdwAlgId = pOIDInfo->Algid;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    *pdwAlgId = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(NotFoundError)
}

//+-------------------------------------------------------------------------
//  Given an CRYPT_ALGORITHM_IDENTIFIER, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCAPI(
    IN DWORD                        dwGroupId,
    IN PCRYPT_ALGORITHM_IDENTIFIER  pai,
    OUT PDWORD                      pdwAlgId)
{
    return ICM_GetCAPIFromOID(dwGroupId, pai->pszObjId, pdwAlgId);
}

//+-------------------------------------------------------------------------
//  Given an OSS AlgorithmIdentifier, return the OID Info
//
//  Caller sets error.
//--------------------------------------------------------------------------
PCCRYPT_OID_INFO
WINAPI
ICM_GetOssOIDInfo(
    IN DWORD                    dwGroupId,
    IN AlgorithmIdentifier      *poai)
{
    PCCRYPT_OID_INFO            pInfo;
    CRYPT_ALGORITHM_IDENTIFIER  ai;   ZEROSTRUCT( ai);

    if (!ICM_Asn1FromAlgorithmIdentifier( poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    pInfo = CryptFindOIDInfo(
        CRYPT_OID_INFO_OID_KEY,
        ai.pszObjId,
        dwGroupId);
CommonReturn:
    ICM_Free( ai.pszObjId);
    return pInfo;

ErrorReturn:
    pInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
}


//+-------------------------------------------------------------------------
//  Given an OSS AlgorithmIdentifier, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCAPI(
    IN DWORD                    dwGroupId,
    IN AlgorithmIdentifier      *poai,
    OUT PDWORD                  pdwAlgId)
{
    BOOL                        fRet;
    CRYPT_ALGORITHM_IDENTIFIER  ai;   ZEROSTRUCT( ai);

    if (!ICM_Asn1FromAlgorithmIdentifier( poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    fRet = ICM_GetCAPI( dwGroupId, &ai, pdwAlgId);
CommonReturn:
    ICM_Free( ai.pszObjId);
    return fRet;

ErrorReturn:
    *pdwAlgId = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
}

//+-------------------------------------------------------------------------
//  Allocate and NOCOPY decode
//--------------------------------------------------------------------------
PVOID
WINAPI
ICM_AllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    void *pvStructInfo = NULL;
    DWORD cbStructInfo;
    
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvStructInfo
            &cbStructInfo
            ) || 0 == cbStructInfo)
        goto DecodeError;
    if (NULL == (pvStructInfo = ICM_Alloc(cbStructInfo)))
        goto OutOfMemory;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvStructInfo,
            &cbStructInfo
            ))
        goto DecodeError;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    ICM_Free(pvStructInfo);
    pvStructInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
TRACE_ERROR(OutOfMemory)
}

PCRYPT_ALGORITHM_IDENTIFIER
WINAPI
ICM_AllocAndGetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss)
{
    PCRYPT_ALGORITHM_IDENTIFIER pai = NULL;
    DWORD cbData;

    if (!ICM_GetALGORITHM_IDENTIFIER(
            paiOss,
            NULL,               // pvData
            &cbData) || 0 == cbData)
        goto GetAlgorithmError;
    if (NULL == (pai = (PCRYPT_ALGORITHM_IDENTIFIER)ICM_Alloc(cbData)))
        goto OutOfMemory;;
    if (!ICM_GetALGORITHM_IDENTIFIER(
            paiOss,
            pai,
            &cbData))
        goto GetAlgorithmError;

CommonReturn:
    return pai;
ErrorReturn:
    ICM_Free(pai);
    pai = NULL;
    goto CommonReturn;
TRACE_ERROR(GetAlgorithmError);
TRACE_ERROR(OutOfMemory)

}

#ifdef CMS_PKCS7

void *
WINAPI
ICM_AllocAndGetParam(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT OPTIONAL DWORD *pcbData = NULL
    )
{
    void *pvData = NULL;
    DWORD cbData;

    if (!CryptMsgGetParam(
            (HCRYPTMSG) pcmi,
            dwParamType,
            dwIndex,
            NULL,                   // pvData
            &cbData))
        goto CryptMsgGetParamError;
    if (0 == cbData)
        goto NoParamData;
    if (NULL == (pvData = ICM_Alloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            (HCRYPTMSG) pcmi,
            dwParamType,
            dwIndex,
            pvData,
            &cbData))
        goto CryptMsgGetParamError;

CommonReturn:
    if (pcbData)
        *pcbData = cbData;
    return pvData;
ErrorReturn:
    if (pvData) {
        ICM_Free(pvData);
        pvData = NULL;
    }
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(CryptMsgGetParamError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(NoParamData, CRYPT_E_INVALID_MSG_TYPE)
}

#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_RC2VersionToBitLength(
    IN DWORD        dwVersion,
    OUT PDWORD      pdwBitLen
    )
{
    BOOL fRet;
    DWORD dwBitLen;

    switch (dwVersion) {
        case CRYPT_RC2_40BIT_VERSION:
            dwBitLen = 40;
            break;
        case CRYPT_RC2_56BIT_VERSION:
            dwBitLen = 56;
            break;
        case CRYPT_RC2_64BIT_VERSION:
            dwBitLen = 64;
            break;
        case CRYPT_RC2_128BIT_VERSION:
            dwBitLen = 128;
            break;
        default:
            goto InvalidRC2VersionError;
    }

    fRet = TRUE;
CommonReturn:
    *pdwBitLen = dwBitLen;
    return fRet;

ErrorReturn:
    dwBitLen = 0;
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidRC2VersionError, CRYPT_E_BAD_ENCODE)
}

BOOL
WINAPI
ICM_BitLengthToRC2Version(
    IN DWORD        dwBitLen,
    OUT PDWORD      pdwVersion
    )
{
    BOOL fRet;
    DWORD dwVersion;

    switch (dwBitLen) {
        case 40:
            dwVersion = CRYPT_RC2_40BIT_VERSION;
            break;
        case 56:
            dwVersion = CRYPT_RC2_56BIT_VERSION;
            break;
        case 64:
            dwVersion = CRYPT_RC2_64BIT_VERSION;
            break;
        case 128:
            dwVersion = CRYPT_RC2_128BIT_VERSION;
            break;
        default:
            goto InvalidArg;
    }

    fRet = TRUE;
CommonReturn:
    *pdwVersion = dwVersion;
    return fRet;

ErrorReturn:
    dwVersion = 0xFFFFFFFF;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

#define IV_LENGTH                   8

// For RC4, the maximum salt length, (128 - 40)/8 = 11.
#define IV_MAX_LENGTH               11

#define AUX_INFO_BIT_LENGTH_MASK    0xFFFF

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. If the
//  ASN.1 encryption algorithm has any parameters, decode to get IV and
//  key bit length.
//
//  Note, for RC4, the IV is its salt.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen,          // 0 => default length
    OUT BYTE                        rgbIV[IV_MAX_LENGTH],
    OUT PDWORD                      pcbIV
    )
{
    BOOL fRet;
    PCRYPT_DATA_BLOB pIVBlob = NULL;
    PCRYPT_RC2_CBC_PARAMETERS pRC2Para = NULL;

    *pdwBitLen = 0;
    *pcbIV = 0;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    // Check if more than just the NULL parameters
    if (2 < paiEncrypt->Parameters.cbData) {
        PBYTE pbIV = NULL;
        DWORD cbIV = 0;
        PBYTE pbEncoded = paiEncrypt->Parameters.pbData;
        DWORD cbEncoded = paiEncrypt->Parameters.cbData;

        if (CALG_RC2 == *pdwAlgIdEncrypt) {
            // Try to decode as RC2_CBC parameters
            if (pRC2Para =
                    (PCRYPT_RC2_CBC_PARAMETERS) ICM_AllocAndDecodeObject(
                        PKCS_RC2_CBC_PARAMETERS,
                        pbEncoded,
                        cbEncoded)) {
                if (!ICM_RC2VersionToBitLength(pRC2Para->dwVersion, pdwBitLen))
                    goto RC2VersionToBitLengthError;
                if (pRC2Para->fIV) {
                    pbIV = pRC2Para->rgbIV;
                    cbIV = sizeof(pRC2Para->rgbIV);
                }
            }
        }

        if (NULL == pRC2Para) {
            // Try to decode as an OctetString containing the IV or the
            // salt for RC4
            if (pIVBlob = (PCRYPT_DATA_BLOB) ICM_AllocAndDecodeObject(
                    X509_OCTET_STRING,
                    pbEncoded,
                    cbEncoded)) {
                pbIV = pIVBlob->pbData;
                cbIV = pIVBlob->cbData;
            } else
                goto DecodeError;
        }

        if (0 != cbIV) {
            if (IV_LENGTH != cbIV &&
                    (CALG_RC4 != *pdwAlgIdEncrypt ||
                        IV_MAX_LENGTH < cbIV))
                goto InvalidIVLengthError;
            memcpy(rgbIV, pbIV, cbIV);
            *pcbIV = cbIV;
        }
    }
    fRet = TRUE;
CommonReturn:
    ICM_Free(pIVBlob);
    ICM_Free(pRC2Para);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(DecodeError)
TRACE_ERROR(RC2VersionToBitLengthError)
SET_ERROR(InvalidIVLengthError, CRYPT_E_BAD_ENCODE)
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2_CBC parameters.
//  For all others encode as an IV octet string. The IV is initialized by
//  calling CryptGenRandom. For RC4, the IV is really its salt.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultEncryptParameters(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    OUT PDWORD pdwAlgIdEncrypt,
    OUT PDWORD pdwBitLen,          // 0 => default length
    OUT BYTE rgbIV[IV_MAX_LENGTH],
    OUT PDWORD pcbIV
    )
{
    BOOL fRet;
    HCRYPTPROV hCryptProv;      // doesn't need to be released
    CRYPT_RC2_CBC_PARAMETERS RC2Para;
    CRYPT_DATA_BLOB IVPara;
    void *pvPara;
    LPCSTR pszStructType;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pContentEncryptInfo->ContentEncryptionAlgorithm;
    DWORD dwBitLen = 0;
    DWORD cbIV = IV_LENGTH;

    CRYPT_ENCODE_PARA EncodePara;

    // Get provider to use for generating the random IV or RC4 salt
    hCryptProv = I_CryptGetDefaultCryptProv(0);
    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;


    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo =
            (PCMSG_RC2_AUX_INFO) pContentEncryptInfo->pvEncryptionAuxInfo;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            dwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;
            if (!ICM_BitLengthToRC2Version(dwBitLen, &RC2Para.dwVersion))
                goto BitLengthToRC2VersionError;
        } else {
            // Default to 40 bits;
            dwBitLen = 40;
            RC2Para.dwVersion = CRYPT_RC2_40BIT_VERSION;
        }

        // Generate the random IV.
        if (!CryptGenRandom(hCryptProv, IV_LENGTH, rgbIV))
            goto GenRandomError;

        // Encode as RC2_CBC parameters
        RC2Para.fIV = TRUE;
        assert(sizeof(RC2Para.rgbIV) == IV_LENGTH);
        memcpy(RC2Para.rgbIV, rgbIV, sizeof(RC2Para.rgbIV));

        pvPara = &RC2Para;
        pszStructType = PKCS_RC2_CBC_PARAMETERS;
    } else {
        if (CALG_RC4 == *pdwAlgIdEncrypt) {
            // For RC4, the IV is really the RC4 salt. There are
            // (128 - dwBitLen)/8 bytes of RC4 salt.

            PCMSG_RC4_AUX_INFO pAuxInfo =
                (PCMSG_RC4_AUX_INFO) pContentEncryptInfo->pvEncryptionAuxInfo;

            // Default to no salt
            cbIV = 0;

            if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC4_AUX_INFO)) {
                dwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;
                if (0 == (pAuxInfo->dwBitLen & CMSG_RC4_NO_SALT_FLAG) &&
                        128 > dwBitLen) {
                    cbIV = (128 - dwBitLen)/ 8;
                    if (IV_MAX_LENGTH < cbIV)
                        cbIV = IV_MAX_LENGTH;
                }
            }

            if (0 == cbIV)
                // No salt
                goto SuccessReturn;
        }

        // Generate the random IV or RC4 salt
        assert(0 < cbIV && IV_MAX_LENGTH >= cbIV);
        if (!CryptGenRandom(hCryptProv, cbIV, rgbIV))
            goto GenRandomError;

        IVPara.pbData = rgbIV;
        IVPara.cbData = cbIV;
        pvPara = &IVPara;
        pszStructType = X509_OCTET_STRING;
    }


    ZEROSTRUCT(EncodePara);
    EncodePara.cbSize = sizeof(EncodePara);
    EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
    EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            CRYPT_ENCODE_ALLOC_FLAG,
            &EncodePara,
            (void *) &paiEncrypt->Parameters.pbData,
            &paiEncrypt->Parameters.cbData
            )) goto EncodeError;
    pContentEncryptInfo->dwFlags |= CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    *pdwBitLen = dwBitLen;
    *pcbIV = cbIV;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(GenRandomError)
TRACE_ERROR(EncodeError)
}


BOOL
WINAPI
ICM_IsSP3CompatibleEncrypt(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    void *pvEncryptAuxInfo = pContentEncryptInfo->pvEncryptionAuxInfo;
    BOOL fSP3CompatibleEncrypt = FALSE;

    if (pvEncryptAuxInfo) {
        PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
            (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
        if (sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) <= pSP3AuxInfo->cbSize &&
                (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {
            fSP3CompatibleEncrypt = TRUE;
        }
    }

    return fSP3CompatibleEncrypt;
}

//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultGenContentEncryptKey(
#else
ICM_DefaultGenContentEncryptKey(
#endif
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pContentEncryptInfo->ContentEncryptionAlgorithm;
    DWORD dwAlgIdEncrypt;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;
    DWORD dwBitLen;
    HCRYPTPROV hCryptProv;
    DWORD dwGenFlags;

    BOOL fSP3CompatibleEncrypt;

    fSP3CompatibleEncrypt = ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo);
    if (fSP3CompatibleEncrypt) {
        cbIV = 0;
        dwBitLen = 0;

        if (!ICM_GetCAPI(
                CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
                paiEncrypt,
                &dwAlgIdEncrypt))
            goto GetCAPIError;

    } else if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultEncryptParameters(
                pContentEncryptInfo,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto CreateDefaultEncryptParametersError;
    } else {
        if (!ICM_GetEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto GetEncryptParametersError;
    }

    hCryptProv = pContentEncryptInfo->hCryptProv;
    if (0 == hCryptProv) {
        DWORD dwAlgIdPubKey = 0;

        if (0 < pContentEncryptInfo->cRecipients) {
            PCMSG_RECIPIENT_ENCODE_INFO prei;
            PCRYPT_ALGORITHM_IDENTIFIER paiPubKey;

            // Get pointer to public key algorithm associated with the first
            // recipient
            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            switch (prei->dwRecipientChoice) {
                case CMSG_KEY_TRANS_RECIPIENT:
                    paiPubKey = &prei->pKeyTrans->KeyEncryptionAlgorithm;
                    break;
                case CMSG_KEY_AGREE_RECIPIENT:
                    paiPubKey = &prei->pKeyAgree->KeyEncryptionAlgorithm;
                    break;
                case CMSG_MAIL_LIST_RECIPIENT:
                default:
                    paiPubKey = NULL;
            }

            if (paiPubKey)
                ICM_GetCAPI(
                    CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                    paiPubKey,
                    &dwAlgIdPubKey);
        }

        hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
            dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        else
            pContentEncryptInfo->hCryptProv = hCryptProv;
    }

    if (fSP3CompatibleEncrypt)
        dwGenFlags = CRYPT_EXPORTABLE;
    else
        dwGenFlags = CRYPT_EXPORTABLE | CRYPT_NO_SALT;
    dwGenFlags |= dwBitLen << 16;

    fRet = CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            dwGenFlags,
            &pContentEncryptInfo->hContentEncryptKey);

    if (!fRet) {
        // Only need to provide backwards compatibility for
        // key transport recipients
        if (0 < pContentEncryptInfo->cRecipients) {
            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_TRANS_RECIPIENT != prei->dwRecipientChoice)
                goto GenKeyError;
        }

        if (dwBitLen) {
            // Try without setting key length
            dwGenFlags &= 0xFFFF;
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    dwGenFlags,
                    &pContentEncryptInfo->hContentEncryptKey);
        }

        if (!fRet && NTE_BAD_FLAGS == GetLastError())
            // Previous versions didn't support CRYPT_NO_SALT flag
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    CRYPT_EXPORTABLE,       // dwFlags
                    &pContentEncryptInfo->hContentEncryptKey);
        if (!fRet) {
            pContentEncryptInfo->hContentEncryptKey = 0;
            goto GenKeyError;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            pContentEncryptInfo->hContentEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV

            CRYPT_DATA_BLOB SaltBlob;
            SaltBlob.pbData = rgbIV;
            SaltBlob.cbData = cbIV;

            if (!CryptSetKeyParam(
                    pContentEncryptInfo->hContentEncryptKey,
                    KP_SALT_EX,
                    (PBYTE) &SaltBlob,
                    0))                 // dwFlags
                goto SetSaltExError;
        } else {
            if (!CryptSetKeyParam(
                    pContentEncryptInfo->hContentEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateDefaultEncryptParametersError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}


BOOL
WINAPI
ICM_GenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    LPCSTR pszContentEncryptOID =
        pContentEncryptInfo->ContentEncryptionAlgorithm.pszObjId;

    if (CryptGetOIDFunctionAddress(
            hGenContentEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pszContentEncryptOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY) pvFuncAddr)(
            pContentEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
    } else {
        if (pContentEncryptInfo->cRecipients
                        &&
                CMSG_KEY_TRANS_RECIPIENT ==
                    pContentEncryptInfo->rgCmsRecipients[0].dwRecipientChoice
                        &&
                CryptGetOIDFunctionAddress(
                    hOldStyleGenEncryptKeyFuncSet,
                    X509_ASN_ENCODING,
                    pszContentEncryptOID,
                    0,                      // dwFlags
                    &pvFuncAddr,
                    &hFuncAddr)
                        &&
#ifdef DEBUG_CRYPT_ASN1
                0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG)
                        &&
#endif // DEBUG_CRYPT_ASN1
                (void *) ICM_DefaultGenEncryptKey != pvFuncAddr) {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                pContentEncryptInfo->rgCmsRecipients[0].pKeyTrans;
            CERT_PUBLIC_KEY_INFO PublicKeyInfo;
            PBYTE pbEncryptParameters = NULL;
            DWORD rgcbEncryptParameters[2] = {0, 0};

            PublicKeyInfo.Algorithm = pKeyTrans->KeyEncryptionAlgorithm;
            PublicKeyInfo.PublicKey = pKeyTrans->RecipientPublicKey;

            fRet = ((PFN_CMSG_GEN_ENCRYPT_KEY) pvFuncAddr)(
                &pContentEncryptInfo->hCryptProv,
                &pContentEncryptInfo->ContentEncryptionAlgorithm,
                pContentEncryptInfo->pvEncryptionAuxInfo,
                &PublicKeyInfo,
                pContentEncryptInfo->pfnAlloc,
                &pContentEncryptInfo->hContentEncryptKey,
                &pbEncryptParameters,
                rgcbEncryptParameters);
            if (pbEncryptParameters) {
                pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData =
                    pbEncryptParameters;
                pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData =
                    rgcbEncryptParameters[0];
                pContentEncryptInfo->dwFlags |=
                    CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;
            }
        } else {
            fRet = ICM_DefaultGenContentEncryptKey(
                pContentEncryptInfo,
                0,                      // dwFlags
                NULL                    // pvReserved
                );
        }
    }

    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fRet;
}

//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_DefaultExportEncryptKey
//
//  OldStyle.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL fRet;

    CMSG_CONTENT_ENCRYPT_INFO ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);
    CMSG_RECIPIENT_ENCODE_INFO CmsRecipientEncodeInfo;
        ZEROSTRUCT(CmsRecipientEncodeInfo);
    CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO KeyTransEncodeInfo;
        ZEROSTRUCT(KeyTransEncodeInfo);

    ContentEncryptInfo.cbSize = sizeof(ContentEncryptInfo);
    ContentEncryptInfo.hCryptProv = *phCryptProv;
    ContentEncryptInfo.ContentEncryptionAlgorithm = *paiEncrypt;
    ContentEncryptInfo.pvEncryptionAuxInfo = pvEncryptAuxInfo;
    ContentEncryptInfo.cRecipients = 1;
    ContentEncryptInfo.rgCmsRecipients = &CmsRecipientEncodeInfo;
    ContentEncryptInfo.pfnAlloc = pfnAlloc;
    ContentEncryptInfo.pfnFree = ICM_Free;
    // ContentEncryptInfo.hContentEncryptKey =
    // ContentEncryptInfo.dwFlags =

    CmsRecipientEncodeInfo.dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
    CmsRecipientEncodeInfo.pKeyTrans = &KeyTransEncodeInfo;

    KeyTransEncodeInfo.cbSize = sizeof(KeyTransEncodeInfo);
    KeyTransEncodeInfo.KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
    // KeyTransEncodeInfo.pvKeyEncryptionAuxInfo =
    // KeyTransEncodeInfo.hCryptProv =
    KeyTransEncodeInfo.RecipientPublicKey = pPublicKeyInfo->PublicKey;
    // KeyTransEncodeInfo.RecipientId =

    // dwEncryptFlags
    if (ICM_IsSP3CompatibleEncrypt(&ContentEncryptInfo))
        rgcbEncryptParameters[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
    else
        rgcbEncryptParameters[1] = 0;

    fRet = ICM_DefaultGenContentEncryptKey(
        &ContentEncryptInfo,
        0,                      // dwFlags
        NULL                    // pvReserved
        );

    assert(0 == (ContentEncryptInfo.dwFlags &
         CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG));

    if (fRet) {
        if (ContentEncryptInfo.dwFlags & CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG) {
            *ppbEncryptParameters =
                ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.pbData;
            rgcbEncryptParameters[0] =
                ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.cbData;
        }

        *phCryptProv = ContentEncryptInfo.hCryptProv;
        *phEncryptKey = ContentEncryptInfo.hContentEncryptKey;
    } else {
        if (ContentEncryptInfo.dwFlags & CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG)
            ICM_Free(ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.pbData);
        if (ContentEncryptInfo.hContentEncryptKey) {
            DWORD dwErr = GetLastError();
            CryptDestroyKey(ContentEncryptInfo.hContentEncryptKey);
            SetLastError(dwErr);
        }
        *phEncryptKey = 0;
    }

    return fRet;
}

#else

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2_CBC parameters.
//  For all others encode as an IV octet string. The IV is initialized by
//  calling CryptGenRandom.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT PDWORD                      pcbEncryptParameters,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen,          // 0 => default length
    OUT BYTE                        rgbIV[IV_LENGTH],
    OUT PDWORD                      pcbIV
    )
{
    BOOL fRet;
    HCRYPTPROV hCryptProv;      // doesn't need to be released
    CRYPT_RC2_CBC_PARAMETERS RC2Para;
    CRYPT_DATA_BLOB IVPara;
    void *pvPara;
    LPCSTR pszStructType;

    *ppbEncryptParameters = NULL;
    *pcbEncryptParameters = 0;
    *pdwBitLen = 0;
    *pcbIV = IV_LENGTH;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    // Generate the random IV.
    hCryptProv = I_CryptGetDefaultCryptProv(0);
    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;
    if (!CryptGenRandom(hCryptProv, IV_LENGTH, rgbIV))
        goto GenRandomError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo = (PCMSG_RC2_AUX_INFO) pvEncryptAuxInfo;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            *pdwBitLen = pAuxInfo->dwBitLen & ~CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
            if (!ICM_BitLengthToRC2Version(*pdwBitLen, &RC2Para.dwVersion))
                goto BitLengthToRC2VersionError;
        } else {
            // Default to 40 bits;
            *pdwBitLen = 40;
            RC2Para.dwVersion = CRYPT_RC2_40BIT_VERSION;
        }

        // Encode as RC2_CBC parameters
        RC2Para.fIV = TRUE;
        assert(sizeof(RC2Para.rgbIV) == IV_LENGTH);
        memcpy(RC2Para.rgbIV, rgbIV, sizeof(RC2Para.rgbIV));

        pvPara = &RC2Para;
        pszStructType = PKCS_RC2_CBC_PARAMETERS;
    } else {
        IVPara.pbData = rgbIV;
        IVPara.cbData = IV_LENGTH;
        pvPara = &IVPara;
        pszStructType = X509_OCTET_STRING;
    }

    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            NULL,                   // pbEncoded
            pcbEncryptParameters
            )) goto EncodeError;
    if (NULL == (*ppbEncryptParameters = (PBYTE) pfnAlloc(
            *pcbEncryptParameters)))
        goto OutOfMemory;
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            *ppbEncryptParameters,
            pcbEncryptParameters
            )) goto EncodeError;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenRandomError)
TRACE_ERROR(EncodeError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_DefaultExportEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL        fRet;
    DWORD       dwAlgIdEncrypt;
    HCRYPTPROV  hCryptProv;
    BYTE        rgbIV[IV_LENGTH];
    DWORD       cbIV;
    DWORD       dwBitLen;
    DWORD       dwEncryptFlags;

    *phEncryptKey = 0;

    dwEncryptFlags = 0;
    rgcbEncryptParameters[1] = 0;    // dwEncryptFlags
    if (pvEncryptAuxInfo) {
        PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
            (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
        if (sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) <= pSP3AuxInfo->cbSize &&
                (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {
            dwEncryptFlags = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
            rgcbEncryptParameters[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
        }
    }

    if (dwEncryptFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG) {
        cbIV = 0;
        dwBitLen = 0;

        if (!ICM_GetCAPI(
                CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
                paiEncrypt,
                &dwAlgIdEncrypt))
            goto GetCAPIError;

    } else if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultEncryptParameters(
                paiEncrypt,
                pvEncryptAuxInfo,
                pfnAlloc,
                ppbEncryptParameters,
                rgcbEncryptParameters,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto CreateDefaultEncryptParametersError;
    } else {
        if (!ICM_GetEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto GetEncryptParametersError;
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        DWORD dwAlgIdPubKey = 0;
        ICM_GetCAPI(
            CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &pPublicKeyInfo->Algorithm,
            &dwAlgIdPubKey);

        hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
            dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        else
            *phCryptProv = hCryptProv;
    }

    fRet = CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            (dwEncryptFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG) ?
                CRYPT_EXPORTABLE :
                CRYPT_EXPORTABLE | CRYPT_NO_SALT,       // dwFlags
            phEncryptKey);
    if (!fRet) {
        if (NTE_BAD_FLAGS == GetLastError())
            // Previous versions didn't support CRYPT_NO_SALT flag
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    CRYPT_EXPORTABLE,       // dwFlags
                    phEncryptKey);
        if (!fRet) {
            *phEncryptKey = 0;    
            goto GenKeyError;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            *phEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (!CryptSetKeyParam(
                *phEncryptKey,
                KP_IV,
                rgbIV,
                0))                 // dwFlags
            goto SetKeyParamError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    if (*phEncryptKey) {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(*phEncryptKey);
        *phEncryptKey = 0;
        SetLastError(dwErr);
    }
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateDefaultEncryptParametersError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(SetKeyParamError)
}

//+-------------------------------------------------------------------------
//  Get an hkey for content encryption for a particular algorithm
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_ExportEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hGenEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            paiEncrypt->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_GEN_ENCRYPT_KEY) pvFuncAddr)(
            phCryptProv,
            paiEncrypt,
            pvEncryptAuxInfo,
            pPublicKeyInfo,
            pfnAlloc,
            phEncryptKey,
            ppbEncryptParameters,
            rgcbEncryptParameters);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultGenEncryptKey(
            phCryptProv,
            paiEncrypt,
            pvEncryptAuxInfo,
            pPublicKeyInfo,
            pfnAlloc,
            phEncryptKey,
            ppbEncryptParameters,
            rgcbEncryptParameters);
    return fResult;
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Advance the phase of a message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_AdvanceMsgPhase(
    IN OUT PDWORD   pdwPhase,
    IN BOOL         fFinal)
{
    BOOL    fRet;
    DWORD   dwPhase = *pdwPhase;

    switch (dwPhase) {
    case PHASE_FIRST_ONGOING:
        dwPhase = fFinal ? PHASE_FIRST_FINAL : PHASE_FIRST_ONGOING;
        break;
    case PHASE_FIRST_FINAL:
        dwPhase = fFinal ? PHASE_SECOND_FINAL : PHASE_SECOND_ONGOING;
        break;
    case PHASE_SECOND_ONGOING:
        dwPhase = fFinal ? PHASE_SECOND_FINAL : PHASE_SECOND_ONGOING;
        break;
    case PHASE_SECOND_FINAL:
        goto TransitionFromSecondFinalError;
    default:
        goto InvalidPhaseError;
    }
    *pdwPhase = dwPhase;
    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(TransitionFromSecondFinalError,CRYPT_E_MSG_ERROR)
SET_ERROR(InvalidPhaseError,CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Return the (cached) value of the hash
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetListHashValue(
    IN CHashNode    *pnHash,
    OUT DWORD       *pcbHash,
    OUT PBYTE       *ppbHash)
{
    BOOL            fRet;
    PICM_HASH_INFO  pHashInfo;

    pHashInfo = pnHash->Data();

    if (0 == pHashInfo->HashBlob.cbData) {
        pHashInfo->HashBlob.pbData = NULL;
        if (!CryptGetHashParam(
                pHashInfo->hHash,
                HP_HASHVAL,
                NULL,                   // pbHash
                &pHashInfo->HashBlob.cbData,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        pHashInfo->HashBlob.pbData = (PBYTE)ICM_Alloc(
                    pHashInfo->HashBlob.cbData);
        if (NULL == pHashInfo->HashBlob.pbData)
            goto HashAllocError;
        if (!CryptGetHashParam(
                pHashInfo->hHash,
                HP_HASHVAL,
                pHashInfo->HashBlob.pbData,
                &pHashInfo->HashBlob.cbData,
                0))                     // dwFlags
            goto GetHashParamError;
    }
    *pcbHash = pHashInfo->HashBlob.cbData;
    *ppbHash = pHashInfo->HashBlob.pbData;
    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    if(pHashInfo->HashBlob.pbData != NULL) {
        ICM_Free(pHashInfo->HashBlob.pbData);
        pHashInfo->HashBlob.pbData = NULL;
    }
    *pcbHash = 0;
#if DBG
    *ppbHash = NULL;
#endif
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetHashParamSizeError)  // error already set
TRACE_ERROR(HashAllocError)         // error already set
TRACE_ERROR(GetHashParamError)      // error already set
}


//+-------------------------------------------------------------------------
//  Return a new hash handle equivalent to the original
//
//  Returns FALSE iff creation failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DupListHash(
    IN CHashNode    *pnHash,
    IN HCRYPTPROV   hCryptProv,
    OUT HCRYPTHASH  *phHash)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();
    HCRYPTHASH      hHash = NULL;
    DWORD           cbHash;
    PBYTE           pbHash;

    if (!ICM_GetListHashValue(
            pnHash,
            &cbHash,
            &pbHash))
        goto GetListHashValueError;
    if (!CryptCreateHash(
            hCryptProv,
            pHashInfo->dwAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!CryptSetHashParam(
            hHash,
            HP_HASHVAL,
            pbHash,
            0))                     // dwFlags
        goto SetHashParamError;

    fRet = TRUE;
CommonReturn:
    *phHash = hHash;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (hHash)
        CryptDestroyHash( hHash);
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetListHashValueError)  // error already set
TRACE_ERROR(CreateHashError)        // error already set
TRACE_ERROR(SetHashParamError)      // error already set
}

#ifndef CMS_PKCS7
//+-------------------------------------------------------------------------
//  Set a DigestAlgorithmIdentifiers
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnDigestAlgorithmIdentifiers(
    OUT DigestAlgorithmIdentifiers  *podais,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN DWORD                        cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO     rgSigners,
    OUT HCRYPTPROV                  *phCryptProv,
    OUT DWORD                       *pdwKeySpec)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    DWORD                       i;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DigestAlgorithmIdentifier   *podai;

    *phCryptProv = NULL;


    // This code does not remove duplicates from the list of
    // algorithms. It is not wrong, but the output message is
    // unnecessarily bulky.
    if (cSigners) {
        podai = (DigestAlgorithmIdentifier *)ICM_AllocZero(
                        cSigners * sizeof( DigestAlgorithmIdentifier));
        if (NULL == podai)
            goto DigestAlgorithmIdentifierAllocError;
    } else {
        podai = NULL;
    }
    podais->count = cSigners;
    podais->value = podai;
    for (i=cSigners, psei=rgSigners; i>0; i--, psei++, podai++) {
        assert( psei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO,
            rgUnauthAttr));
        assert( psei->pvHashAuxInfo == NULL);
        if (psei->cbSize <
                    STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) ||
                psei->pvHashAuxInfo != NULL)
            goto InvalidArg;
        *phCryptProv = psei->hCryptProv; // s/b array, one for each algo
        *pdwKeySpec = psei->dwKeySpec; // s/b array, one for each algo
        *pai = psei->HashAlgorithm;    // s/b array, one for each algo
        if (!ICM_Asn1ToAlgorithmIdentifier( &psei->HashAlgorithm, podai))
            goto Asn1ToAlgorithmIdentifierError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( podai);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestAlgorithmIdentifierAllocError)    // error already set
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)      // error already set
SET_ERROR(InvalidArg,E_INVALIDARG)
}
#endif  // not defined CMS_PKCS7


//+-------------------------------------------------------------------------
//  Fill digestEncryptionAlgorithm
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_FillAsnDigestEncryptionAlgorithm(
    IN PCRYPT_MSG_INFO pcmi,
    IN PCRYPT_ALGORITHM_IDENTIFIER pDigestEncryptAlg,
    IN OUT DigestEncryptionAlgId *pdea
    )
{
    BOOL fRet;
    CRYPT_ALGORITHM_IDENTIFIER DigestEncryptAlg;
    DWORD dwFlags;
    PCCRYPT_OID_INFO pOIDInfo;

    dwFlags = 0;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pDigestEncryptAlg->pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwFlags = pdwExtra[0];
        }

        // Check if more than just the NULL parameters
        if (2 < pDigestEncryptAlg->Parameters.cbData) {
            // Check if we should use the public key parameters
            if (0 == (dwFlags & CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG)) {
                memset(&DigestEncryptAlg, 0, sizeof(DigestEncryptAlg));
                DigestEncryptAlg.pszObjId = pDigestEncryptAlg->pszObjId;
                pDigestEncryptAlg = &DigestEncryptAlg;
            }
        }
    } else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pDigestEncryptAlg->pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID)) {
        if (2 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwFlags = pdwExtra[1];
        }
    }

    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            pDigestEncryptAlg,
            pdea))
        goto DigestEncryptionAsn1ToAlgorithmIdentifierError;

    if (0 == pDigestEncryptAlg->Parameters.cbData &&
            0 != (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG)) {
        // NO NULL parameters
        pdea->bit_mask &= ~parameters_present;
        pdea->parameters.length = 0;
        pdea->parameters.value = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestEncryptionAsn1ToAlgorithmIdentifierError)  // error already set
}

void
WINAPI
ICM_GetCertIdFromCertInfo(
    IN PCERT_INFO               pCertInfo,
    OUT PCERT_ID                pCertId)
{
    if (Asn1UtilExtractKeyIdFromCertInfo(pCertInfo, &pCertId->KeyId)) {
        pCertId->dwIdChoice = CERT_ID_KEY_IDENTIFIER;
    } else {
        pCertId->dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
        pCertId->IssuerSerialNumber.Issuer = pCertInfo->Issuer;
        pCertId->IssuerSerialNumber.SerialNumber = pCertInfo->SerialNumber;
    }
}

BOOL
WINAPI
ICM_GetSignerIdFromSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    OUT PCERT_ID                pSignerId)
{
    BOOL fRet;
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, SignerId) <= psei->cbSize &&
            psei->SignerId.dwIdChoice) {
        *pSignerId = psei->SignerId;
        if (!(CERT_ID_ISSUER_SERIAL_NUMBER == pSignerId->dwIdChoice ||
                CERT_ID_KEY_IDENTIFIER == pSignerId->dwIdChoice))
            goto InvalidSignerIdChoice;
    } else
        ICM_GetCertIdFromCertInfo(psei->pCertInfo, pSignerId);

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidSignerIdChoice, E_INVALIDARG)
}

BOOL
WINAPI
ICM_SetOssCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT CertIdentifier *pOssCertId
    );

void
WINAPI
ICM_FreeOssCertIdentifier(
    IN OUT CertIdentifier *pOssCertId
    );

//+-------------------------------------------------------------------------
//  Fill a single SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillAsnSignerInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    IN PCRYPT_MSG_INFO          pcmi,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN OUT SignerInfo           *psi,
    IN OUT Attribute            **ppAuthAttr,
    IN OUT Attribute            **ppUnauthAttr)
{
    BOOL                fRet;
    Attribute           *pAuthAttr;
    Attribute           *pUnauthAttr;
    int                 i;
    PCRYPT_ATTRIBUTE    patr;
    PCRYPT_ALGORITHM_IDENTIFIER pDigestEncryptAlg;
    CERT_ID             SignerId;

    // psi->bit_mask = 0;

    if (!ICM_GetSignerIdFromSignerEncodeInfo(psei, &SignerId))
        goto GetSignerIdError;

    // version
    if (CERT_ID_ISSUER_SERIAL_NUMBER == SignerId.dwIdChoice)
        psi->version = CMSG_SIGNER_INFO_PKCS_1_5_VERSION;
    else
        psi->version = CMSG_SIGNER_INFO_CMS_VERSION;

    // sid
    if (!ICM_SetOssCertIdentifier(
            &SignerId,
            &psi->sid
            ))
        goto SetOssCertIdentifierError;

    // digestAlgorithm
    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &psei->HashAlgorithm,
            &psi->digestAlgorithm))
        goto DigestAsn1ToAlgorithmIdentifierError;

    // authenticatedAttributes
    if (!ICM_IsData( pszInnerContentObjID) ||
            psei->cAuthAttr ||
            (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG)) {
        psi->bit_mask |= authenticatedAttributes_present;
        // NB - The actual number of authenticated attributes will be
        //      2 larger than requested, because of the 2 required
        //      attributes (if authenticated attributes are present).
        //      Leave room at the beginning of the attribute array.
        pAuthAttr = *ppAuthAttr;
        psi->authenticatedAttributes.count = psei->cAuthAttr + 2;
        psi->authenticatedAttributes.value = pAuthAttr;
        for (i=psei->cAuthAttr, patr=psei->rgAuthAttr, pAuthAttr+=2;
                i>0;
                i--, patr++, pAuthAttr++) {
            if (!ICM_Asn1ToAttribute( patr, pAuthAttr))
                goto Asn1AuthenticatedAttributeError;
        }
        *ppAuthAttr = pAuthAttr;
    }

    // digestEncryptionAlgorithm
#ifdef CMS_PKCS7
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, HashEncryptionAlgorithm) <=
            psei->cbSize && psei->HashEncryptionAlgorithm.pszObjId)
        pDigestEncryptAlg = &psei->HashEncryptionAlgorithm;
    else
#endif  // CMS_PKCS7
        pDigestEncryptAlg = &psei->pCertInfo->SubjectPublicKeyInfo.Algorithm;
    if (!ICM_FillAsnDigestEncryptionAlgorithm(
            pcmi, pDigestEncryptAlg, &psi->digestEncryptionAlgorithm))
        goto FillAsnDigestEncryptionAlgorithmError;

    // encryptedDigest is filled in later, when we see the content

    // unauthenticatedAttributes
    if (0 != psei->cUnauthAttr) {
        psi->bit_mask |= unauthAttributes_present;
        pUnauthAttr = *ppUnauthAttr;
        psi->unauthAttributes.count = psei->cUnauthAttr;
        psi->unauthAttributes.value = pUnauthAttr;
        for (i=psei->cUnauthAttr, patr=psei->rgUnauthAttr;
                i>0;
                i--, patr++, pUnauthAttr++) {
            if (!ICM_Asn1ToAttribute( patr, pUnauthAttr))
                goto Asn1UnauthenticatedAttributeError;
        }
        *ppUnauthAttr = pUnauthAttr;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetSignerIdError)
TRACE_ERROR(SetOssCertIdentifierError)
TRACE_ERROR(DigestAsn1ToAlgorithmIdentifierError)
TRACE_ERROR(Asn1AuthenticatedAttributeError)
TRACE_ERROR(FillAsnDigestEncryptionAlgorithmError)
TRACE_ERROR(Asn1UnauthenticatedAttributeError)
}

//+-------------------------------------------------------------------------
//  Free SignerInfo allocated memory
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeAsnSignerInfo(
    IN OUT SignerInfo           *psi)
{
    Attribute   *poatr;
    DWORD       i;

    ICM_Free(psi->encryptedDigest.value);
    ICM_FreeOssCertIdentifier(&psi->sid);

    for (i=psi->authenticatedAttributes.count,
            poatr = psi->authenticatedAttributes.value;
            i>0;
            i--, poatr++)
        ICM_Free(poatr->attributeValue.value);
    for (i=psi->unauthAttributes.count,
            poatr=psi->unauthAttributes.value;
            i>0;
            i--, poatr++)
        ICM_Free( poatr->attributeValue.value);
}


//+-------------------------------------------------------------------------
//  Set a SignerInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnSignerInfos(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN PCRYPT_MSG_INFO          pcmi,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    OUT SignerInfos             *psis,
    OUT BOOL                    *pfHasCmsSignerId)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    DWORD               i;
    DWORD               cAuthAttr;
    DWORD               cUnauthAttr;
    PCMSG_SIGNER_ENCODE_INFO psei;
    SignerInfo          *psi = NULL;
    Attribute           *pAuthAttr;
    Attribute           *pUnauthAttr;
    DWORD               cSigners  = psmei->cSigners;
    PCMSG_SIGNER_ENCODE_INFO rgSigners = psmei->rgSigners;

    *pfHasCmsSignerId = FALSE;
    psis->value = NULL;
    psis->count = 0;
    if (0 == cSigners)
        goto SuccessReturn;
    // NB - Each SignerInfo gets a non-empty authenticatedAttributes
    //      if the inner contentType is not data (passed in) or if
    //      there are authenticated attributes passed in. In this case,
    //      we reserve two Attribute slots at the beginning of the array
    //      for the content-type and message-digest Attribute values.
    for (i=cSigners, psei=rgSigners, cAuthAttr=0, cUnauthAttr=0;
            i>0;
            i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
#else
            psei++) {
#endif  // CMS_PKCS7
        if (!ICM_IsData( pszInnerContentObjID) ||
                psei->cAuthAttr ||
                (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG))
            cAuthAttr += psei->cAuthAttr + 2;    // reserve 2
        cUnauthAttr += psei->cUnauthAttr;
    }
    psi = (SignerInfo *)ICM_AllocZero(  cSigners    * sizeof( SignerInfo) +
                                        cAuthAttr   * sizeof( Attribute) +
                                        cUnauthAttr * sizeof( Attribute)
                                     );
    if (NULL == psi)
        goto SignerInfoAllocError;
    psis->count = cSigners;
    psis->value = psi;
    pAuthAttr = (Attribute *)(psis->value + cSigners);
    pUnauthAttr = pAuthAttr + cAuthAttr;

    for (i=cSigners, psei=rgSigners, psi=psis->value; i>0; i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize),
#else
            psei++,
#endif  // CMS_PKCS7
            psi++) {
        if (!ICM_FillAsnSignerInfo(
                psei,
                pcmi,
                dwFlags,
                pszInnerContentObjID,
                psi,
                &pAuthAttr,
                &pUnauthAttr))
            goto FillAsnSignerInfoError;

        if (CMSG_SIGNER_INFO_CMS_VERSION <= psi->version)
            *pfHasCmsSignerId = TRUE;
    }
SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SignerInfoAllocError)       // error already set
TRACE_ERROR(FillAsnSignerInfoError)     // error already set
}

#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_IsDuplicateSignerEncodeHashAlgorithm(
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN PCMSG_SIGNER_ENCODE_INFO pNewSigner,
    OUT OPTIONAL DWORD *pdwPrevIndex
    )
{
    PCRYPT_ALGORITHM_IDENTIFIER pNewHashAlg = &pNewSigner->HashAlgorithm;
    PCMSG_SIGNER_ENCODE_INFO pPrevSigner;
    DWORD dwPrevIndex;

    pPrevSigner = rgSigners;
    dwPrevIndex = 0;
    while (pPrevSigner < pNewSigner) {
        PCRYPT_ALGORITHM_IDENTIFIER pPrevHashAlg = &pPrevSigner->HashAlgorithm;
        if (0 == strcmp(pNewHashAlg->pszObjId, pPrevHashAlg->pszObjId)
                        &&
                pNewHashAlg->Parameters.cbData ==
                    pPrevHashAlg->Parameters.cbData
                        &&
                (0 == pNewHashAlg->Parameters.cbData ||
                    0 == memcmp(pNewHashAlg->Parameters.pbData,
                            pPrevHashAlg->Parameters.pbData,
                            pNewHashAlg->Parameters.cbData))) {
            break;
        }

        assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
            pPrevSigner->cbSize);
        assert(pPrevSigner->cbSize == pNewSigner->cbSize);
        pPrevSigner = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) pPrevSigner +
            pPrevSigner->cbSize);
        dwPrevIndex++;
    }

    if (pdwPrevIndex)
        *pdwPrevIndex = dwPrevIndex;
    return pPrevSigner < pNewSigner;
}

//+-------------------------------------------------------------------------
//  Set Signer DigestAlgorithmIdentifiers and create the SignerEncode and
//  Hash lists
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnSignerDigestInfo(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN OUT DigestAlgorithmIdentifiers *podais
    )
{
    BOOL fRet;
    DigestAlgorithmIdentifier *podai = NULL;
    DWORD cDigests = 0;
    DWORD cSigners = psmei->cSigners;

    if (cSigners) {
        DWORD i;
        PCMSG_SIGNER_ENCODE_INFO psei;
        PSIGNER_ENCODE_DATA_INFO rgSignerEncodeDataInfo;

        podai = (DigestAlgorithmIdentifier *) ICM_AllocZero(
            cSigners * sizeof(DigestAlgorithmIdentifier));
        if (NULL == podai)
            goto OutOfMemory;

        rgSignerEncodeDataInfo = (PSIGNER_ENCODE_DATA_INFO) ICM_AllocZero(
            cSigners * sizeof(SIGNER_ENCODE_DATA_INFO));
        if (NULL == rgSignerEncodeDataInfo)
            goto OutOfMemory;
        pcmi->cSignerEncodeDataInfo = cSigners;
        pcmi->rgSignerEncodeDataInfo = rgSignerEncodeDataInfo;

        if (NULL == (pcmi->pHashList = new CHashList))
            goto OutOfMemory;

        for (i = 0, psei = psmei->rgSigners; i < cSigners; i++,
                psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
            DWORD dwPrevIndex;
            ICM_HASH_INFO HashInfo;     ZEROSTRUCT(HashInfo);
            CHashNode *pHashNode;

            assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
                psei->cbSize);
            assert(psei->hCryptProv);
            if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) >
                    psei->cbSize || 0 == psei->hCryptProv)
                goto InvalidArg;

            if (ICM_IsDuplicateSignerEncodeHashAlgorithm(
                    psmei->rgSigners,
                    psei,
                    &dwPrevIndex
                    )) {
                assert(dwPrevIndex < i);
                pHashNode = rgSignerEncodeDataInfo[dwPrevIndex].pHashNode;
            } else {
                if (!ICM_MsgAsn1ToAlgorithmIdentifier(
                        pcmi,
                        &psei->HashAlgorithm,
                        &podai[cDigests]))
                    goto MsgAsn1ToAlgorithmIdentifierError;
                cDigests++;

                if (!(ICM_GetCAPI(
                        CRYPT_HASH_ALG_OID_GROUP_ID,
                        &psei->HashAlgorithm,
                        &HashInfo.dwAlgoCAPI) ||
                      ICM_GetCAPI(
                        CRYPT_SIGN_ALG_OID_GROUP_ID,
                        &psei->HashAlgorithm,
                        &HashInfo.dwAlgoCAPI)))
                    goto GetCAPIError;
                if (!CryptCreateHash(
                                psei->hCryptProv,
                                HashInfo.dwAlgoCAPI,
                                NULL,               // hKey - optional for MAC
                                0,                  // dwFlags
                                &HashInfo.hHash))
                    goto CreateHashError;
                if (NULL == (pHashNode = new CHashNode)) {
                    DWORD dwErr = GetLastError();
                    CryptDestroyHash(HashInfo.hHash);
                    SetLastError(dwErr);
                    goto OutOfMemory;
                }
                pHashNode->SetData(&HashInfo);
                pcmi->pHashList->InsertTail(pHashNode);
            }

            rgSignerEncodeDataInfo[i].hCryptProv = psei->hCryptProv;
            rgSignerEncodeDataInfo[i].dwKeySpec = psei->dwKeySpec;
            rgSignerEncodeDataInfo[i].pHashNode = pHashNode;
        }
        assert(cDigests);
    }

    podais->count = cDigests;
    podais->value = podai;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_Free(podai);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateHashError)
}

//+-------------------------------------------------------------------------
//  Open a signed message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_ENCODE_INFO    psmei;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    SignedData                  *psd = NULL;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       i;
    DWORD                       cbCert;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    DWORD                       cAttrCertEncoded;
    BOOL                        fHasCmsSignerId;

    psmei = (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
        rgCrlEncoded));
    if (psmei->cbSize < STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO, rgCrlEncoded))
        goto InvalidArg;

    for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded, cbCert=0;
            i>0;
            i--, pcert++)
        cbCert += pcert->cbData;

    for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, cbCrl=0;
            i>0;
            i--, pcrl++)
        cbCrl += pcrl->cbData;

    if (psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
            rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;
    } else
        cAttrCertEncoded = 0;

    psd = (SignedData *)ICM_AllocZero(
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert +
                cbCrl);
    if (NULL == psd)
        goto SignedDataAllocError;

    // digest algorithms filled in as part of ICM_SetAsnSignerDigestInfo

    // contentInfo filled in later, when we see the content

    // certificates
    if (0 != psmei->cCertEncoded || 0 != cAttrCertEncoded) {
        psd->bit_mask |= certificates_present;
        psd->certificates.count = psmei->cCertEncoded;
        psd->certificates.count += cAttrCertEncoded;
#ifdef OSS_CRYPT_ASN1
        psd->certificates.certificates = (Certificate *)(psd + 1);
#else
        psd->certificates.value = (Certificate *)(psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCert = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList);
        for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                    pOssCert=psd->certificates.certificates;
#else
                    pOssCert=psd->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            if (pcert->cbData)
                // Change tag from SEQUENCE to [1] IMPLICIT
                *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }
    }

    // crls
    if (0 != psmei->cCrlEncoded) {
        psd->bit_mask |= crls_present;
        psd->crls.count = psmei->cCrlEncoded;
        if (0 != psmei->cCertEncoded || 0 != cAttrCertEncoded)
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *)
                                (psd->certificates.certificates +
#else
            psd->crls.value  = (CertificateRevocationList *)
                                (psd->certificates.value +
#endif  // OSS_CRYPT_ASN1
                                    (psmei->cCertEncoded + cAttrCertEncoded));
        else
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *) (psd + 1);
#else
            psd->crls.value  = (CertificateRevocationList *) (psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCrl = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert;
#ifdef OSS_CRYPT_ASN1
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.crls;
#else
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcrl++, pOssCrl++) {
            pOssCrl->length = pcrl->cbData;
            memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
            pOssCrl->value = pbCrl;
            pbCrl += pcrl->cbData;
        }
    }


    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero(
            sizeof( CRYPT_MSG_INFO))))
        goto OutOfMemory;

    // signerInfos
    if (!ICM_SetAsnSignerInfos(psmei, pcmi, dwFlags, pszInnerContentObjID,
            &psd->signerInfos, &fHasCmsSignerId))
        goto SetAsnSignerInfosError;

    // version
    if (0 < cAttrCertEncoded || fHasCmsSignerId) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data or has attribute certs or has
    // CMS signers, then, CMS version
    if ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) ||
            0 < cAttrCertEncoded || fHasCmsSignerId)
        psd->version = CMSG_SIGNED_DATA_CMS_VERSION;
    else
        psd->version = CMSG_SIGNED_DATA_PKCS_1_5_VERSION;

    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psd;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (!ICM_SetAsnSignerDigestInfo(
            psmei,
            pcmi,
            &psd->digestAlgorithms
            ))
        goto SetAsnSignerDigestInfoError;

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeSignedData( pcmi, psmei))
        goto StreamOpenToEncodeSignedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (psd) {
        if (psd->signerInfos.value) {
            SignerInfo  *psi;

            for (i=psd->signerInfos.count, psi=psd->signerInfos.value;
                    i>0;
                    i--, psi++)
                ICM_FreeAsnSignerInfo(psi);
            ICM_Free(psd->signerInfos.value);
        }
        ICM_Free(psd);
    }
    if (pcmi) {
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        ICM_Free(pcmi->rgSignerEncodeDataInfo);
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free(pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(SetAsnSignerInfosError)                 // error already set
TRACE_ERROR(SetAsnSignerDigestInfoError)            // error already set
TRACE_ERROR(SignedDataAllocError)                   // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
TRACE_ERROR(StreamOpenToEncodeSignedDataError)      // error already set
}

#else

//+-------------------------------------------------------------------------
//  Open a signed message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_ENCODE_INFO    psmei;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    SignedData                  *psd = NULL;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       i;
    DWORD                       cDigestAlgorithms;
    HCRYPTPROV                  hCryptProv;
    DWORD                       dwKeySpec;
    CRYPT_ALGORITHM_IDENTIFIER  aiDigest;
    ICM_HASH_INFO               HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode                   *pHashNode;
    DWORD                       cbCert;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    BOOL                        fHasCmsSignerId;

#ifdef CMS_PKCS7
    DWORD                       cAttrCertEncoded;
#endif  // CMS_PKCS7

    psmei = (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( 2 > psmei->cSigners);
    if (!( 2 > psmei->cSigners))
        goto TooManySignersError;
#ifdef CMS_PKCS7
    assert( psmei->cbSize >= offsetof(CMSG_SIGNED_ENCODE_INFO,
        cAttrCertEncoded));
    if (psmei->cbSize < offsetof(CMSG_SIGNED_ENCODE_INFO, cAttrCertEncoded))
#else
    assert( psmei->cbSize >= sizeof(CMSG_SIGNED_ENCODE_INFO));
    if (psmei->cbSize < sizeof(CMSG_SIGNED_ENCODE_INFO))
#endif
        goto InvalidArg;

    for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded, cbCert=0;
            i>0;
            i--, pcert++)
        cbCert += pcert->cbData;

    for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, cbCrl=0;
            i>0;
            i--, pcrl++)
        cbCrl += pcrl->cbData;

#ifdef CMS_PKCS7
    if (psmei->cbSize > offsetof(CMSG_SIGNED_ENCODE_INFO, rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;
    } else
        cAttrCertEncoded = 0;
#endif  // CMS_PKCS7

    psd = (SignedData *)ICM_AllocZero(
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert +
                cbCrl);
    if (NULL == psd)
        goto SignedDataAllocError;
    psd->bit_mask = 0;
    psd->signerInfos.value = NULL;
    psd->contentInfo.content.value = NULL;

    // version
#ifdef CMS_PKCS7
    if (0 < cAttrCertEncoded) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data or has attribute certs, then,
    // version = 3
    if ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) ||
            0 < cAttrCertEncoded)
        psd->version = CMSG_SIGNED_DATA_CMS_VERSION;
    else
        psd->version = CMSG_SIGNED_DATA_PKCS_1_5_VERSION;
#else
    psd->version = 1;
#endif  // CMS_PKCS7

    // digest algorithms
    if (!ICM_SetAsnDigestAlgorithmIdentifiers(
                &psd->digestAlgorithms,
                &aiDigest,
                psmei->cSigners,
                psmei->rgSigners,
                &hCryptProv,
                &dwKeySpec))
        goto SetAsnDigestAlgorithmIdentifiersError;

    // contentInfo filled in later, when we see the content

    // certificates
    if (0 != psmei->cCertEncoded
#ifdef CMS_PKCS7
            || 0 != cAttrCertEncoded
#endif  // CMS_PKCS7
            ) {
        psd->bit_mask |= certificates_present;
        psd->certificates.count = psmei->cCertEncoded;
#ifdef CMS_PKCS7
        psd->certificates.count += cAttrCertEncoded;
#endif  // CMS_PKCS7
#ifdef OSS_CRYPT_ASN1
        psd->certificates.certificates = (Certificate *)(psd + 1);
#else
        psd->certificates.value = (Certificate *)(psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCert = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList);
        for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                    pOssCert=psd->certificates.certificates;
#else
                    pOssCert=psd->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }

#ifdef CMS_PKCS7
        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            if (pcert->cbData)
                // Change tag from SEQUENCE to [1] IMPLICIT
                *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }
#endif  // CMS_PKCS7
    }

    // crls
    if (0 != psmei->cCrlEncoded) {
        psd->bit_mask |= crls_present;
        psd->crls.count = psmei->cCrlEncoded;
        if (0 != psmei->cCertEncoded
#ifdef CMS_PKCS7
                || 0 != cAttrCertEncoded
#endif  // CMS_PKCS7
                )
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *)
                                (psd->certificates.certificates +
#else
            psd->crls.value  = (CertificateRevocationList *)
                                (psd->certificates.value +
#endif  // OSS_CRYPT_ASN1
                                    (psmei->cCertEncoded
#ifdef CMS_PKCS7
                                        + cAttrCertEncoded
#endif  // CMS_PKCS7
                                    ));
        else
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *) (psd + 1);
#else
            psd->crls.value  = (CertificateRevocationList *) (psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCrl = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert;
#ifdef OSS_CRYPT_ASN1
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.crls;
#else
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcrl++, pOssCrl++) {
            pOssCrl->length = pcrl->cbData;
            memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
            pOssCrl->value = pbCrl;
            pbCrl += pcrl->cbData;
        }
    }

    // signerInfos
    // psd->signerInfos.count = psmei->cSigners;
    // psd->signerInfos.value = (SignerInfo *)
    //                         (psd->crls.crls + psmei->cCrlEncoded);
    if (!ICM_SetAsnSignerInfos( psmei, pcmi, dwFlags, pszInnerContentObjID,
            &psd->signerInfos, &fHasCmsSignerId))
        goto SetAsnSignerInfosError;

    cDigestAlgorithms = psmei->cSigners;
    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto OutOfMemory;

    pcmi->hCryptProv = hCryptProv;
    if (0 == hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwKeySpec = dwKeySpec;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psd;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (psmei->cSigners) {
        if (!(ICM_GetCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                &aiDigest,
                &HashInfo.dwAlgoCAPI) ||
              ICM_GetCAPI(
                CRYPT_SIGN_ALG_OID_GROUP_ID,
                &aiDigest,
                &HashInfo.dwAlgoCAPI)))
            goto GetCAPIError;
        HashInfo.hCryptProv = hCryptProv;
        if (!CryptCreateHash(
                        HashInfo.hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (NULL == (pcmi->pHashList = new CHashList))
            goto NewHashListError;
        if (NULL == (pHashNode = new CHashNode))
            goto NewHashNodeError;
        pHashNode->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pHashNode);
    }

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeSignedData( pcmi, psmei))
        goto StreamOpenToEncodeSignedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( psd);
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(TooManySignersError,E_INVALIDARG)
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(SetAsnSignerInfosError)                 // error already set
TRACE_ERROR(SetAsnDigestAlgorithmIdentifiersError)  // error already set
TRACE_ERROR(SignedDataAllocError)                   // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
TRACE_ERROR(CreateHashError)                        // error already set
TRACE_ERROR(StreamOpenToEncodeSignedDataError)      // error already set
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Open a data message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    OctetStringType             *poos = NULL;

    if (pvMsgEncodeInfo)
        goto EncodeInfoPresentError;

    if (NULL == (poos = (OctetStringType *)ICM_AllocZero( sizeof( OctetStringType))))
        goto AllocOctetStringTypeError;

    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto AllocMsgInfoError;

    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = CMSG_DATA;
//  pcmi->hCryptProv        = 0;
    pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwFlags           = dwFlags;
    pcmi->pvMsg             = poos;
    pcmi->fEncoding         = TRUE;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    pcmi->pStreamInfo       = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo));

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeData( pcmi))
        goto StreamOpenToEncodeDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( poos);
    if (pcmi) {
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free( pcmi);
    }
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(EncodeInfoPresentError,E_INVALIDARG)
TRACE_ERROR(AllocMsgInfoError)                  // error already set
TRACE_ERROR(AllocOctetStringTypeError)          // error already set
TRACE_ERROR(StreamOpenToEncodeDataError)        // error already set
}


//+-------------------------------------------------------------------------
//  Open a digested message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeDigestedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_HASHED_ENCODE_INFO     pdmei;
    DigestedData                *pdd = NULL;
    ICM_HASH_INFO               HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode                   *pHashNode;

    pdmei = (PCMSG_HASHED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( pdmei->cbSize >= sizeof(CMSG_HASHED_ENCODE_INFO));
    assert( pdmei->pvHashAuxInfo == NULL);
    if (pdmei->cbSize < sizeof(CMSG_HASHED_ENCODE_INFO) ||
            pdmei->pvHashAuxInfo != NULL)
        goto InvalidArg;

    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto OutOfMemory;

    pdd = (DigestedData *)ICM_AllocZero( sizeof( DigestedData));
    if (NULL == pdd)
        goto DigestedDataAllocError;

    // version
#ifdef CMS_PKCS7
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data, then, version = 2
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
        pdd->version = CMSG_HASHED_DATA_V2;
    else
        pdd->version = CMSG_HASHED_DATA_V0;
#else
    pdd->version = 0;
#endif  // CMS_PKCS7

    // digest algorithm
    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &pdmei->HashAlgorithm,
            &pdd->digestAlgorithm))
        goto MsgAsn1ToAlgorithmIdentifierError;


    // contentInfo filled in later, when we see the content

    if (pdmei->hCryptProv)
        pcmi->hCryptProv        = pdmei->hCryptProv;
    else {
        pcmi->fDefaultCryptProv = TRUE;
        pcmi->hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == pcmi->hCryptProv)
            goto GetDefaultCryptProvError;
    }
    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = CMSG_HASHED;
    pcmi->dwFlags           = dwFlags;
    pcmi->pvMsg             = pdd;
    pcmi->fEncoding         = TRUE;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1);
    pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo));

    if (!ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &pdmei->HashAlgorithm,
            &HashInfo.dwAlgoCAPI))
        goto GetCAPIError;
#ifndef CMS_PKCS7
    HashInfo.hCryptProv = pcmi->hCryptProv;
#endif  // CMS_PKCS7
    if (!CryptCreateHash(
                    pcmi->hCryptProv,
                    HashInfo.dwAlgoCAPI,
                    NULL,               // hKey - optional for MAC
                    0,                  // dwFlags
                    &HashInfo.hHash))
        goto CreateHashError;

    if (NULL == (pcmi->pHashList = new CHashList) ||
            NULL == (pHashNode = new CHashNode)) {
        DWORD dwErr = GetLastError();
        CryptDestroyHash(HashInfo.hHash);
        SetLastError(dwErr);
        goto NewHashListOrNodeError;
    }
    pHashNode->SetData( &HashInfo);
    pcmi->pHashList->InsertTail( pHashNode);

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pdd);
    if (pcmi) {
#ifdef CMS_PKCS7
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
#endif  // CMS_PKCS7
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free( pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashListOrNodeError,E_OUTOFMEMORY)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)       // error already set
TRACE_ERROR(DigestedDataAllocError)                     // error already set
TRACE_ERROR(CreateHashError)                            // error already set
TRACE_ERROR(OutOfMemory)                                // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Export the hContentEncryptKey from the ContentEncrypt
//  provider and import into the specified provider
//--------------------------------------------------------------------------
HCRYPTKEY
WINAPI
ICM_ExportContentEncryptKeyAndImport(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN HCRYPTPROV hImportProv
    )
{
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hExportProv = pContentEncryptInfo->hCryptProv;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    HCRYPTKEY hImportContentEncryptKey = 0;
#define BASE_DATA_LENGTH    8
    BYTE rgbBaseData[BASE_DATA_LENGTH];
    PBYTE pbContentKey = NULL;
    DWORD cbContentKey = 0;

    DWORD dwImportFlags;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;
    const DWORD dw40BitLen = 40;

    // Generate derive key to use to encrypt and export the content encrypt key
    if (!CryptGenRandom(hExportProv, BASE_DATA_LENGTH, rgbBaseData))
        goto GenRandomError;
    if (!CryptCreateHash(hExportProv, CALG_SHA1, 0, 0, &hHash))
        goto ExportCreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, BASE_DATA_LENGTH, 0))
        goto ExportHashDataError;
    if (!CryptDeriveKey(
            hExportProv,
            CALG_RC2,
            hHash,
            40 << 16,               // dwFlags, dwBitLen in upper WORD
            &hDeriveKey))
        goto ExportDeriveKeyError;

    CryptSetKeyParam(
        hDeriveKey,
        KP_EFFECTIVE_KEYLEN,
        (PBYTE) &dw40BitLen,
        0);                 // dwFlags

    // Export the content encrypt key
    if (!CryptExportKey(
            pContentEncryptInfo->hContentEncryptKey,
            hDeriveKey,
            SYMMETRICWRAPKEYBLOB,
            0,                                          // dwFlags
            NULL,
            &cbContentKey))
        goto ExportKeyError;
    if (NULL == (pbContentKey = (PBYTE) ICM_Alloc(cbContentKey)))
        goto AllocError;
    if (!CryptExportKey(
            pContentEncryptInfo->hContentEncryptKey,
            hDeriveKey,
            SYMMETRICWRAPKEYBLOB,
            0,                                          // dwFlags
            pbContentKey,
            &cbContentKey))
        goto ExportKeyError;

    // Generate derive key to use to decrypt and import the content encrypt key
    CryptDestroyKey(hDeriveKey);
    hDeriveKey = 0;
    CryptDestroyHash(hHash);
    hHash = 0;

    if (!CryptCreateHash(hImportProv, CALG_SHA1, 0, 0, &hHash))
        goto ImportCreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, BASE_DATA_LENGTH, 0))
        goto ImportHashDataError;
    if (!CryptDeriveKey(
            hImportProv,
            CALG_RC2,
            hHash,
            40 << 16,               // dwFlags, dwBitLen in upper WORD
            &hDeriveKey))
        goto ImportDeriveKeyError;

    CryptSetKeyParam(
        hDeriveKey,
        KP_EFFECTIVE_KEYLEN,
        (PBYTE) &dw40BitLen,
        0);                 // dwFlags

    // Decrypt and import the content encrypt key
    dwImportFlags = CRYPT_EXPORTABLE;
    if (!ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo))
        dwImportFlags |= CRYPT_NO_SALT;
    if (!CryptImportKey(
            hImportProv,
            pbContentKey,
            cbContentKey,
            hDeriveKey,
            dwImportFlags,
            &hImportContentEncryptKey))
        goto ImportKeyError;

    // Need to re-set effective key length and IV

    if (!ICM_GetEncryptParameters(
            &pContentEncryptInfo->ContentEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hImportContentEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV

            CRYPT_DATA_BLOB SaltBlob;
            SaltBlob.pbData = rgbIV;
            SaltBlob.cbData = cbIV;

            if (!CryptSetKeyParam(
                    hImportContentEncryptKey,
                    KP_SALT_EX,
                    (PBYTE) &SaltBlob,
                    0))                 // dwFlags
                goto SetSaltExError;
        } else {
            if (!CryptSetKeyParam(
                    hImportContentEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

CommonReturn:
    if (hDeriveKey)
        CryptDestroyKey(hDeriveKey);
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_Free(pbContentKey);
    ICM_SetLastError(dwError);
    return hImportContentEncryptKey;
ErrorReturn:
    dwError = GetLastError();
    if (hImportContentEncryptKey) {
        CryptDestroyKey(hImportContentEncryptKey);
        hImportContentEncryptKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(GenRandomError)
TRACE_ERROR(ExportCreateHashError)
TRACE_ERROR(ExportHashDataError)
TRACE_ERROR(ExportDeriveKeyError)
TRACE_ERROR(ExportKeyError)
TRACE_ERROR(AllocError)
TRACE_ERROR(ImportCreateHashError)
TRACE_ERROR(ImportHashDataError)
TRACE_ERROR(ImportDeriveKeyError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}


//+-------------------------------------------------------------------------
//  Export the encrypted content encrypt key using the KeyTrans or KeyAgree
//  key.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ExportEncryptedKey(
    IN HCRYPTKEY hContentEncryptKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN BOOL fSP3CompatibleEncrypt,
    OUT PCRYPT_DATA_BLOB pEncryptedKey
    )
{
    BOOL fRet;
    PBYTE pbCspEncryptedKey = NULL;
    DWORD cbCspEncryptedKey;

    if (!CryptExportKey(
            hContentEncryptKey,
            hPubKey,
            dwBlobType,
            0,                  // dwFlags
            NULL,
            &cbCspEncryptedKey))
        goto ExportEncryptedKeyError;
    if (NULL == (pbCspEncryptedKey = (PBYTE) ICM_AllocA(cbCspEncryptedKey)))
        goto AllocError;
    if (!CryptExportKey(
            hContentEncryptKey,
            hPubKey,
            dwBlobType,
            0,                  // dwFlags
            pbCspEncryptedKey,
            &cbCspEncryptedKey))
        goto ExportEncryptedKeyError;
    assert(cbCspEncryptedKey >
        (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)));
    cbCspEncryptedKey -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    if (NULL == (pEncryptedKey->pbData = (PBYTE) ICM_Alloc(cbCspEncryptedKey)))
        goto AllocError;
    pEncryptedKey->cbData = cbCspEncryptedKey;


    if (SYMMETRICWRAPKEYBLOB == dwBlobType || fSP3CompatibleEncrypt)
        // Don't byte reverse
        memcpy(pEncryptedKey->pbData,
            pbCspEncryptedKey +
                (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
            cbCspEncryptedKey);
    else
        ICM_ReverseCopy(pEncryptedKey->pbData,
            pbCspEncryptedKey +
                (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
            cbCspEncryptedKey);

    fRet = TRUE;

CommonReturn:
    ICM_FreeA(pbCspEncryptedKey);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(AllocError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_IsSameRecipientPublicKeyAlgorithm(
    IN PCRYPT_ALGORITHM_IDENTIFIER paiPubKey1,
    IN PCRYPT_ALGORITHM_IDENTIFIER paiPubKey2
    )
{
    DWORD dwAlgIdPubKey1;
    DWORD dwAlgIdPubKey2;

    if (0 == strcmp(paiPubKey1->pszObjId, paiPubKey2->pszObjId))
        return TRUE;

    ICM_GetCAPI(
        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
        paiPubKey1,
        &dwAlgIdPubKey1);
    ICM_GetCAPI(
        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
        paiPubKey2,
        &dwAlgIdPubKey2);

    if (dwAlgIdPubKey1 == dwAlgIdPubKey2)
        return TRUE;

    // If we don't know about either public key, default to being the same.
    if (0 == dwAlgIdPubKey1 || 0 == dwAlgIdPubKey2)
        return TRUE;
    
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Default export of the encryption key for key transport recipient
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultExportKeyTrans(
#else
ICM_DefaultExportKeyTrans(
#endif
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hKeyTransProv = 0;
    HCRYPTKEY hContentEncryptKey = 0;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;
    HCRYPTKEY hPubKey = 0;

    hKeyTransProv = pKeyTransEncodeInfo->hCryptProv;

    if (0 == hKeyTransProv) {
        if (0 == pKeyTransEncryptInfo->dwRecipientIndex)
            hKeyTransProv = pContentEncryptInfo->hCryptProv;
        else {
            // Check if the type of and public key algorithm for this
            // recipient is the same as the first recipient's.

            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_TRANS_RECIPIENT == prei->dwRecipientChoice &&
                    ICM_IsSameRecipientPublicKeyAlgorithm(
                        &prei->pKeyTrans->KeyEncryptionAlgorithm,
                        &pKeyTransEncryptInfo->KeyEncryptionAlgorithm))
                hKeyTransProv = pContentEncryptInfo->hCryptProv;
            else {
                // Get default provider associated with the encryption
                // and public key algorithms

                DWORD dwAlgIdPubKey;
                DWORD dwAlgIdEncrypt;
                BYTE rgbIV[IV_MAX_LENGTH];
                DWORD cbIV;
                DWORD dwBitLen;

                if (!ICM_GetEncryptParameters(
                        &pContentEncryptInfo->ContentEncryptionAlgorithm,
                        &dwAlgIdEncrypt,
                        &dwBitLen,
                        rgbIV,
                        &cbIV))
                    goto GetEncryptParametersError;

                ICM_GetCAPI(
                    CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                    &pKeyTransEncryptInfo->KeyEncryptionAlgorithm,
                    &dwAlgIdPubKey);

                hKeyTransProv = I_CryptGetDefaultCryptProvForEncrypt(
                    dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
                if (0 == hKeyTransProv)
                    goto GetDefaultCryptProvError;
            }
        }
    }

    if (hKeyTransProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the KeyTrans provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hKeyTransProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    PublicKeyInfo.Algorithm = pKeyTransEncryptInfo->KeyEncryptionAlgorithm;
    PublicKeyInfo.PublicKey = pKeyTransEncodeInfo->RecipientPublicKey;

    if (!CryptImportPublicKeyInfo(
            hKeyTransProv,
            X509_ASN_ENCODING,
            &PublicKeyInfo,
            &hPubKey))
        goto ImportPubKeyError;

    if (!ICM_ExportEncryptedKey(
            hContentEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo),
            &pKeyTransEncryptInfo->EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    if (hKeyTransProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
            CryptDestroyKey(hContentEncryptKey);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(ImportPubKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    LPCSTR pszKeyEncryptOID =
        pKeyTransEncryptInfo->KeyEncryptionAlgorithm.pszObjId;

    if (CryptGetOIDFunctionAddress(
            hExportKeyTransFuncSet,
            X509_ASN_ENCODING,
            pszKeyEncryptOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_KEY_TRANS) pvFuncAddr)(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
    } else if ((NULL == pKeyTransEncodeInfo->hCryptProv ||
            pKeyTransEncodeInfo->hCryptProv ==
                pContentEncryptInfo->hCryptProv)
                        &&
            CryptGetOIDFunctionAddress(
                hOldStyleExportEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                pszKeyEncryptOID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)
                        &&
#ifdef DEBUG_CRYPT_ASN1
                0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG)
                        &&
#endif // DEBUG_CRYPT_ASN1
            (void *) ICM_DefaultExportEncryptKey != pvFuncAddr) {
        CERT_PUBLIC_KEY_INFO PublicKeyInfo;
        PBYTE pbData;
        DWORD rgcbData[2] = {0, 0};

        if (ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo))
            rgcbData[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;

        PublicKeyInfo.Algorithm = pKeyTransEncryptInfo->KeyEncryptionAlgorithm;
        PublicKeyInfo.PublicKey = pKeyTransEncodeInfo->RecipientPublicKey;
        fRet = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
            pContentEncryptInfo->hCryptProv,
            pContentEncryptInfo->hContentEncryptKey,
            &PublicKeyInfo,
            NULL,                       // pbData
            rgcbData);
        if (fRet) {
            if (NULL == (pbData = (PBYTE) ICM_Alloc(rgcbData[0])))
                fRet = FALSE;
            else {
                fRet = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
                    pContentEncryptInfo->hCryptProv,
                    pContentEncryptInfo->hContentEncryptKey,
                    &PublicKeyInfo,
                    pbData,
                    rgcbData);
                if (fRet) {
                    pKeyTransEncryptInfo->EncryptedKey.pbData = pbData;
                    pKeyTransEncryptInfo->EncryptedKey.cbData = rgcbData[0];
                } else
                    ICM_Free(pbData);
            }
        }
    } else
        fRet = ICM_DefaultExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fRet;
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID.
//
//  For RC2, if the ASN.1 encryption algorithm has any parameters, decode to
//  get the key bit length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetWrapEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    *pdwBitLen = 0;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        // Check if more than just the NULL parameters
        if (2 < paiEncrypt->Parameters.cbData) {
            PBYTE pbEncoded = paiEncrypt->Parameters.pbData;
            DWORD cbEncoded = paiEncrypt->Parameters.cbData;

            // Try to decode as an integer containing the RC2 version
            int iVersion = 0;
            DWORD cbStructInfo = sizeof(iVersion);

            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_INTEGER,
                    pbEncoded,
                    cbEncoded,
                    0,                          // dwFlags
                    &iVersion,
                    &cbStructInfo))
                goto RC2VersionDecodeError;
            if (!ICM_RC2VersionToBitLength(iVersion, pdwBitLen))
                goto RC2VersionToBitLengthError;
        } else
            *pdwBitLen = 40;
    }
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(RC2VersionDecodeError)
TRACE_ERROR(RC2VersionToBitLengthError)
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID and bit length by decoding the DH Encryption Parameters
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDhWrapEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT LPSTR                       *ppszAllocWrapOID,
    OUT PDWORD                      pdwAlgIdWrap,
    OUT PDWORD                      pdwBitLen           // 0 => default length
    )
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fRet;
    ASN1error_e Asn1Err;
    ASN1decoding_t pDec = ICM_GetDecoder();
    AlgorithmIdentifier *poai = NULL;
    CRYPT_ALGORITHM_IDENTIFIER ai;   ZEROSTRUCT(ai);

    // Decode the DH KeyEncryption Parameters to get the Wrap Encryption
    // Algorithm
    if (0 == paiEncrypt->Parameters.cbData)
        goto NoDhWrapParametersError;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poai,
            AlgorithmIdentifier_PDU,
            paiEncrypt->Parameters.pbData,
            paiEncrypt->Parameters.cbData)))
        goto Asn1DecodeAlgorithmIdentifierError;

    if (!ICM_Asn1FromAlgorithmIdentifier(poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    if (!ICM_GetWrapEncryptParameters(&ai, pdwAlgIdWrap, pdwBitLen))
        goto GetWrapEncryptParametersError;
    *ppszAllocWrapOID = ai.pszObjId;
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AlgorithmIdentifier_PDU, poai);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(ai.pszObjId);
    *ppszAllocWrapOID = NULL;
    *pdwBitLen = 0;
    *pdwAlgIdWrap = 0;
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(NoDhWrapParametersError, CRYPT_E_UNKNOWN_ALGO)
SET_ERROR_VAR(Asn1DecodeAlgorithmIdentifierError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
TRACE_ERROR(GetWrapEncryptParametersError)
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2ParameterVersion
//  integer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultWrapEncryptParameters(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    IN PVOID pvEncryptAuxInfo,
    OUT PDWORD pdwAlgIdEncrypt,
    OUT PDWORD pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    assert(0 == paiEncrypt->Parameters.cbData);
    *pdwBitLen = 0;
    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo =
            (PCMSG_RC2_AUX_INFO) pvEncryptAuxInfo;
        CRYPT_ENCODE_PARA EncodePara;
        int iVersion;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            DWORD dwVersion;
            *pdwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;

            if (!ICM_BitLengthToRC2Version(*pdwBitLen, &dwVersion))
                goto BitLengthToRC2VersionError;
            iVersion = dwVersion;
        } else {
            iVersion = CRYPT_RC2_40BIT_VERSION;
            *pdwBitLen = 40;
        }

        ZEROSTRUCT(EncodePara);
        EncodePara.cbSize = sizeof(EncodePara);
        EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
        EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
        if (!CryptEncodeObjectEx(
                X509_ASN_ENCODING,
                X509_INTEGER,
                &iVersion,
                CRYPT_ENCODE_ALLOC_FLAG,
                &EncodePara,
                (void *) &paiEncrypt->Parameters.pbData,
                &paiEncrypt->Parameters.cbData
                )) goto EncodeError;
    }
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID. 
//  Encode the DH EncryptionAlgorithmIdentifier parameters which is the encoded
//  WrapAlgorithmIdentifier.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultDhWrapEncryptParameters(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER paiWrap,
    IN PVOID pvWrapAuxInfo,
    OUT PDWORD pdwAlgIdWrap,
    OUT PDWORD pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    CRYPT_ALGORITHM_IDENTIFIER aiWrap;  ZEROSTRUCT(aiWrap);
    AlgorithmIdentifier oaiWrap;

    assert(0 == paiEncrypt->Parameters.cbData);

    if (0 == paiWrap->Parameters.cbData) {
        aiWrap = *paiWrap;
        if (!ICM_CreateDefaultWrapEncryptParameters(
                pContentEncryptInfo,
                &aiWrap,
                pvWrapAuxInfo,
                pdwAlgIdWrap,
                pdwBitLen))
            goto CreateDefaultWrapEncryptParametersError;
        paiWrap = &aiWrap;
    } else {
        if (!ICM_GetWrapEncryptParameters(
                paiWrap,
                pdwAlgIdWrap,
                pdwBitLen))
            goto GetWrapEncryptParametersError;
    }

    // Encode the Wrap Algorithm Identifier
    if (!ICM_Asn1ToAlgorithmIdentifier(
            paiWrap,
            &oaiWrap))
        goto Asn1ToAlgorithmIdentifierError;
    if (!ICM_Asn1Encode(
            AlgorithmIdentifier_PDU,
            &oaiWrap,
            &paiEncrypt->Parameters))
        goto EncodeAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    ICM_Free(aiWrap.Parameters.pbData);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateDefaultWrapEncryptParametersError)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)
TRACE_ERROR(EncodeAlgorithmIdentifierError)
}

BOOL
WINAPI
ICM_PadEncodedOctets(
    IN DWORD cbMaxContents,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fRet;
    DWORD cbEncoded = *pcbEncoded;
    DWORD cbMaxEncoded;
    DWORD cbLength;

    ICM_GetLengthOctets(cbMaxContents, NULL, &cbLength);
    cbMaxEncoded = 1 + cbLength + cbMaxContents;
    if (cbMaxEncoded > cbEncoded) {
        BYTE *pbMaxEncoded;
        BYTE *pbEncoded;

        if (NULL == (pbMaxEncoded = (BYTE *) ICM_Alloc(cbMaxEncoded)))
            goto OutOfMemory;

        pbEncoded = *ppbEncoded;
        memcpy(pbMaxEncoded, pbEncoded, cbEncoded);
        memset(pbMaxEncoded + cbEncoded, 0, cbMaxEncoded - cbEncoded);
        ICM_Free(pbEncoded);
        *ppbEncoded = pbMaxEncoded;
        *pcbEncoded = cbMaxEncoded;
    } else if (cbMaxEncoded < cbEncoded)
        goto InvalidMaxEncodedLength;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR(InvalidMaxEncodedLength, ERROR_INVALID_DATA)
}


#ifndef DH1
#define DH1 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'1'<<24))
#endif

HCRYPTKEY
WINAPI
ICM_GenerateEphemeralDh(
    IN HCRYPTPROV hProv,
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    OUT DWORD *pcbP
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTKEY hEphemeralKey = 0;
    PCRYPT_ALGORITHM_IDENTIFIER paiEphemeral =
        pKeyAgreeEncodeInfo->pEphemeralAlgorithm;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo =
        &pKeyAgreeEncryptInfo->OriginatorPublicKeyInfo;
    PCERT_X942_DH_PARAMETERS pDhParameters = NULL;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DHPUBKEY *pCspPubKey;
    DWORD cbP;
    PCRYPT_UINT_BLOB pGBlob;
    BYTE *pbY;
    DWORD cbY;
    CRYPT_UINT_BLOB YBlob;
    CRYPT_ENCODE_PARA EncodePara;

    assert(CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE ==
        pKeyAgreeEncodeInfo->dwKeyChoice);
    if (NULL == (pDhParameters =
            (PCERT_X942_DH_PARAMETERS) ICM_AllocAndDecodeObject(
                X942_DH_PARAMETERS,
                paiEphemeral->Parameters.pbData,
                paiEphemeral->Parameters.cbData)))
        goto DhParametersDecodeError;

    cbP = pDhParameters->p.cbData;
    *pcbP = cbP;
    
    if (!CryptGenKey(
            hProv,
            CALG_DH_EPHEM,
            ((cbP * 8) << 16) | CRYPT_EXPORTABLE | CRYPT_PREGEN,
            &hEphemeralKey))
        goto GenEphemeralKeyError;

    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_P,
            (PBYTE) &pDhParameters->p,
            0))                 // dwFlags
        goto SetPError;

    // Note, the length of G can be less than length P. Pad with leading
    // zeroes in little endian form.
    if (pDhParameters->g.cbData >= cbP)
        pGBlob = &pDhParameters->g;
    else {
        DWORD cbG = pDhParameters->g.cbData;

        // We are done using P parameter. Overwrite with the G parameter and
        // pad with leading zeroes in little endian form.
        pGBlob = &pDhParameters->p;
        memcpy(pGBlob->pbData, pDhParameters->g.pbData, cbG);
        memset(pGBlob->pbData + cbG, 0, cbP - cbG);
    }
    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_G,
            (PBYTE) pGBlob,
            0))                 // dwFlags
        goto SetGError;

    if (0 < pDhParameters->q.cbData) {
        if (!CryptSetKeyParam(
                hEphemeralKey,
                KP_Q,
                (PBYTE) &pDhParameters->q,
                0))                 // dwFlags
            goto SetQError;
    }

    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_X,
            NULL,               // pbData
            0))                 // dwFlags
        goto SetXError;

    // Export the public key to get Y
    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hEphemeralKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0))
        goto ExportPublicKeyBlobError;
    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) ICM_Alloc(cbPubKeyStruc)))
        goto OutOfMemory;
    if (!CryptExportKey(
            hEphemeralKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            ))
        goto ExportPublicKeyBlobError;


    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbKey]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbY = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);
    cbY = pCspPubKey->bitlen / 8;

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbY)
        goto InvalidEphemeralKey;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidEphemeralKey;
    if (pCspPubKey->magic != DH1)
        goto InvalidEphemeralKey;
    if (cbY != cbP)
        goto InvalidEphemeralKey;

    ZEROSTRUCT(EncodePara);
    EncodePara.cbSize = sizeof(EncodePara);
    EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
    EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
    YBlob.pbData = pbY;
    YBlob.cbData = cbY;
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            X509_DH_PUBLICKEY,
            &YBlob,
            CRYPT_ENCODE_ALLOC_FLAG,
            &EncodePara,
            (void *) &pPubKeyInfo->PublicKey.pbData,
            &pPubKeyInfo->PublicKey.cbData
            ))
        goto EncodeDHPublicKeyError;

    pKeyAgreeEncryptInfo->dwOriginatorChoice =
        CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY;
    pPubKeyInfo->Algorithm.pszObjId = paiEphemeral->pszObjId;
    pKeyAgreeEncryptInfo->dwFlags |=
        CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG;

    if (pContentEncryptInfo->dwEncryptFlags &
            CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG) {
        if (!ICM_PadEncodedOctets(
                cbY + 1,
                &pPubKeyInfo->PublicKey.pbData,
                &pPubKeyInfo->PublicKey.cbData
                ))
            goto PadEncodedOctetsError;
    }


CommonReturn:
    ICM_Free(pDhParameters);
    ICM_Free(pPubKeyStruc);
    ICM_SetLastError(dwError);
    return hEphemeralKey;

ErrorReturn:
    dwError = GetLastError();
    if (hEphemeralKey) {
        CryptDestroyKey(hEphemeralKey);
        hEphemeralKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(DhParametersDecodeError)
TRACE_ERROR(GenEphemeralKeyError)
TRACE_ERROR(SetPError)
TRACE_ERROR(SetGError)
TRACE_ERROR(SetQError)
TRACE_ERROR(SetXError)
TRACE_ERROR(ExportPublicKeyBlobError)
SET_ERROR(InvalidEphemeralKey, NTE_BAD_PUBLIC_KEY)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(EncodeDHPublicKeyError)
TRACE_ERROR(PadEncodedOctetsError)
}

HCRYPTKEY
WINAPI
ICM_ImportDhAgreeKey(
    IN HCRYPTPROV hKeyAgreeProv,
    IN HCRYPTKEY hMyKey,
    IN DWORD cbP,
    IN PCRYPT_BIT_BLOB pPublicKey,
    IN LPSTR pszWrapOID,
    IN ALG_ID AlgidWrap,
    IN DWORD dwBitLen,
    IN PCRYPT_DATA_BLOB pUserKeyingMaterial
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTKEY hAgreeKey = 0;
    PCRYPT_UINT_BLOB pDhPubKey = NULL;
    PBYTE pbKeyBlob = NULL;
    DWORD cbKeyBlob;
    PUBLICKEYSTRUC *pPubKeyStruc;
    DHPUBKEY *pCspPubKey;
    DWORD cbY;
    PBYTE pbKey;

    CMS_DH_KEY_INFO CmsDhKeyInfo;    ZEROSTRUCT(CmsDhKeyInfo);

    if (NULL == (pDhPubKey = (PCRYPT_UINT_BLOB) ICM_AllocAndDecodeObject(
            X509_DH_PUBLICKEY,
            pPublicKey->pbData,
            pPublicKey->cbData)))
        goto DecodePubKeyError;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbP]

    cbY = pDhPubKey->cbData;
    if (0 == cbY || cbY > cbP)
        goto InvalidDhPubKeyError;
    cbKeyBlob = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbP;
    if (NULL == (pbKeyBlob = (PBYTE) ICM_Alloc(cbKeyBlob)))
        goto OutOfMemory;

    pPubKeyStruc = (PUBLICKEYSTRUC *) pbKeyBlob;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);
    
    // PUBLICKEYSTRUC
    pPubKeyStruc->bType = PUBLICKEYBLOB;
    pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
    pPubKeyStruc->reserved = 0;
    pPubKeyStruc->aiKeyAlg = CALG_DH_SF;
    // DHPUBKEY
    pCspPubKey->magic = DH1;
    pCspPubKey->bitlen = cbP * 8;
    // rgbY[cbP]
    memcpy(pbKey, pDhPubKey->pbData, cbY);
    if (cbP > cbY)
        memset(pbKey + cbY, 0, cbP - cbY);

    if (!CryptImportKey(
            hKeyAgreeProv,
            pbKeyBlob,
            cbKeyBlob,
            hMyKey,
            0,                      // dwFlags
            &hAgreeKey)) {
        hAgreeKey = 0;
        goto ImportKeyError;
    }

    CmsDhKeyInfo.dwVersion = sizeof(CmsDhKeyInfo);
    CmsDhKeyInfo.Algid = AlgidWrap;
    CmsDhKeyInfo.pszContentEncObjId = pszWrapOID;
    CmsDhKeyInfo.PubInfo = *pUserKeyingMaterial;
    // CmsDhKeyInfo.pReserved

    if (!CryptSetKeyParam(
            hAgreeKey,
            KP_CMS_DH_KEY_INFO,
            (PBYTE) &CmsDhKeyInfo,
            (CALG_RC2 == AlgidWrap) ? (dwBitLen << 16) : 0))     // dwFlags
        goto SetCmsDhKeyInfoError;

    if (CALG_RC2 == AlgidWrap && 0 != dwBitLen) {
        if (!CryptSetKeyParam(
                hAgreeKey,
                KP_EFFECTIVE_KEYLEN,
                (PBYTE) &dwBitLen,
                0))                     // dwFlags
            goto SetEffectiveKeyLenError;
    }

CommonReturn:
    ICM_Free(pDhPubKey);
    ICM_Free(pbKeyBlob);
    ICM_SetLastError(dwError);
    return hAgreeKey;

ErrorReturn:
    dwError = GetLastError();
    if (hAgreeKey) {
        CryptDestroyKey(hAgreeKey);
        hAgreeKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(DecodePubKeyError)
SET_ERROR(InvalidDhPubKeyError, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(SetCmsDhKeyInfoError)
TRACE_ERROR(SetEffectiveKeyLenError)
}

BOOL
WINAPI
ICM_DefaultExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hKeyAgreeProv = 0;           // Doesn't need to be released
    HCRYPTKEY hContentEncryptKey = 0;
    HCRYPTKEY hEphemeralKey = 0;
    HCRYPTKEY hAgreeKey = 0;
    DWORD cbP;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pKeyAgreeEncryptInfo->KeyEncryptionAlgorithm;
    LPSTR pszAllocWrapOID = NULL;
    LPSTR pszWrapOID;
    DWORD dwAlgIdWrap;
    DWORD dwBitLen;

    DWORD cRecipient;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *ppRecipientEncryptInfo;
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *ppRecipientEncodeInfo;

    assert(CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE ==
        pKeyAgreeEncodeInfo->dwKeyChoice);
    if (CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE != pKeyAgreeEncodeInfo->dwKeyChoice)
        goto InvalidKeyAgreeKeyChoice;

    if (0 == paiEncrypt->Parameters.cbData) {
        PCRYPT_ALGORITHM_IDENTIFIER paiWrap =
            &pKeyAgreeEncodeInfo->KeyWrapAlgorithm;

        if (!ICM_CreateDefaultDhWrapEncryptParameters(
                pContentEncryptInfo,
                paiEncrypt,
                paiWrap,
                pKeyAgreeEncodeInfo->pvKeyWrapAuxInfo,
                &dwAlgIdWrap,
                &dwBitLen))
            goto CreateDefaultDhWrapEncryptParametersError;
        assert(paiEncrypt->Parameters.cbData);
        pKeyAgreeEncryptInfo->dwFlags |= CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG;
        pszWrapOID = paiWrap->pszObjId;
    } else {
        if (!ICM_GetDhWrapEncryptParameters(
                paiEncrypt,
                &pszAllocWrapOID,
                &dwAlgIdWrap,
                &dwBitLen))
            goto GetDhWrapEncryptParametersError;
        pszWrapOID = pszAllocWrapOID;
    }

    hKeyAgreeProv = pKeyAgreeEncodeInfo->hCryptProv;
    if (0 == hKeyAgreeProv) {
        if (0 == pKeyAgreeEncryptInfo->dwRecipientIndex)
            hKeyAgreeProv = pContentEncryptInfo->hCryptProv;
        else {
            // Check if the type of and public key algorithm for this
            // recipient is the same as the first recipient's.

            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_AGREE_RECIPIENT == prei->dwRecipientChoice &&
                    ICM_IsSameRecipientPublicKeyAlgorithm(
                        &prei->pKeyAgree->KeyEncryptionAlgorithm,
                        paiEncrypt))
                hKeyAgreeProv = pContentEncryptInfo->hCryptProv;
            else {
                // Get default provider associated with the
                // key encryption algorithm
                DWORD dwAlgIdPubKey;

                if (!ICM_GetCAPI(
                        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                        paiEncrypt,
                        &dwAlgIdPubKey))
                    goto GetPublicKeyAlgIdError;

                hKeyAgreeProv = I_CryptGetDefaultCryptProvForEncrypt(
                    dwAlgIdPubKey, dwAlgIdWrap, dwBitLen);
                if (0 == hKeyAgreeProv)
                    goto GetDefaultCryptProvError;
            }
        }
    }

    if (hKeyAgreeProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the KeyAgree provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hKeyAgreeProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    if (0 == (hEphemeralKey = ICM_GenerateEphemeralDh(
            hKeyAgreeProv,
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            &cbP)))
        goto GenerateEphemeralDhError;

    cRecipient = pKeyAgreeEncryptInfo->cKeyAgreeKeyEncryptInfo;
    ppRecipientEncryptInfo = pKeyAgreeEncryptInfo->rgpKeyAgreeKeyEncryptInfo;
    ppRecipientEncodeInfo = pKeyAgreeEncodeInfo->rgpRecipientEncryptedKeys;
    for ( ; 0 < cRecipient;
                    cRecipient--,
                    ppRecipientEncryptInfo++,
                    ppRecipientEncodeInfo++) {
        if (0 == (hAgreeKey = ICM_ImportDhAgreeKey(
                hKeyAgreeProv,
                hEphemeralKey,
                cbP,
                &(*ppRecipientEncodeInfo)->RecipientPublicKey,
                pszWrapOID,
                dwAlgIdWrap,
                dwBitLen,
                &pKeyAgreeEncodeInfo->UserKeyingMaterial
                )))
            goto ImportDhAgreeKeyError;

        if (!ICM_ExportEncryptedKey(
                hContentEncryptKey,
                hAgreeKey,
                SYMMETRICWRAPKEYBLOB,
                FALSE,                  // fAllowSP3CompatibleEncrypt
                &(*ppRecipientEncryptInfo)->EncryptedKey))
            goto ExportEncryptedKeyError;

        CryptDestroyKey(hAgreeKey);
        hAgreeKey = 0;
    }

    fRet = TRUE;

CommonReturn:
    ICM_Free(pszAllocWrapOID);

    if (hKeyAgreeProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
        CryptDestroyKey(hContentEncryptKey);
    if (hAgreeKey)
        CryptDestroyKey(hAgreeKey);
    if (hEphemeralKey)
        CryptDestroyKey(hEphemeralKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidKeyAgreeKeyChoice, E_INVALIDARG)
TRACE_ERROR(CreateDefaultDhWrapEncryptParametersError)
TRACE_ERROR(GetDhWrapEncryptParametersError)
TRACE_ERROR(GetPublicKeyAlgIdError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(GenerateEphemeralDhError)
TRACE_ERROR(ImportDhAgreeKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportKeyAgreeFuncSet,
            X509_ASN_ENCODING,
            pKeyAgreeEncryptInfo->KeyEncryptionAlgorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_KEY_AGREE) pvFuncAddr)(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fRet = ICM_DefaultExportKeyAgree(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    return fRet;
}

BOOL
WINAPI
ICM_DefaultExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hMailListProv = 0;           // not released
    HCRYPTKEY hContentEncryptKey = 0;       // destroy if exported/imported
    HCRYPTKEY hKeyEncryptionKey = 0;        // not destroyed
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pMailListEncryptInfo->KeyEncryptionAlgorithm;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;

    hMailListProv = pMailListEncodeInfo->hCryptProv;
    switch (pMailListEncodeInfo->dwKeyChoice) {
        case CMSG_MAIL_LIST_HANDLE_KEY_CHOICE:
            hKeyEncryptionKey = pMailListEncodeInfo->hKeyEncryptionKey;
            assert(hMailListProv && hKeyEncryptionKey);
            if (0 == hMailListProv || 0 == hKeyEncryptionKey)
                goto InvalidMailListHandleKeyPara;
            break;
        default:
            goto InvalidMailListKeyChoice;
    }

    if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultWrapEncryptParameters(
                pContentEncryptInfo,
                paiEncrypt,
                pMailListEncodeInfo->pvKeyEncryptionAuxInfo,
                &dwAlgIdEncrypt,
                &dwBitLen))
            goto CreateDefaultWrapEncryptParametersError;
        if (paiEncrypt->Parameters.cbData)
            pMailListEncryptInfo->dwFlags |=
                CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG;
    } else {
        if (!ICM_GetWrapEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen))
            goto GetWrapEncryptParametersError;
    }


    if (hMailListProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the MailList provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hMailListProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hKeyEncryptionKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (!ICM_ExportEncryptedKey(
            hContentEncryptKey,
            hKeyEncryptionKey,
            SYMMETRICWRAPKEYBLOB,
            FALSE,                  // fAllowSP3CompatibleEncrypt
            &pMailListEncryptInfo->EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    if (hMailListProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
        CryptDestroyKey(hContentEncryptKey);

    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidMailListHandleKeyPara, E_INVALIDARG)
SET_ERROR(InvalidMailListKeyChoice, E_INVALIDARG)
TRACE_ERROR(CreateDefaultWrapEncryptParametersError)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportMailListFuncSet,
            X509_ASN_ENCODING,
            pMailListEncryptInfo->KeyEncryptionAlgorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_MAIL_LIST) pvFuncAddr)(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            pMailListEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fRet = ICM_DefaultExportMailList(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            pMailListEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    return fRet;
}

//+-------------------------------------------------------------------------
//  Default export of the encryption key
//
//  Note, pcbData[1] contains dwEncryptFlags, where,
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG may be set to disable the reversing
//  of the encoded, encrypted symmetric key.
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
//
//  OldStyle
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL            fRet;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    CRYPT_DATA_BLOB EncryptedKey;       ZEROSTRUCT(EncryptedKey);
    DWORD           cb;

    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;

    if (!ICM_ExportEncryptedKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0 != (rgcbData[1] & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG),
            &EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;
    cb = EncryptedKey.cbData;
    if (pbData) {
        if (rgcbData[0] < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else
            memcpy(pbData, EncryptedKey.pbData, cb);
    }

CommonReturn:
    rgcbData[0] = cb;
    ICM_Free(EncryptedKey.pbData);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    cb = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PCMSG_RECIPIENT_ENCODE_INFO
WINAPI
ICM_CreateCmsRecipientEncodeInfos(
    IN DWORD cRecipients,
    IN PCERT_INFO *rgpCertInfoRecipients
    )
{
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients = NULL;
    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO rgKeyTrans;
    DWORD cbCmsRecipients;
    DWORD i;

    assert(cRecipients && rgpCertInfoRecipients);
    cbCmsRecipients = sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipients +
        sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO) * cRecipients;

    if (NULL == (rgCmsRecipients = (PCMSG_RECIPIENT_ENCODE_INFO) ICM_AllocZero(
            cbCmsRecipients)))
        return NULL;

    rgKeyTrans = (PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)
        (((PBYTE) rgCmsRecipients) +
            sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipients);

    for (i = 0; i < cRecipients; i++) {
        rgCmsRecipients[i].dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
        rgCmsRecipients[i].pKeyTrans = &rgKeyTrans[i];
        rgKeyTrans[i].cbSize = sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO);
        rgKeyTrans[i].KeyEncryptionAlgorithm =
            rgpCertInfoRecipients[i]->SubjectPublicKeyInfo.Algorithm;
        // rgKeyTrans[i].pvKeyEncryptionAuxInfo =
        // rgKeyTrans[i].hCryptProv =
        rgKeyTrans[i].RecipientPublicKey =
            rgpCertInfoRecipients[i]->SubjectPublicKeyInfo.PublicKey;

        ICM_GetCertIdFromCertInfo(rgpCertInfoRecipients[i],
            &rgKeyTrans[i].RecipientId);
    }

    return rgCmsRecipients;
}

void
WINAPI
ICM_FreeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    DWORD dwErr = GetLastError();

    if (pEnvelopedEncodeInfo->rgpRecipients) {
        ICM_Free(pContentEncryptInfo->rgCmsRecipients);
        pContentEncryptInfo->rgCmsRecipients = NULL;
    }

    if (pContentEncryptInfo->hContentEncryptKey) {
        CryptDestroyKey(pContentEncryptInfo->hContentEncryptKey);
        pContentEncryptInfo->hContentEncryptKey = 0;
    }

    if (pContentEncryptInfo->dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG) {
        pContentEncryptInfo->dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG;
        assert(pContentEncryptInfo->hCryptProv);
        CryptReleaseContext(pContentEncryptInfo->hCryptProv, 0);
        pContentEncryptInfo->hCryptProv = 0;
    }

    if (pContentEncryptInfo->dwFlags &
            CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG) {
        pContentEncryptInfo->dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;
        assert(
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData
                &&
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData);
        ICM_Free(
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData);
        pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData = 0;
        pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData = NULL;
    }

    SetLastError(dwErr);
}



BOOL
WINAPI
ICM_InitializeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    BOOL fRet;
    DWORD cRecipients;

    memset(pContentEncryptInfo, 0, sizeof(*pContentEncryptInfo));
    pContentEncryptInfo->cbSize = sizeof(*pContentEncryptInfo);
    pContentEncryptInfo->hCryptProv =
        pEnvelopedEncodeInfo->hCryptProv;
    pContentEncryptInfo->ContentEncryptionAlgorithm =
        pEnvelopedEncodeInfo->ContentEncryptionAlgorithm;
    pContentEncryptInfo->pvEncryptionAuxInfo =
        pEnvelopedEncodeInfo->pvEncryptionAuxInfo;
    pContentEncryptInfo->pfnAlloc = ICM_Alloc;
    pContentEncryptInfo->pfnFree = ICM_Free;
    // pContentEncryptInfo->dwEncryptFlags =
    // pContentEncryptInfo->hContentEncryptKey =
    // pContentEncryptInfo->dwFlags =

    cRecipients = pEnvelopedEncodeInfo->cRecipients;
    pContentEncryptInfo->cRecipients = cRecipients;

    if (0 == cRecipients)
        ;
    else if (pEnvelopedEncodeInfo->rgpRecipients) {
        if (NULL == (pContentEncryptInfo->rgCmsRecipients =
                ICM_CreateCmsRecipientEncodeInfos(
                    cRecipients, pEnvelopedEncodeInfo->rgpRecipients)))
            goto CreateCmsRecipientEncodeInfosError;
    } else {
        if (sizeof(CMSG_ENVELOPED_ENCODE_INFO) > pEnvelopedEncodeInfo->cbSize)
            goto MissingCmsRecipients;
        pContentEncryptInfo->rgCmsRecipients =
            pEnvelopedEncodeInfo->rgCmsRecipients;
        if (NULL == pContentEncryptInfo->rgCmsRecipients)
            goto MissingCmsRecipients;
    }

    if (!ICM_GenContentEncryptKey(pContentEncryptInfo))
        goto GenContentEncryptKeyError;

    fRet = TRUE;

CommonReturn:
    return fRet;
ErrorReturn:
    ICM_FreeContentEncryptInfo(pEnvelopedEncodeInfo, pContentEncryptInfo);
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(MissingCmsRecipients, E_INVALIDARG)
TRACE_ERROR(CreateCmsRecipientEncodeInfosError)
TRACE_ERROR(GenContentEncryptKeyError)
}


//+-------------------------------------------------------------------------
//  Oss set/free functions
//
//  Assumption: upon entry to the set functions, the Oss data structure has
//  already been zeroed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetOssAny(
    IN PCRYPT_DATA_BLOB pAny,
    IN OUT Any *pOssAny
    )
{
    if (NULL == (pOssAny->value =
            (unsigned char *) ICM_DupMem(pAny->pbData, pAny->cbData)))
        return FALSE;
    pOssAny->length = pAny->cbData;
    return TRUE;
}

void
WINAPI
ICM_FreeOssAny(
    IN OUT Any *pOssAny
    )
{
    if (pOssAny->value) {
        ICM_Free(pOssAny->value);
        pOssAny->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssHugeInteger(
    IN PCRYPT_INTEGER_BLOB pHugeInteger,
    IN OUT HugeIntegerType *pOssHugeInteger
    )
{
    return PkiAsn1SetHugeInteger(
        pHugeInteger,
        &pOssHugeInteger->length,
        &pOssHugeInteger->value
        );
}

void
WINAPI
ICM_FreeOssHugeInteger(
    IN OUT HugeIntegerType *pOssHugeInteger
    )
{
    if (pOssHugeInteger->value) {
        PkiAsn1FreeHugeInteger(pOssHugeInteger->value);
        pOssHugeInteger->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssOctetString(
    IN PCRYPT_DATA_BLOB pOctetString,
    IN OUT OctetStringType *pOssOctetString
    )
{
    if (NULL == (pOssOctetString->value =
            (unsigned char *) ICM_DupMem(
                pOctetString->pbData, pOctetString->cbData)))
        return FALSE;
    pOssOctetString->length = pOctetString->cbData;
    return TRUE;
}

void
WINAPI
ICM_FreeOssOctetString(
    IN OUT OctetStringType *pOssOctetString
    )
{
    if (pOssOctetString->value) {
        ICM_Free(pOssOctetString->value);
        pOssOctetString->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssBitString(
    IN PCRYPT_BIT_BLOB pBitString,
    IN OUT BitStringType *pOssBitString
    )
{
    CRYPT_BIT_BLOB BitString = *pBitString;
    if (NULL == (BitString.pbData = (PBYTE) ICM_DupMem(
            BitString.pbData, BitString.cbData)))
        return FALSE;

    PkiAsn1SetBitString(&BitString, &pOssBitString->length,
        &pOssBitString->value);
    return TRUE;
}

void
WINAPI
ICM_FreeOssBitString(
    IN OUT BitStringType *pOssBitString
    )
{
    if (pOssBitString->value) {
        ICM_Free(pOssBitString->value);
        pOssBitString->value = NULL;
    }
}

static BYTE abDerNULL[] = {5, 0};

BOOL
WINAPI
ICM_SetOssAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
    BOOL fRet;
    PBYTE pbData;
    DWORD cbData;

    pOssAlgId->algorithm.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pai->pszObjId,
            &pOssAlgId->algorithm.count,
            pOssAlgId->algorithm.value))
        goto PkiAsn1ToObjectIdentifierError;
    pOssAlgId->bit_mask = parameters_present;

    pbData = pai->Parameters.pbData;
    cbData = pai->Parameters.cbData;
    if (0 == cbData) {
        pOssAlgId->parameters.length = sizeof(abDerNULL);
        pOssAlgId->parameters.value = abDerNULL;
    } else {
        if (NULL == (pOssAlgId->parameters.value =
                (unsigned char *) ICM_DupMem(pbData, cbData)))
            goto OutOfMemory;
        pOssAlgId->parameters.length = cbData;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError, CRYPT_E_OID_FORMAT)
TRACE_ERROR(OutOfMemory)
}

void
WINAPI
ICM_FreeOssAlgorithmIdentifier(
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
    unsigned char *value;

#ifdef OSS_CRYPT_ASN1
    value = pOssAlgId->parameters.value;
#else
    value = (unsigned char *) pOssAlgId->parameters.value;
#endif  // OSS_CRYPT_ASN1
    if (value && value != abDerNULL) {
        ICM_Free(value);
        pOssAlgId->parameters.value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssOtherKeyAttribute(
    IN PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr,
    IN OUT OtherKeyAttribute *pOssOtherAttr
    )
{
    BOOL fRet;

    pOssOtherAttr->keyAttrId.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pOtherAttr->pszObjId,
            &pOssOtherAttr->keyAttrId.count,
            pOssOtherAttr->keyAttrId.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (pOtherAttr->Value.cbData) {
        if (!ICM_SetOssAny(&pOtherAttr->Value, &pOssOtherAttr->keyAttr))
            goto SetOssAnyError;

        pOssOtherAttr->bit_mask |= keyAttr_present;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError, CRYPT_E_OID_FORMAT)
TRACE_ERROR(SetOssAnyError)
}

void
WINAPI
ICM_FreeOssOtherKeyAttribute(
    OUT OtherKeyAttribute *pOssOtherAttr
    )
{
    ICM_FreeOssAny(&pOssOtherAttr->keyAttr);
}

void
WINAPI
ICM_FreeOssIssuerAndSerialNumber(
    IN OUT IssuerAndSerialNumber *pOssIssuerAndSerialNumber
    )
{
    ICM_FreeOssAny(&pOssIssuerAndSerialNumber->issuer);
    ICM_FreeOssHugeInteger(&pOssIssuerAndSerialNumber->serialNumber);
}

BOOL
WINAPI
ICM_SetOssIssuerAndSerialNumber(
    IN PCERT_ISSUER_SERIAL_NUMBER pIssuerAndSerialNumber,
    IN OUT IssuerAndSerialNumber *pOssIssuerAndSerialNumber
    )
{
    BOOL fRet;

    if (!ICM_SetOssAny(&pIssuerAndSerialNumber->Issuer,
            &pOssIssuerAndSerialNumber->issuer))
        goto SetOssAnyError;

    if (!ICM_SetOssHugeInteger(&pIssuerAndSerialNumber->SerialNumber,
            &pOssIssuerAndSerialNumber->serialNumber))
        goto SetOssHugeIntegerError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_FreeOssIssuerAndSerialNumber(pOssIssuerAndSerialNumber);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SetOssAnyError)
TRACE_ERROR(SetOssHugeIntegerError)
}



BOOL
WINAPI
ICM_SetOssCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT CertIdentifier *pOssCertId
    )
{
    BOOL fRet;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (!ICM_SetOssIssuerAndSerialNumber(
                    &pCertId->IssuerSerialNumber,
                    &pOssCertId->u.issuerAndSerialNumber
                    ))
                goto SetOssIssuerAndSerialNumberError;
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!ICM_SetOssOctetString(
                    &pCertId->KeyId,
                    &pOssCertId->u.subjectKeyIdentifier
                    ))
                goto SetOssOctetStringError;
            break;
        default:
            goto InvalidIdChoice;
    }

    assert(CERT_ID_ISSUER_SERIAL_NUMBER == issuerAndSerialNumber_chosen);
    assert(CERT_ID_KEY_IDENTIFIER == subjectKeyIdentifier_chosen);

    pOssCertId->choice = (unsigned short) pCertId->dwIdChoice;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
SET_ERROR(InvalidIdChoice, E_INVALIDARG)
}

void
WINAPI
ICM_FreeOssCertIdentifier(
    IN OUT CertIdentifier *pOssCertId
    )
{
    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_FreeOssIssuerAndSerialNumber(
                &pOssCertId->u.issuerAndSerialNumber);
            break;
        case subjectKeyIdentifier_chosen:
            ICM_FreeOssOctetString(&pOssCertId->u.subjectKeyIdentifier);
            break;
        default:
            break;
    }
    pOssCertId->choice = 0;
}

void
WINAPI
ICM_FreeOssOriginatorCertIdentifierOrKey(
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    switch (pOssOriginator->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_FreeOssIssuerAndSerialNumber(
                &pOssOriginator->u.issuerAndSerialNumber);
            break;
        case subjectKeyIdentifier_chosen:
            ICM_FreeOssOctetString(
                &pOssOriginator->u.subjectKeyIdentifier);
            break;
        case originatorKey_chosen:
            ICM_FreeOssAlgorithmIdentifier(
                &pOssOriginator->u.originatorKey.algorithm);
            ICM_FreeOssBitString(
                &pOssOriginator->u.originatorKey.publicKey);
            break;
        default:
            break;
    }
    pOssOriginator->choice = 0;
}

BOOL
WINAPI
ICM_SetOssOriginatorCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    BOOL fRet;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (!ICM_SetOssIssuerAndSerialNumber(
                    &pCertId->IssuerSerialNumber,
                    &pOssOriginator->u.issuerAndSerialNumber
                    ))
                goto SetOssIssuerAndSerialNumberError;
            pOssOriginator->choice = issuerAndSerialNumber_chosen;
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!ICM_SetOssOctetString(
                    &pCertId->KeyId,
                    &pOssOriginator->u.subjectKeyIdentifier
                    ))
                goto SetOssOctetStringError;
            pOssOriginator->choice = subjectKeyIdentifier_chosen;
            break;
        default:
            goto InvalidIdChoice;
    }


    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
SET_ERROR(InvalidIdChoice, E_INVALIDARG)
}

BOOL
WINAPI
ICM_SetOssOriginatorPublicKey(
    IN PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    BOOL fRet;
    PCRYPT_ALGORITHM_IDENTIFIER pai = &pPublicKeyInfo->Algorithm;
    AlgorithmIdentifier *pOssAlgId = &pOssOriginator->u.originatorKey.algorithm;

    pOssOriginator->choice = originatorKey_chosen;
    if (!ICM_SetOssAlgorithmIdentifier(
            pai,
            pOssAlgId
            ))
        goto SetOssAlgorithmIdentifierError;

    if (0 == pai->Parameters.cbData) {
        DWORD dwFlags;
        PCCRYPT_OID_INFO pOIDInfo;

        dwFlags = 0;
        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pai->pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
            if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
                DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
                dwFlags = pdwExtra[0];
            }
        }

        if (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG) {
            // NO NULL parameters

            pOssAlgId->bit_mask &= ~parameters_present;
            pOssAlgId->parameters.length = 0;
            pOssAlgId->parameters.value = NULL;
        }
    }

    if (!ICM_SetOssBitString(
            &pPublicKeyInfo->PublicKey,
            &pOssOriginator->u.originatorKey.publicKey
            ))
        goto SetOssBitStringError;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    ICM_FreeOssOriginatorCertIdentifierOrKey(pOssOriginator);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssAlgorithmIdentifierError)
TRACE_ERROR(SetOssBitStringError)
}

//+-------------------------------------------------------------------------
//  Free the Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssKeyTransRecipientInfo(
    IN OUT KeyTransRecipientInfo *pori
    )
{
    ICM_FreeOssCertIdentifier(&pori->rid);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);
    ICM_Free(pori->encryptedKey.value);
    pori->encryptedKey.value = NULL;
}

//+-------------------------------------------------------------------------
//  Fill the Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssKeyTransRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT KeyTransRecipientInfo *pori,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    )
{
    BOOL fRet;
    CMSG_KEY_TRANS_ENCRYPT_INFO KeyTransEncryptInfo;

    memset(&KeyTransEncryptInfo, 0, sizeof(KeyTransEncryptInfo));
    KeyTransEncryptInfo.cbSize = sizeof(KeyTransEncryptInfo);
    KeyTransEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    KeyTransEncryptInfo.KeyEncryptionAlgorithm =
        pKeyTransEncodeInfo->KeyEncryptionAlgorithm;
    // KeyTransEncryptInfo.EncryptedKey =
    // KeyTransEncryptInfo.dwFlags =

    if (!ICM_ExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            &KeyTransEncryptInfo
            ))
        goto ExportKeyTransError;
    pori->encryptedKey.length = KeyTransEncryptInfo.EncryptedKey.cbData;
    pori->encryptedKey.value = KeyTransEncryptInfo.EncryptedKey.pbData;

    if (CERT_ID_ISSUER_SERIAL_NUMBER ==
            pKeyTransEncodeInfo->RecipientId.dwIdChoice)
        pori->version = CMSG_KEY_TRANS_PKCS_1_5_VERSION;
    else {
        pori->version = CMSG_KEY_TRANS_CMS_VERSION;
        *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
    }

    if (!ICM_SetOssCertIdentifier(
            &pKeyTransEncodeInfo->RecipientId,
            &pori->rid
            ))
        goto SetOssCertIdentifierError;

    if (!ICM_SetOssAlgorithmIdentifier(
            &KeyTransEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    if (KeyTransEncryptInfo.dwFlags & CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(KeyTransEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    return fRet;

ErrorReturn:
    ICM_FreeOssKeyTransRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportKeyTransError)
TRACE_ERROR(SetOssCertIdentifierError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
}


//+-------------------------------------------------------------------------
//  Free the Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssKeyAgreeRecipientInfo(
    IN OUT KeyAgreeRecipientInfo *pori
    )
{
    RecipientEncryptedKey *porek;
    unsigned int count;

    ICM_FreeOssOriginatorCertIdentifierOrKey(&pori->originator);
    ICM_FreeOssOctetString(&pori->ukm);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);

    porek = pori->recipientEncryptedKeys.value;
    if (NULL == porek)
        return;

    for (count = pori->recipientEncryptedKeys.count;
                                                0 < count; count--, porek++) {
        switch (porek->rid.choice) {
            case issuerAndSerialNumber_chosen:
                ICM_FreeOssIssuerAndSerialNumber(
                    &porek->rid.u.issuerAndSerialNumber);
                break;
            case rKeyId_chosen:
                ICM_FreeOssOctetString(
                    &porek->rid.u.rKeyId.subjectKeyIdentifier);
                ICM_FreeOssOtherKeyAttribute(&porek->rid.u.rKeyId.other);
                break;
        }

        ICM_Free(porek->encryptedKey.value);
        porek->encryptedKey.value = NULL;
    }

    ICM_Free(pori->recipientEncryptedKeys.value);
}


//+-------------------------------------------------------------------------
//  Fill the Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssKeyAgreeRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT KeyAgreeRecipientInfo *pori
    )
{
    BOOL fRet;
    DWORD i;
    CMSG_KEY_AGREE_ENCRYPT_INFO KeyAgreeEncryptInfo;
    DWORD cKeyAgreeKeyEncryptInfo;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *rgpKeyAgreeKeyEncryptInfo = NULL;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO pKeyAgreeKeyEncryptInfo;

    RecipientEncryptedKey *porek;

    memset(&KeyAgreeEncryptInfo, 0, sizeof(KeyAgreeEncryptInfo));
    KeyAgreeEncryptInfo.cbSize = sizeof(KeyAgreeEncryptInfo);
    KeyAgreeEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    KeyAgreeEncryptInfo.KeyEncryptionAlgorithm =
        pKeyAgreeEncodeInfo->KeyEncryptionAlgorithm;
    KeyAgreeEncryptInfo.UserKeyingMaterial =
        pKeyAgreeEncodeInfo->UserKeyingMaterial;
    // KeyAgreeEncryptInfo.dwOriginatorChoice =
    // union
    //    KeyAgreeEncryptInfo.OriginatorCertId =
    //    KeyAgreeEncryptInfo.OriginatorPublicKeyInfo =
    // KeyAgreeEncryptInfo.cKeyAgreeKeyEncryptInfo =
    // KeyAgreeEncryptInfo.rgpKeyAgreeKeyEncryptInfo =
    // KeyAgreeEncryptInfo.dwFlags =

    cKeyAgreeKeyEncryptInfo = pKeyAgreeEncodeInfo->cRecipientEncryptedKeys;
    if (0 == cKeyAgreeKeyEncryptInfo)
        goto NoKeyAgreeKeys;

    if (NULL == (pori->recipientEncryptedKeys.value =
            (RecipientEncryptedKey *) ICM_AllocZero(
                cKeyAgreeKeyEncryptInfo * sizeof(RecipientEncryptedKey))))
        goto OutOfMemory;
    pori->recipientEncryptedKeys.count = cKeyAgreeKeyEncryptInfo;

    if (NULL == (rgpKeyAgreeKeyEncryptInfo =
            (PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *) ICM_AllocZero(
                cKeyAgreeKeyEncryptInfo *
                    sizeof(PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO) +
                cKeyAgreeKeyEncryptInfo *
                    sizeof(CMSG_KEY_AGREE_KEY_ENCRYPT_INFO))))
        goto OutOfMemory;

    pKeyAgreeKeyEncryptInfo =
        PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO (((PBYTE) rgpKeyAgreeKeyEncryptInfo) +
            cKeyAgreeKeyEncryptInfo * sizeof(PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO));
    for (i = 0; i < cKeyAgreeKeyEncryptInfo; i++, pKeyAgreeKeyEncryptInfo++) {
        rgpKeyAgreeKeyEncryptInfo[i] = pKeyAgreeKeyEncryptInfo;
        pKeyAgreeKeyEncryptInfo->cbSize =
            sizeof(CMSG_KEY_AGREE_KEY_ENCRYPT_INFO);
    }

    KeyAgreeEncryptInfo.cKeyAgreeKeyEncryptInfo = cKeyAgreeKeyEncryptInfo;
    KeyAgreeEncryptInfo.rgpKeyAgreeKeyEncryptInfo = rgpKeyAgreeKeyEncryptInfo;

    if (!ICM_ExportKeyAgree(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            &KeyAgreeEncryptInfo
            ))
        goto ExportKeyAgreeError;

    for (i = 0, porek = pori->recipientEncryptedKeys.value;
                                 i < cKeyAgreeKeyEncryptInfo; i++, porek++) {
        porek->encryptedKey.length =
            rgpKeyAgreeKeyEncryptInfo[i]->EncryptedKey.cbData;
        porek->encryptedKey.value =
            rgpKeyAgreeKeyEncryptInfo[i]->EncryptedKey.pbData;
    }

    pori->version = CMSG_KEY_AGREE_VERSION;

    switch (KeyAgreeEncryptInfo.dwOriginatorChoice) {
        case CMSG_KEY_AGREE_ORIGINATOR_CERT:
            if (!ICM_SetOssOriginatorCertIdentifier(
                    &KeyAgreeEncryptInfo.OriginatorCertId,
                    &pori->originator
                    ))
                goto SetOssOriginatorCertIdentifierError;
            break;
        case CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY:
            if (!ICM_SetOssOriginatorPublicKey(
                    &KeyAgreeEncryptInfo.OriginatorPublicKeyInfo,
                    &pori->originator
                    ))
                goto SetOssOriginatorPublicKeyError;
            break;
        default:
            goto InvalidOriginatorChoice;
    }

    if (KeyAgreeEncryptInfo.UserKeyingMaterial.cbData) {
        if (!ICM_SetOssOctetString(
                &KeyAgreeEncryptInfo.UserKeyingMaterial,
                &pori->ukm
                ))
            goto SetOssUserKeyingMaterialError;
        pori->bit_mask |= ukm_present;
    }

    if (!ICM_SetOssAlgorithmIdentifier(
            &KeyAgreeEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    for (i = 0, porek = pori->recipientEncryptedKeys.value;
                                 i < cKeyAgreeKeyEncryptInfo; i++, porek++) {
        PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKeyEncodeInfo =
            pKeyAgreeEncodeInfo->rgpRecipientEncryptedKeys[i];
            

        switch (pEncryptedKeyEncodeInfo->RecipientId.dwIdChoice) {
            case CERT_ID_ISSUER_SERIAL_NUMBER:
                if (!ICM_SetOssIssuerAndSerialNumber(
                        &pEncryptedKeyEncodeInfo->RecipientId.IssuerSerialNumber,
                        &porek->rid.u.issuerAndSerialNumber
                        ))
                    goto SetOssIssuerAndSerialNumberError;
                porek->rid.choice = issuerAndSerialNumber_chosen;
                break;
            case CERT_ID_KEY_IDENTIFIER:
                if (!ICM_SetOssOctetString(
                        &pEncryptedKeyEncodeInfo->RecipientId.KeyId,
                        &porek->rid.u.rKeyId.subjectKeyIdentifier
                        ))
                    goto SetOssOctetStringError;
                porek->rid.choice = rKeyId_chosen;

                if (pEncryptedKeyEncodeInfo->Date.dwLowDateTime ||
                        pEncryptedKeyEncodeInfo->Date.dwHighDateTime) {
                    if (!PkiAsn1ToGeneralizedTime(
                            &pEncryptedKeyEncodeInfo->Date,
                            &porek->rid.u.rKeyId.date
                            ))
                        goto ConvToGeneralizedTimeError;
                    porek->rid.u.rKeyId.bit_mask |= date_present;
                }

                if (pEncryptedKeyEncodeInfo->pOtherAttr) {
                    if (!ICM_SetOssOtherKeyAttribute(
                            pEncryptedKeyEncodeInfo->pOtherAttr,
                            &porek->rid.u.rKeyId.other
                            ))
                        goto SetOssOtherKeyAttributeError;
                    porek->rid.u.rKeyId.bit_mask |= other_present;
                }
                break;
            default:
                goto InvalidRecipientIdChoice;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_Free(rgpKeyAgreeKeyEncryptInfo);

    if (KeyAgreeEncryptInfo.dwFlags & CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    if (KeyAgreeEncryptInfo.dwFlags &
            CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.UserKeyingMaterial.pbData);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG)
        ICM_Free(
            KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.Algorithm.pszObjId);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG)
        ICM_Free(
            KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.Algorithm.Parameters.pbData);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.PublicKey.pbData);

    return fRet;

ErrorReturn:
    ICM_FreeOssKeyAgreeRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidOriginatorChoice, E_INVALIDARG)
SET_ERROR(NoKeyAgreeKeys, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ExportKeyAgreeError)
TRACE_ERROR(SetOssOriginatorCertIdentifierError)
TRACE_ERROR(SetOssOriginatorPublicKeyError)
TRACE_ERROR(SetOssUserKeyingMaterialError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
TRACE_ERROR(ConvToGeneralizedTimeError)
TRACE_ERROR(SetOssOtherKeyAttributeError)
SET_ERROR(InvalidRecipientIdChoice, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Free the Oss MailListRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssMailListRecipientInfo(
    IN OUT MailListRecipientInfo *pori
    )
{
    ICM_FreeOssOctetString(&pori->mlid.kekIdentifier);
    ICM_FreeOssOtherKeyAttribute(&pori->mlid.other);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);
    ICM_Free(pori->encryptedKey.value);
    pori->encryptedKey.value = NULL;
}

//+-------------------------------------------------------------------------
//  Fill the Oss MailListRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssMailListRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT MailListRecipientInfo *pori
    )
{
    BOOL fRet;
    CMSG_MAIL_LIST_ENCRYPT_INFO MailListEncryptInfo;

    memset(&MailListEncryptInfo, 0, sizeof(MailListEncryptInfo));
    MailListEncryptInfo.cbSize = sizeof(MailListEncryptInfo);
    MailListEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    MailListEncryptInfo.KeyEncryptionAlgorithm =
        pMailListEncodeInfo->KeyEncryptionAlgorithm;
    // MailListEncryptInfo.EncryptedKey =
    // MailListEncryptInfo.dwFlags =

    if (!ICM_ExportMailList(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            &MailListEncryptInfo
            ))
        goto ExportMailListError;
    pori->encryptedKey.length = MailListEncryptInfo.EncryptedKey.cbData;
    pori->encryptedKey.value = MailListEncryptInfo.EncryptedKey.pbData;

    pori->version = CMSG_MAIL_LIST_VERSION;

    if (!ICM_SetOssOctetString(
            &pMailListEncodeInfo->KeyId,
            &pori->mlid.kekIdentifier
            ))
        goto SetOssOctetStringError;

    if (pMailListEncodeInfo->Date.dwLowDateTime ||
            pMailListEncodeInfo->Date.dwHighDateTime) {
        if (!PkiAsn1ToGeneralizedTime(
                &pMailListEncodeInfo->Date,
                &pori->mlid.date
                ))
            goto ConvToGeneralizedTimeError;
        pori->mlid.bit_mask |= date_present;
    }

    if (pMailListEncodeInfo->pOtherAttr) {
        if (!ICM_SetOssOtherKeyAttribute(
                pMailListEncodeInfo->pOtherAttr,
                &pori->mlid.other
                ))
            goto SetOssOtherKeyAttributeError;
        pori->mlid.bit_mask |= other_present;
    }

    if (!ICM_SetOssAlgorithmIdentifier(
            &MailListEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    if (MailListEncryptInfo.dwFlags & CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(MailListEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    return fRet;

ErrorReturn:
    ICM_FreeOssMailListRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportMailListError)
TRACE_ERROR(SetOssOctetStringError)
TRACE_ERROR(ConvToGeneralizedTimeError)
TRACE_ERROR(SetOssOtherKeyAttributeError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
}

//+-------------------------------------------------------------------------
//  Free the Oss CmsRecipientInfos
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssCmsRecipientInfos(
    IN OUT CmsRecipientInfos *poris
    )
{
    DWORD i;
    CmsRecipientInfo *pori;

    if (NULL == poris->value)
        return;

    for (i = 0, pori = poris->value; i < poris->count; i++, pori++) {
        switch (pori->choice) {
            case keyTransRecipientInfo_chosen:
                ICM_FreeOssKeyTransRecipientInfo(
                    &pori->u.keyTransRecipientInfo);
                break;
            case keyAgreeRecipientInfo_chosen:
                ICM_FreeOssKeyAgreeRecipientInfo(
                    &pori->u.keyAgreeRecipientInfo);
                break;
            case mailListRecipientInfo_chosen:
                ICM_FreeOssMailListRecipientInfo(
                    &pori->u.mailListRecipientInfo);
                break;
            case 0:
            default:
                break;
        }
    }

    ICM_Free(poris->value);
    poris->value = NULL;
}


//+-------------------------------------------------------------------------
//  Fill the Oss CmsRecipientInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssCmsRecipientInfos(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT CmsRecipientInfos *poris,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    )
{
    BOOL fRet;
    DWORD cRecipients;
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
    CmsRecipientInfo *pori = NULL;
    DWORD i;

    cRecipients = pContentEncryptInfo->cRecipients;
    if (0 == cRecipients)
        goto SuccessReturn;
    rgCmsRecipients = pContentEncryptInfo->rgCmsRecipients;
    assert(cRecipients && rgCmsRecipients);

    if (NULL == (poris->value = (CmsRecipientInfo *) ICM_AllocZero(
            cRecipients * sizeof(CmsRecipientInfo))))
        goto OutOfMemory;
    poris->count = cRecipients;

    for (i = 0, pori = poris->value; i < cRecipients; i++, pori++) {
        switch (rgCmsRecipients[i].dwRecipientChoice) {
            case CMSG_KEY_TRANS_RECIPIENT:
                if (!ICM_FillOssKeyTransRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pKeyTrans,
                        i,
                        &pori->u.keyTransRecipientInfo,
                        pEnvelopedDataVersion
                        ))
                    goto FillOssKeyTransRecipientInfoError;
                pori->choice = keyTransRecipientInfo_chosen;
                break;
            case CMSG_KEY_AGREE_RECIPIENT:
                if (!ICM_FillOssKeyAgreeRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pKeyAgree,
                        i,
                        &pori->u.keyAgreeRecipientInfo
                        ))
                    goto FillOssKeyAgreeRecipientInfoError;
                pori->choice = keyAgreeRecipientInfo_chosen;
                *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
                break;
            case CMSG_MAIL_LIST_RECIPIENT:
                if (!ICM_FillOssMailListRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pMailList,
                        i,
                        &pori->u.mailListRecipientInfo
                        ))
                    goto FillOssMailLIstRecipientInfoError;
                pori->choice = mailListRecipientInfo_chosen;
                *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
                break;
            default:
                goto InvalidRecipientChoice;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_FreeOssCmsRecipientInfos(poris);

    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FillOssKeyTransRecipientInfoError)
TRACE_ERROR(FillOssKeyAgreeRecipientInfoError)
TRACE_ERROR(FillOssMailLIstRecipientInfoError)
SET_ERROR(InvalidRecipientChoice, E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Open an enveloped message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_ENVELOPED_ENCODE_INFO pemei =
        (PCMSG_ENVELOPED_ENCODE_INFO) pvMsgEncodeInfo;
    CmsEnvelopedData            *ped = NULL;
    EncryptedContentInfo        *peci;

    CMSG_CONTENT_ENCRYPT_INFO   ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);

    DWORD                       i;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       cbCert = 0;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    DWORD                       cbOriginatorInfo;
    DWORD                       cUnprotectedAttr;

    assert(pemei->cbSize >= STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO,
        rgpRecipients));
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients))
        goto InvalidArg;

    if (pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO)) {
        for (i=pemei->cCertEncoded, pcert=pemei->rgCertEncoded, cbCert=0;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;

        for (i=pemei->cAttrCertEncoded, pcert=pemei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;

        for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, cbCrl=0;
                i>0;
                i--, pcrl++)
            cbCrl += pcrl->cbData;

        cbOriginatorInfo =
                pemei->cCertEncoded * sizeof(Certificate) +
                pemei->cAttrCertEncoded * sizeof(Certificate) +
                pemei->cCrlEncoded * sizeof(CertificateRevocationList) +
                cbCert + cbCrl;

        cUnprotectedAttr = pemei->cUnprotectedAttr;
    } else {
        cbOriginatorInfo = 0;
        cUnprotectedAttr = 0;
    }

    ped = (CmsEnvelopedData *)ICM_AllocZero(
            sizeof(CmsEnvelopedData) + cbOriginatorInfo);
    if (NULL == ped)
        goto CmsEnvelopedDataAllocError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero(sizeof(CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto PcmiAllocError;

    // pcmi->hCryptProv
    // pcmi->fDefaultCryptProv
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = ped;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    // version
    if (0 < cbOriginatorInfo || 0 < cUnprotectedAttr)
        ped->version = CMSG_ENVELOPED_DATA_CMS_VERSION;
    else
        ped->version = CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION;

    if (0 < cbOriginatorInfo) {
        OriginatorInfo *poi = &ped->originatorInfo;

        // originatorInfo
        ped->bit_mask |= originatorInfo_present;

        // certificates
        if (0 != pemei->cCertEncoded || 0 != pemei->cAttrCertEncoded) {
            poi->bit_mask |= certificates_present;
            poi->certificates.count = pemei->cCertEncoded +
                pemei->cAttrCertEncoded;
#ifdef OSS_CRYPT_ASN1
            poi->certificates.certificates = (Certificate *)(ped + 1);
#else
            poi->certificates.value = (Certificate *)(ped + 1);
#endif  // OSS_CRYPT_ASN1
            pbCert = (PBYTE)ped +
                    sizeof( CmsEnvelopedData) +
                    pemei->cCertEncoded * sizeof( Certificate) +
                    pemei->cAttrCertEncoded * sizeof( Certificate) +
                    pemei->cCrlEncoded * sizeof( CertificateRevocationList);
            for (i=pemei->cCertEncoded, pcert=pemei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                        pOssCert=poi->certificates.certificates;
#else
                        pOssCert=poi->certificates.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pcert++, pOssCert++) {
                pOssCert->length = pcert->cbData;
                memcpy( pbCert, pcert->pbData, pcert->cbData);
                pOssCert->value = pbCert;
                pbCert += pcert->cbData;
            }

            for (i=pemei->cAttrCertEncoded, pcert=pemei->rgAttrCertEncoded;
                    i>0;
                    i--, pcert++, pOssCert++) {
                pOssCert->length = pcert->cbData;
                memcpy( pbCert, pcert->pbData, pcert->cbData);
                if (pcert->cbData)
                    // Change tag from SEQUENCE to [1] IMPLICIT
                    *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
                pOssCert->value = pbCert;
                pbCert += pcert->cbData;
            }
        }

        // crls
        if (0 != pemei->cCrlEncoded) {
            poi->bit_mask |= crls_present;
            poi->crls.count = pemei->cCrlEncoded;
            if (0 != pemei->cCertEncoded || 0 != pemei->cAttrCertEncoded)
#ifdef OSS_CRYPT_ASN1
                poi->crls.crls  = (CertificateRevocationList *)
                    (poi->certificates.certificates +
#else
                poi->crls.value  = (CertificateRevocationList *)
                    (poi->certificates.value +
#endif  // OSS_CRYPT_ASN1
                        (pemei->cCertEncoded + pemei->cAttrCertEncoded));
            else
#ifdef OSS_CRYPT_ASN1
                poi->crls.crls  = (CertificateRevocationList *) (ped + 1);
#else
                poi->crls.value  = (CertificateRevocationList *) (ped + 1);
#endif  // OSS_CRYPT_ASN1
            pbCrl = (PBYTE)ped +
                    sizeof( CmsEnvelopedData) +
                    pemei->cCertEncoded * sizeof( Certificate) +
                    pemei->cAttrCertEncoded * sizeof( Certificate) +
                    pemei->cCrlEncoded * sizeof( CertificateRevocationList) +
                    cbCert;
#ifdef OSS_CRYPT_ASN1
            for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, pOssCrl=poi->crls.crls;
#else
            for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, pOssCrl=poi->crls.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pcrl++, pOssCrl++) {
                pOssCrl->length = pcrl->cbData;
                memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
                pOssCrl->value = pbCrl;
                pbCrl += pcrl->cbData;
            }
        }
    }

    if (0 < cUnprotectedAttr) {
        Attribute *poatr;
        PCRYPT_ATTRIBUTE patr;

        if (NULL == (poatr = (Attribute *) ICM_AllocZero(
                cUnprotectedAttr * sizeof(Attribute))))
            goto UnprotectedAttrsAllocError;
        ped->unprotectedAttrs.value = poatr;
        ped->unprotectedAttrs.count = cUnprotectedAttr;
        ped->bit_mask |= unprotectedAttrs_present;

        for (i=cUnprotectedAttr, patr=pemei->rgUnprotectedAttr;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute(patr, poatr))
                goto Asn1ToAttributeError;
        }
    }


    if (!ICM_InitializeContentEncryptInfo(pemei, &ContentEncryptInfo))
        goto InitializeContentEncryptInfoError;
//    assert(ContentEncryptInfo.hCryptProv);
    pcmi->hCryptProv = ContentEncryptInfo.hCryptProv;
    assert(ContentEncryptInfo.hContentEncryptKey);
    pcmi->hkeyContentCrypt = ContentEncryptInfo.hContentEncryptKey;

    if (pStreamInfo && CMSG_INDEFINITE_LENGTH != pStreamInfo->cbContent)
        ContentEncryptInfo.dwEncryptFlags |=
            CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG;

    if (!ICM_FillOssCmsRecipientInfos(
            &ContentEncryptInfo,
            &ped->recipientInfos,
            &ped->version
            ))
        goto FillOssCmsRecipientInfosError;

    // Is encryptedContent encapsulated ???
    if (ped->version > CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION) {
        if (ICM_IsData(pszInnerContentObjID))
            pcmi->dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            pcmi->dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            pcmi->dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            ped->version = CMSG_ENVELOPED_DATA_CMS_VERSION;
    }

    // encryptedContentInfo
    // (.encryptedContent filled in during update)
    peci = &ped->encryptedContentInfo;
    peci->bit_mask = encryptedContent_present;
    peci->contentType.count =
        sizeof(peci->contentType.value)/sizeof(peci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &peci->contentType.count,
            peci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &ContentEncryptInfo.ContentEncryptionAlgorithm,
            &peci->contentEncryptionAlgorithm))
        goto MsgAsn1ToAlgorithmIdentifierError;

    if (pStreamInfo && !ICMS_OpenToEncodeEnvelopedData( pcmi, pemei))
        goto StreamOpenToEncodeEnvelopedDataError;

    // From here to CommonReturn, NO Errors
    if (ContentEncryptInfo.hCryptProv == pemei->hCryptProv) {
//        assert(ContentEncryptInfo.hCryptProv);
        assert(0 == (ContentEncryptInfo.dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG));
    } else {
        if (pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) {
            pcmi->dwFlags &= ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
            CryptReleaseContext(pemei->hCryptProv, 0);
        }
    }

    if (ContentEncryptInfo.dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG) {
        pcmi->dwFlags |= CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
        ContentEncryptInfo.dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG;
    }

    ContentEncryptInfo.hContentEncryptKey = 0;

CommonReturn:
    ICM_FreeContentEncryptInfo(pemei, &ContentEncryptInfo);
    ICM_SetLastError(dwError);
    return (HCRYPTMSG) pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (ped) {
        ICM_FreeOssCmsRecipientInfos(&ped->recipientInfos);

        if (ped->unprotectedAttrs.value) {
            Attribute *poatr;

            for (i=ped->unprotectedAttrs.count,
                    poatr=ped->unprotectedAttrs.value;
                    i>0;
                    i--, poatr++) {
                ICM_Free(poatr->attributeValue.value);
            }
            ICM_Free(ped->unprotectedAttrs.value);
        }

        ICM_Free(ped);
    }
    if (pcmi) {
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free(pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(DupInnerContentObjIDError)
TRACE_ERROR(DupStreamInfoError)
TRACE_ERROR(CmsEnvelopedDataAllocError)
TRACE_ERROR(PcmiAllocError)
TRACE_ERROR(UnprotectedAttrsAllocError)
TRACE_ERROR(Asn1ToAttributeError)
TRACE_ERROR(InitializeContentEncryptInfoError)
TRACE_ERROR(FillOssCmsRecipientInfosError)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)
TRACE_ERROR(StreamOpenToEncodeEnvelopedDataError)
}
#else

//+-------------------------------------------------------------------------
//  Default export of the encryption key
//
//  Note, pcbData[1] contains dwEncryptFlags, where,
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG may be set to disable the reversing
//  of the encoded, encrypted symmetric key.
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL            fRet;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    PBYTE           pb = NULL;
    DWORD           cb;

    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            NULL,
            &cb))
        goto ExportKeySizeError;
    if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
        goto ExportKeyAllocError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            pb,
            &cb))
        goto ExportKeyError;
    assert( cb > (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)));
    cb -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    fRet = TRUE;
    if (pbData) {
        if (rgcbData[0] < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else if (0 < cb) {
            if (rgcbData[1] & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)
                // Don't byte reverse
                memcpy(pbData,
                    pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
                    cb);
            else
                ICM_ReverseCopy(pbData,
                    pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
                    cb);
        }
    }

CommonReturn:
    rgcbData[0] = cb;
    ICM_FreeA(pb);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    cb = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(ExportKeySizeError)
TRACE_ERROR(ExportKeyAllocError)
TRACE_ERROR(ExportKeyError)
}

//+-------------------------------------------------------------------------
//  Export of the encryption key
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_GenEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pPublicKeyInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            pbData,
            rgcbData);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultExportEncryptKey(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            pbData,
            rgcbData);
    return fResult;
}

// This size is good up through a 2048 bit exchange key
#define EXPORT_ENCRYPT_KEY_LENGTH   256

//+-------------------------------------------------------------------------
//  Fill the RecipientInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillRecipientInfos(
    IN HCRYPTPROV           hCryptProv,
    IN HCRYPTKEY            hKeyContent,
    IN DWORD                cRecipients,
    IN PCERT_INFO           *rgpRecipients,
    IN OUT RecipientInfos   *pris,
    IN DWORD                dwEncryptFlags)
{
    BOOL            fRet;
    PCERT_INFO      *ppci;
    RecipientInfo   *pri;
    PBYTE           pb = NULL;
    DWORD           rgcb[2];        // rgcb[1] is updated with dwEncryptFlags
    DWORD           cTryAgain;
    DWORD           i;
    PBYTE           pbSerialNumber;
    DWORD           cbSerialNumber = 0;

    for (i=cRecipients, ppci=rgpRecipients; i>0; i--, ppci++)
        cbSerialNumber += (*ppci)->SerialNumber.cbData;
    pris->value = (RecipientInfo *)ICM_AllocZero(
                cRecipients * sizeof( RecipientInfo) +
                cbSerialNumber);
    if (NULL == pris->value)
        goto RecipientInfoAllocError;
    pris->count = cRecipients;
    pbSerialNumber = (PBYTE)(pris->value + cRecipients);

    for (i=cRecipients, ppci=rgpRecipients, pri=pris->value;
            i>0;
            i--, ppci++, pri++) {
        // version
        pri->version = 0;

        // issuerAndSerialNumber
        pri->issuerAndSerialNumber.issuer.length = (*ppci)->Issuer.cbData;
        pri->issuerAndSerialNumber.issuer.value = (*ppci)->Issuer.pbData;
        pri->issuerAndSerialNumber.serialNumber.length = (*ppci)->SerialNumber.cbData;
        pb = pbSerialNumber;
        pbSerialNumber += (*ppci)->SerialNumber.cbData;
        ICM_ReverseCopy(
            pb,
            (*ppci)->SerialNumber.pbData,
            (*ppci)->SerialNumber.cbData);
        pri->issuerAndSerialNumber.serialNumber.value = pb;

        // keyEncryptionAlgorithm
        if (!ICM_Asn1ToAlgorithmIdentifier(
                &(*ppci)->SubjectPublicKeyInfo.Algorithm,
                &pri->keyEncryptionAlgorithm))
            goto Asn1ToAlgorithmIdentifierError;

        rgcb[0] = EXPORT_ENCRYPT_KEY_LENGTH;
        rgcb[1] = dwEncryptFlags;
        cTryAgain = 1;
        while (TRUE) {
            if (NULL == (pb = (PBYTE)ICM_Alloc(rgcb[0])))
                goto ExportKeyAllocError;
            if (ICM_ExportEncryptKey(
                    hCryptProv,
                    hKeyContent,
                    &(*ppci)->SubjectPublicKeyInfo,
                    pb,
                    rgcb))
                break;
            ICM_Free(pb);
            if (rgcb[0] && cTryAgain--)
                continue;
            else
                goto ExportKeyError;
        }

        pri->encryptedKey.length = rgcb[0];
        pri->encryptedKey.value = pb;
        pb = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
// Need to free EncrytedKey for each recipient
    ICM_Free( pris->value);

    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(RecipientInfoAllocError)
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)
TRACE_ERROR(ExportKeyAllocError)
TRACE_ERROR(ExportKeyError)
}


//+-------------------------------------------------------------------------
//  Open an enveloped message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_ENVELOPED_ENCODE_INFO pemei = (PCMSG_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo;
    EnvelopedData               *ped = NULL;
    EncryptedContentInfo        *peci;
    DWORD                       dwAlgoCAPI;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    PBYTE                       pbEncryptParameters = NULL;

    // rgcbEncryptParameters[1] contains dwEncryptFlags
    DWORD                       rgcbEncryptParameters[2];

    assert( pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO));
    assert( 0 != pemei->cRecipients);
    if (pemei->cbSize < sizeof(CMSG_ENVELOPED_ENCODE_INFO) ||
            0 == pemei->cRecipients)
        goto InvalidArg;

    ped = (EnvelopedData *)ICM_AllocZero( sizeof( EnvelopedData));
    if (NULL == ped)
        goto EnvelopedDataAllocError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto PcmiAllocError;

    pcmi->hCryptProv = pemei->hCryptProv;
    if (0 == pcmi->hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = ped;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    // version
    ped->version = 0;

    // recipientInfos
    // Use first recipients public key info
    ContentEncryptionAlgorithm = pemei->ContentEncryptionAlgorithm;
    rgcbEncryptParameters[0] = 0;
    rgcbEncryptParameters[1] = 0;
    if (!ICM_GenEncryptKey(
            &pcmi->hCryptProv,
            &ContentEncryptionAlgorithm,
            pemei->pvEncryptionAuxInfo,
            &pemei->rgpRecipients[0]->SubjectPublicKeyInfo,
            ICM_Alloc,
            &pcmi->hkeyContentCrypt,    // not freed for an error
            &pbEncryptParameters,
            rgcbEncryptParameters))
        goto GenKeyError;
    if (rgcbEncryptParameters[0] && pbEncryptParameters) {
        pcmi->pbEncryptParameters = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.pbData = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.cbData = rgcbEncryptParameters[0];
    } else if (pbEncryptParameters) {
        ICM_Free(pbEncryptParameters);
        pbEncryptParameters = NULL;
    }

    if (!ICM_FillRecipientInfos(
                pcmi->hCryptProv,
                pcmi->hkeyContentCrypt,
                pemei->cRecipients,
                pemei->rgpRecipients,
                &ped->recipientInfos,
                rgcbEncryptParameters[1]))      // dwEncryptFlags
        goto FillRecipientInfosError;

    // encryptedContentInfo
    // (.encryptedContent filled in during update)
    peci = &ped->encryptedContentInfo;
    peci->bit_mask = encryptedContent_present;
    peci->contentType.count = sizeof(peci->contentType.value)/sizeof(peci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &peci->contentType.count,
            peci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (!ICM_Asn1ToAlgorithmIdentifier(
            &ContentEncryptionAlgorithm,
            &peci->contentEncryptionAlgorithm))
        goto Asn1ToAlgorithmIdentifierError;

    if (pStreamInfo && !ICMS_OpenToEncodeEnvelopedData( pcmi, pemei))
        goto StreamOpenToEncodeEnvelopedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbEncryptParameters);
    ICM_Free( ped);
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(EnvelopedDataAllocError)                // error already set
TRACE_ERROR(PcmiAllocError)                         // error already set
TRACE_ERROR(GenKeyError)                            // error already set
TRACE_ERROR(FillRecipientInfosError)                // error already set
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)      // error already set
TRACE_ERROR(StreamOpenToEncodeEnvelopedDataError)   // error already set
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Open a signed and enveloped message for encoding
//--------------------------------------------------------------------------
#if 0
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedAndEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    HCRYPTPROV                  hCryptProv;
    DWORD                       dwKeySpec;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO  psemei;
    SignedAndEnvelopedData      *psed = NULL;
    ContentEncryptionAlgorithmIdentifier *pceai;
    DWORD                       dwVersion = 1;
    HCRYPTKEY                   hkeyContentEncryption;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    DWORD                       i;
    CRYPT_ALGORITHM_IDENTIFIER        aiDigest;
    DWORD                       dwAlgoCAPISign;
    DWORD                       dwAlgoCAPIEncrypt;

    psemei = (PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo;
    psed = new SignedAndEnvelopedData;

    assert( 1 == psemei->SignedInfo.cSigners);       // just for now
    assert( psemei->cbSize >= sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO));
    if (psemei->cbSize < sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO))
        goto InvalidArg;

    // version
    psed->version.Write( &dwVersion);

    // recipientInfos
    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            &psemei->ContentEncryptionAlgorithm,
            &dwAlgoCAPIEncrypt))
        goto GetCAPIEncryptError;
    if (!CryptGenKey(
                psemei->EnvelopedInfo.hCryptProv,
                dwAlgoCAPIEncrypt,
                CRYPT_EXPORTABLE,       // dwFlags
                &hkeyContentEncryption))
        goto GenKeyError;
    if (!ICM_FillRecipientInfos(
                psemei->EnvelopedInfo.hCryptProv,
                hkeyContentEncryption,
                psemei->EnvelopedInfo.cRecipients,
                psemei->EnvelopedInfo.rgpRecipients,
                psed->recipientInfos,
                dwEncryptFlags))
        goto FillRecipientInfosError;

    // digestAlgorithms
    if (!ICM_SetAsnDigestAlgorithmIdentifiers(
                psed->digestAlgorithms,
                &aiDigest,
                psemei->SignedInfo.cSigners,
                psemei->SignedInfo.rgSigners,
                &hCryptProv,
                &dwKeySpec))
        goto SetAsnDigestAlgorithmIdentifiersError;

    // encryptedContentInfo.contentEncryptionAlgorithm
    // (.encryptedContent and .encryptedContent filled in during update)
    pceai = &psed->encryptedContentInfo.contentEncryptionAlgorithm;
    pceai->algorithm = psemei->EnvelopedInfo.ContentEncryptionAlgorithm.pszObjId;
    if (0 != psemei->EnvelopedInfo.ContentEncryptionAlgorithm.Parameters.cbData) {
        if (0 > pceai->parameters.Decode(
                psemei->EnvelopedInfo.ContentEncryptionAlgorithm.Parameters.pbData))
            goto ContentEncryptionAlgorithmParametersDecodeError;
    }

    // certificates
    for (i=psemei->SignedInfo.cCertEncoded, pcert=psemei->SignedInfo.rgCertEncoded;
            i>0;
            i--, pcert++) {
        if (0 > psed->certificates[ psed->certificates.Add()].Decode( pcert->pbData))
            goto BadParameter;
    }

    // crls
    for (i=psemei->SignedInfo.cCrlEncoded, pcrl=psemei->SignedInfo.rgCrlEncoded;
            i>0;
            i--, pcrl++) {
        if (0 > psed->crls[ psed->crls.Add()].Decode( pcrl->pbData))
            goto BadParameter;
    }

    // signerInfos
    if (!ICM_SetAsnSignerInfos(
            psed->signerInfos,
            dwFlags,
            psemei->SignedInfo.cSigners,
            psemei->SignedInfo.rgSigners))
        goto SetAsnSignerInfosError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto OutOfMemory;

    pcmi->hCryptProv = hCryptProv;
    if (0 == hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwKeySpec = dwKeySpec;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED_AND_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psed;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    pcmi->pszInnerContentObjID = ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1);
    pcmi->pStreamInfo = ICM_DupMem( pStreamInfo, sizeof(*pStreamInfo));
//    pcmi->cDigestAlgorithms = 1;                        // temp
    if (!(ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &aiDigest,
            &dwAlgoCAPISign) ||
          ICM_GetCAPI(
            CRYPT_SIGN_ALG_OID_GROUP_ID,
            &aiDigest,
            &dwAlgoCAPISign)))
        goto GetCAPISignError;
    pcmi->adwDigestAlgorithms[0] = dwAlgoCAPISign;
    pcmi->hkeyContentCrypt = hkeyContentEncryption;
    if (!CryptCreateHash(
                    hCryptProv,         // s/b various per array
                    dwAlgoCAPISign,     // s/b various per array
                    NULL,               // hKey - optional for MAC
                    0,                  // dwFlags
                    &pcmi->ahHash[0]))
        goto CreateHashError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (psed)
        delete psed;
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(FillRecipientInfosError)                // error already set
TRACE_ERROR(SetAsnDigestAlgorithmIdentifiersError)  // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
SET_ERROR(GetCAPIEncryptError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(GenKeyError)                            // error already set
TRACE_ERROR(BadParameter)
TRACE_ERROR(ContentEncryptionAlgorithmParametersDecodeError)
TRACE_ERROR(SetAsnSignerInfosError)
TRACE_ERROR(GetCAPISignError)
TRACE_ERROR(CreateHashError)
}
#endif


//+-------------------------------------------------------------------------
//  Open a cryptographic message for encoding
//
//  If CMSG_BARE_CONTENT_FLAG is specified for a streamed message,
//  the streamed output will not have an outer ContentInfo wrapper. This
//  makes it suitable to be streamed into an enclosing message.
//
//  The pStreamInfo parameter needs to be set to stream the encoded message
//  output.
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgOpenToEncode(
#else
CryptMsgOpenToEncode(
#endif
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    HCRYPTMSG   hcrmsg = NULL;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncoding;

    switch (dwMsgType) {
    case CMSG_DATA:
        hcrmsg = ICM_OpenToEncodeData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pStreamInfo);
        break;

    case CMSG_SIGNED:
        hcrmsg = ICM_OpenToEncodeSignedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_ENVELOPED:
        hcrmsg = ICM_OpenToEncodeEnvelopedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_SIGNED_AND_ENVELOPED:
#if 0
        hcrmsg = ICM_OpenToEncodeSignedAndEnvelopedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;
#endif
        goto MessageTypeNotSupportedYet;

    case CMSG_HASHED:
        hcrmsg = ICM_OpenToEncodeDigestedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

CommonReturn:
    if (hcrmsg) {
        PCRYPT_MSG_INFO pcmi = (PCRYPT_MSG_INFO) hcrmsg;
        pcmi->lRefCnt = 1;
        if (!Pki_InitializeCriticalSection( &pcmi->CriticalSection)) {
            pcmi->fInitializedCriticalSection = FALSE;
            CryptMsgClose(hcrmsg);
            hcrmsg = NULL;
        } else
            pcmi->fInitializedCriticalSection = TRUE;
    }
    return hcrmsg;

ErrorReturn:
    hcrmsg = NULL;
    goto CommonReturn;
SET_ERROR(InvalidEncoding,E_INVALIDARG)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Open a cryptographic message for decoding
//
//  hCryptProv specifies the crypto provider to use for hashing and/or
//  decrypting the message. If hCryptProv is NULL, a default crypt provider
//  is used.
//
//  Currently pRecipientInfo isn't used and should be set to NULL.
//
//  The pStreamInfo parameter needs to be set to stream the decoded content
//  output.
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgOpenToDecode(
#else
CryptMsgOpenToDecode(
#endif
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                   dwError = ERROR_SUCCESS;
    HCRYPTMSG               hcrmsg;
    PCRYPT_MSG_INFO         pcmi = NULL;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    if (NULL != pRecipientInfo)
        goto RecipientInfoNotSupportedYet;

    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto AllocCmsgError;

    if (0 == hCryptProv) {
        pcmi->fDefaultCryptProv = TRUE;
        pcmi->hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == pcmi->hCryptProv)
            goto GetDefaultCryptProvError;
    } else
        pcmi->hCryptProv        = hCryptProv;

    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = dwMsgType;
    pcmi->dwFlags           = dwFlags;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                            pStreamInfo,
                                            sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (!Pki_InitializeCriticalSection( &pcmi->CriticalSection))
        goto InitializeCriticalSectionError;
    pcmi->fInitializedCriticalSection = TRUE;
    pcmi->lRefCnt = 1;
    hcrmsg = (HCRYPTMSG)pcmi;

CommonReturn:
    ICM_SetLastError(dwError);
    return hcrmsg;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pcmi);
    hcrmsg = NULL;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR(RecipientInfoNotSupportedYet,E_INVALIDARG)
TRACE_ERROR(AllocCmsgError)                         // error already set
TRACE_ERROR(GetDefaultCryptProvError)               // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(InitializeCriticalSectionError)         // error already set
}

//+-------------------------------------------------------------------------
//  Duplicate a cryptographic message handle
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgDuplicate(
#else
CryptMsgDuplicate(
#endif
    IN HCRYPTMSG hCryptMsg
    )
{
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    if (pcmi)
        InterlockedIncrement(&pcmi->lRefCnt);
    return hCryptMsg;
}


//+-------------------------------------------------------------------------
//  Close a cryptographic message handle
//
//  NB- Must preserve LastError.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgClose(
#else
CryptMsgClose(
#endif
    IN HCRYPTMSG hCryptMsg)
{
    DWORD               dwError;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    PCMSG_STREAM_INFO   pcsi;

    if (NULL == hCryptMsg)
        return TRUE;
    if (0 != InterlockedDecrement(&pcmi->lRefCnt))
        return TRUE;

    // Preserve LastError
    dwError = GetLastError();

    pcsi = pcmi->pStreamInfo;

    switch (pcmi->dwMsgType) {
    case CMSG_DATA:
    {
        OctetStringType *poos = (OctetStringType *)pcmi->pvMsg;

        if (!poos)
            break;
        if (pcmi->fEncoding) {
            ICM_Free( poos->value);
            ICM_Free( poos);
        } else {
            PkiAsn1FreeInfo( ICM_GetDecoder(), OctetStringType_PDU, poos);
        }
        break;
    }
    case CMSG_SIGNED:
    {
        SignedData  *psd = (SignedData *)pcmi->pvMsg;

        if (!(psd || pcmi->psdi))
            break;
        if (pcmi->fEncoding) {
            if (psd->signerInfos.value) {
                SignerInfo  *psi;
                DWORD       i;

                for (i=psd->signerInfos.count, psi=psd->signerInfos.value;
                        i>0;
                        i--, psi++)
                    ICM_FreeAsnSignerInfo(psi);
                ICM_Free( psd->signerInfos.value);
            }

            if (ICM_IsAddInnerContentOctetWrapper(pcmi) &&
                    psd->contentInfo.content.length &&
                    psd->contentInfo.content.value)
                PkiAsn1FreeEncoded( ICM_GetEncoder(),
                    psd->contentInfo.content.value);
            if (psd->digestAlgorithms.count && psd->digestAlgorithms.value)
                ICM_Free( psd->digestAlgorithms.value);
            ICM_Free( psd);
            ICM_Free( pcmi->pszInnerContentObjID);

        } else {
            // decoding
            delete pcmi->psdi->pAlgidList;
            delete pcmi->psdi->pCertificateList;
            delete pcmi->psdi->pCrlList;
            delete pcmi->psdi->pSignerList;
            ICM_Free( pcmi->psdi->pci);
            ICM_Free( pcmi->psdi);
        }
        if (pcmi->pHashList)
            delete pcmi->pHashList;
#ifdef CMS_PKCS7
        if (pcmi->rgSignerEncodeDataInfo) {
            assert(pcmi->cSignerEncodeDataInfo);
            if (pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) {
                DWORD       i;

                for (i = 0; i < pcmi->cSignerEncodeDataInfo; i++) {
                    if (pcmi->rgSignerEncodeDataInfo[i].hCryptProv)
                        CryptReleaseContext(
                            pcmi->rgSignerEncodeDataInfo[i].hCryptProv, 0);
                }
            }
            ICM_Free(pcmi->rgSignerEncodeDataInfo);
        }
#endif  // CMS_PKCS7
        break;
    }

    case CMSG_ENVELOPED:
    {
#ifdef CMS_PKCS7
        CmsEnvelopedData   *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData   *ped = (EnvelopedData *)pcmi->pvMsg;
        RecipientInfo   *pri;
#endif  // CMS_PKCS7
        DWORD           i;

        if (pcmi->hkeyContentCrypt)
            CryptDestroyKey( pcmi->hkeyContentCrypt);
        ICM_Free( pcmi->Plaintext.pbData);
#ifndef CMS_PKCS7
        ICM_Free( pcmi->pbEncryptParameters);
#endif  // CMS_PKCS7
        if (pcmi->fEncoding) {
#ifdef CMS_PKCS7
            ICM_FreeOssCmsRecipientInfos(&ped->recipientInfos);

            if (ped->unprotectedAttrs.value) {
                Attribute *poatr;

                for (i=ped->unprotectedAttrs.count,
                        poatr=ped->unprotectedAttrs.value;
                        i>0;
                        i--, poatr++) {
                    ICM_Free(poatr->attributeValue.value);
                }
                ICM_Free(ped->unprotectedAttrs.value);
            }
    
#else
            for (i=ped->recipientInfos.count, pri=ped->recipientInfos.value;
                    i>0;
                    i--, pri++)
                ICM_Free( pri->encryptedKey.value);
            ICM_Free( ped->recipientInfos.value);
#endif  // CMS_PKCS7
            ICM_Free( ped->encryptedContentInfo.encryptedContent.value);
            ICM_Free( ped);
            ICM_Free( pcmi->pszInnerContentObjID);
        } else {
            // decoding
#ifdef CMS_PKCS7
            if (NULL != pcmi->pCertificateList)
                delete pcmi->pCertificateList;
            if (NULL != pcmi->pCrlList)
                delete pcmi->pCrlList;
#endif  // CMS_PKCS7
            if (pcsi) {
                ICM_Free( ped);
            } else {
#ifdef CMS_PKCS7
                PkiAsn1FreeInfo( ICM_GetDecoder(), CmsEnvelopedData_PDU, ped);
#else
                PkiAsn1FreeInfo( ICM_GetDecoder(), EnvelopedData_PDU, ped);
#endif  // CMS_PKCS7
            }
        }
        break;
    }

    case CMSG_HASHED:
    {
        DigestedData  *pdd = (DigestedData *)pcmi->pvMsg;
        if (pcmi->fEncoding) {
            if (ICM_IsAddInnerContentOctetWrapper(pcmi) &&
                    pdd->contentInfo.content.length &&
                    pdd->contentInfo.content.value)
                PkiAsn1FreeEncoded( ICM_GetEncoder(),
                    pdd->contentInfo.content.value);
            ICM_Free ((DigestedData *)pcmi->pvMsg);
            ICM_Free( pcmi->pszInnerContentObjID);
        } else {
            // decoding
            PkiAsn1FreeInfo( ICM_GetDecoder(), DigestedData_PDU,
                (DigestedData *)pcmi->pvMsg);
        }
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        break;
    }

    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    fRet = TRUE;
CommonReturn:
#ifdef CMS_PKCS7
    if (pcmi->pFreeList)
        delete pcmi->pFreeList;
#endif  // CMS_PKCS7
    if (pcmi->plDecodeInfo)
        delete pcmi->plDecodeInfo;
    ICM_Free( pcmi->pStreamInfo);
    ICM_Free( pcmi->bufOutput.pbData);
    ICM_Free( pcmi->bufCrypt.pbData);
    ICM_Free( pcmi->bufPendingCrypt.pbData);
    ICM_Free( pcmi->bufDecode.pbData);
    ICM_Free( pcmi->bufEncode.pbData);

    if (pcmi->pooid)
        PkiAsn1FreeDecoded(ICM_GetDecoder(), pcmi->pooid,
            ObjectIdentifierType_PDU);

    if ((pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) &&
            !pcmi->fDefaultCryptProv && pcmi->hCryptProv)
        CryptReleaseContext(pcmi->hCryptProv, 0);
    if (pcmi->hCryptProvContentCrypt)
        CryptReleaseContext(pcmi->hCryptProvContentCrypt, 0);
    if (pcmi->fInitializedCriticalSection)
        DeleteCriticalSection( &pcmi->CriticalSection);

    ICM_Free( hCryptMsg);
    SetLastError(dwError);              // Preserve LastError
    return fRet;

ErrorReturn:
    fRet = TRUE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(InvalidMsgType)
}


//+-------------------------------------------------------------------------
// Since the encoding might be indefinite-length encoded,
// decode and re-encode as DER.
//
// Returns:    FALSE iff fails
//
// NB: The caller of this routine needs to call
//          PkiAsn1FreeEncoded( ICM_GetEncoder(), pbOut);
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ReEncodeAsOctetDER(
    IN PBYTE    pbIn,
    IN DWORD    cbIn,
    OUT PBYTE   *ppbOut,
    OUT DWORD   *pcbOut)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    ASN1error_e Asn1Err;
    ASN1decoding_t pDec = ICM_GetDecoder();
    PVOID       pvMsg = NULL;

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (0 != (Asn1Err = PkiAsn1Decode(pDec, (void **)&pvMsg,
            OctetStringType_PDU, pbIn, cbIn)))
        goto DecodeInnerContentError;
    if (0 != (Asn1Err = PkiAsn1Encode(ICM_GetEncoder(), pvMsg,
             OctetStringType_PDU, ppbOut, pcbOut)))
        goto EncodeInnerContentError;
    fRet = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    PkiAsn1FreeInfo(pDec, OctetStringType_PDU, pvMsg);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    *ppbOut = NULL;
    *pcbOut = 0;
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeInnerContentError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeInnerContentError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+-------------------------------------------------------------------------
//  Update the digest
//
//  Returns:
//          FALSE iff error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDigest(
    IN HCRYPTHASH hHash,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    BOOL    fRet;

    if (0 != cbData)
        fRet = CryptHashData(
                    hHash,
                    pbData,
                    cbData,
                    0);                     // dwFlags
    else
        fRet = TRUE;

    if (!fRet)
        goto HashDataError;

CommonReturn:
    return fRet;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(HashDataError)      // error already set
}


//+-------------------------------------------------------------------------
//  Update the digests in a list
//
//  Returns:
//          FALSE iff error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateListDigest(
    IN CHashList    *pHashList,
    IN const BYTE   *pbData,
    IN DWORD        cbData)
{
    BOOL        fRet;
    CHashNode   *pnHash;

    if (pHashList) {
        for (pnHash=pHashList->Head(); pnHash; pnHash=pnHash->Next()) {
            if (!ICM_UpdateDigest( pnHash->Data()->hHash, pbData, cbData))
                goto UpdateDigestError;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(UpdateDigestError)  // error already set
}


//+-------------------------------------------------------------------------
//  Alloc and sign a hash.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_AllocAndSignHash(
    IN HCRYPTHASH   hHash,
    IN DWORD        dwKeySpec,
    IN DWORD        dwAlgIdPubKey,
    IN DWORD        dwPubKeyFlags,
    IN BOOL         fMaxLength,
    OUT PBYTE       *ppbSignature,
    OUT DWORD       *pcbSignature)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    fRet;
    PBYTE   pbSignature = NULL;
    DWORD   cbSignature = 0;

    if (dwKeySpec == 0)
        dwKeySpec = AT_SIGNATURE;

    if (CALG_NO_SIGN == dwAlgIdPubKey) {
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                NULL,
                &cbSignature,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        if (NULL == (pbSignature = (PBYTE)ICM_Alloc( cbSignature)))
            goto AllocHashParamError;
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbSignature,
                &cbSignature,
                0))                     // dwFlags
            goto GetHashParamError;
    } else if (CALG_DSS_SIGN == dwAlgIdPubKey &&
            0 == (dwPubKeyFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;
        BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];

        cbData = sizeof(rgbDssSignature);
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // sDescription
                0,                  // dwFlags
                rgbDssSignature,
                &cbData
                )) goto SignHashError;
        assert(cbData == sizeof(rgbDssSignature));

        if (NULL == (pbSignature = (PBYTE)ICM_Alloc(
                CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN)))
            goto AllocSignatureError;
        // Convert from the CSP signature format to an ASN.1 sequence of
        // two integers
        cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
        if (!CryptEncodeObject(
                X509_ASN_ENCODING,
                X509_DSS_SIGNATURE,
                rgbDssSignature,
                pbSignature,
                &cbSignature
                )) goto EncodeDssSignatureError;
        if (fMaxLength) {
            int cbRemain;
            assert(CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN >= cbSignature);
            cbRemain = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN - cbSignature;
            if (cbRemain > 0) {
                memset(pbSignature + cbSignature, 0, cbRemain);
                cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
            }
        }
    } else {
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                NULL,               // pbSignature
                &cbSignature))
            goto SignHashSizeError;
        if (NULL == (pbSignature = (PBYTE)ICM_Alloc( cbSignature)))
            goto AllocSignatureError;
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                pbSignature,
                &cbSignature))
            goto SignHashError;
        ICM_ReverseInPlace( pbSignature, cbSignature);
    }

    fRet = TRUE;
CommonReturn:
    *ppbSignature = pbSignature;
    *pcbSignature = cbSignature;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbSignature);
    pbSignature = NULL;
    cbSignature = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetHashParamSizeError)  // error already set
TRACE_ERROR(AllocHashParamError)    // error already set
TRACE_ERROR(GetHashParamError)      // error already set
TRACE_ERROR(SignHashSizeError)      // error already set
TRACE_ERROR(AllocSignatureError)    // error already set
TRACE_ERROR(SignHashError)          // error already set
TRACE_ERROR(EncodeDssSignatureError) // error already set
}


//+-------------------------------------------------------------------------
//  Get the hash of a blob.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetBlobHash(
    IN HCRYPTPROV       hCryptProv,
    IN DWORD            dwDigestAlgorithm,
    IN PBYTE            pb,
    IN DWORD            cb,
    OUT HCRYPTHASH      *phHash)
{
    BOOL                fRet;
    HCRYPTHASH          hHash;

    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgorithm,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!ICM_UpdateDigest( hHash, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    *phHash = hHash;
    return fRet;

ErrorReturn:
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateHashError)    // error already set
TRACE_ERROR(UpdateDigestError)  // error already set
}


//+-------------------------------------------------------------------------
//  Get the hash of an OSS Attributes. This is used to hash the authenticated
//  attributes for a Signed or SignedAndEnveloped message.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttrsHash(
    IN DWORD            dwDigestAlgorithm,
    IN HCRYPTPROV       hCryptProv,
    IN Attributes       *possAttrs,
    OUT HCRYPTHASH      *phHash)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    ASN1encoding_t      pEnc = ICM_GetEncoder();
    PBYTE               pbEncoded = NULL;
    DWORD               cbEncoded;
    HCRYPTHASH          hHash;

    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgorithm,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            possAttrs,
            Attributes_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeAttributesError;
    if (!ICM_UpdateDigest(
            hHash,
            pbEncoded,
            cbEncoded))
        goto UpdateDigestAttributesError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    *phHash = hHash;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeAttributesError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(UpdateDigestAttributesError)    // error already set
}


//+-------------------------------------------------------------------------
//  Compare 2 OSS object id's.
//
//  Returns:    FALSE iff !equal
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2)
{
    BOOL        fRet;
    DWORD       i;
    PDWORD      pdw1;
    PDWORD      pdw2;

    if (poid1->count != poid2->count)
        goto Unequal;
    for (i=poid1->count, pdw1=poid1->value, pdw2=poid2->value;
            (i>0) && (*pdw1==*pdw2);
            i--, pdw1++, pdw2++)
        ;
    if (i>0)
        goto Unequal;

    fRet = TRUE;        // equal
CommonReturn:
    return fRet;

Unequal:
    fRet = FALSE;       // !equal
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Get the value of an Attribute of a given type.
//
//  Returns:    FALSE iff fails
//
//  NB- Does not set error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttrValue(
    IN Attributes   *poatrs,
    IN ObjectID     *poid,
    OUT Any         *panyValue)
{
    BOOL        fRet;
    DWORD       i;
    Attribute   *poatr;

    for (i=poatrs->count, poatr=poatrs->value; i>0; i--, poatr++) {
        if (ICM_EqualObjectIDs( &poatr->attributeType, poid))
            break;
    }
    if (0 == i)
        goto AttributeNotFoundError;

    *panyValue = *poatr->attributeValue.value;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    panyValue->length = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(AttributeNotFoundError)
}


//+-------------------------------------------------------------------------
//  Fill in the content-type and message-digest authenticated attributes,
//  which are required in a SignedData or SignedAndEnvelopedData message.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillReqAuthAttrs(
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN CHashNode        *pnHash,
    IN OUT Attribute    *possAttr)
{
    BOOL                fRet;
    CRYPT_ATTRIBUTE     atr;
    CRYPT_ATTR_BLOB     atrblob;
    ASN1error_e         Asn1Err;
    ASN1encoding_t      pEnc = ICM_GetEncoder();
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    ObjectID            ossObjID;
    OctetStringType     ost;

    // NB - When psi->authenticatedAttributes was created,
    //      the first 2 slots were reserved for the
    //      content-type and message-digest attributes.

    // content-type attribute
    ossObjID.count = sizeof(ossObjID.value)/sizeof(ossObjID.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeObjectIdentifierError;
    atr.pszObjId = pszObjIdContentType;
    atr.cValue = 1;
    atr.rgValue = &atrblob;
    atrblob.cbData = cbEncoded;
    atrblob.pbData = pbEncoded;
    fRet = ICM_Asn1ToAttribute( &atr, possAttr);
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    if (!fRet)
        goto ContentTypeAsn1ToAttributeError;

    // message-digest attribute
    if (!ICM_GetListHashValue( pnHash, (DWORD*)&ost.length, &ost.value))
        goto GetHashValueError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ost,
            OctetStringType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeOctetStringError;
    atr.pszObjId = pszObjIdMessageDigest;
    atr.cValue = 1;
    atr.rgValue = &atrblob;
    atrblob.cbData = cbEncoded;
    atrblob.pbData = pbEncoded;
    fRet = ICM_Asn1ToAttribute( &atr, possAttr + 1);
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    if (!fRet)
        goto MsgDigestAsn1ToAttributeError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeOctetStringError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ConvToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(ContentTypeAsn1ToAttributeError)     // error already set
TRACE_ERROR(GetHashValueError)                      // error already set
TRACE_ERROR(MsgDigestAsn1ToAttributeError)       // error already set
}


//+-------------------------------------------------------------------------
//  Fill the inner ContentInfo.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillInnerContentInfo(
    OUT ContentInfo     *pci,
    IN OPTIONAL LPSTR   pszInnerID,
    IN DWORD            cbData,
    IN const BYTE       *pbData,
    IN BOOL             fAddInnerContentOctetWrapper    // CMS_PKCS7
    )
{
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    OctetStringType     ost;

    pci->contentType.count = sizeof(pci->contentType.value)/sizeof(pci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerID ? pszInnerID : pszObjIdDataType,
            &pci->contentType.count,
            pci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;
    if (0 != cbData) {
        pci->bit_mask |= content_present;
        if (!fAddInnerContentOctetWrapper) {
            pci->content.length = cbData;
            pci->content.value  = (PBYTE)pbData;
        } else {
            ost.length = cbData;
            ost.value  = (PBYTE)pbData;
            if (0 != (Asn1Err = PkiAsn1Encode(
                    ICM_GetEncoder(),
                    &ost,
                    OctetStringType_PDU,
                    &pbEncoded,
                    &cbEncoded)))
                goto EncodeOctetStringError;
            pci->content.length = cbEncoded;
            pci->content.value  = pbEncoded;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeOctetStringError, PkiAsn1ErrToHr(Asn1Err))
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Fill in the encrypted digest in a signer info.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo       *psi,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo,
    IN BOOL             fMaxLength)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    HCRYPTHASH      hHash;
    HCRYPTHASH      hHashAttr = NULL;
    HCRYPTHASH      hHashDup = NULL;
    PBYTE           pbSignature = NULL;
    DWORD           cbSignature;
    CHashNode       *pnHash = pSignerEncodeDataInfo->pHashNode;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();

    PCCRYPT_OID_INFO pOIDInfo;
    DWORD           dwAlgIdPubKey;
    DWORD           dwPubKeyFlags;

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_FillReqAuthAttrs(
                pszInnerContentObjID,
                pSignerEncodeDataInfo->pHashNode,
                psi->authenticatedAttributes.value))
            goto FillReqAuthAttrsError;
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pSignerEncodeDataInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, pSignerEncodeDataInfo->hCryptProv,
                &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    dwAlgIdPubKey = 0;
    dwPubKeyFlags = 0;
    if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwPubKeyFlags = pdwExtra[0];
        }
    } else if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_SIGN_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        if (1 <= cExtra) {
            dwAlgIdPubKey = pdwExtra[0];
            if (2 <= cExtra)
                dwPubKeyFlags = pdwExtra[1];
        }
    }

    if (!ICM_AllocAndSignHash( hHash, pSignerEncodeDataInfo->dwKeySpec,
            dwAlgIdPubKey, dwPubKeyFlags, fMaxLength,
            &pbSignature, &cbSignature))
        goto AllocAndSignHashError;
    psi->encryptedDigest.length = cbSignature;
    psi->encryptedDigest.value  = pbSignature;
    pbSignature = NULL;

    fRet = TRUE;
CommonReturn:
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_Free(pbSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FillReqAuthAttrsError)      // error already set
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
TRACE_ERROR(AllocAndSignHashError)      // error already set
}

BOOL
WINAPI
ICM_FillSignerEncodeEncryptedDigests(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fMaxLength)
{
    LPSTR pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD cSignerEncodeDataInfo = pcmi->cSignerEncodeDataInfo;
    PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo =
        pcmi->rgSignerEncodeDataInfo;
    SignedData *psd = (SignedData *)pcmi->pvMsg;
    SignerInfo *psi = psd->signerInfos.value;

    assert(psd->signerInfos.count == cSignerEncodeDataInfo);

    for ( ; 0 < cSignerEncodeDataInfo;
                                cSignerEncodeDataInfo--,
                                pSignerEncodeDataInfo++,
                                psi++) {
        if (!ICM_FillSignerEncryptedDigest(
                psi,
                pszInnerContentObjID,
                pSignerEncodeDataInfo,
                fMaxLength))
            return FALSE;
    }

    return TRUE;
}
#else

//+-------------------------------------------------------------------------
//  Fill in the encrypted digest in a signer info.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo       *psi,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN CHashNode        *pnHash,
    IN DWORD            dwKeySpec,
    IN BOOL             fMaxLength)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    HCRYPTHASH      hHash;
    HCRYPTHASH      hHashAttr = NULL;
    HCRYPTHASH      hHashDup = NULL;
    PBYTE           pbSignature = NULL;
    DWORD           cbSignature;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();

    PCCRYPT_OID_INFO pOIDInfo;
    DWORD           dwAlgIdPubKey;
    DWORD           dwPubKeyFlags;

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_FillReqAuthAttrs(
                pszInnerContentObjID,
                pnHash,
                psi->authenticatedAttributes.value))
            goto FillReqAuthAttrsError;
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pHashInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, pHashInfo->hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    dwAlgIdPubKey = 0;
    dwPubKeyFlags = 0;
    if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwPubKeyFlags = pdwExtra[0];
        }
    }

    if (!ICM_AllocAndSignHash( hHash, dwKeySpec,
            dwAlgIdPubKey, dwPubKeyFlags, fMaxLength,
            &pbSignature, &cbSignature))
        goto AllocAndSignHashError;
    psi->encryptedDigest.length = cbSignature;
    psi->encryptedDigest.value  = pbSignature;
    pbSignature = NULL;

    fRet = TRUE;
CommonReturn:
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_Free(pbSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FillReqAuthAttrsError)      // error already set
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
TRACE_ERROR(AllocAndSignHashError)      // error already set
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Update the content of a signed message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    SignedData          *psd = (SignedData *)pcmi->pvMsg;
    LPSTR               pszInnerContentObjID = pcmi->pszInnerContentObjID;
    PBYTE               pb;
    DWORD               cb;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    BOOL                fAddInnerContentOctetWrapper;   // CMS_PKCS7

    if (pcsi) {
        if (!ICMS_UpdateEncodingSignedData( pcmi, (PBYTE)pbData, cbData, fFinal))
            goto StreamUpdateEncodingSignedDataError;
    } else {
        psd->contentInfo.bit_mask = 0;

        fAddInnerContentOctetWrapper = ICM_IsAddInnerContentOctetWrapper(pcmi);
        if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG) &&
                !fAddInnerContentOctetWrapper && pbData) {
            // must be encoded, hash only the contents octets
            if (0 > Asn1UtilExtractContent(
                        (PBYTE)pbData,
                        cbData,
                        &cb,
                        (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = cbData;
            pb = (PBYTE)pbData;
        }
        if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
            goto UpdateDigestError;

        if (fFinal) {
            if (pcmi->dwFlags & CMSG_DETACHED_FLAG) {
                if (!ICM_FillInnerContentInfo(
                        &psd->contentInfo,
                        pszInnerContentObjID,
                        0,                      // cbData
                        NULL,                   // pbData
                        FALSE))                 // fAddInnerContentOctetWrapper
                    goto DetachedFillInnerContentInfoError;
            } else {
                if (!ICM_FillInnerContentInfo(
                        &psd->contentInfo,
                        pszInnerContentObjID,
                        cbData,
                        (PBYTE)pbData,
                        fAddInnerContentOctetWrapper
                        ))
                    goto FillInnerContentInfoError;
            }

#ifdef CMS_PKCS7
            if (pcmi->rgSignerEncodeDataInfo) {
                BOOL fMaxLength =
                    (0 != (pcmi->dwFlags & CMSG_MAX_LENGTH_FLAG));
                if (!ICM_FillSignerEncodeEncryptedDigests(
                        pcmi,
                        fMaxLength))
                    goto FillSignerEncodeEncryptedDigestsError;
            }
#else
            if (pcmi->pHashList) {
                BOOL fMaxLength =
                    (0 != (pcmi->dwFlags & CMSG_MAX_LENGTH_FLAG));
                if (!ICM_FillSignerEncryptedDigest(
                                psd->signerInfos.value,
                                pszInnerContentObjID,
                                pcmi->pHashList->Head(),
                                pcmi->dwKeySpec,
                                fMaxLength))
                    goto FillSignerEncryptedDigestError;
            }
#endif  // CMS_PKCS7
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(UpdateDigestError)                      // error already set
TRACE_ERROR(DetachedFillInnerContentInfoError)      // error already set
TRACE_ERROR(FillInnerContentInfoError)              // error already set
TRACE_ERROR(StreamUpdateEncodingSignedDataError)    // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(FillSignerEncodeEncryptedDigestsError)  // error already set
#else
TRACE_ERROR(FillSignerEncryptedDigestError)         // error already set
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Update the content of a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    OctetStringType     *poos = (OctetStringType *)pcmi->pvMsg;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    if (!pcsi) {
        if (!fFinal)
            goto NotFinalNotSupportedError;

        poos->length = cbData;
        if (NULL == (poos->value = (PBYTE)ICM_DupMem( (PBYTE)pbData, cbData)))
            goto AllocOctetStringError;
    }

    if (pcsi && !ICMS_UpdateEncodingData( pcmi, (PBYTE)pbData, cbData, fFinal))
        goto StreamUpdateEncodingDataError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( poos->value);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NotFinalNotSupportedError,E_INVALIDARG)
TRACE_ERROR(AllocOctetStringError)                  // error already set
TRACE_ERROR(StreamUpdateEncodingDataError)          // error already set
}


//+-------------------------------------------------------------------------
//  Update the content of a digested message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingDigestedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    BOOL                fRet;
    DigestedData        *pdd = (DigestedData *)pcmi->pvMsg;
    PBYTE               pb;
    DWORD               cb;
    LPSTR               pszInnerContentObjID = pcmi->pszInnerContentObjID;
    BOOL                fAddInnerContentOctetWrapper;   // CMS_PKCS7

    pdd->contentInfo.bit_mask = 0;
    if (pcmi->dwFlags & CMSG_DETACHED_FLAG) {
        // must be non-encoded
        if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
            goto DetachedUpdateDigestError;
        if (!ICM_FillInnerContentInfo(
                &pdd->contentInfo,
                pszInnerContentObjID,
                0,                      // cbData
                NULL,                   // pbData
                FALSE                   // fAddInnerContentOctetWrapper
                ))
            goto DetachedFillInnerContentInfoError;
    } else {
        fAddInnerContentOctetWrapper = ICM_IsAddInnerContentOctetWrapper(pcmi);
        if (!fAddInnerContentOctetWrapper && pbData) {
            // must be encoded, hash only the contents octets
            if (0 > Asn1UtilExtractContent( (PBYTE)pbData, cbData, &cb,
                    (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = cbData;
            pb = (PBYTE)pbData;
        }
        if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
            goto UpdateDigestError;
        if (!ICM_FillInnerContentInfo(
                &pdd->contentInfo,
                pszInnerContentObjID,
                cbData,
                (PBYTE)pbData,
                fAddInnerContentOctetWrapper
                ))
            goto FillInnerContentInfoError;
    }
    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (!ICM_GetListHashValue(
                pcmi->pHashList->Head(),
                (DWORD*)&pdd->digest.length,
                &pdd->digest.value))
            goto GetHashValueError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(DetachedUpdateDigestError)          // error already set
TRACE_ERROR(UpdateDigestError)                  // error already set
TRACE_ERROR(DetachedFillInnerContentInfoError)  // error already set
TRACE_ERROR(FillInnerContentInfoError)          // error already set
TRACE_ERROR(GetHashValueError)                  // error already set
fFinal;
}


//+-------------------------------------------------------------------------
//  Get the block size for an encryption algorithm
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetKeyBlockSize(
    IN HCRYPTKEY        hkeyEncrypt,
    OUT PDWORD          pcbBlockSize,
    OUT OPTIONAL PBOOL  pfBlockCipher)
{
    BOOL            fRet;
    BOOL            fBlockCipher;
    DWORD           cbBlockSize;
    DWORD           cbKeyParamLen;

    // Get key's blocksize.
    // Encryption will pad the output data to be blocksize aligned,
    // in the case of a block cipher.
    cbBlockSize = 0;
    cbKeyParamLen = sizeof( cbBlockSize);
    if (!CryptGetKeyParam(
            hkeyEncrypt,
            KP_BLOCKLEN,
            (PBYTE)&cbBlockSize,
            &cbKeyParamLen,
            0))                     // dwFlags
        goto GetKeyParamError;

    if (0 == cbBlockSize) {
        // stream cipher
        fBlockCipher = FALSE;
        cbBlockSize  = 8;       // convenient size
    } else {
        // block cipher
        fBlockCipher = TRUE;
        cbBlockSize /= 8;       // convert from bits to bytes
    }

    fRet = TRUE;
CommonReturn:
    *pcbBlockSize = cbBlockSize;
    if (pfBlockCipher)
        *pfBlockCipher = fBlockCipher;
    return fRet;

ErrorReturn:
    cbBlockSize = 0;
    fBlockCipher = FALSE;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetKeyParamError)   // error already set
}


//+-------------------------------------------------------------------------
//  Encrypt a buffer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EncryptBuffer(
    IN HCRYPTKEY hkeyEncrypt,
    HCRYPTHASH   hHash,
    IN const BYTE *pbPlain,
    IN DWORD    cbPlain,
    OUT PBYTE   *ppbCipher,
    OUT PDWORD  pcbCipher)
{
    BOOL            fRet;
    const BYTE      *pbIn;
    DWORD           cbIn;
    PBYTE           pbOut;
    DWORD           cbOut;
    PBYTE           pbOutBuf = NULL;
    DWORD           cbPlainRemain;
    DWORD           cbBufRemain;
    DWORD           cbBlockLen;
    BOOL            fBlockCipher;

    if (!ICM_GetKeyBlockSize( hkeyEncrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;

    // encrypt
    cbBufRemain = cbPlain;
    if (fBlockCipher) {
        cbBufRemain += cbBlockLen;
        cbBufRemain -= cbBufRemain % cbBlockLen;
    }
    if (NULL == (pbOutBuf = (PBYTE)ICM_Alloc( cbBufRemain)))
        goto OutOfMemory;
    for (pbIn=pbPlain, pbOut=pbOutBuf, cbPlainRemain=cbPlain;
            (cbIn = min( cbBlockLen, cbPlainRemain)) > 0;
            pbIn += cbIn, pbOut += cbOut,
                cbPlainRemain -= cbIn, cbBufRemain -= cbOut) {

        memcpy( pbOut, pbIn, cbIn);
        cbOut = cbIn;
        if (!CryptEncrypt(
                    hkeyEncrypt,
                    hHash,
                    cbPlainRemain <= cbBlockLen,    // fFinal
                    0,                              // dwFlags
                    pbOut,
                    &cbOut,
                    cbBufRemain))
            goto EncryptError;
    }

    *ppbCipher = pbOutBuf;
    *pcbCipher = (DWORD)(pbOut - pbOutBuf);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    if(NULL != pbOutBuf)
        ICM_Free(pbOutBuf);
    *ppbCipher = NULL;
    *pcbCipher = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
TRACE_ERROR(EncryptError)               // error already set
TRACE_ERROR(OutOfMemory)                // error already set
}


//+-------------------------------------------------------------------------
//  Encrypt and store the content of a message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EncryptContent(
    IN HCRYPTKEY                hkeyContentEncryption,
    HCRYPTHASH                  hHash,
    OUT EncryptedContentInfo    *peci,
    IN const BYTE               *pbPlain,
    IN DWORD                    cbPlain)
{
    BOOL    fRet;
    PBYTE   pbCipher = NULL;
    DWORD   cbCipher;

    if (!ICM_EncryptBuffer(
            hkeyContentEncryption,
            hHash,
            pbPlain,
            cbPlain,
            &pbCipher,
            &cbCipher))
        goto EncryptBufferError;

    if (0 != cbCipher) {
        peci->bit_mask |= encryptedContent_present;
        peci->encryptedContent.length = cbCipher;
        peci->encryptedContent.value = pbCipher;
    } else
        ICM_Free(pbCipher);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptBufferError)     // error already set
}


//+-------------------------------------------------------------------------
//  Update the content of a signed and enveloped message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
#if 0
BOOL
WINAPI
ICM_UpdateEncodingSignedAndEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    EncryptedContentInfo    *peci;
    SignedAndEnvelopedData  *psed;
    DWORD                   i;
    DWORD                   iMax;
    PBYTE                   pbSignature;
    DWORD                   cbSignature;
    PBYTE                   pbEncryptedSignature;
    DWORD                   cbEncryptedSignature;

    psed = (SignedAndEnvelopedData *)(pcmi->pvMsg);
    peci = &psed->encryptedContentInfo;

    // Require inner type to be Data for now
    peci->contentType = aoidMessages[ CMSG_DATA - 1];

    // Alloc a bigger buffer with padding and copy input to it

    // encrypt the content and store it
    if (!ICM_EncryptContent(
            pcmi->hkeyContentCrypt,
            pcmi->ahHash[0],        // select the right hHash
            peci,
            pbData,
            cbData))
        goto EncryptError;

    assert( 1 == psed->signerInfos.Count());
    for (i=0, iMax=psed->signerInfos.Count(); i<iMax; i++) {
        // Should use a stack buffer, unless it is too small
        if (!CryptSignHash(
                pcmi->ahHash[i],
                (pcmi->dwKeySpec == 0) ? AT_SIGNATURE : pcmi->dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                NULL,               // pbSignature
                &cbSignature))
            goto GetSignatureSizeError;
        pbSignature = (PBYTE)ICM_AllocA( cbSignature);
        if (NULL == pbSignature)
            goto AllocSignatureError;
        if (!CryptSignHash(
                pcmi->ahHash[i],
                (pcmi->dwKeySpec == 0) ? AT_SIGNATURE : pcmi->dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                pbSignature,
                &cbSignature))
            goto SignHashError;
        // encrypt the signature
        if (!ICM_EncryptBuffer(
                pcmi->hkeyContentCrypt,
                NULL,
                pbSignature,
                cbSignature,
                &pbEncryptedSignature,
                &cbEncryptedSignature))
            goto EncryptError;
        ICM_FreeA( pbSignature);
        pbSignature = NULL;
        if (0 > psed->signerInfos[i].encryptedDigest.Write(
                pbEncryptedSignature,
                cbEncryptedSignature))
            goto EncryptedDigestWriteError;
        ICM_Free( pbEncryptedSignature);
        pbEncryptedSignature = NULL;
    }

    fRet = TRUE;
CommonReturn:
    ICM_FreeA( pbSignature);
    ICM_Free( pbEncryptedSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptError)
TRACE_ERROR(GetSignatureSizeError)
TRACE_ERROR(AllocSignatureError)
TRACE_ERROR(SignHashError)
TRACE_ERROR(EncryptedDigestWriteError)
}
#endif


//+-------------------------------------------------------------------------
//  Update the content of an enveloped message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    BOOL                    fRet;
    PBYTE                   pb;
    DWORD                   cb;
#ifdef CMS_PKCS7
    EncryptedContentInfo    *peci = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#else
    EncryptedContentInfo    *peci = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#endif  // CMS_PKCS7
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    if (pcsi) {
        if (!ICMS_UpdateEncodingEnvelopedData(
                            pcmi,
                            pbData,
                            cbData,
                            fFinal))
            goto StreamUpdateEncodingEnvelopedDataError;
    } else {
        if (!fFinal)
            goto InvalidArg;

        // encrypt the content
        if (!ICM_IsAddInnerContentOctetWrapper(pcmi)) {
            if (0 > Asn1UtilExtractContent( (PBYTE)pbData, cbData, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            pb = (PBYTE)pbData;
            cb = cbData;
        }

        if (!ICM_EncryptContent(
                pcmi->hkeyContentCrypt,
                NULL,           // hHash
                peci,
                pb,
                cb))
            goto EncryptError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(EncryptError)                               // error already set
TRACE_ERROR(StreamUpdateEncodingEnvelopedDataError)     // error already set
}


//+-------------------------------------------------------------------------
//  Convert Any to blob and insert at the tail of a blob list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN Any              *pAny)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;
    CRYPT_DATA_BLOB         blob;

    if (NULL == (pnBlob = new CBlobNode))
        goto NewCBlobNodeError;
    cb = pAny->length;
    if (NULL == (pb = (PBYTE)ICM_Alloc( cb)))
        goto AllocError;
    memcpy( pb, pAny->value, cb);
    blob.cbData = cb;
    blob.pbData = pb;
    pnBlob->SetData( &blob);
    pBlobList->InsertTail( pnBlob);

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    ICM_Free( pb);
    goto CommonReturn;
SET_ERROR(NewCBlobNodeError,E_OUTOFMEMORY)
TRACE_ERROR(AllocError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Use a 0-based index to delete a blob from a list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DelBlobByIndex(
    IN OUT CBlobList    *pBlobList,
    IN DWORD            dwIndex)
{
    BOOL                fRet;
    CBlobNode           *pnBlob = pBlobList->Nth( dwIndex);

    if (NULL == pnBlob)
        goto IndexTooLargeError;

    pBlobList->Remove( pnBlob);
    delete pnBlob;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
}


//+-------------------------------------------------------------------------
//  Convert Any to blob and insert at the tail of a signer list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InsertTailSigner(
    IN OUT CSignerList  *pSignerList,
    IN Any              *pAny)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CSignerNode             *pnSigner = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;
    SIGNER_DATA_INFO        sdi;    ZEROSTRUCT(sdi);

    if (NULL == (pnSigner = new CSignerNode))
        goto NewCSignerNodeError;
    cb = pAny->length;
    if (NULL == (pb = (PBYTE)ICM_Alloc( cb)))
        goto AllocError;
    memcpy( pb, pAny->value, cb);
    sdi.blob.cbData = cb;
    sdi.blob.pbData = pb;
    pnSigner->SetData( &sdi);
    pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pb);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NewCSignerNodeError,E_OUTOFMEMORY)
TRACE_ERROR(AllocError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Convert a signed message to list form
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetListSignedData(
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN SignedDataWithBlobs *psdb)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    Any                 *pAny;
    DWORD               cb;
    DWORD               i;
    PSIGNED_DATA_INFO   psdi = NULL;

    if (NULL == (psdi = (PSIGNED_DATA_INFO)ICM_AllocZero(
                            sizeof(SIGNED_DATA_INFO))))
        goto SdiAllocError;

    if (NULL == (psdi->pAlgidList = new CBlobList))
        goto NewAlgidListError;
    if (NULL == (psdi->pCertificateList = new CBlobList))
        goto NewCertificateListError;
    if (NULL == (psdi->pCrlList = new CBlobList))
        goto NewCrlListError;
    if (NULL == (psdi->pSignerList = new CSignerList))
        goto NewSignerListError;

    // version
    psdi->version = psdb->version;

    // digestAlgorithms
    for (i=psdb->digestAlgorithms.count, pAny=psdb->digestAlgorithms.value;
            i>0;
            i--, pAny++) {
        if (!ICM_InsertTailBlob( psdi->pAlgidList, pAny))
            goto DigestAlgorithmInsertTailBlobError;
    }

    // contentInfo
    cb = 0;
    ICM_GetOssContentInfoData(
            (ContentInfo *)&psdb->contentInfo,  // same, except for NOCOPY
            NULL,
            &cb);
    if (cb == 0)
        goto GetContentInfoDataSizeError;
    if (NULL == (psdi->pci = (PCONTENT_INFO)ICM_Alloc(cb)))
        goto AllocContentInfoError;
    if (!ICM_GetOssContentInfoData(
            (ContentInfo *)&psdb->contentInfo,  // same, except for NOCOPY
            psdi->pci,
            &cb))
        goto GetContentInfoDataError;

    // certificates
    if (psdb->bit_mask & certificates_present) {
#ifdef OSS_CRYPT_ASN1
        for (i=psdb->certificates.count, pAny=psdb->certificates.certificates;
#else
        for (i=psdb->certificates.count, pAny=psdb->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pAny++) {
            if (!ICM_InsertTailBlob( psdi->pCertificateList, pAny))
                goto CertInsertTailBlobError;
        }
    }

    // crls
    if (psdb->bit_mask & crls_present) {
#ifdef OSS_CRYPT_ASN1
        for (i=psdb->crls.count, pAny=psdb->crls.crls;
#else
        for (i=psdb->crls.count, pAny=psdb->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pAny++) {
            if (!ICM_InsertTailBlob( psdi->pCrlList, pAny))
                goto CrlInsertTailBlobError;
        }
    }

    // signerInfos
    for (i=psdb->signerInfos.count, pAny=psdb->signerInfos.value;
            i>0;
            i--, pAny++) {
        if (!ICM_InsertTailSigner( psdi->pSignerList, pAny))
            goto SignerInfoInsertTailBlobError;
    }

    fRet = TRUE;
CommonReturn:
    pcmi->psdi = psdi;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();

    if (NULL != psdi) {
        if(NULL != psdi->pSignerList)
            delete psdi->pSignerList;

        if(NULL != psdi->pCrlList)
            delete psdi->pCrlList;

        if(NULL != psdi->pCertificateList)
            delete psdi->pCertificateList;

        if(NULL != psdi->pAlgidList)
            delete psdi->pAlgidList;

        ICM_Free( psdi);
        psdi = NULL;
    }

    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestAlgorithmInsertTailBlobError)     // error already set
TRACE_ERROR(GetContentInfoDataSizeError)            // error already set
TRACE_ERROR(AllocContentInfoError)                  // error already set
TRACE_ERROR(GetContentInfoDataError)                // error already set
TRACE_ERROR(CertInsertTailBlobError)                // error already set
TRACE_ERROR(CrlInsertTailBlobError)                 // error already set
TRACE_ERROR(SignerInfoInsertTailBlobError)          // error already set
SET_ERROR(NewSignerListError,E_OUTOFMEMORY)
SET_ERROR(NewCrlListError,E_OUTOFMEMORY)
SET_ERROR(NewCertificateListError,E_OUTOFMEMORY)
SET_ERROR(NewAlgidListError,E_OUTOFMEMORY)
SET_ERROR(SdiAllocError,E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Get the CAPI algid from an encoded AlgidBlob
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCapiFromAlgidBlob(
    IN PCRYPT_DATA_BLOB pAlgidBlob,
    OUT PDWORD          pdwAlgidCapi)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    AlgorithmIdentifier *poai = NULL;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poai,
            AlgorithmIdentifier_PDU,
            pAlgidBlob->pbData,
            pAlgidBlob->cbData)))
        goto Asn1DecodeAlgorithmIdentifierError;
    if (!(ICM_GetOssCAPI( CRYPT_HASH_ALG_OID_GROUP_ID, poai, pdwAlgidCapi) ||
            ICM_GetOssCAPI( CRYPT_SIGN_ALG_OID_GROUP_ID, poai, pdwAlgidCapi)))
        goto GetCAPIError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AlgorithmIdentifier_PDU, poai);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    *pdwAlgidCapi = 0;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeAlgorithmIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
}


//+-------------------------------------------------------------------------
//  Create a hash list from a list of hash algid's
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateHashList(
    IN HCRYPTPROV       hCryptProv,
    IN OUT CHashList    **ppHashList,
    IN CBlobList        *pAlgidList)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    CHashList       *pHashList;
    CBlobNode       *pBlobNode;
    CHashNode       *pHashNode;
    ICM_HASH_INFO   HashInfo;       ZEROSTRUCT(HashInfo);

    if (NULL == (pHashList = new CHashList))
        goto NewHashListError;
    if (hCryptProv) {
        for (pBlobNode=pAlgidList->Head();
                pBlobNode;
                pBlobNode=pBlobNode->Next()) {
            if (!ICM_GetCapiFromAlgidBlob(
                    pBlobNode->Data(),
                    &HashInfo.dwAlgoCAPI))
                goto GetCAPIError;
#ifndef CMS_PKCS7
            HashInfo.hCryptProv = hCryptProv;
#endif  // CMS_PKCS7
            if (!CryptCreateHash(
                            hCryptProv,
                            HashInfo.dwAlgoCAPI,
                            NULL,               // hKey - optional for MAC
                            0,                  // dwFlags
                            &HashInfo.hHash))
                goto CreateHashError;
            if (NULL == (pHashNode = new CHashNode))
                goto NewHashNodeError;
            pHashNode->SetData( &HashInfo);
            pHashList->InsertTail( pHashNode);
        }
    }

    fRet = TRUE;
CommonReturn:
    *ppHashList = pHashList;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    pHashList = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
TRACE_ERROR(GetCAPIError)                           // error already set
TRACE_ERROR(CreateHashError)                        // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a signed message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingSignedData(
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    SignedDataWithBlobs *psdb = NULL;
    PBYTE               pb = NULL;
    DWORD               cb;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PBYTE               pbDER = NULL;
    DWORD               cbDER;
    ICM_HASH_INFO       HashInfo;       ZEROSTRUCT(HashInfo);

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&psdb,
                SignedDataWithBlobs_PDU,
                pbData,
                cbData)))
            goto Asn1DecodeSignedDataError;
        if (!ICM_GetListSignedData( pcmi, psdb))
            goto GetListSignedDataError;
        if (!ICM_CreateHashList(
                pcmi->hCryptProv,
                &pcmi->pHashList,
                pcmi->psdi->pAlgidList))
            goto CreateHashListError;
        if (pcmi->psdi->pci->content.cbData) {
            // Get the address & count of the contents octets of the DER
            // encoding of the content. Since the content might be
            // indefinite-length encoded, decode and re-encode as DER.
            pb = pcmi->psdi->pci->content.pbData;
            cb = pcmi->psdi->pci->content.cbData;

            if (0 == strcmp(pszObjIdDataType,
                        pcmi->psdi->pci->pszContentType)
#ifdef CMS_PKCS7
                    ||  pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                    ) {
                if (!ICM_ReEncodeAsOctetDER(
                        pb,
                        cb,
                        &pbDER,
                        &cbDER
                        ))
                    goto ReEncodeAsOctetDERError;
                if (pbDER) {
                    pb = pbDER;
                    cb = cbDER;
                }
            }
            if (0 > Asn1UtilExtractContent( pb, cb, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = 0;
        }
    } else {
        assert (pcmi->dwFlags & CMSG_DETACHED_FLAG);
        if (!(pcmi->dwFlags & CMSG_DETACHED_FLAG))
            goto NonFinalNotDetachedError;
        pb = (PBYTE)pbData;
        cb = cbData;
    }

    if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    PkiAsn1FreeEncoded(ICM_GetEncoder(), pbDER);
    PkiAsn1FreeInfo(pDec, SignedDataWithBlobs_PDU, psdb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignedDataError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(NonFinalNotDetachedError,CRYPT_E_MSG_ERROR)
TRACE_ERROR(GetListSignedDataError)                 // error already set
TRACE_ERROR(CreateHashListError)                    // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)                // error already set
TRACE_ERROR(UpdateDigestError)                      // error already set
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Update for decoding an enveloped message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    CmsEnvelopedData    *ped = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    assert (PHASE_FIRST_FINAL == pcmi->dwPhase);
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **) &ped,
            CmsEnvelopedData_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = ped;

    if (NULL == (pcmi->pCertificateList = new CBlobList))
        goto NewCertificateListError;
    if (NULL == (pcmi->pCrlList = new CBlobList))
        goto NewCrlListError;

    if (ped->bit_mask & originatorInfo_present) {
        OriginatorInfo *poi = &ped->originatorInfo;
        DWORD i;
        Any *pAny;

        // certificates
        if (poi->bit_mask & certificates_present) {
#ifdef OSS_CRYPT_ASN1
            for (i=poi->certificates.count, pAny=poi->certificates.certificates;
#else
            for (i=poi->certificates.count, pAny=poi->certificates.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( pcmi->pCertificateList, pAny))
                    goto CertInsertTailBlobError;
            }
        }

        // crls
        if (poi->bit_mask & crls_present) {
#ifdef OSS_CRYPT_ASN1
            for (i=poi->crls.count, pAny=poi->crls.crls;
#else
            for (i=poi->crls.count, pAny=poi->crls.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( pcmi->pCrlList, pAny))
                    goto CrlInsertTailBlobError;
            }
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;

    if (NULL != pcmi->pCertificateList) {
        delete pcmi->pCertificateList;
        pcmi->pCertificateList = NULL;
    }

    if (NULL != pcmi->pCrlList) {
        delete pcmi->pCrlList;
        pcmi->pCrlList = NULL;
    }

    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NewCertificateListError,E_OUTOFMEMORY)
SET_ERROR(NewCrlListError,E_OUTOFMEMORY)
TRACE_ERROR(CertInsertTailBlobError)
TRACE_ERROR(CrlInsertTailBlobError)
}

#else

//+-------------------------------------------------------------------------
//  Update for decoding an enveloped message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    BOOL                fRet;
    EnvelopedData       *ped = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    assert (PHASE_FIRST_FINAL == pcmi->dwPhase);
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&ped,
            EnvelopedData_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = ped;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Find the HashNode corresponding to a CAPI Algid
//
// NB- Does not fail.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindHashNodeFromCapiAlgid(
    IN CHashList    *pHashList,
    IN DWORD        dwAlgoCAPI,
    OUT CHashNode   **ppnHash)
{
    CHashNode   *pnHash;

    for (pnHash=pHashList->Head(); pnHash; pnHash=pnHash->Next()) {
        if (dwAlgoCAPI == pnHash->Data()->dwAlgoCAPI)
            break;
    }

    *ppnHash = pnHash;

    if(pnHash == NULL) {
        SetLastError((DWORD) CRYPT_E_UNKNOWN_ALGO);
        return FALSE;
    }
    
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Find the HashNode corresponding to an encoded Algid
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindHashNodeFromEncodedAlgo(
    IN CHashList            *pHashList,
    IN PCRYPT_DATA_BLOB     pblobEncodedAlgorithm,
    OUT CHashNode           **ppnHash)
{
    BOOL        fRet;
    DWORD       dwAlgoCAPI;

    if (!ICM_GetCapiFromAlgidBlob(
            pblobEncodedAlgorithm,
            &dwAlgoCAPI))
        goto GetCAPIError;
    fRet = ICM_FindHashNodeFromCapiAlgid( pHashList, dwAlgoCAPI, ppnHash);

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *ppnHash = NULL;
    goto CommonReturn;
TRACE_ERROR(GetCAPIError)       // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a digested message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingDigestedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    DigestedData        *pdd = NULL;
    PBYTE               pb = NULL;
    DWORD               cb;
    PBYTE               pbDER = NULL;
    DWORD               cbDER;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    ICM_HASH_INFO       HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode           *pHashNode;

    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&pdd,
                DigestedData_PDU,
                pbData,
                cbData)))
            goto Asn1DecodeError;
        pcmi->pvMsg = pdd;
        if (!ICM_GetOssCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                &pdd->digestAlgorithm,
                &HashInfo.dwAlgoCAPI))
            goto GetCAPIError;
#ifndef CMS_PKCS7
        HashInfo.hCryptProv = pcmi->hCryptProv;
#endif  // CMS_PKCS7
        if (!CryptCreateHash(
                        pcmi->hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (NULL == (pcmi->pHashList = new CHashList))
            goto NewHashListError;
        if (NULL == (pHashNode = new CHashNode))
            goto NewHashNodeError;
        pHashNode->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pHashNode);
        if (pdd->contentInfo.bit_mask & content_present) {
            // Get the address & count of the contents octets of the DER
            // encoding of the content. Since the content might be
            // indefinite-length encoded, decode and re-encode as DER.
            pb = (PBYTE)pdd->contentInfo.content.value;
            cb = (DWORD)pdd->contentInfo.content.length;

            if (ICM_EqualObjectIDs(
                        &pdd->contentInfo.contentType,
                        &aoidMessages[ CMSG_DATA - 1])
#ifdef CMS_PKCS7
                    || pdd->version >= CMSG_HASHED_DATA_V2 
#endif  // CMS_PKCS7
                    ) {
                if (!ICM_ReEncodeAsOctetDER(
                        pb,
                        cb,
                        &pbDER,
                        &cbDER
                        ))
                    goto ReEncodeAsOctetDERError;
                if (pbDER) {
                    pb = pbDER;
                    cb = cbDER;
                }
            }
            if (0 > Asn1UtilExtractContent( pb, cb, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = 0;
        }
    } else {
        assert (pcmi->dwFlags & CMSG_DETACHED_FLAG);
        if (!(pcmi->dwFlags & CMSG_DETACHED_FLAG))
            goto NonFinalNotDetachedError;
        pb = (PBYTE)pbData;
        cb = cbData;
    }
    if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(ICM_GetEncoder(), pbDER);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    PkiAsn1FreeInfo(pDec, DigestedData_PDU, pdd);
    pcmi->pvMsg = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(NonFinalNotDetachedError,CRYPT_E_MSG_ERROR)
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(UpdateDigestError)              // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)        // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a data message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    OctetStringType     *poos = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    if (PHASE_FIRST_FINAL != pcmi->dwPhase)
        goto NonFirstFinalError;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poos,
            OctetStringType_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = poos;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    PkiAsn1FreeInfo(pDec, OctetStringType_PDU, poos);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NonFirstFinalError,CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Write a buffer to a file
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_WriteBufToFile(
    LPCSTR      pszFileName,
    PBYTE       pbData,
    DWORD       cbData)
{
    BOOL        fRet;
    HANDLE      hFile;
    DWORD       cbWritten;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_WRITE,
            0, NULL, CREATE_ALWAYS, 0, NULL))) {
        goto CreateFileError;
    }

    if (!WriteFile( hFile, pbData, cbData, &cbWritten, NULL) ||
            (cbWritten != cbData)) {
        goto WriteFileError;
    }

    CloseHandle( hFile);
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
}


//+-------------------------------------------------------------------------
//  Update the content of a cryptographic message. Depending on how the
//  message was opened, the content is either encoded or decoded.
//
//  This function is repetitively called to append to the message content.
//  fFinal is set to identify the last update. On fFinal, the encode/decode
//  is completed. The encoded/decoded content and the decoded parameters
//  are valid until the open and all duplicated handles are closed.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgUpdate(
#else
CryptMsgUpdate(
#endif
    IN HCRYPTMSG    hCryptMsg,
    IN const BYTE   *pbData,
    IN DWORD        cbData,
    IN BOOL         fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    ContentInfo         *pci = NULL;
    ASN1error_e         Asn1Err;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    DWORD dwExceptionCode;

    ICM_Lock( pcmi);        // Single thread access to HCRYPTMSG

  // Handle MappedFile Exceptions
  __try {

    if (!ICM_AdvanceMsgPhase( &pcmi->dwPhase, fFinal))
        goto AdvancePhaseError;

    if (pcmi->fEncoding) {
        if (!(((pcmi->dwFlags & CMSG_DETACHED_FLAG) &&
                    (PHASE_FIRST_ONGOING == pcmi->dwPhase)) ||
                (pcsi && (pcmi->dwPhase < PHASE_SECOND_ONGOING)) ||
                (PHASE_FIRST_FINAL == pcmi->dwPhase)))
            goto EncodingPhaseError;

        switch (pcmi->dwMsgType) {
        case CMSG_DATA:
            fRet = ICM_UpdateEncodingData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_SIGNED:
            fRet = ICM_UpdateEncodingSignedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_ENVELOPED:
            fRet = ICM_UpdateEncodingEnvelopedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_HASHED:
            fRet = ICM_UpdateEncodingDigestedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
#if 0
            fRet = ICM_UpdateEncodingSignedAndEnvelopedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
#endif
        case CMSG_ENCRYPTED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }
    } else {
        // decode
        ASN1decoding_t  pDec = ICM_GetDecoder();
        LONG            lth;
        PBYTE           pb;
        DWORD           cb;

        if (pcsi) {
            if (pcmi->dwPhase < PHASE_SECOND_ONGOING) {
                fRet = ICMS_UpdateDecoding( pcmi, pbData, cbData, fFinal);
                if (fRet)
                    goto CommonReturn;
                else
                    goto ErrorReturn;
            }
            // else
            //  streaming detached
        }

        if (PHASE_FIRST_ONGOING == pcmi->dwPhase)
            goto FirstOngoingDecodeError;

        if ((0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) &&
                (PHASE_FIRST_FINAL != pcmi->dwPhase))
            goto SecondOngoingNonDetachedError;

        if ((PHASE_FIRST_FINAL == pcmi->dwPhase) &&
                (0 == pcmi->dwMsgType)) {
            if (0 != (Asn1Err = PkiAsn1Decode(
                    pDec,
                    (void **)&pci,
                    ContentInfoNC_PDU,
                    pbData,
                    cbData)))
                goto Asn1DecodeContentInfoError;
            if (0 == (lth = ICM_ObjIdToIndex( &pci->contentType)))
                goto InvalidMsgType;
            pcmi->dwMsgType = (DWORD)lth;
            pb = (PBYTE)pci->content.value;
            cb = pci->content.length;
        } else {
            pb = (PBYTE)pbData;
            cb = cbData;
        }
        switch (pcmi->dwMsgType) {
        case CMSG_DATA:
            fRet = ICM_UpdateDecodingData( pcmi, pb, cb);
            break;
        case CMSG_SIGNED:
            fRet = ICM_UpdateDecodingSignedData( pcmi, pb, cb);
            break;
        case CMSG_ENVELOPED:
            fRet = ICM_UpdateDecodingEnvelopedData( pcmi, pb, cb);
            break;
        case CMSG_HASHED:
            fRet = ICM_UpdateDecodingDigestedData( pcmi, pb, cb);
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
        case CMSG_ENCRYPTED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }
    }

    if (!fRet)
        goto ErrorReturn;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    if (pci)
        PkiAsn1FreeInfo(ICM_GetDecoder(), ContentInfoNC_PDU, pci);

    ICM_Unlock( pcmi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(EncodingPhaseError,CRYPT_E_MSG_ERROR)
SET_ERROR(FirstOngoingDecodeError,CRYPT_E_MSG_ERROR)
SET_ERROR(SecondOngoingNonDetachedError,CRYPT_E_MSG_ERROR)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR_VAR(Asn1DecodeContentInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AdvancePhaseError)              // error already set
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


BOOL
WINAPI
ICM_VerifySignature(
    IN HCRYPTHASH       hHash,
    IN HCRYPTKEY        hPubKey,
    IN DWORD            dwPubKeyAlgId,
    IN DWORD            dwPubKeyFlags,
    IN PBYTE            pbEncryptedDigest,
    IN DWORD            cbEncryptedDigest)
{
    BOOL fRet;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    PBYTE pb = NULL;

    if (CALG_NO_SIGN == dwPubKeyAlgId) {
        DWORD cbData;

        // The encrypted digest isn't signed. It should be the same as
        // the calculated hash

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                NULL,
                &cbData,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        if (NULL == (pb = (PBYTE)ICM_AllocA( cbData)))
            goto AllocHashParamError;
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pb,
                &cbData,
                0))                     // dwFlags
            goto GetHashParamError;

        // Compare the calculated hash with the "encrypted digest"
        if (cbData != cbEncryptedDigest ||
                0 != memcmp(pb, pbEncryptedDigest, cbData))
            goto NoSignHashCompareError;

        fRet = TRUE;
        goto CommonReturn;
    }

    if (CALG_DSS_SIGN == dwPubKeyAlgId &&
            0 == (dwPubKeyFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_DSS_SIGNATURE,
                pbEncryptedDigest,
                cbEncryptedDigest,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto DecodeError;
        pbEncryptedDigest = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbEncryptedDigest = sizeof(rgbDssSignature);
    } else {
        if (NULL == (pb = (PBYTE)ICM_AllocA( cbEncryptedDigest)))
            goto AllocError;
        ICM_ReverseCopy( pb, pbEncryptedDigest, cbEncryptedDigest);
        pbEncryptedDigest = pb;
    }

    fRet = CryptVerifySignature(
                hHash,
                pbEncryptedDigest,
                cbEncryptedDigest,
                hPubKey,
                NULL,           // pwszDescription
                0);             // dwFlags
CommonReturn:
    ICM_FreeA(pb);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetHashParamSizeError)
TRACE_ERROR(AllocHashParamError)
TRACE_ERROR(GetHashParamError)
SET_ERROR(NoSignHashCompareError, NTE_BAD_SIGNATURE)
TRACE_ERROR(DecodeError)
TRACE_ERROR(AllocError)
}


//+-------------------------------------------------------------------------
//  Verify a signature using the authenticated attributes blob
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_VerifySignatureAuthAttrBlob(
    IN PCRYPT_MSG_INFO  pcmi,
    IN CSignerNode      *pSignerNode,
    IN HCRYPTPROV       hCryptProv,
    IN HCRYPTKEY        hPubKey,
    IN DWORD            dwDigestAlgorithm,
    IN DWORD            dwPubKeyAlgorithm,
    IN DWORD            dwPubKeyFlags,
    IN PBYTE            pbEncryptedDigest,
    IN DWORD            cbEncryptedDigest)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithAABlob    *psiaab = NULL;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    HCRYPTHASH              hHashAttrBlob = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psiaab,
            SignerInfoWithAABlob_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoWithAABlobError;

    cb = psiaab->authenticatedAttributes.length;
    if (NULL == (pb = (PBYTE)ICM_AllocA(cb)))
        goto AuthenticatedAttributesAllocError;
    memcpy( pb, psiaab->authenticatedAttributes.value, cb);
    // The encoded blob should contain 0xa0 ([0] IMPLICIT) as the tag,
    // but the tag needs to be 0x31 (SET OF) for the hash computation.
    if (*pb != (ICM_TAG_CONTEXT_0 | ICM_TAG_CONSTRUCTED))   // [0] IMPLICIT
        goto AuthAttrsTagError;
    *pb = ICM_TAG_SET;          // SET OF

    if (!ICM_GetBlobHash(
            hCryptProv,
            dwDigestAlgorithm,
            pb,
            cb,
            &hHashAttrBlob))
        goto HashAttrBlobError;

    if (!ICM_VerifySignature(
            hHashAttrBlob,
            hPubKey,
            dwPubKeyAlgorithm,
            dwPubKeyFlags,
            pbEncryptedDigest,
            cbEncryptedDigest))
        goto VerifySignatureError;
    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithAABlob_PDU, psiaab);
    if (hHashAttrBlob)
        CryptDestroyHash( hHashAttrBlob);
    ICM_FreeA(pb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoWithAABlobError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(AuthAttrsTagError,CRYPT_E_BAD_ENCODE)
TRACE_ERROR(AuthenticatedAttributesAllocError)      // error already set
TRACE_ERROR(HashAttrBlobError)                      // error already set
TRACE_ERROR(VerifySignatureError)                   // error already set
}


#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_GetVerifySignatureStuff(
    IN DWORD            dwSignerType,
    void                *pvSigner,
    IN OUT HCRYPTPROV   *phCryptProv,
    OUT HCRYPTKEY       *phPubKey,
    OUT DWORD           *pdwPubKeyAlgId,
    OUT DWORD           *pdwPubKeyFlags)
{
    BOOL                    fRet;
    PCCRYPT_OID_INFO        pOIDInfo;
    HCRYPTPROV              hCryptProv;

    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo = NULL;    // not allocated
    CERT_PUBLIC_KEY_INFO    PubKeyInfo;
    BYTE                    *pbAllocPubKeyPara = NULL;

    *pdwPubKeyAlgId = 0;
    *pdwPubKeyFlags = 0;

    switch (dwSignerType) {
        case CMSG_VERIFY_SIGNER_PUBKEY:
            pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvSigner;
            break;
        case CMSG_VERIFY_SIGNER_CHAIN:
            {
                PCCERT_CHAIN_CONTEXT pChain = (PCCERT_CHAIN_CONTEXT) pvSigner;

                // All chains have at least the leaf certificate context
                assert(pChain->cChain && pChain->rgpChain[0]->cElement);
                pvSigner =
                    (void *) pChain->rgpChain[0]->rgpElement[0]->pCertContext;
                dwSignerType = CMSG_VERIFY_SIGNER_CERT;
            }
            // fall through
        case CMSG_VERIFY_SIGNER_CERT:
            {
                PCCERT_CONTEXT pSigner = (PCCERT_CONTEXT) pvSigner;
                PCRYPT_OBJID_BLOB pPara;

                pPubKeyInfo = &pSigner->pCertInfo->SubjectPublicKeyInfo;
                pPara = &pPubKeyInfo->Algorithm.Parameters;

                // Check if the public key parameters were omitted
                // from the encoded certificate. If omitted, try
                // to use the certificate's CERT_PUBKEY_ALG_PARA_PROP_ID
                // property.
                if (0 == pPara->cbData ||
                        ICM_TAG_NULL_OCTETS == *pPara->pbData) {
                    DWORD cbData;

                    if (CertGetCertificateContextProperty(
                            pSigner,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            NULL,                       // pvData
                            &cbData) && 0 < cbData
                                    &&
                        (pbAllocPubKeyPara = (BYTE *) ICM_Alloc(
                            cbData))
                                    &&
                        CertGetCertificateContextProperty(
                            pSigner,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            pbAllocPubKeyPara,
                            &cbData)) {

                        PubKeyInfo = *pPubKeyInfo;
                        PubKeyInfo.Algorithm.Parameters.pbData =
                            pbAllocPubKeyPara;
                        PubKeyInfo.Algorithm.Parameters.cbData = cbData;
                        pPubKeyInfo = &PubKeyInfo;
                    }
                }
            }
            break;
        case CMSG_VERIFY_SIGNER_NULL:
            break;
        default:
            goto InvalidSignerType;
    }

    if (CMSG_VERIFY_SIGNER_NULL == dwSignerType)
        ;
    else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pPubKeyInfo->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        *pdwPubKeyAlgId = pOIDInfo->Algid;
        if (1 <= cExtra)
            *pdwPubKeyFlags = pdwExtra[0];
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(*pdwPubKeyAlgId);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        *phCryptProv = hCryptProv;
    }

    if (CMSG_VERIFY_SIGNER_NULL == dwSignerType) {
        // The signature is simply the hash octets
        *pdwPubKeyAlgId = CALG_NO_SIGN;
        *phPubKey = NULL;

        // import the signer's public key
    } else if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            phPubKey))
        goto ImportKeyFailed;
    fRet = TRUE;
CommonReturn:
    ICM_Free(pbAllocPubKeyPara);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *phPubKey = 0;
    goto CommonReturn;
SET_ERROR(InvalidSignerType, E_INVALIDARG)
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(ImportKeyFailed)                    // error already set
}

BOOL
WINAPI
ICM_FindSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           *ppv);


//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignatureEx(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA pPara
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    HCRYPTHASH              hHashDup = NULL;
    HCRYPTHASH              hHash = NULL;
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTPROV              hCryptProv;         // doen't need to be released
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    PBYTE                   pbHash;
    ULONG                   cb;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;

    if (!ICM_FindSignerInfo(pcmi, pPara->dwSignerIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoWithBlobsError;

    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();

    if (pPara->hCryptProv)
        hCryptProv = pPara->hCryptProv;
    else if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;

    if (!ICM_GetVerifySignatureStuff(
            pPara->dwSignerType,
            pPara->pvSigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    if (psib->bit_mask & authAttributes_present) {
        // find the message digest attr value
        if (!ICM_GetAttrValue(
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &oidMessageDigest,
                &anyValue))
            goto FindAttrError;
        // find the message digest octets
        if (!Asn1UtilExtractContent(
#ifdef OSS_CRYPT_ASN1
                anyValue.value,
#else
                (const BYTE *) anyValue.value,
#endif  // OSS_CRYPT_ASN1
                anyValue.length,
                &cbMessageDigest,
                (const BYTE **)&pbMessageDigest))
            goto ExtractContentError;
        // get the hash value computed on the data
        if (!ICM_GetListHashValue( pnHash, &cb, &pbHash))
            goto GetHashValueError;
        // hash sizes equal?
        if (cb != cbMessageDigest)
            goto HashCompareSizeError;
        // hash octets equal?
        if (memcmp( pbMessageDigest, pbHash, cb))
            goto HashCompareValueError;
        // Now that we have verified the message digest octets,
        // get the hash of the authenticated attributes.
        // Should check the content type attribute as well.
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    // verify the hash, signature, and public key are consistent
    fRet = ICM_VerifySignature(
                hHash,
                hPubKey,
                dwPubKeyAlgId,
                dwPubKeyFlags,
                psib->encryptedDigest.value,
                psib->encryptedDigest.length);

    if (!fRet && hHashAttr) {
        // The hash of the authenticated attributes failed.
        // Maybe they hashed incorrectly-DER-encoded authenticated attributes
        // and gave us that encoding. Hash and verify the actual encoding of
        // the authattrs that they gave us. There is a bug in IE3.0 which hits
        // this path, due to a bug in the then-current OSS libraries.
        fRet = ICM_VerifySignatureAuthAttrBlob(
                        pcmi,
                        pSignerNode,
                        hCryptProv,
                        hPubKey,
                        pHashInfo->dwAlgoCAPI,
                        dwPubKeyAlgId,
                        dwPubKeyFlags,
                        psib->encryptedDigest.value,
                        psib->encryptedDigest.length);
    }
    if (!fRet)
        goto VerifySignatureError;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
//    if (hHash && (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)))
//        CryptDestroyHash( hHash);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FindSignerInfoError)            // error already set

SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetHashValueError)                  // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(GetSignatureStuffError)             // error already set
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(DupListHashError)                   // error already set
TRACE_ERROR(VerifySignatureError)               // error already set
dwFlags;
}

//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignature(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCERT_INFO pci)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    ULONG                   cbIssuer;
    PBYTE                   pb = NULL;
    ULONG                   cb;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CertIdentifier          *pOssCertId = NULL;
    IssuerAndSerialNumber   *pisn;              // not allocated
    DWORD                   dwSignerIndex;
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA ExPara;

    ZEROSTRUCT(ExPara);
    ExPara.cbSize = sizeof(ExPara);
    // ExPara.hCryptProv = 
    // ExPara.dwSignerIndex =
    ExPara.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
    ExPara.pvSigner = (void *) &pci->SubjectPublicKeyInfo;

    cb = pci->SerialNumber.cbData;
    if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
        goto SerialNumberAllocError;
    cbIssuer = pci->Issuer.cbData;

    switch (pcmi->dwMsgType) {
    case CMSG_SIGNED:
        {
            for (pSignerNode=pcmi->psdi->pSignerList->Head(), dwSignerIndex = 0;
                    pSignerNode;
                    pSignerNode = pSignerNode->Next(), dwSignerIndex++) {
                PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
                psib = NULL;
                PkiAsn1FreeInfo(pDec, CertIdentifier_PDU, pOssCertId);
                pOssCertId = NULL;
                DataBlob = pSignerNode->Data()->blob;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&psib,
                        SignerInfoWithBlobs_PDU,
                        DataBlob.pbData,
                        DataBlob.cbData)))
                    goto DecodeSignerInfoWithBlobsError;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&pOssCertId,
                        CertIdentifier_PDU,
                        (BYTE *) psib->sid.value,
                        psib->sid.length)))
                    goto DecodeCertIdentifierError;

                switch (pOssCertId->choice) {
                    case issuerAndSerialNumber_chosen:
                        pisn = &pOssCertId->u.issuerAndSerialNumber;
                        if (pisn->issuer.length != cbIssuer)
                            break;
                        if (0 != memcmp( pci->Issuer.pbData,
                                pisn->issuer.value, cbIssuer))
                            break;
                        // We need to add an integer method to compare
                        // big-endian internal to a little-endian external
                        // value.
                        if (pisn->serialNumber.length != cb)
                            break;
                        ICM_ReverseCopy( pb, pisn->serialNumber.value, cb);
                        if (0 == memcmp( pb, pci->SerialNumber.pbData, cb))
                            goto VerifyFoundSigner;
                        break;
                    case subjectKeyIdentifier_chosen:
                        // Go for it. See if we are able to verify using
                        // the public key for this signer
                        ExPara.dwSignerIndex = dwSignerIndex;
                        fRet = ICM_ControlVerifySignatureEx(
                            pcmi,
                            dwFlags,
                            &ExPara
                            );
                        if (fRet)
                            goto CommonReturn;
                        break;
                }
            }
            // No signer was found
            break;
        }

    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    assert(NULL == pSignerNode);
    goto SignerNotFound;

VerifyFoundSigner:
    ExPara.dwSignerIndex = dwSignerIndex;
    fRet = ICM_ControlVerifySignatureEx(
        pcmi,
        dwFlags,
        &ExPara
        );
    if (!fRet)
        goto ErrorReturn;

CommonReturn:
    ICM_FreeA( pb);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    PkiAsn1FreeInfo(pDec, CertIdentifier_PDU, pOssCertId);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR_VAR(DecodeCertIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(SignerNotFound,CRYPT_E_SIGNER_NOT_FOUND)
TRACE_ERROR(SerialNumberAllocError)             // error already set
}

#else

BOOL
WINAPI
ICM_GetVerifySignatureStuff(
    IN PCERT_INFO       pci,
    IN OUT HCRYPTPROV   *phCryptProv,
    OUT HCRYPTKEY       *phPubKey,
    OUT DWORD           *pdwPubKeyAlgId,
    OUT DWORD           *pdwPubKeyFlags)
{
    BOOL                    fRet;
    PCCRYPT_OID_INFO        pOIDInfo;
    HCRYPTPROV              hCryptProv;

    *pdwPubKeyAlgId = 0;
    *pdwPubKeyFlags = 0;
    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pci->SubjectPublicKeyInfo.Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        *pdwPubKeyAlgId = pOIDInfo->Algid;
        if (1 <= cExtra)
            *pdwPubKeyFlags = pdwExtra[0];
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(*pdwPubKeyAlgId);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        *phCryptProv = hCryptProv;
    }

    // import the signer's public key
    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            &pci->SubjectPublicKeyInfo,
            phPubKey))
        goto ImportKeyFailed;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *phPubKey = 0;
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(ImportKeyFailed)                    // error already set
}


//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignature(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCERT_INFO pci)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    SignerInfo              *psi = NULL;
    Any                     *pc;            // &content
    HCRYPTHASH              hHashAttr = NULL;
    HCRYPTHASH              hHashDup = NULL;
    HCRYPTHASH              hHash = NULL;
    HCRYPTKEY               hPubKey = NULL;

    HCRYPTPROV              hCryptProv;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;

    ULONG                   cbIssuer;
    PBYTE                   pbHash;
    PBYTE                   pb = NULL;
    ULONG                   cb;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    IssuerAndSerialNumber   *pisn = NULL;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;


    switch (pcmi->dwMsgType) {
    case CMSG_SIGNED:
        {
            pc = (Any *)&pcmi->psdi->pci->content;
            cb = pci->SerialNumber.cbData;
            if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
                goto SerialNumberAllocError;
            cbIssuer = pci->Issuer.cbData;
            for (pSignerNode=pcmi->psdi->pSignerList->Head();
                    pSignerNode;
                    pSignerNode = pSignerNode->Next()) {
                PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
                psib = NULL;
                PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
                pisn = NULL;

                DataBlob = pSignerNode->Data()->blob;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&psib,
                        SignerInfoWithBlobs_PDU,
                        DataBlob.pbData,
                        DataBlob.cbData)))
                    goto DecodeSignerInfoWithBlobsError;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&pisn,
                        IssuerAndSerialNumber_PDU,
                        (BYTE *) psib->issuerAndSerialNumber.value,
                        psib->issuerAndSerialNumber.length)))
                    goto DecodeIssuerAndSerialNumberError;
                if (pisn->issuer.length != cbIssuer)
                    continue;
                if (0 != memcmp( pci->Issuer.pbData, pisn->issuer.value, cbIssuer))
                    continue;
                // We need to add an integer method to compare big-endian
                // internal to a little-endian external value.
                if (pisn->serialNumber.length != cb)
                    continue;
                ICM_ReverseCopy( pb, pisn->serialNumber.value, cb);
                if (0 != memcmp( pb, pci->SerialNumber.pbData, cb))
                    continue;
                break;
            }
            // The matching signer (if found) is in psib
            // If no signer found, pSignerNode == NULL
            ICM_FreeA( pb);
            pb = NULL;
            break;
        }

    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == pSignerNode)
        goto SignerNotFound;
    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();


    if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;
    if (!ICM_GetVerifySignatureStuff(
            pci,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    if (psib->bit_mask & authAttributes_present) {
        // find the message digest attr value
        if (!ICM_GetAttrValue(
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &oidMessageDigest,
                &anyValue))
            goto FindAttrError;
        // find the message digest octets
        if (!Asn1UtilExtractContent(
                (BYTE *) anyValue.value,
                anyValue.length,
                &cbMessageDigest,
                (const BYTE **)&pbMessageDigest))
            goto ExtractContentError;
        // get the hash value computed on the data
        if (!ICM_GetListHashValue( pnHash, &cb, &pbHash))
            goto GetHashValueError;
        // hash sizes equal?
        if (cb != cbMessageDigest)
            goto HashCompareSizeError;
        // hash octets equal?
        if (memcmp( pbMessageDigest, pbHash, cb))
            goto HashCompareValueError;
        // Now that we have verified the message digest octets,
        // get the hash of the authenticated attributes.
        // Should check the content type attribute as well.
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    // verify the hash, signature, and public key are consistent
    fRet = ICM_VerifySignature(
                hHash,
                hPubKey,
                dwPubKeyAlgId,
                dwPubKeyFlags,
                psib->encryptedDigest.value,
                psib->encryptedDigest.length);

    if (!fRet && hHashAttr) {
        // The hash of the authenticated attributes failed.
        // Maybe they hashed incorrectly-DER-encoded authenticated attributes
        // and gave us that encoding. Hash and verify the actual encoding of
        // the authattrs that they gave us. There is a bug in IE3.0 which hits
        // this path, due to a bug in the then-current OSS libraries.
        fRet = ICM_VerifySignatureAuthAttrBlob(
                        pcmi,
                        pSignerNode,
                        hCryptProv,
                        hPubKey,
                        pHashInfo->dwAlgoCAPI,
                        dwPubKeyAlgId,
                        dwPubKeyFlags,
                        psib->encryptedDigest.value,
                        psib->encryptedDigest.length);
    }
    if (!fRet)
        goto VerifySignatureError;

CommonReturn:
    ICM_FreeA( pb);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
//    if (hHash && (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)))
//        CryptDestroyHash( hHash);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(SignerNotFound,CRYPT_E_SIGNER_NOT_FOUND)
TRACE_ERROR(SerialNumberAllocError)             // error already set
TRACE_ERROR(GetHashValueError)                  // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(GetSignatureStuffError)             // error already set
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(DupListHashError)                   // error already set
TRACE_ERROR(VerifySignatureError)               // error already set
dwFlags;
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Verify a digest
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifyDigest(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    BYTE            *pbComputedDigest = NULL;
    DWORD           cbComputedDigest = 0;
    BYTE            *pbDigest = NULL;
    DWORD           cbDigest = 0;

    if (CMSG_HASHED != pcmi->dwMsgType)
        goto InvalidMsgTypeError;

    // get the computed digest
    CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_COMPUTED_HASH_PARAM,
                    0,                      // dwIndex
                    NULL,                   // pvData
                    &cbComputedDigest);
    if (0 == cbComputedDigest)
        goto EmptyComputedDigestError;
    if (NULL == (pbComputedDigest = (PBYTE)ICM_AllocA( cbComputedDigest)))
        goto ComputedDigestAllocError;
    if (!CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_COMPUTED_HASH_PARAM,
                    0,                      // dwIndex
                    pbComputedDigest,
                    &cbComputedDigest))
        goto GetComputedDigestError;

    // get the digest from the message
    CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_HASH_DATA_PARAM,
                    0,                      // dwIndex
                    NULL,                   // pvData
                    &cbDigest);
    if (0 == cbDigest)
        goto EmptyDigestError;
    if (NULL == (pbDigest = (PBYTE)ICM_AllocA( cbDigest)))
        goto DigestAllocError;
    if (!CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_HASH_DATA_PARAM,
                    0,                      // dwIndex
                    pbDigest,
                    &cbDigest))
        goto GetDigestError;

    // compare the computed digest to the digest from the message
    if (cbComputedDigest != cbDigest)
        goto DigestSizesUnequalError;
    if (0 != memcmp( pbDigest, pbComputedDigest, cbDigest))
        goto DigestsDifferError;

    fRet = TRUE;

CommonReturn:
    ICM_FreeA( pbComputedDigest);
    ICM_FreeA( pbDigest);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EmptyComputedDigestError)   // error already set
TRACE_ERROR(ComputedDigestAllocError)   // error already set
TRACE_ERROR(GetComputedDigestError)     // error already set
TRACE_ERROR(EmptyDigestError)           // error already set
TRACE_ERROR(DigestAllocError)           // error already set
TRACE_ERROR(GetDigestError)             // error already set
SET_ERROR(DigestSizesUnequalError,CRYPT_E_HASH_VALUE)
SET_ERROR(DigestsDifferError,CRYPT_E_HASH_VALUE)
SET_ERROR(InvalidMsgTypeError,CRYPT_E_INVALID_MSG_TYPE)
dwFlags;
}

#ifdef CMS_PKCS7

CmsRecipientInfos *
WINAPI
ICM_GetDecodedCmsRecipientInfos(
    IN PCRYPT_MSG_INFO pcmi
    )
{
    PCMSG_STREAM_INFO pcsi = pcmi->pStreamInfo;
    CmsRecipientInfos *pris = NULL;

    if (pcmi->fEncoding)
        goto InvalidMsgType;
    if (pcsi && (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
        goto StreamMsgNotReadyError;
    if (NULL == pcmi->pvMsg)
        goto NotUpdated;

    switch (pcmi->dwMsgType) {
        case CMSG_ENVELOPED:
            pris = &((CmsEnvelopedData *)pcmi->pvMsg)->recipientInfos;
            break;

        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;

        default:
            goto InvalidMsgType;
    }

CommonReturn:
    return pris;

ErrorReturn:
    goto CommonReturn;

SET_ERROR(InvalidMsgType, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(NotUpdated, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(StreamMsgNotReadyError, CRYPT_E_STREAM_MSG_NOT_READY)
SET_ERROR(MessageTypeNotSupportedYet, CRYPT_E_INVALID_MSG_TYPE)
}

BOOL
WINAPI
ICM_ConvertPkcsToCmsRecipientIndex(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwPkcsIndex,
    OUT DWORD *pdwCmsIndex
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwCmsIndex;
    DWORD i;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    pri = pris->value;
    dwCmsIndex = dwPkcsIndex;
    i = 0;
    for ( ; 0 < dwCount; dwCount--, pri++) {
        if (keyTransRecipientInfo_chosen != pri->choice) {
            // Advance past non KeyTrans recipients
            dwCmsIndex++;
        } else {
            if (i == dwPkcsIndex)
                goto SuccessReturn;
            else
                i++;
        }
    }

    goto IndexTooBig;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    *pdwCmsIndex = dwCmsIndex;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    dwCmsIndex = 0xFFFFFFFF;
    goto CommonReturn;
TRACE_ERROR(GetDecodedCmsRecipientsError)
SET_ERROR(IndexTooBig, CRYPT_E_INVALID_INDEX)
}

BOOL
WINAPI
ICM_ConvertCmsToPkcsRecipientIndex(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwCmsIndex,
    OUT DWORD *pdwPkcsIndex
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwPkcsIndex;
    DWORD i;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    if (dwCmsIndex >= dwCount)
        goto InvalidCmsIndex;
    pri = &pris->value[dwCmsIndex];
    if (keyTransRecipientInfo_chosen != pri->choice)
        goto InvalidPkcsIndex;

    pri = pris->value;
    dwPkcsIndex = 0;
    for (i = 0; i < dwCmsIndex; i++, pri++) {
        if (keyTransRecipientInfo_chosen == pri->choice)
            dwPkcsIndex++;
    }

    fRet = TRUE;
CommonReturn:
    *pdwPkcsIndex = dwPkcsIndex;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    dwPkcsIndex = 0xFFFFFFFF;
    goto CommonReturn;

TRACE_ERROR(GetDecodedCmsRecipientsError)
SET_ERROR(InvalidCmsIndex, CRYPT_E_INVALID_INDEX)
SET_ERROR(InvalidPkcsIndex, CRYPT_E_INVALID_INDEX)
}

BOOL
WINAPI
ICM_GetPkcsRecipientCount(
    IN PCRYPT_MSG_INFO pcmi,
    OUT DWORD *pdwPkcsCount
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwPkcsCount;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    pri = pris->value;
    dwPkcsCount = 0;
    for ( ; 0 < dwCount; dwCount--, pri++) {
        if (keyTransRecipientInfo_chosen == pri->choice)
            dwPkcsCount++;
    }

    fRet = TRUE;
CommonReturn:
    *pdwPkcsCount = dwPkcsCount;
    return fRet;

ErrorReturn:
    dwPkcsCount = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDecodedCmsRecipientsError)
}


typedef BOOL (WINAPI *PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) (
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN void *pvDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );

BOOL
WINAPI
ICM_ImportContentEncryptKey(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN void *pvDecryptPara,
    IN HCRYPTOIDFUNCADDR hImportContentEncryptKeyFuncSet,
    IN LPSTR pszKeyEncryptionOID,
    IN PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY pDefaultImportContentEncryptKey,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{

    BOOL fRet;
    DWORD i;

#define IMPORT_CONTENT_ENCRYPT_OID_CNT  3
    LPSTR rgpszOID[IMPORT_CONTENT_ENCRYPT_OID_CNT] = {
        NULL,                       // pszKeyEncryptOID!pszContentEncryptOID
        pszKeyEncryptionOID,
        pContentEncryptionAlgorithm->pszObjId
    };

    DWORD cch;
    LPSTR psz;

    cch = strlen(rgpszOID[1]) + 1 + strlen(rgpszOID[2]) + 1;

    if (NULL == (psz = (LPSTR) ICM_Alloc(cch))) {
        *phContentEncryptKey = 0;
        return FALSE;
    }
    strcpy(psz, rgpszOID[1]);
    strcat(psz, "!");
    strcat(psz, rgpszOID[2]);
    rgpszOID[0] = psz;

    for (i = 0; i < IMPORT_CONTENT_ENCRYPT_OID_CNT; i++) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (CryptGetOIDFunctionAddress(
                hImportContentEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                rgpszOID[i],
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            fRet = ((PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) pvFuncAddr)(
                pContentEncryptionAlgorithm,
                pvDecryptPara,
                0,                              // dwFlags
                NULL,                           // pvReserved
                phContentEncryptKey
                );
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);

            if (fRet || E_NOTIMPL != GetLastError())
                goto CommonReturn;
        }
    }

    fRet = pDefaultImportContentEncryptKey(
        pContentEncryptionAlgorithm,
        pvDecryptPara,
        0,                              // dwFlags
        NULL,                           // pvReserved
        phContentEncryptKey
        );

CommonReturn:
    ICM_Free(rgpszOID[0]);
    return fRet;
}

HCRYPTKEY
WINAPI
ICM_ImportEncryptedKey(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN HCRYPTPROV hCryptProv,
    IN HCRYPTKEY hUserKey,
    IN ALG_ID aiEncAlg,
    IN BYTE bType,
    IN PCRYPT_DATA_BLOB pEncryptedKey
    )
{
    BOOL fRet;
    DWORD dwError;
    HCRYPTKEY hEncryptKey = 0;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;

    PBYTE pbCspKey = NULL;
    DWORD cbCspKey;
    PUBLICKEYSTRUC *ppks;
    PSIMPLEBLOBHEADER psbh;

    if (!ICM_GetEncryptParameters(
            pContentEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;

    cbCspKey = sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER) +
        pEncryptedKey->cbData;
    if (NULL == (pbCspKey = (PBYTE)ICM_AllocA( cbCspKey)))
        goto CspKeyAllocError;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = bType;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = aiEncAlg;
    if (SYMMETRICWRAPKEYBLOB == bType)
        memcpy( (PBYTE)(psbh+1), pEncryptedKey->pbData,
            pEncryptedKey->cbData);
    else
        ICM_ReverseCopy( (PBYTE)(psbh+1), pEncryptedKey->pbData,
            pEncryptedKey->cbData);

    fRet = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            hUserKey,
            CRYPT_NO_SALT,       // dwFlags
            &hEncryptKey);

    if (!fRet) {
        hEncryptKey = 0;
        goto ImportKeyFailed;
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV
            BOOL fRC4Salt = TRUE;

            if (IV_LENGTH == cbIV) {
                // Old implementations of 40 bit or 128 bit RC4 set the
                // IV which was ignored and didn't set the salt.

                // Get the bit length of the imported key and don't
                // set the salt for 40 or 128 bit RC4.

                DWORD dwRC4BitLen;
                DWORD cbKeyParamLen;

                dwRC4BitLen = 0;
                cbKeyParamLen = sizeof(dwRC4BitLen);
                if (!CryptGetKeyParam(
                        hEncryptKey,
                        KP_KEYLEN,
                        (PBYTE) &dwRC4BitLen,
                        &cbKeyParamLen,
                        0                       // dwFlags
                        ) || 40 == dwRC4BitLen || 128 == dwRC4BitLen)
                    fRC4Salt = FALSE;
            }

            if (fRC4Salt) {
                CRYPT_DATA_BLOB SaltBlob;
                SaltBlob.pbData = rgbIV;
                SaltBlob.cbData = cbIV;

                if (!CryptSetKeyParam(
                        hEncryptKey,
                        KP_SALT_EX,
                        (PBYTE) &SaltBlob,
                        0))                 // dwFlags
                    goto SetSaltExError;
            }
        } else {
            if (!CryptSetKeyParam(
                    hEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

CommonReturn:
    ICM_FreeA(pbCspKey);
    return hEncryptKey;

ErrorReturn:
    if (hEncryptKey) {
        dwError = GetLastError();
        CryptDestroyKey(hEncryptKey);
        SetLastError(dwError);
        hEncryptKey = 0;
    }
    goto CommonReturn;
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(ImportKeyFailed)
TRACE_ERROR(CspKeyAllocError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultImportKeyTrans(
#else
ICM_DefaultImportKeyTrans(
#endif
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fRet;
    HCRYPTKEY hUserKey = 0;
    PCMSG_KEY_TRANS_RECIPIENT_INFO pri = pKeyTransDecryptPara->pKeyTrans;
    HCRYPTPROV hCryptProv = pKeyTransDecryptPara->hCryptProv;

    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hOldStyleImportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pContentEncryptionAlgorithm->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        if ((void *) ICM_DefaultImportEncryptKey == pvFuncAddr)
            fRet = FALSE;
#ifdef DEBUG_CRYPT_ASN1
        else if (0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
            fRet = FALSE;
#endif // DEBUG_CRYPT_ASN1
        else
            fRet = ((PFN_CMSG_IMPORT_ENCRYPT_KEY) pvFuncAddr)(
                hCryptProv,
                pKeyTransDecryptPara->dwKeySpec,
                pContentEncryptionAlgorithm,
                &pri->KeyEncryptionAlgorithm,
                pri->EncryptedKey.pbData,
                pri->EncryptedKey.cbData,
                phContentEncryptKey);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);

        if (fRet)
            return TRUE;
    }

    if (0 != pKeyTransDecryptPara->dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                pKeyTransDecryptPara->dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hCryptProv,
            hUserKey,
            CALG_RSA_KEYX,
            SIMPLEBLOB,
            &pri->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyAgree(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hKeyAgreeProv = 0;           // Doesn't need to be released
    HCRYPTKEY hMyKey = 0;
    HCRYPTKEY hAgreeKey = 0;
    DWORD cbP;
    DWORD dwKeySpec;
    LPSTR pszWrapOID = NULL;
    DWORD dwAlgIdWrap;
    DWORD dwBitLen;
    PCMSG_KEY_AGREE_RECIPIENT_INFO pri = pKeyAgreeDecryptPara->pKeyAgree;

    hKeyAgreeProv = pKeyAgreeDecryptPara->hCryptProv;

    dwKeySpec = pKeyAgreeDecryptPara->dwKeySpec;
    if (0 == dwKeySpec)
        dwKeySpec = AT_KEYEXCHANGE;

    // Get my private Diffie Hellman key
    if (!CryptGetUserKey(
            hKeyAgreeProv,
            pKeyAgreeDecryptPara->dwKeySpec,
            &hMyKey)) {
        hMyKey = 0;
        goto GetMyKeyFailed;
    }

    // Get the length of P
    cbP = 0;
    if (!CryptGetKeyParam(
            hMyKey,
            KP_P,
            NULL,               // pbData
            &cbP,
            0                   // dwFlags
            ) || 0 == cbP)
        goto GetPLengthError;

    if (!ICM_GetDhWrapEncryptParameters(
            &pri->KeyEncryptionAlgorithm,
            &pszWrapOID,                    // allocated
            &dwAlgIdWrap,
            &dwBitLen))
        goto GetDhWrapEncryptParametersError;

    if (0 == (hAgreeKey = ICM_ImportDhAgreeKey(
            hKeyAgreeProv,
            hMyKey,
            cbP,
            &pKeyAgreeDecryptPara->OriginatorPublicKey,
            pszWrapOID,
            dwAlgIdWrap,
            dwBitLen,
            &pri->UserKeyingMaterial
            )))
        goto ImportDhAgreeKeyError;

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hKeyAgreeProv,
            hAgreeKey,
            dwAlgIdWrap,
            SYMMETRICWRAPKEYBLOB,
            &pri->rgpRecipientEncryptedKeys[
                pKeyAgreeDecryptPara->dwRecipientEncryptedKeyIndex]->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    ICM_Free(pszWrapOID);
    if (hAgreeKey)
        CryptDestroyKey(hAgreeKey);
    if (hMyKey)
        CryptDestroyKey(hMyKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetMyKeyFailed)
TRACE_ERROR(GetPLengthError)
TRACE_ERROR(GetDhWrapEncryptParametersError)
TRACE_ERROR(ImportDhAgreeKeyError)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportMailList(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hMailListProv = 0;           // not released
    HCRYPTKEY hKeyEncryptionKey = 0;        // not destroyed
    PCMSG_MAIL_LIST_RECIPIENT_INFO pri = pMailListDecryptPara->pMailList;

    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;

    hMailListProv = pMailListDecryptPara->hCryptProv;
    switch (pMailListDecryptPara->dwKeyChoice) {
        case CMSG_MAIL_LIST_HANDLE_KEY_CHOICE:
            hKeyEncryptionKey = pMailListDecryptPara->hKeyEncryptionKey;
            assert(hMailListProv && hKeyEncryptionKey);
            if (0 == hMailListProv || 0 == hKeyEncryptionKey)
                goto InvalidMailListHandleKeyPara;
            break;
        default:
            goto InvalidMailListKeyChoice;
    }

    if (!ICM_GetWrapEncryptParameters(
            &pri->KeyEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen))
        goto GetWrapEncryptParametersError;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hKeyEncryptionKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hMailListProv,
            hKeyEncryptionKey,
            dwAlgIdEncrypt,
            SYMMETRICWRAPKEYBLOB,
            &pri->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidMailListHandleKeyPara, E_INVALIDARG)
SET_ERROR(InvalidMailListKeyChoice, E_INVALIDARG)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//  Default import of the encryption key (OldStyle)
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    HCRYPTKEY               hUserKey = 0;
    CRYPT_DATA_BLOB         EncryptedKey;

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    EncryptedKey.cbData = cbEncodedKey;
    EncryptedKey.pbData = pbEncodedKey;
    if (0 == (*phEncryptKey = ICM_ImportEncryptedKey(
            paiEncrypt,
            hCryptProv,
            hUserKey,
            CALG_RSA_KEYX,
            SIMPLEBLOB,
            &EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportEncryptedKeyError)
}


//+-------------------------------------------------------------------------
//  Decrypt the content using any CMS recipient type
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlCmsDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN void *pvDecryptPara,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwRecipientIndex,
    IN HCRYPTOIDFUNCADDR hImportContentEncryptKeyFuncSet,
    IN LPSTR pszKeyEncryptionOID,
    IN PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY pDefaultImportContentEncryptKey
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    EncryptedContentInfo    *peci = NULL;
    HCRYPTKEY               hkeySeal = NULL;
    PBYTE                   pbData = NULL;
    LONG                    cbData;
    AlgorithmIdentifier     *paiOssContentEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiContentEncryption = NULL;
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    if( pcmi->Plaintext.pbData)
        goto MessageAlreadyDecrypted;

    switch (pcmi->dwMsgType) {
    case CMSG_ENVELOPED:
        {
            CmsEnvelopedData   *ped;

            ped = (CmsEnvelopedData *)pcmi->pvMsg;
            if (NULL == ped)
                goto NotUpdated;
            if (dwRecipientIndex >= ped->recipientInfos.count)
                goto RecipientIndexTooLarge;
            peci = &ped->encryptedContentInfo;
            paiOssContentEncryption =
                    &ped->encryptedContentInfo.contentEncryptionAlgorithm;
            break;
        }
    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == (paiContentEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssContentEncryption)))
        goto GetEncryptAlgorithmError;

    if (!ICM_ImportContentEncryptKey(
            paiContentEncryption,
            pvDecryptPara,
            hImportContentEncryptKeyFuncSet,
            pszKeyEncryptionOID,
            pDefaultImportContentEncryptKey,
            &hkeySeal))
        goto ImportKeyError;

    if (pcsi) {
        if (!ICMS_SetDecryptKey( pcmi, hkeySeal))
            goto SetDecryptKeyError; // NB- Do not trash err from callback!
        hkeySeal = NULL;
    } else {
        // NB- For common bulk encryption algos,
        // sizeof(plaintext)<=sizeof(ciphertext)
        if (peci->bit_mask & encryptedContent_present)
            cbData = peci->encryptedContent.length;
        else
            cbData = 0;
        if (NULL == (pbData = (PBYTE)ICM_Alloc( cbData)))
            goto EncryptedContentAllocError;
        if (cbData ) {
            memcpy( pbData, peci->encryptedContent.value, cbData);
            if (!CryptDecrypt(
                    hkeySeal,
                    NULL,
                    TRUE,               // fFinal
                    0,                  // dwFlags
                    pbData,
                    (PDWORD)&cbData))
                goto DecryptError;
        }
        CryptDestroyKey( hkeySeal);
        hkeySeal = NULL;

        pcmi->Plaintext.cbData = cbData;
        pcmi->Plaintext.pbData = pbData;
        pbData = NULL;
    }

    if (dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG)
        pcmi->hCryptProvContentCrypt = hCryptProv;
    pcmi->dwDecryptedRecipientIndex = dwRecipientIndex;

    fRet = TRUE;
CommonReturn:
    ICM_Free(paiContentEncryption);
    ICM_Free(pbData);
    if (hkeySeal)
        CryptDestroyKey( hkeySeal);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(MessageAlreadyDecrypted,CRYPT_E_ALREADY_DECRYPTED)
SET_ERROR(RecipientIndexTooLarge, CRYPT_E_INVALID_INDEX)
SET_ERROR(NotUpdated, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(GetEncryptAlgorithmError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(EncryptedContentAllocError)
TRACE_ERROR(SetDecryptKeyError)
TRACE_ERROR(DecryptError)
}


//+-------------------------------------------------------------------------
//  Decrypt the content using only a PKCS 1.5 recipient type
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlPkcsDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCMSG_CTRL_DECRYPT_PARA pmcdp
    )
{
    BOOL fRet;
    CMSG_CTRL_KEY_TRANS_DECRYPT_PARA KeyTransDecryptPara;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    DWORD dwCmsIndex;

    assert( pmcdp->cbSize >= sizeof(*pmcdp));
    if (pmcdp->cbSize < sizeof(*pmcdp))
        goto InvalidArg;

    if (!ICM_ConvertPkcsToCmsRecipientIndex(
            pcmi, pmcdp->dwRecipientIndex, &dwCmsIndex))
        goto ConvertPkcsToCmsRecipientIndexError;

    if (NULL == (pRecipientInfo =
        (PCMSG_CMS_RECIPIENT_INFO) ICM_AllocAndGetParam(
            pcmi, CMSG_CMS_RECIPIENT_INFO_PARAM, dwCmsIndex)))
        goto GetCmsRecipientInfoParamError;

    assert(CMSG_KEY_TRANS_RECIPIENT == pRecipientInfo->dwRecipientChoice);

    memset(&KeyTransDecryptPara, 0, sizeof(KeyTransDecryptPara));
    KeyTransDecryptPara.cbSize = sizeof(KeyTransDecryptPara);
    KeyTransDecryptPara.hCryptProv = pmcdp->hCryptProv;
    KeyTransDecryptPara.dwKeySpec = pmcdp->dwKeySpec;
    KeyTransDecryptPara.pKeyTrans = pRecipientInfo->pKeyTrans;
    KeyTransDecryptPara.dwRecipientIndex = dwCmsIndex;

    fRet = ICM_ControlCmsDecrypt(
        pcmi,
        dwFlags,
        &KeyTransDecryptPara,
        KeyTransDecryptPara.hCryptProv,
        dwCmsIndex,
        hImportKeyTransFuncSet,
        KeyTransDecryptPara.pKeyTrans->KeyEncryptionAlgorithm.pszObjId,
        (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyTrans
        );

CommonReturn:
    ICM_Free(pRecipientInfo);
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ConvertPkcsToCmsRecipientIndexError)
TRACE_ERROR(GetCmsRecipientInfoParamError)
}

#else
//+-------------------------------------------------------------------------
//  Default import of the encryption key
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    HCRYPTKEY               hEncryptKey = 0;
    HCRYPTKEY               hUserKey = 0;
    DWORD                   dwAlgIdEncrypt;
    DWORD                   dwAlgIdPubKey;
    PBYTE                   pbCspKey = NULL;
    DWORD                   cbCspKey;
    PUBLICKEYSTRUC          *ppks;
    PSIMPLEBLOBHEADER       psbh;

    BYTE                    rgbIV[IV_LENGTH];
    DWORD                   cbIV;
    DWORD                   dwBitLen;

    if (!ICM_GetEncryptParameters(
            paiEncrypt,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;
#if 0
    if (!ICM_GetOssCAPI(
            CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            paiPubKey,
            &dwAlgIdPubKey))
        goto PubKeyGetCAPIError;
#else
    // We have no idea what the right values are for the alg id's here.
    dwAlgIdPubKey = CALG_RSA_KEYX;
#endif
    cbCspKey = cbEncodedKey + sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);
    if (NULL == (pbCspKey = (PBYTE)ICM_AllocA( cbCspKey)))
        goto CspKeyAllocError;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = SIMPLEBLOB;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = dwAlgIdPubKey;
    ICM_ReverseCopy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    fRet = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            hUserKey,
            CRYPT_NO_SALT,       // dwFlags
            &hEncryptKey);
    if (!fRet) {
        dwError = GetLastError();
        if (hUserKey) {
            if (NTE_BAD_FLAGS == dwError)
                // Try without salt. Previous versions didn't support
                // CRYPT_NO_SALT flag
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    hUserKey,
                    0,       // dwFlags
                    &hEncryptKey);
            if (!fRet) {
                // Try without using the specified user key. Many versions of
                // the CSP don't allow a non-null hUserKey parameter.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,                  // hUserKey
                    CRYPT_NO_SALT,      // dwFlags
                    &hEncryptKey);
                if (!fRet)
                    dwError = GetLastError();

            }
        }

        if (!fRet && NTE_BAD_FLAGS == dwError)
            // Try without user key and without CRYPT_NO_SALT flag
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                0,          // hUserKey
                0,          // dwFlags
                &hEncryptKey);

        if (!fRet && 2 >= paiEncrypt->Parameters.cbData) {
            // Try importing as an NT4.0 SP3 encypted key that wasn't byte
            // reversed and with zero salt.
            memcpy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                hUserKey,
                0,          // dwFlags
                &hEncryptKey);
            if (!fRet && hUserKey) {
                // Try without using the specified user key.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,          // hUserKey
                    0,          // dwFlags
                    &hEncryptKey);
            }
        }

        if (!fRet) {
            hEncryptKey = 0;
            goto ImportKeyFailed;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (!CryptSetKeyParam(
                hEncryptKey,
                KP_IV,
                rgbIV,
                0))                 // dwFlags
            goto SetKeyParamError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_FreeA(pbCspKey);
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    *phEncryptKey = hEncryptKey;
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetEncryptParametersError)
//SET_ERROR(PubKeyGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportKeyFailed)
TRACE_ERROR(CspKeyAllocError)
TRACE_ERROR(SetKeyParamError)
}


//+-------------------------------------------------------------------------
//  Import the encryption key
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hImportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            paiEncrypt->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_IMPORT_ENCRYPT_KEY) pvFuncAddr)(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultImportEncryptKey(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decrypt the content
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN void *pvCtrlPara)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    PCMSG_CTRL_DECRYPT_PARA  pmcdp;
    RecipientInfo           *pri = NULL;
    EncryptedContentInfo    *peci = NULL;
    HCRYPTKEY               hkeySeal = NULL;
    PBYTE                   pbData = NULL;
    LONG                    cbData;
    AlgorithmIdentifier     *paiOssContentEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiContentEncryption = NULL;
    AlgorithmIdentifier     *paiOssKeyEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiKeyEncryption = NULL;
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    pmcdp = (PCMSG_CTRL_DECRYPT_PARA)pvCtrlPara;
    assert( pmcdp->cbSize >= sizeof(CMSG_CTRL_DECRYPT_PARA));
    if (pmcdp->cbSize < sizeof(CMSG_CTRL_DECRYPT_PARA))
        goto InvalidArg;

    if (dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG)
        pcmi->hCryptProvContentCrypt = pmcdp->hCryptProv;

    if( pcmi->Plaintext.pbData)
        goto MessageAlreadyDecrypted;

    switch (pcmi->dwMsgType) {
    case CMSG_ENVELOPED:
        {
            EnvelopedData   *ped;

            ped = (EnvelopedData *)pcmi->pvMsg;
            peci = &ped->encryptedContentInfo;
            if (pmcdp->dwRecipientIndex >= ped->recipientInfos.count)
                goto RecipientIndexTooLarge;
            pri = ped->recipientInfos.value + pmcdp->dwRecipientIndex;
            paiOssContentEncryption =
                    &ped->encryptedContentInfo.contentEncryptionAlgorithm;
            paiOssKeyEncryption = &pri->keyEncryptionAlgorithm;
            break;
        }
    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == pri)
        goto RecipientNotFound;         // really NULL if not found?

    if (NULL == (paiContentEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssContentEncryption)))
        goto GetEncryptAlgorithmError;
    if (NULL == (paiKeyEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssKeyEncryption)))
        goto GetKeyAlgorithmError;
    if (!ICM_ImportEncryptKey(
            pmcdp->hCryptProv,
            pmcdp->dwKeySpec,
            paiContentEncryption,
            paiKeyEncryption,
            pri->encryptedKey.value,
            pri->encryptedKey.length,
            &hkeySeal))
        goto ImportKeyError;

    if (pcsi) {
        if (!ICMS_SetDecryptKey( pcmi, hkeySeal))
            goto SetDecryptKeyError; // NB- Do not trash err from callback!
        hkeySeal = NULL;
    } else {
        // NB- For common bulk encryption algos,
        // sizeof(plaintext)<=sizeof(ciphertext)
        cbData = peci->encryptedContent.length;
        if (NULL == (pbData = (PBYTE)ICM_Alloc( cbData)))
            goto EncryptedContentAllocError;
        memcpy( pbData, peci->encryptedContent.value, cbData);
        if (!CryptDecrypt(
                hkeySeal,
                NULL,
                TRUE,               // fFinal
                0,                  // dwFlags
                pbData,
                (PDWORD)&cbData))
            goto DecryptError;
        CryptDestroyKey( hkeySeal);
        hkeySeal = NULL;

        pcmi->Plaintext.cbData = cbData;
        pcmi->Plaintext.pbData = pbData;
        pbData = NULL;
    }

    pcmi->dwDecryptedRecipientIndex = pmcdp->dwRecipientIndex;

    fRet = TRUE;
CommonReturn:
    ICM_Free(paiContentEncryption);
    ICM_Free(paiKeyEncryption);
    ICM_Free( pbData);
    if (hkeySeal)
        CryptDestroyKey( hkeySeal);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(MessageAlreadyDecrypted,CRYPT_E_ALREADY_DECRYPTED)
SET_ERROR(RecipientIndexTooLarge,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(RecipientNotFound,CRYPT_E_RECIPIENT_NOT_FOUND)
TRACE_ERROR(GetEncryptAlgorithmError)
TRACE_ERROR(GetKeyAlgorithmError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(EncryptedContentAllocError)
TRACE_ERROR(SetDecryptKeyError)
TRACE_ERROR(DecryptError)
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Hash the content of a message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT HCRYPTHASH   hHash)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    HCRYPTMSG   hCryptMsg = (HCRYPTMSG)pcmi;
    PBYTE       pbAllocData = NULL;
    PBYTE       pbData;
    DWORD       cbData;

    cbData = 0;
    CryptMsgGetParam(
            hCryptMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            NULL,
            &cbData);
    if (0 == cbData)
        goto GetContentSizeError;
    if (NULL == (pbAllocData = (PBYTE)ICM_Alloc(cbData)))
        goto AllocContentError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbAllocData,
            &cbData))
        goto GetContentError;

    pbData = pbAllocData;

    if (0 != strcmp(pszObjIdDataType, pcmi->psdi->pci->pszContentType)
#ifdef CMS_PKCS7
            &&  pcmi->psdi->version < CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                ) {
        // Leading tag and length octets aren't included in the digest
        if (0 > Asn1UtilExtractContent( pbData, cbData, &cbData,
                    (const BYTE **)&pbData))
            goto ExtractContentError;
    }

    if (!ICM_UpdateDigest( hHash, pbData, cbData))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    ICM_Free( pbAllocData);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetContentSizeError)    // error already set
TRACE_ERROR(AllocContentError)      // error already set
TRACE_ERROR(GetContentError)        // error already set
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(UpdateDigestError)      // error already set
}


//+-------------------------------------------------------------------------
//  Add a signer to a signed-data or signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddSigner(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN PCMSG_SIGNER_ENCODE_INFO psei)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    CHashNode           *pnHash;
    CSignerNode         *pnSigner;
    DWORD               dwAlgoCAPI;
    SignerInfo          *psi = NULL;
    Attribute           *pAuthAttr;
    DWORD               cAuthAttr;
    Attribute           *pUnauthAttr;
    DWORD               cUnauthAttr;
    LPSTR               pszInnerContentObjID;
    ICM_HASH_INFO       HashInfo;               ZEROSTRUCT(HashInfo);
    AlgorithmIdentifier oaiHash;
    CBlobNode           *pnBlob;
    CRYPT_DATA_BLOB     blobHashAlgo;           ZEROSTRUCT(blobHashAlgo);
    SIGNER_DATA_INFO    sdi;                    ZEROSTRUCT(sdi);

#ifdef CMS_PKCS7
    SIGNER_ENCODE_DATA_INFO SignerEncodeDataInfo;
#endif  // CMS_PKCS7

    // if the hash algorithm matches one of the ones already in use,
    //      get that hash and encrypt it
    // else
    //      hash the data again and add hash algo to top-level list
    //      [NB- must access data again]

    // Search for a hash node with a matching hash algorithm
    if (!(ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &psei->HashAlgorithm,
            &dwAlgoCAPI) ||
          ICM_GetCAPI(
            CRYPT_SIGN_ALG_OID_GROUP_ID,
            &psei->HashAlgorithm,
            &dwAlgoCAPI)))
        goto GetCAPIError;

    // before, this could have never failed, but now it can
    // only create a hash node if the hash didn't exists.
    if (!ICM_FindHashNodeFromCapiAlgid( pcmi->pHashList, dwAlgoCAPI, &pnHash)  &&
        GetLastError() != CRYPT_E_UNKNOWN_ALGO)
        goto FindHashNodeFromCapiAlgidError;

    if (!pnHash) {
        // New hash.
        // 1. Create hash node
        // 2. Hash the data
        // 3. Add hash node to pcmi->pHashList
        // 4. Encode this hash algo and add to pcmi->psdi->pAlgidList
        HashInfo.dwAlgoCAPI = dwAlgoCAPI;
#ifndef CMS_PKCS7
        HashInfo.hCryptProv = psei->hCryptProv;
#endif  // CMS_PKCS7
        if (!CryptCreateHash(
                        psei->hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (!ICM_HashContent( pcmi, HashInfo.hHash))    // hash content
            goto HashContentError;
        if (NULL == (pnHash = new CHashNode))
            goto NewHashNodeError;
        pnHash->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pnHash);

        // Convert the hash algorithm to a blob and
        // add to pcmi->psdi->pAlgidList.
        if (!ICM_MsgAsn1ToAlgorithmIdentifier(
                pcmi,
                &psei->HashAlgorithm,
                &oaiHash))
            goto MsgAsn1ToAlgorithmIdentifierError;
        if (!ICM_Asn1Encode(
                AlgorithmIdentifier_PDU,
                &oaiHash,
                &blobHashAlgo))
            goto EncodeHashAlgorithmError;
        if (NULL == (pnBlob = new CBlobNode))
            goto NewBlobNodeError;
        pnBlob->SetData( &blobHashAlgo);
        pcmi->psdi->pAlgidList->InsertTail( pnBlob);
    }

    // Alloc and fill in a SignerInfo

    pszInnerContentObjID = pcmi->psdi->pci->pszContentType;
    if (!strcmp( pszInnerContentObjID, pszObjIdDataType))
        pszInnerContentObjID = NULL;

    // NB - Each SignerInfo gets a non-empty authenticatedAttributes
    //      if the inner contentType is not data (passed in) or if
    //      there are authenticated attributes passed in. In this case,
    //      we reserve two Attribute slots at the beginning of the array
    //      for the content-type and message-digest Attribute values.
    cAuthAttr = 0;
    if (pszInnerContentObjID ||
            psei->cAuthAttr ||
            (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG)) {
        cAuthAttr = psei->cAuthAttr + 2;        // reserve 2
    }
    cUnauthAttr = psei->cUnauthAttr;
    psi = (SignerInfo *)ICM_AllocZero(                sizeof( SignerInfo) +
                                        cAuthAttr   * sizeof( Attribute) +
                                        cUnauthAttr * sizeof( Attribute)
                                     );
    if (NULL == psi)
        goto SignerInfoAllocError;
    pAuthAttr = (Attribute *)(psi + 1);
    pUnauthAttr = pAuthAttr + cAuthAttr;

    if (!ICM_FillAsnSignerInfo(
            psei,
            pcmi,
            dwFlags,
            pszInnerContentObjID,
            psi,
            &pAuthAttr,
            &pUnauthAttr))
        goto FillAsnSignerInfoError;

#ifdef CMS_PKCS7
    SignerEncodeDataInfo.hCryptProv = psei->hCryptProv;
    SignerEncodeDataInfo.dwKeySpec = psei->dwKeySpec;
    SignerEncodeDataInfo.pHashNode = pnHash;
    if (!ICM_FillSignerEncryptedDigest(
            psi,
            pszInnerContentObjID,
            &SignerEncodeDataInfo,
            FALSE))             // fMaxLength
        goto FillSignerEncryptedDigestError;
#else
    if (!ICM_FillSignerEncryptedDigest(
            psi,
            pszInnerContentObjID,
            pnHash,
            psei->dwKeySpec,
            FALSE))             // fMaxLength
        goto FillSignerEncryptedDigestError;
#endif  // CMS_PKCS7

    // Encode the signer and add to pcmi->psdi->pSignerList.
    if (!ICM_Asn1Encode(
            SignerInfo_PDU,
            psi,
            &sdi.blob))
        goto EncodeSignerInfoError;
    if (NULL == (pnSigner = new CSignerNode))
        goto NewSignerInfoBlobNodeError;
    pnSigner->SetData( &sdi);
    pcmi->psdi->pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    if (psi) {
        ICM_FreeAsnSignerInfo(psi);
        ICM_Free(psi);
    }
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(blobHashAlgo.pbData);
    ICM_Free(sdi.blob.pbData);
    if (HashInfo.hHash)
        CryptDestroyHash(HashInfo.hHash);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(NewBlobNodeError,E_OUTOFMEMORY)
SET_ERROR(NewSignerInfoBlobNodeError,E_OUTOFMEMORY)
TRACE_ERROR(FindHashNodeFromCapiAlgidError)     // error already set
TRACE_ERROR(CreateHashError)                    // error already set
TRACE_ERROR(HashContentError)                   // error already set
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError) // error already set
TRACE_ERROR(EncodeHashAlgorithmError)           // error already set
TRACE_ERROR(SignerInfoAllocError)               // error already set
TRACE_ERROR(FillAsnSignerInfoError)             // error already set
TRACE_ERROR(FillSignerEncryptedDigestError)     // error already set
TRACE_ERROR(EncodeSignerInfoError)              // error already set
}

//+-------------------------------------------------------------------------
//  Add a CMS signer info to a signed-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddCmsSignerInfo(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN PCMSG_CMS_SIGNER_INFO    psi)
{
    BOOL                fRet;
    CSignerNode         *pnSigner;
    SIGNER_DATA_INFO    sdi;                    ZEROSTRUCT(sdi);


    // Encode the signer
    if (!ICM_CmsSignerInfoEncode(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            psi,
            NULL,               // pbEncoded
            &sdi.blob.cbData
            ))
        goto EncodeSignerInfoError;
    if (NULL == (sdi.blob.pbData = (PBYTE) ICM_Alloc(sdi.blob.cbData)))
        goto OutOfMemory;
    if (!ICM_CmsSignerInfoEncode(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            psi,
            sdi.blob.pbData,
            &sdi.blob.cbData
            ))
        goto EncodeSignerInfoError;

    // Add to pcmi->psdi->pSignerList.
    if (NULL == (pnSigner = new CSignerNode))
        goto NewSignerInfoBlobNodeError;
    pnSigner->SetData( &sdi);
    pcmi->psdi->pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_Free(sdi.blob.pbData);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(EncodeSignerInfoError)
SET_ERROR(NewSignerInfoBlobNodeError,E_OUTOFMEMORY)
}

//+-------------------------------------------------------------------------
//  Remove a signer from a signed-data or signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDelSigner(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN DWORD                    dwIndex)
{
    BOOL                fRet;
    CSignerNode         *pnSigner = pcmi->psdi->pSignerList->Nth( dwIndex);

    if (NULL == pnSigner)
        goto IndexTooLargeError;

    pcmi->psdi->pSignerList->Remove( pnSigner);
    delete pnSigner;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
dwFlags;
}


//+-------------------------------------------------------------------------
//  Initialize the unauthenticated attributes list. Called before doing an
//  add or delete.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InitUnauthAttrList(
    IN CSignerNode          *pnSigner
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CBlobList               *plBlob = NULL;
    DWORD                   i;
    SIGNER_DATA_INFO        sdi;
    SignerInfoWithAttrBlobs *posib = NULL;
    Any                     *pAny;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();

    assert(pnSigner);
    sdi = *pnSigner->Data();
    if (NULL == sdi.pUnauthAttrList) {
        if (NULL == (plBlob = new CBlobList))
            goto NewUnauthAttrListError;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&posib,
                SignerInfoWithAttrBlobs_PDU,
                sdi.blob.pbData,
                sdi.blob.cbData)))
            goto DecodeSignerInfoError;
        if (posib->bit_mask & unauthAttributes_present) {
            for (i=posib->unauthAttributes.count, pAny=posib->unauthAttributes.value;
                    i>0;
                    i--, pAny++)
                if (!ICM_InsertTailBlob( plBlob, pAny))
                    goto InsertOldUnauthAttrBlobError;
        }
        sdi.pUnauthAttrList = plBlob;

        pnSigner->SetData( &sdi);
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithAttrBlobs_PDU, posib);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (plBlob)
        delete plBlob;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NewUnauthAttrListError,E_OUTOFMEMORY)
TRACE_ERROR(InsertOldUnauthAttrBlobError)   // error already set
}

//+-------------------------------------------------------------------------
//  Add an unauthenticated attribute to a SignerInfo of a signed-data or
//  signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddUnauthAttr(
    IN PCRYPT_MSG_INFO      pcmi,
    IN DWORD                dwFlags,
    IN PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA pmcasuap)
{
    BOOL                    fRet;
    CSignerNode             *pnSigner;
    DWORD                   i;

    for (i=pmcasuap->dwSignerIndex,
                pnSigner=pcmi->psdi->pSignerList->Head();
            (i>0) && pnSigner;
            i--, pnSigner = pnSigner->Next())
        ;
    if (NULL == pnSigner)
        goto IndexTooLargeError;

    if (!ICM_InitUnauthAttrList(pnSigner))
        goto InitUnauthAttrListError;

    assert(pnSigner->Data()->pUnauthAttrList);
    if (!ICM_InsertTailBlob( pnSigner->Data()->pUnauthAttrList,
            (Any *)&pmcasuap->blob))
        goto InsertUnauthAttrBlobError;


    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(InitUnauthAttrListError)        // error already set
TRACE_ERROR(InsertUnauthAttrBlobError)      // error already set
dwFlags;
}


//+-------------------------------------------------------------------------
//  Delete an unauthenticated attribute from a SignerInfo of a signed-data or
//  signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDelUnauthAttr(
    IN PCRYPT_MSG_INFO      pcmi,
    IN DWORD                dwFlags,
    IN PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA pmcdsuap)
{
    BOOL                    fRet;
    CSignerNode             *pnSigner;
    DWORD                   i;

    for (i=pmcdsuap->dwSignerIndex,
                pnSigner=pcmi->psdi->pSignerList->Head();
            (i>0) && pnSigner;
            i--, pnSigner = pnSigner->Next())
        ;
    if (NULL == pnSigner)
        goto IndexTooLargeError;

    if (!ICM_InitUnauthAttrList(pnSigner))
        goto InitUnauthAttrListError;

    assert(pnSigner->Data()->pUnauthAttrList);
    if (!ICM_DelBlobByIndex(
            pnSigner->Data()->pUnauthAttrList,
            pmcdsuap->dwUnauthAttrIndex))
        goto DelBlobByIndexError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(InitUnauthAttrListError)        // error already set
TRACE_ERROR(DelBlobByIndexError)            // error already set
dwFlags;
}


//+-------------------------------------------------------------------------
//  Perform a special "control" function after the final CryptMsgUpdate of a
//  encoded/decoded cryptographic message.
//
//  The dwCtrlType parameter specifies the type of operation to be performed.
//
//  The pvCtrlPara definition depends on the dwCtrlType value.
//
//  See below for a list of the control operations and their pvCtrlPara
//  type definition.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgControl(
#else
CryptMsgControl(
#endif
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara)
{
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;

    ICM_Lock( pcmi);    // Single thread access to HCRYPTMSG

    // Only support control for decoding
    if (pcmi->fEncoding)
        goto ControlForEncodingNotSupported;

    switch (dwCtrlType) {
    case CMSG_CTRL_VERIFY_SIGNATURE:
        fRet = ICM_ControlVerifySignature(
                        pcmi,
                        dwFlags,
                        (PCERT_INFO)pvCtrlPara);
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_VERIFY_SIGNATURE_EX:
        fRet = ICM_ControlVerifySignatureEx(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA)pvCtrlPara);
        break;
#endif  // CMS_PKCS7

    case CMSG_CTRL_DECRYPT:
#ifdef CMS_PKCS7
        fRet = ICM_ControlPkcsDecrypt(
#else
        fRet = ICM_ControlDecrypt(
#endif  // CMS_PKCS7
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_DECRYPT_PARA) pvCtrlPara);
        break;
    case CMSG_CTRL_VERIFY_HASH:
        fRet = ICM_ControlVerifyDigest(
                        pcmi,
                        dwFlags);
        break;
    case CMSG_CTRL_ADD_SIGNER:
        fRet = ICM_ControlAddSigner(
                        pcmi,
                        dwFlags,
                        (PCMSG_SIGNER_ENCODE_INFO)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_CMS_SIGNER_INFO:
        fRet = ICM_ControlAddCmsSignerInfo(
                        pcmi,
                        dwFlags,
                        (PCMSG_CMS_SIGNER_INFO)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_SIGNER:
        fRet = ICM_ControlDelSigner(
                        pcmi,
                        dwFlags,
                        *(PDWORD)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR:
        fRet = ICM_ControlAddUnauthAttr(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR:
        fRet = ICM_ControlDelUnauthAttr(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_CERT:
        fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCertificateList,
                        (Any *)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_CERT:
        {
            DWORD dwIndex = *(PDWORD)pvCtrlPara;
#ifdef CMS_PKCS7
            if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                // Advance index past attribute certs.
                ICM_GetTaggedBlobAndAdvanceIndex(
                    pcmi->psdi->pCertificateList,
                    ICM_TAG_SEQ,
                    &dwIndex
                    );
#endif  // CMS_PKCS7
            fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCertificateList,
                        dwIndex);
        }
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_ADD_ATTR_CERT:
        {
            Any *pAny = (Any *) pvCtrlPara;
            Any AnyAttrCert;
            BOOL fV3;

            fV3 = (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION);
            if (!(fV3 || 0 != strcmp(pszObjIdDataType,
                    pcmi->psdi->pci->pszContentType)))
                goto InvalidMsgTypeToAddAttrCert;
            
            AnyAttrCert.length = pAny->length;
            if (0 == AnyAttrCert.length)
                goto InvalidParamError;
            if (NULL == (AnyAttrCert.value = (unsigned char*) ICM_Alloc(
                    AnyAttrCert.length)))
                goto AllocError;
            memcpy(AnyAttrCert.value, pAny->value, AnyAttrCert.length);
#ifdef OSS_CRYPT_ASN1
            *AnyAttrCert.value = ICM_TAG_CONSTRUCTED_CONTEXT_1;
#else
            *((BYTE *) AnyAttrCert.value) = ICM_TAG_CONSTRUCTED_CONTEXT_1;
#endif  // OSS_CRYPT_ASN1
            fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCertificateList,
                        &AnyAttrCert);
            if (fRet && !fV3)
                pcmi->psdi->version = CMSG_SIGNED_DATA_CMS_VERSION;
            ICM_Free(AnyAttrCert.value);
        }
        break;
    case CMSG_CTRL_DEL_ATTR_CERT:
        if (pcmi->psdi->version < CMSG_SIGNED_DATA_CMS_VERSION)
            goto NoAttrCerts;
        else {
            DWORD dwIndex = *(PDWORD)pvCtrlPara;

            // Advance index past certs.
            ICM_GetTaggedBlobAndAdvanceIndex(
                pcmi->psdi->pCertificateList,
                ICM_TAG_CONSTRUCTED_CONTEXT_1,
                &dwIndex
                );

            fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCertificateList,
                        dwIndex);
        }
        break;
#endif  // CMS_PKCS7

    case CMSG_CTRL_ADD_CRL:
        fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCrlList,
                        (Any *)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_CRL:
        fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCrlList,
                        *(PDWORD)pvCtrlPara);
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_KEY_TRANS_DECRYPT:
        {
            PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportKeyTransFuncSet,
                    pmcdp->pKeyTrans->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyTrans
                    );
        }
        break;
    case CMSG_CTRL_KEY_AGREE_DECRYPT:
        {
            PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportKeyAgreeFuncSet,
                    pmcdp->pKeyAgree->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyAgree
                    );
            if (fRet)
                pcmi->dwDecryptedRecipientEncryptedKeyIndex =
                    pmcdp->dwRecipientEncryptedKeyIndex;
        }
        break;
    case CMSG_CTRL_MAIL_LIST_DECRYPT:
        {
            PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportMailListFuncSet,
                    pmcdp->pMailList->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportMailList
                    );
        }
        break;
#endif  // CMS_PKCS7

    default:
        goto InvalidCtrlType;
    }

CommonReturn:
    ICM_Unlock( pcmi);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ControlForEncodingNotSupported,E_INVALIDARG)
SET_ERROR(InvalidCtrlType,CRYPT_E_CONTROL_TYPE)
#ifdef CMS_PKCS7
SET_ERROR(InvalidMsgTypeToAddAttrCert,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidParamError,E_INVALIDARG)
TRACE_ERROR(AllocError)
SET_ERROR(NoAttrCerts,CRYPT_E_INVALID_INDEX)
SET_ERROR(InvalidArg,E_INVALIDARG)
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Copy out a DWORD
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDWORD(
    IN DWORD dwValue,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    return ICM_CopyOut(
                (PBYTE)&dwValue,
                sizeof(DWORD),
                (PBYTE)pvData,
                pcbData);
}


//+-------------------------------------------------------------------------
//  Get Any
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAny(
        IN Any          *pany,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE     **ppbExtra,
        IN OUT LONG     *plRemainExtra)
{
    BOOL fResult = TRUE;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    BOOL fNULL = FALSE;
    PBYTE pbValue;

    pbValue = (PBYTE) pany->value;
    if ((pany->length == 2) &&
            (pbValue[0] == 0x05) &&
            (pbValue[1] == 0x00)) {
        // Detected NULL encoding. Map to NULL blob.
        fNULL = TRUE;
    }

    lData = fNULL ? 0 : pany->length;
    lAlignExtra = INFO_LEN_ALIGN(lData);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if ((lData > 0) && !fNULL) {
            pInfo->pbData = pbExtra;
            pInfo->cbData = (DWORD) lData;
            memcpy( pbExtra, pany->value, lData);
        } else {
            memset(pInfo, 0, sizeof(*pInfo));
        }
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;

    return fResult;
}


//+-------------------------------------------------------------------------
//  Get the data for an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAnyData(
        IN Any *pAny,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_DATA_BLOB pBlob = (PCRYPT_DATA_BLOB)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_DATA_BLOB));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pBlob = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pBlob + lData;
    }
    if (!ICM_GetOssAny( pAny, pBlob, &pbExtra, &lRemainExtra))
        goto GetOssAnyError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAnyError)         // error already set
}


//+-------------------------------------------------------------------------
//  Get Object Identifier string
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssObjId(
        IN ObjectID *poi,
        OUT LPSTR   *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lObjId;

    if (!PkiAsn1FromObjectIdentifier(
            poi->count,
            poi->value,
            NULL,
            (PDWORD)&lObjId))
        goto PkiAsn1FromObjectIdentifierSizeError;
    lAlignExtra = INFO_LEN_ALIGN(lObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(lObjId > 0) {
            *ppszObjId = (LPSTR) pbExtra;
            if (!PkiAsn1FromObjectIdentifier(
                    poi->count,
                    poi->value,
                    (LPSTR)pbExtra,
                    (PDWORD)&lObjId))
                goto PkiAsn1FromObjectIdentifierError;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }
    fRet = TRUE;

CommonReturn:
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    return fRet;

ErrorReturn:
    *ppszObjId = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1FromObjectIdentifierSizeError,CRYPT_E_OID_FORMAT)
SET_ERROR(PkiAsn1FromObjectIdentifierError,CRYPT_E_OID_FORMAT)
}



//+-------------------------------------------------------------------------
//  Get Oss HugeInteger
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssHugeInteger(
    IN HugeIntegerType *pOssHugeInteger,
    OUT PCRYPT_INTEGER_BLOB pHugeInteger,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetHugeInteger(pOssHugeInteger->length, pOssHugeInteger->value, 0,
        pHugeInteger, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Get an Attribute
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAttribute(
        IN Attribute *poatr,
        OUT PCRYPT_ATTRIBUTE patr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL        fRet;
    LONG        lData;
    DWORD       i;
    Any         *pAny;
    PCRYPT_ATTR_BLOB  patrbl = NULL;

    if (!ICM_GetOssObjId(&poatr->attributeType, &patr->pszObjId,
            ppbExtra, plRemainExtra))
        goto GetOssObjIdError;

    lData = INFO_LEN_ALIGN( poatr->attributeValue.count * sizeof(CRYPT_ATTR_BLOB));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patr->cValue = poatr->attributeValue.count;
        patr->rgValue = patrbl = (PCRYPT_ATTR_BLOB)*ppbExtra;
        *ppbExtra += lData;
    }
    for (i=poatr->attributeValue.count, pAny=poatr->attributeValue.value;
            i>0;
            i--, pAny++, patrbl++) {
        if (!ICM_GetOssAny(pAny, patrbl, ppbExtra, plRemainExtra))
            goto GetOssAnyError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssObjIdError)   // error already set
TRACE_ERROR(GetOssAnyError)     // error already set
}


//+-------------------------------------------------------------------------
//  Get an CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetATTRIBUTE(
        IN Attribute *poatr,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_ATTRIBUTE  patr = (PCRYPT_ATTRIBUTE)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        patr = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)patr + lData;
    }
    if (!ICM_GetOssAttribute( poatr, patr, &pbExtra, &lRemainExtra))
        goto GetOssAttributeError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributeError)   // error already set
}


//+-------------------------------------------------------------------------
//  Get an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAttributes(
        IN Attributes *poatrs,
        OUT PCRYPT_ATTRIBUTES patrs,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL        fRet;
    LONG        lData;
    DWORD       i;
    Attribute   *poatr;
    PCRYPT_ATTRIBUTE  patr;

    lData = INFO_LEN_ALIGN( poatrs->count * sizeof(CRYPT_ATTRIBUTE));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patrs->cAttr = poatrs->count;
        patrs->rgAttr = patr = (PCRYPT_ATTRIBUTE)*ppbExtra;
        *ppbExtra += lData;
    } else {
        patr = NULL;
    }
    for (i=poatrs->count, poatr=poatrs->value;
            i>0;
            i--, poatr++, patr++) {
        if (!ICM_GetOssAttribute( poatr, patr, ppbExtra, plRemainExtra))
            goto GetOssAttributeError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributeError)   // error already set
}


//+-------------------------------------------------------------------------
//  Get from an Attributes in CList form
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCListAttributes(
        IN CBlobList *pBlobList,
        OUT PCRYPT_ATTRIBUTES patrs,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CBlobNode           *pBlobNode;
    AttributeNC2        *poatr = NULL;
    PCRYPT_ATTRIBUTE    patr;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCRYPT_DATA_BLOB    pDataBlob;

    lData = INFO_LEN_ALIGN( pBlobList->Length() * sizeof(CRYPT_ATTRIBUTE));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patrs->cAttr = pBlobList->Length();
        patrs->rgAttr = patr = (PCRYPT_ATTRIBUTE)*ppbExtra;
        *ppbExtra += lData;
    } else {
        patr = NULL;
    }
    for (pBlobNode=pBlobList->Head();
            pBlobNode;
            pBlobNode=pBlobNode->Next(), patr++) {
        poatr = NULL;
        pDataBlob = pBlobNode->Data();
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&poatr,
                AttributeNC2_PDU,
                pDataBlob->pbData,
                pDataBlob->cbData)))
            goto DecodeAttributeNC2Error;
        if (!ICM_GetOssAttribute(
                (Attribute *)poatr,     // same, except for NOCOPY
                patr,
                ppbExtra,
                plRemainExtra))
            goto GetOssAttributeError;
        PkiAsn1FreeDecoded(pDec, poatr, AttributeNC2_PDU);
        poatr = NULL;
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AttributeNC2_PDU, poatr);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeAttributeNC2Error, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssAttributeError)       // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttributesData(
        IN Attributes *poatrs,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_ATTRIBUTES patrs = (PCRYPT_ATTRIBUTES)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ATTRIBUTES));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        patrs = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)patrs + lData;
    }
    if (!ICM_GetOssAttributes( poatrs, patrs, &pbExtra, &lRemainExtra))
        goto GetOssAttributesError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributesError)      // error already set
}


//+-------------------------------------------------------------------------
//  Get an OSS Algorithm
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAlgorithm(
        IN AlgorithmIdentifier *pai,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    if (!ICM_GetOssObjId(&pai->algorithm, &pInfo->pszObjId,
            ppbExtra, plRemainExtra))
        return FALSE;
    
    if (pai->bit_mask & parameters_present) {
        if (!ICM_GetOssAny(&pai->parameters, &pInfo->Parameters,
                ppbExtra, plRemainExtra))
            return FALSE;
    } else if (*plRemainExtra >= 0) {
        memset(&pInfo->Parameters, 0, sizeof(pInfo->Parameters));
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get a ContentInfo (internal)
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssContentInfo(
        IN ContentInfo *poci,
        OUT PCONTENT_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    if (!ICM_GetOssObjId(&poci->contentType, &pInfo->pszContentType,
            ppbExtra, plRemainExtra))
        return FALSE;
    if (poci->bit_mask & content_present) {
        if (!ICM_GetOssAny(&poci->content, &pInfo->content,
                ppbExtra, plRemainExtra))
            return FALSE;
    } else {
        if (pInfo) {
            pInfo->content.cbData = 0;
            pInfo->content.pbData = 0;
        }
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get a ContentInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssContentInfoData(
        IN ContentInfo *poci,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCONTENT_INFO pci = (PCONTENT_INFO)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CONTENT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pci = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pci + lData;
    }
    if (!ICM_GetOssContentInfo( poci, pci, &pbExtra, &lRemainExtra))
        goto GetContentInfoError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetContentInfoError)        // error already set
}


BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromCertId(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra);

//+-------------------------------------------------------------------------
//  Get an Special Issuer and SerialNumber from a KeyId.
//
//  Converts the KeyId to a special encoded Issuer name having a RDN with
//  the szOID_KEYID_RDN OID and a CERT_RDN_OCTET_STRING value containing
//  the KeyId. The SerialNumber is set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromKeyId(
	    IN SubjectKeyIdentifier *pOssKeyId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;

    CertIdentifier OssCertId;
    ASN1octet_t SerialNumber;
    CERT_RDN_ATTR KeyIdAttr;
    CERT_RDN KeyIdRDN;
    CERT_NAME_INFO IssuerInfo;
    BYTE *pbEncodedIssuer = NULL;
    DWORD cbEncodedIssuer;

    KeyIdAttr.pszObjId = szOID_KEYID_RDN;
    KeyIdAttr.dwValueType = CERT_RDN_OCTET_STRING;
    KeyIdAttr.Value.pbData = pOssKeyId->value;
    KeyIdAttr.Value.cbData = pOssKeyId->length;
    KeyIdRDN.cRDNAttr = 1;
    KeyIdRDN.rgRDNAttr = &KeyIdAttr;
    IssuerInfo.cRDN = 1;
    IssuerInfo.rgRDN = &KeyIdRDN;

    // Encode the special Issuer Name containing the KeyId
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            X509_NAME,
            &IssuerInfo,
            CRYPT_ENCODE_ALLOC_FLAG,
            &PkiEncodePara,
            (void *) &pbEncodedIssuer,
            &cbEncodedIssuer
            ))
        goto EncodeError;

    OssCertId.choice = issuerAndSerialNumber_chosen;
    OssCertId.u.issuerAndSerialNumber.serialNumber.length = 1;
    OssCertId.u.issuerAndSerialNumber.serialNumber.value = &SerialNumber;
    SerialNumber = 0;
    OssCertId.u.issuerAndSerialNumber.issuer.length = cbEncodedIssuer;
    OssCertId.u.issuerAndSerialNumber.issuer.value = pbEncodedIssuer;

    fRet = ICM_GetOssIssuerAndSerialNumberFromCertId(
        &OssCertId,
        pIssuer,
        pSerialNumber,
        ppbExtra,
        plRemainExtra
        );

CommonReturn:
    PkiFree(pbEncodedIssuer);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Get an Issuer and SerialNumber from a CertIdentifier.
//
//  Converts a KEYID choice to a special encoded Issuer name having a RDN with
//  the szOID_KEYID_RDN OID and a CERT_RDN_OCTET_STRING value containing
//  the KeyId. The SerialNumber is set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromCertId(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;

    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_GetOssHugeInteger(
                &pOssCertId->u.issuerAndSerialNumber.serialNumber,
                pSerialNumber, ppbExtra, plRemainExtra);
            if (!ICM_GetOssAny(&pOssCertId->u.issuerAndSerialNumber.issuer,
                    pIssuer, ppbExtra, plRemainExtra))
                goto GetIssuerError;
            break;
        case subjectKeyIdentifier_chosen:
            if (!ICM_GetOssIssuerAndSerialNumberFromKeyId(
                    &pOssCertId->u.subjectKeyIdentifier,
                    pIssuer, pSerialNumber, ppbExtra, plRemainExtra))
                goto GetKeyIdError;
            break;
        default:
            goto InvalidCertIdChoice;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetIssuerError)
TRACE_ERROR(GetKeyIdError)
SET_ERROR(InvalidCertIdChoice, CRYPT_E_BAD_ENCODE)
}

BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberForCertInfo(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_INFO pCertInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    return ICM_GetOssIssuerAndSerialNumberFromCertId(
        pOssCertId,
        &pCertInfo->Issuer,
        &pCertInfo->SerialNumber,
        ppbExtra,
        plRemainExtra
        );
}


//+-------------------------------------------------------------------------
//  Get an CertInfo with an updated IssuerAndSerialNumber
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCertInfoIssuerAndSerialNumber(
    IN CertIdentifier *pOssCertIdentifier,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL         fRet;
    LONG         lData;
    PCERT_INFO   pci = (PCERT_INFO)pvData;
    PBYTE        pbExtra;
    LONG         lRemainExtra;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CERT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pci = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pci + lData;
    }
    if (!ICM_GetOssIssuerAndSerialNumberForCertInfo(pOssCertIdentifier,
            pci, &pbExtra, &lRemainExtra))
        goto GetOssIssuerAndSerialNumberError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssIssuerAndSerialNumberError)   // error already set
}

BOOL
WINAPI
ICM_GetOssCertIdentifier(
    IN CertIdentifier *pOssCertId,
    OUT PCERT_ID pCertId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    );

BOOL
WINAPI
ICM_GetCertId(
    IN CertIdentifier *pOssCertIdentifier,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL         fRet;
    LONG         lData;
    PCERT_ID     pid = (PCERT_ID)pvData;
    PBYTE        pbExtra;
    LONG         lRemainExtra;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CERT_ID));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pid = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pid + lData;
    }
    if (!ICM_GetOssCertIdentifier(pOssCertIdentifier,
            pid, &pbExtra, &lRemainExtra))
        goto GetOssCertIdentifierError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssCertIdentifierError)   // error already set
}


//+-------------------------------------------------------------------------
//  Copy out an CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL                    fRet;
    LONG                    lData;
    PCRYPT_ALGORITHM_IDENTIFIER   pai = (PCRYPT_ALGORITHM_IDENTIFIER)pvData;
    PBYTE                   pbExtra;
    LONG                    lRemainExtra;

    if (NULL == pvData)
        *pcbData = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ALGORITHM_IDENTIFIER));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pai = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pai + lData;
    }
    if (!ICM_GetOssAlgorithm( paiOss, pai, &pbExtra, &lRemainExtra))
        goto GetOssAlgorithmError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAlgorithmError)       // error already set
}


//+-------------------------------------------------------------------------
//  Get the digest in a DIGESTED message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDigestDataParam(
    IN PCRYPT_MSG_INFO pcmi,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL            fRet;
    DigestedData    *pdd;

    if (CMSG_HASHED != pcmi->dwMsgType)
        goto InvalidMsgType;
    pdd = (DigestedData *)pcmi->pvMsg;
    fRet = ICM_CopyOut(
                (PBYTE)pdd->digest.value,
                (DWORD)pdd->digest.length,
                (PBYTE)pvData,
                pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}

#ifdef CMS_PKCS7

HCRYPTHASH
WINAPI
ICM_GetEncodedSignerHash(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwSignerIndex
    )
{
    HCRYPTHASH hHash = NULL;
    SignerInfo *psi;
    PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo;
    CHashNode *pnHash;
    PICM_HASH_INFO pHashInfo;

    if (dwSignerIndex >= ((SignedData *)pcmi->pvMsg)->signerInfos.count)
        goto IndexTooBig;
    psi = ((SignedData *)pcmi->pvMsg)->signerInfos.value + dwSignerIndex;
    pSignerEncodeDataInfo = pcmi->rgSignerEncodeDataInfo + dwSignerIndex;
    pnHash = pSignerEncodeDataInfo->pHashNode;
    pHashInfo = pnHash->Data();

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pSignerEncodeDataInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHash))
            goto GetAuthAttrsHashError;
    } else {
        if (!ICM_DupListHash( pnHash, pSignerEncodeDataInfo->hCryptProv,
                &hHash))
            goto DupListHashError;
    }

CommonReturn:
    return hHash;

ErrorReturn:
    hHash = NULL;
    goto CommonReturn;

SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
}


HCRYPTHASH
WINAPI
ICM_GetDecodedSignerHash(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwSignerIndex
    )
{
    HCRYPTHASH              hHash = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    HCRYPTPROV              hCryptProv;         // doen't need to be released
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;

    if (!ICM_FindSignerInfo(pcmi, dwSignerIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoWithBlobsError;

    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();

    if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
    }

    if (psib->bit_mask & authAttributes_present) {
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHash))
            goto GetAuthAttrsHashError;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHash))
            goto DupListHashError;
    }

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    ICM_SetLastError(dwError);
    return hHash;

ErrorReturn:
    dwError = GetLastError();
    hHash = NULL;
    goto CommonReturn;

TRACE_ERROR(FindSignerInfoError)                // error already set
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(DupListHashError)                   // error already set
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get the digest of the content in a DIGESTED message or for one of
//  the signers in a SIGNED message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetComputedDigestParam(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL                fRet;
    DWORD               dwError = ERROR_SUCCESS;
    HCRYPTHASH          hHash = NULL;
    PBYTE               pbAllocHash = NULL;
    DWORD               cbHash;
    PBYTE               pbHash;

    switch (pcmi->dwMsgType) {
    case CMSG_HASHED:
        if (!ICM_GetListHashValue(
                pcmi->pHashList->Head(),
                &cbHash,
                &pbHash))
            goto GetHashValueError;
        break;
#ifdef CMS_PKCS7
    case CMSG_SIGNED:
        if (pcmi->fEncoding)
            hHash = ICM_GetEncodedSignerHash(pcmi, dwIndex);
        else
            hHash = ICM_GetDecodedSignerHash(pcmi, dwIndex);
        if (NULL == hHash)
            goto GetSignerHashError;

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                NULL,
                &cbHash,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        if (NULL == (pbAllocHash = (PBYTE)ICM_AllocA(cbHash)))
            goto AllocHashParamError;
        pbHash = pbAllocHash;
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbHash,
                &cbHash,
                0))                     // dwFlags
            goto GetHashParamError;
        break;
#endif  // CMS_PKCS7
    default:
        goto InvalidMsgType;
    }

    fRet = ICM_CopyOut(
                pbHash,
                cbHash,
                (PBYTE)pvData,
                pcbData);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_FreeA(pbAllocHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(GetHashValueError)
TRACE_ERROR(GetSignerHashError)
TRACE_ERROR(GetHashParamSizeError)
TRACE_ERROR(AllocHashParamError)
TRACE_ERROR(GetHashParamError)
}


//+-------------------------------------------------------------------------
//  Find the SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           *ppv)
{
    BOOL        fRet;
    PVOID       pv;
    SignerInfo  *psi = NULL;
    CSignerNode *pSignerNode = NULL;
    DWORD       i;

    if (pcmi->fEncoding) {

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (dwIndex >= ((SignedData *)pcmi->pvMsg)->signerInfos.count)
                goto IndexTooBig;
            psi = ((SignedData *)pcmi->pvMsg)->signerInfos.value + dwIndex;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }

        pv = psi;

    } else {

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (NULL == pcmi->psdi)
                goto InvalidSignedMessageError;
            for (i=dwIndex, pSignerNode=pcmi->psdi->pSignerList->Head();
                    (i>0) && pSignerNode;
                    i--, pSignerNode=pSignerNode->Next())
                ;
            if (NULL == pSignerNode)
                goto IndexTooBig;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }

        pv = pSignerNode;
    }

    fRet = TRUE;
CommonReturn:
    *ppv = pv;
    return fRet;

ErrorReturn:
    pv = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidSignedMessageError, ERROR_INVALID_DATA)
SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Countersign an already-existing signature, output an encoded attribute
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgCountersignEncoded(
#else
CryptMsgCountersignEncoded(
#endif
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignatureAttribute,
    IN OUT PDWORD               pcbCountersignatureAttribute)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    HCRYPTMSG                   hCryptMsgCountersign = NULL;
    CMSG_SIGNED_ENCODE_INFO     EncodeInfo;     ZEROSTRUCT(EncodeInfo);
    EncodeInfo.cbSize = sizeof(EncodeInfo);
    CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA   UnauthAttrPara; ZEROSTRUCT(UnauthAttrPara);
    UnauthAttrPara.cbSize = sizeof(UnauthAttrPara);
    Attribute                   oatrCountersignature;   ZEROSTRUCT(oatrCountersignature);
    ASN1error_e                 Asn1Err;
    ASN1decoding_t              pDec = ICM_GetDecoder();
    ASN1encoding_t              pEnc = ICM_GetEncoder();
    PBYTE                       pbEncoded = NULL;
    DWORD                       cbEncoded;
    SignerInfoWithBlobs         *posib = NULL;
    DWORD                       i;
    Any                         *pAny;
    DWORD                       dwFlags;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // create a new message
    EncodeInfo.cSigners  = cCountersigners;
    EncodeInfo.rgSigners = rgCountersigners;
    dwFlags = CMSG_AUTHENTICATED_ATTRIBUTES_FLAG;
    if (NULL == pbCountersignatureAttribute ||
            0 == *pcbCountersignatureAttribute)
        dwFlags |= CMSG_MAX_LENGTH_FLAG;
    if (NULL == (hCryptMsgCountersign = CryptMsgOpenToEncode(
            PKCS_7_ASN_ENCODING,
            dwFlags,
            CMSG_SIGNED,
            &EncodeInfo,
            NULL,                       // pszInnerContentObjID
            NULL)))                     // pStreamInfo
        goto OpenToEncodeError;

    // feed encrypted digest into the new message
    if (!CryptMsgUpdate(
            hCryptMsgCountersign,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length,
            TRUE))                      // fFinal
        goto UpdateError;

    oatrCountersignature.attributeType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            szOID_RSA_counterSign,
            &oatrCountersignature.attributeType.count,
            oatrCountersignature.attributeType.value))
        goto PkiAsn1ToObjectIdentifierError;
    oatrCountersignature.attributeValue.count = cCountersigners;
    if (NULL == (oatrCountersignature.attributeValue.value = (Any *)ICM_AllocA(
            cCountersigners * sizeof(Any))))
        goto AllocCountersignersError;

    // extract encoded SignerInfo's, and store
    for (i=0, pAny=oatrCountersignature.attributeValue.value;
            i<cCountersigners;
            i++, pAny++) {
        cbSignerInfo = 0;
        CryptMsgGetParam(
                hCryptMsgCountersign,
                CMSG_ENCODED_SIGNER,
                i,
                NULL,
                &cbSignerInfo);
        if (cbSignerInfo == 0)
            goto GetSignerInfoSizeError;
        if (NULL == (pbSignerInfo = (PBYTE)ICM_AllocA( cbSignerInfo)))
            goto AllocSignerInfoError;
        if (!CryptMsgGetParam(
                hCryptMsgCountersign,
                CMSG_ENCODED_SIGNER,
                i,
                pbSignerInfo,
                &cbSignerInfo))
            goto GetSignerInfoError;
        pAny->length = cbSignerInfo;
        pAny->value  = pbSignerInfo;
    }

    // encode the Countersignature attribute
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &oatrCountersignature,
            AttributeNC2_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto Asn1EncodeAttributeError;

    // copy out the Countersignature attribute
    fRet = ICM_CopyOut(
                    pbEncoded,
                    cbEncoded,
                    pbCountersignatureAttribute,
                    pcbCountersignatureAttribute);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    CryptMsgClose( hCryptMsgCountersign);
    if (oatrCountersignature.attributeValue.value) {
        for (i=cCountersigners, pAny=oatrCountersignature.attributeValue.value;
                i>0;
                i--, pAny++)
            ICM_FreeA( pAny->value);
        ICM_FreeA( oatrCountersignature.attributeValue.value);
    }
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(Asn1EncodeAttributeError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(OpenToEncodeError)                  // error already set
TRACE_ERROR(UpdateError)                        // error already set
TRACE_ERROR(AllocCountersignersError)           // error already set
TRACE_ERROR(GetSignerInfoSizeError)             // error already set
TRACE_ERROR(AllocSignerInfoError)               // error already set
TRACE_ERROR(GetSignerInfoError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Countersign an already-existing signature in a message
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgCountersign(
#else
CryptMsgCountersign(
#endif
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    PBYTE                       pbCountersignatureAttribute = NULL;
    DWORD                       cbCountersignatureAttribute;
    PBYTE                       pbSignerInfo = NULL;
    DWORD                       cbSignerInfo;
    CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA   UnauthAttrPara; ZEROSTRUCT(UnauthAttrPara);
    UnauthAttrPara.cbSize = sizeof(UnauthAttrPara);

    if (((PCRYPT_MSG_INFO)hCryptMsg)->fEncoding)
        goto EncodingCountersignNotSupportedError;

    // extract encoded SignerInfo being countersigned from the message
    cbSignerInfo = 0;
    CryptMsgGetParam(
            hCryptMsg,
            CMSG_ENCODED_SIGNER,
            dwIndex,
            NULL,
            &cbSignerInfo);
    if (cbSignerInfo == 0)
        goto GetEncodedSignerSizeError;
    if (NULL == (pbSignerInfo = (PBYTE)ICM_AllocA( cbSignerInfo)))
        goto AllocEncodedSignerError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_ENCODED_SIGNER,
            dwIndex,
            pbSignerInfo,
            &cbSignerInfo))
        goto GetEncodedSignerError;

    // create the countersignature blob
    cbCountersignatureAttribute = 0;
    CryptMsgCountersignEncoded(
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            NULL,
            &cbCountersignatureAttribute);
    if (cbCountersignatureAttribute == 0)
        goto GetCountersignatureAttributeSizeError;
    if (NULL == (pbCountersignatureAttribute = (PBYTE)ICM_AllocA( cbCountersignatureAttribute)))
        goto AllocCountersignatureAttributeError;
    if (!CryptMsgCountersignEncoded(
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignatureAttribute,
            &cbCountersignatureAttribute))
        goto GetCountersignatureAttributeError;

    // add encoded Countersignature attribute to unauth attrs
    UnauthAttrPara.dwSignerIndex = dwIndex;
    UnauthAttrPara.blob.cbData = cbCountersignatureAttribute;
    UnauthAttrPara.blob.pbData = pbCountersignatureAttribute;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                          // dwFlags
            CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR,
            &UnauthAttrPara))
        goto AddUnauthAttrError;

    fRet = TRUE;
CommonReturn:
    ICM_FreeA( pbSignerInfo);
    ICM_FreeA( pbCountersignatureAttribute);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodingCountersignNotSupportedError)   // error already set
TRACE_ERROR(GetEncodedSignerSizeError)              // error already set
TRACE_ERROR(AllocEncodedSignerError)                // error already set
TRACE_ERROR(GetEncodedSignerError)                  // error already set
TRACE_ERROR(GetCountersignatureAttributeSizeError)  // error already set
TRACE_ERROR(AllocCountersignatureAttributeError)    // error already set
TRACE_ERROR(GetCountersignatureAttributeError)      // error already set
TRACE_ERROR(AddUnauthAttrError)                     // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level.
//  ie. verify that pbSignerInfoCountersignature contains the encrypted
//  hash of the encryptedDigest field of pbSignerInfo.
//
//  hCryptProv is used to hash the encryptedDigest field of pbSignerInfo.
//
//  The signer can be a CERT_PUBLIC_KEY_INFO, certificate context or a
//  chain context. 
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
#else
CryptMsgVerifyCountersignatureEncodedEx(
#endif
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *posib = NULL;
    SignerInfoWithBlobs     *posibCS = NULL;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    DWORD                   dwDigestAlgoCAPI;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTHASH              hHashRaw = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    PBYTE                   pbHash = NULL;
    DWORD                   cbHash;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // crack the SignerInfo doing the countersigning
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posibCS,
            SignerInfoWithBlobs_PDU,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature)))
        goto DecodeSignerInfoCSError;

    if (!ICM_GetVerifySignatureStuff(
            dwSignerType,
            pvSigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    // hash the encrypted digest
    if (!ICM_GetCapiFromAlgidBlob(
            (PCRYPT_DATA_BLOB)&posibCS->digestAlgorithm,
            &dwDigestAlgoCAPI))
        goto GetCapiFromAlgidBlobError;
    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHashRaw))
        goto CreateHashError;
    if (!ICM_UpdateDigest(
            hHashRaw,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length))
        goto HashDataError;

    if (0 == (posibCS->bit_mask & authAttributes_present))
        goto CountersignerAuthAttributesMissingError;

    // check that the message digest attr matches the hashed encrypted digest
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            NULL,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamSizeError;
    if (NULL == (pbHash = (PBYTE)ICM_AllocA( cbHash)))
        goto AllocHashParamError;
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            pbHash,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamError;
    // find the message digest attr value
    if (!ICM_GetAttrValue(
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &oidMessageDigest,
            &anyValue))
        goto FindAttrError;
    // find the message digest octets
    if (!Asn1UtilExtractContent(
#ifdef OSS_CRYPT_ASN1
            anyValue.value,
#else
            (const BYTE *) anyValue.value,
#endif  // OSS_CRYPT_ASN1
            anyValue.length,
            &cbMessageDigest,
            (const BYTE **)&pbMessageDigest))
        goto ExtractContentError;
    // hash sizes equal?
    if (cbHash != cbMessageDigest)
        goto HashCompareSizeError;
    // hash octets equal?
    if (memcmp( pbMessageDigest, pbHash, cbHash))
        goto HashCompareValueError;
    // Now that we have verified the message digest octets,
    // get the hash of the authenticated attributes.
    if (!ICM_GetAttrsHash(
            dwDigestAlgoCAPI,
            hCryptProv,
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &hHashAttr))
        goto GetAuthAttrsHashError;

    // verify the hash, signature, and public key are consistent
    if (!ICM_VerifySignature(
            hHashAttr,
            hPubKey,
            dwPubKeyAlgId,
            dwPubKeyFlags,
            posibCS->encryptedDigest.value,
            posibCS->encryptedDigest.length))
        goto VerifySignatureError;

    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posibCS);
    if (hHashRaw)
        CryptDestroyHash( hHashRaw);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hPubKey)
        CryptDestroyKey( hPubKey);
    ICM_FreeA( pbHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoCSError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(CountersignerAuthAttributesMissingError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
TRACE_ERROR(GetCapiFromAlgidBlobError)      // error already set
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(HashDataError)                  // error already set
TRACE_ERROR(GetHashParamSizeError)          // error already set
TRACE_ERROR(AllocHashParamError)            // error already set
TRACE_ERROR(GetHashParamError)              // error already set
TRACE_ERROR(GetAuthAttrsHashError)          // error already set
TRACE_ERROR(GetSignatureStuffError)         // error already set
TRACE_ERROR(VerifySignatureError)           // error already set
}

//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncoded(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN PCERT_INFO   pciCountersigner)
{
    return CryptMsgVerifyCountersignatureEncodedEx(
        hCryptProv,
        dwEncodingType,
        pbSignerInfo,
        cbSignerInfo,
        pbSignerInfoCountersignature,
        cbSignerInfoCountersignature,
        CMSG_VERIFY_SIGNER_PUBKEY,
        (void *) &pciCountersigner->SubjectPublicKeyInfo,
        0,                                                  // dwFlags
        NULL                                                // pvReserved
        );
}


#else


//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncoded(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN PCERT_INFO   pciCountersigner)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *posib = NULL;
    SignerInfoWithBlobs     *posibCS = NULL;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    DWORD                   dwDigestAlgoCAPI;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    IssuerAndSerialNumber   *pisn = NULL;
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTHASH              hHashRaw = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    PBYTE                   pbHash = NULL;
    DWORD                   cbHash;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // crack the SignerInfo doing the countersigning
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posibCS,
            SignerInfoWithBlobs_PDU,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature)))
        goto DecodeSignerInfoCSError;

    // verify that the countersignature SignerInfo and the cert info are consistent
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&pisn,
            IssuerAndSerialNumber_PDU,
            (BYTE *) posibCS->issuerAndSerialNumber.value,
            posibCS->issuerAndSerialNumber.length)))
        goto DecodeIssuerAndSerialNumberError;
    if (pisn->issuer.length != pciCountersigner->Issuer.cbData)
        goto IssuerSizeMismatchError;
    if (0 != memcmp(
            pciCountersigner->Issuer.pbData,
            pisn->issuer.value,
            pciCountersigner->Issuer.cbData))
        goto IssuerValueMismatchError;
    if (pisn->serialNumber.length != pciCountersigner->SerialNumber.cbData)
        goto SerialNumberSizeMismatchError;
    if (ICM_ReverseCompare(
            pisn->serialNumber.value,
            pciCountersigner->SerialNumber.pbData,
            pciCountersigner->SerialNumber.cbData))
        goto SerialNumberValueMismatchError;

    if (!ICM_GetVerifySignatureStuff(
            pciCountersigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    // hash the encrypted digest
    if (!ICM_GetCapiFromAlgidBlob(
            (PCRYPT_DATA_BLOB)&posibCS->digestAlgorithm,
            &dwDigestAlgoCAPI))
        goto GetCapiFromAlgidBlobError;
    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHashRaw))
        goto CreateHashError;
    if (!ICM_UpdateDigest(
            hHashRaw,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length))
        goto HashDataError;

    if (0 == (posibCS->bit_mask & authAttributes_present))
        goto CountersignerAuthAttributesMissingError;

    // check that the message digest attr matches the hashed encrypted digest
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            NULL,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamSizeError;
    if (NULL == (pbHash = (PBYTE)ICM_AllocA( cbHash)))
        goto AllocHashParamError;
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            pbHash,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamError;
    // find the message digest attr value
    if (!ICM_GetAttrValue(
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &oidMessageDigest,
            &anyValue))
        goto FindAttrError;
    // find the message digest octets
    if (!Asn1UtilExtractContent(
            (BYTE *) anyValue.value,
            anyValue.length,
            &cbMessageDigest,
            (const BYTE **)&pbMessageDigest))
        goto ExtractContentError;
    // hash sizes equal?
    if (cbHash != cbMessageDigest)
        goto HashCompareSizeError;
    // hash octets equal?
    if (memcmp( pbMessageDigest, pbHash, cbHash))
        goto HashCompareValueError;
    // Now that we have verified the message digest octets,
    // get the hash of the authenticated attributes.
    if (!ICM_GetAttrsHash(
            dwDigestAlgoCAPI,
            hCryptProv,
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &hHashAttr))
        goto GetAuthAttrsHashError;

    // verify the hash, signature, and public key are consistent
    if (!ICM_VerifySignature(
            hHashAttr,
            hPubKey,
            dwPubKeyAlgId,
            dwPubKeyFlags,
            posibCS->encryptedDigest.value,
            posibCS->encryptedDigest.length))
        goto VerifySignatureError;

    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posibCS);
    PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
    if (hHashRaw)
        CryptDestroyHash( hHashRaw);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hPubKey)
        CryptDestroyKey( hPubKey);
    ICM_FreeA( pbHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoCSError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(IssuerSizeMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(IssuerValueMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(SerialNumberSizeMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(SerialNumberValueMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(CountersignerAuthAttributesMissingError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
TRACE_ERROR(GetCapiFromAlgidBlobError)      // error already set
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(HashDataError)                  // error already set
TRACE_ERROR(GetHashParamSizeError)          // error already set
TRACE_ERROR(AllocHashParamError)            // error already set
TRACE_ERROR(GetHashParamError)              // error already set
TRACE_ERROR(GetAuthAttrsHashError)          // error already set
TRACE_ERROR(GetSignatureStuffError)         // error already set
TRACE_ERROR(VerifySignatureError)           // error already set
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Set an OSS Any
//--------------------------------------------------------------------------
void
WINAPI
ICM_SetOssAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    pOss->encoded = pInfo->pbData;
    pOss->length = pInfo->cbData;
}


//+-------------------------------------------------------------------------
//  Encode a CMS SignerInfo
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_CmsSignerInfoEncode(
    IN DWORD                    dwEncodingType,
    IN LPCSTR                   lpszStructType,
    IN PCMSG_CMS_SIGNER_INFO    pInfo,
    OUT PBYTE                   pbEncoded,
    IN OUT PDWORD               pcbEncoded)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    SignerInfo          osi;        ZEROSTRUCT(osi);
    PCMSG_CMS_SIGNER_INFO psi = pInfo;
    DWORD               i;
    Attribute           *poatrAuth = NULL;
    Attribute           *poatrUnauth = NULL;
    Attribute           *poatr;
    PCRYPT_ATTRIBUTE    patr;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // version
    osi.version = psi->dwVersion;

    // sid
    if (!ICM_SetOssCertIdentifier(
            &psi->SignerId,
            &osi.sid
            ))
        goto SetOssCertIdentifierError;

    // digestAlgorithm
    if (!ICM_Asn1ToAlgorithmIdentifier(
            &psi->HashAlgorithm,
            &osi.digestAlgorithm))
        goto DigestAsn1ToAlgorithmIdentifierError;

    // authenticatedAttributes
    if (psi->AuthAttrs.cAttr) {
        osi.bit_mask |= authenticatedAttributes_present;
        osi.authenticatedAttributes.count = psi->AuthAttrs.cAttr;
        if (NULL == (poatrAuth = (Attribute *)ICM_AllocA(
                psi->AuthAttrs.cAttr * sizeof(Attribute))))
            goto AllocAuthAttrsError;
        osi.authenticatedAttributes.value = poatrAuth;
        for (i=psi->AuthAttrs.cAttr, patr=psi->AuthAttrs.rgAttr, poatr=poatrAuth;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute( patr, poatr))
                goto Asn1AuthenticatedAttributeError;
        }
    }

    // digestEncryptionAlgorithm
    if (!ICM_FillAsnDigestEncryptionAlgorithm(
            NULL,                           // pcmi
            &psi->HashEncryptionAlgorithm,
            &osi.digestEncryptionAlgorithm))
        goto FillAsnDigestEncryptionAlgorithmError;

    // encryptedDigest
    osi.encryptedDigest.length = psi->EncryptedHash.cbData;
    osi.encryptedDigest.value  = psi->EncryptedHash.pbData;

    // unauthenticatedAttributes
    if (psi->UnauthAttrs.cAttr) {
        osi.bit_mask |= unauthAttributes_present;
        osi.unauthAttributes.count = psi->UnauthAttrs.cAttr;
        if (NULL == (poatrUnauth = (Attribute *)ICM_AllocA(
                psi->UnauthAttrs.cAttr * sizeof(Attribute))))
            goto AllocUnauthAttrsError;
        osi.unauthAttributes.value = poatrUnauth;
        for (i=psi->UnauthAttrs.cAttr, patr=psi->UnauthAttrs.rgAttr, poatr=poatrUnauth;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute( patr, poatr))
                goto Asn1UnauthenticatedAttributeError;
        }
    }

    fRet = PkiAsn1EncodeInfo(
                    ICM_GetEncoder(),
                    SignerInfo_PDU,
                    &osi,
                    pbEncoded,
                    pcbEncoded);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    ICM_FreeOssCertIdentifier(&osi.sid);

    if (poatrAuth) {
        for (i=psi->AuthAttrs.cAttr, poatr=poatrAuth;
                i>0;
                i--, poatr++)
            ICM_Free( poatr->attributeValue.value);
    }
    if (poatrUnauth) {
        for (i=psi->UnauthAttrs.cAttr, poatr=poatrUnauth;
                i>0;
                i--, poatr++)
            ICM_Free( poatr->attributeValue.value);
    }
    ICM_FreeA( poatrAuth);
    ICM_FreeA( poatrUnauth);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    *pcbEncoded = 0;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
TRACE_ERROR(SetOssCertIdentifierError)               // error already set
TRACE_ERROR(DigestAsn1ToAlgorithmIdentifierError)    // error already set
TRACE_ERROR(AllocAuthAttrsError)                        // error already set
TRACE_ERROR(Asn1AuthenticatedAttributeError)         // error already set
TRACE_ERROR(FillAsnDigestEncryptionAlgorithmError)      // error already set
TRACE_ERROR(AllocUnauthAttrsError)                      // error already set
TRACE_ERROR(Asn1UnauthenticatedAttributeError)       // error already set
lpszStructType;
}

//+-------------------------------------------------------------------------
//  Encode a Pkcs SignerInfo
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_PkcsSignerInfoEncode(
    IN DWORD                    dwEncodingType,
    IN LPCSTR                   lpszStructType,
    IN PCMSG_SIGNER_INFO        pInfo,
    OUT PBYTE                   pbEncoded,
    IN OUT PDWORD               pcbEncoded)
{
    CMSG_CMS_SIGNER_INFO csi;
    CERT_INFO CertInfo;

    csi.dwVersion = pInfo->dwVersion;

    CertInfo.Issuer = pInfo->Issuer;
    CertInfo.SerialNumber = pInfo->SerialNumber;
    ICM_GetCertIdFromCertInfo(&CertInfo, &csi.SignerId);

    csi.HashAlgorithm = pInfo->HashAlgorithm;
    csi.HashEncryptionAlgorithm = pInfo->HashEncryptionAlgorithm;
    csi.EncryptedHash = pInfo->EncryptedHash;
    csi.AuthAttrs = pInfo->AuthAttrs;
    csi.UnauthAttrs = pInfo->UnauthAttrs;

    return ICM_CmsSignerInfoEncode(
        dwEncodingType,
        lpszStructType,
        &csi,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Get fields shared by PKCS and CMS SignerInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssSharedSignerInfo(
    IN SignerInfo                   *posi,
    IN CBlobList                    *pUnauthAttrList,
    OUT PCRYPT_ALGORITHM_IDENTIFIER  pHashAlgorithm,
    OUT PCRYPT_ALGORITHM_IDENTIFIER  pHashEncryptionAlgorithm,
    OUT PCRYPT_DATA_BLOB             pEncryptedHash,
    OUT PCRYPT_ATTRIBUTES            pAuthAttrs,
    OUT PCRYPT_ATTRIBUTES            pUnauthAttrs,
    IN OUT PBYTE                    *ppbExtra,
    IN OUT LONG                     *plRemainExtra)
{
    BOOL        fRet;

    if (!ICM_GetOssAlgorithm( &posi->digestAlgorithm,
            pHashAlgorithm, ppbExtra, plRemainExtra))
        goto GetOssHashAlgorithmError;
    if (!ICM_GetOssAlgorithm( &posi->digestEncryptionAlgorithm,
            pHashEncryptionAlgorithm, ppbExtra, plRemainExtra))
        goto GetOssHashEncryptionAlgorithmError;
    if (!ICM_GetOssAny( (Any *)&posi->encryptedDigest,
            pEncryptedHash, ppbExtra, plRemainExtra))
        goto GetOssEncryptedHashError;
    if (posi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_GetOssAttributes( &posi->authenticatedAttributes,
                pAuthAttrs, ppbExtra, plRemainExtra))
            goto GetOssAuthAttrsError;
    } else if (0 <= *plRemainExtra)
        pAuthAttrs->cAttr = 0;

    if (posi->bit_mask & unauthAttributes_present || pUnauthAttrList) {
        if (pUnauthAttrList) {
            if (!ICM_GetCListAttributes( pUnauthAttrList,
                    pUnauthAttrs, ppbExtra, plRemainExtra))
                goto GetCListUnauthAttrsError;
        } else {
            if (!ICM_GetOssAttributes( &posi->unauthAttributes,
                    pUnauthAttrs, ppbExtra, plRemainExtra))
                goto GetOssUnauthAttrsError;
        }
    } else if (0 <= *plRemainExtra)
        pUnauthAttrs->cAttr = 0;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssHashAlgorithmError)               // error already set
TRACE_ERROR(GetOssHashEncryptionAlgorithmError)     // error already set
TRACE_ERROR(GetOssEncryptedHashError)               // error already set
TRACE_ERROR(GetOssAuthAttrsError)                   // error already set
TRACE_ERROR(GetCListUnauthAttrsError)               // error already set
TRACE_ERROR(GetOssUnauthAttrsError)                 // error already set
}

//+-------------------------------------------------------------------------
//  Get a CMS SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCmsSignerInfo(
    IN SignerInfo   *posi,
    IN CBlobList    *pUnauthAttrList,
    OUT PCMSG_CMS_SIGNER_INFO psi,
    IN OUT PBYTE    *ppbExtra,
    IN OUT LONG     *plRemainExtra)
{
    BOOL        fRet;

    if (0 <= *plRemainExtra)
        psi->dwVersion = posi->version;

    if (!ICM_GetOssCertIdentifier(&posi->sid, &psi->SignerId,
            ppbExtra, plRemainExtra))
        goto GetOssCertIdentifierError;

    if (!ICM_GetOssSharedSignerInfo(
            posi,
            pUnauthAttrList,
            &psi->HashAlgorithm,
            &psi->HashEncryptionAlgorithm,
            &psi->EncryptedHash,
            &psi->AuthAttrs,
            &psi->UnauthAttrs,
            ppbExtra,
            plRemainExtra))
        goto GetOssSharedSignerInfoError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssCertIdentifierError)              // error already set
TRACE_ERROR(GetOssSharedSignerInfoError)            // error already set
}


//+-------------------------------------------------------------------------
//  Get a PKCS SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssPkcsSignerInfo(
    IN SignerInfo   *posi,
    IN CBlobList    *pUnauthAttrList,
    OUT PCMSG_SIGNER_INFO psi,
    IN OUT PBYTE    *ppbExtra,
    IN OUT LONG     *plRemainExtra)
{
    BOOL        fRet;

    if (0 <= *plRemainExtra)
        psi->dwVersion = posi->version;

    if (!ICM_GetOssIssuerAndSerialNumberFromCertId(&posi->sid,
            &psi->Issuer, &psi->SerialNumber, ppbExtra, plRemainExtra))
        goto GetOssIssuerAndSerialNumberError;

    if (!ICM_GetOssSharedSignerInfo(
            posi,
            pUnauthAttrList,
            &psi->HashAlgorithm,
            &psi->HashEncryptionAlgorithm,
            &psi->EncryptedHash,
            &psi->AuthAttrs,
            &psi->UnauthAttrs,
            ppbExtra,
            plRemainExtra))
        goto GetOssSharedSignerInfoError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssIssuerAndSerialNumberError)       // error already set
TRACE_ERROR(GetOssSharedSignerInfoError)            // error already set
}


//+-------------------------------------------------------------------------
//  Decode a PKCS SignerInfo blob.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_PkcsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCMSG_SIGNER_INFO   psi = pInfo;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            pbEncoded,
            cbEncoded)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbInfo - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssPkcsSignerInfo(
            posi,
            NULL,       // pUnauthAttrList
            psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pInfo, pcbInfo);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbInfo = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssSignerInfoError)      // error already set
dwFlags;
lpszStructType;
}


//+-------------------------------------------------------------------------
//  Find the Pkcs SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetPkcsSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CSignerNode         *pSignerNode;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB     DataBlob;
    PCMSG_SIGNER_INFO   psi = (PCMSG_SIGNER_INFO)pvData;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssPkcsSignerInfo( posi, pSignerNode->Data()->pUnauthAttrList,
                psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(FindSignerInfoError)            // error already set
TRACE_ERROR(GetOssSignerInfoError)          // error already set
}

//+-------------------------------------------------------------------------
//  Decode a CMS SignerInfo blob.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_CmsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_CMS_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCMSG_CMS_SIGNER_INFO psi = pInfo;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            pbEncoded,
            cbEncoded)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_CMS_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbInfo - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssCmsSignerInfo(
            posi,
            NULL,       // pUnauthAttrList
            psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pInfo, pcbInfo);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbInfo = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssSignerInfoError)      // error already set
dwFlags;
lpszStructType;
}


//+-------------------------------------------------------------------------
//  Find the CMS SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCmsSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CSignerNode         *pSignerNode;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB     DataBlob;
    PCMSG_CMS_SIGNER_INFO psi = (PCMSG_CMS_SIGNER_INFO)pvData;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_CMS_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssCmsSignerInfo( posi, pSignerNode->Data()->pUnauthAttrList,
                psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(FindSignerInfoError)            // error already set
TRACE_ERROR(GetOssSignerInfoError)          // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer, while encoding a message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetSignerParamEncoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    ASN1error_e     Asn1Err;
    ASN1encoding_t  pEnc = ICM_GetEncoder();
    PBYTE           pbEncoded = NULL;
    DWORD           cbEncoded;
    SignerInfo      *posi = NULL;


    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&posi))
        goto FindSignerInfoError;

    switch (dwParamType) {

    case CMSG_ENCODED_SIGNER:
        if (0 != (Asn1Err = PkiAsn1Encode(
                pEnc,
                posi,
                SignerInfo_PDU,
                &pbEncoded,
                &cbEncoded)))
            goto EncodeSignerInfoError;
        break;

    default:
        goto InvalidParamError;
    }

    fRet = ICM_CopyOut(
                pbEncoded,
                cbEncoded,
                (PBYTE)pvData,
                pcbData);
    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FindSignerInfoError)        // error already set
SET_ERROR_VAR(EncodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidParamError,E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetSignerParam(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    ASN1uint32_t            pdunumRef = 0;      // invalid
    SignerInfoWithBlobs     *posib = NULL;
    PVOID                   pv = NULL;
    CSignerNode             *pSignerNode;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoError;

    switch (dwParamType) {

    case CMSG_SIGNER_INFO_PARAM:
        fRet = ICM_GetPkcsSignerInfo( pcmi, dwIndex, pvData, pcbData);
        break;
    case CMSG_CMS_SIGNER_INFO_PARAM:
        fRet = ICM_GetCmsSignerInfo( pcmi, dwIndex, pvData, pcbData);
        break;

    case CMSG_ENCRYPTED_DIGEST:
        fRet = ICM_CopyOut(
                    (PBYTE)posib->encryptedDigest.value,
                    (DWORD)posib->encryptedDigest.length,
                    (PBYTE)pvData,
                    pcbData);
        break;

    case CMSG_ENCODED_SIGNER:
        if (pSignerNode->Data()->pUnauthAttrList) {
            // Need to re-encode with new unauth attrs
            goto ReEncodedSignerNotImplementedError;
        } else {
            fRet = ICM_CopyOut(
                        pSignerNode->Data()->blob.pbData,
                        pSignerNode->Data()->blob.cbData,
                        (PBYTE)pvData,
                        pcbData);
        }
        break;

    case CMSG_SIGNER_CERT_INFO_PARAM:
    case CMSG_SIGNER_CERT_ID_PARAM:
        pdunumRef = CertIdentifier_PDU;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                &pv,
                pdunumRef,
                (BYTE *) posib->sid.value,
                posib->sid.length)))
            goto DecodeCertIdentifierError;
        if (CMSG_SIGNER_CERT_INFO_PARAM == dwParamType)
            fRet = ICM_GetCertInfoIssuerAndSerialNumber(
                    (CertIdentifier *)pv,
                    pvData,
                    pcbData);
        else
            fRet = ICM_GetCertId(
                    (CertIdentifier *)pv,
                    pvData,
                    pcbData);
        break;

    case CMSG_SIGNER_HASH_ALGORITHM_PARAM:
        pdunumRef = AlgorithmIdentifierNC2_PDU;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                &pv,
                pdunumRef,
                (BYTE *) posib->digestAlgorithm.value,
                posib->digestAlgorithm.length)))
            goto DecodeAlgorithmIdentifierNC2Error;
        fRet = ICM_GetALGORITHM_IDENTIFIER(
                (AlgorithmIdentifier *)pv,
                pvData,
                pcbData);
        break;

    case CMSG_SIGNER_AUTH_ATTR_PARAM:
        if (posib->bit_mask & authAttributes_present)
            fRet = ICM_GetAttributesData(
                        (Attributes *)&posib->authAttributes,
                        pvData,
                        pcbData);
        else
            goto AuthAttrMissingError;
        break;

    case CMSG_SIGNER_UNAUTH_ATTR_PARAM:
        if (posib->bit_mask & unauthAttributes_present)
            fRet = ICM_GetAttributesData(
                        (Attributes *)&posib->unauthAttributes,
                        pvData,
                        pcbData);
        else
            goto UnauthAttrMissingError;
        break;

    default:
        goto InvalidParamError;
    }
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, pdunumRef, pv);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeCertIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeAlgorithmIdentifierNC2Error, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(AuthAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
SET_ERROR(UnauthAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
SET_ERROR(ReEncodedSignerNotImplementedError,E_INVALIDARG)
SET_ERROR(InvalidParamError,E_INVALIDARG)
TRACE_ERROR(FindSignerInfoError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Get the encoded blob for a SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncodedSignerInfo(
    IN DWORD                dwEncodingType,
    IN PSIGNER_DATA_INFO    pSignerInfo,
    OUT PBYTE               pbSignerInfo,
    IN OUT PDWORD           pcbSignerInfo)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithAttrBlobs *posiab = NULL;
    Any                     *pAnyAttr = NULL;
    Any                     *pAny;
    DWORD                   cAnyAttr;
    AttributesNC            unauthAttributesSave;
                                        ZEROSTRUCT(unauthAttributesSave);
#ifdef OSS_CRYPT_ASN1
    BYTE                    bit_maskSave = 0;
#else
    ASN1uint16_t            bit_maskSave = 0;
#endif  // OSS_CRYPT_ASN1
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;
    CBlobNode               *pnBlob;
    DWORD                   cbOut;
    PBYTE                   pbOut;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    if (pSignerInfo->pUnauthAttrList) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&posiab,
                SignerInfoWithAttrBlobs_PDU,
                pSignerInfo->blob.pbData,
                pSignerInfo->blob.cbData)))
            goto DecodeSignerInfoWithAttrBlobsError;
        // We have to take into account both the case where we have added
        // unauth attrs, and the case where we have removed them. There might
        // have been unauth attrs in the original message, and we removed
        // them all. Or, there might have been none originally, and we added
        // some.
        bit_maskSave = posiab->bit_mask;
        unauthAttributesSave = posiab->unauthAttributes;
        cAnyAttr = pSignerInfo->pUnauthAttrList->Length();
        posiab->bit_mask &= ~unauthAttributes_present;
        posiab->bit_mask |= (cAnyAttr > 0) ? unauthAttributes_present : 0;
        if (NULL == (pAnyAttr = (Any *)ICM_AllocA( cAnyAttr * sizeof(Any))))
            goto AllocAnyAttrError;
        posiab->unauthAttributes.count = cAnyAttr;
        posiab->unauthAttributes.value = pAnyAttr;
        for (pnBlob=pSignerInfo->pUnauthAttrList->Head(), pAny=pAnyAttr;
                pnBlob;
                pnBlob=pnBlob->Next(), pAny++)
            *pAny = *(Any *)pnBlob->Data();
        if (0 != (Asn1Err = PkiAsn1Encode(
                pEnc,
                posiab,
                SignerInfoWithAttrBlobs_PDU,
                &pbEncoded,
                &cbEncoded)))
            goto EncodeSignerInfoWithAttrBlobsError;
        cbOut = cbEncoded;
        pbOut = pbEncoded;
    } else {
        cbOut = pSignerInfo->blob.cbData;
        pbOut = pSignerInfo->blob.pbData;
    }

    fRet = ICM_CopyOut(
                pbOut,
                cbOut,
                pbSignerInfo,
                pcbSignerInfo);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    ICM_FreeA( pAnyAttr);
    if (posiab) {
        posiab->bit_mask = bit_maskSave;
        posiab->unauthAttributes = unauthAttributesSave;
        PkiAsn1FreeDecoded(pDec, posiab, SignerInfoWithAttrBlobs_PDU);
    }
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoWithAttrBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeSignerInfoWithAttrBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AllocAnyAttrError)              // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncodedMessageParam(
    IN PCRYPT_MSG_INFO  pcmi,
    OUT PBYTE           pbEncodedMessage,
    IN OUT PDWORD       pcbEncodedMessage)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignedDataWithBlobs     *posdb = NULL;
    PSIGNED_DATA_INFO       psdi = pcmi->psdi;
    Any                     *pAny;
    PSIGNER_DATA_INFO       pSignerInfo;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncodedSignedData = NULL;
    DWORD                   cbEncodedSignedData;
    PBYTE                   pbEncodedContentInfo = NULL;
    DWORD                   cbEncodedContentInfo;
    CSignerNode             *pnSigner;
    CBlobNode               *pnBlob;
    DWORD                   cb;
    PBYTE                   pb;
    DWORD                   i;
    ContentInfo             ci;


    if (NULL == (posdb = (SignedDataWithBlobs *)ICM_AllocZeroA(
                sizeof(SignedDataWithBlobs) +
                sizeof(Any) *
                   (psdi->pAlgidList->Length() +
                    psdi->pCertificateList->Length() +
                    psdi->pCrlList->Length() +
                    psdi->pSignerList->Length()))))
        goto AllocSignedDataWithBlobsError;
    pAny = (Any *)(posdb + 1);

    // version
    posdb->version = psdi->version;

    // digest algorithms
    posdb->digestAlgorithms.count = psdi->pAlgidList->Length();
    posdb->digestAlgorithms.value = pAny;
    for (pnBlob=psdi->pAlgidList->Head();
            pnBlob;
            pnBlob=pnBlob->Next())
        *pAny++ = *(Any *)pnBlob->Data();

    // contentInfo
    posdb->contentInfo.contentType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            psdi->pci->pszContentType,
            &posdb->contentInfo.contentType.count,
            posdb->contentInfo.contentType.value))
        goto PkiAsn1ToObjectIdentifierError;
    if (psdi->pci->content.cbData) {
        posdb->contentInfo.bit_mask |= content_present;
        posdb->contentInfo.content.length = psdi->pci->content.cbData;
        posdb->contentInfo.content.value  = psdi->pci->content.pbData;
    }

    // certificates
    posdb->certificates.count = psdi->pCertificateList->Length();
#ifdef OSS_CRYPT_ASN1
    posdb->certificates.certificates = pAny;
#else
    posdb->certificates.value = pAny;
#endif  // OSS_CRYPT_ASN1
    for (pnBlob=psdi->pCertificateList->Head();
            pnBlob;
            pnBlob=pnBlob->Next()) {
        posdb->bit_mask |= certificates_present;
        *pAny++ = *(Any *)pnBlob->Data();
    }

    // crls
    posdb->crls.count = psdi->pCrlList->Length();
#ifdef OSS_CRYPT_ASN1
    posdb->crls.crls  = pAny;
#else
    posdb->crls.value  = pAny;
#endif  // OSS_CRYPT_ASN1
    for (pnBlob=psdi->pCrlList->Head();
            pnBlob;
            pnBlob=pnBlob->Next()) {
        posdb->bit_mask |= crls_present;
        *pAny++ = *(Any *)pnBlob->Data();
    }

    // signerInfos
    posdb->signerInfos.count = psdi->pSignerList->Length();
    posdb->signerInfos.value = pAny;
    for (pnSigner=psdi->pSignerList->Head();
            pnSigner;
            pnSigner=pnSigner->Next()) {
        pSignerInfo = pnSigner->Data();
        if (!ICM_GetEncodedSignerInfo(
                PKCS_7_ASN_ENCODING,
                pnSigner->Data(),
                NULL,
                &cb))
            goto GetEncodedSignerInfoSizeError;
        if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
            goto AllocEncodedSignerInfoError;
        if (!ICM_GetEncodedSignerInfo(
                PKCS_7_ASN_ENCODING,
                pnSigner->Data(),
                pb,
                &cb))
            goto GetEncodedSignerInfoError;
        pAny->length = cb;
        pAny->value  = pb;
        pAny++;
    }

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            posdb,
            SignedDataWithBlobs_PDU,
            &pbEncodedSignedData,
            &cbEncodedSignedData)))
        goto EncodeSignedDataWithBlobsError;

    ci.contentType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            szOID_RSA_signedData,
            &ci.contentType.count,
            ci.contentType.value))
        goto ConvSignedDataToOidError;
    ci.bit_mask = content_present;
    ci.content.length = cbEncodedSignedData;
    ci.content.value = pbEncodedSignedData;

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ci,
            ContentInfo_PDU,
            &pbEncodedContentInfo,
            &cbEncodedContentInfo)))
        goto EncodeContentInfoError;

    fRet = ICM_CopyOut(
                pbEncodedContentInfo,
                cbEncodedContentInfo,
                pbEncodedMessage,
                pcbEncodedMessage);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncodedSignedData);
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentInfo);

    if (NULL != posdb) {
        for (i=posdb->signerInfos.count, pAny=posdb->signerInfos.value;
                i>0;
                i--, pAny++)
            ICM_FreeA( pAny->value);
        ICM_FreeA(posdb);
    }

    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeSignedDataWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ConvSignedDataToOidError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeContentInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AllocSignedDataWithBlobsError)      // error already set
TRACE_ERROR(GetEncodedSignerInfoSizeError)      // error already set
TRACE_ERROR(AllocEncodedSignerInfoError)        // error already set
TRACE_ERROR(GetEncodedSignerInfoError)          // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get Oss OctetString
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssOctetString(
    IN OctetStringType *pOssOctetString,
    OUT PCRYPT_DATA_BLOB pOctetString,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetOctetString(pOssOctetString->length, pOssOctetString->value, 0,
        pOctetString, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Get Oss BitString
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssBitString(
    IN BitStringType *pOssBitString,
    OUT PCRYPT_BIT_BLOB pBitString,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetBitString(pOssBitString->length, pOssBitString->value, 0,
        pBitString, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Get an Oss IssuerAndSerialNumber
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumber(
    IN IssuerAndSerialNumber *pOssIssuerAndSerialNumber,
    OUT PCERT_ISSUER_SERIAL_NUMBER pIssuerAndSerialNumber,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    ICM_GetOssHugeInteger(&pOssIssuerAndSerialNumber->serialNumber,
            &pIssuerAndSerialNumber->SerialNumber, ppbExtra, plRemainExtra);
    return ICM_GetOssAny(&pOssIssuerAndSerialNumber->issuer,
            &pIssuerAndSerialNumber->Issuer, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Get Oss CertIdentifier
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCertIdentifier(
    IN CertIdentifier *pOssCertId,
    OUT PCERT_ID pCertId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;

    if (0 <= *plRemainExtra) {
        assert(CERT_ID_ISSUER_SERIAL_NUMBER == issuerAndSerialNumber_chosen);
        assert(CERT_ID_KEY_IDENTIFIER == subjectKeyIdentifier_chosen);
        pCertId->dwIdChoice = pOssCertId->choice;
    }

    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            if (!ICM_GetOssIssuerAndSerialNumber(
                    &pOssCertId->u.issuerAndSerialNumber,
                    &pCertId->IssuerSerialNumber, ppbExtra, plRemainExtra))
                goto GetOssIssuerAndSerialNumberError;
            break;
        case subjectKeyIdentifier_chosen:
            ICM_GetOssOctetString( &pOssCertId->u.subjectKeyIdentifier,
                &pCertId->KeyId, ppbExtra, plRemainExtra);
            break;
        default:
            goto InvalidCertIdChoice;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssIssuerAndSerialNumberError)
SET_ERROR(InvalidCertIdChoice, CRYPT_E_BAD_ENCODE)
}

//+-------------------------------------------------------------------------
//  Get Oss OtherKeyAttribute
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssOtherKeyAttribute(
    IN OtherKeyAttribute *pOssOtherAttr,
    OUT PCRYPT_ATTRIBUTE_TYPE_VALUE *ppOtherAttr,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;

    lData = INFO_LEN_ALIGN(sizeof(CRYPT_ATTRIBUTE_TYPE_VALUE));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pOtherAttr = (PCRYPT_ATTRIBUTE_TYPE_VALUE) *ppbExtra;
        memset(pOtherAttr, 0, sizeof(*pOtherAttr));
        *ppOtherAttr = pOtherAttr;

        *ppbExtra += lData;
    } else
        pOtherAttr = NULL;

    if (!ICM_GetOssObjId(&pOssOtherAttr->keyAttrId, &pOtherAttr->pszObjId,
            ppbExtra, plRemainExtra))
        goto GetOssObjIdError;
    if (pOssOtherAttr->bit_mask & keyAttr_present) {
        if (!ICM_GetOssAny(&pOssOtherAttr->keyAttr,
                &pOtherAttr->Value, ppbExtra, plRemainExtra))
            goto GetOssAnyError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssObjIdError)
TRACE_ERROR(GetOssAnyError)
}


//+-------------------------------------------------------------------------
//  Get Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssKeyTransRecipientInfo(
    IN KeyTransRecipientInfo *pori,
    OUT PCMSG_KEY_TRANS_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_KEY_TRANS_RECIPIENT_INFO pri;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_KEY_TRANS_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_KEY_TRANS_RECIPIENT_INFO) *ppbExtra;
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }
    
    if (!ICM_GetOssCertIdentifier(&pori->rid, &pri->RecipientId,
            ppbExtra, plRemainExtra))
        goto GetOssCertIdentifierError;

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    ICM_GetOssOctetString(&pori->encryptedKey, &pri->EncryptedKey,
        ppbExtra, plRemainExtra);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssCertIdentifierError)
TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
}

//+-------------------------------------------------------------------------
//  Get Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssKeyAgreeRecipientInfo(
    IN KeyAgreeRecipientInfo *pori,
    OUT PCMSG_KEY_AGREE_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_KEY_AGREE_RECIPIENT_INFO pri;
    DWORD count;
    OriginatorIdentifierOrKey *pooriginator;
    OriginatorPublicKey *pooriginatorKey;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_KEY_AGREE_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_KEY_AGREE_RECIPIENT_INFO) *ppbExtra;
        memset(pri, 0, sizeof(*pri));
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }
    
    pooriginator = &pori->originator;
    switch (pooriginator->choice) {
        case issuerAndSerialNumber_chosen:
            if (!ICM_GetOssIssuerAndSerialNumber(
                    &pooriginator->u.issuerAndSerialNumber,
                    &pri->OriginatorCertId.IssuerSerialNumber,
                    ppbExtra, plRemainExtra))
                goto GetOssOriginatorIssuerAndSerialNumberError;
            if (0 <= *plRemainExtra) {
                pri->OriginatorCertId.dwIdChoice =
                    CERT_ID_ISSUER_SERIAL_NUMBER;
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_CERT;
            }
            break;
        case subjectKeyIdentifier_chosen:
            ICM_GetOssOctetString(
                &pooriginator->u.subjectKeyIdentifier,
                &pri->OriginatorCertId.KeyId,
                ppbExtra, plRemainExtra);
            if (0 <= *plRemainExtra) {
                pri->OriginatorCertId.dwIdChoice =
                    CERT_ID_KEY_IDENTIFIER;
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_CERT;
            }
            break;
        case originatorKey_chosen:
            pooriginatorKey = &pooriginator->u.originatorKey;
            if (!ICM_GetOssAlgorithm(&pooriginatorKey->algorithm,
                    &pri->OriginatorPublicKeyInfo.Algorithm,
                    ppbExtra, plRemainExtra
                    ))
                goto GetOssOriginatorPublicKeyAlgorithmError;
            ICM_GetOssBitString(&pooriginatorKey->publicKey,
                &pri->OriginatorPublicKeyInfo.PublicKey,
                ppbExtra, plRemainExtra);
            if (0 <= *plRemainExtra)
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY;
            break;
        default:
            goto InvalidOriginatorChoice;
    }

    if (pori->bit_mask & ukm_present)
        ICM_GetOssOctetString(&pori->ukm, &pri->UserKeyingMaterial,
            ppbExtra, plRemainExtra);

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    count = pori->recipientEncryptedKeys.count;
    if (0 < count) {
        RecipientEncryptedKey *porek;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO prek;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *pprek;

        lData = INFO_LEN_ALIGN(
            count * sizeof(PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO) +
            count * sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_INFO));

        *plRemainExtra -= lData;
        if (0 <= *plRemainExtra) {
            pprek = (PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *) *ppbExtra;
            prek = (PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO) (((PBYTE) pprek) +
                (count * sizeof(PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO)));
            *ppbExtra += lData;

            pri->cRecipientEncryptedKeys = count;
            pri->rgpRecipientEncryptedKeys = pprek;
        } else {
            pprek = NULL;
            prek = NULL;
        }

        porek = pori->recipientEncryptedKeys.value;
        for ( ; 0 < count; count--, porek++, prek++, pprek++) {
            RecipientIdentifier *porid = &porek->rid;

            if (0 <= *plRemainExtra) {
                memset(prek, 0, sizeof(*prek));
                *pprek = prek;

                assert(issuerAndSerialNumber_chosen ==
                    CERT_ID_ISSUER_SERIAL_NUMBER);
                assert(rKeyId_chosen ==
                    CERT_ID_KEY_IDENTIFIER);
                prek->RecipientId.dwIdChoice = porid->choice;
            }

            ICM_GetOssOctetString(&porek->encryptedKey, &prek->EncryptedKey,
                ppbExtra, plRemainExtra);

            switch (porid->choice) {
                case issuerAndSerialNumber_chosen:
                    if (!ICM_GetOssIssuerAndSerialNumber(
                            &porid->u.issuerAndSerialNumber,
                            &prek->RecipientId.IssuerSerialNumber,
                            ppbExtra, plRemainExtra))
                        goto GetOssIssuerAndSerialNumberError;
                    break;
                case rKeyId_chosen:
                    ICM_GetOssOctetString(
                        &porid->u.rKeyId.subjectKeyIdentifier,
                        &prek->RecipientId.KeyId, ppbExtra, plRemainExtra);

                    if (porid->u.rKeyId.bit_mask & date_present) {
                        if (0 <= *plRemainExtra) {
                            if (!PkiAsn1FromGeneralizedTime(
                                    &porid->u.rKeyId.date, &prek->Date))
                                goto ConvFromGeneralizedTimeError;
                        }
                    }

                    if (porid->u.rKeyId.bit_mask & other_present) {
                        if (!ICM_GetOssOtherKeyAttribute(
                                &porid->u.rKeyId.other,
                                &prek->pOtherAttr,
                                ppbExtra, plRemainExtra))
                            goto GetOssOtherKeyAttributeError;
                    }
                    break;
                default:
                    goto InvalidRecipientChoice;
            }
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssOriginatorIssuerAndSerialNumberError)
TRACE_ERROR(GetOssOriginatorPublicKeyAlgorithmError)
TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
TRACE_ERROR(GetOssIssuerAndSerialNumberError)
TRACE_ERROR(ConvFromGeneralizedTimeError)
TRACE_ERROR(GetOssOtherKeyAttributeError)
SET_ERROR(InvalidOriginatorChoice, CRYPT_E_BAD_ENCODE)
SET_ERROR(InvalidRecipientChoice, CRYPT_E_BAD_ENCODE)
}


//+-------------------------------------------------------------------------
//  Get Oss MailListRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssMailListRecipientInfo(
    IN MailListRecipientInfo *pori,
    OUT PCMSG_MAIL_LIST_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_MAIL_LIST_RECIPIENT_INFO pri;
    MailListKeyIdentifier *pomlid;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_MAIL_LIST_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_MAIL_LIST_RECIPIENT_INFO) *ppbExtra;
        memset(pri, 0, sizeof(*pri));
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }

    pomlid = &pori->mlid;
    ICM_GetOssOctetString(&pomlid->kekIdentifier, &pri->KeyId,
        ppbExtra, plRemainExtra);

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    ICM_GetOssOctetString(&pori->encryptedKey, &pri->EncryptedKey,
        ppbExtra, plRemainExtra);


    if (pomlid->bit_mask & date_present) {
        if (0 <= *plRemainExtra) {
            if (!PkiAsn1FromGeneralizedTime(
                    &pomlid->date, &pri->Date))
                goto ConvFromGeneralizedTimeError;
        }
    }

    if (pomlid->bit_mask & other_present) {
        if (!ICM_GetOssOtherKeyAttribute(
                &pomlid->other,
                &pri->pOtherAttr,
                ppbExtra, plRemainExtra))
            goto GetOssOtherKeyAttributeError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
TRACE_ERROR(ConvFromGeneralizedTimeError)
TRACE_ERROR(GetOssOtherKeyAttributeError)
}

//+-------------------------------------------------------------------------
//  Copy out a CMSG_CMS_RECIPIENT_INFO
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCmsRecipientInfo(
    IN CmsRecipientInfo *pori,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_CMS_RECIPIENT_INFO pri = (PCMSG_CMS_RECIPIENT_INFO) pvData;
    PBYTE pbExtra;
    LONG lRemainExtra;

    if (NULL == pvData)
        *pcbData = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN(sizeof(CMSG_CMS_RECIPIENT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pri = NULL;
        pbExtra = NULL;
    } else {
        assert(CMSG_KEY_TRANS_RECIPIENT == keyTransRecipientInfo_chosen);
        assert(CMSG_KEY_AGREE_RECIPIENT == keyAgreeRecipientInfo_chosen);
        assert(CMSG_MAIL_LIST_RECIPIENT == mailListRecipientInfo_chosen);
        pri->dwRecipientChoice = pori->choice;

        pbExtra = (PBYTE) pri + lData;
    }

    switch (pori->choice) {
        case keyTransRecipientInfo_chosen:
            if (!ICM_GetOssKeyTransRecipientInfo(
                    &pori->u.keyTransRecipientInfo,
                    &pri->pKeyTrans,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssKeyTransRecipientInfoError;
            break;
        case keyAgreeRecipientInfo_chosen:
            if (!ICM_GetOssKeyAgreeRecipientInfo(
                    &pori->u.keyAgreeRecipientInfo,
                    &pri->pKeyAgree,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssKeyAgreeRecipientInfoError;
            break;
        case mailListRecipientInfo_chosen:
            if (!ICM_GetOssMailListRecipientInfo(
                    &pori->u.mailListRecipientInfo,
                    &pri->pMailList,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssMailListRecipientInfoError;
            break;
        default:
            goto InvalidRecipientChoice;

    }

    fRet = ICM_GetSizeFromExtra(lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssKeyTransRecipientInfoError)
TRACE_ERROR(GetOssKeyAgreeRecipientInfoError)
TRACE_ERROR(GetOssMailListRecipientInfoError)
SET_ERROR(InvalidRecipientChoice, CRYPT_E_BAD_ENCODE)
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Get a parameter after encoding/decoding a cryptographic message. Called
//  after the final CryptMsgUpdate. Only the CMSG_CONTENT_PARAM and
//  CMSG_COMPUTED_HASH_PARAM are valid for an encoded message.
//
//  For an encoded HASHED message, the CMSG_COMPUTED_HASH_PARAM can be got
//  before any CryptMsgUpdates to get its length.
//
//  The pvData type definition depends on the dwParamType value.
//
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  Upon input, if *pcbData == 0, then, *pcbData is updated with the length
//  of the data and the pvData parameter is ignored.
//
//  Upon return, *pcbData is updated with the length of the data.
//
//  The OBJID BLOBs returned in the pvData structures point to
//  their still encoded representation. The appropriate functions
//  must be called to decode the information.
//
//  See wincrypt.h for a list of the parameters to get.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgGetParam(
#else
CryptMsgGetParam(
#endif
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    ASN1error_e         Asn1Err;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;
    BOOL                fBER = FALSE;                

    DWORD dwExceptionCode;

    ICM_Lock( pcmi);    // Single thread access to HCRYPTMSG

  // Handle MappedFile Exceptions
  __try {

    if (NULL == pvData)
        *pcbData = 0;

#ifdef CMS_PKCS7
    if (CMSG_VERSION_PARAM == dwParamType) {
        int version = 0;

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (pcmi->fEncoding) {
                if (NULL == pcmi->pvMsg)
                    goto InvalidMessageDataError;
                version = ((SignedData *)pcmi->pvMsg)->version;
            } else {
                if (NULL == pcmi->psdi)
                    goto MessageNotDecodedError;
                version = pcmi->psdi->version;
            }
            break;
        case CMSG_ENVELOPED:
            if (NULL == pcmi->pvMsg)
                goto MessageNotDecodedError;
            version = ((CmsEnvelopedData *)pcmi->pvMsg)->version;
            break;
        case CMSG_HASHED:
            if (NULL == pcmi->pvMsg)
                goto MessageNotDecodedError;
            version = ((DigestedData *)pcmi->pvMsg)->version;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        case CMSG_ENCRYPTED:
        case CMSG_DATA:
        default:
            goto InvalidMsgType;
        }

        fRet = ICM_GetDWORD(version, pvData, pcbData);
        goto PreserveLengthReturn;
    }
#endif  // CMS_PKCS7

    if (pcmi->fEncoding) {
        switch (dwParamType) {
        case CMSG_CONTENT_PARAM:
        case CMSG_BARE_CONTENT_PARAM:
            {
                ContentInfo     ci;
                ASN1encoding_t  pEnc = ICM_GetEncoder();
                PBYTE           pbEncoded = NULL;
                DWORD           cbEncoded;
                PBYTE           pbContent = NULL;

                if (pcsi)
                    goto GetContentParamNotValidForStreaming;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (0 == ((SignedData *) pcmi->pvMsg)->signerInfos.count)
                        // For a bag of certs, don't DER order
                        fBER = TRUE;
                    break;
                case CMSG_DATA:
                case CMSG_ENVELOPED:
                case CMSG_HASHED:
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                if (fBER)
                    PkiAsn1SetEncodingRule(ICM_GetEncoder(), ASN1_BER_RULE_BER);

                if (0 != (Asn1Err = PkiAsn1Encode(
                        pEnc,
                        pcmi->pvMsg,
                        aiPduNum[ pcmi->dwMsgType - 1],
                        &pbEncoded,
                        &cbEncoded))) {
                    goto CONTENT_PARAMAsn1EncodeError;
                }

                if (CMSG_CONTENT_PARAM == dwParamType) {
                    if (!ICM_CopyOssObjectIdentifier(
                            &ci.contentType,
                            &aoidMessages[ pcmi->dwMsgType - 1]))
                        goto CopyOssObjectIdentifierContentTypeError;
                    ci.bit_mask = content_present;
                    ci.content.length = cbEncoded;
                    ci.content.value = pbEncoded;
                    pbContent = pbEncoded;

                    if (0 != (Asn1Err = PkiAsn1Encode(
                            pEnc,
                            &ci,
                            ContentInfo_PDU,
                            &pbEncoded,
                            &cbEncoded))) {
                        PkiAsn1FreeEncoded(pEnc, pbContent);
                        goto Asn1EncodeSignedDataError;
                    }
                }

                fRet = ICM_CopyOut(
                            pbEncoded,
                            cbEncoded,
                            (PBYTE)pvData,
                            pcbData);
                if (!fRet)
                    dwError = GetLastError();
                if (pbContent)
                    PkiAsn1FreeEncoded(pEnc, pbContent);
                PkiAsn1FreeEncoded(pEnc, pbEncoded);
                if (!fRet)
                    SetLastError(dwError);
                break;
            }

        case CMSG_COMPUTED_HASH_PARAM:
            fRet = ICM_GetComputedDigestParam( pcmi, dwIndex, pvData, pcbData);
            break;

        case CMSG_ENCODED_SIGNER:
            switch (pcmi->dwMsgType) {
            case CMSG_SIGNED:
                break;
            case CMSG_SIGNED_AND_ENVELOPED:
                goto MessageTypeNotSupportedYet;
            default:
                goto InvalidMsgType;
            }
            fRet = ICM_GetSignerParamEncoding(
                            pcmi,
                            dwIndex,
                            dwParamType,
                            pvData,
                            pcbData);
            break;

        default:
            goto InvalidMsgType;
        }
    } else {
        //
        // Decode
        //
        switch (dwParamType) {
        case CMSG_TYPE_PARAM:
            if (pcsi && (0 == pcmi->dwMsgType))
                goto StreamMsgNotReadyError;
            fRet = ICM_GetDWORD( pcmi->dwMsgType, pvData, pcbData);
            break;
        case CMSG_CONTENT_PARAM:
            {
                ContentInfo     *pci;
                PCONTENT_INFO   pci2;
                PBYTE           pbDER = NULL;
                DWORD           cbDER;
                PBYTE           pb;
                DWORD           cb;

                if (pcsi)
                    goto GetContentParamNotValidForStreaming;

                switch (pcmi->dwMsgType) {
                case CMSG_DATA:
                {
                    OctetStringType *poos = (OctetStringType *)pcmi->pvMsg;

                    pb = (PBYTE)poos->value;
                    cb = poos->length;
                    fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                    break;
                }
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pci2 = pcmi->psdi->pci;
                    if (pci2->content.cbData) {
                        cb = pci2->content.cbData;
                        pb = pci2->content.pbData;

                        if (0 == strcmp(pszObjIdDataType,
                                pci2->pszContentType)
#ifdef CMS_PKCS7
                                ||  pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                                ) {
                            if (!ICM_ReEncodeAsOctetDER(
                                    pb,
                                    cb,
                                    &pbDER,
                                    &cbDER
                                    ))
                                goto ReEncodeAsOctetDERError;
                            if (pbDER) {
                                if (0 > Asn1UtilExtractContent( pbDER, cbDER,
                                        &cb, (const BYTE **)&pb)) {
                                    PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                                    goto ExtractContentError;
                                }
                            }
                        }

                        fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                        if (!fRet)
                            dwError = GetLastError();
                        if (pbDER)
                            PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                        if (!fRet)
                            SetLastError(dwError);
                    } else {
                        *pcbData = 0;
                        fRet = TRUE;
                    }
                    break;
                case CMSG_ENVELOPED:
                    if (NULL == pcmi->Plaintext.pbData) {
                        // Hasn't been decrypted yet

                        EncryptedContentInfo *peci;
                        PBYTE pbCiphertext;
                        DWORD cbCiphertext;
#ifdef CMS_PKCS7
                        peci = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#else
                        peci = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#endif  // CMS_PKCS7

                        if (peci->bit_mask & encryptedContent_present) {
                            pbCiphertext = peci->encryptedContent.value;
                            cbCiphertext = peci->encryptedContent.length;
                        } else {
                            pbCiphertext = NULL;
                            cbCiphertext = 0;
                        }


                        if (NULL == pvData) {
                            // Assume (sizeof plaintext) <=
                            // (sizeof ciphertext)
                            //
                            // not decrypted yet; return ciphertext size

                            fRet = TRUE;
                            // + 6 => to allow for identifier and length octets
                            *pcbData = cbCiphertext + 6;
                        } else
                            // Return ciphertext
                            fRet = ICM_CopyOut(
                                    pbCiphertext,
                                    cbCiphertext,
                                    (PBYTE)pvData,
                                    pcbData);
                        goto ContentCopiedOut;
                    }

                    if (!ICM_EqualObjectIDs(
#ifdef CMS_PKCS7
                            &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType,
                            &aoidMessages[ CMSG_DATA - 1])
                                    &&
                            CMSG_ENVELOPED_DATA_CMS_VERSION >
                                ((CmsEnvelopedData *)pcmi->pvMsg)->version) {
#else
                            &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType,
                            &aoidMessages[ CMSG_DATA - 1])) {
#endif  // CMS_PKCS7
                        // Not DATA or encapsulated, so must prepend
                        // identifier and length octets
                        fRet = ICM_CopyOutAddDERPrefix(
                                    pcmi->Plaintext.pbData,
                                    pcmi->Plaintext.cbData,
                                    ICM_TAG_SEQ,
                                    (PBYTE)pvData,
                                    pcbData);
                    } else {
                        fRet = ICM_CopyOut(
                                    pcmi->Plaintext.pbData,
                                    pcmi->Plaintext.cbData,
                                    (PBYTE)pvData,
                                    pcbData);
                    }
                    goto ContentCopiedOut;

                case CMSG_HASHED:
                    pci = &((DigestedData *)pcmi->pvMsg)->contentInfo;
                    if (pci->bit_mask & content_present) {
                        cb = (DWORD)pci->content.length;
                        pb = (PBYTE)pci->content.value;

                        if (ICM_EqualObjectIDs(
                                    &pci->contentType,
                                    &aoidMessages[ CMSG_DATA - 1])
#ifdef CMS_PKCS7
                                || ((DigestedData *)pcmi->pvMsg)->version >=
                                    CMSG_HASHED_DATA_V2 
#endif  // CMS_PKCS7
                                ) {
                            if (!ICM_ReEncodeAsOctetDER(
                                    pb,
                                    cb,
                                    &pbDER,
                                    &cbDER
                                    ))
                                goto ReEncodeAsOctetDERError;
                            if (pbDER) {
                                if (0 > Asn1UtilExtractContent( pbDER, cbDER,
                                        &cb, (const BYTE **)&pb)) {
                                    PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                                    goto ExtractContentError;
                                }
                            }
                        }

                        fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                        if (!fRet)
                            dwError = GetLastError();
                        if (pbDER)
                            PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                        if (!fRet)
                            SetLastError(dwError);
                    } else {
                        *pcbData = 0;
                        fRet = TRUE;
                    }
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
ContentCopiedOut:
                break;
            }

        case CMSG_INNER_CONTENT_TYPE_PARAM:
            {
                ContentType     *pct;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    fRet = ICM_CopyOut(
                                (PBYTE)pcmi->psdi->pci->pszContentType,
                                strlen( pcmi->psdi->pci->pszContentType) + 1,
                                (PBYTE)pvData,
                                pcbData);
                    goto ContentTypeCopiedOut;
                    break;
                case CMSG_ENVELOPED:
#ifdef CMS_PKCS7
                    pct = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType;
#else
                    pct = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType;
#endif  // CMS_PKCS7
                    break;
                case CMSG_HASHED:
                    pct = &((DigestedData *)pcmi->pvMsg)->contentInfo.contentType;
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = PkiAsn1FromObjectIdentifier(
                            pct->count,
                            pct->value,
                            (LPSTR)pvData,
                            pcbData);
ContentTypeCopiedOut:
                break;
            }

        case CMSG_ENCODED_MESSAGE:
            fRet = ICM_GetEncodedMessageParam(
                            pcmi,
                            (PBYTE)pvData,
                            pcbData);
            break;

        case CMSG_SIGNER_COUNT_PARAM:
            {
                DWORD   cSigner;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    cSigner = pcmi->psdi->pSignerList->Length();
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = ICM_GetDWORD( cSigner, pvData, pcbData);
                break;
            }

        case CMSG_ENCRYPTED_DIGEST:
        case CMSG_ENCODED_SIGNER:
        case CMSG_SIGNER_INFO_PARAM:
        case CMSG_SIGNER_CERT_INFO_PARAM:
        case CMSG_SIGNER_HASH_ALGORITHM_PARAM:
        case CMSG_SIGNER_AUTH_ATTR_PARAM:
        case CMSG_SIGNER_UNAUTH_ATTR_PARAM:

        case CMSG_CMS_SIGNER_INFO_PARAM:
        case CMSG_SIGNER_CERT_ID_PARAM:

            switch (pcmi->dwMsgType) {
            case CMSG_SIGNED:
                break;
            case CMSG_SIGNED_AND_ENVELOPED:
                goto MessageTypeNotSupportedYet;
            default:
                goto InvalidMsgType;
            }
            fRet = ICM_GetSignerParam(
                            pcmi,
                            dwIndex,
                            dwParamType,
                            pvData,
                            pcbData);
            break;

        case CMSG_CERT_COUNT_PARAM:
            {
                CBlobList *pBlobList;
                DWORD     dwCount;
#ifdef CMS_PKCS7
                BOOL      fPossibleAttrCert = FALSE;
#endif  // CMS_PKCS7

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
#ifdef CMS_PKCS7
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
#endif  // CMS_PKCS7
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                dwCount = pBlobList->Length();

#ifdef CMS_PKCS7
                if (dwCount && fPossibleAttrCert)
                    dwCount = ICM_GetTaggedBlobCount(
                        pBlobList,
                        ICM_TAG_SEQ
                        );
#endif  // CMS_PKCS7

                fRet = ICM_GetDWORD( dwCount, pvData, pcbData);
                break;
            }

        case CMSG_CERT_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
#ifdef CMS_PKCS7
                BOOL        fPossibleAttrCert = FALSE;
#endif  // CMS_PKCS7

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
#ifdef CMS_PKCS7
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
#endif  // CMS_PKCS7
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                // Get blob at specified cert index. Index
                // is advanced to the appropriate blob.
                pBlobNode = ICM_GetTaggedBlobAndAdvanceIndex(
                    pBlobList,
#ifdef CMS_PKCS7
                    (BYTE)( fPossibleAttrCert ? ICM_TAG_SEQ : 0),
#else
                    0,                  // bTag
#endif  // CMS_PKCS7
                    &dwIndex
                    );
                    
                if (pBlobNode)
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                else
                    fRet = FALSE;
                break;
            }

#ifdef CMS_PKCS7
        case CMSG_ATTR_CERT_COUNT_PARAM:
            {
                CBlobList *pBlobList;
                BOOL      fPossibleAttrCert = FALSE;
                DWORD     dwCount;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
                    break;
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
                default:
                    goto InvalidMsgType;
                }

                if (fPossibleAttrCert)
                    dwCount = ICM_GetTaggedBlobCount(
                        pBlobList,
                        ICM_TAG_CONSTRUCTED_CONTEXT_1
                        );
                else
                    dwCount = 0;

                fRet = ICM_GetDWORD( dwCount, pvData, pcbData);
                break;
            }

        case CMSG_ATTR_CERT_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
                BOOL        fPossibleAttrCert = FALSE;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
                    break;
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
                default:
                    goto InvalidMsgType;
                }

                if (!fPossibleAttrCert)
                    pBlobNode = NULL;
                else
                    // Get blob at specified attribute cert index. Index
                    // is advanced to the appropriate blob
                    pBlobNode = ICM_GetTaggedBlobAndAdvanceIndex(
                        pBlobList,
                        ICM_TAG_CONSTRUCTED_CONTEXT_1,
                        &dwIndex
                        );
                    
                if (pBlobNode) {
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                    if (fRet && pvData)
                        *((PBYTE)pvData) = ICM_TAG_SEQ;
                } else
                    fRet = FALSE;
                break;
            }
#endif  // CMS_PKCS7

        case CMSG_CRL_COUNT_PARAM:
            {
                CBlobList *pBlobList;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCrlList;
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCrlList;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = ICM_GetDWORD( pBlobList->Length(), pvData, pcbData);
                break;
            }

        case CMSG_CRL_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
                DWORD       i;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCrlList;
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCrlList;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                // This list-walking should be a class method
                for (i=dwIndex, pBlobNode=pBlobList->Head();
                        (i>0) && pBlobNode;
                        i--, pBlobNode=pBlobNode->Next())
                    ;
                if (pBlobNode)
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                else
                    fRet = FALSE;
                break;
            }

        case CMSG_ENVELOPE_ALGORITHM_PARAM:
            {
                ContentEncryptionAlgId  *pceai;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
#ifdef CMS_PKCS7
                    pceai = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentEncryptionAlgorithm;
#else
                    pceai = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentEncryptionAlgorithm;
#endif  // CMS_PKCS7
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetALGORITHM_IDENTIFIER( pceai, pvData, pcbData);
                break;
            }

#ifdef CMS_PKCS7
        case CMSG_UNPROTECTED_ATTR_PARAM:
            {
                CmsEnvelopedData *ped;

                ped = (CmsEnvelopedData *)pcmi->pvMsg;
                if (ped && (ped->bit_mask & unprotectedAttrs_present))
                    fRet = ICM_GetAttributesData(
                        &ped->unprotectedAttrs,
                        pvData,
                        pcbData);
                else
                    goto UnprotectedAttrMissingError;
            }
            break;

        case CMSG_RECIPIENT_COUNT_PARAM:
            {
                DWORD dwPkcsCount;
                if (!ICM_GetPkcsRecipientCount(pcmi, &dwPkcsCount))
                    goto GetPkcsRecipientCountError;
                fRet = ICM_GetDWORD(dwPkcsCount, pvData, pcbData);
            }
            break;

        case CMSG_RECIPIENT_INDEX_PARAM:
            {
                DWORD dwPkcsIndex;
                DWORD dwCmsIndex;
                DWORD cbData = sizeof(dwCmsIndex);

                if (!CryptMsgGetParam(
                        hCryptMsg,
                        CMSG_CMS_RECIPIENT_INDEX_PARAM,
                        0,                                  // dwIndex
                        &dwCmsIndex,
                        &cbData))
                    goto GetCmsRecipientIndexError;

                if (!ICM_ConvertCmsToPkcsRecipientIndex(
                        pcmi, dwCmsIndex, &dwPkcsIndex))
                    goto ConvertCmsToPkcsRecipientIndexError;

                fRet = ICM_GetDWORD(
                            dwPkcsIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_RECIPIENT_INFO_PARAM:
            {
                CmsRecipientInfos *pris;
                KeyTransRecipientInfo *pri;
                DWORD dwCmsIndex;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;

                if (!ICM_ConvertPkcsToCmsRecipientIndex(
                        pcmi, dwIndex, &dwCmsIndex))
                    goto ConvertPkcsToCmsRecipientIndexError;
                pri = &pris->value[dwCmsIndex].u.keyTransRecipientInfo;

                fRet = ICM_GetCertInfoIssuerAndSerialNumber(
                    &pri->rid, pvData, pcbData);
                break;
            }

        case CMSG_CMS_RECIPIENT_COUNT_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                fRet = ICM_GetDWORD(pris->count, pvData, pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_INDEX_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM:
            {
                CmsRecipientInfos *pris;
                CmsRecipientInfo *pri;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;

                pri = pris->value + pcmi->dwDecryptedRecipientIndex;
                if (keyAgreeRecipientInfo_chosen != pri->choice)
                    goto NotKeyAgreeRecipientIndex;
                
                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientEncryptedKeyIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_INFO_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                if (dwIndex >= pris->count)
                    goto IndexTooBig;
                fRet = ICM_GetCmsRecipientInfo(pris->value + dwIndex,
                    pvData, pcbData);
            }
            break;
#else

        case CMSG_RECIPIENT_COUNT_PARAM:
            {
                RecipientInfos *pris;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                    pris = &((EnvelopedData *)pcmi->pvMsg)->recipientInfos;
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetDWORD( pris->count, pvData, pcbData);
                break;
            }

        case CMSG_RECIPIENT_INDEX_PARAM:
            {
                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                case CMSG_SIGNED_AND_ENVELOPED:
                    break;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientIndex,
                            pvData,
                            pcbData);
                break;
            }

        case CMSG_RECIPIENT_INFO_PARAM:
            {
                RecipientInfos *pris;
                RecipientInfo  *pri;
                PCERT_INFO      pci = (PCERT_INFO)pvData;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                    pris = &((EnvelopedData *)pcmi->pvMsg)->recipientInfos;
                    if (dwIndex >= pris->count)
                        goto IndexTooBig;
                    pri = pris->value + dwIndex;
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                // for lRemainExtra < 0, LENGTH_ONLY calculation
                lData = INFO_LEN_ALIGN( sizeof(CERT_INFO));
                lRemainExtra = (LONG)*pcbData - lData;
                if (0 > lRemainExtra) {
                    pci = NULL;
                    pbExtra = NULL;
                } else {
                    pbExtra = (PBYTE)pci + lData;
                }
                if (!ICM_GetOssIssuerAndSerialNumber(
                        &pri->issuerAndSerialNumber,
                        pci, &pbExtra, &lRemainExtra))
                    goto GetOssIssuerAndSerialNumberError;
                fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);
                break;
            }
#endif  // CMS_PKCS7

        case CMSG_HASH_ALGORITHM_PARAM:
            fRet = ICM_GetALGORITHM_IDENTIFIER(
                            &((DigestedData *)pcmi->pvMsg)->digestAlgorithm,
                            pvData,
                            pcbData);
            break;

        case CMSG_HASH_DATA_PARAM:
            fRet = ICM_GetDigestDataParam( pcmi, pvData, pcbData);
            break;

        case CMSG_COMPUTED_HASH_PARAM:
            fRet = ICM_GetComputedDigestParam( pcmi, dwIndex, pvData, pcbData);
            break;

        case CMSG_ENCRYPT_PARAM:
#if 0
            {
                goto ParamTypeNotSupportedYet;
            }
#endif
        default:
            goto InvalidMsgType;
        }
    }

#ifdef CMS_PKCS7
PreserveLengthReturn:
#endif  // CMS_PKCS7

    if (!fRet)
        dwError = GetLastError();

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    if (fBER)
        PkiAsn1SetEncodingRule(ICM_GetEncoder(), ASN1_BER_RULE_DER);

    ICM_Unlock( pcmi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
StreamMsgNotReadyError:
    dwError = (DWORD)CRYPT_E_STREAM_MSG_NOT_READY;
    goto ErrorReturn;
SET_ERROR(GetContentParamNotValidForStreaming, E_INVALIDARG)
SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(CONTENT_PARAMAsn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(Asn1EncodeSignedDataError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(CopyOssObjectIdentifierContentTypeError)    // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)                    // error already set
SET_ERROR(InvalidSignedMessageError, ERROR_INVALID_DATA)
#ifdef CMS_PKCS7
SET_ERROR(MessageNotDecodedError, ERROR_INVALID_DATA)
SET_ERROR(InvalidMessageDataError, ERROR_INVALID_DATA)

TRACE_ERROR(GetDecodedCmsRecipientsError)
TRACE_ERROR(GetPkcsRecipientCountError)
TRACE_ERROR(ConvertCmsToPkcsRecipientIndexError)
TRACE_ERROR(ConvertPkcsToCmsRecipientIndexError)
TRACE_ERROR(GetCmsRecipientIndexError)
SET_ERROR(NotKeyAgreeRecipientIndex, CRYPT_E_INVALID_INDEX)
SET_ERROR(UnprotectedAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
#else
TRACE_ERROR(GetOssIssuerAndSerialNumberError)           // error already set
#endif  // CMS_PKCS7
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+=========================================================================
//  Data structures and functions to test and compare the NEW Net Meeting
//  ASN1 compiler and RTS with the OSS compiler and RTS.
//-=========================================================================

#ifdef DEBUG_CRYPT_ASN1

//#define DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG              0x010
//#define DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG      0x020
//#define DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG      0x100

//static BOOL fGotDebugCryptAsn1Flags = FALSE;
//static int iDebugCryptAsn1Flags = 0;

#ifdef DEBUG_CRYPT_ASN1_MASTER

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_OPEN_TO_ENCODE)(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );
static PFN_CRYPT_MSG_OPEN_TO_ENCODE pfnOssCryptMsgOpenToEncode = NULL;

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_OPEN_TO_DECODE)(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );
static PFN_CRYPT_MSG_OPEN_TO_DECODE pfnOssCryptMsgOpenToDecode = NULL;

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_DUPLICATE)(
    IN HCRYPTMSG hCryptMsg
    );
static PFN_CRYPT_MSG_DUPLICATE pfnOssCryptMsgDuplicate = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_CLOSE)(
    IN HCRYPTMSG hCryptMsg
    );
static PFN_CRYPT_MSG_CLOSE pfnOssCryptMsgClose = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_UPDATE)(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    );
static PFN_CRYPT_MSG_UPDATE pfnOssCryptMsgUpdate = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_GET_PARAM)(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );
static PFN_CRYPT_MSG_GET_PARAM pfnOssCryptMsgGetParam = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_CONTROL)(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    );
static PFN_CRYPT_MSG_CONTROL pfnOssCryptMsgControl = NULL;


#ifdef CMS_PKCS7

typedef BOOL (WINAPI *PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX)(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    );
static PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX
            pfnOssCryptMsgVerifyCountersignatureEncodedEx = NULL;

#endif  // CMS_PKCS7

typedef BOOL (WINAPI *PFN_CRYPT_MSG_COUNTERSIGN)(
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners
    );
static PFN_CRYPT_MSG_COUNTERSIGN pfnOssCryptMsgCountersign = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_COUNTERSIGN_ENCODED)(
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignature,
    IN OUT PDWORD               pcbCountersignature
    );
static PFN_CRYPT_MSG_COUNTERSIGN_ENCODED
            pfnOssCryptMsgCountersignEncoded = NULL;

#endif  // DEBUG_CRYPT_ASN1_MASTER


int
WINAPI
ICMTest_GetDebugCryptAsn1Flags()
{
    if (!fGotDebugCryptAsn1Flags) {
        char    *pszEnvVar;
        char    *p;
        int     iFlags;

        if (pszEnvVar = getenv("DEBUG_CRYPT_ASN1_FLAGS")) {
            iFlags = strtol(pszEnvVar, &p, 16);
#ifdef DEBUG_CRYPT_ASN1_MASTER
            if (iFlags) {
                if (NULL == (hOssCryptDll = LoadLibraryA("osscrypt.dll"))) {
                    iFlags = 0;
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "LoadLibrary(osscrypt.dll) failed",
                        "CheckCryptMessageAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
                } else if (NULL == (pfnOssCryptMsgOpenToEncode = 
                            (PFN_CRYPT_MSG_OPEN_TO_ENCODE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgOpenToEncode")) ||
                        NULL == (pfnOssCryptMsgOpenToDecode = 
                            (PFN_CRYPT_MSG_OPEN_TO_DECODE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgOpenToDecode")) ||
                        NULL == (pfnOssCryptMsgDuplicate = 
                            (PFN_CRYPT_MSG_DUPLICATE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgDuplicate")) ||
                        NULL == (pfnOssCryptMsgClose = 
                            (PFN_CRYPT_MSG_CLOSE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgClose")) ||
                        NULL == (pfnOssCryptMsgUpdate = 
                            (PFN_CRYPT_MSG_UPDATE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgUpdate")) ||
                        NULL == (pfnOssCryptMsgControl = 
                            (PFN_CRYPT_MSG_CONTROL) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgControl")) ||
                        NULL == (pfnOssCryptMsgGetParam = 
                            (PFN_CRYPT_MSG_GET_PARAM) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgGetParam")) ||
#ifdef CMS_PKCS7
                        NULL == (pfnOssCryptMsgVerifyCountersignatureEncodedEx = 
                            (PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgVerifyCountersignatureEncodedEx"))
                                        ||
#endif  // CMS_PKCS7
                        NULL == (pfnOssCryptMsgCountersign = 
                            (PFN_CRYPT_MSG_COUNTERSIGN) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgCountersign")) ||
                        NULL == (pfnOssCryptMsgCountersignEncoded = 
                            (PFN_CRYPT_MSG_COUNTERSIGN_ENCODED) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgCountersignEncoded"))) {
                    iFlags = 0;
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "GetProcAddress(osscrypt.dll) failed",
                        "CheckCryptMessageAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
                }
            }
#endif  // DEBUG_CRYPT_ASN1_MASTER
        } else
            iFlags = 0;

        if (iFlags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG)
            iFlags &= ~DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG;

        iDebugCryptAsn1Flags = iFlags;
        fGotDebugCryptAsn1Flags = TRUE;
    }
    return iDebugCryptAsn1Flags;
}

HCRYPTKEY
ICMTest_GetSameEncryptKey()
{
    DWORD dwError = 0;
    HCRYPTPROV hCryptProv;                // doesn't need to be freed
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    BYTE rgbBaseData[] = {1,2,3,4,5,6,7,8};

    hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
        0,          // aiPubKey
        CALG_RC2,
        0           // dwBitLen
        );

    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;

    if (!CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))
        goto CreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, sizeof(rgbBaseData), 0))
        goto HashDataError;
    if (!CryptDeriveKey(hCryptProv, CALG_RC2, hHash, 0, &hDeriveKey))
        goto DeriveKeyError;

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return hDeriveKey;
ErrorReturn:
    dwError = GetLastError();
    if (hDeriveKey) {
        CryptDestroyKey(hDeriveKey);
        hDeriveKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(DeriveKeyError)
}

#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_DefaultGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultGenContentEncryptKey(
            pContentEncryptInfo,
            dwFlags,
            pvReserved
            );

    pContentEncryptInfo->hContentEncryptKey = ICMTest_GetSameEncryptKey();
    if (pContentEncryptInfo->hContentEncryptKey)
        return TRUE;
    else
        return FALSE;
}

BOOL
WINAPI
ICM_DefaultExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();
    PCRYPT_DATA_BLOB pEncryptedKey;
    BYTE rgbEncryptedKey[] = {1,1,2,2,3,3,4,4,5,5};

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            dwFlags,
            pvReserved
            );

    pEncryptedKey = &pKeyTransEncryptInfo->EncryptedKey;
    if (NULL == (pEncryptedKey->pbData = (PBYTE) ICM_Alloc(
            sizeof(rgbEncryptedKey))))
        return FALSE;
    pEncryptedKey->cbData = sizeof(rgbEncryptedKey);
    memcpy(pEncryptedKey->pbData, rgbEncryptedKey, sizeof(rgbEncryptedKey));
    return TRUE;
}

BOOL
WINAPI
ICM_DefaultImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultImportKeyTrans(
            pContentEncryptionAlgorithm,
            pKeyTransDecryptPara,
            dwFlags,
            pvReserved,
            phContentEncryptKey
            );
    *phContentEncryptKey = ICMTest_GetSameEncryptKey();
    if (*phContentEncryptKey)
        return TRUE;
    else
        return FALSE;
}

#endif  // CMS_PKCS7


#ifdef DEBUG_CRYPT_ASN1_MASTER

void
ICMTest_MessageBox(
    IN LPSTR pszText
    )
{
    int id;
    LPSTR pszAlloc = NULL;
    DWORD cchAlloc;

    static LPCSTR pszSelect =
        " Select Cancel to stop future OssCryptAsn1 Cryptographic Messages.";

    cchAlloc = strlen(pszText) + strlen(pszSelect) + 1;

    if (pszAlloc = (LPSTR) ICM_Alloc(cchAlloc)) {
        strcpy(pszAlloc, pszText);
        strcat(pszAlloc, pszSelect);
        pszText = pszAlloc;
    }

    id = MessageBoxA(
        NULL,           // hwndOwner
        pszText,
        "CheckCryptMessageAsn1",
        MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
            MB_SERVICE_NOTIFICATION
        );
    if (IDCANCEL == id)
        iDebugCryptAsn1Flags = 0;

    ICM_Free(pszAlloc);
}

void
ICMTest_MessageBoxLastError(
    IN LPSTR pszText,
    IN DWORD dwOssErr,
    IN DWORD dwNewErr
    )
{
    char szText[512];

    if (dwNewErr == (DWORD) PkiAsn1ErrToHr(ASN1_ERR_BADTAG) &&
            (OSS_DATA_ERROR == dwOssErr || OSS_PDU_MISMATCH == dwOssErr))
        return;
    if (dwNewErr == (DWORD) PkiAsn1ErrToHr(ASN1_ERR_EOD) &&
            OSS_MORE_INPUT == dwOssErr)
        return;

    wsprintfA(szText,
        "%s:: failed with different LastError Oss: %d 0x%x New: %d 0x%x.",
        pszText, dwOssErr, dwOssErr, dwNewErr, dwNewErr
        );
    ICMTest_MessageBox(szText);
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
ICMTest_WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
    } else {
        DWORD dwBytesWritten;
        fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                );
        CloseHandle(hFile);
    }
    return fResult;
}


#define TEST_MAGIC -12348765

// Note, in the following data structure lMagic is at the same offest as
// lRefCnt in CRYPT_MSG_INFO. lRefCnt should never be negative.
typedef struct _OSS_CRYPT_ASN1_MSG_INFO {
    // The following must be ordered the same as CRYPT_MSG_INFO through
    // dwEncodingType. msghlpr.cpp does a (PCRYPT_MSG_INFO) cast to
    // access dwEncodingType.
    CRITICAL_SECTION        CriticalSection;
    LONG                    lMagic;             // lRefCnt in CRYPT_MSG_INFO
    HCRYPTPROV              hCryptProv;         // decode
    BOOL                    fDefaultCryptProv;  // decode
    DWORD                   dwKeySpec;          // key to use in CryptSignHash
    DWORD                   dwEncodingType;     // encode

    LONG                    lRefCnt;
    union {
        HCRYPTMSG               hNewCryptMsg;
        PCRYPT_MSG_INFO         pNewcmi;
    };
    union {
        HCRYPTMSG               hOssCryptMsg;
        PCRYPT_MSG_INFO         pOsscmi;
    };
    PFN_CMSG_STREAM_OUTPUT  pfnStreamOutput;
    void                    *pvArg;
    BYTE                    *pbOssOutput;
    DWORD                   cbOssOutput;
    BOOL                    fOssFinal;
    BYTE                    *pbNewOutput;
    DWORD                   cbNewOutput;
    BOOL                    fNewFinal;
    BOOL                    fDidCompare;
} OSS_CRYPT_ASN1_MSG_INFO, *POSS_CRYPT_ASN1_MSG_INFO;

BOOL
WINAPI
ICMTest_OssStreamOutput(
    IN const void *pvArg,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) pvArg;
    assert(TEST_MAGIC == pInfo->lMagic);

    assert(!pInfo->fOssFinal);
    pInfo->fOssFinal = fFinal;

    if (cbData) {
        BYTE *pbOssOutput;

        if (pbOssOutput = (BYTE *) ICM_ReAlloc(pInfo->pbOssOutput,
                pInfo->cbOssOutput + cbData)) {
            memcpy(pbOssOutput + pInfo->cbOssOutput, pbData, cbData);
            pInfo->pbOssOutput = pbOssOutput;
            pInfo->cbOssOutput += cbData;
        }
    }
    return TRUE;
}

BOOL
WINAPI
ICMTest_NewStreamOutput(
    IN const void *pvArg,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) pvArg;
    assert(TEST_MAGIC == pInfo->lMagic);

    assert(!pInfo->fNewFinal);
    pInfo->fNewFinal = fFinal;

    if (cbData) {
        BYTE *pbNewOutput;

        if (pbNewOutput = (BYTE *) ICM_ReAlloc(pInfo->pbNewOutput,
                pInfo->cbNewOutput + cbData)) {
            memcpy(pbNewOutput + pInfo->cbNewOutput, pbData, cbData);
            pInfo->pbNewOutput = pbNewOutput;
            pInfo->cbNewOutput += cbData;
        }
    }

    return pInfo->pfnStreamOutput(
        pInfo->pvArg,
        pbData,
        cbData,
        fFinal
        );
}

void
ICMTest_CompareMessageBox(
    IN LPSTR pszText,
    IN BYTE *pbOss,
    IN DWORD cbOss,
    IN BYTE *pbNew,
    IN DWORD cbNew
    )
{
    if (NULL == pbOss || NULL == pbNew)
        return;

    if (cbOss != cbNew || 0 != memcmp(pbOss, pbNew, cbNew)) {
        ICMTest_WriteDERToFile("ossasn1.der", pbOss, cbOss);
        ICMTest_WriteDERToFile("newasn1.der", pbNew, cbNew);
        
        ICMTest_MessageBox(pszText);
    }
}

void
ICMTest_CompareStreamOutput(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo,
    IN BOOL fForceCompare = FALSE
    )
{
    BOOL fDoCompare;

    if (NULL == pInfo->pfnStreamOutput || pInfo->fDidCompare)
        return;

    fDoCompare = fForceCompare;
    if (pInfo->fOssFinal || pInfo->fNewFinal)
        fDoCompare = TRUE;

    if (fDoCompare) {
        if (pInfo->fOssFinal != pInfo->fNewFinal) {
            if (pInfo->fOssFinal)
                ICMTest_MessageBox("No fFinal on NewStreamOutput.");
            else
                ICMTest_MessageBox("No fFinal on OssStreamOutput.");
        }

        ICMTest_CompareMessageBox(
            "StreamOutput compare failed. Check ossasn1.der and newasn1.der.",
            pInfo->pbOssOutput,
            pInfo->cbOssOutput,
            pInfo->pbNewOutput,
            pInfo->cbNewOutput
            );

        pInfo->fDidCompare = TRUE;
    }
}

void
ICMTest_CompareGetParam(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    IN void *pvOssData,
    IN DWORD cbOssData,
    IN void *pvNewData,
    IN DWORD cbNewData
    )
{
    char szText[512];

    switch (dwParamType) {
        case CMSG_TYPE_PARAM:
        case CMSG_CONTENT_PARAM:
        case CMSG_BARE_CONTENT_PARAM:
        case CMSG_INNER_CONTENT_TYPE_PARAM:
        case CMSG_SIGNER_COUNT_PARAM:
        case CMSG_CERT_COUNT_PARAM:
        case CMSG_CERT_PARAM:
        case CMSG_CRL_COUNT_PARAM:
        case CMSG_CRL_PARAM:
        case CMSG_RECIPIENT_COUNT_PARAM:
        case CMSG_HASH_DATA_PARAM:
        case CMSG_COMPUTED_HASH_PARAM:
        case CMSG_ENCRYPTED_DIGEST:
        case CMSG_ENCODED_SIGNER:
        case CMSG_ENCODED_MESSAGE:
#ifdef CMS_PKCS7
        case CMSG_VERSION_PARAM:
        case CMSG_ATTR_CERT_COUNT_PARAM:
        case CMSG_ATTR_CERT_PARAM:
        case CMSG_CMS_RECIPIENT_COUNT_PARAM:
#endif  // CMS_PKCS7
            break;
        default:
            return;
    }

    if (NULL == pvOssData || NULL == pvNewData)
        return;


    wsprintfA(szText,
        "ParamType: %d compare failed. Check ossasn1.der and newasn1.der.",
        dwParamType
        );

    ICMTest_CompareMessageBox(
        szText,
        (BYTE *) pvOssData,
        cbOssData,
        (BYTE *) pvNewData,
        cbNewData
        );
}

inline
void
ICMTest_Lock(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo
    )
{
    EnterCriticalSection( &pInfo->CriticalSection);
}

inline
void
ICMTest_Unlock(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo
    )
{
    LeaveCriticalSection( &pInfo->CriticalSection);
}

HCRYPTMSG
WINAPI
CryptMsgOpenToEncode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        POSS_CRYPT_ASN1_MSG_INFO pInfo;
        CMSG_STREAM_INFO StreamInfo;
        DWORD dwOssErr;
        DWORD dwNewErr;

        if (NULL == (pInfo = (POSS_CRYPT_ASN1_MSG_INFO) ICM_AllocZero(
                sizeof(OSS_CRYPT_ASN1_MSG_INFO))))
            return NULL;
        pInfo->lMagic = TEST_MAGIC;

        if (pStreamInfo) {
            pInfo->pfnStreamOutput = pStreamInfo->pfnStreamOutput;
            pInfo->pvArg = pStreamInfo->pvArg;
            StreamInfo.cbContent = pStreamInfo->cbContent;
            // StreamInfo.pfnStreamOutput =
            StreamInfo.pvArg = pInfo;
            pStreamInfo = &StreamInfo;
        }

        StreamInfo.pfnStreamOutput = ICMTest_NewStreamOutput;
        pInfo->hNewCryptMsg = ICMTest_NewCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
        dwNewErr = GetLastError();

        StreamInfo.pfnStreamOutput = ICMTest_OssStreamOutput;
        pInfo->hOssCryptMsg = pfnOssCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
        dwOssErr = GetLastError();

        if (pInfo->hNewCryptMsg) {
            if (pInfo->hOssCryptMsg) {
                pInfo->dwEncodingType = pInfo->pNewcmi->dwEncodingType;
                InitializeCriticalSection(&pInfo->CriticalSection);
                pInfo->lRefCnt = 1;
                return (HCRYPTMSG) pInfo;
            } else {
                HCRYPTMSG hRet;
                ICMTest_MessageBox("OssCryptMsgOpenToEncode failed.");
                hRet = pInfo->hNewCryptMsg;
                ICM_Free(pInfo);
                return hRet;
            }
        } else {
            if (pInfo->hOssCryptMsg) {
                ICMTest_MessageBox("OssCryptMsgOpenToEncode succeeded while NewCryptMsgOpenToEncoded failed.");
                pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
            } else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgOpenToEncode",
                    dwOssErr, dwNewErr);

            ICM_Free(pInfo);
            SetLastError(dwNewErr);
            return NULL;
        }
    } else if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
    else
        return ICMTest_NewCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
}

HCRYPTMSG
WINAPI
CryptMsgOpenToDecode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        POSS_CRYPT_ASN1_MSG_INFO pInfo;
        CMSG_STREAM_INFO StreamInfo;
        DWORD dwOssErr;
        DWORD dwNewErr;

        if (NULL == (pInfo = (POSS_CRYPT_ASN1_MSG_INFO) ICM_AllocZero(
                sizeof(OSS_CRYPT_ASN1_MSG_INFO))))
            return NULL;
        pInfo->lMagic = TEST_MAGIC;

        if (pStreamInfo) {
            pInfo->pfnStreamOutput = pStreamInfo->pfnStreamOutput;
            pInfo->pvArg = pStreamInfo->pvArg;
            StreamInfo.cbContent = pStreamInfo->cbContent;
            // StreamInfo.pfnStreamOutput =
            StreamInfo.pvArg = pInfo;
            pStreamInfo = &StreamInfo;
        }

        StreamInfo.pfnStreamOutput = ICMTest_NewStreamOutput;
        pInfo->hNewCryptMsg = ICMTest_NewCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
        dwNewErr = GetLastError();

        StreamInfo.pfnStreamOutput = ICMTest_OssStreamOutput;
        pInfo->hOssCryptMsg = pfnOssCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
        dwOssErr = GetLastError();

        if (pInfo->hNewCryptMsg) {
            if (pInfo->hOssCryptMsg) {
                pInfo->dwEncodingType = pInfo->pNewcmi->dwEncodingType;
                InitializeCriticalSection(&pInfo->CriticalSection);
                pInfo->lRefCnt = 1;
                return (HCRYPTMSG) pInfo;
            } else {
                HCRYPTMSG hRet;
                ICMTest_MessageBox("OssCryptMsgOpenToDecode failed.");
                hRet = pInfo->hNewCryptMsg;
                ICM_Free(pInfo);
                return hRet;
            }
        } else {
            if (pInfo->hOssCryptMsg) {
                ICMTest_MessageBox("OssCryptMsgOpenToDecode succeeded while NewCryptMsgOpenToDecode failed.");
                pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
            } else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgOpenToDecode",
                    dwOssErr, dwNewErr);

            ICM_Free(pInfo);
            SetLastError(dwNewErr);
            return NULL;
        }
    } else if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
    else
        return ICMTest_NewCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
}

HCRYPTMSG
WINAPI
CryptMsgDuplicate(
    IN HCRYPTMSG hCryptMsg
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;
    if (pInfo && TEST_MAGIC == pInfo->lMagic) {
        InterlockedIncrement(&pInfo->lRefCnt);
        return hCryptMsg;
    } else if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgDuplicate(hCryptMsg);
    else
        return ICMTest_NewCryptMsgDuplicate(hCryptMsg);
}

BOOL
WINAPI
CryptMsgClose(
    IN HCRYPTMSG hCryptMsg
    )
{
    BOOL fRet;
    DWORD dwError;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo)
        return TRUE;
    if (TEST_MAGIC != pInfo->lMagic) {
        if (iDebugCryptAsn1Flags &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgClose(hCryptMsg);
        else
            return ICMTest_NewCryptMsgClose(hCryptMsg);
    }
    if (0 != InterlockedDecrement(&pInfo->lRefCnt))
        return TRUE;

    // Preserve LastError
    dwError = GetLastError();

    assert(pInfo->hOssCryptMsg);
    assert(1 == ((PCRYPT_MSG_INFO) pInfo->hOssCryptMsg)->lRefCnt);
    assert(pInfo->hNewCryptMsg);
    assert(1 == ((PCRYPT_MSG_INFO) pInfo->hNewCryptMsg)->lRefCnt);

    ICMTest_CompareStreamOutput(pInfo, TRUE);

    pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
    fRet = ICMTest_NewCryptMsgClose(pInfo->hNewCryptMsg);

    ICM_Free(pInfo->pbOssOutput);
    ICM_Free(pInfo->pbNewOutput);
    DeleteCriticalSection(&pInfo->CriticalSection);
    ICM_Free(pInfo);

    SetLastError(dwError);              // Preserve LastError
    return fRet;
}


BOOL
WINAPI
CryptMsgUpdate(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgUpdate(
                hCryptMsg,
                pbData,
                cbData,
                fFinal
                );
        else
            return ICMTest_NewCryptMsgUpdate(
                hCryptMsg,
                pbData,
                cbData,
                fFinal
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgUpdate(
        pInfo->hOssCryptMsg,
        pbData,
        cbData,
        fFinal
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgUpdate(
        pInfo->hNewCryptMsg,
        pbData,
        cbData,
        fFinal
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareStreamOutput(pInfo);
        else
            ICMTest_MessageBox("OssCryptMsgUpdate failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgUpdate succeeded while NewCryptMsgUpdate failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgUpdate",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}
    

BOOL
WINAPI
CryptMsgGetParam(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fOss;
    DWORD dwOssErr;
    void *pvOssData = NULL;
    DWORD cbOssData;
    BOOL fNew;
    DWORD dwNewErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgGetParam(
                hCryptMsg,
                dwParamType,
                dwIndex,
                pvData,
                pcbData
                );
        else
            return ICMTest_NewCryptMsgGetParam(
                hCryptMsg,
                dwParamType,
                dwIndex,
                pvData,
                pcbData
                );
    }

    ICMTest_Lock(pInfo);

    cbOssData = *pcbData;
    if (pvData)
        pvOssData = ICM_Alloc(cbOssData);

    fOss = pfnOssCryptMsgGetParam(
        pInfo->hOssCryptMsg,
        dwParamType,
        dwIndex,
        pvOssData,
        &cbOssData
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgGetParam(
        pInfo->hNewCryptMsg,
        dwParamType,
        dwIndex,
        pvData,
        pcbData
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareGetParam(
                pInfo,
                dwParamType,
                dwIndex,
                pvOssData,
                cbOssData,
                pvData,
                *pcbData
                );
        else
            ICMTest_MessageBox("OssCryptMsgGetParam failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgGetParam succeeded while NewCryptMsgGetParam failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgGetParam",
                dwOssErr, dwNewErr);
    }

    ICMTest_Unlock(pInfo);
    ICM_Free(pvOssData);
    SetLastError(dwNewErr);
    return fNew;
}


BOOL
WINAPI
CryptMsgControl(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgControl(
                hCryptMsg,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                );
        else
            return ICMTest_NewCryptMsgControl(
                hCryptMsg,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgControl(
        pInfo->hOssCryptMsg,
        dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
        dwCtrlType,
        pvCtrlPara
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgControl(
        pInfo->hNewCryptMsg,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareStreamOutput(pInfo);
        else
            ICMTest_MessageBox("OssCryptMsgControl failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgControl succeeded while NewCryptMsgControl failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgControl",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}



#ifdef CMS_PKCS7
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncodedEx(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fOss;
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags &
            (DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG |
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)))
        return ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );

    fOss = pfnOssCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        DWORD dwOssErr = GetLastError();
        BOOL fNew;
        DWORD dwNewErr;

        fNew = ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );
        dwNewErr = GetLastError();

        if (fNew) {
            if (!fOss)
                ICMTest_MessageBox("OssCryptMsgVerifyCountersignatureEncodedEx failed.");
        } else {
            if (fOss)
                ICMTest_MessageBox("OssCryptMsgVerifyCountersignatureEncodedEx succeeded while NewCryptMsgVerifyCountersignatureEncodedEx failed.");
            else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgVerifyCountersignatureEncodedEx",
                    dwOssErr, dwNewErr);

        }

        SetLastError(dwOssErr);
    }

    return fOss;

}
#endif  // CMS_PKCS7

BOOL
WINAPI
CryptMsgCountersign(
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgCountersign(
                hCryptMsg,
                dwIndex,
                cCountersigners,
                rgCountersigners
                );
        else
            return ICMTest_NewCryptMsgCountersign(
                hCryptMsg,
                dwIndex,
                cCountersigners,
                rgCountersigners
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgCountersign(
        pInfo->hOssCryptMsg,
        dwIndex,
        cCountersigners,
        rgCountersigners
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgCountersign(
        pInfo->hNewCryptMsg,
        dwIndex,
        cCountersigners,
        rgCountersigners
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (!fOss)
            ICMTest_MessageBox("OssCryptMsgCountersign failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgCountersign succeeded while NewCryptMsgCountersign failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgCountersign",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}

BOOL
WINAPI
CryptMsgCountersignEncoded(
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignature,
    IN OUT PDWORD               pcbCountersignature
    )
{
    BOOL fOss;
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();
    BYTE *pbNew = NULL;
    DWORD cbNew;

    if (0 == (iOssAsn1Flags &
            (DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG |
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)))
        return ICMTest_NewCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignature,
            pcbCountersignature
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        cbNew = *pcbCountersignature;
        if (pbCountersignature)
            pbNew = (BYTE *) ICM_Alloc(cbNew);
    }

    fOss = pfnOssCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignature,
            pcbCountersignature
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        DWORD dwOssErr = GetLastError();
        BOOL fNew;
        DWORD dwNewErr;

        fNew = ICMTest_NewCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbNew,
            &cbNew
            );
        dwNewErr = GetLastError();


        if (fNew) {
            if (fOss)
                ICMTest_CompareMessageBox(
                    "CountersignEncoded compare failed. Check ossasn1.der and newasn1.der.",
                    pbCountersignature,
                    *pcbCountersignature,
                    pbNew,
                    cbNew
                    );
            else
                ICMTest_MessageBox("NewCryptMsgCountersignEncoded failed.");
        } else {
            if (fOss)
                ICMTest_MessageBox("OssCryptMsgCountersignEncoded succeeded while NewCryptMsgCountersignEncoded failed.");
            else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgCountersignEncoded",
                    dwOssErr, dwNewErr);

        }

        SetLastError(dwOssErr);
    }

    ICM_Free(pbNew);
    return fOss;
}


#endif  // DEBUG_CRYPT_ASN1_MASTER

#endif  // DEBUG_CRYPT_ASN1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\fileguid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       fileguid.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "sgnerror.h"

//+-----------------------------------------------------------------------
//  SignGetFileType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------



HRESULT SignGetFileType(HANDLE hFile,
                        const WCHAR *pwszFile,
                       GUID* pGuid)
// Answer as to the type as which we should sign this file
{
    if (!(pGuid) || !(hFile) || (hFile == INVALID_HANDLE_VALUE))
    {
        return(E_INVALIDARG);
    }

    if (!(CryptSIPRetrieveSubjectGuid(pwszFile, hFile, pGuid)))
    {
        return(GetLastError());
    }

    return(S_OK);

#   ifdef PCB_OLD
        // Java class files have a magic number at their start. They always begin
        //      0xCA 0xFE 0xBA 0xBE
        // CAB files begin 'M' 'S' 'C' 'F'
        //
        
        if(!pGuid || hFile == NULL || hFile == INVALID_HANDLE_VALUE) 
            return E_INVALIDARG;
        
        ZeroMemory(pGuid, sizeof(GUID));
        PKITRY { 
            static  BYTE rgbMagicJava[] = { 0xCA, 0xFE, 0xBA, 0xBE };
            static  BYTE rgbMagicCab [] = { 'M', 'S', 'C', 'F' };
            BYTE rgbRead[4];
            DWORD dwRead;
            
            if (ReadFile(hFile, rgbRead, 4, &dwRead, NULL) &&
                dwRead == 4) {
                if (memcmp(rgbRead, rgbMagicJava, 4)==0) 
                    *pGuid = JavaImage;
                else if (memcmp(rgbRead, rgbMagicCab, 4)==0)
                    *pGuid = CabImage;
                else 
                    *pGuid = PeImage;
            }
        
        
            // Rewind the file
            if(SetFilePointer(hFile, 0, 0, FILE_BEGIN) == 0xffffffff)
                PKITHROW(SignError());
        
        }
        PKICATCH(err) {
            hr = err.pkiError;
        } PKIEND;
        
        return hr;
#   endif // PCB_OLD
}

//Xiaohs: the following function is no longer necessary after auth2upd
/*HRESULT SignLoadSipFlags(GUID* pSubjectGuid,
                        DWORD *dwFlags)
{
    HRESULT hr = S_OK;
    GUID sSip;
    if(!dwFlags)
        return E_INVALIDARG;

    if (dwFlags)
    {
        *dwFlags = 0;
        sSip = PeImage;
        if(memcmp(&sSip, pSubjectGuid, sizeof(GUID)) == 0) 
        {
            *dwFlags = SPC_INC_PE_RESOURCES_FLAG | SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG;
            return hr;
        }
    }
    return hr;
} */


//+-----------------------------------------------------------------------
//  FileToSubjectType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    TRUST_E_SUBJECT_FORM_UNKNOWN
//       Unknow file type
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SignOpenFile(LPCWSTR  pwszFilename, 
                    HANDLE*  pFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hFile = NULL;
    BY_HANDLE_FILE_INFORMATION hFileInfo;
    
    if(!pwszFilename || !pFileHandle)
        return E_INVALIDARG;
    
    PKITRY {
        hFile = CreateFileU(pwszFilename,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,                   // lpsa
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);                 // hTemplateFile

        if(INVALID_HANDLE_VALUE == hFile) 
            PKITHROW(SignError());
    
        if(!GetFileInformationByHandle(hFile,
                                       &hFileInfo))
            PKITHROW(SignError());
        
        // Test to see if we have a directory or offline
		if(	(hFileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)	||
			(hFileInfo.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) )
		{
            PKITHROW(TRUST_E_SUBJECT_FORM_UNKNOWN);
        }
    }
    PKICATCH(err) {
        hr = err.pkiError;
        CloseHandle(hFile);
        hFile = NULL;
    } PKIEND;

    *pFileHandle = hFile;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\pvkdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkdlg.cpp
//
//  Contents:   Private Key Dialog Box APIs.
//
//  Functions:  PvkDlgGetKeyPassword
//
//  History:    12-May-96   philh created
//
//--------------------------------------------------------------------------


#include "global.hxx"
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "pvk.h"

// ENTER_PASSWORD:
//  IDC_PASSWORD0 - Password

// CREATE_PASSWORD:
//  IDC_PASSWORD0 - Password
//  IDC_PASSWORD1 - Confirm Password


typedef struct _KEY_PASSWORD_PARAM {
    PASSWORD_TYPE   PasswordType;
    LPWSTR          pwszKey;           // IDC_KEY
    LPSTR           *ppszPassword;
} KEY_PASSWORD_PARAM, *PKEY_PASSWORD_PARAM;


// Where to get the dialog resources from

// Forward reference to local functions
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            );

static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            );

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            )
{
    int nResult;
    LPSTR pszPassword = NULL;
    KEY_PASSWORD_PARAM KeyPasswordParam = {
        PasswordType,
        (LPWSTR) pwszKeyName,
        &pszPassword
    };

    LPCSTR pszTemplate = PasswordType == ENTER_PASSWORD ?
        MAKEINTRESOURCE(IDD_ENTERKEYPASSWORD) :
        MAKEINTRESOURCE(IDD_CREATEKEYPASSWORD);

    nResult = (BOOL)DialogBoxParam(
        GetInstanceHandle(),
        pszTemplate,
        hwndOwner,
        KeyPasswordDlgProc,
        (LPARAM) &KeyPasswordParam
        );

    *ppbPassword = (BYTE *) pszPassword;
    if (pszPassword)
        *pcbPassword = strlen(pszPassword);
    else
        *pcbPassword = 0;

    return nResult;
}

//+-------------------------------------------------------------------------
//  Allocate and get the password(s) from the dialog box
//
//  For no password input, returns NULL
//  pointer for the password. Otherwise, the password is PvkAlloc'ed.
//--------------------------------------------------------------------------
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            )
{
    LPSTR rgpszPassword[2] = {NULL, NULL};
	WCHAR	wszNoPassword[128];
	WCHAR	wszPasswordNoMatch[128];

    *ppszPassword = NULL;

    // Get the entered password(s)
    assert(PasswordType < 2);
    int i;
    for (i = 0; i <= PasswordType; i++) {
        LONG cchPassword;
        cchPassword = (LONG)SendDlgItemMessage(
            hwndDlg,
            IDC_PASSWORD0 + i,
            EM_LINELENGTH,
            (WPARAM) 0,
            (LPARAM) 0
            );
        if (cchPassword > 0) {
            rgpszPassword[i] = (LPSTR) PvkAlloc(cchPassword + 1);
            assert(rgpszPassword[i]);
            if (rgpszPassword[i])
                GetDlgItemText(
                    hwndDlg,
                    IDC_PASSWORD0 + i,
                    rgpszPassword[i],
                    cchPassword + 1
                    );
        }
    }

    if (PasswordType == ENTER_PASSWORD) {
        *ppszPassword = rgpszPassword[0];
        return IDOK;
    }

    int nResult = IDOK;
#define MSG_BOX_TITLE_LEN 128
    WCHAR wszMsgBoxTitle[MSG_BOX_TITLE_LEN];
    GetWindowTextU(hwndDlg, wszMsgBoxTitle, MSG_BOX_TITLE_LEN);

    if (rgpszPassword[0] == NULL && rgpszPassword[1] == NULL) {

		if(0 == LoadStringU(hInstance, IDS_NO_PASSWORD, wszNoPassword, 128))
			wcscpy(wszNoPassword, L"Without password protection ?");

        // Didn't enter a password
        nResult = MessageBoxU(
            hwndDlg,
            wszNoPassword,
            wszMsgBoxTitle,
            MB_YESNOCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2
            );
        if (nResult == IDYES)
            nResult = IDOK;
        else if (nResult == IDNO)
            nResult = IDRETRY;
    } else if (rgpszPassword[0] == NULL || rgpszPassword[1] == NULL ||
               strcmp(rgpszPassword[0], rgpszPassword[1]) != 0) {

		if(0 == LoadStringU(hInstance, IDS_PASSWORD_NO_MATCH, wszPasswordNoMatch, 128))
			wcscpy(wszPasswordNoMatch, L"Confirm password doesn't match");

        // Confirmed password didn't match
        nResult = MessageBoxU(
            hwndDlg,
            wszPasswordNoMatch,
            wszMsgBoxTitle,
            MB_RETRYCANCEL | MB_ICONEXCLAMATION
            );
        if (nResult == IDRETRY) {
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 0, "");
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 1, "");
        }
    }

    if (nResult == IDOK)
        *ppszPassword = rgpszPassword[0];
    else if (rgpszPassword[0])
        PvkFree(rgpszPassword[0]);
    if (rgpszPassword[1])
        PvkFree(rgpszPassword[1]);

    if (nResult == IDRETRY)
        SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD0));
    return nResult;
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password DialogProc
//--------------------------------------------------------------------------
static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            )
{
    switch (uMsg) {
        case WM_INITDIALOG:
        {
            PKEY_PASSWORD_PARAM pKeyPasswordParam =
                (PKEY_PASSWORD_PARAM) lParam;

            char sz[128];
            WideCharToMultiByte(CP_ACP, 0, pKeyPasswordParam->pwszKey, -1,
                (LPSTR) sz, 128, NULL, NULL);

            SetDlgItemText(hwndDlg, IDC_KEY, sz);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pKeyPasswordParam);
            return TRUE;
        }
        case WM_COMMAND:
            int nResult = LOWORD(wParam);
            switch (nResult) {
                case IDOK:
                {
                    PKEY_PASSWORD_PARAM pKeyPasswordParam =
                        (PKEY_PASSWORD_PARAM) GetWindowLongPtr(hwndDlg, DWLP_USER);

                    nResult = GetPassword(
                        hwndDlg,
                        pKeyPasswordParam->PasswordType,
                        pKeyPasswordParam->ppszPassword
                        );
                    if (nResult != IDRETRY)
                        EndDialog(hwndDlg, nResult);
                    return TRUE;
                }
                    break;
                case IDC_NONE:
                    nResult = IDOK;     // *ppszPassword == NULL
                    // Fall through
                case IDCANCEL:
                    EndDialog(hwndDlg, nResult);
                    return TRUE;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\mssign32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signer.cpp
//
//  Contents:   Microsoft Internet Security Signing API
//
//  History:    June-25-97 xiaohs   created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <stdio.h>



//--------------------------------------------------------------------------
//
//   InternalSign:
//       The signing routine called by signer.dll internally.  This is the 
//       function that actually does the job.
//
//--------------------------------------------------------------------------
HRESULT WINAPI 
InternalSign(IN  DWORD dwEncodingType,          // Encoding type
             IN  HCRYPTPROV hCryptProv,         // CAPI provider, opened for signing private key
             IN  DWORD dwKeySpec,               // Type of signing key, AT_SIGNATURE or AT_EXCHANGE
             IN  LPCSTR pszAlgorithmOid,        // Algorithm id used to create digest
             IN  LPSIP_SUBJECTINFO pSipInfo,    // SIP information
             IN  DWORD  *pdwIndex,              // signer index
             IN  PCCERT_CONTEXT psSigningContext, // Cert context to the signing certificate
             IN  HCERTSTORE hSpcStore,          // The credentials to use in the signing
             IN  LPCWSTR pwszOpusName,          // Optional, the name of the program to appear in
             IN  LPCWSTR pwszOpusInfo,          // Optional, the unparsed name of a link to more
             IN  BOOL fIncludeCerts,            // add the certificates to the signature
             IN  BOOL fCommercial,              // commerical signing
             IN  BOOL fIndividual,              // individual signing
             IN  BOOL fAuthcode,                // whether use fCommercial as an attributes
             IN  PCRYPT_ATTRIBUTES  psAuthenticated,   // Optional, authenticated attributes added to signature
             IN  PCRYPT_ATTRIBUTES  psUnauthenticated, // Optional, unauthenticated attributes added to signature
             OUT PBYTE* ppbDigest,              //Optional: return the Digest of the file
             OUT DWORD* pcbDigest,              //Optional: return the size of the digest
             OUT PBYTE* ppbMessage,             //Optional: return the encoded signed message
             OUT DWORD* pcbMessage)             //Optional: return the size of encoded signed message
{

    HRESULT    hr = S_OK;

    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions

    PBYTE      pbOpusAttribute = NULL; // Encoding for the opus attribute
    DWORD      cbOpusAttribute = 0;    //    :

    PBYTE      pbStatementAttribute = NULL; // Encoding for the statement attribute
    DWORD      cbStatementAttribute = 0;    //    :

    PCRYPT_ATTRIBUTE rgpAuthAttributes = NULL;
    DWORD             dwAuthAttributes = 0;

    PCRYPT_ATTRIBUTE rgpUnauthAttributes = NULL;
    DWORD             dwUnauthAttributes = 0;

    PSIP_INDIRECT_DATA psIndirectData = NULL; // Indirect data structure
    DWORD              dwIndirectData = 0; 

    PBYTE      pbIndirectBlob = NULL; // Encoding Indirect blob
    DWORD      cbIndirectBlob = 0;    //    :

    PBYTE               pbGetBlob=NULL;
    DWORD               cbGetBlob=0;
    CRYPT_DATA_BLOB     PKCS7Blob;
    HCERTSTORE          hPKCS7CertStore=NULL;
    DWORD               dwPKCS7Certs=0;
    PCERT_BLOB          rgPKCS7Certs=NULL;

    PBYTE      pbEncodedSignMsg = NULL; // Encoding for the statement attribute
    DWORD      cbEncodedSignMsg  = 0;    //    :


    HCRYPTMSG hMsg = NULL;
    CMSG_SIGNER_ENCODE_INFO sSignerInfo;
    CMSG_SIGNED_ENCODE_INFO sSignedInfo;

    PCERT_BLOB    rgpCryptMsgCertificates = NULL;
    DWORD          dwCryptMsgCertificates = 0;
    PCRL_BLOB     rgpCryptMsgCrls = NULL;
    DWORD          dwCryptMsgCrls = 0;

    PBYTE pbSignerData = NULL;
    DWORD cbSignerData = 0;  

    BOOL            fSignCommercial=FALSE;
    BOOL            fCTLFile =FALSE;

    PCTL_CONTEXT    pCTLContext=NULL;

    GUID            CTLGuid=CRYPT_SUBJTYPE_CTL_IMAGE;
    GUID            CATGuid=CRYPT_SUBJTYPE_CATALOG_IMAGE;
    DWORD           dwCertIndex=0;
    BOOL            fFound=FALSE;
    BOOL            fNeedStatementType=FALSE;

    PKITRY {

        //init memory
        ZeroMemory(&sSignerInfo, sizeof(CMSG_SIGNER_ENCODE_INFO));

        ZeroMemory(&sSignedInfo, sizeof(CMSG_SIGNED_ENCODE_INFO));


        // Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,                              // Reserved
                         &sSip))                         // Table of functions
            PKITHROW(SignError());


        // Set up the attributes (AUTHENTICODE Specific, replace with your attributes)
        // Encode the opus information up into an attribute
        if(fAuthcode)
        {
            hr = CreateOpusInfo(pwszOpusName,
                            pwszOpusInfo,
                            &pbOpusAttribute,
                            &cbOpusAttribute);
            if(hr != S_OK) PKITHROW(hr);


            //Check to see if we need to put the statement type attributes
            if(NeedStatementTypeAttr(psSigningContext, fCommercial, fIndividual))
            {
            
                fNeedStatementType=TRUE;

                // Check signing certificate to see if its signing cabablity complies
                //with the request
                if(S_OK!=(hr=CheckCommercial(psSigningContext,fCommercial, fIndividual,
                                &fSignCommercial)))
                    PKITHROW(hr);
        
                if(S_OK !=(hr = CreateStatementType(fSignCommercial,
                                        &pbStatementAttribute,
                                        &cbStatementAttribute)))
                    PKITHROW(hr);
            }
            else
                fNeedStatementType=FALSE;
        }

        // Create Authenticode attributes and append additional authenticated attributes.
        // Allocate and add StatementType and SpOpusInfo (add room for one blob per attribute, which we need)
        DWORD dwAttrSize = 0;

        //get the number of authenticated attributes
        if(fAuthcode)
        {
            if(fNeedStatementType)
                dwAuthAttributes = 2;  // StatementType + opus
            else
                dwAuthAttributes= 1;
        }
        else
            dwAuthAttributes=  0;  

        if(psAuthenticated)
            dwAuthAttributes += psAuthenticated->cAttr;
        
        dwAttrSize = sizeof(CRYPT_ATTRIBUTE) * dwAuthAttributes + 2 * sizeof(CRYPT_ATTR_BLOB);
        rgpAuthAttributes = (PCRYPT_ATTRIBUTE) malloc(dwAttrSize);
        if(!rgpAuthAttributes) PKITHROW(E_OUTOFMEMORY);

        ZeroMemory(rgpAuthAttributes, dwAttrSize);
        PCRYPT_ATTR_BLOB pValue = (PCRYPT_ATTR_BLOB) (rgpAuthAttributes + dwAuthAttributes);
    
        //the start of the authenticated attributes
        dwAttrSize=0;

        //add the authenticode specific attributes
        if(fAuthcode)
        {
    
            // Update SpOpusInfo
            rgpAuthAttributes[dwAttrSize].pszObjId = SPC_SP_OPUS_INFO_OBJID;
            rgpAuthAttributes[dwAttrSize].cValue = 1;
            rgpAuthAttributes[dwAttrSize].rgValue = &pValue[dwAttrSize];
            pValue[dwAttrSize].pbData = pbOpusAttribute;
            pValue[dwAttrSize].cbData = cbOpusAttribute;
            dwAttrSize++;

            // Update StatementType
            if(fNeedStatementType)
            {
                rgpAuthAttributes[dwAttrSize].pszObjId = SPC_STATEMENT_TYPE_OBJID;
                rgpAuthAttributes[dwAttrSize].cValue = 1;
                rgpAuthAttributes[dwAttrSize].rgValue = &pValue[dwAttrSize];
                pValue[dwAttrSize].pbData = pbStatementAttribute;
                pValue[dwAttrSize].cbData = cbStatementAttribute;
                dwAttrSize++;
            }
        }
        
        if(psAuthenticated) {
            for(DWORD i = dwAttrSize, ii = 0; ii < psAuthenticated->cAttr; ii++, i++) 
                rgpAuthAttributes[i] = psAuthenticated->rgAttr[ii];
        }

        // Get the Unauthenticated attributes
        if(psUnauthenticated) {
            rgpUnauthAttributes = psUnauthenticated->rgAttr;
            dwUnauthAttributes = psUnauthenticated->cAttr;
        }

        //check to see if the file is either a catalog file or a CTL file 
        if((CTLGuid == (*(pSipInfo->pgSubjectType))) ||
           (CATGuid == (*(pSipInfo->pgSubjectType))) 
            )
            fCTLFile=TRUE;
        else
        {
            // Get the indirect data struct from the SIP
            if(!sSip.pfCreate(pSipInfo,
                          &dwIndirectData,
                          psIndirectData))
                PKITHROW(SignError());


            psIndirectData = (PSIP_INDIRECT_DATA) malloc(dwIndirectData);
            if(!psIndirectData) 
                PKITHROW(E_OUTOFMEMORY);
            
            if(!sSip.pfCreate(pSipInfo,
                              &dwIndirectData,
                              psIndirectData))
                PKITHROW(SignError());
            
            // Encode the indirect data
            CryptEncodeObject(dwEncodingType,
                              SPC_INDIRECT_DATA_CONTENT_STRUCT,
                              psIndirectData,
                              pbIndirectBlob,                   
                              &cbIndirectBlob);
            if (cbIndirectBlob == 0) 
                PKITHROW(SignError());
            pbIndirectBlob = (PBYTE) malloc(cbIndirectBlob);
            if(!pbIndirectBlob)
                PKITHROW(E_OUTOFMEMORY);
            if (!CryptEncodeObject(dwEncodingType,
                                   SPC_INDIRECT_DATA_CONTENT_STRUCT,
                                   psIndirectData,
                                   pbIndirectBlob,
                                   &cbIndirectBlob))
                PKITHROW(SignError());
        }
    
        
        
        // Encode the signed message
        // Setup the signing info
        ZeroMemory(&sSignerInfo, sizeof(CMSG_SIGNER_ENCODE_INFO));
        sSignerInfo.cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
        sSignerInfo.pCertInfo = psSigningContext->pCertInfo;
        sSignerInfo.hCryptProv = hCryptProv;
        sSignerInfo.dwKeySpec = dwKeySpec;
        sSignerInfo.HashAlgorithm.pszObjId = (char*) pszAlgorithmOid;
        sSignerInfo.cAuthAttr = dwAuthAttributes;
        sSignerInfo.rgAuthAttr = rgpAuthAttributes;
        sSignerInfo.cUnauthAttr = dwUnauthAttributes;
        sSignerInfo.rgUnauthAttr = rgpUnauthAttributes;


        // Setup the signing structures
        ZeroMemory(&sSignedInfo, sizeof(CMSG_SIGNED_ENCODE_INFO));
        sSignedInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
        sSignedInfo.cSigners = 1;
        sSignedInfo.rgSigners = &sSignerInfo;

        //  if there are certificates to add change them to the 
        //  form required by CryptMsg... functions

        //    load up the certificates into a vector 
        //    Count the number of certs in the store
        if(fIncludeCerts && hSpcStore) {
            PCCERT_CONTEXT pCert = NULL;
            while ((pCert = CertEnumCertificatesInStore(hSpcStore, pCert)))
                dwCryptMsgCertificates++;
            
            //        Get the encoded blobs of the CERTS
            if (dwCryptMsgCertificates > 0) {
                rgpCryptMsgCertificates = (PCERT_BLOB) malloc(sizeof(CERT_BLOB) * dwCryptMsgCertificates);
                if(!rgpCryptMsgCertificates)
                    PKITHROW(E_OUTOFMEMORY);

                ZeroMemory(rgpCryptMsgCertificates, sizeof(CERT_BLOB) * dwCryptMsgCertificates);
                
                PCERT_BLOB pCertPtr = rgpCryptMsgCertificates;
                pCert = NULL;
                DWORD c = 0;
                while ((pCert = CertEnumCertificatesInStore(hSpcStore, pCert)) && c < dwCryptMsgCertificates) {
                    pCertPtr->pbData = pCert->pbCertEncoded;
                    pCertPtr->cbData = pCert->cbCertEncoded;
                    c++; pCertPtr++;
                }
            }
            sSignedInfo.cCertEncoded = dwCryptMsgCertificates;
            sSignedInfo.rgCertEncoded = rgpCryptMsgCertificates;

            rgpCryptMsgCertificates=NULL;

            //        Get the encoded blobs of the CRLS
            DWORD crlFlag = 0;
            PCCRL_CONTEXT pCrl = NULL;
            while ((pCrl = CertGetCRLFromStore(hSpcStore, NULL, pCrl, &crlFlag)))
                dwCryptMsgCrls++;
            
            if (dwCryptMsgCrls > 0) {
                rgpCryptMsgCrls = (PCRL_BLOB) malloc(sizeof(CRL_BLOB) * dwCryptMsgCrls);
                if(!rgpCryptMsgCrls) PKITHROW(E_OUTOFMEMORY);

                ZeroMemory(rgpCryptMsgCrls, sizeof(CRL_BLOB) * dwCryptMsgCrls);
                PCRL_BLOB pCrlPtr = rgpCryptMsgCrls;
                pCrl = NULL;
                DWORD c = 0;
                while ((pCrl = CertGetCRLFromStore(hSpcStore, NULL, pCrl, &crlFlag)) && c < dwCryptMsgCrls) {
                    pCrlPtr->pbData = pCrl->pbCrlEncoded;
                    pCrlPtr->cbData = pCrl->cbCrlEncoded;
                    c++; pCrlPtr++;
                }
            }
            sSignedInfo.cCrlEncoded = dwCryptMsgCrls;
            sSignedInfo.rgCrlEncoded = rgpCryptMsgCrls;

            rgpCryptMsgCrls=NULL;
        }
        
        //check to see if the subject is a CTL file.  If it is, we need to preserve
        //all the certificates in the original signer Info
        if(CTLGuid == (*(pSipInfo->pgSubjectType)))
        {
            PCCERT_CONTEXT  pCert = NULL;

            //call Get the get the original signer information
            sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, NULL);
            
            if (cbGetBlob < 1)
            {
                PKITHROW(SignError());
            }

            if (!(pbGetBlob = (BYTE *)malloc(cbGetBlob)))
            {
                PKITHROW(E_OUTOFMEMORY);
            }

            if (!(sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, pbGetBlob)))
            {
                PKITHROW(SignError());
            }

            //open the PKCS7 BLOB as a certificate store
            PKCS7Blob.cbData=cbGetBlob;
            PKCS7Blob.pbData=pbGetBlob;

            hPKCS7CertStore=CertOpenStore(CERT_STORE_PROV_PKCS7,
                                          dwEncodingType,
                                          NULL,
                                          0,
                                          &PKCS7Blob);

            if(!hPKCS7CertStore)
                PKITHROW(SignError());  

            //enum all the certificate in the store
            while ((pCert = CertEnumCertificatesInStore(hPKCS7CertStore, pCert)))
                dwPKCS7Certs++;
            
            //Get the encoded blobs of the CERTS
            if (dwPKCS7Certs > 0) 
            {
                VOID *pvTemp;
                pvTemp = realloc(sSignedInfo.rgCertEncoded, 
                                      sizeof(CERT_BLOB) * (sSignedInfo.cCertEncoded+dwPKCS7Certs));
                if(!pvTemp)
                    PKITHROW(E_OUTOFMEMORY)
                else
                    sSignedInfo.rgCertEncoded = (PCERT_BLOB) pvTemp;

                PCERT_BLOB pCertPtr = (sSignedInfo.rgCertEncoded + sSignedInfo.cCertEncoded);
                pCert = NULL;
                DWORD c = 0;
                while ((pCert = CertEnumCertificatesInStore(hPKCS7CertStore, pCert)) && c < dwPKCS7Certs) 
                {
                   fFound=FALSE;

                    //we need to make sure that we do not add duplicated certificates
                    for(dwCertIndex=0; dwCertIndex<sSignedInfo.cCertEncoded; dwCertIndex++)
                    {
                        if((sSignedInfo.rgCertEncoded[dwCertIndex]).cbData==pCert->cbCertEncoded)
                        {
                          if(0==memcmp((sSignedInfo.rgCertEncoded[dwCertIndex]).pbData,
                                       pCert->pbCertEncoded, pCert->cbCertEncoded))
                          {
                               fFound=TRUE;
                               break;
                          }
                        }

                    }

                    //we only add the certificates that do not duplicates the signer's
                    //certificates
                    if(FALSE==fFound)
                    {
                        pCertPtr->pbData = pCert->pbCertEncoded;
                        pCertPtr->cbData = pCert->cbCertEncoded;
                        c++; pCertPtr++; 
                    }
                }
            
                sSignedInfo.cCertEncoded += c;
            }
        }

        if (fCTLFile)
        {
            //
            //  get the signed message if we need to
            //
            if(NULL==pbGetBlob)
            {
                //
                sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, NULL);
            
                if (cbGetBlob < 1)
                {
                    PKITHROW(SignError());
                }
                if (!(pbGetBlob = (BYTE *)malloc(cbGetBlob)))
                {
                    PKITHROW(E_OUTOFMEMORY);
                }

                if (!(sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, pbGetBlob)))
                {
                    PKITHROW(SignError());
                } 
            }

            //
            //  extract the inner content
            //
            
            pCTLContext = (PCTL_CONTEXT)CertCreateCTLContext(
                                                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                                    pbGetBlob,
                                                    cbGetBlob);

            if (!(pCTLContext))
            {
                PKITHROW(SignError());
            }

            if (!(pCTLContext->pbCtlContent))
            {
                PKITHROW(SignError());
            }

            //
            //  add singer info! (e.g.: sign it!)
            //
            cbEncodedSignMsg = 0;

            CryptMsgSignCTL(dwEncodingType, pCTLContext->pbCtlContent, pCTLContext->cbCtlContent,
                                &sSignedInfo, 0, NULL, &cbEncodedSignMsg);

            if (cbEncodedSignMsg < 1)
            {
                PKITHROW(SignError());
            }

            if (!(pbEncodedSignMsg = (BYTE *)malloc(cbEncodedSignMsg)))
            {
                PKITHROW(E_OUTOFMEMORY);
            }

            if (!(CryptMsgSignCTL(dwEncodingType, 
                                  pCTLContext->pbCtlContent, pCTLContext->cbCtlContent,
                                  &sSignedInfo, 0, pbEncodedSignMsg, &cbEncodedSignMsg)))
            {
                PKITHROW(SignError());
            }

            CertFreeCTLContext(pCTLContext);
            pCTLContext = NULL;
        }
        else
        {
            hMsg = CryptMsgOpenToEncode(dwEncodingType,
                                        0,                      // dwFlags
                                        CMSG_SIGNED,
                                        &sSignedInfo,
                                        SPC_INDIRECT_DATA_OBJID,
                                        NULL);
            if(hMsg == NULL)
                PKITHROW(SignError());
            
            if (!CryptMsgUpdate(hMsg,
                                pbIndirectBlob,
                                cbIndirectBlob,
                                TRUE))  // Final
                PKITHROW(SignError());
            
            CryptMsgGetParam(hMsg,
                             CMSG_CONTENT_PARAM,
                             0,                      // dwIndex
                             NULL,                   // pbSignedData
                             &cbEncodedSignMsg);
            if (cbEncodedSignMsg == 0) PKITHROW(SignError());
            
            pbEncodedSignMsg = (PBYTE) malloc(cbEncodedSignMsg);
            if(!pbEncodedSignMsg) PKITHROW(E_OUTOFMEMORY);
            
            if (!CryptMsgGetParam(hMsg,
                                  CMSG_CONTENT_PARAM,
                                  0,                      // dwIndex
                                  pbEncodedSignMsg,
                                  &cbEncodedSignMsg))
                PKITHROW(SignError());
        }
        
        //put the signatures if we are dealing with anything other than the BLOB
        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
            // Purge all the signatures in the subject
            sSip.pfRemove(pSipInfo, *pdwIndex);

            // Store the Signed Message in the sip
            if(!(sSip.pfPut(    pSipInfo,
                                dwEncodingType,
                                pdwIndex,
                                cbEncodedSignMsg,
                                pbEncodedSignMsg)))
            {
                PKITHROW(SignError());
            }
        }

        if(ppbMessage && pcbMessage) {
            *ppbMessage = pbEncodedSignMsg;
            pbEncodedSignMsg = NULL;
            *pcbMessage = cbEncodedSignMsg;
        }

        if(ppbDigest && pcbDigest) {
            // Get the encrypted digest
            pbSignerData = NULL;
            CryptMsgGetParam(hMsg,
                             CMSG_ENCRYPTED_DIGEST,
                             0,                      // dwIndex
                             pbSignerData,
                             &cbSignerData);
            if(cbSignerData == 0) PKITHROW(SignError());
            
            pbSignerData = (PBYTE)  malloc(cbSignerData);
            if(!pbSignerData) PKITHROW(E_OUTOFMEMORY);
            
            if(!CryptMsgGetParam(hMsg,
                                 CMSG_ENCRYPTED_DIGEST,
                                 0,                      // dwIndex
                                 pbSignerData,
                                 &cbSignerData))
                PKITHROW(SignError());
            *ppbDigest = pbSignerData;
            pbSignerData = NULL;
            *pcbDigest = cbSignerData;
        }
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (pCTLContext)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (pbSignerData) 
        free(pbSignerData);
    if(pbEncodedSignMsg)
        free(pbEncodedSignMsg);
    if(hMsg)
        CryptMsgClose(hMsg);

    if(sSignedInfo.rgCrlEncoded)
        free(sSignedInfo.rgCrlEncoded);

    if(sSignedInfo.rgCertEncoded)
        free(sSignedInfo.rgCertEncoded);

    if(pbIndirectBlob)                      
        free(pbIndirectBlob);
    if(pbGetBlob)
        free(pbGetBlob);
    if(hPKCS7CertStore)
        CertCloseStore(hPKCS7CertStore,0);
    if(psIndirectData)
        free(psIndirectData);
    if(rgpAuthAttributes)
        free(rgpAuthAttributes);
    if(pbStatementAttribute)
        free(pbStatementAttribute);
    if(pbOpusAttribute)
        free(pbOpusAttribute);
    return hr;
}


//--------------------------------------------------------------------------
//
//  SignerTimeStamp:
//      Timestamp a file.  
//
//--------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStamp(
IN  SIGNER_SUBJECT_INFO *pSubjectInfo,      //Required: The subject to be timestamped 
IN  LPCWSTR             pwszHttpTimeStamp,  // Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES   psRequest,          // Optional, attributes added to the timestamp 
IN  LPVOID              pSipData            // Optional: The additional data passed to sip funcitons
)
{
    return SignerTimeStampEx(0,
                            pSubjectInfo,
                           pwszHttpTimeStamp,
                           psRequest,
                           pSipData,
                           NULL);
}

//--------------------------------------------------------------------------
//
//  SignerTimeStampEx:
//      Timestamp a file.  
//
//--------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStampEx(
IN  DWORD               dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO *pSubjectInfo,      //Required: The subject to be timestamped 
IN  LPCWSTR             pwszHttpTimeStamp,  // Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES   psRequest,          // Optional, attributes added to the timestamp 
IN  LPVOID              pSipData,           // Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT      **ppSignerContext   // Optional: The signed BLOB.  User has to free
                                            //          the context via SignerFreeSignerContext
)       
{
    HRESULT     hr=E_FAIL;
    DWORD       dwTimeStampRequest=0;
    BYTE        *pbTimeStampRequest=NULL;
    DWORD       dwTimeStampResponse=0;
    BYTE        *pbTimeStampResponse=NULL;
    CHttpTran   cTran;
    BOOL        fOpen=FALSE;
    DWORD       err;
    LPSTR       szURL=NULL;
    DWORD       dwEncodingType=OCTET_ENCODING;
    CHAR        *pEncodedRequest=NULL;
    DWORD       dwEncodedRequest=0;
    CHAR        *pEncodedResponse=NULL;
    DWORD       dwEncodedResponse=0;

    //input parameter check
    if((!pwszHttpTimeStamp) ||(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo)))
        return E_INVALIDARG;

    //request a time stamp
    hr=SignerCreateTimeStampRequest(pSubjectInfo,
                                psRequest,
                                pSipData,
                                NULL,
                                &dwTimeStampRequest);

    if(hr!=S_OK)
        goto CLEANUP;

    pbTimeStampRequest=(BYTE *)malloc(dwTimeStampRequest);

    if(!pbTimeStampRequest)
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }


    hr=SignerCreateTimeStampRequest(pSubjectInfo,
                                psRequest,
                                pSipData,
                                pbTimeStampRequest,
                                &dwTimeStampRequest);

   if(hr!=S_OK)
       goto CLEANUP;

   //conver the WSTR of URL to STR
   if((hr=WSZtoSZ((LPWSTR)pwszHttpTimeStamp,&szURL))!=S_OK)
       goto CLEANUP;

   //base64 encode the request
   if(S_OK!=(hr=BytesToBase64(pbTimeStampRequest, 
       dwTimeStampRequest, 
       &pEncodedRequest,
       &dwEncodedRequest)))
       goto CLEANUP;

   //estalish the connection between the http site
   err=cTran.Open( szURL, GTREAD|GTWRITE);

   if(err!=ERROR_SUCCESS)
   {
        hr=E_FAIL;
        goto CLEANUP;
   }

   //mark that we have open the connection successful
   fOpen=TRUE;


   //send the request
   err=cTran.Send(dwEncodingType,dwEncodedRequest,(BYTE *)pEncodedRequest);

   if(err!=ERROR_SUCCESS)
   {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto CLEANUP;
   }

      //send the request
   err=cTran.Receive(&dwEncodingType,&dwEncodedResponse,(BYTE **)&pEncodedResponse);

   if(err!=ERROR_SUCCESS)
   {
        hr=E_FAIL;
        goto CLEANUP;
   }
      
   //make sure the encoding type is correct
  // if(dwEncodingType!=OCTET_ENCODING)
  // {
//      hr=E_FAIL;
//      goto CLEANUP;
 //  }

   //base64 decode the response
   if(S_OK != (hr=Base64ToBytes(
       pEncodedResponse,
       dwEncodedResponse,
       &pbTimeStampResponse,
       &dwTimeStampResponse)))
       goto CLEANUP;


   //add the timestamp response to the time
   hr=SignerAddTimeStampResponseEx(0, pSubjectInfo,pbTimeStampResponse,
                                dwTimeStampResponse, pSipData,
                                ppSignerContext);



CLEANUP:
          
   if(pEncodedRequest)
       free(pEncodedRequest);

   if(pbTimeStampResponse)
       free(pbTimeStampResponse);

   if(pbTimeStampRequest)
       free(pbTimeStampRequest);

   if(szURL)
       free(szURL);

   if(fOpen)
   {
        if(pEncodedResponse)
            cTran.Free((BYTE *)pEncodedResponse);

        cTran.Close();
   }

    return hr;

}
//+-----------------------------------------------------------------------
//  
//  SignerSign:
//      Sign and/or timestamp a file.
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSign(
IN  SIGNER_SUBJECT_INFO     *pSubjectInfo,      //Required: The subject to be signed and/or timestamped 
IN  SIGNER_CERT             *pSignerCert,       //Required: The signing certificate to use
IN  SIGNER_SIGNATURE_INFO   *pSignatureInfo,    //Required: The signature information during signing process
IN  SIGNER_PROVIDER_INFO    *pProviderInfo,     //Optional: The crypto security provider to use.
                                                //          This parameter has to be set unless
                                                //          certStoreInfo is set in *pSignerCert
                                                //          and the signing certificate has provider
                                                //          information associated with it
IN  LPCWSTR                 pwszHttpTimeStamp,  //Optional: Timestamp server http address.  If this parameter
                                                //          is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES       psRequest,          //Optional: Attributes added to Time stamp request. Ignored
                                                //          unless pwszHttpTimeStamp is set   
IN  LPVOID                  pSipData            //Optional: The additional data passed to sip funcitons
)
{

    return SignerSignEx(
                0,
               pSubjectInfo,        
               pSignerCert,     
               pSignatureInfo,  
               pProviderInfo,       
               pwszHttpTimeStamp,   
               psRequest,           
               pSipData,
               NULL);

}


//+-----------------------------------------------------------------------
//  
//  SignerSignEx:
//      Sign and/or timestamp a file.
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSignEx(
IN  DWORD                   dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO     *pSubjectInfo,      //Required: The subject to be signed and/or timestamped 
IN  SIGNER_CERT             *pSignerCert,       //Required: The signing certificate to use
IN  SIGNER_SIGNATURE_INFO   *pSignatureInfo,    //Required: The signature information during signing process
IN  SIGNER_PROVIDER_INFO    *pProviderInfo,     //Optional: The crypto security provider to use.
                                                //          This parameter has to be set unless
                                                //          certStoreInfo is set in *pSignerCert
                                                //          and the signing certificate has provider
                                                //          information associated with it
IN  LPCWSTR                 pwszHttpTimeStamp,  //Optional: Timestamp server http address.  If this parameter
                                                //          is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES       psRequest,          //Optional: Attributes added to Time stamp request. Ignored
                                                //          unless pwszHttpTimeStamp is set   
IN  LPVOID                  pSipData,           //Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext   //Optional: The signed BLOB.  User has to free
                                                //          the context via SignerFreeSignerContext
)                                   
{

    HRESULT             hr = S_OK;
    HANDLE              hFile = NULL;      // File to sign
    BOOL                fFileOpen=FALSE;
    HCERTSTORE          hSpcStore = NULL;  // Certificates added to signature
    PCCERT_CONTEXT      psSigningContext = NULL; // Cert context to the signing certificate

    GUID                gSubjectGuid; // The subject guid used to load the sip
    SIP_SUBJECTINFO     sSubjInfo; ZERO(sSubjInfo);
    MS_ADDINFO_BLOB     sBlob; 

    HCRYPTPROV          hCryptProv = NULL; // Crypto provider, uses private key container
    HCRYPTPROV          hMSBaseProv = NULL; //This is the MS base provider for hashing purpose
    LPWSTR              pwszTmpContainer = NULL; // Pvk container (opened up pvk file)
    LPWSTR              pwszProvName=NULL;
    DWORD               dwProvType;
    BOOL                fAcquired=FALSE;

    LPCWSTR             pwszPvkFile = NULL;
    LPCWSTR             pwszKeyContainerName = NULL; 
    BOOL                fAuthcode=FALSE;
    BOOL                fCertAcquire=FALSE;

    //set dwKeySpec to 0.  That is, we allow any key specification 
    //for code signing
    DWORD               dwKeySpec = 0; 
    DWORD               dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.
    LPCSTR              pszAlgorithmOid = NULL;
    WCHAR               wszPublisher[40];

    PBYTE               pbEncodedMessage=NULL;          
    DWORD               cbEncodedMessage=0;         


    //input parameter checking
    if(!CheckSigncodeParam(pSubjectInfo, pSignerCert, pSignatureInfo,
                    pProviderInfo))
        return E_INVALIDARG;

    //determine if this is an authenticode specific signing
    if(pSignatureInfo->dwAttrChoice==SIGNER_AUTHCODE_ATTR)
        fAuthcode=TRUE;

    //init
    if(ppSignerContext)
        *ppSignerContext=NULL;
            
    // Acquire a context for the specified provider

    // First,try to acquire the provider context based on the properties on a cert
    if(pSignerCert->dwCertChoice==SIGNER_CERT_STORE)
    {
        if(GetCryptProvFromCert(pSignerCert->hwnd,
                            (pSignerCert->pCertStoreInfo)->pSigningCert,
                            &hCryptProv,
                            &dwKeySpec,
                            &fAcquired,
                            &pwszTmpContainer,
                            &pwszProvName,
                            &dwProvType))
            //mark that we acquire the context via the cert's property
            fCertAcquire=TRUE;
    }

    // If the 1st failed, try to acquire the provider context based on 
    //pPvkInfo
    if(hCryptProv==NULL)
    {
        //pProviderInfo has to be set
        if(!pProviderInfo)
        {
            hr=CRYPT_E_NO_PROVIDER;
            goto CLEANUP;
        }

        //decide the PVK file name or the key container name
        if(pProviderInfo->dwPvkChoice == PVK_TYPE_FILE_NAME)
            pwszPvkFile=pProviderInfo->pwszPvkFileName;
        else
            pwszKeyContainerName=pProviderInfo->pwszKeyContainer;

        //load from the resource of string L"publisher"
        if(0==LoadStringU(hInstance, IDS_Publisher, wszPublisher, 40))
        {
            hr=SignError();
            goto CLEANUP;
        }

        //acquire the context
        if(S_OK != (hr=PvkGetCryptProv(
                            pSignerCert->hwnd,
                            wszPublisher,
                            pProviderInfo->pwszProviderName,
                            pProviderInfo->dwProviderType,
                            pwszPvkFile,
                            pwszKeyContainerName,
                            &(pProviderInfo->dwKeySpec),
                            &pwszTmpContainer,
                            &hCryptProv)))
        {
            hr=CRYPT_E_NO_PROVIDER;
            goto CLEANUP;
        }

        //mark the hCryptProv is acquired
        fAcquired=TRUE;

        //mark the key spec that we used
        dwKeySpec=pProviderInfo->dwKeySpec;
    }


    //now, acquire a MS base crypto provider for any operation other than
    //signing

    if(!CryptAcquireContext(&hMSBaseProv,
                            NULL,
                            MS_DEF_PROV,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT))
    {
        hr=GetLastError();
        goto CLEANUP;
    }

    

    //build a certificate store, which includes the signing certificate,
    //and all the certs necessary in the signature
    //get the signing certificate
    if(S_OK != (hr = BuildCertStore(hCryptProv,
                                    dwKeySpec,
                                    hMSBaseProv, 
                                    dwEncodingType,
                                    pSignerCert, 
                                    &hSpcStore,
                                    &psSigningContext)))
        goto CLEANUP;      
    
    //check the time validity of the signing certificate
    if(0!=CertVerifyTimeValidity(NULL, psSigningContext->pCertInfo))
    {
        hr=CERT_E_EXPIRED;
        goto CLEANUP;
    }

    // Determine the hashing algorithm
    pszAlgorithmOid = CertAlgIdToOID(pSignatureInfo->algidHash);
            
    // Set up the sip information 
    sSubjInfo.hProv = hMSBaseProv;
    sSubjInfo.DigestAlgorithm.pszObjId = (char*) pszAlgorithmOid;
    sSubjInfo.dwEncodingType = dwEncodingType;
    sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
    sSubjInfo.pClientData = pSipData;
           

    //set up file information
    if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
    {
        // Open up the file
        if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
            (pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
        {
            if(S_OK != (hr = SignOpenFile(
                            pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
                goto CLEANUP;

            fFileOpen=TRUE;
        }
        else
            hFile=pSubjectInfo->pSignerFileInfo->hFile;

        // Get the subject type.
        if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
            goto CLEANUP;


        sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
        sSubjInfo.hFile = hFile;
        sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
    }
    else
    {
         memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

         sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
         sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
         sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
         sSubjInfo.psBlob=&sBlob;

         sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
         sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
         sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
    }

    //now call InternalSign to do the real work
    hr = InternalSign(dwEncodingType,
          hCryptProv,
          dwKeySpec,
          pszAlgorithmOid,
          &sSubjInfo,
          pSubjectInfo->pdwIndex,
          psSigningContext,
          hSpcStore,
          fAuthcode ? pSignatureInfo->pAttrAuthcode->pwszName : NULL,
          fAuthcode ? pSignatureInfo->pAttrAuthcode->pwszInfo : NULL,
          TRUE,
          fAuthcode ? pSignatureInfo->pAttrAuthcode->fCommercial : FALSE,
          fAuthcode ? pSignatureInfo->pAttrAuthcode->fIndividual : FALSE,
          fAuthcode,
          pSignatureInfo->psAuthenticated,
          pSignatureInfo->psUnauthenticated,
          NULL,
          NULL,
          &pbEncodedMessage,
          &cbEncodedMessage);

    if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
    {
        fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
    }

    if(hr != S_OK) 
        goto CLEANUP;

    //timestamp the file if requested
    if(pwszHttpTimeStamp)
    {
        if(S_OK != (hr =SignerTimeStampEx(0,
                                          pSubjectInfo,pwszHttpTimeStamp, 
                                          psRequest,pSipData,
                                          ppSignerContext)))
            goto CLEANUP;
    }
    else
    {
        if(ppSignerContext)
        {
            //set up the context information
            *ppSignerContext=(SIGNER_CONTEXT *)malloc(sizeof(SIGNER_CONTEXT));

            if(NULL==(*ppSignerContext))
            {
                hr=E_OUTOFMEMORY;
                goto CLEANUP;
            }

            (*ppSignerContext)->cbSize=sizeof(SIGNER_CONTEXT);
            (*ppSignerContext)->cbBlob=cbEncodedMessage;
            (*ppSignerContext)->pbBlob=pbEncodedMessage;
            pbEncodedMessage=NULL;
        }
    }

    hr=S_OK;


CLEANUP:

    //free the memory. 
    if(pbEncodedMessage)
        free(pbEncodedMessage);

    if(psSigningContext) 
        CertFreeCertificateContext(psSigningContext);

    if(hSpcStore) 
        CertCloseStore(hSpcStore, 0);

    //free the CryptProvider
    if(hCryptProv)
    {
        if(fCertAcquire)
        {
           FreeCryptProvFromCert(fAcquired,
                                 hCryptProv,
                                 pwszProvName,
                                 dwProvType,
                                 pwszTmpContainer);
        }
        else
        {
            PvkFreeCryptProv(hCryptProv,
                             pProviderInfo? pProviderInfo->pwszProviderName : NULL,
                             pProviderInfo? pProviderInfo->dwProviderType : 0,
                             pwszTmpContainer);
        }
    }

    if(hMSBaseProv)
    {
        CryptReleaseContext(hMSBaseProv, 0);
    }


    if(hFile && (fFileOpen==TRUE)) 
        CloseHandle(hFile);

#if (1) //DSIE: bug 306005.
    if (hr != S_OK && !HRESULT_SEVERITY(hr))
    {
        // Some CAPIs does not return HRESULT. They return Win API errors,
        // so need to convert to HRESULT so that caller using the FAILED
        // macro will catch the error.
        hr = HRESULT_FROM_WIN32((DWORD) hr);
    }
#endif

    return hr;
}


//+-----------------------------------------------------------------------
//  
// SignerFreeSignerContext
//     
//------------------------------------------------------------------------
HRESULT WINAPI
SignerFreeSignerContext(
IN  SIGNER_CONTEXT          *pSignerContext)
{
    if(pSignerContext)
    {
        if(pSignerContext->pbBlob)
            free(pSignerContext->pbBlob);

        free(pSignerContext);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\makefile.inc ===
mssign32_all:
    xcopy /D $(SDK_LIB_PATH)\mssign32.* $(SECURITY_LIB_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\pvkhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.cpp
//
//  Contents:   Private Key Helper APIs
//
//  Functions:  PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <assert.h>
#include <string.h>
#include <memory.h>
#include <objbase.h>
#include "pvk.h"
#include "unicode.h"


//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0
#define PVK_RC4_PASSWORD_ENCRYPT        1
#define PVK_RC2_CBC_PASSWORD_ENCRYPT    2

#define MAX_PVK_FILE_LEN            4096
#define MAX_BOB_FILE_LEN            (4096*4)

typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);



//+-------------------------------------------------------------------------
//  Private key helper allocation and free functions
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
void PvkFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Read  & Write to file function
//--------------------------------------------------------------------------
static BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}

static BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL) && cbBytesRead == cb);
}


//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL WriteToMemory(HANDLE h, void * p, DWORD cb) {

    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if(pMemInfo->cbSeek + cb <= pMemInfo->cb)
        // copy the bytes
        memcpy(&pMemInfo->pb[pMemInfo->cbSeek], p, cb);

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

static BOOL GetPasswordKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN PASSWORD_TYPE PasswordType,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN BOOL fNoPassDlg,
    IN BYTE *pbSalt,
    IN DWORD cbSalt,
    OUT HCRYPTKEY *phEncryptKey,
    OUT OPTIONAL HCRYPTKEY *ph40EncryptKey = NULL,
    OUT OPTIONAL HCRYPTKEY *ph128EncryptKey = NULL
    )
{
    BOOL fResult;
    BYTE *pbAllocPassword = NULL;
    BYTE *pbPassword;
    DWORD cbPassword;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hEncryptKey = 0;
    BYTE rgbDefPw []    = { 0x43, 0x52, 0x41, 0x50 };
    DWORD cbDefPw       = sizeof(rgbDefPw);

    if (ph40EncryptKey)
        *ph40EncryptKey = 0;
    if (ph128EncryptKey)
        *ph128EncryptKey = 0;

    if (fNoPassDlg) {
        pbPassword = rgbDefPw;
        cbPassword = cbDefPw;
    } else {
        if (IDOK != PvkDlgGetKeyPassword(
                PasswordType,
                hwndOwner,
                pwszKeyName,
                &pbAllocPassword,
                &cbPassword
                )) {
            SetLastError(PVK_HELPER_PASSWORD_CANCEL);
            goto ErrorReturn;
        }
        pbPassword = pbAllocPassword;
    }

    if (cbPassword) {
        if (!CryptCreateHash(hProv, CALG_SHA, 0, 0, &hHash))
            goto ErrorReturn;
        if (cbSalt) {
            if (!CryptHashData(hHash, pbSalt, cbSalt, 0))
                goto ErrorReturn;
        }
        if (!CryptHashData(hHash, pbPassword, cbPassword, 0))
            goto ErrorReturn;
        if (!CryptDeriveKey(hProv, Algid, hHash, 0, &hEncryptKey))
            goto ErrorReturn;
        if (ph40EncryptKey) {
            if (!CryptDeriveKey(hProv, Algid, hHash,
                    40 << 16,   // dwFlags, dwBitLen in upper WORD
                    ph40EncryptKey)) {
                *ph40EncryptKey = NULL;
            }
        }
        if (ph128EncryptKey) {
            if (!CryptDeriveKey(hProv, Algid, hHash,
                    128 << 16,  // dwFlags, dwBitLen in upper WORD
                    ph128EncryptKey)) {
                *ph128EncryptKey = NULL;
            }
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
CommonReturn:
    if (pbAllocPassword) {
        SecureZeroMemory(pbAllocPassword, cbPassword);
        PvkFree(pbAllocPassword);
    }
    if (hHash)
        CryptDestroyHash(hHash);
    *phEncryptKey = hEncryptKey;
    return fResult;
}

// Support backwards compatibility with Bob's storage file which contains
// a snap shot of the keys as they are stored in the registry. Note, for
// win95, the registry values are decrypted before being written to the file.
static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    );

static BOOL LoadKeyW(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hDecryptKey = 0;
    HCRYPTKEY h40DecryptKey = 0;
    HCRYPTKEY h128DecryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr))) goto BadPvkFile;
    if (Hdr.dwMagic != PVK_MAGIC)
        // Try to load as Bob's storage file containing streams for the
        // private and public keys. Bob made a copy of the cryptography
        // registry key values.
        //
        // Note, Bob now has two different formats for storing the private
        // key information. See LoadBobKey for details.
        fResult = LoadBobKey(hCryptProv, hRead, pfnRead, cbKeyData, hwndOwner,
            pwszKeyName, dwFlags, pdwKeySpec, &Hdr);
    else {
        // Treat as a "normal" private key file
        cbPvk = Hdr.cbPvk;
        if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
            Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
            cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
        goto BadPvkFile;
    
        if (pdwKeySpec) {
            DWORD dwKeySpec = *pdwKeySpec;
            *pdwKeySpec = Hdr.dwKeySpec;
            if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
                SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
                goto ErrorReturn;
            }
        }
    
        if (Hdr.cbEncryptData) {
            // Read the encrypt data
            if (NULL == (pbEncryptData = (BYTE *) PvkAlloc(Hdr.cbEncryptData)))
                goto ErrorReturn;
            if (!pfnRead(hRead, pbEncryptData, Hdr.cbEncryptData))
                goto BadPvkFile;
        }
    
        // Allocate and read the private key
        if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
            goto ErrorReturn;
        if (!pfnRead(hRead, pbPvk, cbPvk))
            goto BadPvkFile;
    
    
        // Get symmetric key to decrypt the private key
        switch (Hdr.dwEncryptType) {
            case PVK_NO_ENCRYPT:
                break;
            case PVK_RC4_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC4,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey, &h40DecryptKey, &h128DecryptKey))
                    goto ErrorReturn;
                break;
            case PVK_RC2_CBC_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC2,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey, &h40DecryptKey, &h128DecryptKey))
                    goto ErrorReturn;
                break;
            default:
                goto BadPvkFile;
        }

        // Decrypt and import the private key
        hKey = 0;
        fResult = CryptImportKey(hCryptProv, pbPvk, cbPvk, hDecryptKey, dwFlags,
                &hKey);

        if (!fResult && h40DecryptKey) {
            hKey = 0;
            fResult = CryptImportKey(hCryptProv, pbPvk, cbPvk,
                h40DecryptKey, dwFlags, &hKey);
        }

        if (!fResult && h128DecryptKey) {
            hKey = 0;
            fResult = CryptImportKey(hCryptProv, pbPvk, cbPvk,
                h128DecryptKey, dwFlags, &hKey);
        }
    }
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncryptData)
        PvkFree(pbEncryptData);
    if (pbPvk)
        PvkFree(pbPvk);
    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (h40DecryptKey)
        CryptDestroyKey(h40DecryptKey);
    if (h128DecryptKey)
        CryptDestroyKey(h128DecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL LoadKeyA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    
    WIDEN(pszKeyName, pwszKeyName);
    //    LPWSTR pwszKeyName = MkWStr((char*) pszKeyName);
    BOOL fResult = LoadKeyW(hCryptProv,
                            hRead,
                            pfnRead,
                            cbKeyData,
                            hwndOwner,
                            pwszKeyName,
                            dwFlags,
                            pdwKeySpec);
    return fResult;
}

static BOOL SaveKeyW(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hEncryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;     // Not allocated
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    BYTE rgbSalt[16];

    // Initialize the header record
    memset(&Hdr, 0, sizeof(Hdr));
    Hdr.dwMagic = PVK_MAGIC;
    Hdr.dwVersion = PVK_FILE_VERSION_0;
    Hdr.dwKeySpec = dwKeySpec;

    // Generate random salt
    if (!CryptGenRandom(hCryptProv, sizeof(rgbSalt), rgbSalt))
        goto ErrorReturn;

    // Get symmetric key to use to encrypt the private key
#if 1
    if (!GetPasswordKey(hCryptProv, CALG_RC4,
#else
    if (!GetPasswordKey(hCryptProv, CALG_RC2,
#endif
            CREATE_PASSWORD, hwndOwner, pwszKeyName,
            fNoPassDlg, rgbSalt, sizeof(rgbSalt), &hEncryptKey))
        goto ErrorReturn;
    if (hEncryptKey) {
#if 1
        Hdr.dwEncryptType = PVK_RC4_PASSWORD_ENCRYPT;
#else
        Hdr.dwEncryptType = PVK_RC2_CBC_PASSWORD_ENCRYPT;
#endif
        Hdr.cbEncryptData = sizeof(rgbSalt);
        pbEncryptData = rgbSalt;
    } else
        Hdr.dwEncryptType = PVK_NO_ENCRYPT;

    // Allocate, encrypt and export the private key
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
        goto ErrorReturn;
    cbPvk = 0;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, NULL,
            &cbPvk))
        goto ErrorReturn;
    if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
        goto ErrorReturn;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, pbPvk,
            &cbPvk))
        goto ErrorReturn;
    Hdr.cbPvk = cbPvk;


    // Write the header, optional encrypt data, and private key to the file
    if (!pfnWrite(hWrite, &Hdr, sizeof(Hdr)))
        goto ErrorReturn;
    if (Hdr.cbEncryptData) {
        if (!pfnWrite(hWrite, pbEncryptData, Hdr.cbEncryptData))
            goto ErrorReturn;
    }
    if (!pfnWrite(hWrite, pbPvk, cbPvk))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        PvkFree(pbPvk);
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}


static BOOL SaveKeyA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    
    WIDEN(pszKeyName, pwszKeyName);

    //    LPWSTR pwszKeyName = MkWStr((char*) pszKeyName);
    BOOL fResult = SaveKeyW(hCryptProv,
                            hWrite,
                            pfnWrite,
                            dwKeySpec,
                            hwndOwner,
                            pwszKeyName,
                            dwFlags,
                            fNoPassDlg);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from the file into the cryptographic provider.
//
//  If the private key was password encrypted, then, the user is first
//  presented with a dialog box to enter the password.
//
//  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
//  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
//  a mismatch. *pdwKeySpec is updated with the key type.
//
//  dwFlags is passed through to CryptImportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKeyW(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

BOOL
WINAPI
PvkPrivateKeyLoadA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKeyA(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to the specified file.
//
//  The user is presented with a dialog box to enter an optional password to
//  encrypt the private key.
//
//  dwFlags is passed through to CryptExportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKeyW(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

BOOL
WINAPI
PvkPrivateKeySaveA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKeyA(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from memory into the cryptographic provider.
//
//  Except for the key being loaded from memory, identical to PrivateKeyLoad.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyLoadFromMemory(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKeyW(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

BOOL
WINAPI
PvkPrivateKeyLoadFromMemoryA(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKeyA(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to memory.
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error (also, the user isn't prompted for a password).
//
//  Except for the key being saved to memory, identical to PrivateKeySave.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeySaveToMemory(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    if (fResult = SaveKeyW(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            )) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


BOOL
WINAPI
PvkPrivateKeySaveToMemoryA(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    if (fResult = SaveKeyA(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            )) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(WCHAR))


//+-------------------------------------------------------------------------
//  Converts the bytes into CHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(CHAR) bytes of space in sz
//--------------------------------------------------------------------------
static void BytesToStr(ULONG cb, void* pv, LPTSTR sz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        b = *pb & 0x0F;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        pb++;
    }
    *sz++ = 0;
}

#define UUID_STR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(CHAR))


static BOOL AcquireKeyContextW(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;

    // Create a temporary keyset to load the private key into
    // UuidCreate(&TmpContainerUuid);
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto ErrorReturn;
    }
    if (NULL == (pwszTmpContainer = (LPWSTR) PvkAlloc(
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES)))
        goto ErrorReturn;
    wcscpy(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKeyW(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pwszTmpContainer) {
        PvkFree(pwszTmpContainer);
        pwszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppwszTmpContainer = pwszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

static BOOL AcquireKeyContextA(
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPTSTR *ppszTmpContainer
    )
{
    DWORD hr;
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPTSTR pszTmpContainer = NULL;

    // Create a temporary keyset to load the private key into
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto ErrorReturn;
    }
    if (NULL == (pszTmpContainer = (LPTSTR) PvkAlloc(
            6 * sizeof(CHAR) + UUID_STR_BYTES)))
        goto ErrorReturn;
    strcpy(pszTmpContainer, "TmpKey");
    BytesToStr(sizeof(UUID), &TmpContainerUuid, pszTmpContainer + 6);

    if (!CryptAcquireContext(
            &hProv,
            pszTmpContainer,
            pszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKeyA(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContext(
        &hProv,
        pszTmpContainer,
        pszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    hr = GetLastError();
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pszTmpContainer) {
        PvkFree(pszTmpContainer);
        pszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppszTmpContainer = pszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from the specified file.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoad is called to load the private key into the temporary
//  container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyAcquireContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    HRESULT hr = S_OK;

    if(FAILED(hr))
        return FALSE;

    BOOL fhr = AcquireKeyContextW(
        pwszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
    return fhr;
}

BOOL
WINAPI
PvkPrivateKeyAcquireContextA(
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPTSTR *ppszTmpContainer
    )
{
    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    BOOL fhr = AcquireKeyContextA(
        pszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppszTmpContainer
        );
    return fhr;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    BOOL fhr = AcquireKeyContextW(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
    return fhr;
}

BOOL
WINAPI
PvkPrivateKeyAcquireContextFromMemoryA(
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPTSTR *ppszTmpContainer
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    BOOL fhr = AcquireKeyContextA(
        pszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppszTmpContainer
        );
    return fhr;
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pwszTmpContainer);
    }

    return TRUE;
}

BOOL
WINAPI
PvkPrivateKeyReleaseContextA(
    IN HCRYPTPROV hCryptProv,
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN LPTSTR pszTmpContainer
    )
{
    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContext(
                &hCryptProv,
                pszTmpContainer,
                pszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pszTmpContainer);
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Functions supporting backwards compatibility with Bob's storage file
//  containing a snap shot of the keys as they are stored in the registry.
//  Note, for win95, the registry values are decrypted before being written to
//  the file.
//--------------------------------------------------------------------------

// Return the size of this stream; return 0 if an error
static DWORD CbBobSize(IStream *pStm)
{
    STATSTG stat;
    if (FAILED(pStm->Stat(&stat, STATFLAG_NONAME)))
        return 0;
    return stat.cbSize.LowPart;
}

// Allocate and read this value which has the indicated stream name from the
// storage
static BOOL LoadBobStream(
    IStorage *pStg,
    LPCWSTR pwszStm,
    BYTE **ppbValue,
    DWORD *pcbValue
    )
{
    BOOL fResult;
    HRESULT hr;
    IStream *pStm = NULL;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    DWORD cbRead;

    if (FAILED(hr = pStg->OpenStream(pwszStm, 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm)))
        goto HrError;

    if (0 == (cbValue = CbBobSize(pStm))) goto BadBobFile;

    if (NULL == (pbValue = (BYTE *) PvkAlloc(cbValue))) goto ErrorReturn;

    pStm->Read(pbValue, cbValue, &cbRead);
    if (cbRead != cbValue) goto BadBobFile;

    fResult = TRUE;
    goto CommonReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;
BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    if (pbValue) {
        PvkFree(pbValue);
        pbValue = NULL;
    }
    cbValue = 0;
    fResult = FALSE;
CommonReturn:
    if (pStm)
        pStm->Release();
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
}

// New "Bob" format::
//
// Allocate and read either the Exported Signature or Exchange Private 
// key stream from the storage
static BOOL LoadBobExportedPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"Exported Signature Private Key";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"Exported Exchange Private Key";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

// Old "Bob" format::
//
// Allocate and read either the Signature or Exchange Private
// key streams from the storage
static BOOL LoadBobOldPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"SPvk";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"EPvk";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Key header structures for private key construction
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.
//
//    For more info see Jeff Spellman in the crypto team or look in the
//    source to RsaBase.Dll
//

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;

///////////////////////////////////////////////////////////////////////////////////////
//
//  Take a raw exported unshrowded private key from the registry and turn it
//  into a private key export blob.
//
//  This is based on the PreparePrivateKeyForExport routine from rsabase.dll
//
static BOOL ConstructPrivateKeyExportBlob(
        IN DWORD            dwKeySpec,
        IN BSAFE_PRV_KEY *  pPrvKey,            
        IN DWORD            PrvKeyLen,
        OUT PBYTE           *ppbBlob,
        OUT DWORD           *pcbBlob
        )
{
    BOOL fResult;
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = pPrvKey->bitlen / 16;
    cbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen +
        sizeof(PUBLICKEYSTRUC);

    if (NULL == (pbBlob = (BYTE *) PvkAlloc(cbBlob))) {
        fResult = FALSE;
        cbBlob = 0;
    } else {
        BYTE* pb = pbBlob;
        PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pb;
        pPubKeyStruc->bType         = PRIVATEKEYBLOB;
        pPubKeyStruc->bVersion      = 2;
        pPubKeyStruc->reserved      = 0;
        if (dwKeySpec == AT_KEYEXCHANGE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        else if (dwKeySpec == AT_SIGNATURE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_SIGN;
        else
            pPubKeyStruc->aiKeyAlg = 0;

        pb = pbBlob + sizeof(PUBLICKEYSTRUC);

        // take most of the header info
        pExportKey = (PEXPORT_PRV_KEY)pb;
        pExportKey->magic  = pPrvKey->magic;
        pExportKey->bitlen = pPrvKey->bitlen;
        pExportKey->pubexp = pPrvKey->pubexp;

        pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
        pbOut = pb + sizeof(EXPORT_PRV_KEY);

        // copy all the private key info
        memcpy(pbOut, pbIn, cbHalfModLen * 2);
        pbIn += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbOut += cbHalfModLen * 2;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen * 2);

        fResult = TRUE;
    }
    *ppbBlob = pbBlob;
    *pcbBlob = cbBlob;
    return fResult;
}

static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    )
{
    BOOL fResult;
    DWORD dwErr = 0;
    HRESULT hr;
    HGLOBAL hGlobal = NULL;
    BYTE *pbBobKey;         // not allocated
    ILockBytes *pLkByt = NULL;
    IStorage *pStg = NULL;
    IStorage *pPrivStg = NULL;
    BYTE *pbPvkValue = NULL;
    DWORD cbPvkValue;
    DWORD dwKeySpec;

    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    if (cbBobKey > MAX_BOB_FILE_LEN) goto BadBobFile;

    if (NULL == (hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
            cbBobKey)))
        goto ErrorReturn;

    if (NULL == (pbBobKey = (BYTE *) GlobalLock(hGlobal)))
        goto ErrorReturn;
    memcpy(pbBobKey, (BYTE *) pHdr, sizeof(FILE_HDR));
    if (cbBobKey > sizeof(FILE_HDR))
        fResult = pfnRead(hRead, pbBobKey + sizeof(FILE_HDR),
            cbBobKey - sizeof(FILE_HDR));
    else
        fResult = TRUE;
    GlobalUnlock(hGlobal);
    if (!fResult) goto ErrorReturn;

    // FALSE => don't DeleteOnRelease
    if (FAILED(hr = CreateILockBytesOnHGlobal(hGlobal, FALSE, &pLkByt)))
        goto HrError;

    if (FAILED(hr = StgOpenStorageOnILockBytes(
            pLkByt,
            NULL,       // pStgPriority
            STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE,
            NULL,    // snbExclude
            0,       // dwReserved
            &pStg
            ))) goto HrError;

    if (FAILED(pStg->OpenStorage(
            L"Plain Private Key",
            0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL,
            0,
            &pPrivStg))) goto BadBobFile;

    if (pdwKeySpec && *pdwKeySpec)
        dwKeySpec = *pdwKeySpec;
    else
        dwKeySpec = AT_SIGNATURE;

    // First, attempt to read the new format where the keys are stored in
    // the private key export format
    fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec, &pbPvkValue,
        &cbPvkValue);
    if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
        dwKeySpec = AT_KEYEXCHANGE;
        fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec,
            &pbPvkValue, &cbPvkValue);
    }
    if (fResult)
        fResult =  PvkPrivateKeyLoadFromMemory(
            hCryptProv,
            pbPvkValue,
            cbPvkValue,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            &dwKeySpec
            );
    else {
        // Try "old" format

        if (pdwKeySpec && *pdwKeySpec)
            dwKeySpec = *pdwKeySpec;
        else
            dwKeySpec = AT_SIGNATURE;

        fResult = LoadBobOldPvk(pPrivStg, dwKeySpec, &pbPvkValue, &cbPvkValue);
        if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
            dwKeySpec = AT_KEYEXCHANGE;
            fResult = LoadBobOldPvk(pPrivStg, dwKeySpec,
                &pbPvkValue, &cbPvkValue);
        }
        if (fResult) {
            BYTE *pbExportPvk;
            DWORD cbExportPvk;
            // Convert Bob's old private key format to the new export private
            // key format
            if ((fResult = ConstructPrivateKeyExportBlob(
                    dwKeySpec,
                    (BSAFE_PRV_KEY *) pbPvkValue,
                    cbPvkValue,
                    &pbExportPvk,
                    &cbExportPvk
                    ))) {
                HCRYPTKEY hKey = 0;
                // Import the private key
                fResult = CryptImportKey(hCryptProv, pbExportPvk, cbExportPvk,
                    0, dwFlags, &hKey);
                if (hKey)
                    CryptDestroyKey(hKey);
                PvkFree(pbExportPvk);
            }
        }
    }
    
    if (fResult) goto CommonReturn;
    goto ErrorReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;

BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    dwKeySpec = 0;
    fResult = FALSE;

    // One of the following Releases may clear it out
    dwErr = GetLastError();
CommonReturn:
    if (pbPvkValue)
        PvkFree(pbPvkValue);
    if (pPrivStg)
        pPrivStg->Release();
    if (pStg)
        pStg->Release();
    if (pLkByt)
        pLkByt->Release();
    if (hGlobal)
        GlobalFree(hGlobal);

    if (pdwKeySpec)
        *pdwKeySpec = dwKeySpec;
    if (dwErr)
        SetLastError(dwErr);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\dllmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dllmain.cpp
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Function:   DllRegisterServer
//
//  Synopsis:   Add registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------

#include "global.hxx"

HINSTANCE hInstance = NULL;

/*extern HRESULT WINAPI SpcASNRegisterServer(LPCWSTR dllName);
extern HRESULT WINAPI SpcASNUnregisterServer();
extern HRESULT WINAPI OidASNRegisterServer(LPCWSTR pszDllName);
extern HRESULT WINAPI OidASNUnregisterServer(void);

extern BOOL AttributeInit(HMODULE hInst); */

STDAPI DllRegisterServer ( void )
{
    HRESULT hr = S_OK;
    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:   Remove registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------

STDAPI DllUnregisterServer ( void )
{
    HRESULT hr = S_OK;
    return hr;
}


BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls((HINSTANCE)hInstDLL);

        hInstance = (HINSTANCE)hInstDLL;
    }

	return(TRUE);
}


HINSTANCE GetInstanceHandle()
{
    return hInstance;
}

/*
#if !DBG
int _cdecl main(int argc, char * argv[])
{
    return 0;
}
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\httptran.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       httptran.cpp
//
//--------------------------------------------------------------------------


#include "global.hxx"

#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>


#define REALLOCSIZE 4096

DWORD CHttpTran::Open(const TCHAR * tszURL, DWORD fOpenT) {

    TCHAR   tszDomanNameDef[_MAX_PATH];
    TCHAR   tszPort[12];
    TCHAR * tszDomanName;
    TCHAR * ptch;
    TCHAR * ptchT;
    DWORD   err;
    DWORD   dwLen;
    INTERNET_PORT dwPort = INTERNET_OPEN_TYPE_PRECONFIG;

    // did we get a flag?
    if(  (fOpenT & (GTREAD | GTWRITE)) == 0 )
        return(ERROR_INVALID_PARAMETER);

    // is it a readonly flag, then do gets
    fOpen = fOpenT;

    assert(tszURL != NULL);

    // we must have http://
    assert(_tcslen(tszURL) > 7);
    assert(_tcsnicmp(tszURL, TEXT("http://"), 7) == 0);

    // make sure we can't overflow tszDomanName
    dwLen = _tcslen((TCHAR *)&tszURL[7]);
    if (dwLen < _MAX_PATH) {
        // it will fit, so use our pre-allocated buffer
        tszDomanName = tszDomanNameDef;
    } else {
        // it might not fit, so reallocate a new buffer.
        tszDomanName = (TCHAR *)malloc(sizeof(TCHAR) * (dwLen + 1));
        if (NULL == tszDomanName)
            return ERROR_OUTOFMEMORY;
    }

    // copy the Doman Name
    ptch = (TCHAR *) &tszURL[7];
    ptchT = tszDomanName;
    while(*ptch != _T('/')  && *ptch != _T(':') &&  *ptch != 0)
        *ptchT++ = *ptch++;
    *ptchT = 0;


    // parse out the port number
    tszPort[0] = 0;
    if(*ptch == _T(':')) {
        ptchT = tszPort;
        while(*ptch != _T('/') && *ptch != 0 &&
              (ptchT - tszPort) < 11 )
            *ptchT++ = *ptch++;
        *ptchT = 0;
    }

    // Note, we don't support port numbers
    if(tszPort[0] != 0) {
        assert(tszPort[0] == ':');
        dwPort = (INTERNET_PORT)atoi(&tszPort[1]);
    }

    // save away what to look up.
    tszPartURL = (TCHAR *) malloc((_tcslen(ptch) + 1) * sizeof(TCHAR));
    if(NULL == tszPartURL) {
        if (tszDomanName != tszDomanNameDef)
            free(tszDomanName);
        return ERROR_OUTOFMEMORY;
    }

    _tcscpy(tszPartURL, ptch);

    //                        INTERNET_OPEN_TYPE_DIRECT,
    if( (hIOpen = InternetOpen( TEXT("Transport"),
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0)) == NULL                 ||

        (hIConnect = InternetConnect(hIOpen,
                                    tszDomanName,
                                    dwPort,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0)) == NULL     ) {
        err = GetLastError();
        if (tszDomanName != tszDomanNameDef)
            free(tszDomanName);
        return(err);
    }

    // we don't need tszDomanName anymore, so free it if it was allocated
    if (tszDomanName != tszDomanNameDef)
        free(tszDomanName);

    // If this is a GET, do a dummy send
    if( fOpen == GTREAD  &&
        ((hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("GET"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL     ||
        HttpSendRequest(hIHttp, TEXT("Accept: */*\r\n"), (DWORD) -1, NULL, 0) == FALSE) ) {
        err = GetLastError();
        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Send(DWORD dwEncodeType, DWORD cbSendBuff, const BYTE * pbSendBuff) {

    TCHAR       tszBuff[1024];
    DWORD       err;
    TCHAR *     tszContentType;


    if( pbRecBuf != NULL || (fOpen & GTWRITE) != GTWRITE)
        return(ERROR_INVALID_PARAMETER);

    switch( dwEncodeType ) {
        case ASN_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-asn");
            break;
        case TLV_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-tlv");
            break;
        case IDL_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-idl");
            break;
        case OCTET_ENCODING:
            tszContentType = TEXT("application/octet-stream");
            break;
        default:
            tszContentType = TEXT("text/*");
            break;
    }

    // say how long the buffer is
    _stprintf(tszBuff, TEXT("Content-Type: %s\r\nContent-Length: %d\r\nAccept: %s\r\n"), tszContentType, cbSendBuff,tszContentType);

    if( (hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("POST"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL ) {
        return(GetLastError());
    }

    // send of the request, this will wait for a response
    if( HttpSendRequest(hIHttp, tszBuff, (DWORD) -1, (LPVOID) pbSendBuff, cbSendBuff) == FALSE ) {

        err = GetLastError();
        // close out the handle
        assert(hIHttp != NULL);
        InternetCloseHandle(hIHttp);
        hIHttp = NULL;

        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Receive(DWORD * pdwEncodeType, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {

    TCHAR       tszBuff[1024];
    DWORD       cbBuff, cbBuffRead, cbBuffT;
    DWORD       err;
    VOID        *pvTemp;


    assert(pcbReceiveBuff != NULL && ppbReceiveBuff != NULL);
    *ppbReceiveBuff = NULL;
    *pcbReceiveBuff = 0;

    if( pbRecBuf != NULL  || (fOpen & GTREAD) != GTREAD || hIHttp == NULL)
        return(ERROR_INVALID_PARAMETER);

    // get the content type
    if( pdwEncodeType != NULL) {

        cbBuff = sizeof(tszBuff);
        if(HttpQueryInfo(   hIHttp,
                            HTTP_QUERY_CONTENT_TYPE,
                            tszBuff,
                            &cbBuff,
                            NULL) == FALSE)
            return(GetLastError());

        assert(cbBuff > 0);

        // for now assert we have a content type of TLV_ENCODING
        if(!_tcscmp(TEXT("application/x-octet-stream-asn"), tszBuff))
            *pdwEncodeType = ASN_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-idl"), tszBuff))
            *pdwEncodeType = IDL_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-tlv"), tszBuff))
            *pdwEncodeType = TLV_ENCODING;
        else if(!_tcscmp(TEXT("application/octet-stream"), tszBuff))
            *pdwEncodeType = OCTET_ENCODING;
        else
            *pdwEncodeType = ASCII_ENCODING;

    }

    // allocate a buffer
    cbBuff = REALLOCSIZE;
    if( (pbRecBuf = (PBYTE) malloc(cbBuff)) == NULL )
    return(ERROR_NOT_ENOUGH_MEMORY);

    // read the data
    cbBuffRead = 0;
    cbBuffT = 1;
    while(cbBuffT != 0) {
    cbBuffT = 0;

    if((cbBuff - cbBuffRead) == 0) {
        cbBuff += REALLOCSIZE;
        pvTemp = realloc(pbRecBuf, cbBuff);
        if( pvTemp == NULL ) {
            free(pbRecBuf);
            pbRecBuf = NULL;
            InternetCloseHandle(hIHttp);
            return(ERROR_NOT_ENOUGH_MEMORY);
        } else {
            pbRecBuf = (PBYTE) pvTemp;
        }
    }

        if(InternetReadFile(hIHttp, &pbRecBuf[cbBuffRead], (cbBuff - cbBuffRead), &cbBuffT)  == FALSE  ) {
            err = GetLastError();
            free(pbRecBuf);
            pbRecBuf = NULL;
            InternetCloseHandle(hIHttp);
            return(err);
        }
        cbBuffRead += cbBuffT;
    }

    // pass back the info
    *ppbReceiveBuff = pbRecBuf;
    *pcbReceiveBuff = cbBuffRead;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Free(BYTE * pb) {
    assert(pb == pbRecBuf);
    free(pbRecBuf);
    pbRecBuf = NULL;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Close(void) {

    // free any buffers
    if(pbRecBuf != NULL) {
        free(pbRecBuf);
        pbRecBuf = NULL;
    }

    if(tszPartURL != NULL) {
        free(tszPartURL);
        tszPartURL = NULL;
    }

    if(hIHttp != NULL) {
        InternetCloseHandle(hIHttp);
        hIHttp = NULL;
    }

    if(hIConnect != NULL) {
        InternetCloseHandle(hIConnect);
        hIConnect = NULL;
    }

    if(hIOpen != NULL) {
        InternetCloseHandle(hIOpen);
        hIOpen = NULL;
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\cert2spc\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for cert2spc.cpp.  
//
//
//  History:    01-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------

//defintion for string IDS
 
#define IDS_ENDOF_LINE				6001
#define IDS_SYNTAX					6002
#define IDS_CRL_EXTENSION			6003
#define IDS_CAN_NOT_OPEN_FILE		6004
#define IDS_OUT_OF_MEMORY			6005 
#define IDS_FILE_EMPTY				6006
#define IDS_CAN_NOT_READ_FILE		6007
#define IDS_CAN_NOT_WRITE_FILE		6008
#define IDS_CAN_NOT_OPEN_STORE		6009
#define IDS_CAN_NOT_LOAD_CRL		6010
#define IDS_CAN_NOT_LOAD			6011
#define IDS_ERROR_OUTPUT			6012
#define IDS_FAILED					6013
#define IDS_SUCCEEDED				6014
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\timereq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       timereq.cpp
//
//  Contents:   Digital Timestamping APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------

#include "global.hxx"
#include <stdio.h>

static char szCrypt32[]="crypt32.dll";
//The version for crtyp32.dll which shipped with NT sp3: "4.0.1381.4"
static DWORD	dwLowVersion=0x05650004;
static DWORD	dwHighVersion=0x00040000;

HRESULT WINAPI 
GetSignedMessageSignerInfoSubj(IN  DWORD dwEncodingType,
                           IN  HCRYPTPROV hCryptProv,
                           IN  LPSIP_SUBJECTINFO pSipInfo,  
						   IN  DWORD*     pdwIndex,
                           IN  OUT PBYTE* ppbSignerInfo,    
                           IN  OUT DWORD* pcbSignerInfo)
{
    HRESULT hr = S_OK;
    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions
    DWORD cbSignedMsg = 0;
    PBYTE pbSignedMsg = 0;
    DWORD dwCertEncoding = 0;
    DWORD dwMsgType = 0;
    HCRYPTMSG hMsg = NULL;
    DWORD   cbSignerInfo=0;
    BYTE    *pbSignerInfo=NULL;

    PKITRY {

        if(!pcbSignerInfo || !ppbSignerInfo)
            PKITHROW(E_INVALIDARG);

        //init
        *pcbSignerInfo=0;
        *ppbSignerInfo=NULL;


       // Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,               // Reserved
                         &sSip))          // Table of functions
            PKITHROW(SignError());
            
        sSip.pfGet(pSipInfo, 
                   &dwCertEncoding,
                   *pdwIndex, 
                   &cbSignedMsg,
                   NULL);
        if(cbSignedMsg == 0) PKITHROW(SignError());
        
        pbSignedMsg = (PBYTE) malloc(cbSignedMsg);
        if (!pbSignedMsg) PKITHROW(E_OUTOFMEMORY);
        
        if(!sSip.pfGet(pSipInfo, 
                       &dwCertEncoding,
                       *pdwIndex, 
                       &cbSignedMsg,
                       pbSignedMsg))
            PKITHROW(SignError()); // Real error.
       if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
       {
        if(dwCertEncoding != dwEncodingType) 
            PKITHROW(TRUST_E_NOSIGNATURE); 
       }
        
        if ((GET_CMSG_ENCODING_TYPE(dwEncodingType) & PKCS_7_ASN_ENCODING) &&
                SignNoContentWrap(pbSignedMsg, cbSignedMsg))
                dwMsgType = CMSG_SIGNED;
            
        // Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbSignedMsg,
                            cbSignedMsg,
                            TRUE))                    // fFinal
            PKITHROW(SignError());

        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCODED_SIGNER,
                             0, // First signer
                             NULL,
                             &cbSignerInfo))
             PKITHROW(SignError());

        pbSignerInfo=(PBYTE)malloc(cbSignerInfo);
        if(!pbSignerInfo)
            PKITHROW(E_OUTOFMEMORY);

        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCODED_SIGNER,
                             0, // First signer
                             pbSignerInfo,
                             &cbSignerInfo))
             PKITHROW(SignError());

        //copy to the out put
        *ppbSignerInfo=pbSignerInfo;
        *pcbSignerInfo=cbSignerInfo;

        hr=S_OK;

        
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (hMsg) 
        CryptMsgClose(hMsg);
    if(pbSignedMsg)
        free(pbSignedMsg);
    if( (hr!=S_OK) && (pbSignerInfo))
        free(pbSignerInfo);
    return hr;
}



HRESULT WINAPI 
GetSignedMessageSignerInfo(IN  HCRYPTPROV				hCryptProv,
						   IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,	
						   IN  LPVOID					pSipInfo,
						   IN  OUT PBYTE*				ppbSignerInfo,    
                           IN  OUT DWORD*				pcbSignerInfo)
{
    HRESULT    hr = S_OK;
    HANDLE     hFile = NULL;
	BOOL	   fFileOpen=FALSE;

    GUID			gSubjectGuid; // The subject guid used to load the sip
	MS_ADDINFO_BLOB	sBlob;
    SIP_SUBJECTINFO sSubjInfo; ZERO(sSubjInfo);
    
    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.

    PKITRY {
        if(!pcbSignerInfo || !ppbSignerInfo)
            PKITHROW(E_INVALIDARG);
        
        sSubjInfo.dwEncodingType = dwEncodingType;
        sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
        sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
		sSubjInfo.hProv=hCryptProv;
        
		//set up file information
		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			// Open up the file
			if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
				(pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
			{
				if(S_OK != (hr = SignOpenFile(
							pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
					PKITHROW(hr);

				fFileOpen=TRUE;
			}
			else
				hFile=pSubjectInfo->pSignerFileInfo->hFile;

			// Get the subject type.
            if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
					PKITHROW(hr);


			sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
			sSubjInfo.hFile = hFile;
			sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
		}
		else
		{
			memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

			sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
			sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
			sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
			sSubjInfo.psBlob=&sBlob;

			sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
			sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
			sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
		}


        hr = GetSignedMessageSignerInfoSubj(
										dwEncodingType,
                                        hCryptProv,
                                        &sSubjInfo,
										pSubjectInfo->pdwIndex,
                                        ppbSignerInfo,
                                        pcbSignerInfo);

    if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
    {
        fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
    }

        if(hr != S_OK) PKITHROW(hr);
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;
    if(hFile && (fFileOpen==TRUE)) CloseHandle(hFile);
    return hr;
}

HRESULT WINAPI
SignerAddTimeStampResponse(
			IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
             IN PBYTE					pbTimeStampResponse,
             IN DWORD					cbTimeStampResponse,
			 IN LPVOID					pSipData)
{
    return SignerAddTimeStampResponseEx(
            0,
            pSubjectInfo,		
            pbTimeStampResponse, 
            cbTimeStampResponse, 
            pSipData,
            NULL);            
}



HRESULT WINAPI
SignerAddTimeStampResponseEx(
             IN  DWORD                  dwFlags,                //Reserved: Has to be set to 0.
			 IN  SIGNER_SUBJECT_INFO    *pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
             IN PBYTE					pbTimeStampResponse,
             IN DWORD					cbTimeStampResponse,
			 IN LPVOID					pSipData,
             OUT SIGNER_CONTEXT         **ppSignerContext      
             )
{
    HRESULT    hr = S_OK;
    HANDLE     hFile = NULL;
	BOOL	   fFileOpen=FALSE;


    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;


    GUID			gSubjectGuid; // The subject guid used to load the sip
    SIP_SUBJECTINFO sSubjInfo; ZERO(sSubjInfo);
	MS_ADDINFO_BLOB	sBlob;
    HCRYPTPROV		hCryptProv = NULL;

	DWORD	        cbSignerInfo=0;
	BYTE        	*pbSignerInfo=NULL;

    PBYTE           pbEncodedMessage=NULL;			
    DWORD           cbEncodedMessage=0;			


    PKITRY {

        //init
       if(ppSignerContext)
           *ppSignerContext=NULL;

	   if(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo))
            PKITHROW(E_INVALIDARG);

        // Use the default provider
        if(!CryptAcquireContext(&hCryptProv,
                                NULL,
                                MS_DEF_PROV,
                                PROV_RSA_FULL,
                                CRYPT_VERIFYCONTEXT))
            PKITHROW(SignError());
        

		//retrieve the enccoded signer info
		hr = GetSignedMessageSignerInfo(hCryptProv,
										pSubjectInfo,
										pSipData,
                                        &pbSignerInfo,
                                        &cbSignerInfo);

		if(hr != S_OK) PKITHROW(hr);


        
        sSubjInfo.hProv = hCryptProv;
        sSubjInfo.DigestAlgorithm.pszObjId = NULL;
        sSubjInfo.dwEncodingType = dwEncodingType;
        
        sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
		sSubjInfo.pClientData = pSipData;

		//set up file information
		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			// Open up the file
			if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
				(pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
			{
				if(S_OK != (hr = SignOpenFile(
							pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
					PKITHROW(hr);

				fFileOpen=TRUE;
			}
			else
				hFile=pSubjectInfo->pSignerFileInfo->hFile;

			// Get the subject type.
			if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
					PKITHROW(hr);


			sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
			sSubjInfo.hFile = hFile;
			sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
		}
		else
		{
			memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

			sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
			sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
			sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
			sSubjInfo.psBlob=&sBlob;

			sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
			sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
			sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
		}

        
        hr = AddTimeStampSubj(dwEncodingType,
                              hCryptProv,
                              &sSubjInfo,
							  pSubjectInfo->pdwIndex,
                              pbTimeStampResponse,
                              cbTimeStampResponse,
							  pbSignerInfo,
							  cbSignerInfo,
                              &pbEncodedMessage,
                              &cbEncodedMessage);

        if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
        {
            fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
        }

        if(hr != S_OK) PKITHROW(hr);
        
        //set up the signer context
        if(ppSignerContext)
        {
            //set up the context information
            *ppSignerContext=(SIGNER_CONTEXT *)malloc(sizeof(SIGNER_CONTEXT));

            if(NULL==(*ppSignerContext))
            {
                hr=E_OUTOFMEMORY;
                PKITHROW(hr);
            }

            (*ppSignerContext)->cbSize=sizeof(SIGNER_CONTEXT);
            (*ppSignerContext)->cbBlob=cbEncodedMessage;
            (*ppSignerContext)->pbBlob=pbEncodedMessage;
            pbEncodedMessage=NULL;
        }

        hr=S_OK;

    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;
    if(hFile && (fFileOpen==TRUE)) CloseHandle(hFile);
    if(hCryptProv) CryptReleaseContext(hCryptProv, 0); 
	if(pbSignerInfo) free(pbSignerInfo);
    if(pbEncodedMessage) 
        free(pbEncodedMessage);
        
    return hr;
}


HRESULT WINAPI
AddTimeStampSubj(IN DWORD dwEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN LPSIP_SUBJECTINFO pSipInfo,
				 IN DWORD *pdwIndex,
                 IN PBYTE pbTimeStampResponse,
                 IN DWORD cbTimeStampResponse,
				 IN PBYTE pbEncodedSignerInfo,
				 IN DWORD cbEncodedSignerInfo,
                 OUT PBYTE* ppbMessage,				
                 OUT DWORD* pcbMessage			
)
{
    HRESULT hr = S_OK;
    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions

    DWORD cbSignedMsg = 0;
    PBYTE pbSignedMsg = 0;
    DWORD dwCertEncoding = 0;
    DWORD dwMsgType = 0;
    HCRYPTMSG hMsg = NULL;
    PBYTE pbEncodedSigner = NULL;
    DWORD cbEncodedSigner = 0;
    PBYTE pbEncodedSignMsg = NULL; // Encoding for the statement attribute
    DWORD cbEncodedSignMsg  = 0;    //    :

    PBYTE pbCounterSign = NULL;
    DWORD cbCounterSign = 0;

	CERT_INFO	*pbCertInfo = NULL;
	DWORD		cbCertInfo = 0;

    HCERTSTORE hTmpCertStore=NULL;
    PCCERT_CONTEXT pCert = NULL;
    PCCRL_CONTEXT pCrl = NULL;

    PCRYPT_ATTRIBUTES pbUnauth = NULL;
    DWORD             cbUnauth = 0;
	DWORD			  dwFileVersionSize=0;
	DWORD			  dwFile=0;
	BYTE			  *pVersionInfo=NULL;
	VS_FIXEDFILEINFO  *pFixedFileInfo=NULL;
	UINT			  unitFixedFileInfo=0; 	

    
    PKITRY {
        
		// Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbTimeStampResponse,
                            cbTimeStampResponse,
                            TRUE))                    // fFinal
            PKITHROW(SignError());

		//get the encoded signer BLOB
        CryptMsgGetParam(hMsg,
                         CMSG_ENCODED_SIGNER,
                         0,
                         NULL,               
                         &cbEncodedSigner);
        if (cbEncodedSigner == 0) PKITHROW(S_FALSE); // no attributes
        
        pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner);
        if(!pbEncodedSigner) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptMsgGetParam(hMsg,
                              CMSG_ENCODED_SIGNER,
                              0,
                              pbEncodedSigner,
                              &cbEncodedSigner))
            PKITHROW(SignError());

		//get the timestamp signer's cert info
        if(!CryptMsgGetParam(hMsg,
                         CMSG_SIGNER_CERT_INFO_PARAM,
                         0,
                         NULL,               
                         &cbCertInfo))
			PKITHROW(SignError());

        if (cbCertInfo == 0) PKITHROW(SignError()); 
        
        pbCertInfo = (CERT_INFO *) malloc(cbCertInfo);
        if(!pbCertInfo) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptMsgGetParam(hMsg,
                              CMSG_SIGNER_CERT_INFO_PARAM,
                              0,
                              pbCertInfo,
                              &cbCertInfo))
            PKITHROW(SignError());


		// get the cert store from the timestamp response
		hTmpCertStore = CertOpenStore(CERT_STORE_PROV_MSG,
                                      dwEncodingType,
                                      hCryptProv,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      hMsg);

		if (hTmpCertStore == NULL) PKITHROW(SignError()); 

		//find the timestamper's certificate
		pCert = CertGetSubjectCertificateFromStore(
					hTmpCertStore,
					X509_ASN_ENCODING,
					pbCertInfo);

		if(NULL == pCert)
		{
			hr=HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			PKITHROW(hr);
		}	

		//make sure the timestamper's certiricate is either from verisign, 
		// or has the correct key usage
	/*	if(!ValidTimestampCert(pCert))
		{
			hr=TRUST_E_TIME_STAMP;
			PKITHROW(hr);
		}  	   */


		//Compare hashed signature of the orinigal signed message
		//with the authenticated attribute from the timestamp respoonse.
		//they have to match
		if(pbEncodedSignerInfo!=NULL && cbEncodedSignerInfo!=0)
		{			
			//verify the signature of the timestamp
			if(0==CryptMsgControl(hMsg,0,CMSG_CTRL_VERIFY_SIGNATURE,
				 pCert->pCertInfo))
			{
				hr=HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				PKITHROW(hr);
			}

			//verify the signatures
			if(!CryptMsgVerifyCountersignatureEncoded(
				hCryptProv,
				dwEncodingType,
				pbEncodedSignerInfo,
				cbEncodedSignerInfo,
				pbEncodedSigner,
				cbEncodedSigner,
				pCert->pCertInfo))
			{
				hr=HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				PKITHROW(hr);
			}	
		
		}//end of the counter signature verificate
		
		//release the cert context
		if(pCert)
		{
			CertFreeCertificateContext(pCert);
			pCert=NULL;
		}

		//close the certstore
		if(hTmpCertStore)
		{
			CertCloseStore(hTmpCertStore, 0);
			hTmpCertStore=NULL;
		}

        // get the cert store from the file
        hTmpCertStore = CertOpenStore(CERT_STORE_PROV_MSG,
                                      dwEncodingType,
                                      hCryptProv,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      hMsg);
        if (hTmpCertStore == NULL) PKITHROW(SignError());
            
        CryptMsgClose(hMsg);
		hMsg = NULL;
        
        // Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,							// Reserved
                         &sSip))					// Table of functions
            PKITHROW(SignError());

        sSip.pfGet(pSipInfo, 
                   &dwCertEncoding,
                   *pdwIndex, 
                   &cbSignedMsg,
                   NULL);
        if(cbSignedMsg == 0) PKITHROW(SignError());
        
        pbSignedMsg = (PBYTE) malloc(cbSignedMsg);
        if (!pbSignedMsg) PKITHROW(E_OUTOFMEMORY);
        
        if(!sSip.pfGet(pSipInfo, 
                       &dwCertEncoding,
                       *pdwIndex, 
                       &cbSignedMsg,
                       pbSignedMsg))
            PKITHROW(SignError()); // Real error.

        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
            if(dwCertEncoding != dwEncodingType) 
                PKITHROW(TRUST_E_NOSIGNATURE); 
        }
        
        if ((GET_CMSG_ENCODING_TYPE(dwEncodingType) & PKCS_7_ASN_ENCODING) &&
            SignNoContentWrap(pbSignedMsg, cbSignedMsg))
            dwMsgType = CMSG_SIGNED;
        

        // Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbSignedMsg,
                            cbSignedMsg,
                            TRUE))                    // fFinal
            PKITHROW(SignError());


        // Encode up the signer info from the timestamp response and
        // add it as an unauthenticated attribute.
        CRYPT_ATTRIBUTE sAttr;
        CRYPT_ATTR_BLOB sSig;

        sSig.pbData = pbEncodedSigner;
        sSig.cbData = cbEncodedSigner;
        sAttr.pszObjId = szOID_RSA_counterSign;
        sAttr.cValue = 1;
        sAttr.rgValue = &sSig;

        CryptEncodeObject(dwEncodingType,
                          PKCS_ATTRIBUTE,
                          &sAttr,
                          pbCounterSign,
                          &cbCounterSign);
        if(cbCounterSign == 0) PKITHROW(SignError());
        
        pbCounterSign = (PBYTE) malloc(cbCounterSign);
        if(!pbCounterSign) PKITHROW(E_OUTOFMEMORY);

        if(!CryptEncodeObject(dwEncodingType,
                              PKCS_ATTRIBUTE,
                              &sAttr,
                              pbCounterSign,
                              &cbCounterSign))
            PKITHROW(SignError());
        

        CryptMsgGetParam(hMsg,
                         CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                         0,
                         NULL,
                         &cbUnauth);
        if(cbUnauth) 
		{
            
			//check the version of "crytp32.dll".  If it is more than
			//"4.0.1381.4", we should be able to timestamp a timestamped
			//file



			dwFileVersionSize=GetFileVersionInfoSize(szCrypt32,&dwFile);

			if(!dwFileVersionSize)
				PKITHROW(SignError());

			pVersionInfo=(BYTE *)malloc(dwFileVersionSize);

			if(!pVersionInfo)
				 PKITHROW(SignError());

			if(!GetFileVersionInfo(szCrypt32, NULL,dwFileVersionSize,
				pVersionInfo))
				  PKITHROW(SignError());

			if(!VerQueryValue(pVersionInfo, "\\", (LPVOID *)&pFixedFileInfo,
				&unitFixedFileInfo))
			  PKITHROW(SignError());

			if(pFixedFileInfo->dwFileVersionMS <= dwHighVersion &&
				pFixedFileInfo->dwFileVersionLS <= dwLowVersion)
				PKITHROW(SignError());


			// we delete any existing time stamps since our policy provider
			//only support one timestamp per file
		
			pbUnauth = (PCRYPT_ATTRIBUTES) malloc(cbUnauth);
            if(!pbUnauth) PKITHROW(E_OUTOFMEMORY);
            
            if(!CryptMsgGetParam(hMsg,
                                 CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                                 0,
                                 pbUnauth,
                                 &cbUnauth))
                PKITHROW(SignError());
            
            
            CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA  sAttrDel; ZERO(sAttrDel);
            sAttrDel.cbSize = sizeof(CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA);
			//we always assume there is only one signer
            sAttrDel.dwSignerIndex = 0;
            for(DWORD ii = 0; ii < pbUnauth->cAttr; ii++) 
			{
                if(strcmp(pbUnauth->rgAttr[ii].pszObjId, szOID_RSA_counterSign) == 0) 
				{
                        sAttrDel.dwUnauthAttrIndex = ii;
                        if (!CryptMsgControl(hMsg,
                                             0,
                                             CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR,
                                             &sAttrDel))
                            PKITHROW(SignError());
                }
            }  
        }
            
        CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA  sAttrPara; ZERO(sAttrPara);
        sAttrPara.cbSize = sizeof(CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA);
        sAttrPara.dwSignerIndex = 0;
        sAttrPara.blob.pbData = pbCounterSign;
        sAttrPara.blob.cbData = cbCounterSign;
        if (!CryptMsgControl(hMsg,
                             0,
                             CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR,
                             &sAttrPara))
            PKITHROW(SignError());
        // merge all the certificates from the time stamp response
        DWORD dwFlags = 0;

        while ((pCert = CertEnumCertificatesInStore(hTmpCertStore, pCert))) {
            CRYPT_DATA_BLOB blob;
            blob.pbData = pCert->pbCertEncoded;
            blob.cbData = pCert->cbCertEncoded;
            if (!CryptMsgControl(hMsg,
                                 0,
                                 CMSG_CTRL_ADD_CERT,
                                 &blob))
                PKITHROW(SignError());
        }

        while ((pCrl = CertGetCRLFromStore(hTmpCertStore, NULL, pCrl, &dwFlags))) {
            CRYPT_DATA_BLOB blob;
            blob.pbData = pCrl->pbCrlEncoded;
            blob.cbData = pCrl->cbCrlEncoded;
            if (!CryptMsgControl(hMsg,
                                 0,
                                 CMSG_CTRL_ADD_CRL,
                                 &blob))
                PKITHROW(SignError());
        }

        // Re-encode up the message and away we go.
        CryptMsgGetParam(hMsg,
                         CMSG_ENCODED_MESSAGE,
                         0,                      // dwIndex
                         NULL,                   // pbSignedData
                         &cbEncodedSignMsg);
        if (cbEncodedSignMsg == 0) PKITHROW(SignError());
        
        pbEncodedSignMsg = (PBYTE) malloc(cbEncodedSignMsg);
        if(!pbEncodedSignMsg) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptMsgGetParam(hMsg,
                              CMSG_ENCODED_MESSAGE,
                              0,                      // dwIndex
                              pbEncodedSignMsg,
                              &cbEncodedSignMsg))
            PKITHROW(SignError());
        
        //put the signatures if we are dealing with anything other than the BLOB
        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
            // Purge all the signatures in the subject
            sSip.pfRemove(pSipInfo, *pdwIndex);

            // Store the Signed Message in the sip
            if(!sSip.pfPut(pSipInfo,
                           dwEncodingType,
                           pdwIndex,
                           cbEncodedSignMsg,
                           pbEncodedSignMsg))
                PKITHROW(SignError());
        }


        if(ppbMessage && pcbMessage) 
        {
            *ppbMessage = pbEncodedSignMsg;
            pbEncodedSignMsg = NULL;
            *pcbMessage = cbEncodedSignMsg;
        }

    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if(pbUnauth)
        free(pbUnauth);
    if(pCert)
        CertFreeCertificateContext(pCert);
    if(pCrl)
        CertFreeCRLContext(pCrl);
    if(hTmpCertStore)
        CertCloseStore(hTmpCertStore, 0);
    if(pbCounterSign)
        free(pbCounterSign);
    if(pbEncodedSignMsg)
        free(pbEncodedSignMsg);
    if (hMsg) 
        CryptMsgClose(hMsg);
    if(pbEncodedSigner)
        free(pbEncodedSigner);
    if(pbSignedMsg)
        free(pbSignedMsg);
	if(pVersionInfo)
		free(pVersionInfo);
	if(pbCertInfo)
		free(pbCertInfo);

    return hr;
}            


HRESULT WINAPI 
SignerCreateTimeStampRequest(
					   IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
                       IN  PCRYPT_ATTRIBUTES psRequest,         // Optional, attributes added to Time stamp request 
					   IN  LPVOID	pSipData,
                       OUT PBYTE pbTimeStampRequest,
                       IN OUT DWORD* pcbTimeStampRequest)
{
    HRESULT    hr = S_OK;
	BOOL		fResult=FALSE;

    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.

    PBYTE pbDigest = NULL;
    DWORD cbDigest = 0;

    PKITRY {
        if((!pcbTimeStampRequest) ||(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo)))
            PKITHROW(E_INVALIDARG);

        if(*pcbTimeStampRequest == 0)
            pbTimeStampRequest = NULL;

            
        // Retrieve the digest from the signature on the file.

		hr = GetSignedMessageDigest(pSubjectInfo,
									  pSipData,
                                       &pbDigest,
                                        &cbDigest);

		if(hr != S_OK) PKITHROW(hr);

        hr = TimeStampRequest(dwEncodingType,
                              psRequest,
                              pbDigest,
                              cbDigest,
                              pbTimeStampRequest,
                              pcbTimeStampRequest);
        if(hr != S_OK) PKITHROW(hr);
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if(pbDigest) free(pbDigest);

    return hr;
}    
            

HRESULT WINAPI 
GetSignedMessageDigest(IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
					   IN  LPVOID					pSipData,
                       IN  OUT PBYTE*				ppbDigest,    
                       IN  OUT DWORD*				pcbDigest)
{
    HRESULT    hr = S_OK;
    HANDLE     hFile = NULL; 
	BOOL	   fFileOpen=FALSE;


    GUID				gSubjectGuid; // The subject guid used to load the sip
	MS_ADDINFO_BLOB		sBlob;
    SIP_SUBJECTINFO		sSubjInfo; ZERO(sSubjInfo);
    
    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.

    PKITRY {
        if((!pcbDigest) || (!ppbDigest) || (FALSE==CheckSigncodeSubjectInfo(pSubjectInfo)))
            PKITHROW(E_INVALIDARG);

		*ppbDigest = NULL;

        
        // Set up the sip information (this is based on mssip.h)
        sSubjInfo.dwEncodingType = dwEncodingType;
        
        sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
		sSubjInfo.pClientData = pSipData;


		//set up file information
		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			// Open up the file
			if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
				(pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
			{
				if(S_OK != (hr = SignOpenFile(
							pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
					PKITHROW(hr);

				fFileOpen=TRUE;
			}
			else
				hFile=pSubjectInfo->pSignerFileInfo->hFile;

			// Get the subject type.
			if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
					PKITHROW(hr);


			sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
			sSubjInfo.hFile = hFile;
			sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
		}
		else
		{
			memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

			sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
			sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
			sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
			sSubjInfo.psBlob=&sBlob;

			sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
			sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
			sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
		}

        hr = GetSignedMessageDigestSubj(dwEncodingType,
                                        NULL,
                                        &sSubjInfo,
										pSubjectInfo->pdwIndex,
                                        ppbDigest,
                                        pcbDigest);

        if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
        {
            fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
        }


        if(hr != S_OK) PKITHROW(hr);
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;
    if(hFile && (fFileOpen==TRUE)) CloseHandle(hFile);
    return hr;
}


HRESULT WINAPI 
GetSignedMessageDigestSubj(IN  DWORD dwEncodingType,
                           IN  HCRYPTPROV hCryptProv,
                           IN  LPSIP_SUBJECTINFO pSipInfo,  
						   IN  DWORD	  *pdwIndex,
                           IN  OUT PBYTE* ppbTimeDigest,    
                           IN  OUT DWORD* pcbTimeDigest)
{
    HRESULT hr = S_OK;
    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions
    DWORD cbSignedMsg = 0;
    PBYTE pbSignedMsg = 0;
    DWORD dwCertEncoding = 0;
    DWORD dwMsgType = 0;
    HCRYPTMSG hMsg = NULL;
    BOOL fAcquiredCryptProv = FALSE;
	DWORD	cbTimeDigest=0;
	BYTE	*pbTimeDigest=NULL;

    PKITRY {

        if(!pcbTimeDigest || !ppbTimeDigest)
            PKITHROW(E_INVALIDARG);

		*ppbTimeDigest=NULL;
        *pcbTimeDigest=0;

        if(hCryptProv == NULL) 
		{
            if(!CryptAcquireContext(&hCryptProv,
                                    NULL,
                                    MS_DEF_PROV,
                                    PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT))
                PKITHROW(SignError());
            fAcquiredCryptProv = TRUE;

			//update the subject Info
			if(NULL==(pSipInfo->hProv))
				pSipInfo->hProv=hCryptProv;
        }            

        // Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,               // Reserved
                         &sSip))          // Table of functions
            PKITHROW(SignError());
            
        sSip.pfGet(pSipInfo, 
                   &dwCertEncoding,
                   *pdwIndex, 
                   &cbSignedMsg,
                   NULL);
        if(cbSignedMsg == 0) PKITHROW(SignError());
        
        pbSignedMsg = (PBYTE) malloc(cbSignedMsg);
        if (!pbSignedMsg) PKITHROW(E_OUTOFMEMORY);
        
        if(!sSip.pfGet(pSipInfo, 
                       &dwCertEncoding,
                       *pdwIndex, 
                       &cbSignedMsg,
                       pbSignedMsg))
            PKITHROW(SignError()); // Real error.
        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
             if(dwCertEncoding != dwEncodingType) 
                    PKITHROW(TRUST_E_NOSIGNATURE); 
        }
        
        if ((GET_CMSG_ENCODING_TYPE(dwEncodingType) & PKCS_7_ASN_ENCODING) &&
                SignNoContentWrap(pbSignedMsg, cbSignedMsg))
                dwMsgType = CMSG_SIGNED;
            
        // Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbSignedMsg,
                            cbSignedMsg,
                            TRUE))                    // fFinal
            PKITHROW(SignError());
						                
        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCRYPTED_DIGEST,
                             0, 
                             NULL,
                             &cbTimeDigest))
              PKITHROW(SignError());

        //allocate memory
        pbTimeDigest = (PBYTE)malloc(cbTimeDigest);
        if(!pbTimeDigest)
            PKITHROW(E_OUTOFMEMORY);


        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCRYPTED_DIGEST,
                             0,
                             pbTimeDigest,
                             &cbTimeDigest))
              PKITHROW(SignError());

        //copy the information
        *ppbTimeDigest=pbTimeDigest;
        *pcbTimeDigest=cbTimeDigest;

        hr=S_OK;
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (hMsg) 
        CryptMsgClose(hMsg);
    if(pbSignedMsg)
        free(pbSignedMsg);
    if((hr!=S_OK) && (pbTimeDigest))
        free(pbTimeDigest);
    if(fAcquiredCryptProv)
        CryptReleaseContext(hCryptProv, 0);
    return hr;
}

HRESULT WINAPI 
TimeStampRequest(IN  DWORD dwEncodingType,
                 IN  PCRYPT_ATTRIBUTES psRequest,
                 IN  PBYTE pbDigest,
                 IN  DWORD cbDigest,
                 OUT PBYTE pbTimeRequest,      
                 IN  OUT DWORD* pcbTimeRequest)
{
    HRESULT    hr = S_OK;

    CRYPT_TIME_STAMP_REQUEST_INFO sTimeRequest; ZERO(sTimeRequest);
    PBYTE pbEncodedRequest = NULL;
    DWORD cbEncodedRequest = 0;



    PKITRY {
        if(!pcbTimeRequest) 
            PKITHROW(E_INVALIDARG);
        
        if(*pcbTimeRequest == 0)
            pbTimeRequest = NULL;

        sTimeRequest.pszTimeStampAlgorithm = SPC_TIME_STAMP_REQUEST_OBJID;
        sTimeRequest.pszContentType = szOID_RSA_data;
        sTimeRequest.Content.pbData = pbDigest;
        sTimeRequest.Content.cbData = cbDigest;
        if(psRequest) {
            sTimeRequest.cAttribute = psRequest->cAttr;
            sTimeRequest.rgAttribute = psRequest->rgAttr;
        }
        
        CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                          PKCS_TIME_REQUEST,
                          &sTimeRequest,
                          pbEncodedRequest,
                          &cbEncodedRequest);

        if(cbEncodedRequest == 0) PKITHROW(SignError());

        pbEncodedRequest = (PBYTE) malloc(cbEncodedRequest);
        if(!pbEncodedRequest) PKITHROW(E_OUTOFMEMORY);
        
        if(!CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              PKCS_TIME_REQUEST,
                              &sTimeRequest,
                              pbEncodedRequest,
                              &cbEncodedRequest))
            PKITHROW(SignError());
        
		//return the infomation
		if(*pcbTimeRequest==0)
		{
			*pcbTimeRequest=cbEncodedRequest;
			hr=S_OK;
		}
		else
		{
			if(*pcbTimeRequest < cbEncodedRequest)
			{
				hr=ERROR_MORE_DATA;
				PKITHROW(SignError());
			}
			else
			{
				memcpy(pbTimeRequest, pbEncodedRequest, cbEncodedRequest);
				hr=S_OK;
			}
		}
        
        
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if(pbEncodedRequest)
        free(pbEncodedRequest);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\cert2spc\cert2spc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       Cert2Spc.cpp
//
//  Contents:   Copy certs and/or CRLs to a SPC file.
//
//              A SPC file is an ASN.1 encoded PKCS #7 SignedData message
//              containing certificates and/or CRLs.
//
//              See Usage() for list of options.
//
//
//  Functions:  main
//
//  History:    05-May-96     philh   created
//  History:    08-August-97  xiaohs  input can be a spc, serialized store
//              
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "resource.h"

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include <dbgdef.h>	
#include <unicode.h>	 
#include <wchar.h>

#include "toolutl.h"


//--------------------------------------------------------------------------
//
// Global Data
//
//----------------------------------------------------------------------------

HMODULE		hModule=NULL;

#define		ITEM_CERT				0x00000001
#define		ITEM_CTL				0x00000002
#define		ITEM_CRL				0x00000004


//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;
	
	return TRUE;
}



//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init 
//---------------------------------------------------------------------------
static void Usage(void)
{
	IDSwprintf(hModule, IDS_SYNTAX);
}


BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem);


//---------------------------------------------------------------------------
//	 wmain
//---------------------------------------------------------------------------
extern "C" int __cdecl
wmain(int argc, WCHAR *wargv[])
{
    int			ReturnStatus=-1;
    HCERTSTORE  hStore = NULL;
	HCERTSTORE	hFileStore=NULL;
    HANDLE		hFile = INVALID_HANDLE_VALUE;
    LPWSTR		pwszFilename=NULL;

    BYTE		*pbEncoded = NULL;
    DWORD		cbEncoded =0;


    if (argc < 3)
	{
		Usage();
		return -1;
    }


	if(!InitModule())
		return -1;


	// Open temp store to contain the certs and/or CRLs to be written
    // to the spc file
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwCertEncodingType
            0,                      // hCryptProv,
            0,                      // dwFlags
            NULL                    // pvPara
            ))) 
	{
        IDSwprintf(hModule,IDS_CAN_NOT_OPEN_STORE);
        goto ErrorReturn;
    }

	//If there is any .crt or .crl file left
    while (--argc > 1)
    {	
       
		pwszFilename = *(++wargv);

		if (S_OK != RetrieveBLOBFromFile(pwszFilename, &cbEncoded, &pbEncoded))
		{
			IDSwprintf(hModule, IDS_CAN_NOT_LOAD, pwszFilename);
			goto ErrorReturn;
		}

		//deal with .crl file
        if (!CertAddEncodedCRLToStore(
                        hStore,
                        X509_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded,
                        CERT_STORE_ADD_USE_EXISTING,
                        NULL                // ppCrlContext
                        )) 
		{

			//open a certificate store
			hFileStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
								X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
								NULL,
								0,
								pwszFilename);

			if(!hFileStore)
			{
				IDSwprintf(hModule, IDS_CAN_NOT_LOAD, pwszFilename);
				goto ErrorReturn;
            }

			//copy all the certs and CRLs from hFileStore to hStore
			if(!MoveItem(hFileStore, hStore, ITEM_CERT|ITEM_CRL))
			{
				IDSwprintf(hModule, IDS_CAN_NOT_LOAD, pwszFilename);
				goto ErrorReturn;
			} 

			//close store
			CertCloseStore(hFileStore, 0);
			hFileStore=NULL;
        }
    
		UnmapViewOfFile(pbEncoded);
        pbEncoded = NULL;
		cbEncoded=0;
	
    }

	pwszFilename = *(++wargv);

    hFile = CreateFileU(
            pwszFilename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) 
	{
        IDSwprintf(hModule, IDS_CAN_NOT_OPEN_FILE, pwszFilename);
        goto ErrorReturn;
    }

    if (!CertSaveStore(hStore,
		X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		CERT_STORE_SAVE_AS_PKCS7,
		CERT_STORE_SAVE_TO_FILE,
		(void *)hFile,
		0					//dwFlags
		)) 
	{
        DWORD dwErr = GetLastError();
        IDSwprintf(hModule, IDS_ERROR_OUTPUT, dwErr, dwErr);
        goto ErrorReturn;
    }

    ReturnStatus = 0;
	IDSwprintf(hModule, IDS_SUCCEEDED);
    goto CommonReturn;
            


ErrorReturn:
    ReturnStatus = -1;
	//print out an error msg
	IDSwprintf(hModule, IDS_FAILED);
CommonReturn:
    if (pbEncoded)
        UnmapViewOfFile(pbEncoded);

	if (hFileStore)
		CertCloseStore(hFileStore, 0);

    if (hStore)
        CertCloseStore(hStore, 0);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return ReturnStatus;
}

//-------------------------------------------------------------------------
//
//	Move Certs/CRls/CTLs from the source store to the destination
//
//-------------------------------------------------------------------------
BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem)
{
	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//add the certs
	if(dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
		 {

			if(!CertAddCertificateContextToStore(hDesStore,
												pCertContext,
												CERT_STORE_ADD_REPLACE_EXISTING,
												NULL))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }

	}

	//add the CTLs
	if(dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hSrcStore, pCTLPre))
		 {
			if(!CertAddCTLContextToStore(hDesStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCTLPre=pCTLContext;
		 }
	}

	//add the CRLs
	if(dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hSrcStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {

			if(!CertAddCRLContextToStore(hDesStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCRLPre=pCRLContext;
		 }

	}


	fResult=TRUE;


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\pvkutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pvkutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "pvkhlpr.h"

//+-------------------------------------------------------------------------
//  Get crypto provider to based on either the pvkfile or key container name
//--------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(	IN HWND hwnd,
							IN LPCWSTR pwszCaption,
							IN LPCWSTR pwszCapiProvider,
							IN DWORD   dwProviderType,
							IN LPCWSTR pwszPvkFile,
							IN LPCWSTR pwszKeyContainerName,
							IN DWORD   *pdwKeySpec,
							OUT LPWSTR *ppwszTmpContainer,
							OUT HCRYPTPROV *phCryptProv)
{
	HANDLE	hFile=NULL;
	HRESULT	hr=E_FAIL;
	DWORD	dwRequiredKeySpec=0;

	//Init
	*ppwszTmpContainer=NULL;
	*phCryptProv=NULL;

	//get the provider handle based on the key container name
	if(pwszKeyContainerName)
	{
		if(!CryptAcquireContextU(phCryptProv,
                                 pwszKeyContainerName,
                                 pwszCapiProvider,
                                 dwProviderType,
                                 0))          // dwFlags
			return SignError();

		//try to figure out the key specification
		if((*pdwKeySpec)==0)
			dwRequiredKeySpec=AT_SIGNATURE;
		else
			dwRequiredKeySpec=*pdwKeySpec;

		//make sure *pdwKeySpec is the correct key spec
		HCRYPTKEY hPubKey;
		if (CryptGetUserKey(
            *phCryptProv,
            dwRequiredKeySpec,
            &hPubKey
            )) 
		{
			CryptDestroyKey(hPubKey);
			*pdwKeySpec=dwRequiredKeySpec;
			return S_OK;
		} 
		else 
		{
			//we fail is user required another key spec
			if((*pdwKeySpec)!=0)
			{
				// Doesn't have the specified public key
				hr=SignError();
				CryptReleaseContext(*phCryptProv, 0);
				*phCryptProv=NULL;
				return hr;
			}

			//now we try AT_EXCHANGE key
			dwRequiredKeySpec=AT_KEYEXCHANGE;

			if (CryptGetUserKey(
				*phCryptProv,
				dwRequiredKeySpec,
				&hPubKey
				)) 
			{
				CryptDestroyKey(hPubKey);
				*pdwKeySpec=dwRequiredKeySpec;
				return S_OK;
			}
			else
			{
				// Doesn't have the specified public key
				hr=SignError();
				CryptReleaseContext(*phCryptProv, 0);
				*phCryptProv=NULL;
				return hr;
			}
		}		
	}

	//get the providedr handle based on the pvk file name

     hFile = CreateFileU(pwszPvkFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,                   // lpsa
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);	// hTemplateFile


     if (hFile == INVALID_HANDLE_VALUE) 
		  return SignError();
		 

     if(!PvkPrivateKeyAcquireContext(pwszCapiProvider,
                                            dwProviderType,
                                            hFile,
                                            hwnd,
                                            pwszCaption,
                                            pdwKeySpec,
                                            phCryptProv,
                                            ppwszTmpContainer))
	 {
			*phCryptProv=NULL;
			hr=SignError();
	 }
	 else
		    hr=S_OK;

    CloseHandle(hFile);
    return hr;
}



void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer)
{
    
    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        PvkPrivateKeyReleaseContext(hProv,
                                    pwszCapiProvider,
                                    dwProviderType,
                                    pwszTmpContainer);
    } else {
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\signhlp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signhlp.h
//
//  Contents:   Digital Signing Helper APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------
#ifndef _SIGNHLP_H
#define _SIGNHLP_H


#ifdef __cplusplus
extern "C" {
#endif	 


//--------------------------------------------------------------------------
//
//	Copy all the certs from store name to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStoreName(HCRYPTPROV	hCryptProv, 
					  DWORD			dwCertEncodingType, 
					  HCERTSTORE	hDescStore, 
					  DWORD			dwStoreName,
					  DWORD			dwStoreFlag);


//--------------------------------------------------------------------------
//
//	Copy all the certs from hSrcStore to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStore(HCERTSTORE	hDescStore, 
				  HCERTSTORE	hSrcStore);


//--------------------------------------------------------------------------
//
//	Build up the certificate chain.  Put the whole chain to the store
//
//
//--------------------------------------------------------------------------
HRESULT	BuildCertChain(HCRYPTPROV		hCryptProv, 
					   DWORD			dwCertEncodingType,
					   HCERTSTORE		hStore, 
					   HCERTSTORE		hOptionalStore,
					   PCCERT_CONTEXT	pSigningCert, 
					   DWORD            dwCertPolicy);


//+-------------------------------------------------------------------------
//  Build the spc certificate store from the cert chain
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromStore(HCRYPTPROV              hPvkProv,
                            DWORD                   dwKeySpec,
                            HCRYPTPROV				hCryptProv, 
							DWORD					dwCertEncodingType,				
							SIGNER_CERT_STORE_INFO  *pCertStoreInfo,
							HCERTSTORE				*phSpcStore,
                            PCCERT_CONTEXT          *ppSignCert);

//+-------------------------------------------------------------------------
//  Build the spc certificate store from  a spc file 
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromSpcFile(HCRYPTPROV        hPvkProv,
                              DWORD             dwKeySpec,
                              HCRYPTPROV	    hCryptProv, 
							  DWORD			    dwCertEncodingType,
							  LPCWSTR		    pwszSpcFile, 
							  HCERTSTORE	    *phSpcStore,
                              PCCERT_CONTEXT    *ppSignCert);



//+-------------------------------------------------------------------------
//  Build the spc certificate store from either a spc file or the
//	cert chain
//--------------------------------------------------------------------------
HRESULT	BuildCertStore(HCRYPTPROV        hPvkProv,
                       DWORD            dwKeySpec,    
                       HCRYPTPROV	    hCryptProv,
					   DWORD		    dwCertEncodingType,
					   SIGNER_CERT	    *pSignerCert,
					   HCERTSTORE	    *phSpcStore,
                       PCCERT_CONTEXT   *ppSigningCert);
												   

//-----------------------------------------------------------------------------
//
//  Parse the private key information from a pCertContext's property
//	CERT_PVK_FILE_PROP_ID
//
//----------------------------------------------------------------------------
BOOL	GetProviderInfoFromCert(PCCERT_CONTEXT		pCertContext, 
								CRYPT_KEY_PROV_INFO	*pKeyProvInfo);

//+-------------------------------------------------------------------------
//  Get hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
BOOL WINAPI GetCryptProvFromCert( 
	HWND			hwnd,
    PCCERT_CONTEXT	pCert,
    HCRYPTPROV		*phCryptProv,
    DWORD			*pdwKeySpec,
    BOOL			*pfDidCryptAcquire,
	LPWSTR			*ppwszTmpContainer,
	LPWSTR			*ppwszProviderName,
	DWORD			*pdwProviderType
    );


//This is a subst of GetCryptProvFromCert.  This function does not consider
//the private key file property of the certificate
BOOL WINAPI CryptProvFromCert(
	HWND				hwnd,
    PCCERT_CONTEXT		pCert,
    HCRYPTPROV			*phCryptProv,
    DWORD				*pdwKeySpec,
    BOOL				*pfDidCryptAcquire
    );

//+-------------------------------------------------------------------------
//  Free hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
void WINAPI FreeCryptProvFromCert(BOOL			fAcquired,
						   HCRYPTPROV	hProv,
						   LPWSTR		pwszCapiProvider,
                           DWORD		dwProviderType,
                           LPWSTR		pwszTmpContainer);


//+-----------------------------------------------------------------------
//  Check the input parameters of Signcode.  Make sure they are valid.
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeParam(
				SIGNER_SUBJECT_INFO		*pSubjectInfo,			
				SIGNER_CERT				*pSignerCert,
				SIGNER_SIGNATURE_INFO	*pSignatureInfo,
				SIGNER_PROVIDER_INFO	*pProviderInfo); 

//+-----------------------------------------------------------------------
//  Check the SIGNER_SUBJECT_INFO
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeSubjectInfo(
				PSIGNER_SUBJECT_INFO		pSubjectInfo); 


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI
AddTimeStampSubj(IN DWORD dwEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN LPSIP_SUBJECTINFO pSipInfo,
				 IN DWORD *pdwIndex,
                 IN PBYTE pbTimeStampResponse,
                 IN DWORD cbTimeStampResponse,
				 IN PBYTE pbEncodedSignerInfo,
				 IN DWORD cbEncodedSignerInfo,
                 OUT PBYTE* ppbMessage,				
                 OUT DWORD* pcbMessage);			


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
GetSignedMessageDigest(IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
					   IN  LPVOID					pSipData,
                       IN  OUT PBYTE*				ppbDigest,    
                       IN  OUT DWORD*				pcbDigest);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
GetSignedMessageDigestSubj(IN  DWORD dwEncodingType,
                           IN  HCRYPTPROV hCryptProv,
                           IN  struct SIP_SUBJECTINFO_ *pSipInfo,           // SIP information
						   IN  DWORD*     pdwIndex,
                           IN  OUT PBYTE* ppbTimeDigest,    
                           IN  OUT DWORD* pcbTimeDigest);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
TimeStampRequest(IN  DWORD dwEncodingType,
                 IN  PCRYPT_ATTRIBUTES psRequest,
                 IN  PBYTE pbDigest,
                 IN  DWORD cbDigest,
                 OUT PBYTE pbTimeRequest,      
                 IN  OUT DWORD* pcbTimeRequest);


//+-----------------------------------------------------------------------
//  FileToSubjectType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    TRUST_E_SUBJECT_FORM_UNKNOWN
//       Unknow file type
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SignOpenFile(LPCWSTR  pwszFilename, 
                    HANDLE*  pFileHandle);


//+-----------------------------------------------------------------------
//  SignGetFileType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SignGetFileType(HANDLE hFile,
                        const WCHAR *pwszFile,
                       GUID* pGuid);

//+-----------------------------------------------------------------------
//  SpcGetFileType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------
HRESULT SpcGetFileType(HANDLE hFile,
                       GUID*  pGuid);


//+-----------------------------------------------------------------------
//  SpcOpenFile
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a handle);
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SpcOpenFile(LPCWSTR  pwszFileName, 
                    HANDLE* pFileHandle);


//+-------------------------------------------------------------------------
//  Find the the cert from the hprov
//  Parameter Returns:
//      pReturnCert - context of the cert found (must pass in cert context);
//  Returns:
//      S_OK - everything worked
//      E_OUTOFMEMORY - memory failure
//      E_INVALIDARG - no pReturnCert supplied
//      CRYPT_E_NO_MATCH - could not locate certificate in store
//
     
HRESULT 
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN DWORD hKeySpec,
                  OUT PCCERT_CONTEXT* pReturnCert);


//+-------------------------------------------------------------------------
//If all of the  following three conditions are true, we should not put 
// commercial or individual authenticated attributes into signer info 
//
//1.  the enhanced key usage extension of the signer's certificate has no code signing usage (szOID_PKIX_KP_CODE_SIGNING)
//2. basic constraints extension of the signer's cert is missing, or it is neither commercial nor individual
//3. user did not specify -individual or -commercial in signcode.exe.
//--------------------------------------------------------------------------
BOOL    NeedStatementTypeAttr(IN PCCERT_CONTEXT psSigningContext, 
                              IN BOOL           fCommercial, 
                              IN BOOL           fIndividual);

//+-------------------------------------------------------------------------
//  Returns TRUE if the Signer Cert has a Key Usage Restriction extension and
//  only the commercial key purpose policy object identifier.
//
//  Returns FALSE if it contains both a commercial and individual purpose
//  policy object identifier.
//--------------------------------------------------------------------------
HRESULT CheckCommercial(IN PCCERT_CONTEXT pSignerCert,
							   IN BOOL fCommercial,
							   IN BOOL fIndividual, 
							   OUT BOOL *pfCommercial);


//+-------------------------------------------------------------------------
//  Encode the StatementType authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateStatementType(IN BOOL fCommercial,
                            OUT BYTE **ppbEncoded,
                            IN OUT DWORD *pcbEncoded);

//+-------------------------------------------------------------------------
//  Encode the SpOpusInfo authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateOpusInfo(IN LPCWSTR pwszOpusName,
                       IN LPCWSTR pwszOpusInfo,
                       OUT BYTE **ppbEncoded,
                       IN OUT DWORD *pcbEncoded);


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT SpcLoadSipFlags(GUID* pSubjectGuid,
                        DWORD *dwFlags);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HINSTANCE GetInstanceHandle();

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer);


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(	IN HWND hwnd,
							IN LPCWSTR pwszCaption,
							IN LPCWSTR pwszCapiProvider,
							IN DWORD   dwProviderType,
							IN LPCWSTR pwszPvkFile,
							IN LPCWSTR pwszKeyContainerName,
							IN DWORD   *pdwKeySpec,
							OUT LPWSTR *ppwszTmpContainer,
							OUT HCRYPTPROV *phCryptProv);




//+-----------------------------------------------------------------------
//  Check to see if the certificate is a glue cert
//------------------------------------------------------------------------
HRESULT SignIsGlueCert(IN PCCERT_CONTEXT pCert);

//+-----------------------------------------------------------------------
//  Return hr based on GetLastError().
//------------------------------------------------------------------------
HRESULT WINAPI SignError();

//+-----------------------------------------------------------------------
//  Check if there is TAG in front of a PKCS7 signed message
//------------------------------------------------------------------------
BOOL WINAPI SignNoContentWrap(IN const BYTE *pbDER,
							 IN DWORD cbDER);

//-------------------------------------------------------------------------
//
//	WSZtoSZ:
//		Convert a wchar string to a multi-byte string.
//
//-------------------------------------------------------------------------
HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz);

//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			convert bytes to base64 bstr
//
//-------------------------------------------------------------------------
HRESULT BytesToBase64(BYTE *pb, DWORD cb, CHAR **pszEncode, DWORD *pdwEncode);

//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb);



#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mssign32.rc
//
#define IDC_PASSWORD0                   501
#define IDC_PASSWORD1                   502
#define IDC_KEY                         504
#define IDC_NONE                        505
#define IDD_ENTERKEYPASSWORD            530
#define IDD_CREATEKEYPASSWORD           540
#define IDS_Publisher                   6000
#define IDS_MY                          6001
#define IDS_CA                          6002
#define IDS_SPC                         6003
#define IDS_ROOTSTORE                   6004
#define	IDS_NO_PASSWORD					6005
#define	IDS_PASSWORD_NO_MATCH			6006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\mssign32\signhlp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signhlp.cpp
//
//  Contents:   Digital Signing Helper APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------
#include "global.hxx"

//+-------------------------------------------------------------------------
// Local function for SpcGetCertFromKey
//
//  Signer cert flags. Used to determine the "strength" of the signer cert.
//
//  The following must be ordered as follows. ie, END_ENTITY_FLAG is most
//  important and needs to be the largest number.
//--------------------------------------------------------------------------
#define SIGNER_CERT_NOT_SELF_SIGNED_FLAG    0x00000001
#define SIGNER_CERT_NOT_GLUE_FLAG           0x00000002
#define SIGNER_CERT_NOT_CA_FLAG             0x00000004
#define SIGNER_CERT_END_ENTITY_FLAG         0x00000008
#define SIGNER_CERT_ALL_FLAGS               0x0000000F


//--------------------------------------------------------------------------
//
//	Copy all the certs from store name to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStoreName(HCRYPTPROV	hCryptProv, 
					  DWORD			dwCertEncodingType, 
					  HCERTSTORE	hDescStore, 
					  DWORD			dwStoreName,
					  DWORD			dwStoreFlag)
{
	HCERTSTORE	hTmpStore=NULL;
	HRESULT		hr;
	WCHAR		wszStoreName[40];

	//load the name of the store
	if(0==LoadStringU(hInstance, dwStoreName, wszStoreName, 40))
	{
		hr=SignError();
		goto CLEANUP;
	}


	//open a system cert store
   	if (NULL == (hTmpStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwCertEncodingType,      
            hCryptProv,                  
            dwStoreFlag,                   
            wszStoreName                  
            ))) 
	{
		 hr=SignError();
		 goto CLEANUP;
	}

	hr=MoveStore(hDescStore, hTmpStore);

CLEANUP:
	if(hTmpStore)
		CertCloseStore(hTmpStore,0);

	return hr;

}

//--------------------------------------------------------------------------
//
//	Copy all the certs from hSrcStore to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStore(HCERTSTORE	hDescStore, 
				  HCERTSTORE	hSrcStore)
{
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pPreContext=NULL;
	HRESULT			hr=S_OK;

	while(pCertContext=CertEnumCertificatesInStore(hSrcStore,
							pPreContext))
	{
		if(!(CertAddCertificateContextToStore(hDescStore,
							pCertContext,CERT_STORE_ADD_USE_EXISTING,
							NULL)))
		{
			hr=SignError();
			goto CLEANUP;
		}

		pPreContext=pCertContext;
		pCertContext=NULL;
	}

	hr=S_OK;

CLEANUP:
	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	return hr;
}

//--------------------------------------------------------------------------
//
//	Build up the certificate chain.  Put the whole chain to the store
//
//
//--------------------------------------------------------------------------
HRESULT	BuildCertChain(HCRYPTPROV		hCryptProv, 
					   DWORD			dwCertEncodingType,
					   HCERTSTORE		hStore, 
					   HCERTSTORE		hOptionalStore,
					   PCCERT_CONTEXT	pSigningCert, 
					   DWORD            dwCertPolicy)
{

    DWORD						i=0;
	PCCERT_CHAIN_CONTEXT		pCertChainContext = NULL;
	CERT_CHAIN_PARA				CertChainPara;
	HRESULT						hr=E_FAIL;
    
    //we regard the chain is good unless there are some cryptographic errors.
    //all error code regarding trusted root and CTLs are machine dependent, therefore
    //they are ignored.  We do not consider revocation.  
    DWORD                       dwChainError=CERT_TRUST_IS_NOT_TIME_VALID | 
                                           CERT_TRUST_IS_NOT_SIGNATURE_VALID;

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				HCCE_CURRENT_USER,
				pSigningCert,
				NULL,
                hOptionalStore,
				&CertChainPara,
				0,
				NULL,
				&pCertChainContext))
	{
		hr=SignError();
        goto CLEANUP;
	}
    
	//
	// make sure there is at least 1 simple chain
	//
    if (pCertChainContext->cChain == 0)
    {
        hr=SignError();
        goto CLEANUP;
    }

    // make sure that we have a good chain
    if(dwChainError & (pCertChainContext->rgpChain[0]->TrustStatus.dwErrorStatus))
    {
        hr=CERT_E_CHAINING;
        goto CLEANUP;
    }


	i = 0;

	while (i < pCertChainContext->rgpChain[0]->cElement)
	{
		//
		// if we are supposed to skip the root cert,
		// and we are on the root cert, then continue
		//
	     if(dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT ||
            dwCertPolicy & SIGNER_CERT_POLICY_SPC)
         {
		    if ((pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
            {
                i++;
			    continue;
            }
         }

		 CertAddCertificateContextToStore(
				hStore, 
				pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext, 
				CERT_STORE_ADD_REPLACE_EXISTING, 
				NULL);

		i++;
	}
    
    hr=S_OK;

	
CLEANUP:

	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	return hr;

}

//--------------------------------------------------------------------------
//
//	 Make sure the two certificates are the same
//
//
//--------------------------------------------------------------------------
BOOL    SameCert(PCCERT_CONTEXT pCertOne, PCCERT_CONTEXT    pCertTwo)
{
    if(!pCertOne || !pCertTwo)
        return FALSE;

    if(pCertOne->cbCertEncoded != pCertTwo->cbCertEncoded)
        return FALSE;

    if(0 == memcmp(pCertOne->pbCertEncoded, pCertTwo->pbCertEncoded, pCertTwo->cbCertEncoded))
        return TRUE;

    return FALSE;
}


//The following cert chain building code is obsolete.  The new cert chain
//building API should be used
//--------------------------------------------------------------------------
//
//	Build up the certificate chain.  Put the whole chain to the store
//
//
//--------------------------------------------------------------------------
/*HRESULT	BuildCertChain(HCRYPTPROV		hCryptProv, 
					   DWORD			dwCertEncodingType,
					   HCERTSTORE		hStore, 
					   HCERTSTORE		hOptionalStore,
					   PCCERT_CONTEXT	pSigningCert, 
					   DWORD            dwCertPolicy)
{
	HRESULT			hr=E_FAIL;
	HCERTSTORE		hSpcStore=NULL;
  	PCCERT_CONTEXT	pSubCertContext=NULL;
	PCCERT_CONTEXT	pIssuerCertContext=NULL;
	PCCERT_CONTEXT	pFindCertContext=NULL;
    LPWSTR			rgwszStoreName[4] ={L"MY", L"ROOT", L"CA",L"SPC"};
	DWORD			dwStoreOpenFlag=0;
	HCERTSTORE		rghStore[5]={NULL, NULL, NULL, NULL,NULL};
	DWORD			dwStoreCount=0;
	DWORD			dwStoreIndex=0;
	FILETIME		fileTime;
	DWORD			dwConfidence=0;
	DWORD			dwError=0;
	BYTE			*pbHash=NULL;
    DWORD			cbHash = 0;
	CRYPT_HASH_BLOB Blob;


	//open a spc cert store
	dwStoreCount=sizeof(rgwszStoreName)/sizeof(rgwszStoreName[0]); 
	GetSystemTimeAsFileTime(&fileTime);

	//open the spc store
	if (NULL == (hSpcStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwCertEncodingType,      
            hCryptProv,                  
            CERT_STORE_NO_CRYPT_RELEASE_FLAG|CERT_SYSTEM_STORE_CURRENT_USER,                   
            L"SPC"                  
            ))) 
	{
		 hr=SignError();
		 goto CLEANUP;
	}

	//open SPC, my, CA, root store
	for(dwStoreIndex=0; dwStoreIndex<dwStoreCount; dwStoreIndex++)
	{
		//open the store
	    dwStoreOpenFlag= CERT_STORE_NO_CRYPT_RELEASE_FLAG|CERT_SYSTEM_STORE_CURRENT_USER;


		if (NULL == (rghStore[dwStoreIndex] = CertOpenStore(
				CERT_STORE_PROV_SYSTEM_W,
				dwCertEncodingType,      
				hCryptProv,                  
				dwStoreOpenFlag,
				rgwszStoreName[dwStoreIndex]                  
				))) 
		{
			hr=SignError();
			goto CLEANUP;
		}
	}

	//copy all the certs in hOptionalStore if present
	if(hOptionalStore)
	{
		rghStore[dwStoreCount]=hOptionalStore;
		dwStoreCount++;
	}

	//now, build the chain
	pSubCertContext=CertDuplicateCertificateContext(pSigningCert);

	//loop until break
	while(1==1)
	{
		//find the issuer of the certificate
		if(!(pIssuerCertContext=TrustFindIssuerCertificate(
										   pSubCertContext,
                                           dwCertEncodingType,
                                           dwStoreCount,
                                           rghStore,
                                           &fileTime,
                                           &dwConfidence,
                                           &dwError,
                                           0)))

		{
			 //fail if we can not find one
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}

		//now, make sure the confidence level is hign enough
		if(dwConfidence < (CERT_CONFIDENCE_SIG+CERT_CONFIDENCE_TIME+CERT_CONFIDENCE_TIMENEST))
		{
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}
		
        //check to see if the cert is the root cert
        if(TrustIsCertificateSelfSigned(pIssuerCertContext,
            pIssuerCertContext->dwCertEncodingType,
            0))
        {
            if(dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT)
		        break;
            else
            {
                //add the root and we are done
		        if(!CertAddCertificateContextToStore(hStore,pIssuerCertContext,
								        CERT_STORE_ADD_USE_EXISTING, NULL))
		        {
				        hr=CERT_E_CHAINING;
				        goto CLEANUP;
		        }

                break;
            }
        }
        else
        {
		    //add the certificate context to the store
		    if(!CertAddCertificateContextToStore(hStore,pIssuerCertContext,
								    CERT_STORE_ADD_USE_EXISTING, NULL	))
		    {
				    hr=CERT_E_CHAINING;
				    goto CLEANUP;
		    }
        }



		//check if the certificate is from the spc store
		if(dwCertPolicy & SIGNER_CERT_POLICY_SPC)
		{

			//get the SHA1 hash of the certificate
			if(!CertGetCertificateContextProperty(
				pIssuerCertContext,
				CERT_SHA1_HASH_PROP_ID,
				NULL,
				&cbHash
				))
			{
				hr=SignError();
				goto CLEANUP;
			}

			pbHash=(BYTE *)malloc(cbHash);
			if(!pbHash)
			{
				hr=E_OUTOFMEMORY;
				goto CLEANUP;
			}
 			if(!CertGetCertificateContextProperty(
				pIssuerCertContext,
				CERT_SHA1_HASH_PROP_ID,
				pbHash,
				&cbHash
				))
			{
				hr=SignError();
				goto CLEANUP;
			}


			//find the ceritificate in the store
			Blob.cbData=cbHash;
			Blob.pbData=pbHash;

			pFindCertContext=CertFindCertificateInStore(
								hSpcStore,
								dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);

			//if the certificate is from the SPC store, we are done
			if(pFindCertContext)
				break;
		}

		//free the subject context
		if(pSubCertContext)
			CertFreeCertificateContext(pSubCertContext);

		pSubCertContext=pIssuerCertContext;

		pIssuerCertContext=NULL;

	}

	hr=S_OK;

CLEANUP:
   if(pIssuerCertContext)
	   CertFreeCertificateContext(pIssuerCertContext);

   if(pSubCertContext)
	   CertFreeCertificateContext(pSubCertContext);


   if(pFindCertContext)
	   CertFreeCertificateContext(pFindCertContext);

   //close all of the stores
   for(dwStoreIndex=0; dwStoreIndex < (hOptionalStore ? dwStoreCount-1 : dwStoreCount); 
			dwStoreIndex++)
   {
	  if(rghStore[dwStoreIndex])
		CertCloseStore(rghStore[dwStoreIndex], 0);
   }

   if(hSpcStore)
	   CertCloseStore(hSpcStore,0);

   if(pbHash)
	   free(pbHash);
	
	return hr;
}  */

//+-------------------------------------------------------------------------
//  Build the SPC certificate store from the SPC file and the certificate chain
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromSpcChain(HCRYPTPROV              hPvkProv,
                            DWORD                   dwKeySpec,
                            HCRYPTPROV				hCryptProv, 
							DWORD					dwCertEncodingType,				
                            SIGNER_SPC_CHAIN_INFO   *pSpcChainInfo, 
							HCERTSTORE				*phSpcStore,
                            PCCERT_CONTEXT          *ppSignCert
)
{
	HCERTSTORE		hMemoryStore=NULL;
	HRESULT			hr=S_OK;
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pPreContext=NULL;

	if(!pSpcChainInfo || !phSpcStore || !ppSignCert)
		return E_INVALIDARG;

	//init
	*phSpcStore=NULL;

	//open a memory store
	 if (NULL == (hMemoryStore = CertOpenStore(
                              CERT_STORE_PROV_FILENAME_W,
                              dwCertEncodingType,
                              hCryptProv,
                              CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                              pSpcChainInfo->pwszSpcFile)))
	{
		 hr=SignError();
		 goto CLEANUP;
	}

    //get the signing certificate
    if(S_OK != SpcGetCertFromKey(
							   dwCertEncodingType,
                               hMemoryStore, 
                               hPvkProv,
                               dwKeySpec,
                               ppSignCert))
	{
		hr=CRYPT_E_NO_MATCH;
		goto CLEANUP;
	}


	 //add all the certs in optional certStore
	 if(pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_STORE)
	 {
		if(!(pSpcChainInfo->hCertStore))
		{
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}

		//enumerate all the certs in store and add them
		while(pCertContext=CertEnumCertificatesInStore(pSpcChainInfo->hCertStore,
												pPreContext))
		{
			if(!CertAddCertificateContextToStore(hMemoryStore, pCertContext,
									CERT_STORE_ADD_USE_EXISTING,
									NULL))
			{
				hr=SignError();
				goto CLEANUP;
			}

			pPreContext=pCertContext;
		}

		hr=S_OK;
	 }

	 //see if the certs if self-signed
   /*  if(TrustIsCertificateSelfSigned(*ppSignCert,
         (*ppSignCert)->dwCertEncodingType,
         0))
     {
			//no need to build the certificate chain anymore
			hr=S_OK;
			goto CLEANUP;
	 } */

	 //build up the cert chain as requested
	 if(pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN ||
        pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT ||
        pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_SPC
       )
	 {
		//include everthing in the chain
		hr=BuildCertChain(hCryptProv, dwCertEncodingType,
							hMemoryStore, hMemoryStore,
							*ppSignCert, pSpcChainInfo->dwCertPolicy);
     }


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(hr==S_OK)
	{
		*phSpcStore=hMemoryStore;
	}
	else
	{
		if(hMemoryStore)
			CertCloseStore(hMemoryStore, 0);

        if(*ppSignCert)
        {
            CertFreeCertificateContext(*ppSignCert);
            *ppSignCert=NULL;
        }
	}

	return hr;
}

//+-------------------------------------------------------------------------
//  Build the spc certificate store from cert chain 
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromStore(HCRYPTPROV              hPvkProv,
                            DWORD                   dwKeySpec,
                            HCRYPTPROV				hCryptProv, 
							DWORD					dwCertEncodingType,				
							SIGNER_CERT_STORE_INFO  *pCertStoreInfo,
							HCERTSTORE				*phSpcStore,
                            PCCERT_CONTEXT          *ppSignCert
)
{
	HCERTSTORE		hMemoryStore=NULL;
	HRESULT			hr=S_OK;
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pPreContext=NULL;

	if(!pCertStoreInfo || !phSpcStore || !ppSignCert)
		return E_INVALIDARG;

	//init
	*phSpcStore=NULL;

	//open a memory store
	 if (NULL == (hMemoryStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            dwCertEncodingType,      
            hCryptProv,                  
            CERT_STORE_NO_CRYPT_RELEASE_FLAG,                   
            NULL                  
            ))) 
	{
		 hr=SignError();
		 goto CLEANUP;
	}

	//add the signing cert to the store
	 if(!CertAddCertificateContextToStore(hMemoryStore, 
										pCertStoreInfo->pSigningCert,
										CERT_STORE_ADD_USE_EXISTING	,
										NULL))
	 {
		hr=SignError();
		goto CLEANUP;
	 }


    //get the signing certificate based on the private key
    if(S_OK != SpcGetCertFromKey(
							   dwCertEncodingType,
                               hMemoryStore, 
                               hPvkProv,
                               dwKeySpec,
                               ppSignCert))
	{
		hr=CRYPT_E_NO_MATCH;
		goto CLEANUP;
	}


	 //add all the certs in optional certStore
	 if(pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_STORE)
	 {
		if(!(pCertStoreInfo->hCertStore))
		{
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}

		//enumerate all the certs in store and add them
		while(pCertContext=CertEnumCertificatesInStore(pCertStoreInfo->hCertStore,
												pPreContext))
		{
			if(!CertAddCertificateContextToStore(hMemoryStore, pCertContext,
									CERT_STORE_ADD_USE_EXISTING,
									NULL))
			{
				hr=SignError();
				goto CLEANUP;
			}

			pPreContext=pCertContext;
		}

		hr=S_OK;
	 }

	 //see if the certs if self-signed
    /* if(TrustIsCertificateSelfSigned(pCertStoreInfo->pSigningCert,
         pCertStoreInfo->pSigningCert->dwCertEncodingType,
         0))
     {
			//no need to build the certificate chain anymore
            *ppSignCert=CertDuplicateCertificateContext(pCertStoreInfo->pSigningCert);
			hr=S_OK;
			goto CLEANUP;
	 }*/

	 //build up the cert chain as requested
	 if(pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN ||
        pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT ||
        pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_SPC
       )
	 {
		//include everthing in the chain
		hr=BuildCertChain(hCryptProv, dwCertEncodingType,
							hMemoryStore, NULL,
							pCertStoreInfo->pSigningCert, pCertStoreInfo->dwCertPolicy);
	 }

     if(S_OK != hr)
         goto CLEANUP;
    

    hr=S_OK;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(hr==S_OK)
	{
		*phSpcStore=hMemoryStore;
	}
	else
	{
		if(hMemoryStore)
			CertCloseStore(hMemoryStore, 0);

        if(*ppSignCert)
        {
            CertFreeCertificateContext(*ppSignCert);
            *ppSignCert=NULL;
        }

    }

	return hr;
}

//+-------------------------------------------------------------------------
//  Build the spc certificate store from  a spc file 
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromSpcFile(HCRYPTPROV        hPvkProv,
                              DWORD             dwKeySpec,
                              HCRYPTPROV	    hCryptProv, 
							  DWORD			    dwCertEncodingType,
							  LPCWSTR		    pwszSpcFile, 
							  HCERTSTORE	    *phSpcStore,
                              PCCERT_CONTEXT    *ppSignCert)
{
	
	
	if(!phSpcStore || !pwszSpcFile || !ppSignCert)
		return E_INVALIDARG;

	*phSpcStore=NULL;

	// Open up the spc store
	*phSpcStore= CertOpenStore(CERT_STORE_PROV_FILENAME_W,
                              dwCertEncodingType,
                              hCryptProv,
                              CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                              pwszSpcFile);
	if(!(*phSpcStore))
		return SignError();


    //get the signing certificate
    if(S_OK != SpcGetCertFromKey(dwCertEncodingType,
                               *phSpcStore, 
                               hPvkProv,
                               dwKeySpec,
                               ppSignCert))
    {
        CertCloseStore(*phSpcStore, 0);
        *phSpcStore=NULL;

		return CRYPT_E_NO_MATCH;
    }

    return S_OK;


}

//+-------------------------------------------------------------------------
//  Build the spc certificate store from either a spc file or the
//	cert chain
//--------------------------------------------------------------------------
HRESULT	BuildCertStore(HCRYPTPROV       hPvkProv,
                       DWORD            dwKeySpec,    
                       HCRYPTPROV	    hCryptProv,
					   DWORD		    dwCertEncodingType,
					   SIGNER_CERT	    *pSignerCert,
					   HCERTSTORE	    *phSpcStore,
                       PCCERT_CONTEXT   *ppSigningCert)
{
	HRESULT		hr;

	if(!pSignerCert || !phSpcStore || !ppSigningCert)
		return E_INVALIDARG;

	//init
	*phSpcStore=NULL;

	if(pSignerCert->dwCertChoice==SIGNER_CERT_SPC_FILE)
	{
		hr=BuildStoreFromSpcFile(hPvkProv,
                                dwKeySpec,
                                hCryptProv, 
                                dwCertEncodingType,
							    pSignerCert->pwszSpcFile, 
                                phSpcStore,
                                ppSigningCert);
	}
	else
	{
        if(pSignerCert->dwCertChoice==SIGNER_CERT_STORE)
        {

		    hr=BuildStoreFromStore(hPvkProv,
                                    dwKeySpec,
                                    hCryptProv, 
                                    dwCertEncodingType,
									(pSignerCert->pCertStoreInfo),
                                    phSpcStore,
                                    ppSigningCert);
        }
        else
            hr=BuildStoreFromSpcChain(hPvkProv,
                                      dwKeySpec,
                                      hCryptProv, 
                                      dwCertEncodingType,
                                      (pSignerCert->pSpcChainInfo), 
                                      phSpcStore,
                                      ppSigningCert);
	}

#if (0) //DSIE: Bug 284639, the fix is to also preserve 0x80070002 since we
        //      really don't know what the impact will be for existing apps,
        //      if we preserve all error codes.
	if(hr!=S_OK && hr!=CRYPT_E_NO_MATCH)
		hr=CERT_E_CHAINING;
#else
	if(hr!=S_OK && hr!=CRYPT_E_NO_MATCH && hr!=0x80070002)
		hr=CERT_E_CHAINING;
#endif

	return hr;

}

//-----------------------------------------------------------------------------
//
//  Parse the private key information from a pCertContext's property
//	CERT_PVK_FILE_PROP_ID
//
//----------------------------------------------------------------------------
BOOL	GetProviderInfoFromCert(PCCERT_CONTEXT		pCertContext, 
								CRYPT_KEY_PROV_INFO	*pKeyProvInfo)
{

	BOOL				fResult=FALSE;
	BYTE				*pbData=NULL;
	BYTE				*pbToFree=NULL;
	DWORD				cbData=0;

	//init
	if(!pCertContext || !pKeyProvInfo)
		return FALSE;

	memset(pKeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

	//get the property
	if(!CertGetCertificateContextProperty(pCertContext,
							CERT_PVK_FILE_PROP_ID,
							NULL,
							&cbData))
		return FALSE;

	pbData=(BYTE *)malloc(cbData);

	if(!pbData)
		return FALSE;

	if(!CertGetCertificateContextProperty(pCertContext,
							CERT_PVK_FILE_PROP_ID,
							pbData,
							&cbData))
		goto CLEANUP;

	
	//get the information from the property
	pbToFree=pbData;

	//get the private key information
	cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);

	pKeyProvInfo->pwszContainerName=(LPWSTR)malloc(cbData);

	if(!(pKeyProvInfo->pwszContainerName))
		goto CLEANUP;

	wcscpy(pKeyProvInfo->pwszContainerName,(LPWSTR)pbData);
	
	//get the key spec
	pbData = pbData + cbData;

	cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);

	pKeyProvInfo->dwKeySpec=_wtol((LPWSTR)pbData);

	//get the provider type
	pbData = pbData + cbData;

	cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);

	pKeyProvInfo->dwProvType=_wtol((LPWSTR)pbData);

	//get the provider name
	pbData = pbData + cbData;

	if(*((LPWSTR)pbData)!=L'\0')
	{
		cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);
		pKeyProvInfo->pwszProvName=(LPWSTR)malloc(cbData);

        if(NULL == pKeyProvInfo->pwszProvName)
            goto CLEANUP;

		wcscpy(pKeyProvInfo->pwszProvName, (LPWSTR)pbData);
	}

	fResult=TRUE;

CLEANUP:

	if(pbToFree)
		free(pbToFree);

	if(FALSE==fResult)
	{
		if(pKeyProvInfo->pwszContainerName)
			free( pKeyProvInfo->pwszContainerName);

		if(pKeyProvInfo->pwszProvName)
			free( pKeyProvInfo->pwszProvName);

		//memset the output to 0
		memset(pKeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

	}

	return fResult;
}


//+-------------------------------------------------------------------------
//  Get hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
BOOL WINAPI GetCryptProvFromCert( 
	HWND			hwnd,
    PCCERT_CONTEXT	pCert,
    HCRYPTPROV		*phCryptProv,
    DWORD			*pdwKeySpec,
    BOOL			*pfDidCryptAcquire,
	LPWSTR			*ppwszTmpContainer,
	LPWSTR			*ppwszProviderName,
	DWORD			*pdwProviderType
    )
{
	
	BOOL					fResult=FALSE;
	WCHAR					wszPublisher[45];
	CRYPT_KEY_PROV_INFO		keyProvInfo;
	HRESULT					hr;
	


	memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

	*ppwszTmpContainer=NULL;
	*phCryptProv=NULL;
	*pfDidCryptAcquire=FALSE;
	*ppwszProviderName=NULL;
	*pdwKeySpec=0;

	//first, try to get from the key container
	if(CryptProvFromCert(hwnd, pCert, phCryptProv, 
					pdwKeySpec, pfDidCryptAcquire))
		return TRUE;

	//load from the resource of string L"publisher"
	if(0==LoadStringU(hInstance, IDS_Publisher, wszPublisher, 40))
		goto CLEANUP;


	//Get provider information from the property
	if(!GetProviderInfoFromCert(pCert, &keyProvInfo))
	{
		SetLastError((DWORD) CRYPT_E_NO_KEY_PROPERTY);
		goto CLEANUP;
	}

	//acquire context based on the private key file.  A temporary
	//key container will be created, along with information 
	//about the provider name and provider type, which are needed
	//to destroy the key container
	if(S_OK!=(hr=PvkGetCryptProv(	hwnd,                     
									wszPublisher,           
									keyProvInfo.pwszProvName,      
									keyProvInfo.dwProvType,        
									keyProvInfo.pwszContainerName,           
									NULL,  
									&(keyProvInfo.dwKeySpec),           
									ppwszTmpContainer,    
									phCryptProv)))
	{
		*phCryptProv=NULL;
		*ppwszTmpContainer=NULL;
		SetLastError((DWORD)hr);
		goto CLEANUP;
	}


	//copy the provder name
	if(keyProvInfo.pwszProvName)
	{
		*ppwszProviderName=(LPWSTR)malloc(
			sizeof(WCHAR)*(wcslen(keyProvInfo.pwszProvName)+1));

		if((*ppwszProviderName)==NULL)
		{
			SetLastError(E_OUTOFMEMORY);

			//free the hCrytProv
			PvkPrivateKeyReleaseContext(
									*phCryptProv,
                                    keyProvInfo.pwszProvName,
                                    keyProvInfo.dwProvType,
                                    *ppwszTmpContainer);

			*phCryptProv=NULL;
			*ppwszTmpContainer=NULL;

			goto CLEANUP;
		}

		wcscpy(*ppwszProviderName, keyProvInfo.pwszProvName);
	}

	//copy the provider type
	*pdwProviderType=keyProvInfo.dwProvType; 

	//copy the key spec
	*pdwKeySpec=keyProvInfo.dwKeySpec;
	*pfDidCryptAcquire=TRUE;

	fResult=TRUE;

CLEANUP:

	if(keyProvInfo.pwszProvName)
		free(keyProvInfo.pwszProvName);

	if(keyProvInfo.pwszContainerName)
		free(keyProvInfo.pwszContainerName);

	return fResult;

}

//+-------------------------------------------------------------------------
//  Free hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
void WINAPI FreeCryptProvFromCert(BOOL			fAcquired,
						   HCRYPTPROV	hProv,
						   LPWSTR		pwszCapiProvider,
                           DWORD		dwProviderType,
                           LPWSTR		pwszTmpContainer)
{
    
	if(fAcquired)
	{
		if (pwszTmpContainer) 
		{
			// Delete the temporary container for the private key from
			// the provider
			PvkPrivateKeyReleaseContext(hProv,
                                    pwszCapiProvider,
                                    dwProviderType,
                                    pwszTmpContainer);

			if(pwszCapiProvider)
				free(pwszCapiProvider);
		} 
		else 
		{
			if (hProv)
				CryptReleaseContext(hProv, 0);
		}
	}
}


//+-------------------------------------------------------------------------
//
//This is a subst of GetCryptProvFromCert.  This function does not consider
//the private key file property of the certificate
//+-------------------------------------------------------------------------
BOOL WINAPI CryptProvFromCert(
	HWND				hwnd,
    PCCERT_CONTEXT		pCert,
    HCRYPTPROV			*phCryptProv,
    DWORD				*pdwKeySpec,
    BOOL				*pfDidCryptAcquire
    )
{
    return CryptAcquireCertificatePrivateKey(
            pCert,
            0,   //we do not do the compare.  It will be done later.
            NULL,
            phCryptProv,
            pdwKeySpec,
            pfDidCryptAcquire);


    /*BOOL fResult;
    BOOL fDidCryptAcquire = FALSE;
    CERT_KEY_CONTEXT KeyContext;
    memset(&KeyContext, 0, sizeof(KeyContext));
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbData;
    DWORD dwIdx;


    // Get either the CERT_KEY_CONTEXT_PROP_ID or
    // CERT_KEY_PROV_INFO_PROP_ID, or 
	// CERT_PVK_FILE_PROP_ID for the Cert.
    cbData = sizeof(KeyContext);
    CertGetCertificateContextProperty(
        pCert,
        CERT_KEY_CONTEXT_PROP_ID,
        &KeyContext,
        &cbData
        );

    if (KeyContext.hCryptProv == 0) 
	{
        cbData = 0;
        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbData
            );
        if (cbData == 0) 
		{
            SetLastError((DWORD) CRYPT_E_NO_KEY_PROPERTY);
            goto ErrorReturn;
		}
		else
		{
			pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) malloc(cbData);
			if (pKeyProvInfo == NULL) goto ErrorReturn;
			fResult = CertGetCertificateContextProperty(
				pCert,
				CERT_KEY_PROV_INFO_PROP_ID,
				pKeyProvInfo,
				&cbData
				);
			if (!fResult) goto ErrorReturn;

			if (PROV_RSA_FULL == pKeyProvInfo->dwProvType &&
					(NULL == pKeyProvInfo->pwszProvName ||
						L'\0' == *pKeyProvInfo->pwszProvName))
				fResult = CryptAcquireContextU(
					&KeyContext.hCryptProv,
					pKeyProvInfo->pwszContainerName,
					MS_ENHANCED_PROV_W,
					PROV_RSA_FULL,
					pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID
					);
			else
				fResult = FALSE;
			if (!fResult)
				fResult = CryptAcquireContextU(
					&KeyContext.hCryptProv,
					pKeyProvInfo->pwszContainerName,
					pKeyProvInfo->pwszProvName,
					pKeyProvInfo->dwProvType,
					pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID
					);
			if (!fResult) goto ErrorReturn;
			fDidCryptAcquire = TRUE;
			for (dwIdx = 0; dwIdx < pKeyProvInfo->cProvParam; dwIdx++) 
			{
				PCRYPT_KEY_PROV_PARAM pKeyProvParam = &pKeyProvInfo->rgProvParam[dwIdx];
				fResult = CryptSetProvParam(
					KeyContext.hCryptProv,
					pKeyProvParam->dwParam,
					pKeyProvParam->pbData,
					pKeyProvParam->dwFlags
					);
				if (!fResult) goto ErrorReturn;
			}
			KeyContext.dwKeySpec = pKeyProvInfo->dwKeySpec;
			if (pKeyProvInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID) 
			{
				// Set the certificate's property so we only need to do the
				// acquire once
				KeyContext.cbSize = sizeof(KeyContext);
				fResult = CertSetCertificateContextProperty(
					pCert,
					CERT_KEY_CONTEXT_PROP_ID,
					0,                              // dwFlags
					(void *) &KeyContext
					);
				if (!fResult) goto ErrorReturn;
				fDidCryptAcquire = FALSE;
			}
		}
    } 

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (fDidCryptAcquire) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(KeyContext.hCryptProv, 0);
        SetLastError(dwErr);

        fDidCryptAcquire = FALSE;
    }
    KeyContext.hCryptProv = 0;
    fResult = FALSE;
CommonReturn:
    if (pKeyProvInfo)
        free(pKeyProvInfo);
    *phCryptProv = KeyContext.hCryptProv;
    *pdwKeySpec = KeyContext.dwKeySpec;
    *pfDidCryptAcquire = fDidCryptAcquire;
    return fResult;*/
}

//+-----------------------------------------------------------------------
//  Check the SIGNER_SUBJECT_INFO
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeSubjectInfo(
				PSIGNER_SUBJECT_INFO		pSubjectInfo) 
{
		if(!pSubjectInfo)
			return FALSE;

		//check pSubjectInfo
		if(pSubjectInfo->cbSize < sizeof(SIGNER_SUBJECT_INFO))
			return FALSE;

		if(NULL==(pSubjectInfo->pdwIndex))
			return FALSE;

        //currently, we only allow index of 0
        if(0!= (*(pSubjectInfo->pdwIndex)))
            return FALSE;

		if((pSubjectInfo->dwSubjectChoice!=SIGNER_SUBJECT_FILE)&&
		   (pSubjectInfo->dwSubjectChoice!=SIGNER_SUBJECT_BLOB))
		   return FALSE;

		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			if((pSubjectInfo->pSignerFileInfo)==NULL)
				return FALSE;
			
			//check SIGNER_FILE_INFO
			if(pSubjectInfo->pSignerFileInfo->cbSize < sizeof(SIGNER_FILE_INFO))
				return FALSE;

			if((pSubjectInfo->pSignerFileInfo->pwszFileName)==NULL)
				return FALSE;
		}
		else
		{
			if((pSubjectInfo->pSignerBlobInfo)==NULL)
				return FALSE;

			//check SIGNER_BLOB_INFO
			if(pSubjectInfo->pSignerBlobInfo->cbSize < sizeof(SIGNER_BLOB_INFO))
				return FALSE;

			if(NULL==(pSubjectInfo->pSignerBlobInfo->pGuidSubject))
				return FALSE;

			if(0==(pSubjectInfo->pSignerBlobInfo->cbBlob))
				return FALSE;

			if(NULL==(pSubjectInfo->pSignerBlobInfo->pbBlob))
				return FALSE;
		}

		return TRUE;
}


//+-----------------------------------------------------------------------
//  Check the input parameters of Signcode.  Make sure they are valid.
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeParam(
				PSIGNER_SUBJECT_INFO		pSubjectInfo, 
				PSIGNER_CERT				pSignerCert,
				PSIGNER_SIGNATURE_INFO		pSignatureInfo,
				PSIGNER_PROVIDER_INFO		pProviderInfo) 
{
		//except for pPvkInfo and pProviderInfo, the rest are required.
		if(!pSubjectInfo ||!pSignerCert || !pSignatureInfo)
			return FALSE;

		//check pSubjectInfo
		if(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo))
			return FALSE;

		//check pSignatureInfo
		if(pSignatureInfo->cbSize < sizeof(SIGNER_SIGNATURE_INFO))
			return FALSE;

		//check the attributes in pSignatureInfo
		if(pSignatureInfo->dwAttrChoice == SIGNER_AUTHCODE_ATTR)
		{
			if((pSignatureInfo->pAttrAuthcode)==NULL)
				return FALSE;

			//check pSignatureInfo->pAttrAuthcode
			if(pSignatureInfo->pAttrAuthcode->cbSize < sizeof(SIGNER_ATTR_AUTHCODE))
				return FALSE;
		}
		else
		{
			if(pSignatureInfo->dwAttrChoice !=SIGNER_NO_ATTR)
				return FALSE;
		}


		//check provider info
		if(pProviderInfo)
		{
			if(pProviderInfo->cbSize < sizeof(SIGNER_PROVIDER_INFO))
				return FALSE;

			//dwPvkType has to be valid
			if((pProviderInfo->dwPvkChoice!=PVK_TYPE_FILE_NAME) &&
			   (pProviderInfo->dwPvkChoice!=PVK_TYPE_KEYCONTAINER) )
			   return FALSE;

			if(pProviderInfo->dwPvkChoice==PVK_TYPE_FILE_NAME)
			{
				if(!(pProviderInfo->pwszPvkFileName))
					return FALSE;
			}
			else
			{
				if(!(pProviderInfo->pwszKeyContainer))
					return FALSE;
			}

		}


		//check pSignerCert
		if(pSignerCert->cbSize < sizeof(SIGNER_CERT))
			return FALSE;

		//check the dwCertChoice
		if((pSignerCert->dwCertChoice!= SIGNER_CERT_SPC_FILE) && 
			((pSignerCert->dwCertChoice!= SIGNER_CERT_STORE)) &&
            (pSignerCert->dwCertChoice!= SIGNER_CERT_SPC_CHAIN) 
           )
			return FALSE;

		//check the spc file situation
		if(pSignerCert->dwCertChoice == SIGNER_CERT_SPC_FILE)
		{
		   if(pSignerCert->pwszSpcFile==NULL)
			   return FALSE;
		}

		//check the cert store situation
		if(pSignerCert->dwCertChoice==SIGNER_CERT_STORE)
		{
			//pCertStoreInfo has to be set
			if((pSignerCert->pCertStoreInfo)==NULL)
				return FALSE;

			if((pSignerCert->pCertStoreInfo)->cbSize < sizeof(SIGNER_CERT_STORE_INFO))
				return FALSE;

			//pSigngingCert has to be set
			if((pSignerCert->pCertStoreInfo)->pSigningCert == NULL )
				return FALSE;
		}

		//check the SPC chain situation
		if(pSignerCert->dwCertChoice==SIGNER_CERT_SPC_CHAIN)
		{
			//pCertStoreInfo has to be set
			if((pSignerCert->pSpcChainInfo)==NULL)
				return FALSE;

			if((pSignerCert->pSpcChainInfo)->cbSize != sizeof(SIGNER_SPC_CHAIN_INFO))
				return FALSE;

			//pSigngingCert has to be set
			if((pSignerCert->pSpcChainInfo)->pwszSpcFile == NULL )
				return FALSE;
		}
		//end of the checking
		return TRUE;

}


//-------------------------------------------------------------------------
//
//	GetSubjectTypeFlags:
//		Check the BASIC_CONSTRAINTS extension from the certificate
//		to see if the certificate is a CA or end entity certs
//
//-------------------------------------------------------------------------
static DWORD GetSubjectTypeFlags(IN DWORD dwCertEncodingType,
                                 IN PCCERT_CONTEXT pCert)
{
    HRESULT hr = S_OK;
    DWORD grfSubjectType = 0;
    PCERT_EXTENSION pExt;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo = NULL;
    DWORD cbInfo;
    
    PKITRY {
        if ((pExt = CertFindExtension(szOID_BASIC_CONSTRAINTS,
                                      pCert->pCertInfo->cExtension,
                                      pCert->pCertInfo->rgExtension)) == NULL)
            PKITHROW(CRYPT_E_NO_MATCH);
        
        cbInfo = 0;
        CryptDecodeObject(dwCertEncodingType, 
                     X509_BASIC_CONSTRAINTS,
                     pExt->Value.pbData,
                     pExt->Value.cbData,
                     0,                      // dwFlags
                     NULL,                   // pInfo
                     &cbInfo);
        if (cbInfo == 0) 
            PKITHROW(CRYPT_E_NO_MATCH);
        pInfo = (PCERT_BASIC_CONSTRAINTS_INFO) malloc(cbInfo);
        if(!pInfo)
            PKITHROW(E_OUTOFMEMORY);
        if (!CryptDecodeObject(dwCertEncodingType, 
                               X509_BASIC_CONSTRAINTS,
                               pExt->Value.pbData,
                               pExt->Value.cbData,
                               0,                  // dwFlags
                               pInfo,
                               &cbInfo)) 
            PKITHROW(SignError());
        
        if (pInfo->SubjectType.cbData > 0) {
            BYTE bSubjectType = *pInfo->SubjectType.pbData;
            if (bSubjectType & CERT_END_ENTITY_SUBJECT_FLAG)
                grfSubjectType |= SIGNER_CERT_END_ENTITY_FLAG;
            if (0 == (bSubjectType & CERT_CA_SUBJECT_FLAG))
                grfSubjectType |= SIGNER_CERT_NOT_CA_FLAG;
        }
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (pInfo) free(pInfo);
    return grfSubjectType;
}

//-------------------------------------------------------------------------
//
//	WSZtoSZ:
//		Convert a wchar string to a multi-byte string.
//
//-------------------------------------------------------------------------
HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz)
{

	DWORD	cbSize=0;


	*psz=NULL;

	if(!wsz)
		return S_OK;

	cbSize=WideCharToMultiByte(0,0,wsz,-1,
			NULL,0,0,0);

	if(cbSize==0)
	   	return SignError();


	*psz=(LPSTR)malloc(cbSize);

	if(*psz==NULL)
		return E_OUTOFMEMORY;

	if(WideCharToMultiByte(0,0,wsz,-1,
			*psz,cbSize,0,0))
	{
		return S_OK;
	}
	else
	{
		 free(*psz);
		 return SignError();
	}
}


//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			convert bytes to base64 bstr
//
//-------------------------------------------------------------------------
HRESULT BytesToBase64(BYTE *pb, DWORD cb, CHAR **pszEncode, DWORD *pdwEncode)
{
    DWORD dwErr;
    DWORD cch;
    CHAR  *psz=NULL;

	*pszEncode=NULL;
	*pdwEncode=0;

    if (cb == 0) {
          return S_OK;
    }

    cch = 0;
    if (!CryptBinaryToStringA(
            pb,
            cb,
            CRYPT_STRING_BASE64,
            NULL,
            &cch
            ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (NULL == (psz=(CHAR *)malloc(cch * sizeof(char))))
        return E_OUTOFMEMORY;

    if (!CryptBinaryToStringA(
            pb,
            cb,
            CRYPT_STRING_BASE64,
            psz,
            &cch
            )) {
        free(psz);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *pszEncode=psz;
		*pdwEncode=cch + 1; //plus 1 to include NULL
        return S_OK;
    }
}


//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb)
{
    DWORD dwErr;
    BYTE *pb;
    DWORD cb;

    *ppb = NULL;
    *pcb = 0;

 
    cb = 0;
    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            NULL,
            &cb,
            NULL,
            NULL))
        return HRESULT_FROM_WIN32(GetLastError());
    if (cb == 0)
        return S_OK;

    if (NULL == (pb = (BYTE *) malloc(cb)))
        return E_OUTOFMEMORY;

    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            pb,
            &cb,
            NULL,
            NULL
            )) {
        free(pb);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *ppb = pb;
        *pcb = cb;
        return S_OK;
    }

}




//+-------------------------------------------------------------------------
//  Find the the cert from the hprov
//  Parameter Returns:
//      pReturnCert - context of the cert found (must pass in cert context);
//  Returns:
//      S_OK - everything worked
//      E_OUTOFMEMORY - memory failure
//      E_INVALIDARG - no pReturnCert supplied
//      CRYPT_E_NO_MATCH - could not locate certificate in store
//
//+-------------------------------------------------------------------------     
HRESULT 
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN DWORD dwKeySpec,
                  OUT PCCERT_CONTEXT* pReturnCert)
{
    PCERT_PUBLIC_KEY_INFO psPubKeyInfo = NULL;
    DWORD dwPubKeyInfo;
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pEnumCert = NULL;
    DWORD grfCert = 0;
    HRESULT hr = S_OK;

    PKITRY {
        if(!pReturnCert) PKITHROW(E_INVALIDARG);

        // Get public key to compare certificates with
        dwPubKeyInfo = 0;
        CryptExportPublicKeyInfo(hProv,
                                 dwKeySpec,
                                 dwCertEncodingType,
                                 NULL,               // psPubKeyInfo
                                 &dwPubKeyInfo);
        if (dwPubKeyInfo == 0) 
            PKITHROW(SignError());
        psPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) malloc(dwPubKeyInfo);
        if(!psPubKeyInfo) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptExportPublicKeyInfo(hProv,
                                      dwKeySpec,
                                      dwCertEncodingType,
                                      psPubKeyInfo,
                                      &dwPubKeyInfo)) 
            PKITHROW(SignError());
        
        // Find the "strongest" cert with a matching public key
        while (TRUE) {
            pEnumCert = CertEnumCertificatesInStore(hStore, pEnumCert);
            if (pEnumCert) {
                if (CertComparePublicKeyInfo(pEnumCert->dwCertEncodingType,
                                             &pEnumCert->pCertInfo->SubjectPublicKeyInfo,
                                             psPubKeyInfo)) {
                    
                    // END_ENTITY, NOT_CA
                    DWORD grfEnumCert = GetSubjectTypeFlags(pEnumCert->dwCertEncodingType,
                                                            pEnumCert);
                    if (S_OK != SignIsGlueCert(pEnumCert))
                        grfEnumCert |= SIGNER_CERT_NOT_GLUE_FLAG;
                    if (!CertCompareCertificateName(pEnumCert->dwCertEncodingType,
                                                    &pEnumCert->pCertInfo->Issuer,
                                                    &pEnumCert->pCertInfo->Subject))
                        grfEnumCert |= SIGNER_CERT_NOT_SELF_SIGNED_FLAG;
                    
                    if (grfEnumCert >= grfCert) {
                        // Found a signer cert with a stronger match
                        if (pCert)
                            CertFreeCertificateContext(pCert);
                        grfCert = grfEnumCert;
                        if (grfCert == SIGNER_CERT_ALL_FLAGS) {
                            pCert = pEnumCert;
                            break;
                        } else
                            // Not a perfect match. Check for a better signer cert.
                            pCert = CertDuplicateCertificateContext(pEnumCert);
                    }
                }
            } else
                break;
        }
        if (pCert == NULL) 
            PKITHROW(CRYPT_E_NO_MATCH);
        
        if (!CertSetCertificateContextProperty(pCert,
                                               CERT_KEY_PROV_HANDLE_PROP_ID,
                                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                               (void *) hProv)) 
            PKITHROW(SignError());
    }
    PKICATCH(err) {
        hr = err.pkiError;
        if (pCert) {
            CertFreeCertificateContext(pCert);
            pCert = NULL;
        }
    } PKIEND;
    
    *pReturnCert = pCert;
    if (psPubKeyInfo)
        free(psPubKeyInfo);
    return hr;
}

///-------------------------------------------------------------------------
// Authenticode routines (not necessary for all implementations)


//+-------------------------------------------------------------------------
//If all of the  following three conditions are true, we should not put 
// commercial or individual authenticated attributes into signer info 
//
//1. the enhanced key usage extension of the signer's certificate has no code signing usage (szOID_PKIX_KP_CODE_SIGNING)
//2. basic constraints extension of the signer's cert is missing, or it is neither commercial nor individual
//3. user did not specify -individual or -commercial in signcode.exe.
//--------------------------------------------------------------------------
BOOL    NeedStatementTypeAttr(IN PCCERT_CONTEXT pSignerCert, 
                              IN BOOL           fCommercial, 
                              IN BOOL           fIndividual)
{
    BOOL                    fNeedStatementTypeAttr=FALSE;
    PCERT_EXTENSION         pEKUExt=NULL;
    PCERT_EXTENSION         pRestrictionExt=NULL;
    DWORD                   cPolicyId=0;
    PCERT_POLICY_ID         pPolicyId=NULL;

    BOOL                    fPolicyCommercial = FALSE;
    BOOL                    fPolicyIndividual = FALSE; 
    BOOL                    fCodeSiginigEKU=FALSE;
    
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;
    DWORD                   cbInfo=0;

    PCERT_ENHKEY_USAGE      pEKUInfo=NULL;
    DWORD                   dwIndex=0;


    if(!pSignerCert)
        return FALSE;


    //check for condition # 3
    if(fCommercial || fIndividual)
        return TRUE;

    //now we know user did not specify -individual or -commerical options

    //if the cert has enhanced key usage extension 
    pEKUExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);


    pRestrictionExt = CertFindExtension(szOID_KEY_USAGE_RESTRICTION,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);


    if((!pEKUExt) && (!pRestrictionExt))
        return FALSE;

    if(pEKUExt)
    {
        cbInfo=0;

        if(CryptDecodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          pEKUExt->Value.pbData,
                          pEKUExt->Value.cbData,
                          0,                      // dwFlags
                          NULL,                   // pInfo
                          &cbInfo) && (cbInfo != 0))
        {
            pEKUInfo = (PCERT_ENHKEY_USAGE) malloc(cbInfo);
            if(pEKUInfo)
            {
                if(CryptDecodeObject(X509_ASN_ENCODING,
                                  X509_ENHANCED_KEY_USAGE,
                                  pEKUExt->Value.pbData,
                                  pEKUExt->Value.cbData,
                                  0,                          // dwFlags
                                  pEKUInfo,                   // pInfo
                                  &cbInfo) && (cbInfo != 0))
                {
                    for(dwIndex=0; dwIndex < pEKUInfo->cUsageIdentifier; dwIndex++)
                    {
                        if(0==strcmp(szOID_PKIX_KP_CODE_SIGNING, 
                                pEKUInfo->rgpszUsageIdentifier[dwIndex]))
                                fCodeSiginigEKU=TRUE;


                        if(0==strcmp(SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID, 
                                pEKUInfo->rgpszUsageIdentifier[dwIndex]))
                                fPolicyCommercial=TRUE;


                        if(0==strcmp(SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID, 
                                pEKUInfo->rgpszUsageIdentifier[dwIndex]))
                                fPolicyIndividual=TRUE;


                    }
                }

            }

        }

    }

    if(pRestrictionExt)
    {
        cbInfo = 0;
        if(CryptDecodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE_RESTRICTION,
                          pRestrictionExt->Value.pbData,
                          pRestrictionExt->Value.cbData,
                          0,                      // dwFlags
                          NULL,                   // pInfo
                          &cbInfo) && (cbInfo != 0))
        {
            pInfo = (PCERT_KEY_USAGE_RESTRICTION_INFO) malloc(cbInfo);
            if(pInfo)
            {
                if (CryptDecodeObject(X509_ASN_ENCODING,
                               X509_KEY_USAGE_RESTRICTION,
                               pRestrictionExt->Value.pbData,
                               pRestrictionExt->Value.cbData,
                               0,                  // dwFlags
                               pInfo,
                               &cbInfo)) 
                {
                    if (pInfo->cCertPolicyId) 
		            {
                        cPolicyId = pInfo->cCertPolicyId;
                        pPolicyId = pInfo->rgCertPolicyId;

                        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) 
			            {
                            DWORD cElementId = pPolicyId->cCertPolicyElementId;
                            LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;

                            for ( ; cElementId > 0; cElementId--, ppszElementId++) 
				            {
                                if (strcmp(*ppszElementId,
                                           SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) == 0)
                                {
                                    fPolicyCommercial = TRUE;
                                }

                                if (strcmp(*ppszElementId,
                                           SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID) == 0)
                                    fPolicyIndividual = TRUE;
                            }
                        }
                    }
                }

            }

        }
    }
        

    //free the memory
    if(pInfo)
        free(pInfo);

    if(pEKUInfo)
        free(pEKUInfo);

    //if any of the value is true in the properties,
    //we need to add the statement type attribute
    if( fPolicyCommercial || fPolicyIndividual || fCodeSiginigEKU)
        return TRUE;

    return FALSE;
}


//+-------------------------------------------------------------------------
//  
//	The function decides whether to sign the certificate as a commerical,
// or individual.  The default is the certificate's highest capability.  If fCommercial
// is set and the cert can not signly commercially, an error is returned.
// Same for fIndividual.  
//
//--------------------------------------------------------------------------
HRESULT CheckCommercial(PCCERT_CONTEXT pSignerCert, BOOL fCommercial,
				BOOL fIndividual, BOOL *pfCommercial)
{
    HRESULT                 hr = S_OK;
    BOOL                    fPolicyCommercial = FALSE;
    BOOL                    fPolicyIndividual = FALSE;  
    PCERT_EXTENSION         pExt;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;
    DWORD                   cbInfo;

    PCERT_EXTENSION         pEKUExt=NULL;
    PCERT_ENHKEY_USAGE      pUsage=NULL;
    DWORD                   cCount=0;

	if(!pfCommercial)
		return E_INVALIDARG;

	//init
	*pfCommercial=FALSE;

	//fCommercial and fIndividual can not be set at the same time
	if(fCommercial && fIndividual)
		return E_INVALIDARG;


    PKITRY {

		//first look into the cert extension szOID_KEY_USAGE_RESTRICTION
        pExt = CertFindExtension(szOID_KEY_USAGE_RESTRICTION,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);
        
        if(pExt) 
		{
            
            cbInfo = 0;
            CryptDecodeObject(X509_ASN_ENCODING,
                              X509_KEY_USAGE_RESTRICTION,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,                      // dwFlags
                              NULL,                   // pInfo
                              &cbInfo);
            if (cbInfo == 0)
                PKITHROW(SignError());
            pInfo = (PCERT_KEY_USAGE_RESTRICTION_INFO) malloc(cbInfo);
            if(!pInfo)
                PKITHROW(E_OUTOFMEMORY);
            if (!CryptDecodeObject(X509_ASN_ENCODING,
                                   X509_KEY_USAGE_RESTRICTION,
                                   pExt->Value.pbData,
                                   pExt->Value.cbData,
                                   0,                  // dwFlags
                                   pInfo,
                                   &cbInfo)) 
                PKITHROW(SignError());
            
            if (pInfo->cCertPolicyId) 
			{
                DWORD cPolicyId;
                PCERT_POLICY_ID pPolicyId;
                
                cPolicyId = pInfo->cCertPolicyId;
                pPolicyId = pInfo->rgCertPolicyId;
                for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) 
				{
                    DWORD cElementId = pPolicyId->cCertPolicyElementId;
                    LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;
                    for ( ; cElementId > 0; cElementId--, ppszElementId++) 
					{
                        if (strcmp(*ppszElementId,
                                   SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) == 0)
                        {
                            fPolicyCommercial = TRUE;
                        }
                        if (strcmp(*ppszElementId,
                                   SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID) == 0)
                            fPolicyIndividual = TRUE;
                    }
                }
            } //end of pInfo->cCertPolicyId
        } //end of pExt


		//now 
    }
    PKICATCH(err) 
	{
        hr = err.pkiError;
    } PKIEND;


    if (pInfo)
    {
        free(pInfo);
        pInfo=NULL;
    }

	if(hr!=S_OK)
		return hr;


    //if either of the policy is set, we check for the EKU extension
    if((!fPolicyCommercial) && (!fPolicyIndividual))
    {
        pExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);

        if(pExt)
        {
            cbInfo = 0;

            if(CryptDecodeObject(X509_ASN_ENCODING,
                              X509_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,                     
                              NULL,                   
                              &cbInfo) && (cbInfo != 0))
            {
                pUsage = (PCERT_ENHKEY_USAGE) malloc(cbInfo);

                if(pUsage)
                {
                    if (CryptDecodeObject(X509_ASN_ENCODING,
                                           X509_ENHANCED_KEY_USAGE,
                                           pExt->Value.pbData,
                                           pExt->Value.cbData,
                                           0,                  // dwFlags
                                           pUsage,
                                           &cbInfo))
                    {
                        
                        for(cCount=0; cCount< pUsage->cUsageIdentifier; cCount++)
                        {
                            if (strcmp((pUsage->rgpszUsageIdentifier)[cCount],
                                       SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) == 0)
                            {
                                fPolicyCommercial = TRUE;
                            }

                            if (strcmp((pUsage->rgpszUsageIdentifier)[cCount],
                                       SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID) == 0)
                            {
                                fPolicyIndividual = TRUE;     
                            }
                        }
                    }

                }
            }
        }
    }
	
    if(pUsage)
    {
        free(pUsage);
        pUsage=NULL;
    }

	//if either of the policy is set, we use individual
	if(!fPolicyCommercial && !fPolicyIndividual)
		fPolicyIndividual=TRUE;

	//default
	if((!fCommercial) && (!fIndividual))
	{
		if(fPolicyCommercial)
			*pfCommercial=TRUE;
		else
			*pfCommercial=FALSE;	

		return S_OK;
	}


	if(fCommercial && (!fIndividual))
	{
		if(fPolicyCommercial)
		{
			*pfCommercial=TRUE;
			return S_OK;
		}
		else
			return TYPE_E_TYPEMISMATCH;
	}

	//the following is fIndividual and !fCommercial
	if(fPolicyIndividual)
	{
		*pfCommercial=FALSE;
		return S_OK;
	}
	else
		return TYPE_E_TYPEMISMATCH;
}


//+-------------------------------------------------------------------------
//  Encode the StatementType authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateStatementType(IN BOOL fCommercial,
                            OUT BYTE **ppbEncoded,
                            IN OUT DWORD *pcbEncoded)
{
    HRESULT hr = S_OK;
    PBYTE pbEncoded = NULL;
    DWORD cbEncoded;
    LPSTR pszIndividual = SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID;
    LPSTR pszCommercial = SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID;
    SPC_STATEMENT_TYPE StatementType;

    StatementType.cKeyPurposeId = 1;
    if (fCommercial)
        StatementType.rgpszKeyPurposeId = &pszCommercial;
    else
        StatementType.rgpszKeyPurposeId = &pszIndividual;

    PKITRY {

        cbEncoded = 0;
        CryptEncodeObject(X509_ASN_ENCODING,
                          SPC_STATEMENT_TYPE_STRUCT,
                          &StatementType,
                          NULL,           // pbEncoded
                          &cbEncoded);
        if (cbEncoded == 0)
            PKITHROW(SignError());
        pbEncoded = (BYTE *) malloc(cbEncoded);
        if (pbEncoded == NULL) 
            PKITHROW(E_OUTOFMEMORY);
        if (!CryptEncodeObject(X509_ASN_ENCODING,
                               SPC_STATEMENT_TYPE_STRUCT,
                               &StatementType,
                               pbEncoded,
                               &cbEncoded)) 
            PKITHROW(SignError());
    }
    PKICATCH(err) {
        if (pbEncoded) {
            free(pbEncoded);
            pbEncoded = NULL;
        }
        cbEncoded = 0;
        hr = err.pkiError;
    } PKIEND;

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return hr;
}

//+-------------------------------------------------------------------------
//  Encode the SpOpusInfo authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateOpusInfo(IN LPCWSTR pwszOpusName,
                       IN LPCWSTR pwszOpusInfo,
                       OUT BYTE **ppbEncoded,
                       IN OUT DWORD *pcbEncoded)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    SPC_LINK MoreInfo;
    SPC_SP_OPUS_INFO sSpcOpusInfo;
    
    ZeroMemory(&sSpcOpusInfo, sizeof(SPC_SP_OPUS_INFO));
    sSpcOpusInfo.pwszProgramName = (LPWSTR) pwszOpusName;

    if (pwszOpusInfo) {
        MoreInfo.dwLinkChoice = SPC_URL_LINK_CHOICE;

        //
        // To be backwards compatible with IE 3.0 WinVerifyTrust the
        // following is set to an even length to inhibit the possibility
        // of an 0x7f length in the encoded ASN.
        // In IE 3.0 an 0x81 is erroneously prepended before a
        // 0x7f length when the OPUS info is re-encoded before hashing. Making
        // the length of pwszUrl even precludes this from happening.
        //
        // Note, the pwszUrl is first converted to multibyte before being
        // encoded. Its the multibyte length that must have an even length.

        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(CP_ACP,
                                           0,          // dwFlags
                                           pwszOpusInfo,
                                           -1,         // cchWideChar, -1 => null terminated
                                           NULL,       // lpMultiByteStr
                                           0,          // cchMultiByte
                                           NULL,       // lpDefaultChar
                                           NULL        // lpfUsedDefaultChar
                                           );
        // cchMultiByte includes the null terminator
        if (cchMultiByte > 1 && ((cchMultiByte - 1) & 1)) {
            // Odd length. Add extra space to end.
            int Len = wcslen(pwszOpusInfo);
            MoreInfo.pwszUrl = (LPWSTR) _alloca((Len + 2) * sizeof(WCHAR));
            wcscpy(MoreInfo.pwszUrl, pwszOpusInfo);
            wcscpy(MoreInfo.pwszUrl + Len, L" ");
        } else
            MoreInfo.pwszUrl = (LPWSTR) pwszOpusInfo;
        sSpcOpusInfo.pMoreInfo = &MoreInfo;
    }
    
    PKITRY {
        cbEncoded = 0;
        CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                          SPC_SP_OPUS_INFO_STRUCT,
                          &sSpcOpusInfo,
                          NULL,           // pbEncoded
                          &cbEncoded);
        if (cbEncoded == 0) 
            PKITHROW(SignError());
        
        pbEncoded = (BYTE *) malloc(cbEncoded);
        if (pbEncoded == NULL) 
            PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               SPC_SP_OPUS_INFO_STRUCT,
                               &sSpcOpusInfo,
                               pbEncoded,
                               &cbEncoded)) 
            PKITHROW(SignError());
        
    }
    PKICATCH(err) {
        if (pbEncoded) {
            free(pbEncoded);
            pbEncoded = NULL;
        }
        cbEncoded = 0;
        hr = err.pkiError;
    } PKIEND;

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return hr;
}

//+-------------------------------------------------------------------------
//  Checks if the certificate a glue certificate
//  in IE30
//  Returns: S_OK                   - Is a glue certificate
//           S_FALSE                - Not a certificate
//           CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
//+-------------------------------------------------------------------------
HRESULT SignIsGlueCert(IN PCCERT_CONTEXT pCert)
{
    HRESULT hr = S_OK;
    PCERT_NAME_BLOB pName = &pCert->pCertInfo->Subject;
    PCERT_NAME_INFO pNameInfo = NULL;
    DWORD cbNameInfo;

    PKITRY {
        cbNameInfo = 0;
        CryptDecodeObject(X509_ASN_ENCODING,
                     X509_NAME,
                     pName->pbData,
                     pName->cbData,
                     0,                      // dwFlags
                     NULL,                   // pNameInfo
                     &cbNameInfo);
        
        if (cbNameInfo == 0) 
            PKITHROW(SignError());
        
        pNameInfo = (PCERT_NAME_INFO) malloc(cbNameInfo);
        if(!pNameInfo)
            return E_OUTOFMEMORY;
        
        if (!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          pName->pbData,
                          pName->cbData,
                          0,                  // dwFlags
                          pNameInfo,
                          &cbNameInfo)) 
            PKITHROW(SignError());

        if(!CertFindRDNAttr(SPC_GLUE_RDN_OBJID, pNameInfo) != NULL)
            hr = S_FALSE;
    }
    PKICATCH (err) {
        hr = err.pkiError;
    } PKIEND;

    if (pNameInfo) free(pNameInfo);

    return hr;
}


//+-------------------------------------------------------------------------
//  Skip over the identifier and length octets in an ASN encoded blob.
//  Returns the number of bytes skipped.
//
//  For an invalid identifier or length octet returns 0.
//--------------------------------------------------------------------------
static DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
#define TAG_MASK 0x1f
    DWORD   cb;
    DWORD   cbLength;
    const BYTE   *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
        return 0;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++) {
            if (cb >= cbDER)
                return 0;
        }
    } else
        // low-tag-number form
        cb = 1;

    // need at least one more byte for length
    if (cb >= cbDER)
        return 0;

    if (0x80 == *pb)
        // Indefinite
        cb++;
    else if ((cbLength = *pb) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;
        if (cb > cbDER)
            return 0;
    } else
        cb++;

    return cb;
}

//--------------------------------------------------------------------------
//
//	Skip over the tag and length
//----------------------------------------------------------------------------
BOOL WINAPI SignNoContentWrap(IN const BYTE *pbDER,
              IN DWORD cbDER)
{
    DWORD cb;

    cb = SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if (cb > 0 && cb < cbDER && pbDER[cb] == 0x02)
        return TRUE;
    else
        return FALSE;
}

#define SH1_HASH_LENGTH     20

//+-----------------------------------------------------------------------
//  Make sure that the certificate is valid for timestamp 
//------------------------------------------------------------------------
/*BOOL	ValidTimestampCert(PCCERT_CONTEXT pCertContext)
{
	BOOL				fValid=FALSE;	
    DWORD               cbSize=0;
    PCERT_ENHKEY_USAGE  pCertEKU=NULL;
    BYTE                *pbaSignersThumbPrint=NULL;
	DWORD				dwIndex=0;

    static BYTE         baVerisignTimeStampThumbPrint[SH1_HASH_LENGTH] =
                            { 0x38, 0x73, 0xB6, 0x99, 0xF3, 0x5B, 0x9C, 0xCC, 0x36, 0x62,
                              0xB6, 0x48, 0x3A, 0x96, 0xBD, 0x6E, 0xEC, 0x97, 0xCF, 0xB7 };

    cbSize = 0;

	if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, 
                    NULL, &cbSize)))
		goto CLEANUP;

	pbaSignersThumbPrint=(BYTE *)malloc(cbSize);
	if(!pbaSignersThumbPrint)
		goto CLEANUP;


    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, 
                                        pbaSignersThumbPrint, &cbSize)))
		goto CLEANUP;

    //
    //  1st, check to see if it's Verisign's first timestamp certificate
	if(cbSize!=sizeof(baVerisignTimeStampThumbPrint)/sizeof(baVerisignTimeStampThumbPrint[0]))
		goto CLEANUP;

    if (memcmp(pbaSignersThumbPrint, baVerisignTimeStampThumbPrint, cbSize) == 0)
    {
		fValid=TRUE;
		goto CLEANUP;
    }

    //
    //  see if the certificate has the proper enhanced key usage OID
    //
    cbSize = 0;

    if(!CertGetEnhancedKeyUsage(pCertContext, 
                            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                            NULL,
                            &cbSize) || (cbSize==0))
		goto CLEANUP;

	pCertEKU = (PCERT_ENHKEY_USAGE)malloc(cbSize);
	if(!pCertEKU)
		goto CLEANUP;

    if (!(CertGetEnhancedKeyUsage(pCertContext,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  pCertEKU,
                                  &cbSize)))
		goto CLEANUP;		

    for (dwIndex = 0; dwIndex < pCertEKU->cUsageIdentifier; dwIndex++)
    {
        if (strcmp(pCertEKU->rgpszUsageIdentifier[dwIndex], szOID_KP_TIME_STAMP_SIGNING) == 0)
        {
			fValid=TRUE;
			break;
		}


        if (strcmp(pCertEKU->rgpszUsageIdentifier[dwIndex], szOID_PKIX_KP_TIMESTAMP_SIGNING) == 0)
        {
            fValid=TRUE;
            break;
        }

    }


CLEANUP:

	if(pbaSignersThumbPrint)
		free(pbaSignersThumbPrint);

	if(pCertEKU)
		free(pCertEKU);

	return fValid;
}  */

//-------------------------------------------------------------------------
//
//	Call GetLastError and convert the return code to HRESULT
//--------------------------------------------------------------------------
HRESULT WINAPI SignError ()
{
    DWORD   dw = GetLastError ();
    HRESULT hr;
    if ( dw <= (DWORD) 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;
    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certmgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:      certmgr.h
//
//  Contents:   the header for CertMgr tool 
//
//
//  History:    21-July-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef CERTMGR_H
#define CERTMGR_H


#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <unicode.h>	 
#include <wchar.h>

#include "wincrypt.h"
#include "mssip.h"
#include "wintrust.h"
#include "sipbase.h"
#include "unicode.h"
#include "toolutl.h"
#include "certhlp.h"
#include "resource.h"
#include "cryptui.h"



#endif  // CERTMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\makecert\makecert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       makecert.cpp
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
// MakeCert - x509 certificate generator
//
//            Generates test certificates for Software Publishers. The default
//            root key and certificate is stored as a program resource.
//
// HansHu   2/20/96 created
// Philh    5/17/96 changed to use wincert      
// Xiaohs   5/12/97 localization and change the command line options
//
//--------------------------------------------------------------------------
#define _CRYPT32_
#include "global.hxx"

//+-------------------------------------------------------------------------
//  contants
//--------------------------------------------------------------------------

//allow max 10 extensions per certificate
#define MAX_EXT_CNT 10

//+-------------------------------------------------------------------------
//  Parameters configurable via command line arguments
//--------------------------------------------------------------------------
BOOL     fUseSubjectPvkFile       = FALSE;
BOOL     fUseSubjectKeyContainer  = FALSE;
BOOL     fUseIssuerPvkFile        = FALSE;
BOOL     fSetSubjectName          = FALSE;      //use has specify the -n option

#if (1) //DSIE: Bug 205195
BOOL     fPrivateKeyExportable    = FALSE;
#endif

WCHAR*   wszSubjectKey            = NULL;
WCHAR*   wszSubjectCertFile       = NULL;
WCHAR*   wszSubjectStore          = NULL;
WCHAR*   wszSubjectStoreLocation  = NULL;
DWORD    dwSubjectStoreFlag       = CERT_SYSTEM_STORE_CURRENT_USER;

WCHAR*   wszIssuerKey             = NULL;
WCHAR*   wszIssuerCertFile        = NULL;
WCHAR*   wszIssuerStore           = NULL;
WCHAR*   wszIssuerStoreLocation   = NULL;
DWORD    dwIssuerStoreFlag        = CERT_SYSTEM_STORE_CURRENT_USER;
WCHAR*   wszIssuerCertName        = NULL;
DWORD    dwIssuerKeySpec          = 0;

WCHAR*   wszSubjectX500Name       = NULL;
WCHAR*   wszSubjectRequestFile    = NULL;
WCHAR*   wszPolicyLink            = NULL;
WCHAR*   wszOutputFile            = NULL;
WCHAR*   wszAuthority             = NULL;
WCHAR*   wszAlgorithm             = NULL;
WCHAR*   wszCertType              = NULL;
WCHAR*   wszIssuerKeyType         = NULL;
WCHAR*   wszSubjectKeyType        = NULL;
WCHAR*   wszEKUOids               = NULL;

DWORD   dwKeySpec               = 0;
BOOL    fCertIndividual         = FALSE;
BOOL    fCertCommercial         = FALSE;
BOOL    fSelfSigned             = FALSE;
BOOL    fGlueCert               = FALSE;
BOOL    fNetscapeClientAuth     = FALSE;
BOOL    fNoPubKeyPara           = FALSE;
BOOL    fNoVerifyPublic         = FALSE;
LPWSTR  wszIssuerProviderName   = NULL;
DWORD   dwIssuerProviderType    = PROV_RSA_FULL;
LPWSTR  wszSubjectProviderName  = NULL;
DWORD   dwSubjectProviderType   = PROV_RSA_FULL;
ALG_ID  algidHash               = CALG_MD5;
ULONG   ulSerialNumber          = 0;                // In future, allow serial nubmers of larger size
BOOL    fSetSerialNumber        = FALSE;
DWORD   dwCertStoreEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
BOOL    fIssuerInformation      = FALSE;
BOOL    fSubjectInformation     = FALSE;

LPWSTR  wszDhParaCertFile       = NULL;
DWORD   dwKeyBitLen             = 0;

WCHAR   wszGlue[10];
WCHAR   wszKey[10];
WCHAR   wszName[40];
WCHAR   wszRoot[40];
WCHAR   wszMakeCertRoot[40];   //used for indicating to use the root.cer.  Root is also a registry name
WCHAR   wszPlus[10];
WCHAR   wszNULL[10];

FILETIME g_ftNotBefore          = { 0, 0 };
FILETIME g_ftNotAfter           = { 0, 0 };
FILETIME g_ftZero               = { 0, 0 };
long     nMonths                = -1;

long     pathLenConstraint      = -1;
BYTE     certTypes              = 0;                // must be of type BYTE
CHAR*    szSignatureAlgObjId     = NULL;

static CERT_RDN_ATTR GlueRDNAttr=
    {
        SPC_GLUE_RDN_OBJID, CERT_RDN_PRINTABLE_STRING,
        {0, (BYTE *) wszGlue }
    };


//Global Data for loading the string
#define OPTION_SWITCH_SIZE  5


HMODULE hModule=NULL;

//---------------------------------------------------------------------------
//   Get the hModule hanlder and init two DLLMain.
//  
//---------------------------------------------------------------------------
BOOL    InitModule()
{
    if(!(hModule=GetModuleHandle(NULL)))
       return FALSE;
    
    return TRUE;
}

//-------------------------------------------------------------------------
//
//   BasicUsage()
//
//
//-------------------------------------------------------------------------
static void BasicUsage()
{
    IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_BASIC_OPTIONS);
    IDSwprintf(hModule,IDS_OPTION_SK_DESC);
#if (1) //DSIE: Bug 205195.
    IDSwprintf(hModule,IDS_OPTION_PE_DESC);
#endif
    IDSwprintf(hModule,IDS_OPTION_SS_DESC);
    IDSwprintf(hModule,IDS_OPTION_SS_DESC1);
    IDSwprintf(hModule,IDS_OPTION_SR_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_DEFAULT, IDS_OPTION_CU,
                            IDS_OPTION_LM,IDS_OPTION_CU );
    IDSwprintf(hModule,IDS_OPTION_SERIAL_DESC);
    IDSwprintf(hModule,IDS_OPTION_AUTH_DESC);
    IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_2, IDS_OPTION_AUTH_IND,
                        IDS_OPTION_AUTH_COM);
    IDSwprintf(hModule,IDS_OPTION_N_DESC);
    IDSwprintf(hModule,IDS_OPTION_BASIC_DESC);
    IDSwprintf(hModule,IDS_OPTION_EXTENDED_DESC);

}

//-------------------------------------------------------------------------
//
//   ExtendedUsage()
//
//
//-------------------------------------------------------------------------
static void ExtendedUsage()
{
    IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_EXTENDED_OPTIONS);
    IDSwprintf(hModule,IDS_OPTION_SC_DESC);
    IDSwprintf(hModule,IDS_OPTION_SV_DESC);
    IDSwprintf(hModule,IDS_OPTION_IC_DESC);
    IDSwprintf(hModule,IDS_OPTION_IK_DESC);
    IDSwprintf(hModule,IDS_OPTION_IV_DESC);
    IDSwprintf(hModule,IDS_OPTION_IS_DESC);
    IDSwprintf(hModule,IDS_OPTION_IR_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_DEFAULT, IDS_OPTION_CU,
        IDS_OPTION_LM,IDS_OPTION_CU );
    IDSwprintf(hModule,IDS_OPTION_IN_DESC);
    IDSwprintf(hModule,IDS_OPTION_ALGO_DESC, IDS_OPTION_ALGO);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_DEFAULT,IDS_OPTION_ALGO_MD5,
                            IDS_OPTION_ALGO_SHA, IDS_OPTION_ALGO_MD5);
    IDSwprintf(hModule,IDS_OPTION_IP_DESC);
    IDSwprintf(hModule,IDS_OPTION_IY_DESC);
    IDSwprintf(hModule,IDS_OPTION_SP_DESC);
    IDSwprintf(hModule,IDS_OPTION_SY_DESC);
    IDSwprintf(hModule,IDS_OPTION_IKY_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_KY, IDS_OPTION_KY_SIG,
                            IDS_OPTION_KY_EXC,IDS_OPTION_KY_SIG);
    IDSwprintf(hModule,IDS_OPTION_SKY_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_KY, IDS_OPTION_KY_SIG,
                            IDS_OPTION_KY_EXC,IDS_OPTION_KY_SIG);
    IDSwprintf(hModule,IDS_OPTION_L_DESC);
    IDSwprintf(hModule,IDS_OPTION_CY_DESC);
    IDS_IDS_IDSwprintf(hModule,IDS_OPTION_VALUES_2, IDS_OPTION_CY_END,
                            IDS_OPTION_CY_AUTH);
    IDSwprintf(hModule,IDS_OPTION_B_DESC);
    IDSwprintf(hModule,IDS_OPTION_M_DESC);
    IDSwprintf(hModule,IDS_OPTION_E_DESC);
    IDSwprintf(hModule,IDS_OPTION_H_DESC);
//  IDSwprintf(hModule,IDS_OPTION_G_DESC);
    IDSwprintf(hModule,IDS_OPTION_KEY_LEN_DESC);
    IDSwprintf(hModule,IDS_OPTION_R_DESC);
    IDSwprintf(hModule,IDS_OPTION_NSCP_DESC);
    IDSwprintf(hModule,IDS_OPTION_ENHKEY_USAGE_DESC);

    IDSwprintf(hModule,IDS_OPTION_BASIC_DESC);
    IDSwprintf(hModule,IDS_OPTION_EXTENDED_DESC);
}

static void UndocumentedUsage()
{
    IDSwprintf(hModule,IDS_SYNTAX);

    IDSwprintf(hModule,IDS_OPTION_SQ_DESC);
    IDSwprintf(hModule,IDS_OPTION_NOPUBKEYPARA_DESC);
    IDSwprintf(hModule,IDS_OPTION_DH_PARA_DESC);
    IDSwprintf(hModule,IDS_OPTION_NOPUBVERIFY_DESC);
}

//+=========================================================================
//  Local Support Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintLastError(int ids)
{
    DWORD       dwErr = GetLastError(); 
    IDS_IDS_DW_DWwprintf(hModule,IDS_ERR_LAST, ids, dwErr, dwErr);
}
//+-------------------------------------------------------------------------
//  Allocation and free macros
//--------------------------------------------------------------------------
#define MakeCertAlloc(p1)   ToolUtlAlloc(p1, hModule, IDS_ERR_DESC_ALLOC)

#define MakeCertFree(p1)    ToolUtlFree(p1)

//-----------------------------------------------------------------------------
//
//  Calculate the number of days
//-----------------------------------------------------------------------------
WORD DaysInMonth(WORD wMonth, WORD wYear)
{
    static int mpMonthDays[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
                            //       J   F   M   A   M   J   J   A   S   O   N   D

    WORD w = (WORD)mpMonthDays[wMonth];
    if ((wMonth == 2) && (wYear % 4 == 0) && (wYear%400 == 0 || wYear%100 != 0))
        {
        w += 1;
        }
    return w;
}



//-----------------------------------------------------------------------------
//
// Convert the string into a FILETIME. Let OLE do a bunch of work for us.
//----------------------------------------------------------------------------
BOOL FtFromWStr(LPCWSTR wsz, FILETIME* pft)
{
    memset(pft, 0, sizeof(*pft));

    WCHAR   wszMonth[3];
    DWORD   lcid=0;
    WORD    langid=0;

    //make sure wsz follows the mm/dd/yyyy
    if(wcslen(wsz)!=wcslen(L"mm/dd/yyyy"))
        return FALSE;

    //make sure wsz starts with "mm"
    wszMonth[0]=wsz[0];
    wszMonth[1]=wsz[1];
    wszMonth[2]=L'\0';

    if(!((_wtol(wszMonth)>0)&&(_wtol(wszMonth)<=12)))
        return FALSE;

    if (wsz)
        {
        //
        // The DATE Type
        //
        // The DATE type is implemented using an 8-byte floating-point number.
        // Days are represented by whole number increments starting with 30
        // December 1899, midnight as time zero. Hour values are expressed
        // as the absolute value of the fractional part of the number.
        //
        // We are using the English locale since the input format
        // should always be mm/dd/yyyy
        //
        langid=MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

        lcid = MAKELCID (langid, SORT_DEFAULT);

        DATE date;
        if (VarDateFromStr((LPWSTR)wsz, lcid, 0, &date) != S_OK)
            { return FALSE; }
        if (date < 0)
            { return FALSE; }                 // not implemented

        double days   = date;
        double hours  = ((days      - (LONG)    days) *   24);
        double minutes= ((hours     - (LONG)   hours) *   60);
        double seconds= ((minutes   - (LONG) minutes) *   60);
        double ms     = ((seconds   - (LONG) seconds) * 1000);

        SYSTEMTIME st;
        st.wYear    = 1899;
        st.wMonth   = 12;
        ULONG wDay  = 30 + (ULONG)days;
        st.wHour    =      (WORD)hours;
        st.wMinute  =      (WORD)minutes;
        st.wSecond  =      (WORD)seconds;
        st.wMilliseconds = (WORD)ms;

        //
        // Correct for rounding errors in the arithmetic
        //
        if (st.wMilliseconds >= 0.5)
            st.wSecond += 1;
        st.wMilliseconds = 0;
        if (st.wSecond >= 60)
            {
            st.wMinute += 1;
            st.wSecond -= 60;
            }
        if (st.wMinute >= 60)
            {
            st.wHour += 1;
            st.wMinute -= 60;
            }
        if (st.wHour >= 24)
            {
            st.wHour -= 24;
            }


        while (wDay > DaysInMonth(st.wMonth, st.wYear))
            {
            wDay   -= DaysInMonth(st.wMonth, st.wYear);
            st.wMonth += 1;
            if (st.wMonth > 12)
                {
                st.wMonth  = 1;
                st.wYear  += 1;
                }
            }

        st.wDay       = (WORD)wDay;
        st.wDayOfWeek = 0;

        FILETIME ft;
        SystemTimeToFileTime(&st, &ft);
        LocalFileTimeToFileTime(&ft, pft);

        return TRUE;
        }
    else
        return FALSE;
}



//-------------------------------------------------------------------------
//
// Set the parameters.  Each parameter can only be set once
//
//--------------------------------------------------------------------------
BOOL    SetParam(WCHAR **pwszParam, WCHAR *wszValue)
{
    if(*pwszParam!=NULL)
    {
        IDSwprintf(hModule,IDS_ERR_TOO_MANY_PARAM);
        return FALSE;
    }

    *pwszParam=wszValue;

    if(NULL==wszValue)
        return FALSE;
    
    return TRUE;

}



//--------------------------------------------------------------------------
//
//  Command Line Parsing
//
//--------------------------------------------------------------------------
static BOOL ParseCommandLine(int argc, WCHAR* wargv[])
{
    
    for ( int i = 1; i < argc; ++i )
    {
        WCHAR*   p = wargv[i];
        
        if(IDSwcsnicmp(hModule,p, IDS_SWITCH1, 1)!=0 &&
            IDSwcsnicmp(hModule,p,IDS_SWITCH2, 1)!=0)
        {
            if(!SetParam(&wszOutputFile,p))
                goto BasicErr;
            else
                continue;
        }

        //move over to the real option
        ++p;

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SERIAL)==0)
        {
            i++;
            p=wargv[i];

            if(NULL==p)
                goto BasicErr;

            ulSerialNumber=_wtol(p);
            fSetSerialNumber=TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_H)==0)
        {
            i++;
            p=wargv[i];

            if(NULL==p)
                goto ExtendedErr;


            pathLenConstraint=_wtol(p);

            if(pathLenConstraint < 0)
                goto ExtendedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_CY)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszCertType, p))
                goto ExtendedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_M)==0)
        {
            i++;
            p=wargv[i];

            if(NULL==p)
                goto ExtendedErr;

            nMonths=_wtol(p);

            if(nMonths < 0)
                goto ExtendedErr;

            continue;
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_B)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;


            if(!FtFromWStr(p, &g_ftNotBefore))
            {
                IDSwprintf(hModule, IDS_ERR_INVALID_B);
                goto ExtendedErr;
            }

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_E)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;

            if(!FtFromWStr(p, &g_ftNotAfter))
            {
                IDSwprintf(hModule, IDS_ERR_INVALID_E);
                goto ExtendedErr;
            }

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_AUTH)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszAuthority, p))
                goto BasicErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_R)==0)
        {
            fSelfSigned=TRUE;
            continue;   
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_SK)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectKey, p))
            {
                if(TRUE==fUseSubjectPvkFile)
                    IDSwprintf(hModule, IDS_ERR_SK_SV);

                goto BasicErr;
            }

            fUseSubjectKeyContainer=TRUE;
            fSubjectInformation=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SQ)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectRequestFile, p))
                goto UndocumentedErr;
            continue;
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_SV)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectKey, p))
            {
                if(TRUE==fUseSubjectKeyContainer)
                    IDSwprintf(hModule, IDS_ERR_SK_SV);
                goto ExtendedErr;
            }

            fSubjectInformation=TRUE;
            fUseSubjectPvkFile=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SC)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectCertFile, p))
                goto ExtendedErr;

            fSubjectInformation=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SS)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectStore, p))
                goto BasicErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SR)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectStoreLocation, p))
                goto BasicErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_N)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectX500Name, p))
                goto BasicErr;

            fSetSubjectName = TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IP)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerProviderName, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IY)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;

            dwIssuerProviderType=_wtol(p);

            fIssuerInformation = TRUE;

            continue;
        }
        
        if(IDSwcsicmp(hModule,p, IDS_OPTION_SP)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectProviderName, p))
                goto ExtendedErr;    

            fSubjectInformation=TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SY)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto ExtendedErr;

            dwSubjectProviderType=_wtol(p);

            fSubjectInformation=TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IK)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerKey, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IV)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerKey, p))
                goto ExtendedErr;

            fUseIssuerPvkFile=TRUE;
            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IS)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerStore, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IR)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerStoreLocation,p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IN)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerCertName,p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IC)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerCertFile, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_L)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszPolicyLink, p))
                goto ExtendedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_SKY)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszSubjectKeyType, p))
                goto ExtendedErr;

            fSubjectInformation=TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_IKY)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszIssuerKeyType, p))
                goto ExtendedErr;

            fIssuerInformation = TRUE;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_ALGO)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszAlgorithm, p))
                goto ExtendedErr;

            continue;
        }

        if (IDSwcsicmp(hModule,p, IDS_OPTION_ENHKEY_USAGE)==0)
        {
            i++;
            p=wargv[i];

            if (!SetParam(&wszEKUOids, p))
                goto ExtendedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_NSCP)==0)
        {
            fNetscapeClientAuth = TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_NOPUBVERIFY)==0)
        {
            fNoVerifyPublic = TRUE;
            continue;
        }       

        if(IDSwcsicmp(hModule,p, IDS_OPTION_EXTENDED)==0)
        {
            //display extended options
            goto ExtendedErr;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_TEST)==0)
        {
            //display extended options
            goto UndocumentedErr;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_NOPUBKEYPARA)==0)
        {
            fNoPubKeyPara = TRUE;
            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_DH_PARA)==0)
        {
            i++;
            p=wargv[i];

            if(!SetParam(&wszDhParaCertFile, p))
                goto UndocumentedErr;

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_KEY_LEN)==0)
        {
            i++;
            p=wargv[i];
            if(NULL==p)
                goto UndocumentedErr;

            dwKeyBitLen=_wtol(p);

            continue;
        }

        if(IDSwcsicmp(hModule,p, IDS_OPTION_PE)==0)
        {
            fPrivateKeyExportable=TRUE;
            continue;
        }

        //display basic options
        goto BasicErr;
    }

    //Only change container name if request private key
    //to be exportable. This way we maintain backward
    //compatibility, and allow user to request private
    //key to be marked as exportable.
    //Note: If the private key is not marked as exportable,
    //      the hardcoded container name, "JoeSoft", is
    //      always used, which means more than one cert
    //      can share the same key pair.
    //Note2: If the user specifies the container name, use that one instead
    if (fPrivateKeyExportable && (wszSubjectKey == NULL))
    {
        UUID uuidContainerName;
        RPC_STATUS rpcs;

        rpcs = UuidCreate(&uuidContainerName);
        if ((rpcs != RPC_S_OK) &&
            (rpcs != RPC_S_UUID_LOCAL_ONLY) &&
            (rpcs != RPC_S_UUID_NO_ADDRESS))
        {
            IDSwprintf(hModule, IDS_ERR_PE_CONTAINER);
            goto BasicErr;
        }

        if (RPC_S_OK != UuidToStringU(&uuidContainerName, &wszSubjectKey))
        {
            IDSwprintf(hModule, IDS_ERR_PE_CONTAINER);
            goto BasicErr;
        }
    }

    //make sure the either output file or the subject' cert store is set
    if((wszOutputFile==NULL) && (wszSubjectStore==NULL))
    {
        IDSwprintf(hModule, IDS_ERR_NO_OUTPUT);
        goto BasicErr;
    }

    //set the authority
    if(wszAuthority)
    {
        if(IDSwcsicmp(hModule,wszAuthority, IDS_OPTION_AUTH_IND) == 0)
            fCertIndividual = TRUE;
        else
        {
            if(IDSwcsicmp(hModule,wszAuthority, IDS_OPTION_AUTH_COM) == 0)
                fCertCommercial = TRUE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_AUTH);
                goto BasicErr;
            }
        }
    }

    //set the algorithm
    if(wszAlgorithm)
    {
        if(IDSwcsicmp(hModule,wszAlgorithm, IDS_OPTION_ALGO_SHA) == 0)
            algidHash = CALG_SHA;
        else
        {
            if(IDSwcsicmp(hModule,wszAlgorithm, IDS_OPTION_ALGO_MD5) == 0)
                algidHash = CALG_MD5;   
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_ALGO);
                goto ExtendedErr;
            }
        }
    }

    //set the cert type
    if(wszCertType)
    {
        if(IDSwcsicmp(hModule,wszCertType, IDS_OPTION_CY_END) == 0)
            certTypes |= CERT_END_ENTITY_SUBJECT_FLAG;
        else
        {
            if(IDSwcsicmp(hModule,wszCertType, IDS_OPTION_CY_AUTH) == 0)
                certTypes |= CERT_CA_SUBJECT_FLAG;
            else
            {
		IDSwprintf(hModule,IDS_ERR_NO_CY);
		goto ExtendedErr;
	    }
        }
    }

    //set the issuer key type
    if(wszIssuerKeyType)
    {
        if(IDSwcsicmp(hModule,wszIssuerKeyType, IDS_OPTION_KY_SIG) == 0)
            dwIssuerKeySpec = AT_SIGNATURE;
        else
        {
            if(IDSwcsicmp(hModule,wszIssuerKeyType, IDS_OPTION_KY_EXC) == 0)
                dwIssuerKeySpec = AT_KEYEXCHANGE;
            else
                dwIssuerKeySpec=_wtol(wszIssuerKeyType);
        }

    }

    //set the subject key type
    if(wszSubjectKeyType)
    {
        if(IDSwcsicmp(hModule,wszSubjectKeyType, IDS_OPTION_KY_SIG) == 0)
            dwKeySpec = AT_SIGNATURE;
        else
        {
            if(IDSwcsicmp(hModule,wszSubjectKeyType, IDS_OPTION_KY_EXC) == 0)
                dwKeySpec = AT_KEYEXCHANGE;
            else
                dwKeySpec=_wtol(wszSubjectKeyType); 
        }

    }

    //determing the issuer store location
    if(wszIssuerStoreLocation)
    {
        if(IDSwcsicmp(hModule,wszIssuerStoreLocation, IDS_OPTION_CU) == 0)
            dwIssuerStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
        else
        {
            if(IDSwcsicmp(hModule,wszIssuerStoreLocation, IDS_OPTION_LM) == 0)
                dwIssuerStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_IR);
                goto ExtendedErr;
            }
        }
    }

    //determind the subject store location
    if(wszSubjectStoreLocation)
    {
        if(IDSwcsicmp(hModule,wszSubjectStoreLocation, IDS_OPTION_CU) == 0)
            dwSubjectStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
        else
        {
            if(IDSwcsicmp(hModule,wszSubjectStoreLocation, IDS_OPTION_LM) == 0)
                dwSubjectStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_IR);
                goto BasicErr;
            }
        }
    }

    //wszIssuerStore and wszIssuerKey can not be set at the same time
    if(wszIssuerKey || wszIssuerProviderName || wszIssuerKeyType)
    {
        if(wszIssuerStore || wszIssuerCertName)
        {
            //remind user that -ik, -iv, -ip can not be
            //set with -is, -in options
            IDSwprintf(hModule,IDS_ERR_TOO_MANY_STORE_KEY);
            goto ExtendedErr;
        }
    }

    //wszCertFile and wszCertName can not be set at the same time
    if(wszIssuerCertFile && wszIssuerCertName)
    {
        IDSwprintf(hModule, IDS_ERR_CERT_FILE_NAME);
        goto ExtendedErr;
    }

    //is wszIsserCertFile is NULL
    if(wszIssuerCertFile==NULL)
    {
        //we init wszIssuerKey to "MakeCertRoot" if there is no store
        //information
        if(wszIssuerStore==NULL)
        {
            if(wszIssuerKey)
            {
                //if wszIssuerKey is set, we have to set the IssuerCertFile
                IDSwprintf(hModule, IDS_ERR_NO_ISSUER_CER_FILE);
                goto ExtendedErr;
            }
            else
            {
                wszIssuerKey=wszMakeCertRoot;
            }
        }
    }
    else
    {
        //either wszIssuerStore or wszIssuerKey should be set
        if((!wszIssuerStore) && (!wszIssuerKey))
        {
            IDSwprintf(hModule, IDS_ERR_EITHER_STORE_OR_KEY);
            goto ExtendedErr;
        }
    }

    //for self signed certificate, user should not supply
    //issuer information
    if(fIssuerInformation && fSelfSigned)
    {
        IDSwprintf(hModule, IDS_NO_ISSUER_FOR_SELF_SIGNED);
        goto ExtendedErr;
    }

    //user can not request a self signed certificate with
    //a PKCS10 file.  We neither generate or have access
    //to the private key
    if(fSelfSigned && wszSubjectRequestFile)
    {
        IDSwprintf(hModule, IDS_NO_PKCS10_AND_SELF_SIGNED);
        goto ExtendedErr;
    }


    if(fSubjectInformation && wszSubjectRequestFile)
    {
        IDSwprintf(hModule, IDS_NO_PKCS10_AND_SUBJECT_PVK);
        goto ExtendedErr;
    }

    //for self signed certificate, copy the provider type 
    //to the issuer so that the signatureAlgObjID will
    //be corrrect
    if(fSelfSigned)
        dwIssuerProviderType = dwSubjectProviderType;

    // Set the signature and public key algorithm parameters
    if (PROV_DSS == dwIssuerProviderType ||
            PROV_DSS_DH == dwIssuerProviderType)
        szSignatureAlgObjId     = szOID_X957_SHA1DSA;
    else if (algidHash == CALG_SHA)
        szSignatureAlgObjId     = szOID_OIWSEC_sha1RSASign;
    else
        szSignatureAlgObjId     = szOID_RSA_MD5RSA;

    return TRUE;

BasicErr:
    BasicUsage();
    return FALSE;

ExtendedErr:
    ExtendedUsage();
    return FALSE;

UndocumentedErr:
    UndocumentedUsage();
    return FALSE;
}

static BOOL MakeCert();

//+-------------------------------------------------------------------------
//  Check if creating a self signed certificate
//--------------------------------------------------------------------------
static BOOL IsSelfSignedCert()
{
    return fSelfSigned;
}


//--------------------------------------------------------------------------
//
//    wmain
//
//--------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR ** wargv)
{
    int status = 0;


    //get the module handle
    if(!InitModule())
        return -1;

    //load the string for Glue cert attribute
    if(!LoadStringU(hModule, IDS_GLUE,wszGlue, sizeof(wszGlue)/sizeof(wszGlue[0])))
        return -1;
    
    //load the string for wszSubjectKey and wszSubjectX500Name
    if(!LoadStringU(hModule, IDS_JOE_SOFT,
        wszKey, sizeof(wszKey)/sizeof(wszKey[0]))
      || !LoadStringU(hModule, IDS_JOE_NAME,
        wszName, sizeof(wszName)/sizeof(wszName[0]))
      || !LoadStringU(hModule, IDS_MAKECERT_ROOT,
         wszMakeCertRoot, sizeof(wszMakeCertRoot)/sizeof(wszMakeCertRoot[0]))
      || !LoadStringU(hModule, IDS_PLUS,
         wszPlus, sizeof(wszPlus)/sizeof(wszPlus[0]))
      || !LoadStringU(hModule, IDS_ROOT,
        wszRoot, sizeof(wszRoot)/sizeof(wszRoot[0]))
      )
        return -1;

    LoadStringU(hModule, IDS_NULL,
         wszNULL, sizeof(wszNULL)/sizeof(wszNULL[0]));

    // Parse the command line
    if (!ParseCommandLine(argc, wargv))
    {
        return -1;
    }

    //init wszSubjectKey and wszSubjectX500Name
    if(wszSubjectKey==NULL)
        wszSubjectKey=wszKey;

    if(wszSubjectX500Name==NULL)
        wszSubjectX500Name=wszName;

    if (FAILED(CoInitialize(NULL)))
    {
        IDSwprintf(hModule,IDS_ERR_COINIT);
        return -1;
    }

    // Get to work and make the certificate
    if (!MakeCert())
    {
        CoUninitialize();
        goto ErrorReturn;
    }

    //print out the success information
    IDSwprintf(hModule,IDS_SUCCEEDED);

CommonReturn:
    CoUninitialize();
    return status;

ErrorReturn:
    status = -1;
    IDSwprintf(hModule,IDS_ERR_FAILED);
    goto CommonReturn;
}

//+=========================================================================
//  MakeCert support functions
//==========================================================================

static BOOL IsRootKey();
static PCCERT_CONTEXT GetRootCertContext();
static HCRYPTPROV GetRootProv(OUT LPWSTR *ppwszTmpContainer);
static PCCERT_CONTEXT GetIssuerCertContext();
static BOOL VerifyIssuerKey(
    IN HCRYPTPROV hProv,
    IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo
    );
static HCRYPTPROV GetIssuerProv(OUT LPWSTR *ppwszTmpContainer);
static HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer);
static HCRYPTPROV GetProvFromStore(IN   LPWSTR pwszStoreName);


static BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    );
static BOOL GetSubject(
    OUT PCCERT_CONTEXT *ppCertContext,
    OUT BYTE **ppbEncodedName,
    OUT DWORD *pcbEncodedName
    );
static BOOL GetRequestInfo(
    OUT PCERT_REQUEST_INFO *ppStuff);
static BOOL EncodeSubject(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL SignAndEncodeCert(
    HCRYPTPROV hProv,
    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded
    );

static BOOL CreateAuthorityKeyId(
    IN HCRYPTPROV hProv,
    PCERT_INFO pIssuerCert,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateSpcSpAgency(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );
static BOOL CreateBasicConstraints(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz);

BOOL    SaveCertToStore(HCRYPTPROV  hProv,      
                        DWORD       dwEncodingType,
                        LPWSTR      wszStore,       
                        DWORD       dwFlag,
                        BYTE        *pbEncodedCert, 
                        DWORD       cbEncodedCert,
                        LPWSTR      wszPvk,         
                        BOOL        fPvkFile,
                        DWORD       dwKeySpecification,
                        LPWSTR      wszCapiProv,        
                        DWORD       dwCapiProvType);


PCCERT_CONTEXT  GetIssuerCertAndStore(HCERTSTORE *phCertStore, BOOL *pfMore);

HRESULT GetCertHashFromFile(LPWSTR  pwszCertFile,
                            BYTE    **ppHash,
                            DWORD   *pcbHash,
                            BOOL    *pfMore);


BOOL    EmptySubject(CERT_NAME_BLOB *pSubject);

BOOL    GetExtensionsFromRequest(PCERT_REQUEST_INFO  pReqInfo, DWORD *pdwCount, PCERT_EXTENSIONS **pprgExtensions);



//+=========================================================================
// Support functions to generate DH keys having the 'Q'parameter
//==========================================================================
static BOOL GenDhKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags
    );
static BOOL UpdateDhPublicKey(
    IN OUT PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    );
static BOOL IsDh3Csp();


//+-------------------------------------------------------------------------
//  Make the subject certificate. If the subject doesn't have a private
//  key, then, create.
//--------------------------------------------------------------------------
static BOOL MakeCert()
{
    BOOL fResult;

    HCRYPTPROV      hIssuerProv = 0;
    LPWSTR          pwszTmpIssuerContainer = NULL;
    BOOL            fDidIssuerAcquire=FALSE;
    LPWSTR          pwszTmpIssuerProvName=NULL;
    DWORD           dwTmpIssuerProvType;
    PCCERT_CONTEXT  pIssuerCertContext = NULL;
    HCERTSTORE      hIssuerCertStore=NULL;
    PCERT_INFO      pIssuerCert =NULL; // not allocated
    PCERT_REQUEST_INFO  pReqInfo =NULL;
    HCRYPTPROV      hSubjectProv = 0;
    LPWSTR          pwszTmpSubjectContainer = NULL;
    PCCERT_CONTEXT  pSubjectCertContext = NULL;
    DWORD               dwRequestExtensions=0;
    PCERT_EXTENSIONS    *rgpRequestExtensions=NULL;
    DWORD               dwExtIndex=0;
    DWORD               dwPerExt=0;
    DWORD               dwExistExt=0;

    PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo = NULL;         // not allocated
    PCERT_PUBLIC_KEY_INFO pAllocSubjectPubKeyInfo = NULL;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded =0;
    BYTE *pbKeyIdEncoded = NULL;
    DWORD cbKeyIdEncoded =0;
    BYTE *pbSerialNumber = NULL;
    DWORD cbSerialNumber = 0;
    BYTE *pbSpcSpAgencyEncoded = NULL;
    DWORD cbSpcSpAgencyEncoded =0;
    BYTE *pbSpcCommonNameEncoded = NULL;
    DWORD cbSpcCommonNameEncoded =0;
    BYTE *pbKeyUsageEncoded = NULL;
    DWORD cbKeyUsageEncoded =0;
    BYTE *pbFinancialCriteria = NULL;
    DWORD cbFinancialCriteria =0;
    BYTE *pbBasicConstraintsEncoded = NULL;
    DWORD cbBasicConstraintsEncoded =0;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded =0;
    BYTE *pbEKUEncoded = NULL;
    DWORD cbEKUEncoded = 0;

    CERT_INFO Cert;
    GUID SerialNumber;

    CERT_EXTENSION *rgExt=NULL;
    DWORD           dwExtAlloc=0;
    DWORD           cExt = 0;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        szSignatureAlgObjId, 0, 0
    };

    BYTE *pbIssuerEncoded;  // not allocated
    DWORD cbIssuerEncoded;

    if (wszSubjectRequestFile)
    {
        if (!GetRequestInfo(&pReqInfo))
        {
            IDSwprintf(hModule,IDS_INVALID_REQUEST_FILE, wszSubjectRequestFile);
            goto ErrorReturn;
        }

        pSubjectPubKeyInfo = &(pReqInfo->SubjectPublicKeyInfo);

        if(!GetExtensionsFromRequest(pReqInfo, &dwRequestExtensions, &rgpRequestExtensions))
        {
            IDSwprintf(hModule,IDS_INVALID_ATTR_REQUEST_FILE, wszSubjectRequestFile);
            goto ErrorReturn;
        }
        
        //if the subject informatin is empt or user has supplied the subject
        //name through the command line, we use the command line options
        if(fSetSubjectName || wszSubjectCertFile || EmptySubject(&(pReqInfo->Subject)))
        {
            if (wszSubjectCertFile) 
            {
                // Get encoded subject name and public key from the subject cert
                if (!GetSubject(&pSubjectCertContext,
                                &pbSubjectEncoded, &cbSubjectEncoded))
                    goto ErrorReturn;
            } 
            else 
            {
                // Encode the subject name
                if (!EncodeSubject(&pbSubjectEncoded, &cbSubjectEncoded))
                    goto ErrorReturn;
            }
        }
        else
        {
            cbSubjectEncoded = pReqInfo->Subject.cbData;

            pbSubjectEncoded = (BYTE *) MakeCertAlloc(cbSubjectEncoded);

            if(NULL == pbSubjectEncoded)
                goto ErrorReturn;

            memcpy(pbSubjectEncoded, pReqInfo->Subject.pbData, cbSubjectEncoded);

        }
    }
    else
    {
        if (wszSubjectCertFile) 
        {
            // Get encoded subject name and public key from the subject cert
            if (!GetSubject(&pSubjectCertContext,
                            &pbSubjectEncoded, &cbSubjectEncoded))
                goto ErrorReturn;
            pSubjectPubKeyInfo = &pSubjectCertContext->pCertInfo->SubjectPublicKeyInfo;
	    pbSerialNumber = pSubjectCertContext->pCertInfo->SerialNumber.pbData;
	    cbSerialNumber = pSubjectCertContext->pCertInfo->SerialNumber.cbData;
        } 
        else 
        {
            //
            // Get access to the subject's (public) key, creating it if necessary
            //
            if (0 == (hSubjectProv = GetSubjectProv(&pwszTmpSubjectContainer)))
                goto ErrorReturn;

            if (!GetPublicKey(hSubjectProv, &pAllocSubjectPubKeyInfo))
                goto ErrorReturn;
            pSubjectPubKeyInfo = pAllocSubjectPubKeyInfo;

            //
            // Encode the subject name
            //
            if (!EncodeSubject(&pbSubjectEncoded, &cbSubjectEncoded))
                goto ErrorReturn;
        }
    }

    //
    // Get access to the issuer's (private) key
    //
    if( IsSelfSignedCert())
    {
        hIssuerProv=hSubjectProv;
        dwIssuerKeySpec=dwKeySpec;

        pbIssuerEncoded = pbSubjectEncoded;
        cbIssuerEncoded = cbSubjectEncoded;
        pIssuerCert = &Cert;

       if (!VerifyIssuerKey(hIssuerProv, pSubjectPubKeyInfo))
            goto ErrorReturn;

    }
    else
    {   
        //get the hProv from the certificate store
        if(wszIssuerStore)
        {
            BOOL    fMore=FALSE;

            pwszTmpIssuerContainer=NULL;

            //get the non-root private key set based on the store name

            //first, get the certificate context from the cert store
            if(NULL==(pIssuerCertContext=GetIssuerCertAndStore(
                                            &hIssuerCertStore,
                                            &fMore)))
            {
                if(fMore==FALSE)
                    IDSwprintf(hModule, IDS_ERR_NO_ISSUER_CERT,
                                wszIssuerStore);
                else
                    IDSwprintf(hModule, IDS_ERR_MORE_ISSUER_CERT,
                                wszIssuerStore);

                goto ErrorReturn;
            }

            //second, get the hProv from the certifcate context
            if(!GetCryptProvFromCert(
                                    NULL,
                                    pIssuerCertContext,
                                    &hIssuerProv,
                                    &dwIssuerKeySpec,
                                    &fDidIssuerAcquire,
                                    &pwszTmpIssuerContainer,
                                    &pwszTmpIssuerProvName,
                                    &dwTmpIssuerProvType))
            {
                IDSwprintf(hModule, IDS_ERR_NO_PROV_FROM_CERT);
                goto ErrorReturn;
            }
        }
        else
        {

            if (0 == (hIssuerProv = GetIssuerProv(&pwszTmpIssuerContainer)))
                goto ErrorReturn;

            // Get the Issuer's Certificate
            if (NULL == (pIssuerCertContext = GetIssuerCertContext()))
                goto ErrorReturn;
            
        }

        // Verify the issuer's key. Its public key must match the one
        // in the issuer's provider
        //
        pIssuerCert = pIssuerCertContext->pCertInfo;

        if ((!fNoVerifyPublic) && (!VerifyIssuerKey(hIssuerProv, &pIssuerCert->SubjectPublicKeyInfo)))
            goto ErrorReturn;

        pbIssuerEncoded = pIssuerCert->Subject.pbData;
        cbIssuerEncoded = pIssuerCert->Subject.cbData;
    }


    //
    // Update the CERT_INFO
    //
    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;

    if (0 != cbSerialNumber) {
        Cert.SerialNumber.pbData = pbSerialNumber;
        Cert.SerialNumber.cbData = cbSerialNumber;
    } else if (fSetSerialNumber) {
        Cert.SerialNumber.pbData = (BYTE *) &ulSerialNumber;
        Cert.SerialNumber.cbData = sizeof(ulSerialNumber);
    } else if (0 == Cert.SerialNumber.cbData) {
        CoCreateGuid(&SerialNumber);
        Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
        Cert.SerialNumber.cbData = sizeof(SerialNumber);
    }

    Cert.SignatureAlgorithm = SignatureAlgorithm;
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    {
        SYSTEMTIME st;
        
        //decide NotBefore

        // Let the user override the default validity endpoints
        //
        if (CompareFileTime(&g_ftNotBefore, &g_ftZero) != 0)
        {
            Cert.NotBefore = g_ftNotBefore;
        }
        else
        {
            // Default validity: now through end of 2039
            GetSystemTimeAsFileTime(&Cert.NotBefore);
        }

        //decide NotAfter
        if (CompareFileTime(&g_ftNotAfter, &g_ftZero) != 0)
        {
            Cert.NotAfter = g_ftNotAfter;
        }
        else
        {
            memset(&st, 0, sizeof(st));
            st.wYear  = 2039;
            st.wMonth = 12;
            st.wDay   = 31;
            st.wHour  = 23;
            st.wMinute= 59;
            st.wSecond= 59;
            SystemTimeToFileTime(&st, &Cert.NotAfter);
        }

        //add the number of months
        if (nMonths >= 0)
        {
            //if the user has specified NotAfter with -E switch, error
            if(CompareFileTime(&g_ftNotAfter, &g_ftZero) != 0)
                goto ErrorReturn;

            if (nMonths > 0)
            {
                FILETIME    tempFT;
                DWORD       dwMonth;
                SYSTEMTIME  tempST;
                BOOL        fFirstDayOfMonth;

                // 
                // Cert.NotBefore is stored as UTC, but the user has entered
                // nMonths based on local time, so convert to local time, then:
                // NotAfter = (NotBefore - 1 second) + nMonths
                // 
                if (!FileTimeToLocalFileTime(&Cert.NotBefore, &tempFT))
                    goto ErrorReturn;

                //
                // if the day is the first day of the month, then subtract
                // one second after the months are added to the NotBefore
                // time instead of before the months are added, otherwise
                // we could end up with the wrong ending date.
                //
                if (FileTimeToSystemTime(&tempFT, &tempST)) {               
                    fFirstDayOfMonth = (tempST.wDay == 1);
                }
                else {
                    goto ErrorReturn;
                }

                // Subtract one second from the starting date, and then
                // add the number of months to that time
                //
                // FILETIME is in units of 100 nanoseconds (10**-7)
                if (!fFirstDayOfMonth) {
                    unsigned __int64* pli = (unsigned __int64*) &tempFT;
                    *pli -= 10000000;       // ten million
                }
                
                if (!FileTimeToSystemTime(&tempFT, &st))
                    goto ErrorReturn;
                
                dwMonth = (DWORD) nMonths + st.wMonth;
                while (dwMonth > 12)
                {
                    dwMonth -= 12;
                    st.wYear += 1;
                }
                st.wMonth = (WORD) dwMonth;

                //
                // This loop is because the ending month may not have as
                // many days as the starting month... so the initial
                // ending day may not even exist, thus, loop until we
                // find one that does or we go below 28 (no month ever has
                // less than 28 days)
                //
                while(!SystemTimeToFileTime(&st, &tempFT)) {
                    if(st.wDay >= 29 )
                        st.wDay--;
                    else                    
                        goto ErrorReturn;
                }

                //
                // if first day of month then subtract our one second
                // after month calculations
                //
                if (fFirstDayOfMonth) {
                    unsigned __int64* pli = (unsigned __int64*) &tempFT;
                    *pli -= 10000000;       // ten million
                }

                if (!LocalFileTimeToFileTime(&tempFT, &Cert.NotAfter))
                    goto ErrorReturn;
            
            }
            else {
                
                if (!FileTimeToSystemTime(&Cert.NotBefore, &st))
                    goto ErrorReturn;

                if (!SystemTimeToFileTime(&st, &Cert.NotAfter))
                    goto ErrorReturn;
            }
        }
    }

    Cert.Subject.pbData = pbSubjectEncoded;
    Cert.Subject.cbData = cbSubjectEncoded;
    Cert.SubjectPublicKeyInfo = *pSubjectPubKeyInfo;

    //allocate memory to hold all the extensions
    dwExtAlloc = MAX_EXT_CNT;
     
    for(dwExtIndex=0; dwExtIndex < dwRequestExtensions; dwExtIndex++)
        dwExtAlloc += (rgpRequestExtensions[dwExtIndex])->cExtension;

    rgExt = (CERT_EXTENSION *)MakeCertAlloc(dwExtAlloc * sizeof(CERT_EXTENSION));   
    if(NULL == rgExt)
        goto ErrorReturn;

    memset(rgExt, 0, dwExtAlloc * sizeof(CERT_EXTENSION));
    cExt=0;
    
    // Cert Extensions
    if (fNetscapeClientAuth) {
        // Set Netscape specific extensions

        static BYTE  rgXxxxData[] = { 0x30, 0x03, 0x02, 0x01, 0x00 };
        rgExt[cExt].pszObjId = "2.5.29.19";
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = rgXxxxData;
        rgExt[cExt].Value.cbData = sizeof(rgXxxxData);
        cExt++;

        static BYTE  rgNscpData[] = { 0x03, 0x02, 0x07, 0x80 };
        rgExt[cExt].pszObjId = "2.16.840.1.113730.1.1";
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = rgNscpData;
        rgExt[cExt].Value.cbData = sizeof(rgNscpData);
        cExt++;
    }

    if (pathLenConstraint >= 0 || certTypes) {
        if (!CreateBasicConstraints(
                &pbBasicConstraintsEncoded,
                &cbBasicConstraintsEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_BASIC_CONSTRAINTS2;
        rgExt[cExt].fCritical = TRUE;
        rgExt[cExt].Value.pbData = pbBasicConstraintsEncoded;
        rgExt[cExt].Value.cbData = cbBasicConstraintsEncoded;
        cExt++;
    }


    if (fCertCommercial || fCertIndividual) {
        if (!CreateKeyUsage(
                &pbKeyUsageEncoded,
                &cbKeyUsageEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = szOID_KEY_USAGE_RESTRICTION;
        rgExt[cExt].fCritical = TRUE;
        rgExt[cExt].Value.pbData = pbKeyUsageEncoded;
        rgExt[cExt].Value.cbData = cbKeyUsageEncoded;
        cExt++;
    }

    if (wszPolicyLink) {
        if (!CreateSpcSpAgency(
                &pbSpcSpAgencyEncoded,
                &cbSpcSpAgencyEncoded))
            goto ErrorReturn;
        rgExt[cExt].pszObjId = SPC_SP_AGENCY_INFO_OBJID;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbSpcSpAgencyEncoded;
        rgExt[cExt].Value.cbData = cbSpcSpAgencyEncoded;
        cExt++;
    }

    //if user has specified fCertCommercial or fCertIndividual,
    //we add the code signing oid to the EKU extensions
    if (wszEKUOids || fCertCommercial || fCertIndividual) {
        if (!CreateEnhancedKeyUsage(
                &pbEKUEncoded,
                &cbEKUEncoded))
            goto ErrorReturn;

        rgExt[cExt].pszObjId = szOID_ENHANCED_KEY_USAGE;
        rgExt[cExt].fCritical = FALSE;
        rgExt[cExt].Value.pbData = pbEKUEncoded;
        rgExt[cExt].Value.cbData = cbEKUEncoded;
        cExt++;
    }

    if (!CreateAuthorityKeyId(
            hIssuerProv,
            pIssuerCert,
            &pbKeyIdEncoded,
            &cbKeyIdEncoded))
        goto ErrorReturn;
    rgExt[cExt].pszObjId = szOID_AUTHORITY_KEY_IDENTIFIER;
    rgExt[cExt].fCritical = FALSE;
    rgExt[cExt].Value.pbData = pbKeyIdEncoded;
    rgExt[cExt].Value.cbData = cbKeyIdEncoded;
    cExt++;

    //we now combine the extension from the certificate request file.
    //In case of duplication of extensions, the command line options
    //have higher priority
    for(dwExtIndex=0; dwExtIndex < dwRequestExtensions; dwExtIndex++)
    {
        for(dwPerExt=0; dwPerExt < rgpRequestExtensions[dwExtIndex]->cExtension; dwPerExt++)
        {
            for(dwExistExt=0; dwExistExt<cExt; dwExistExt++)
            {
                if(0 == strcmp(rgExt[dwExistExt].pszObjId,
                            (rgpRequestExtensions[dwExtIndex]->rgExtension[dwPerExt]).pszObjId))
                    break;
            }

            //we merge if this is a new extension
            if(dwExistExt == cExt)
            {   
                memcpy(&(rgExt[cExt]), &(rgpRequestExtensions[dwExtIndex]->rgExtension[dwPerExt]), sizeof(CERT_EXTENSION));
                cExt++;
            }
        }
    }

    Cert.rgExtension = rgExt;
    Cert.cExtension = cExt;

    //
    // Sign and encode the certificate
    //
    cbCertEncoded = 0;
    CryptSignAndEncodeCertificate(
        hIssuerProv,
        dwIssuerKeySpec,
        X509_ASN_ENCODING,
        X509_CERT_TO_BE_SIGNED,
        &Cert,
        &Cert.SignatureAlgorithm,
        NULL,                       // pvHashAuxInfo
        NULL,                       // pbEncoded
        &cbCertEncoded
        );
    if (cbCertEncoded == 0) {
        PrintLastError(IDS_ERR_SIGN_ENCODE_CB);
        goto ErrorReturn;
    }
    pbCertEncoded = (BYTE *) MakeCertAlloc(cbCertEncoded);
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptSignAndEncodeCertificate(
            hIssuerProv,
            dwIssuerKeySpec,
            X509_ASN_ENCODING,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            &Cert.SignatureAlgorithm,
            NULL,                       // pvHashAuxInfo
            pbCertEncoded,
            &cbCertEncoded
            )) {
        PrintLastError(IDS_ERR_SIGN_ENCODE);
        goto ErrorReturn;
    }

    //output the encoded certificate to an output file
    if(wszOutputFile)
    {

        if (S_OK!=OpenAndWriteToFile(wszOutputFile, pbCertEncoded, cbCertEncoded))
        {
            PrintLastError(IDS_ERR_DESC_WRITE);
            goto ErrorReturn;
        }
    }

    //output the encoded certificate to an cerificate store
    if(wszSubjectStore)
    {
       if((!SaveCertToStore(hSubjectProv, dwCertStoreEncodingType,
                wszSubjectStore, dwSubjectStoreFlag,
                pbCertEncoded, cbCertEncoded, wszSubjectKey, fUseSubjectPvkFile,
                dwKeySpec, wszSubjectProviderName, dwSubjectProviderType)))
       {
            PrintLastError(IDS_ERR_DESC_SAVE_STORE);
            goto ErrorReturn;

       }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:

    if((!IsSelfSignedCert()) && hIssuerProv)
    {
        if(wszIssuerStore)
        {
            FreeCryptProvFromCert(fDidIssuerAcquire,
                                  hIssuerProv,
                                  pwszTmpIssuerProvName,
                                  dwTmpIssuerProvType,
                                  pwszTmpIssuerContainer);
        }
        else
        {
            PvkFreeCryptProv(hIssuerProv, wszIssuerProviderName,
                            dwIssuerProviderType, pwszTmpIssuerContainer);
        }
    }

    PvkFreeCryptProv(hSubjectProv, wszSubjectProviderName,
                    dwSubjectProviderType,pwszTmpSubjectContainer);

    if (pIssuerCertContext)
        CertFreeCertificateContext(pIssuerCertContext);
    
    if(hIssuerCertStore)
        CertCloseStore(hIssuerCertStore, 0);

    if (pSubjectCertContext)
        CertFreeCertificateContext(pSubjectCertContext);

    //pReqInfo is allocated via CryptQueryObject
    if (pReqInfo)
        LocalFree((HLOCAL)pReqInfo); 

    if (pAllocSubjectPubKeyInfo)
        MakeCertFree(pAllocSubjectPubKeyInfo);
    if (pbSubjectEncoded)
        MakeCertFree(pbSubjectEncoded);
    if (pbKeyIdEncoded)
        MakeCertFree(pbKeyIdEncoded);
    if (pbSpcSpAgencyEncoded)
        MakeCertFree(pbSpcSpAgencyEncoded);
    if (pbEKUEncoded)
        MakeCertFree(pbEKUEncoded);
    if (pbSpcCommonNameEncoded)
        MakeCertFree(pbSpcCommonNameEncoded);
    if (pbKeyUsageEncoded)
        MakeCertFree(pbKeyUsageEncoded);
    if (pbFinancialCriteria)
        MakeCertFree(pbFinancialCriteria);
    if (pbBasicConstraintsEncoded)
        MakeCertFree(pbBasicConstraintsEncoded);
    if (pbCertEncoded)
        MakeCertFree(pbCertEncoded);  
    if (rgpRequestExtensions)
    {
        for(dwExtIndex=0; dwExtIndex<dwRequestExtensions; dwExtIndex++)
        {
            if(rgpRequestExtensions[dwExtIndex])
                MakeCertFree(rgpRequestExtensions[dwExtIndex]);  
        }

        MakeCertFree(rgpRequestExtensions);
    }
    if (rgExt)
        MakeCertFree(rgExt);

    return fResult;
}

//+-------------------------------------------------------------------------
//  save the certificate to a certificate store.  Attach private key information
//  to the certificate
//--------------------------------------------------------------------------
BOOL    SaveCertToStore(
                HCRYPTPROV hProv,       DWORD dwEncodingType,
                LPWSTR wszStore,        DWORD dwFlag,
                BYTE *pbEncodedCert,    DWORD cbEncodedCert,
                LPWSTR wszPvk,          BOOL fPvkFile,
                DWORD dwKeySpecification,
                LPWSTR wszCapiProv,     DWORD dwCapiProvType)
{
        BOOL                    fResult=FALSE;
        HCERTSTORE              hStore=NULL;
        PCCERT_CONTEXT          pCertContext=NULL;
        CRYPT_KEY_PROV_INFO     KeyProvInfo;
        CRYPT_DATA_BLOB         dataBlob;
        DWORD                   cwchar;
        LPWSTR                  pwszPvkProperty=NULL;
        HRESULT                 hr=S_OK;

        HCRYPTPROV              hDefaultProvName=NULL;
        DWORD                   cbData=0;
        LPSTR                   pszName=NULL;
        LPWSTR                  pwszName=NULL;

        //init
        memset(&KeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

        //open a cert store
        hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
            dwEncodingType,
            hProv,
            CERT_STORE_NO_CRYPT_RELEASE_FLAG|dwFlag,
            wszStore);

        if(hStore==NULL)
            goto CLEANUP;

        //add the encoded certificate to store
        if(!CertAddEncodedCertificateToStore(
                    hStore,
                    X509_ASN_ENCODING,
                    pbEncodedCert,
                    cbEncodedCert,
                    CERT_STORE_ADD_REPLACE_EXISTING,
                    &pCertContext))
            goto CLEANUP;


        //if user has specified a request file, there is no need to
        //add the private key property
        if(wszSubjectRequestFile)
        {
            fResult = TRUE;
            goto CLEANUP;
        }

        //add properties to the certificate
        KeyProvInfo.pwszContainerName=wszPvk;
        KeyProvInfo.pwszProvName=wszCapiProv,
        KeyProvInfo.dwProvType=dwCapiProvType,
        KeyProvInfo.dwKeySpec=dwKeySpecification;

        //if wszCapiProv is NULL, we get the default provider name
        if(NULL==wszCapiProv)
        {
            //get the default provider
            if(CryptAcquireContext(&hDefaultProvName,
                                    NULL,
                                    NULL,
                                    KeyProvInfo.dwProvType,
                                    CRYPT_VERIFYCONTEXT))
            {

                //get the provider name
                if(CryptGetProvParam(hDefaultProvName,
                                    PP_NAME,
                                    NULL,
                                    &cbData,
                                    0) && (0!=cbData))
                {

                    if(pszName=(LPSTR)MakeCertAlloc(cbData))
                    {
                        if(CryptGetProvParam(hDefaultProvName,
                                            PP_NAME,
                                            (BYTE *)pszName,
                                            &cbData,
                                            0))
                        {
                            pwszName=MkWStr(pszName);

                            KeyProvInfo.pwszProvName=pwszName;
                        }
                    }
                }
            }
        }

        //free the provider as we want
        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        hDefaultProvName=NULL;


        if(fPvkFile)
        {
            //add the property related to private key file
            if(S_OK != (hr=ComposePvkString(&KeyProvInfo,
                                 &pwszPvkProperty,
                                 &cwchar)))
            {
                SetLastError(hr);
                goto CLEANUP;
            }

            //set up
            dataBlob.cbData=cwchar*sizeof(WCHAR);
            dataBlob.pbData=(BYTE *)pwszPvkProperty;

            if(!CertSetCertificateContextProperty(
                    pCertContext,
                    CERT_PVK_FILE_PROP_ID,
                    0,
                    &dataBlob))
                goto CLEANUP;


        }
        else
        {
            if (dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE)
                KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET;

            //add property related to the key container
            if(!CertSetCertificateContextProperty(
                    pCertContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    0,
                    &KeyProvInfo))
                goto CLEANUP;
        }

        fResult=TRUE;

CLEANUP:

        //free the cert context
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        //free the cert store
        if(hStore)
             CertCloseStore(hStore, 0);

        if(pwszPvkProperty)
              MakeCertFree(pwszPvkProperty);

        if(pszName)
            MakeCertFree(pszName);

        if(pwszName)
           FreeWStr(pwszName);

        if(hDefaultProvName)
            CryptReleaseContext(hDefaultProvName, 0);

        return fResult;

}

//+-------------------------------------------------------------------------
//  Check if the root issuer.
//--------------------------------------------------------------------------
static BOOL IsRootKey()
{
     if(IDSwcsicmp(hModule,(WCHAR *)wszIssuerKey, IDS_MAKECERT_ROOT) != 0)
         return FALSE;

     //in orde to be sure that we are using the default root, wszIssuerCertFile
     //has to NULL
     if(wszIssuerCertFile!=NULL)
         return FALSE;

     return TRUE;
}


//+-------------------------------------------------------------------------
//  Get the root's certificate from the program's resources
//--------------------------------------------------------------------------
static PCCERT_CONTEXT GetRootCertContext()
{
    PCCERT_CONTEXT  pCert = NULL;
    HRSRC           hRes;
    CHAR            szCer[10];

    //load the string CER
    if(!LoadStringA(hModule, IDS_CER, szCer, sizeof(szCer)/sizeof(szCer[0])))
    {
        IDSwprintf(hModule,IDS_ERR_LOAD_ROOT);
        return pCert;
    }


    //
    // The root certificate is stored as a resource of ours.
    // Load it...
    //
    if (0 != (hRes = FindResource(NULL, MAKEINTRESOURCE(IDR_ROOTCERTIFICATE),
                        szCer))) {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(NULL, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(NULL, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);
            if (cbRes && pbRes)
                pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pbRes, cbRes);
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (pCert == NULL)
        IDSwprintf(hModule,IDS_ERR_LOAD_ROOT);
    return pCert;
}

//+-------------------------------------------------------------------------
//  Get the root's private key from the program's resources and create
//  a temporary key provider container
//--------------------------------------------------------------------------
static HCRYPTPROV GetRootProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV      hProv = 0;
    HRSRC           hRes;
    CHAR            szPvk[10];
    WCHAR           wszRootSig[40];

    //load the string CER
    if(!LoadStringA(hModule, IDS_PVK, szPvk, sizeof(szPvk)/sizeof(szPvk[0])))
    {
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
        return hProv;
    }

    //load the string "Root Signature"
    if(!LoadStringU(hModule, IDS_ROOT_SIGNATURE, wszRootSig, sizeof(wszRootSig)/sizeof(wszRootSig[0])))
    {
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
        return hProv;
    }




    *ppwszTmpContainer = NULL;

    if (0 != (hRes = FindResource(NULL, MAKEINTRESOURCE(IDR_PVKROOT), szPvk)))
    {
        HGLOBAL hglobRes;
        if (NULL != (hglobRes = LoadResource(NULL, hRes))) {
            BYTE *pbRes;
            DWORD cbRes;

            cbRes = SizeofResource(NULL, hRes);
            pbRes = (BYTE *) LockResource(hglobRes);
            if (cbRes && pbRes) {
                PvkPrivateKeyAcquireContextFromMemory(
                    wszIssuerProviderName,
                    dwIssuerProviderType,
                    pbRes,
                    cbRes,
                    NULL,               // hwndOwner
                    wszRootSig,
                    &dwIssuerKeySpec,
                    &hProv,
                    ppwszTmpContainer
                    );
            }
            UnlockResource(hglobRes);
            FreeResource(hglobRes);
        }
    }

    if (hProv == 0)
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
    return hProv;
}

//+-------------------------------------------------------------------------
//  Get the issuer's certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT GetIssuerCertContext()
{
    if (IsRootKey())
    {
        PCCERT_CONTEXT pCert = NULL;
        wszIssuerKey=wszRoot;   

        // Get root certificate from the program's resources
        pCert=GetRootCertContext();

        wszIssuerKey=wszMakeCertRoot;

        return pCert;
    }
    else {
        PCCERT_CONTEXT pCert = NULL;
        BYTE *pb;
        DWORD cb;

        //make sure we have issuer's certificate
        if(wszIssuerCertFile)
        {

            if (S_OK==RetrieveBLOBFromFile(wszIssuerCertFile,&cb, &pb))
            {
                pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
                UnmapViewOfFile(pb);
            }
        }

        if (pCert == NULL)
            IDSwprintf(hModule,IDS_ERR_LOAD_ISSUER, wszIssuerCertFile);
        return pCert;
    }
}

//+-------------------------------------------------------------------------
//  Verify the issuer's certificate. The public key in the certificate
//  must match the public key associated with the private key in the
//  issuer's provider
//--------------------------------------------------------------------------
static BOOL VerifyIssuerKey(
    IN HCRYPTPROV hProv,
    IN PCERT_PUBLIC_KEY_INFO pIssuerKeyInfo
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    // Get issuer's public key
    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,                      
        dwIssuerKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0)
    {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwIssuerKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (!CertComparePublicKeyInfo(
            X509_ASN_ENCODING,
            pIssuerKeyInfo,
            pPubKeyInfo)) {
        // This might be the test root with an incorrectly
        // encoded public key. Convert to the capi representation and
        // compare.
        BYTE rgProvKey[256];
        BYTE rgCertKey[256];
        DWORD cbProvKey = sizeof(rgProvKey);
        DWORD cbCertKey = sizeof(rgCertKey);

        if (!CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pIssuerKeyInfo->PublicKey.pbData,
                    pIssuerKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgProvKey,
                    &cbProvKey)                             ||
            !CryptDecodeObject(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                    pPubKeyInfo->PublicKey.pbData,
                    pPubKeyInfo->PublicKey.cbData,
                    0,                  // dwFlags
                    rgCertKey,
                    &cbCertKey)                             ||
                cbProvKey == 0 || cbProvKey != cbCertKey    ||
                memcmp(rgProvKey, rgCertKey, cbProvKey) != 0) {
            IDSwprintf(hModule,IDS_ERR_MISMATCH);
            goto ErrorReturn;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pPubKeyInfo)
        MakeCertFree(pPubKeyInfo);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Get the issuer's private signature key provider
//--------------------------------------------------------------------------
static HCRYPTPROV GetIssuerProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV      hProv=0;
    WCHAR           wszIssuerSig[40];

    //load the string "Issuer Signature"
    if(!LoadStringU(hModule, IDS_ISSUER_SIGNATURE, wszIssuerSig, sizeof(wszIssuerSig)/sizeof(wszIssuerSig[0])))
    {
        IDSwprintf(hModule,IDS_ERR_ROOT_KEY);
        return NULL;
    }


    if (IsRootKey())
    {
        wszIssuerKey=wszRoot;

        // Get root key from the program's resoures and create a temporary
        // key container
        hProv = GetRootProv(ppwszTmpContainer);

        wszIssuerKey=wszMakeCertRoot;
    }
    else
    {
        // get the non-root private key set from either pvk file
        // of the key container
        if(fUseIssuerPvkFile)
        {
            if(S_OK!=PvkGetCryptProv(
                                    NULL,
                                    wszIssuerSig,
                                    wszIssuerProviderName,
                                    dwIssuerProviderType,
                                    wszIssuerKey,
                                    NULL,
                                    &dwIssuerKeySpec,
                                    ppwszTmpContainer,
                                    &hProv))
                hProv=0;
        }
        else
        {
            if(S_OK!=PvkGetCryptProv(
                                    NULL,
                                    wszIssuerSig,
                                    wszIssuerProviderName,
                                    dwIssuerProviderType,
                                    NULL,
                                    wszIssuerKey,
                                    &dwIssuerKeySpec,
                                    ppwszTmpContainer,
                                    &hProv))
                hProv=0;
        }

        if (hProv == 0)
            IDSwprintf(hModule,IDS_ERR_ISSUER_KEY, wszIssuerKey);
    }
    return hProv;
}

//+-------------------------------------------------------------------------
//  Get the subject's private key provider
//--------------------------------------------------------------------------
static HCRYPTPROV GetSubjectProv(OUT LPWSTR *ppwszTmpContainer)
{
    HCRYPTPROV  hProv=0;
    WCHAR       wszKeyName[40];
    int         ids;
    WCHAR       *wszRegKeyName=NULL;
    BOOL        fResult;
    HCRYPTKEY   hKey=NULL;
    DWORD       dwFlags = 0;
    DWORD       dwRequiredKeySpec;
    HCRYPTKEY   hPubKey;
    UUID        TmpContainerUuid;

    
    if(dwKeySpec==AT_SIGNATURE)
         ids=IDS_SUB_SIG;
    else
         ids=IDS_SUB_EXCHANGE;

    //load the string
    if(!LoadStringU(hModule, ids, wszKeyName, sizeof(wszKeyName)/sizeof(wszKeyName[0])))
        goto CreateKeyError;
    
    //try to get the hProv from either a private key file or
    //key container
    if(fUseSubjectPvkFile)
    {
        // Try to open the PVK file if it already exists:
        if(S_OK != PvkGetCryptProv(NULL,
                                   wszKeyName,
                                   wszSubjectProviderName,
                                   dwSubjectProviderType,
                                   wszSubjectKey,
                                   NULL,
                                   &dwKeySpec,
                                   ppwszTmpContainer,
                                   &hProv))
            hProv=0;
    }
    else // try to open the key container to see if it exists:
    {
        if (dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE)
        {
            // For machine keysets, we have to do all this ourselves:
            if(!CryptAcquireContextU(&hProv,
                                     wszSubjectKey,
                                     wszSubjectProviderName,
                                     dwSubjectProviderType,
                                     CRYPT_MACHINE_KEYSET))
                hProv=0;
            else
            {
                //try to figure out the key specification
                if(dwKeySpec==0)
                    dwRequiredKeySpec=AT_SIGNATURE;
                else
                    dwRequiredKeySpec=dwKeySpec;
    
                //make sure dwKeySpec is the correct key spec
                if (CryptGetUserKey(hProv,
                                    dwRequiredKeySpec,
                                    &hPubKey)) 
                {
                    CryptDestroyKey(hPubKey);
                    dwKeySpec = dwRequiredKeySpec;
                } 
                else 
                {
                    //we fail if user required another key spec
                    if(dwKeySpec != 0)
                    {
                        // Doesn't have the specified public key
                        CryptReleaseContext(hProv, 0);
                        hProv = 0;
                    }
                    else
                    {
                        //now we try AT_EXCHANGE key
                        dwRequiredKeySpec=AT_KEYEXCHANGE;
        
                        if (CryptGetUserKey(hProv,
                                            dwRequiredKeySpec,
                                            &hPubKey)) 
                        {
                            CryptDestroyKey(hPubKey);
                            dwKeySpec = dwRequiredKeySpec;
                        }
                        else
                        {
                            // Doesn't have the specified public key
                            CryptReleaseContext(hProv, 0);
                            hProv = 0;
                        }
                    }
                }
            }
        }
        else
        {
            // For user keysets we can use this function to try to acquire the key:
            if(S_OK != PvkGetCryptProv(NULL,
                                       wszKeyName,
                                       wszSubjectProviderName,
                                       dwSubjectProviderType,
                                       NULL,
                                       wszSubjectKey,
                                       &dwKeySpec,
                                       ppwszTmpContainer,
                                       &hProv))
                hProv=0;
        }
    }

    // If the keyset didn't already exist, generate a new private keyset:
    if (0 == hProv)
    {
        //now that we have to generate private keys, generate
        //AT_SIGNATURE key by default:

        if(dwKeySpec==0)
            dwKeySpec=AT_SIGNATURE;

        //when the subject PVK file is used
        if(fUseSubjectPvkFile)
        {
            // Create a temporary keyset to load the private key into
            if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
            {
                goto CreateKeyError;
            }

            if (NULL == (wszRegKeyName = (LPWSTR) MakeCertAlloc
                (((sizeof(UUID) * 2 + 1) * sizeof(WCHAR)))))
                goto CreateKeyError;

            BytesToWStr(sizeof(UUID), &TmpContainerUuid, wszRegKeyName);

            // Open a new key container
            if (!CryptAcquireContextU(
                    &hProv,
                    wszRegKeyName,
                    wszSubjectProviderName,
                    dwSubjectProviderType,
                    CRYPT_NEWKEYSET               // dwFlags
                    ))
                goto CreateKeyError;

            // generate new keys in the key container
            if (AT_KEYEXCHANGE == dwKeySpec &&
                    PROV_DSS_DH == dwSubjectProviderType) {
                if (!GenDhKey(
                        hProv,
                        CRYPT_EXPORTABLE    // dwFlags
                        ))
                    goto ErrorReturn;
            } else if (!CryptGenKey(
                hProv,
                dwKeySpec,
                (dwKeyBitLen << 16) | CRYPT_EXPORTABLE,
                &hKey
                ))
                goto CreateKeyError;
            else
                CryptDestroyKey(hKey);

            // Save the key into the file and delete from the provider
            //
            HANDLE hFile = CreateFileU(
                wszSubjectKey,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,                   // lpsa
                CREATE_NEW,
                FILE_ATTRIBUTE_NORMAL,
                NULL                    // hTemplateFile
                );

            if (hFile == INVALID_HANDLE_VALUE)
            {
                if (GetLastError() == ERROR_FILE_EXISTS)
                    IDSwprintf(hModule,IDS_ERR_SUB_FILE_EXIST, wszSubjectKey);
                else
                    IDSwprintf(hModule,IDS_ERR_SUB_FILE_CREATE, wszSubjectKey);

                fResult = FALSE;
            }
            else
            {
                dwFlags = 0;

                if (AT_KEYEXCHANGE == dwKeySpec &&
                        PROV_DSS_DH == dwSubjectProviderType &&
                        IsDh3Csp())
                    dwFlags |= CRYPT_BLOB_VER3;

                fResult = PvkPrivateKeySave(
                    hProv,
                    hFile,
                    dwKeySpec,
                    NULL,               // hwndOwner
                    wszKeyName,
                    dwFlags
                    );
            }

            //release hProv
            CryptReleaseContext(hProv, 0);

            fResult &= CryptAcquireContextU(
                            &hProv,
                            wszRegKeyName,
                            wszSubjectProviderName,
                            dwSubjectProviderType,
                            CRYPT_DELETEKEYSET);
            hProv = 0;

            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);

                if (!fResult)
                    DeleteFileU(wszSubjectKey);
            }

            if (!fResult)
                goto CreateKeyError;

            //get hProv

            if(S_OK != PvkGetCryptProv(NULL,
                                    wszKeyName,
                                    wszSubjectProviderName,
                                    dwSubjectProviderType,
                                    wszSubjectKey,
                                    NULL,
                                    &dwKeySpec,
                                    ppwszTmpContainer,
                                    &hProv))
                hProv=0;
        }
        else
        { // If we're not using a PVK file:
            // generate a machine keyset if the cert is going to the machine store
            dwFlags = CRYPT_NEWKEYSET;
            if (dwSubjectStoreFlag == CERT_SYSTEM_STORE_LOCAL_MACHINE)
                dwFlags |= CRYPT_MACHINE_KEYSET;

            // Open a new key container
            if (!CryptAcquireContextU(
                    &hProv,
                    wszSubjectKey,
                    wszSubjectProviderName,
                    dwSubjectProviderType,
                    dwFlags       // dwFlags
                    ))
            goto CreateKeyError;
            

            // Before, dwFlags contained flags for CryptAcquireContext.
            // Now these are flags to CSPGenKey
            dwFlags = 0;

            if (fPrivateKeyExportable)
                dwFlags |= CRYPT_EXPORTABLE;

            if (AT_KEYEXCHANGE == dwKeySpec &&
                    PROV_DSS_DH == dwSubjectProviderType) {
                if (!GenDhKey(
                        hProv,
                        dwFlags               // dwFlags
                        ))
                    goto ErrorReturn;
            } else if (!CryptGenKey(
                hProv,
                dwKeySpec,
                (dwKeyBitLen << 16) | dwFlags,
                &hKey
                ))
                goto CreateKeyError;
            else
                CryptDestroyKey(hKey);

            //try to get the user key
            if (CryptGetUserKey(
                hProv,
                dwKeySpec,
                &hKey
                ))
            {
                CryptDestroyKey(hKey);
            }
            else
            {
                // Doesn't have the specified public key
                CryptReleaseContext(hProv, 0);
                hProv=0;
            }
        }

        if (0 == hProv )
        {
            IDSwprintf(hModule,IDS_ERR_SUB_KEY, wszSubjectKey);
            goto ErrorReturn;
        }
    }//hProv==0

    goto CommonReturn;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    if (hProv)
    {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
CommonReturn:
    if(wszRegKeyName)
        MakeCertFree(wszRegKeyName);

    return hProv;
}



//+-------------------------------------------------------------------------
//  Allocate and get the public key info for the provider
//--------------------------------------------------------------------------
static BOOL GetPublicKey(
    HCRYPTPROV hProv,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    BOOL fResult;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        dwKeySpec,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (fNoPubKeyPara) {
        pPubKeyInfo->Algorithm.Parameters.cbData = 0;
        pPubKeyInfo->Algorithm.Parameters.pbData = NULL;
    }

    if (AT_KEYEXCHANGE == dwKeySpec && PROV_DSS_DH == dwSubjectProviderType) {
        if (!UpdateDhPublicKey(&pPubKeyInfo))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (pPubKeyInfo) {
        MakeCertFree(pPubKeyInfo);
        pPubKeyInfo = NULL;
    }
CommonReturn:
    *ppPubKeyInfo = pPubKeyInfo;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Encode the Glue Name from the input name by prepending the following
//  CERT_RDN_ATTR:
//   pszObjID       = SPC_GLUE_RDN_OBJID
//   dwValueType    = CERT_RDN_PRINTABLE_STRING
//   Value          = "Glue"
//--------------------------------------------------------------------------
static BOOL EncodeGlueName(
    IN PCERT_NAME_BLOB pName,
    OUT BYTE **ppbEncodedGlueName,
    OUT DWORD *pcbEncodedGlueName
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = NULL;
    DWORD cbNameInfo;

    CERT_NAME_INFO GlueNameInfo;
    DWORD cGlueRDN;
    PCERT_RDN pGlueRDN = NULL;

    BYTE *pbEncodedGlueName = NULL;
    DWORD cbEncodedGlueName;

    DWORD i;

    cbNameInfo = 0;
    CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            pName->pbData,
            pName->cbData,
            0,                      // dwFlags
            NULL,                   // pNameInfo
            &cbNameInfo
            );
    if (cbNameInfo == 0) goto ErrorReturn;
    if (NULL == (pNameInfo = (PCERT_NAME_INFO) MakeCertAlloc(cbNameInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            pName->pbData,
            pName->cbData,
            0,                      // dwFlags
            pNameInfo,
            &cbNameInfo)) goto ErrorReturn;

    cGlueRDN = pNameInfo->cRDN + 1;
    if (NULL == (pGlueRDN = (PCERT_RDN) MakeCertAlloc(cGlueRDN * sizeof(CERT_RDN))))
        goto ErrorReturn;

    pGlueRDN[0].cRDNAttr = 1;
    pGlueRDN[0].rgRDNAttr = &GlueRDNAttr;
    for (i = 1; i < cGlueRDN; i++)
        pGlueRDN[i] = pNameInfo->rgRDN[i - 1];
    GlueNameInfo.cRDN = cGlueRDN;
    GlueNameInfo.rgRDN = pGlueRDN;

    cbEncodedGlueName = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            &GlueNameInfo,
            NULL,                   // pbEncodedGlueName
            &cbEncodedGlueName
            );
    if (cbEncodedGlueName == 0) goto ErrorReturn;
    if (NULL == (pbEncodedGlueName = (BYTE *) MakeCertAlloc(cbEncodedGlueName)))
        goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
            &GlueNameInfo,
            pbEncodedGlueName,
            &cbEncodedGlueName)) goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncodedGlueName) {
        MakeCertFree(pbEncodedGlueName);
        pbEncodedGlueName = NULL;
    }
    cbEncodedGlueName = 0;
    fResult = FALSE;
CommonReturn:
    if (pNameInfo)
        MakeCertFree(pNameInfo);
    if (pGlueRDN)
        MakeCertFree(pGlueRDN);

    *ppbEncodedGlueName = pbEncodedGlueName;
    *pcbEncodedGlueName = cbEncodedGlueName;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Get the subject's cert context and encoded name
//--------------------------------------------------------------------------
static BOOL GetRequestInfo(OUT CERT_REQUEST_INFO **ppCertInfo)
{
    BOOL fResult = FALSE;

    fResult = CryptQueryObject(
                    CERT_QUERY_OBJECT_FILE,
                    wszSubjectRequestFile,
                    CERT_QUERY_CONTENT_FLAG_PKCS10,
                    CERT_QUERY_FORMAT_FLAG_ALL,
                    CRYPT_DECODE_ALLOC_FLAG,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    (const void **)ppCertInfo);

    return fResult;

}



//+-------------------------------------------------------------------------
//  GetExtensionsFromRequest
//
//      We get all the requested extensions from the PKCS10 request
//--------------------------------------------------------------------------
BOOL GetExtensionsFromRequest(PCERT_REQUEST_INFO  pReqInfo, DWORD *pdwCount, PCERT_EXTENSIONS **pprgExtensions)
{
    DWORD               dwIndex = 0;
    BOOL                fResult = FALSE;
    PCRYPT_ATTRIBUTE    pAttr=NULL;
    DWORD               cbData=0;

    *pdwCount =0;
    *pprgExtensions=NULL;

    if(!pReqInfo)
        goto CLEANUP;

    // Look for the RSA extension OID first:
    for(dwIndex=0; dwIndex < pReqInfo->cAttribute; dwIndex++)
    {
        if(0 == strcmp((pReqInfo->rgAttribute[dwIndex]).pszObjId, szOID_RSA_certExtensions))
            break;
    }

    if( dwIndex == pReqInfo->cAttribute)
    {
        // We could not find the RSA OID. Try the old Microsoft OID next:
        for(dwIndex=0; dwIndex < pReqInfo->cAttribute; dwIndex++)
        {
            if(0 == strcmp((pReqInfo->rgAttribute[dwIndex]).pszObjId, SPC_CERT_EXTENSIONS_OBJID))
                break;
        }
        if( dwIndex == pReqInfo->cAttribute)
        {
            // We could not find the requested extensions.
            fResult = TRUE;
            goto CLEANUP;
        }
    }

    pAttr=&(pReqInfo->rgAttribute[dwIndex]);

    if(0 == pAttr->cValue)
    {
        fResult=TRUE;
        goto CLEANUP;
    }

    *pprgExtensions = (PCERT_EXTENSIONS *)MakeCertAlloc((pAttr->cValue) * sizeof(PCERT_EXTENSIONS));

    if(NULL == (*pprgExtensions))
        goto CLEANUP;

    memset(*pprgExtensions, 0, (pAttr->cValue) * sizeof(PCERT_EXTENSIONS));

    for(dwIndex=0; dwIndex<pAttr->cValue; dwIndex++)
    {
        cbData = 0;
        if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            X509_EXTENSIONS,
                            pAttr->rgValue[dwIndex].pbData,
                            pAttr->rgValue[dwIndex].cbData,
                            0,
                            NULL,
                            &cbData))
            goto CLEANUP;

        (*pprgExtensions)[dwIndex]=(PCERT_EXTENSIONS)MakeCertAlloc(cbData);

        if(NULL == (*pprgExtensions)[dwIndex])
            goto CLEANUP;

        if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                            X509_EXTENSIONS,
                            pAttr->rgValue[dwIndex].pbData,
                            pAttr->rgValue[dwIndex].cbData,
                            0,
                            (*pprgExtensions)[dwIndex],
                            &cbData))
            goto CLEANUP;
    } 

    *pdwCount=pAttr->cValue; 

    fResult = TRUE;

CLEANUP:

    if(FALSE == fResult)
    {
       //we need to free the memory
        if(*pprgExtensions)
        {
            for(dwIndex=0; dwIndex<pAttr->cValue; dwIndex++)
            {
                if((*pprgExtensions)[dwIndex])
                    MakeCertFree((*pprgExtensions)[dwIndex]);
            } 

            MakeCertFree(*pprgExtensions);
            *pprgExtensions = NULL;
        }

        *pdwCount=0;
    }

    return fResult;

}




//+-------------------------------------------------------------------------
//  Get the subject's cert context and encoded name
//--------------------------------------------------------------------------
static BOOL GetSubject(
    OUT PCCERT_CONTEXT *ppCertContext,
    OUT BYTE **ppbEncodedName,
    OUT DWORD *pcbEncodedName
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pb;
    DWORD cb;
    BYTE *pbEncodedName = NULL;
    DWORD cbEncodedName;

    if (S_OK==RetrieveBLOBFromFile(wszSubjectCertFile,&cb, &pb))
    {
        pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
        UnmapViewOfFile(pb);
    }
    if (pCert == NULL)
        goto BadFile;

    if (0 == (cbEncodedName = pCert->pCertInfo->Subject.cbData))
        goto BadFile;
    if (fGlueCert ) {
        if (!EncodeGlueName(
                &pCert->pCertInfo->Subject,
                &pbEncodedName,
                &cbEncodedName))
            goto ErrorReturn;
    } else {
        if (NULL == (pbEncodedName = (BYTE *) MakeCertAlloc(cbEncodedName)))
            goto ErrorReturn;
        memcpy(pbEncodedName, pCert->pCertInfo->Subject.pbData, cbEncodedName);
    }

    fResult = TRUE;
    goto CommonReturn;

BadFile:
    IDSwprintf(hModule, IDS_ERR_CANNOT_LOAD_SUB_CERT,
        wszSubjectCertFile);
ErrorReturn:
    if (pbEncodedName) {
        MakeCertFree(pbEncodedName);
        pbEncodedName = NULL;
    }
    cbEncodedName = 0;
    if (pCert) {
        CertFreeCertificateContext(pCert);
        pCert = NULL;
    }
    fResult = FALSE;
CommonReturn:
    *ppCertContext = pCert;
    *ppbEncodedName = pbEncodedName;
    *pcbEncodedName = cbEncodedName;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert and encode the subject's X500 formatted name
//--------------------------------------------------------------------------
static BOOL EncodeSubject(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL            fResult;
    DWORD           cbEncodedSubject=0;
    BYTE            *pbEncodedSubject=NULL;
    BYTE            *pbEncoded = NULL;
    DWORD           cbEncoded;

    CERT_NAME_BLOB  SubjectInfo;

    //encode the wszSubjectX500Name into an encoded X509_NAME
    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        wszSubjectX500Name,
        CERT_NAME_STR_REVERSE_FLAG,
        NULL,
        NULL,
        &cbEncodedSubject,
        NULL))
    {
        PrintLastError(IDS_CERT_STR_TO_NAME);
        goto ErrorReturn;
    }

    pbEncodedSubject = (BYTE *) MakeCertAlloc(cbEncodedSubject);
    if (pbEncodedSubject == NULL) goto ErrorReturn; 

    if(!CertStrToNameW(
        X509_ASN_ENCODING,
        wszSubjectX500Name,
        CERT_NAME_STR_REVERSE_FLAG,
        NULL,
        pbEncodedSubject,
        &cbEncodedSubject,
        NULL))
    {
        PrintLastError(IDS_CERT_STR_TO_NAME);
        goto ErrorReturn;
    }

    SubjectInfo.cbData=cbEncodedSubject;
    SubjectInfo.pbData=pbEncodedSubject;


    //add the GLUE CDRT_RDN_ATTR
    if (fGlueCert)
    {
        if(!EncodeGlueName(&SubjectInfo,
            &pbEncoded,
            &cbEncoded))
            goto ErrorReturn;
    }
    else
    {
        cbEncoded=cbEncodedSubject;
        pbEncoded=pbEncodedSubject;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    //we need to free the memory for pbEncodedSubject for GlueCert
    if(fGlueCert)
    {
        if(pbEncodedSubject)
        {
            MakeCertFree(pbEncodedSubject);
            pbEncodedSubject=NULL;
        }
    }   
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


// The test root's public key isn't encoded properly in the certificate.
// It's missing a leading zero to make it a unsigned integer.
static BYTE rgbTestRoot[] = {
    #include "root.h"
};
static CERT_PUBLIC_KEY_INFO TestRootPublicKeyInfo = {
    szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0
};

static BYTE rgbTestRootInfoAsn[] = {
    #include "rootasn.h"
};

//+-------------------------------------------------------------------------
//  X509 Extensions: Allocate and Encode functions
//--------------------------------------------------------------------------
static BOOL CreateAuthorityKeyId(
        IN HCRYPTPROV hProv,
        IN PCERT_INFO pIssuerCert,
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_AUTHORITY_KEY_ID_INFO KeyIdInfo;
#define MAX_HASH_LEN  20
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;

    // Issuer's KeyId: MD5 hash of the encoded issuer's public key info

    // First check if the issuer is the test root with an incorrectly
    // encoded public key.
    if (CertComparePublicKeyInfo(
            X509_ASN_ENCODING,
            &pIssuerCert->SubjectPublicKeyInfo,
            &TestRootPublicKeyInfo
            )) {
        if (!CryptHashCertificate(
                hProv,
                CALG_MD5,
                0,                  // dwFlags
                rgbTestRootInfoAsn,
                sizeof(rgbTestRootInfoAsn),
                rgbHash,
                &cbHash)) {
            PrintLastError(IDS_CRYPT_HASH_CERT);
            goto ErrorReturn;
        }
    } else {
        if (!CryptHashPublicKeyInfo(
                hProv,
                CALG_MD5,
                0,                  // dwFlags
                X509_ASN_ENCODING,
                &pIssuerCert->SubjectPublicKeyInfo,
                rgbHash,
                &cbHash)) {
            PrintLastError(IDS_CRYPT_HASP_PUB);
            goto ErrorReturn;
        }
    }
    KeyIdInfo.KeyId.pbData = rgbHash;
    KeyIdInfo.KeyId.cbData = cbHash;

    // Issuer's Issuer
    KeyIdInfo.CertIssuer = pIssuerCert->Issuer;

    // Issuer's SerialNumber
    KeyIdInfo.CertSerialNumber = pIssuerCert->SerialNumber;

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_AUTHORITY_KEY_ID,
            &KeyIdInfo,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_AUTH_KEY);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_AUTHORITY_KEY_ID,
            &KeyIdInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_AUTH_KEY);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreateSpcSpAgency(
        OUT BYTE **ppbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    SPC_LINK PolicyLink;
    SPC_SP_AGENCY_INFO AgencyInfo;

    memset(&AgencyInfo, 0, sizeof(AgencyInfo));

    if (wszPolicyLink) {
        PolicyLink.dwLinkChoice = SPC_URL_LINK_CHOICE;
        PolicyLink.pwszUrl = wszPolicyLink;
        AgencyInfo.pPolicyInformation = &PolicyLink;
    }


    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING,
                      SPC_SP_AGENCY_INFO_OBJID,
                      &AgencyInfo,
                      NULL,           // pbEncoded
                      &cbEncoded);
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_SPC_AGENCY);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, SPC_SP_AGENCY_INFO_STRUCT,
            &AgencyInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_SPC_AGENCY);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded)
    {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static BOOL CreateEnhancedKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL               fResult = FALSE;
    LPBYTE             pbEncoded =NULL;
    DWORD              cbEncoded =0;
    DWORD              cCount =0;
    LPSTR              psz=NULL;
    LPSTR              pszTok=NULL;
    DWORD              cTok = 0;
    PCERT_ENHKEY_USAGE pUsage =NULL;
    LPSTR              pszCodeSigning = szOID_PKIX_KP_CODE_SIGNING;    
    BOOL               fFound=FALSE;

    if(wszEKUOids)
    {
        if ( WSZtoSZ(wszEKUOids, &psz) != S_OK )
            goto CLEANUP;

        //
        // Count the number of OIDs as well as converting from comma delimited
        // to NULL character delimited
        //

        pszTok = strtok(psz, ",");
        while ( pszTok != NULL )
        {
            cTok++;
            pszTok = strtok(NULL, ",");
        }

        //
        // Allocate a cert enhanced key usage structure and fill it in with
        // the string tokens
        //
        // we allocate one more string for the code signing OIDs
        //

        pUsage = (PCERT_ENHKEY_USAGE)new BYTE [sizeof(CERT_ENHKEY_USAGE) + ( (cTok + 1) * sizeof(LPSTR) )];

        if(NULL == pUsage)
            goto CLEANUP;

        pszTok = psz;
        pUsage->cUsageIdentifier = cTok;
        pUsage->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage+sizeof(CERT_ENHKEY_USAGE));

        for ( cCount = 0; cCount < cTok; cCount++ )
        {
            pUsage->rgpszUsageIdentifier[cCount] = pszTok;
            pszTok = pszTok+strlen(pszTok)+1;
        }

        //we add the code signing OID if use has specified commerical or individual signing
        if(fCertCommercial || fCertIndividual)
        {
            //check to see if the code signing OID is alreayd present
            for(cCount = 0; cCount < pUsage->cUsageIdentifier; cCount++)
            {
                if(0 == strcmp(pszCodeSigning,pUsage->rgpszUsageIdentifier[cCount]))
                {
                    fFound=TRUE;
                    break;
                }
            }

            if(FALSE == fFound)
            {
                (pUsage->rgpszUsageIdentifier)[pUsage->cUsageIdentifier] = pszCodeSigning;
                (pUsage->cUsageIdentifier)++ ;
            }
        }
    }
    else
    {
        if(fCertCommercial || fCertIndividual)
        {

            pUsage = (PCERT_ENHKEY_USAGE)new BYTE [sizeof(CERT_ENHKEY_USAGE)];

            if(NULL == pUsage)
                goto CLEANUP;

            pUsage->cUsageIdentifier = 1;
            pUsage->rgpszUsageIdentifier = &pszCodeSigning;
        }
        else
        {
            goto CLEANUP;
        }
    }

    //
    // Encode the usage
    //

    if(!CryptEncodeObject(
                   X509_ASN_ENCODING,
                   szOID_ENHANCED_KEY_USAGE,
                   pUsage,
                   NULL,
                   &cbEncoded
                   ))
        goto CLEANUP;

    pbEncoded = new BYTE [cbEncoded];

    if(NULL == pbEncoded)
        goto CLEANUP;

    fResult = CryptEncodeObject(
                   X509_ASN_ENCODING,
                   szOID_ENHANCED_KEY_USAGE,
                   pUsage,
                   pbEncoded,
                   &cbEncoded
                   );

    //
    // Cleanup
    //

CLEANUP:

    if(pUsage)
        delete[] pUsage;

    if(psz)
        MakeCertFree(psz);

    if ( TRUE == fResult)
    {
        *ppbEncoded = pbEncoded;
        *pcbEncoded = cbEncoded;
    }
    else
    {
        if(pbEncoded)
            delete[] pbEncoded;
    }

    return  fResult;
}


static BOOL CreateKeyUsage(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_USAGE_RESTRICTION_INFO KeyUsageInfo;
    BYTE bRestrictedKeyUsage;
    DWORD cCertPolicyId;

    LPSTR rgpszIndividualCertPolicyElementId[1] = {
        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID
    };
    LPSTR rgpszCommercialCertPolicyElementId[1] = {
        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID
    };
    CERT_POLICY_ID rgCertPolicyId[2];

    memset(&KeyUsageInfo, 0, sizeof(KeyUsageInfo));

    bRestrictedKeyUsage = CERT_DIGITAL_SIGNATURE_KEY_USAGE;
    KeyUsageInfo.RestrictedKeyUsage.pbData = &bRestrictedKeyUsage;
    KeyUsageInfo.RestrictedKeyUsage.cbData = 1;
    KeyUsageInfo.RestrictedKeyUsage.cUnusedBits = 7;

    cCertPolicyId = 0;
    if (fCertIndividual) {
        rgCertPolicyId[cCertPolicyId].cCertPolicyElementId = 1;
        rgCertPolicyId[cCertPolicyId].rgpszCertPolicyElementId =
            rgpszIndividualCertPolicyElementId;
        cCertPolicyId++;
    }
    if (fCertCommercial) {
        rgCertPolicyId[cCertPolicyId].cCertPolicyElementId = 1;
        rgCertPolicyId[cCertPolicyId].rgpszCertPolicyElementId =
            rgpszCommercialCertPolicyElementId;
        cCertPolicyId++;
    }

    if (cCertPolicyId > 0) {
        KeyUsageInfo.cCertPolicyId = cCertPolicyId;
        KeyUsageInfo.rgCertPolicyId = rgCertPolicyId;
    }

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_KEY_USAGE_RESTRICTION,
            &KeyUsageInfo,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_KEY_USAGE);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_KEY_USAGE_RESTRICTION,
            &KeyUsageInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_KEY_USAGE);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}


static BOOL CreateBasicConstraints(
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_BASIC_CONSTRAINTS2_INFO Info2;

    memset(&Info2, 0, sizeof(Info2));
    if (certTypes == 0)
        certTypes = CERT_END_ENTITY_SUBJECT_FLAG;

    if (CERT_CA_SUBJECT_FLAG & certTypes)
    {
        Info2.fCA = TRUE;
    }

    if (pathLenConstraint < 0) {
        Info2.fPathLenConstraint = FALSE;
    } else {
        Info2.fPathLenConstraint = TRUE;
        Info2.dwPathLenConstraint = pathLenConstraint;
    }

    cbEncoded = 0;
    CryptEncodeObject(X509_ASN_ENCODING, X509_BASIC_CONSTRAINTS2,
            &Info2,
            NULL,           // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError(IDS_ENCODE_BASIC_CONSTRAINTS2);
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(X509_ASN_ENCODING, X509_BASIC_CONSTRAINTS2,
            &Info2,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError(IDS_ENCODE_BASIC_CONSTRAINTS2);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        MakeCertFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}



//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//-----------------------------------------------------------------------
//
// Get the hash from a cert file
//
//--------------------------------------------------------------------------
HRESULT GetCertHashFromFile(LPWSTR  pwszCertFile,
                            BYTE    **ppHash,
                            DWORD   *pcbHash,
                            BOOL    *pfMore)
{
    HRESULT         hr;
    HCERTSTORE      hCertStore=NULL;
    PCCERT_CONTEXT  pSigningCert=NULL;
    PCCERT_CONTEXT  pPreCert=NULL;
    PCCERT_CONTEXT  pDupCert=NULL;
    DWORD           dwCount=0;

    if(!ppHash || !pcbHash || !pfMore)
        return E_INVALIDARG;

    //init
    *pcbHash=0;
    *ppHash=NULL;
    *pfMore=FALSE;
    
    //open a cert store
    hCertStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
                        dwCertStoreEncodingType,
                        NULL,
                        0,
                        pwszCertFile);

    if(hCertStore==NULL)
    {
        hr=SignError();
        goto CLEANUP;
    }

    while(pDupCert=CertEnumCertificatesInStore(hCertStore,
                                        pPreCert))
    {
        dwCount++;

        // Fail if there is more than one cert in the store
        if(dwCount > 1)
        {
            CertFreeCertificateContext(pDupCert);
            pDupCert=NULL;
            CertFreeCertificateContext(pSigningCert);
            pSigningCert=NULL;

            *pfMore=TRUE;
            hr=E_FAIL;
            goto CLEANUP;
        }

        pPreCert=pDupCert;

        pSigningCert=CertDuplicateCertificateContext(pDupCert);

    }

    if(pSigningCert==NULL)
    {
        hr=CRYPT_E_NO_DECRYPT_CERT;
        goto CLEANUP;
    }

    //get the hash
    if(!CertGetCertificateContextProperty(pSigningCert,
                        CERT_SHA1_HASH_PROP_ID,
                        NULL,
                        pcbHash))
    {
        hr=SignError();
        goto CLEANUP;
    }

    *ppHash=(BYTE *)ToolUtlAlloc(*pcbHash);
    if(!(*ppHash))
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    if(!CertGetCertificateContextProperty(pSigningCert,
                        CERT_SHA1_HASH_PROP_ID,
                        *ppHash,
                        pcbHash))
    {
        hr=SignError();
        goto CLEANUP;
    }

    hr=S_OK;

CLEANUP:

    if(pSigningCert)
        CertFreeCertificateContext(pSigningCert);

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hr!=S_OK)
    {
        if(*ppHash)
        {
          ToolUtlFree(*ppHash);
          *ppHash=NULL;
        }

    }

    return hr;
}



//-----------------------------------------------------------------------
//
// Get the signing certificate
//
//--------------------------------------------------------------------------
PCCERT_CONTEXT  GetIssuerCertAndStore(HCERTSTORE *phCertStore, BOOL *pfMore)
{                   
    PCCERT_CONTEXT  pSigningCert=NULL;
    PCCERT_CONTEXT  pPreCert=NULL;  
    PCCERT_CONTEXT  pDupCert=NULL;
    BYTE            *pHash=NULL;
    DWORD           cbHash;
    HCERTSTORE      hCertStore=NULL;
    CRYPT_HASH_BLOB HashBlob;
    DWORD           dwCount=0;

    //init the output
    if(!phCertStore || !pfMore)
        return NULL;

    *phCertStore=NULL;
    *pfMore=FALSE;

    //open a cert store
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                        dwCertStoreEncodingType,
                        NULL,
                        dwIssuerStoreFlag|CERT_STORE_READONLY_FLAG,
                        wszIssuerStore);

    if(!hCertStore)
        return NULL;


    //get the hash of the certificate.  Find the cert based on
    //pwszCertFile
    if(wszIssuerCertFile)
    {
        if(S_OK != GetCertHashFromFile(wszIssuerCertFile, &pHash, &cbHash, pfMore))
            goto CLEANUP;
        
        HashBlob.cbData=cbHash;
        HashBlob.pbData=pHash;

        pSigningCert=CertFindCertificateInStore(hCertStore,
                            X509_ASN_ENCODING,
                            0,
                            CERT_FIND_SHA1_HASH,
                            &HashBlob,
                            NULL);
    }
    else
    {
        //find the certificate with the common name
        if(wszIssuerCertName)
        {
            while(pDupCert=CertFindCertificateInStore(hCertStore,
                                X509_ASN_ENCODING,
                                0,
                                CERT_FIND_SUBJECT_STR_W,
                                wszIssuerCertName,
                                pPreCert))
            {
                dwCount++;

                if(dwCount > 1)
                {
                    CertFreeCertificateContext(pDupCert);
                    pDupCert=NULL;
                    CertFreeCertificateContext(pSigningCert);
                    pSigningCert=NULL;

                    *pfMore=TRUE;
                    goto CLEANUP;
                }

                pPreCert=pDupCert;

                pSigningCert=CertDuplicateCertificateContext(pDupCert);

            }
            
        }
        else
        {
            //no searching criteria, find the only cert in the store
            while(pDupCert=CertEnumCertificatesInStore(hCertStore,
                                        pPreCert))
            {
                dwCount++;

                if(dwCount > 1)
                {
                    CertFreeCertificateContext(pDupCert);
                    pDupCert=NULL;
                    CertFreeCertificateContext(pSigningCert);
                    pSigningCert=NULL;

                    *pfMore=TRUE;
                    goto CLEANUP;
                }

                pPreCert=pDupCert;

                pSigningCert=CertDuplicateCertificateContext(pDupCert);

            }
            
        }
    }
CLEANUP:

    if(pHash)
        ToolUtlFree(pHash);

    if(pSigningCert)
    {
       *phCertStore=hCertStore;
    }
    else
    {
        //free the hCertStore
        CertCloseStore(hCertStore, 0);
    }

    return pSigningCert;

}


//-----------------------------------------------------------------------
//
// EmptySubject
//
//--------------------------------------------------------------------------
BOOL    EmptySubject(CERT_NAME_BLOB *pSubject)
{
    BOOL                fEmpty = TRUE;
    CERT_NAME_INFO      *pCertNameInfo=NULL;
    DWORD               cbData =0;
    
    if(!pSubject)
        goto CLEANUP;

    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_UNICODE_NAME,
                          pSubject->pbData, 
                          pSubject->cbData,
                          0,
                          NULL,
                          &cbData))
        goto CLEANUP;


    pCertNameInfo = (CERT_NAME_INFO  *)MakeCertAlloc(cbData);
    if(NULL == pCertNameInfo)
        goto CLEANUP;

    if(!CryptDecodeObject(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                          X509_UNICODE_NAME,
                          pSubject->pbData, 
                          pSubject->cbData,
                          0,
                          pCertNameInfo,
                          &cbData))
        goto CLEANUP;

    if((pCertNameInfo->cRDN) > 0)
        fEmpty = FALSE;

CLEANUP:

    if(pCertNameInfo)
        MakeCertFree(pCertNameInfo);    

    return fEmpty;

}



//+=========================================================================
// Support functions to generate DH keys having the 'Q'parameter
//==========================================================================

static BOOL EncodeAndAllocObject(
    IN LPCSTR       lpszStructType,
    IN const void   *pvStructInfo,
    OUT BYTE        **ppbEncoded,
    IN OUT DWORD    *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded = 0;

    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            NULL,
            &cbEncoded
            ))
        goto ErrorReturn;
    if (NULL == (pbEncoded = (BYTE *) MakeCertAlloc(cbEncoded)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = TRUE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    MakeCertFree(pbEncoded);
    pbEncoded = NULL;
    goto CommonReturn;
}

static BOOL DecodeAndAllocObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT void        **ppvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    )
{
    BOOL fResult;
    void *pvStructInfo = NULL;
    DWORD cbStructInfo = 0;

    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            NULL,
            &cbStructInfo
            ))
        goto ErrorReturn;
    if (NULL == (pvStructInfo = MakeCertAlloc(cbStructInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

    fResult = TRUE;

CommonReturn:
    *ppvStructInfo = pvStructInfo;
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    MakeCertFree(pvStructInfo);
    pvStructInfo = NULL;
    goto CommonReturn;
}

static BYTE rgbDhQ[21];
static CRYPT_UINT_BLOB DhQ = {0, NULL};

static BOOL GetDhParaFromCertFile(
    OUT PCERT_X942_DH_PARAMETERS *ppX942DhPara
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pDhCert = NULL;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;

    BYTE *pb;
    DWORD cb;

    if (S_OK == RetrieveBLOBFromFile(wszDhParaCertFile, &cb, &pb)) {
        pDhCert = CertCreateCertificateContext(X509_ASN_ENCODING, pb, cb);
        UnmapViewOfFile(pb);
    }
    if (pDhCert == NULL)
        goto DhParaCertFileError;

    if (!DecodeAndAllocObject(
            X942_DH_PARAMETERS,
            pDhCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pDhCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
            (void **) &pX942DhPara,
            &cb
            ))
        goto DhParaCertFileError;

    fResult = TRUE;
CommonReturn:
    CertFreeCertificateContext(pDhCert);
    *ppX942DhPara = pX942DhPara;
    return fResult;

DhParaCertFileError:
    IDSwprintf(hModule, IDS_ERR_DH_PARA_FILE, wszDhParaCertFile);
    MakeCertFree(pX942DhPara);
    pX942DhPara = NULL;
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL GetDhParaFromDssKey(
    OUT PCERT_DSS_PARAMETERS *ppDssPara
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    WCHAR *wszRegKeyName = NULL;
    UUID TmpContainerUuid;
    PCERT_DSS_PARAMETERS pDssPara = NULL;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD cbDssPara;

    // Create a temporary keyset to load the private key into
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto CreateKeyError;
    }

    if (NULL == (wszRegKeyName = (LPWSTR) MakeCertAlloc
        (((sizeof(UUID) * 2 + 1) * sizeof(WCHAR)))))
        goto CreateKeyError;

    BytesToWStr(sizeof(UUID), &TmpContainerUuid, wszRegKeyName);

    // Open a new key container
    if (!CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_NEWKEYSET               // dwFlags
            )) {
        hProv = 0;
        goto CreateKeyError;
    }

    if (0 == dwKeyBitLen)
        dwKeyBitLen = 512;
    
    // generate new DSS key in the key container
    if (!CryptGenKey(
            hProv,
            AT_SIGNATURE,
            (dwKeyBitLen << 16) | CRYPT_EXPORTABLE,
            &hKey
            ))
        goto CreateKeyError;
    else
        CryptDestroyKey(hKey);

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        AT_SIGNATURE,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (!DecodeAndAllocObject(
            X509_DSS_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData,
            (void **) &pDssPara,
            &cbDssPara
            ))
        goto CreateKeyError;

    // Save away the DSS 'Q' parameter. It will be used in GetPublicKey()
    // to update the DH parameters in the PublicKeyInfo
    if (pDssPara->q.cbData <= sizeof(rgbDhQ)) {
        memcpy(rgbDhQ, pDssPara->q.pbData, pDssPara->q.cbData);
        DhQ.cbData = pDssPara->q.cbData;
        DhQ.pbData = rgbDhQ;
    }

    fResult = TRUE;
CommonReturn:
    if (hProv) {
        // Delete the just created DSS key
        CryptReleaseContext(hProv, 0);
        CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_DELETEKEYSET
            );
    }
    MakeCertFree(wszRegKeyName);
    MakeCertFree(pPubKeyInfo);

    *ppDssPara = pDssPara;
    return fResult;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    MakeCertFree(pDssPara);
    pDssPara = NULL;
    fResult = FALSE;
    goto CommonReturn;
}

#ifndef DH3
#define DH3 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'3'<<24))
#endif

static BOOL CreateDh3PubKeyStruc(
    IN PCERT_X942_DH_PARAMETERS pX942DhPara,
    OUT PUBLICKEYSTRUC **ppPubKeyStruc,
    OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DHPUBKEY_VER3 *pCspPubKey;
    BYTE *pbKey;

    DWORD cbP;
    DWORD cbQ;
    DWORD cbJ;
    DWORD cb;

    cbP = pX942DhPara->p.cbData;
    cbQ = pX942DhPara->q.cbData;
    cbJ = pX942DhPara->j.cbData;

    if (0 == cbQ) {
        *ppPubKeyStruc = NULL;
        *pcbPubKeyStruc = 0;
        return TRUE;
    }

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY_VER3
    //  - rgbP[cbP]
    //  - rgbQ[cbQ]
    //  - rgbG[cbP]
    //  - rgbJ[cbJ] -- optional
    //  - rgbY[cbP] -- will be omitted here

    cbPubKeyStruc = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3) +
        cbP + cbQ + cbP + cbJ;

    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) MakeCertAlloc(
            cbPubKeyStruc)))
        goto ErrorReturn;
    memset(pPubKeyStruc, 0, cbPubKeyStruc);

    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY_VER3 *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY_VER3);

    pPubKeyStruc->bType = PUBLICKEYBLOB;
    pPubKeyStruc->bVersion = 3;
    pPubKeyStruc->aiKeyAlg = CALG_DH_SF;
    pCspPubKey->magic = DH3;
    pCspPubKey->bitlenP = cbP * 8;
    pCspPubKey->bitlenQ = cbQ * 8;
    pCspPubKey->bitlenJ = cbJ * 8;

    pCspPubKey->DSSSeed.counter = 0xFFFFFFFF;
    if (pX942DhPara->pValidationParams) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;

        pValidationParams = pX942DhPara->pValidationParams;
        if (0 != pValidationParams->pgenCounter &&
                sizeof(pCspPubKey->DSSSeed.seed) ==
                    pValidationParams->seed.cbData) {
            pCspPubKey->DSSSeed.counter =
                pValidationParams->pgenCounter;
            memcpy(pCspPubKey->DSSSeed.seed,
                pValidationParams->seed.pbData,
                sizeof(pCspPubKey->DSSSeed.seed));
        }
    }

    // rgbP[cbP]
    memcpy(pbKey, pX942DhPara->p.pbData, cbP);
    pbKey += cbP;

    // rgbQ[cbQ]
    memcpy(pbKey, pX942DhPara->q.pbData, cbQ);
    pbKey += cbQ;

    // rgbG[cbP]
    cb = pX942DhPara->g.cbData;
    if (0 == cb || cb > cbP)
        goto ErrorReturn;
    memcpy(pbKey, pX942DhPara->g.pbData, cb);
    if (cbP > cb)
        memset(pbKey + cb, 0, cbP - cb);
    pbKey += cbP;

    // rgbJ[cbJ]
    if (cbJ) {
        memcpy(pbKey, pX942DhPara->j.pbData, cbJ);
        pbKey += cbJ;
    }

    fResult = TRUE;

CommonReturn:
    *ppPubKeyStruc = pPubKeyStruc;
    *pcbPubKeyStruc = cbPubKeyStruc;
    return fResult;
ErrorReturn:
    MakeCertFree(pPubKeyStruc);
    pPubKeyStruc = NULL;
    cbPubKeyStruc = 0;
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL IsDh3Csp()
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    WCHAR *wszRegKeyName = NULL;
    UUID TmpContainerUuid;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;
    DWORD cbX942DhPara;

    // Create a temporary keyset to load the private key into
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto CreateKeyError;
    }

    if (NULL == (wszRegKeyName = (LPWSTR) MakeCertAlloc
        (((sizeof(UUID) * 2 + 1) * sizeof(WCHAR)))))
        goto CreateKeyError;

    BytesToWStr(sizeof(UUID), &TmpContainerUuid, wszRegKeyName);

    // Open a new key container
    if (!CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_NEWKEYSET               // dwFlags
            )) {
        hProv = 0;
        goto CreateKeyError;
    }

    // generate new DH key in the key container
    if (!CryptGenKey(
            hProv,
            AT_KEYEXCHANGE,
            (512 << 16) | CRYPT_EXPORTABLE,
            &hKey
            ))
        goto CreateKeyError;
    else
        CryptDestroyKey(hKey);

    cbPubKeyInfo = 0;
    CryptExportPublicKeyInfo(
        hProv,
        AT_KEYEXCHANGE,
        X509_ASN_ENCODING,
        NULL,               // pPubKeyInfo
        &cbPubKeyInfo
        );
    if (cbPubKeyInfo == 0) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }
    if (NULL == (pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) MakeCertAlloc(cbPubKeyInfo)))
        goto ErrorReturn;
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_KEYEXCHANGE,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            &cbPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (!DecodeAndAllocObject(
            X942_DH_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData,
            (void **) &pX942DhPara,
            &cbX942DhPara
            ))
        goto CreateKeyError;

    if (pX942DhPara->q.cbData)
        // Q para is only supported in Dh3 version of CSP
        fResult = TRUE;
    else
        fResult = FALSE;
CommonReturn:
    if (hProv) {
        // Delete the just created DH key
        CryptReleaseContext(hProv, 0);
        CryptAcquireContextU(
            &hProv,
            wszRegKeyName,
            wszSubjectProviderName,
            dwSubjectProviderType,
            CRYPT_DELETEKEYSET
            );
    }
    MakeCertFree(wszRegKeyName);
    MakeCertFree(pX942DhPara);
    MakeCertFree(pPubKeyInfo);

    return fResult;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL GenDhKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HCRYPTKEY hKey = 0;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;
    PCERT_DSS_PARAMETERS pDssPara = NULL;

    PCRYPT_UINT_BLOB pP;
    PCRYPT_UINT_BLOB pG;
    DWORD cbP;

    PUBLICKEYSTRUC *pDh3PubKeyStruc = NULL;
    DWORD cbDh3PubKeyStruc;
    BOOL fSetKeyPara;

    if (wszDhParaCertFile) {
        if (!GetDhParaFromCertFile(&pX942DhPara))
            goto ErrorReturn;

        CreateDh3PubKeyStruc(pX942DhPara, &pDh3PubKeyStruc, &cbDh3PubKeyStruc);

        pP = &pX942DhPara->p;
        pG = &pX942DhPara->g;
    } else if (dwKeyBitLen > 1024 || IsDh3Csp()) {
        // generate new keys in the key container
        if (!CryptGenKey(
                hProv,
                AT_KEYEXCHANGE,
                (dwKeyBitLen << 16) | dwFlags,
                &hKey
                )) {
            hKey = 0;
            goto CreateKeyError;
        } else
            goto SuccessReturn;
    } else {
        if (!GetDhParaFromDssKey(&pDssPara))
            goto ErrorReturn;

        pP = &pDssPara->p;
        pG = &pDssPara->g;
    }

    cbP = pP->cbData;
    
    if (!CryptGenKey(
            hProv,
            CALG_DH_SF,
            ((cbP * 8) << 16) | CRYPT_PREGEN | dwFlags,
            &hKey)) {
        hKey = 0;
        goto CreateKeyError;
    }

    fSetKeyPara = FALSE;
    if (pDh3PubKeyStruc) {
        CRYPT_DATA_BLOB Dh3Blob;

        Dh3Blob.pbData = (PBYTE) pDh3PubKeyStruc;
        Dh3Blob.cbData = cbDh3PubKeyStruc;

        if (CryptSetKeyParam(
                hKey,
                KP_PUB_PARAMS,
                (PBYTE) &Dh3Blob,
                0))                 // dwFlags
            fSetKeyPara = TRUE;
    }

    if (!fSetKeyPara) {
        if (!CryptSetKeyParam(
                hKey,
                KP_P,
                (PBYTE) pP,
                0))                 // dwFlags
            goto CreateKeyError;

        // Note, the length of G can be less than length P. Pad with leading
        // zeroes in little endian form.
        if (pG->cbData < cbP) {
            DWORD cbG = pG->cbData;

            // We are done using P parameter. Overwrite with the G parameter and
            // pad with leading zeroes in little endian form.
            memcpy(pP->pbData, pG->pbData, cbG);
            memset(pP->pbData + cbG, 0, cbP - cbG);
            pG = pP;
        }
        if (!CryptSetKeyParam(
                hKey,
                KP_G,
                (PBYTE) pG,
                0))                 // dwFlags
            goto CreateKeyError;
    }

    if (!CryptSetKeyParam(
            hKey,
            KP_X,
            NULL,               // pbData
            0))                 // dwFlags
        goto CreateKeyError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hKey)
        CryptDestroyKey(hKey);
    MakeCertFree(pDh3PubKeyStruc);
    MakeCertFree(pX942DhPara);
    MakeCertFree(pDssPara);
    return fResult;

CreateKeyError:
    IDSwprintf(hModule,IDS_ERR_SUB_KEY_CREATE, wszSubjectKey);
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL UpdateDhPublicKey(
    IN OUT PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = *ppPubKeyInfo;
    PCERT_X942_DH_PARAMETERS pX942DhPara = NULL;
    DWORD cbDhPara;
    PCERT_X942_DH_PARAMETERS pX942DhParaCertFile = NULL;

    BYTE *pbReencodedPara = NULL;
    DWORD cbReencodedPara;
    BYTE *pbReencodedPubKeyInfo = NULL;
    DWORD cbReencodedPubKeyInfo;
    PCERT_PUBLIC_KEY_INFO pUpdatedPubKeyInfo = NULL;
    DWORD cbUpdatedPubKeyInfo;

    if (NULL == wszDhParaCertFile && 0 == DhQ.cbData)
        return TRUE;

    if (!DecodeAndAllocObject(
            X942_DH_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData,
            (void **) &pX942DhPara,
            &cbDhPara
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (wszDhParaCertFile) {
        if (!GetDhParaFromCertFile(&pX942DhParaCertFile))
            goto ErrorReturn;

        if (!CertCompareIntegerBlob(&pX942DhPara->p, &pX942DhParaCertFile->p))
            goto DhParaCertFileError;
        if (!CertCompareIntegerBlob(&pX942DhPara->g, &pX942DhParaCertFile->g))
            goto DhParaCertFileError;

        // Use Dh parameters from the CertFile
        MakeCertFree(pX942DhPara);
        pX942DhPara = pX942DhParaCertFile;
        pX942DhParaCertFile = NULL;
    } else if (pX942DhPara->q.cbData) {
        MakeCertFree(pX942DhPara);
        return TRUE;
    } else
        // Use Q parameter saved away when the DH key was generated
        pX942DhPara->q = DhQ;

    // Re-encode the DH parameters
    if (!EncodeAndAllocObject(
            X942_DH_PARAMETERS,
            pX942DhPara,
            &pbReencodedPara,
            &cbReencodedPara
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    if (0 == strcmp(szOID_RSA_DH, pPubKeyInfo->Algorithm.pszObjId))
        pPubKeyInfo->Algorithm.pszObjId = szOID_ANSI_X942_DH;

    // Re-encode the PublicKeyInfo using the above re-encoded DH parameters
    pPubKeyInfo->Algorithm.Parameters.pbData = pbReencodedPara;
    pPubKeyInfo->Algorithm.Parameters.cbData = cbReencodedPara;
    if (!EncodeAndAllocObject(
            X509_PUBLIC_KEY_INFO,
            pPubKeyInfo,
            &pbReencodedPubKeyInfo,
            &cbReencodedPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    // Decode to get the updated public key info
    if (!DecodeAndAllocObject(
            X509_PUBLIC_KEY_INFO,
            pbReencodedPubKeyInfo,
            cbReencodedPubKeyInfo,
            (void **) &pUpdatedPubKeyInfo,
            &cbUpdatedPubKeyInfo
            )) {
        PrintLastError(IDS_ERR_EXPORT_PUB);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    MakeCertFree(pbReencodedPubKeyInfo);
    MakeCertFree(pbReencodedPara);
    MakeCertFree(pX942DhPara);
    MakeCertFree(pX942DhParaCertFile);

    MakeCertFree(pPubKeyInfo);
    *ppPubKeyInfo = pUpdatedPubKeyInfo;
    return fResult;

DhParaCertFileError:
    IDSwprintf(hModule, IDS_ERR_DH_PARA_FILE, wszDhParaCertFile);
ErrorReturn:
    MakeCertFree(pUpdatedPubKeyInfo);
    pUpdatedPubKeyInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\certmgr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for CertMgr.cpp.  
//
//
//  History:    21-July-97   xiaohs   created
//              
//--------------------------------------------------------------------------

//defintion for string IDS

#define         IDI_APP                         201
 
#define			IDS_SYNTAX						6001
#define			IDS_SUCCEEDED					6002
#define			IDS_FAILED						6003
#define			IDS_OPTIONS						6004																																																																						
#define			IDS_OPTION_ADD					6005
#define			IDS_OPTION_ADD_DESC				6006                  
#define			IDS_OPTION_DEL					6007
#define			IDS_OPTION_DEL_DESC				6008
#define			IDS_OPTION_S					6009
#define			IDS_OPTION_S_DESC				6010
#define			IDS_OPTION_R					6011
#define			IDS_OPTION_R_DESC				6012
#define			IDS_OPTION_MORE_VALUE			6013
#define			IDS_R_CU						6014
#define			IDS_R_LM						6015
#define			IDS_OPTION_C					6016
#define			IDS_OPTION_C_DESC				6017
#define			IDS_OPTION_CRL					6018
#define			IDS_OPTION_CRL_DESC				6019
#define			IDS_OPTION_CTL					6020
#define			IDS_OPTION_CTL_DESC				6021
#define			IDS_OPTION_V					6022
#define			IDS_OPTION_V_DESC				6023
#define			IDS_OPTION_ALL					6024
#define			IDS_OPTION_ALL_DESC				6025
#define			IDS_OPTION_N					6026
#define			IDS_OPTION_N_DESC				6027
#define			IDS_OPTION_SHA1					6028
#define			IDS_OPTION_SHA1_DESC			6029
#define			IDS_OPTION_7					6030
#define			IDS_OPTION_7_DESC				6031
#define			IDS_OPTION_E					6032
#define			IDS_OPTION_E_DESC				6033
#define			IDS_OPTION_Y					6034
#define			IDS_OPTION_Y_DESC				6035
#define			IDS_OPTION_F					6036
#define			IDS_OPTION_F_DESC				6037
#define			IDS_OPTION_EKU					6038
#define			IDS_OPTION_EKU_DESC				6039
#define			IDS_OPTION_TEST					6040
#define			IDS_OPTION_PUT                  6041
#define			IDS_OPTION_PUT_DESC             6042
#define			IDS_OPTION_PUT_DESC1            6043
#define			IDS_OPTION_PUT_DESC2            6044

												
#define			IDS_SWITCH1						6050
#define			IDS_SWITCH2						6051
#define			IDS_ERR_TOO_MANY_PARAM			6052
#define			IDS_ERR_N_SHA1					6053
#define			IDS_ERR_ALL_N_SHA1				6054
#define			IDS_ERR_SOURCE_STORE			6055
#define			IDS_ERR_STORE_PROVIDER			6056
#define			IDS_ERR_NO_REG					6057
#define			IDS_ERR_SHA1_HASH				6058
#define			IDS_ERR_DISPLAY_TOO_MANY		6059
#define			IDS_ERR_CTL_7					6060
#define			IDS_ERR_C_CTL_CTL_ALL			6061
#define			IDS_ERR_DES_STORE				6062
#define			IDS_ERR_SOURCE_SYSTEM_7			6063
#define			IDS_ERR_OPEN_SOURCE_STORE		6064
#define			IDS_ERR_TMP_STORE				6065
#define			IDS_ERR_ADD_CERT_ALL			6066
#define			IDS_ERR_DELETE_CERT_ALL			6067
#define			IDS_ERR_NO_CERT_HASH			6068
#define			IDS_ERR_ADD_CERT				6069
#define			IDS_ERR_DELETE_CERT				6070
#define			IDS_ERR_CERT_FIND				6071
#define			IDS_ERR_ADD_NO_CERT				6072
#define			IDS_ERR_DELETE_NO_CERT			6073
#define			IDS_ERR_ADD_CRL_ALL				6074
#define			IDS_ERR_DELETE_CRL_ALL			6075
#define			IDS_ERR_NO_CRL_HASH				6076
#define			IDS_ERR_ADD_CRL					6077
#define			IDS_ERR_DELETE_CRL				6078
#define			IDS_ERR_CRL_FIND				6079
#define			IDS_ERR_ADD_CTL_ALL				6080
#define			IDS_ERR_DELETE_CTL_ALL			6081
#define			IDS_ERR_NO_CTL_HASH				6082
#define			IDS_ERR_ADD_CTL					6083
#define			IDS_ERR_DELETE_CTL				6084
#define			IDS_ERR_CTL_FIND				6085
#define			IDS_ERR_COPY_FROM_SRC			6086
#define			IDS_ERR_SAVE_DES_STORE			6087
#define			IDS_ERR_OPEN_DES_STORE			6088
#define			IDS_CERT_INDEX					6089
#define			IDS_ERR_DISPLAY					6090
#define			IDS_CRL_INDEX					6092
#define			IDS_CTL_INDEX					6093
#define			IDS_NO_CERT						6094
#define			IDS_NO_CTL						6095
#define			IDS_NO_CRL						6096
#define			IDS_ERR_SINGLE_ACTION			6097
#define			IDS_ERR_GET_SINGER_COUNT		6098
#define			IDS_ERR_GET_SIGNER_CERT			6099
#define			IDS_NULL						7000
#define			IDS_SHA1						7001
#define			IDS_MD5							7002
#define			IDS_UNKNOWN						7003
#define			IDS_SUBJECT						7004
#define			IDS_ISSUER						7005
#define			IDS_SERIAL_NUMBER				7006
#define			IDS_KEY							7007
#define			IDS_KEY_PROVIDER				7008
#define			IDS_PROV_NAME					7009
#define			IDS_FLAGS						7010
#define			IDS_CONTAINER					7011
#define			IDS_PARAMS						7012
#define			IDS_KEY_SPEC					7013
#define			IDS_NOT_BEFORE					7014
#define			IDS_NOT_AFTER					7015
#define			IDS_VERSION						7016
#define			IDS_SIG_ALGO					7017
#define			IDS_SIG_ALGO_PARAM				7018
#define			IDS_SUB_KEY_ALGO				7019
#define			IDS_SUB_KEY_ALGO_PARAM			7020
#define			IDS_DSS_LENGTH					7021
#define			IDS_DSS_P						7022
#define			IDS_DSS_Q						7023
#define			IDS_DSS_G						7024
#define			IDS_SUB_KEY_INFO				7025
#define			IDS_BIT_LENGTH					7026
#define			IDS_UNUSED_BITS					7027
#define			IDS_RSA_CSP						7028
#define			IDS_DSS_Y						7029
#define			IDS_NO_PUB_KEY					7030
#define			IDS_ISSUER_ID					7031
#define			IDS_SUBJECT_ID					7032
#define			IDS_SUBJECT_USAGE				7033
#define			IDS_NO_USAGE_IDS				7034
#define			IDS_LIST_DIS					7035
#define			IDS_SEQUENCE					7036
#define			IDS_THIS_UPDATE					7037
#define			IDS_NEXT_UPDATE					7038
#define			IDS_TIME_INVALID				7039
#define			IDS_SUB_ALGO					7040
#define			IDS_SUB_ALGO_PARAM				7041
#define			IDS_NO_ENTRIES					7042
#define			IDS_ENTRIES						7043
#define			IDS_SUB_ID						7044
#define			IDS_ATTR						7045
#define			IDS_SERIAL_NUM_I				7046
#define			IDS_REVOC_DATE					7047
#define			IDS_NO_EXTENSION				7048
#define			IDS_EXTENSION					7049
#define			IDS_DIS_NO_SIGNER				7050
#define			IDS_SIGNER_INDEX				7051
#define			IDS_DIS_SIGNER_AUTH_ATTR		7052
#define			IDS_DIS_SIGNER_UNAUTH_ATTR		7053
#define			IDS_NO_BYTE						7054
#define			IDS_NEXT_UPDATE_LOCATION		7055
#define			IDS_NO_VALUE_BYTES				7056
#define			IDS_I_ID_NO_VALUE				7057
#define			IDS_OTHER_NAME					7058
#define			IDS_X400						7059
#define			IDS_DIRECTORY_NAME				7060
#define			IDS_EDI_PARTY					7061
#define			IDS_RFC							7062
#define			IDS_DNS							7063
#define			IDS_ALT_NAME_URL				7064
#define			IDS_IP							7065
#define			IDS_REG_ID						7066
#define			IDS_UNKNOWN_ALT_NAME			7067
#define			IDS_Thumbprint					7068
#define			IDS_FILE_TIME					7069
#define			IDS_MILLI_SECOND				7070
#define			IDS_AUX_PROP_ID					7071
#define			IDS_ENHANCED_KEY_USAGE			7072
#define			IDS_NO_PROP_BYTES				7073
#define			IDS_NO_USAGE_ID					7074
#define			IDS_CONTENT_SIG_ALGO			7075
#define			IDS_CONTENT_SIG_ALGO_PARAM		7076
#define			IDS_CONTEXT_SIG					7077
#define			IDS_DSS_R						7078
#define			IDS_DSS_S						7079
#define			IDS_DSS_INFO					7080
#define			IDS_CONTENT_SIG_NONE			7081
#define			IDS_VALUE_TYPE					7082
#define			IDS_STR							7083
#define			IDS_WSTR						7084
#define			IDS_TRUE						7085
#define			IDS_FALSE						7086
#define			IDS_EXTENSION_INDEX				7087
#define			IDS_NAME_CRITICAL				7088
#define			IDS_STRING						7089
#define			IDS_SUB_KEY_ID					7090
#define			IDS_SUB_ALT						7091
#define			IDS_ISS_ALT						7092
#define			IDS_SUB_ALT2					7093
#define			IDS_NEXT_UPDATE_LOC				7094
#define			IDS_CERT_POLICIES				7095
#define			IDS_NSCP_CERT					7096
#define			IDS_NSCP_BASE					7097
#define			IDS_NSCP_REV					7098
#define			IDS_NSCP_CA_REV					7099
#define			IDS_NSCP_RENEW					7100
#define			IDS_NSCP_CA_URL					7101
#define			IDS_NSCP_SSL					7102
#define			IDS_NSCP_COM					7103
#define			IDS_SMIME						7104
#define			IDS_NONE						7105
#define			IDS_PARAM						7106
#define			IDS_ENH_KEY_USAGE				7107
#define			IDS_COMMON_NAME					7108
#define			IDS_VALUE_STRING				7109
#define			IDS_FIN_CRI						7110
#define			IDS_FIN_AVAI					7111
#define			IDS_MEET_CRI					7112
#define			IDS_NO_MEET_CRI					7113
#define			IDS_MIN_CRI						7114
#define			IDS_MEET_MIN					7115
#define			IDS_NO_MEET_MIN					7116
#define			IDS_SPC_URL						7117
#define			IDS_SERIAL_DATA					7118
#define			IDS_SPC_FILE					7119
#define			IDS_UNKNOWN_SPC					7120
#define			IDS_SPC_AGENCY					7121
#define			IDS_POL_INFO					7122
#define			IDS_POL_DIS						7123
#define			IDS_IMG_LINK					7124
#define			IDS_BITMAP						7125
#define			IDS_META_FILE					7126
#define			IDS_ENH_META					7127
#define			IDS_GIF_FILE					7128
#define			IDS_LOGO_LINK					7129
#define			IDS_QUALI						7130
#define			IDS_ENCODED_DATA				7131
#define			IDS_KEY_USAGE					7132
#define			IDS_BASIC_CON2					7133
#define			IDS_PATH_LEN					7134
#define			IDS_BASIC_CON					7135
#define			IDS_SUB_TYPE					7136
#define			IDS_SUB_CA						7137
#define			IDS_SUB_EE						7138
#define			IDS_SUB_CON						7139
#define			IDS_DIG_SIG						7140
#define			IDS_NON_REP						7141
#define			IDS_KEY_ENCI					7142
#define			IDS_DATA_ENCI					7143
#define			IDS_KEY_AGRE					7144
#define			IDS_CERT_SIGN					7145
#define			IDS_OFFLINE_CRL					7146
#define			IDS_KEY_RESTRIC					7147
#define			IDS_CERT_POLICY					7148
#define			IDS_RESTRIC_KEY					7149
#define			IDS_CRL_REASON					7150
#define			IDS_CRL_UNSPECIFIED				7151
#define			IDS_KEY_COMP					7152
#define			IDS_CA_COMP						7153
#define			IDS_AFFI_CHANGED				7154
#define			IDS_SUPERSEDED					7155
#define			IDS_CESS_OPER					7156
#define			IDS_CERT_HOLD					7157
#define			IDS_REMOVE_CRL					7158
#define			IDS_KEY_ATTR					7159
#define			IDS_KEY_ID						7160
#define			IDS_INTEND_KEY_USAGE			7161
#define			IDS_NO_CRL_DIS					7162
#define			IDS_CRL_IDS_I					7163
#define			IDS_CRL_DIS_FULL_NAME			7164
#define			IDS_CRL_RDN						7165
#define			IDS_CRL_UNKNOWN					7166
#define			IDS_REASON_FLAG					7167
#define			IDS_REASON_UNUSED				7168
#define			IDS_CRL_ISSUER					7169
#define			IDS_AUTH_KEY_ID					7170
#define			IDS_AUTH_CERT_ISSUER			7172
#define			IDS_AUTH_CERT_ISSUER_SERIAL_NUMBER			7173
#define			IDS_AUTH_KEY_ID2				7174
#define			IDS_VALUE_STRING_S				7175
#define			IDS_ELN							7176
#define			IDS_ISS_ALT2					7177
#define			IDS_ERR_INVALID_INDEX			7178
#define			IDS_SEPERATOR					7179
#define			IDS_NOT_AVAILABLE				7180
#define			IDS_NONE_NOELN					7181
#define			IDS_TS_VERSION					7182
#define			IDS_TS_ISSUER					7183
#define			IDS_TS_SERIAL_NUMBER			7184
#define			IDS_TS_AUTHATTR					7185
#define			IDS_TS_UNAUTHATTR				7186
#define			IDS_TIMESTMAP					7187
#define			IDS_SIGNING_TIME				7188
#define			IDS_HASH_ALGO					7189
#define			IDS_HASH_ALGO_PARAM				7190
#define			IDS_ENCRYPT_ALGO				7191
#define			IDS_ENCRYPT_ALGO_PARAM			7192
#define			IDS_SIGNER_INDEX_CERT			7193
#define			IDS_SPC_SP_NAME					7197		
#define			IDS_SPC_FIN_NAME				7198
#define			IDS_SPC_MIN_NAME				7199
#define			IDS_NTSP_CERT_NAME				7200
#define			IDS_NTSP_BASE_NAME				7201
#define			IDS_NTSP_REV_NAME				7202
#define			IDS_NTSP_CA_REV_NAME			7203
#define			IDS_NTSP_RENEW_NAME				7204
#define			IDS_NTSP_POL_NAME				7205
#define			IDS_NTSP_SSL_SERVER_NAME		7206
#define			IDS_NTSP_COMMENT				7207
#define			IDS_ERR_INIT_OID_SET			7208
#define			IDS_ERR_INSTALL_OID				7209
#define			IDS_ERR_REG_OID					7210
#define			IDS_ERR_DELETE_SIGNED_FILE		7211
#define			IDS_ERR_SET_EKU					7212
#define			IDS_ERR_DISPLAY_EKU				7213
#define			IDS_SYNTAX1						7214
#define			IDS_OPTION_DEL_DESC1			7215
#define			IDS_ERR_PROVIDER_SYSTEM			7216
#define			IDS_OPTION_E_DESC1				7217
#define			IDS_ENTER_ADD_INDEX_CERT        7218
#define			IDS_ENTER_ADD_INDEX_CRL		    7219
#define			IDS_ENTER_ADD_INDEX_CTL		    7220
#define			IDS_ENTER_DELETE_INDEX_CERT     7221
#define			IDS_ENTER_DELETE_INDEX_CRL	    7222
#define			IDS_ENTER_DELETE_INDEX_CTL	    7223
#define			IDS_ENTER_PUT_INDEX_CERT        7224
#define			IDS_ENTER_PUT_INDEX_CTL	        7225
#define			IDS_ENTER_PUT_INDEX_CRL	        7226
#define			IDS_ERR_7_CTL                   7227
#define			IDS_ERR_7_CTL1                  7228
#define			IDS_TOO_MANY_DES_STORE          7229
#define			IDS_ERR_ALL_PUT                 7230
#define			IDS_ERR_PUT_ITEM                7231
#define			IDS_ERR_PUT_CERT		        7232
#define			IDS_ERR_PUT_NO_CERT             7233
#define			IDS_ERR_PUT_CRL			        7234
#define			IDS_ERR_PUT_CRL_FIND            7235
#define			IDS_ERR_PUT_CTL_FIND            7236
#define			IDS_ERR_PUT_CTL                 7237
#define			IDS_ERR_SET_NAME                7238
#define			IDS_OPTION_NAME_DESC            7239
#define			IDS_OPTION_NAME                 7240
#define			IDS_OPTION_MULTI_DESC           7241
#define			IDS_OPTION_MULTI                7242
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\makecert\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by makecert.rc
//
#define VS_VERSION_INFO1            2
#define IDR_PVKROOT                 101
#define IDR_ROOTCERTIFICATE         102

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



#define IDS_SYNTAX				     6001
#define IDS_BASIC_OPTIONS		     6002
#define IDS_EXTENDED_OPTIONS	     6003
#define IDS_OPTION_SK			     6004
#define IDS_OPTION_SK_DESC		     6005
#define IDS_OPTION_SC			     6006
#define IDS_OPTION_SC_DESC		     6007
#define IDS_OPTION_SV			     6008
#define IDS_OPTION_SV_DESC		     6009
#define IDS_OPTION_IK			     6010
#define IDS_OPTION_IK_DESC		     6011
#define IDS_OPTION_IC			     6012
#define IDS_OPTION_IC_DESC		     6013
#define IDS_OPTION_IV			     6014
#define IDS_OPTION_IV_DESC		     6015
#define IDS_OPTION_SERIAL		     6016
#define IDS_OPTION_SERIAL_DESC	     6017
#define IDS_OPTION_AUTH			     6018
#define IDS_OPTION_AUTH_DESC	     6019
#define IDS_OPTION_ALL_VALUES	     6020
#define IDS_OPTION_AUTH_IND		     6021
#define IDS_OPTION_AUTH_COM		     6022
#define IDS_OPTION_ALGO			     6025
#define IDS_OPTION_ALGO_DESC	     6026
#define IDS_OPTION_ALGO_SHA		     6027
#define IDS_OPTION_ALGO_MD5		     6028
#define IDS_OPTION_VALUES_DEFAULT    6029
#define IDS_OPTION_VALUES_2		     6030
//#define IDS_OPTION_VALUES_3		     6031
#define IDS_OPTION_IY			     6032
#define IDS_OPTION_IY_DESC		     6033
#define IDS_OPTION_IP			     6034
#define IDS_OPTION_IP_DESC		     6035
#define IDS_OPTION_N			     6036
#define IDS_OPTION_N_DESC		     6037
#if (1) //DSIE: Bug 205195.
#define IDS_OPTION_PE                6038
#define IDS_OPTION_PE_DESC           6039
#endif
#define IDS_OPTION_L			     6040
#define IDS_OPTION_L_DESC		     6041
#define IDS_OPTION_IKY			     6042
#define IDS_OPTION_IKY_DESC		     6043
#define IDS_OPTION_KY_SIG		     6044
#define IDS_OPTION_KY_EXC		     6045
#define IDS_OPTION_CY			     6046
#define IDS_OPTION_CY_DESC		     6047
#define IDS_OPTION_CY_END		     6048
#define IDS_OPTION_CY_AUTH		     6049
//#define IDS_OPTION_CY_BOTH		     6050
#define IDS_OPTION_B			     6052
#define IDS_OPTION_B_DESC		     6053
#define IDS_OPTION_M			     6054
#define IDS_OPTION_M_DESC		     6055
#define IDS_OPTION_E			     6056
#define IDS_OPTION_E_DESC		     6057
#define IDS_OPTION_H			     6058
#define IDS_OPTION_H_DESC		     6059
#define IDS_OPTION_G			     6060
#define IDS_OPTION_G_DESC		     6061
#define IDS_OPTION_R			     6062
#define IDS_OPTION_R_DESC		     6063
#define IDS_OPTION_NSCP			     6064
#define IDS_OPTION_NSCP_DESC	     6065
#define IDS_OPTION_EXTENDED		     6066
#define IDS_OPTION_EXTENDED_DESC     6067
#define IDS_OPTION_BASIC		     6068
#define IDS_OPTION_BASIC_DESC	     6069
#define	IDS_SWITCH1				     6070
#define IDS_SWITCH2				     6071
#define IDS_OPTION_IS			     6072
#define IDS_OPTION_IS_DESC		     6073
#define IDS_OPTION_IR			     6074
#define IDS_OPTION_IR_DESC		     6075
#define IDS_OPTION_CU				 6076
#define IDS_OPTION_LM				 6077
#define IDS_OPTION_ENHKEY_USAGE      6078
#define IDS_OPTION_ENHKEY_USAGE_DESC 6079
#define IDS_OPTION_SY			     6080
#define IDS_OPTION_SY_DESC		     6081
#define IDS_OPTION_SP			     6082
#define IDS_OPTION_SP_DESC		     6083
#define	IDS_OPTION_SS				 6084
#define IDS_OPTION_SS_DESC			 6085
#define IDS_OPTION_SR				 6087
#define IDS_OPTION_SR_DESC			 6088
#define	IDS_OPTION_IN				 6089
#define	IDS_OPTION_IN_DESC			 6090
#define IDS_OPTION_SKY			     6091
#define IDS_OPTION_SKY_DESC		     6092
#define IDS_OPTION_VALUES_KY		 6093

#define IDS_OPTION_NOPUBKEYPARA      6095
#define IDS_OPTION_NOPUBKEYPARA_DESC 6096

#define IDS_OPTION_SQ				 6097
#define IDS_OPTION_SQ_DESC			 6098

#define IDS_OPTION_DH_PARA           6099
#define IDS_OPTION_DH_PARA_DESC      6100
#define IDS_OPTION_KEY_LEN           6101
#define IDS_OPTION_KEY_LEN_DESC      6102
#define IDS_OPTION_NOPUBVERIFY       6103
#define IDS_OPTION_NOPUBVERIFY_DESC  6104
#define	IDS_OPTION_TEST				 6105


#define IDS_MAKECERT_ROOT			6994
#define IDS_ERR_SELF_SIGNED			6995
#define IDS_ERR_NO_ALGO				6996
#define IDS_ERR_NO_KY				6997
#define IDS_ERR_NO_CY				6998
#define IDS_ERR_NO_AUTH	            6999
#define IDS_ERR_TOO_MANY_PARAM		7000			
#define IDS_ERR_LAST				7001
#define IDS_ERR_CANNOT_OPEN			7002
#define IDS_ERR_EMPTY_FILE			7003
#define IDS_ERR_CANNOT_ALLOC		7004
#define IDS_ERR_CANNOT_READ			7005
#define IDS_ERR_COINIT				7006
#define IDS_ERR_FAILED				7007
#define IDS_ERR_LOAD_ROOT			7008
#define IDS_ERR_ROOT_KEY			7009
#define IDS_ERR_LOAD_ISSUER			7010
#define IDS_ERR_MISMATCH			7011
#define IDS_ERR_ISSUER_KEY			7012
#define IDS_ERR_BAD_PSW				7013
#define IDS_ERR_SUB_FILE_EXIST		7014
#define IDS_ERR_SUB_FILE_CREATE		7015
#define IDS_ERR_SUB_KEY				7016
#define IDS_ERR_SUB_KEY_CREATE		7017
#define IDS_ERR_CANNOT_LOAD_SUB_CERT   7018
#define IDS_ERR_NO_OUTPUT			7019
			
#define IDS_ERR_DESC_ALLOC			7020
#define IDS_ERR_DESC_WRITE			7021
#define IDS_ERR_SIGN_ENCODE_CB		7022
#define IDS_ERR_SIGN_ENCODE			7023
#define IDS_ERR_EXPORT_PUB			7024
#define IDS_CERT_STR_TO_NAME		7025
#define IDS_CRYPT_HASH_CERT			7026
#define IDS_CRYPT_HASP_PUB			7027
#define IDS_ENCODE_AUTH_KEY			7028
#define IDS_ENCODE_SPC_AGENCY		7029
#define IDS_ENCODE_UNICODE_NAME_VALUE  7030
#define IDS_ENCODE_KEY_USAGE		7031
#define IDS_ENCODE_FINANCIAL		7032
#define IDS_ENCODE_BASIC_CONSTRAINTS2  7033
#define IDS_SUCCEEDED				7034
#define IDS_ERR_NO_IR				7035
#define IDS_ERR_DESC_SAVE_STORE		7036 
#define IDS_ERR_INVALID_B			7037
#define	IDS_ERR_INVALID_E			7038
#define	IDS_OPTION_TIME_DESC		7039

#define IDS_ROOT					7040
#define IDS_CER						7041
#define IDS_PVK						7042
#define IDS_GLUE					7043
#define IDS_BACK_SLASH				7044
#define IDS_JOE_SOFT				7045
#define IDS_JOE_NAME				7046
#define IDS_ROOT_SIGNATURE			7047
#define IDS_ISSUER_SIGNATURE		7048
#define IDS_SUB_SIG					7049
#define IDS_SUB_EXCHANGE			7050
#define IDS_NULL					7051
#define IDS_PLUS					7052
#define IDS_REG_CA					7053
#define IDS_REG_ROOT				7054
#define IDS_REG_MY					7055

#define	IDS_ERR_NO_PROV_FROM_CERT	7056
#define	IDS_ERR_NO_ISSUER_CERT		7057
#define	IDS_ERR_MORE_ISSUER_CERT	7058
#define	IDS_ERR_NO_ISSUER_CER_FILE	7059
#define	IDS_ERR_EITHER_STORE_OR_KEY	7060
#define	IDS_ERR_TOO_MANY_STORE_KEY	7061
#define	IDS_ERR_CERT_FILE_NAME		7062
#define	IDS_OPTION_SS_DESC1			7063
#define	IDS_ERR_SK_SV				7064
#define	IDS_NO_ISSUER_FOR_SELF_SIGNED   7065
#define	IDS_NO_PKCS10_AND_SELF_SIGNED	7066
#define	IDS_ERR_DH_PARA_FILE        7067
#define	IDS_INVALID_REQUEST_FILE		7068
#define	IDS_NO_PKCS10_AND_SUBJECT_PVK	7069
#define	IDS_INVALID_ATTR_REQUEST_FILE	7070

#if (1) //DSIE: Bug 205195.
#define IDS_ERR_PE_CONTAINER        7071
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certmgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       CertMgr
//
//  Contents:   Certificate store management tools
//
//              See Usage() for list of options.
//
//
//  Functions:  wmain
//
//  History:    July 21st   xiaohs   created
//              
//--------------------------------------------------------------------------

#include "certmgr.h"

//--------------------------------------------------------------------------
//
// Global Flags
//
//----------------------------------------------------------------------------
#define		ITEM_VERBOSE			0x00010000
#define		ITEM_CERT				0x00000001
#define		ITEM_CTL				0x00000002
#define		ITEM_CRL				0x00000004

#define		ACTION_DISPLAY			0x01
#define		ACTION_ADD				0x02
#define		ACTION_DELETE			0x04
#define     ACTION_PUT              0x08

#define		OPTION_SWITCH_SIZE		10

#define		SHA1_LENGTH				20
#define		MAX_HASH_LEN			20

#define		MAX_STRING_RSC_SIZE		512

//--------------------------------------------------------------------------
//
// Global Variable
//
//----------------------------------------------------------------------------
 
HMODULE	hModule=NULL;

//varibles for installable formatting routines
 HCRYPTOIDFUNCSET hFormatFuncSet;

 const CRYPT_OID_FUNC_ENTRY g_FormatTable[] = {
    szOID_BASIC_CONSTRAINTS2, FormatBasicConstraints2};

 DWORD	g_dwFormatCount=sizeof(g_FormatTable)/sizeof(g_FormatTable[0]);

typedef BOOL (WINAPI *PFN_FORMAT_FUNC)(
	IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    );


//variables for installing OID information
typedef struct _CERTMGR_OID_INFO
{
    LPCSTR              pszOID;
    int					idsOIDName;
}CERTMGR_OID_INFO;

CERTMGR_OID_INFO	g_rgOIDInfo[]={
		SPC_SP_AGENCY_INFO_OBJID,			IDS_SPC_SP_NAME,
		SPC_FINANCIAL_CRITERIA_OBJID,		IDS_SPC_FIN_NAME,
		SPC_MINIMAL_CRITERIA_OBJID,			IDS_SPC_MIN_NAME,
		szOID_NETSCAPE_CERT_TYPE,			IDS_NTSP_CERT_NAME,
		szOID_NETSCAPE_BASE_URL,			IDS_NTSP_BASE_NAME,
		szOID_NETSCAPE_REVOCATION_URL,		IDS_NTSP_REV_NAME,
		szOID_NETSCAPE_CA_REVOCATION_URL,	IDS_NTSP_CA_REV_NAME,
		szOID_NETSCAPE_CERT_RENEWAL_URL,	IDS_NTSP_RENEW_NAME,
		szOID_NETSCAPE_CA_POLICY_URL,		IDS_NTSP_POL_NAME,
		szOID_NETSCAPE_SSL_SERVER_NAME,		IDS_NTSP_SSL_SERVER_NAME,
		szOID_NETSCAPE_COMMENT,				IDS_NTSP_COMMENT};


DWORD	g_dwOIDInfo=sizeof(g_rgOIDInfo)/sizeof(g_rgOIDInfo[0]);

//varibles for string manipulations
WCHAR	g_wszBuffer[MAX_STRING_RSC_SIZE];
DWORD	g_dwBufferSize=sizeof(g_wszBuffer)/sizeof(g_wszBuffer[0]); 


//varibles for options
DWORD		g_dwAction=0;
DWORD		g_dwItem=0;
LPWSTR		g_wszCertEncodingType=NULL;
DWORD		g_dwCertEncodingType = X509_ASN_ENCODING;
DWORD		g_dwMsgEncodingType = PKCS_7_ASN_ENCODING;
DWORD		g_dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
BOOL		g_fSaveAs7 = FALSE;
LPWSTR		g_wszCertCN = NULL;
LPWSTR		g_wszSha1Hash = NULL;
BYTE		*g_pbHash=NULL;
DWORD		g_cbHash=0;
BOOL		g_fAll=FALSE;
HCRYPTMSG	g_hMsg=NULL;
LPWSTR		g_wszEKU=NULL;
LPWSTR      g_wszName=NULL;
BOOL        g_fMulti=FALSE;
BOOL		g_fUndocumented=FALSE;

BOOL		g_fSrcSystemStore = FALSE;
LPWSTR		g_wszSrcStoreLocation=NULL;
DWORD		g_dwSrcStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
LPWSTR		g_wszSrcStoreName=NULL;

BOOL		g_fSameSrcDes=FALSE;
BOOL		g_fDesSystemStore = FALSE;
LPWSTR		g_wszDesStoreLocation=NULL;
DWORD		g_dwDesStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
LPWSTR		g_wszDesStoreName=NULL;

LPWSTR		g_wszSrcStoreProvider = NULL;
LPSTR		g_szSrcStoreProvider = NULL;
LPWSTR		g_wszSrcStoreOpenFlag = NULL;
DWORD		g_dwSrcStoreOpenFlag = 0;	

LPWSTR		g_wszDesStoreProvider = NULL;
LPSTR		g_szDesStoreProvider = NULL;
LPWSTR		g_wszDesStoreOpenFlag = NULL;
DWORD		g_dwDesStoreOpenFlag = 0;	


CHAR		g_szNULL[OPTION_SWITCH_SIZE];
WCHAR		g_wszSHA1[OPTION_SWITCH_SIZE];
WCHAR		g_wszMD5[OPTION_SWITCH_SIZE];
WCHAR		g_wszUnKnown[OPTION_SWITCH_SIZE*2];



//---------------------------------------------------------------------------
//	wmain
//	 
//---------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR *wargv[])
{
    int				ReturnStatus=-1;  

	//variables for parse the options
	WCHAR			*pwChar;
	WCHAR			wszSwitch1[OPTION_SWITCH_SIZE];
	WCHAR			wszSwitch2[OPTION_SWITCH_SIZE];

	HCERTSTORE		hCertStore=NULL;
    CRYPTUI_CERT_MGR_STRUCT          CertMgrStruct;


	//get the module handler
	if(!InitModule())
		goto ErrorReturn;

	//load the strings necessary for parsing the parameters
	if( !LoadStringU(hModule, IDS_SWITCH1,	wszSwitch1, OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_SWITCH2,  wszSwitch2,	OPTION_SWITCH_SIZE)
											//<NULL>
	  ||!LoadStringA(hModule, IDS_NULL,     g_szNULL,  OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_SHA1,		g_wszSHA1, 	OPTION_SWITCH_SIZE)
	  ||!LoadStringU(hModule, IDS_MD5,      g_wszMD5,  OPTION_SWITCH_SIZE)
											//<UNKNOWN OID>
	  ||!LoadStringU(hModule, IDS_UNKNOWN,	g_wszUnKnown, OPTION_SWITCH_SIZE*2))
		goto ErrorReturn;

    //call the UI versino of certmgr if no parameter is passed
    //memset
    if(1== argc)
    {
        memset(&CertMgrStruct, 0, sizeof(CRYPTUI_CERT_MGR_STRUCT));
        CertMgrStruct.dwSize=sizeof(CRYPTUI_CERT_MGR_STRUCT);

        CryptUIDlgCertMgr(&CertMgrStruct);

        ReturnStatus = 0;
	    IDSwprintf(hModule, IDS_SUCCEEDED);
        goto CommonReturn;
    }


	//parse the parameters
    while (--argc) 
	{
        pwChar = *++wargv;
        if (*pwChar == *wszSwitch1 || *pwChar == *wszSwitch2) 
		{
			//parse the options
            if(!ParseSwitch (&argc, &wargv))
			{
				if(TRUE==g_fUndocumented)
					goto UndocReturn;
				else
					goto UsageReturn;
			}
        } 
		else
		{
			//set the source file name
			if(NULL==g_wszSrcStoreName)
				g_wszSrcStoreName=pwChar;
			else
			{
				//set the destination file name
				if(!SetParam(&g_wszDesStoreName, pwChar))
					goto UsageReturn;
			}
		}
    }

	//check the parameters.  Make sure that they are valid and make sense
	if(!CheckParameter())
		goto UsageReturn;

	//open the destination store, which includes all the CERTS, CRTs, and CTLs
	if(!OpenGenericStore(g_wszSrcStoreName,
						 g_fSrcSystemStore,
						 g_dwSrcStoreFlag,
						 g_szSrcStoreProvider,
						 g_dwSrcStoreOpenFlag,
						 TRUE,
						 &hCertStore))
	{
		IDSwprintf(hModule,IDS_ERR_OPEN_SOURCE_STORE);
		goto ErrorReturn;
	}

	//error if we opened a signed file and there is a delete option with on destination
	if(g_hMsg)
	{
		if(g_dwAction & ACTION_DELETE)
		{
			if(g_fSameSrcDes)
			{
				IDSwprintf(hModule, IDS_ERR_DELETE_SIGNED_FILE);
				goto ErrorReturn;
			}
		}

	}

	//Display
	if(g_dwAction & ACTION_DISPLAY)
	{
		//if the msg is signed, disply the signer info
		if(g_hMsg)
		{
			if(!DisplaySignerInfo(g_hMsg, g_dwItem))
				goto ErrorReturn;
		}

		if(!DisplayCertStore(hCertStore))
			goto ErrorReturn;
	  	
		IDSwprintf(hModule, IDS_SEPERATOR);
	}


	//Delete
	if(g_dwAction & ACTION_DELETE)
	{
		if(!DeleteCertStore(hCertStore))
			goto ErrorReturn;

	}


	//Add
	if(g_dwAction & ACTION_ADD)
	{
		if(!AddCertStore(hCertStore))
			goto ErrorReturn;
	}

    if(g_dwAction & ACTION_PUT)
    {
        if(!PutCertStore(hCertStore))
            goto ErrorReturn;

    }

	//mark succeed
    ReturnStatus = 0;
	IDSwprintf(hModule, IDS_SUCCEEDED);
    goto CommonReturn;
          

UndocReturn:
	//print out the undocuemted Usage
	UndocumentedUsage();
	goto CommonReturn;

//print out the Usage.  
UsageReturn:
	Usage();
	goto CommonReturn;


ErrorReturn:
	//print out an error msg
	IDSwprintf(hModule, IDS_FAILED);
	goto CommonReturn;   


CommonReturn:
	//clean up memory.  Return the status
	if(g_szSrcStoreProvider)
		ToolUtlFree(g_szSrcStoreProvider);

	if(g_szDesStoreProvider)
		ToolUtlFree(g_szDesStoreProvider);

	if(g_pbHash)
		ToolUtlFree(g_pbHash);

	if(g_hMsg)
		CryptMsgClose(g_hMsg);

	if(hCertStore)
		CertCloseStore(hCertStore, 0);
	
	return ReturnStatus;

}

//---------------------------------------------------------------------------
// The private version of wcscat
//----------------------------------------------------------------------------

wchar_t *IDSwcscat(HMODULE hModule, WCHAR *pwsz, int idsString)
{
	//load the string
	if(!LoadStringU(hModule, idsString, g_wszBuffer, g_dwBufferSize))
		return pwsz;

	return wcscat(pwsz, g_wszBuffer);
}

//---------------------------------------------------------------------------
//	 Get the hModule hanlder and init two DLLMain.
//	 
//---------------------------------------------------------------------------
BOOL	InitModule()
{
	WCHAR			wszOIDName[MAX_STRING_RSC_SIZE];
	DWORD			dwIndex=0;
	CRYPT_OID_INFO	OIDInfo;
	
	if(!(hModule=GetModuleHandle(NULL)))
	   return FALSE;

    //We do not need to do the following any more.

    //the oid information are now in the OID database
	//now, we are installing the format the extensions :
	//BASICCONTRAINTS2
    if (NULL == (hFormatFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                0)))	// dwFlags
	 {
		 IDSwprintf(hModule, IDS_ERR_INIT_OID_SET);
         return FALSE;
	 }

	//install the default formatting routine
	if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                g_dwCertEncodingType,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                g_dwFormatCount,
                g_FormatTable,
                0))                         // dwFlags
    {
		IDSwprintf(hModule, IDS_ERR_INSTALL_OID);
		return FALSE;
	}

	//secondly, we install the OID information

	//init OIDInfo
/*	memset(&OIDInfo, 0, sizeof(CRYPT_OID_INFO));
	OIDInfo.cbSize=sizeof(CRYPT_OID_INFO);
	OIDInfo.dwGroupId=CRYPT_EXT_OR_ATTR_OID_GROUP_ID;

	for(dwIndex=0; dwIndex < g_dwOIDInfo; dwIndex++)
	{
		if(!LoadStringU(hModule, g_rgOIDInfo[dwIndex].idsOIDName,	
			wszOIDName, MAX_STRING_RSC_SIZE))
			return FALSE;
		
		OIDInfo.pszOID=g_rgOIDInfo[dwIndex].pszOID;
		OIDInfo.pwszName=wszOIDName;

		CryptRegisterOIDInfo(&OIDInfo,0);


	}   */

	return TRUE;
}

//---------------------------------------------------------------------------
//	Usage
//	 
//---------------------------------------------------------------------------
 void Usage(void)
{
	IDSwprintf(hModule,IDS_SYNTAX);
	IDSwprintf(hModule,IDS_SYNTAX1);
	IDSwprintf(hModule,IDS_OPTIONS);
	IDSwprintf(hModule,IDS_OPTION_ADD_DESC);			
	IDSwprintf(hModule,IDS_OPTION_DEL_DESC);
	IDSwprintf(hModule,IDS_OPTION_DEL_DESC1);
    IDSwprintf(hModule,IDS_OPTION_PUT_DESC);
    IDSwprintf(hModule,IDS_OPTION_PUT_DESC1);
    IDSwprintf(hModule,IDS_OPTION_PUT_DESC2);
	IDSwprintf(hModule,IDS_OPTION_S_DESC);			
	IDSwprintf(hModule,IDS_OPTION_R_DESC);			
	IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE,IDS_R_CU,IDS_R_LM,IDS_R_CU);	
	IDSwprintf(hModule,IDS_OPTION_C_DESC);			
	IDSwprintf(hModule,IDS_OPTION_CRL_DESC);			
	IDSwprintf(hModule,IDS_OPTION_CTL_DESC);			
	IDSwprintf(hModule,IDS_OPTION_V_DESC);			
	IDSwprintf(hModule,IDS_OPTION_ALL_DESC);			
	IDSwprintf(hModule,IDS_OPTION_N_DESC);			
	IDSwprintf(hModule,IDS_OPTION_SHA1_DESC);			
	IDSwprintf(hModule,IDS_OPTION_7_DESC);			
	IDSwprintf(hModule,IDS_OPTION_E_DESC);
	IDSwprintf(hModule,IDS_OPTION_E_DESC1);
	IDSwprintf(hModule,IDS_OPTION_F_DESC);
	IDSwprintf(hModule,IDS_OPTION_Y_DESC);
}

//---------------------------------------------------------------------------
//
//	Usage
//	 
//---------------------------------------------------------------------------
void UndocumentedUsage()
{
	IDSwprintf(hModule, IDS_SYNTAX);
	IDSwprintf(hModule, IDS_OPTIONS);
	IDSwprintf(hModule, IDS_OPTION_EKU_DESC);
    IDSwprintf(hModule, IDS_OPTION_NAME_DESC);
    IDSwprintf(hModule, IDS_OPTION_MULTI_DESC);
}

//--------------------------------------------------------------------------------
// Parse arguements
//--------------------------------------------------------------------------------
BOOL 
ParseSwitch (int	*pArgc,
             WCHAR	**pArgv[])
{
    WCHAR* param = **pArgv;

	//move pass '/' or '-'
    param++;

    if (IDSwcsicmp(hModule, param, IDS_OPTION_ADD)==0) {

		g_dwAction |= ACTION_ADD;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule, param, IDS_OPTION_DEL)==0) {

		g_dwAction |= ACTION_DELETE;
		return TRUE;
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_PUT)==0) {

		g_dwAction |= ACTION_PUT;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_S)==0) {

		if(NULL==g_wszSrcStoreName)
			g_fSrcSystemStore=TRUE;
		else
			g_fDesSystemStore=TRUE;

		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_R)==0) {
        if (!--(*pArgc)) 
			return FALSE;

       (*pArgv)++;

	   if(NULL==g_wszSrcStoreName)
			return SetParam(&g_wszSrcStoreLocation, **pArgv);
	   else
		    return SetParam(&g_wszDesStoreLocation, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_C)==0) {

		g_dwItem |= ITEM_CERT;
		return TRUE;
	}
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_CRL)==0) {

		g_dwItem |= ITEM_CRL;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_CTL)==0) {

		g_dwItem |= ITEM_CTL;
		return TRUE;
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_V)==0) {

		g_dwItem |= ITEM_VERBOSE;
		return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_ALL)==0) {

		g_fAll=TRUE;
		return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_N)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&g_wszCertCN, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_SHA1)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		return SetParam(&g_wszSha1Hash, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_7)==0) {

		g_fSaveAs7=TRUE;
		return TRUE;
	}
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_E)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&g_wszCertEncodingType, **pArgv);
    }

    else if(IDSwcsicmp(hModule,param, IDS_OPTION_Y)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		if(NULL==g_wszSrcStoreName)
			return SetParam(&g_wszSrcStoreProvider, **pArgv);
		else
			return SetParam(&g_wszDesStoreProvider, **pArgv);
    }
	else if(IDSwcsicmp(hModule,param, IDS_OPTION_F)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

		if(NULL==g_wszSrcStoreName)
			return SetParam(&g_wszSrcStoreOpenFlag, **pArgv);
		else
			return SetParam(&g_wszDesStoreOpenFlag, **pArgv);

    }
	else if(IDSwcsicmp(hModule, param, IDS_OPTION_EKU)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&g_wszEKU, **pArgv);
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_NAME)==0) {
        if (!--(*pArgc)) 
			return FALSE;

        (*pArgv)++;

        return SetParam(&g_wszName, **pArgv);
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_MULTI)==0) {

        g_fMulti=TRUE;

        return TRUE;
    }
	else if(IDSwcsicmp(hModule, param, IDS_OPTION_TEST)==0) {

        g_fUndocumented=TRUE;

		return FALSE;
    }


	return FALSE;
}

//-----------------------------------------------------------------------------
//	Check the parameters
//
//-----------------------------------------------------------------------------
BOOL	CheckParameter()
{
    DWORD   dwItemCount=0;  

	//check actions
	if((g_dwAction & ACTION_ADD) && (g_dwAction & ACTION_DELETE))
	{
		IDSwprintf(hModule, IDS_ERR_SINGLE_ACTION);
		return FALSE;
	}

    if((g_dwAction & ACTION_ADD) && (g_dwAction & ACTION_PUT))
	{
		IDSwprintf(hModule, IDS_ERR_SINGLE_ACTION);
		return FALSE;
	}

    if((g_dwAction & ACTION_PUT) && (g_dwAction & ACTION_DELETE))
	{
		IDSwprintf(hModule, IDS_ERR_SINGLE_ACTION);
		return FALSE;
	}

	if(0==g_dwAction)
		g_dwAction |= ACTION_DISPLAY;

    //-7 and -CTL can not be set at the same time for add or put
    if(TRUE==g_fSaveAs7)
    {
        if(g_dwItem & ITEM_CTL)
        {
            if((g_dwAction & ACTION_ADD) || (g_dwAction & ACTION_PUT))
            {
               IDSwprintf(hModule, IDS_ERR_7_CTL);
               IDSwprintf(hModule, IDS_ERR_7_CTL1);
               return FALSE;
            }
        }
    }

	//-n and -sha1 can not be set at the same time
	if(g_wszCertCN && g_wszSha1Hash)
	{
		IDSwprintf(hModule, IDS_ERR_N_SHA1);
		return FALSE;
	}

	//-all can not be set with -n and -sha1 option
	if(TRUE==g_fAll)
	{
		if(g_wszCertCN || g_wszSha1Hash)
		{
			IDSwprintf(hModule, IDS_ERR_ALL_N_SHA1);
			return FALSE;
		}

	}

	//-y, -f can not be set with -s and -r for source
	if(g_wszSrcStoreProvider || g_wszSrcStoreOpenFlag)
	{
		if((TRUE==g_fSrcSystemStore)||(g_wszSrcStoreLocation))
		{
			IDSwprintf(hModule, IDS_ERR_PROVIDER_SYSTEM);
			return FALSE;
		}
	}

	//-y, -f can not be set with -s and -r	for desitnation
	if(g_wszDesStoreProvider || g_wszDesStoreOpenFlag)
	{
		if((TRUE==g_fDesSystemStore)||(g_wszDesStoreLocation))
		{
			IDSwprintf(hModule, IDS_ERR_PROVIDER_SYSTEM);
			return FALSE;
		}
	}


	//source store has to be set
	if(NULL==g_wszSrcStoreName)
	{
		IDSwprintf(hModule, IDS_ERR_SOURCE_STORE);
		return FALSE;
	}

	//get the source store Provider
	if(g_wszSrcStoreProvider)
	{
		if(S_OK != WSZtoSZ(g_wszSrcStoreProvider, &g_szSrcStoreProvider))
		{
			IDSwprintf(hModule, IDS_ERR_STORE_PROVIDER);
			return FALSE;
		}
	}

	//get the source store open flag
	if(g_wszSrcStoreOpenFlag)
	{
		g_dwSrcStoreOpenFlag = _wtol(g_wszSrcStoreOpenFlag);
	}

	//get the destination store Provider
	if(g_wszDesStoreProvider)
	{
		if(S_OK != WSZtoSZ(g_wszDesStoreProvider, &g_szDesStoreProvider))
		{
			IDSwprintf(hModule, IDS_ERR_STORE_PROVIDER);
			return FALSE;
		}
	}

	//get the destination store open flag
	if(g_wszDesStoreOpenFlag)
	{
		g_dwDesStoreOpenFlag = _wtol(g_wszDesStoreOpenFlag);
	}

	//get the encoding type
	if(g_wszCertEncodingType)
	{
		g_dwCertEncodingType = _wtol(g_wszCertEncodingType);
	}

	g_dwMsgAndCertEncodingType |= g_dwCertEncodingType;

	//get the source store location
	if(g_wszSrcStoreLocation)
	{
		if(IDSwcsicmp(hModule,g_wszSrcStoreLocation, IDS_R_CU) == 0) 
			g_dwSrcStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
		else 
		{
			if(IDSwcsicmp(hModule,g_wszSrcStoreLocation, IDS_R_LM) == 0) 
				g_dwSrcStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_REG);
				return FALSE;
			}
		}
	}

	
	//get the destincation store location
	if(g_wszDesStoreLocation)
	{
		if(IDSwcsicmp(hModule,g_wszDesStoreLocation, IDS_R_CU) == 0) 
			g_dwDesStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
		else 
		{
			if(IDSwcsicmp(hModule,g_wszDesStoreLocation, IDS_R_LM) == 0) 
				g_dwDesStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
			else
			{
				IDSwprintf(hModule,IDS_ERR_NO_REG);
				return FALSE;
			}
		}
	}

	//get the hash 
	if(g_wszSha1Hash)
	{
		if(S_OK != WSZtoBLOB(g_wszSha1Hash, &g_pbHash, &g_cbHash))
		{
			//sha1 hash is invalid
			IDSwprintf(hModule, IDS_ERR_SHA1_HASH);
			return FALSE;
		}
	}

	//check the item
	if(g_dwAction & ACTION_DISPLAY)
	{
		if(0==g_dwItem || ITEM_VERBOSE==g_dwItem)
			g_dwItem = g_dwItem | ITEM_CERT | ITEM_CTL | ITEM_CRL;

		//can not set destination source
		if((g_wszDesStoreLocation) || (g_fDesSystemStore==TRUE) ||
			(g_wszCertCN) || (g_wszSha1Hash) || (g_fSaveAs7==TRUE) ||
			(g_wszDesStoreName) ||(g_wszDesStoreProvider) ||(g_wszDesStoreOpenFlag))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY_TOO_MANY);
			return FALSE;
		}

	}

    //-eku can not be set for DISPLAY or PUT
    if((g_dwAction & ACTION_DISPLAY) || (g_dwAction & ACTION_PUT))
    {
        //can not set -eku option
		if(g_wszEKU || g_wszName)
		{
			IDSwprintf(hModule, IDS_ERR_DISPLAY_EKU);
			return FALSE;
		}
    }

    if(g_dwAction & ACTION_PUT)
    {
		//g_fAll can not be set, 
		if(TRUE==g_fAll)
		{
            IDSwprintf(hModule, IDS_ERR_ALL_PUT);
            return FALSE;
        }

        //only one item can not set
        dwItemCount=0;

        if(g_dwItem & ITEM_CERT)
            dwItemCount++;
        if(g_dwItem & ITEM_CTL)
            dwItemCount++;
        if(g_dwItem & ITEM_CRL)
            dwItemCount++;

        if(1!=dwItemCount)
        {
            IDSwprintf(hModule, IDS_ERR_PUT_ITEM);
            return FALSE;
        }

		//check the destination store
		if(NULL == g_wszDesStoreName)
		{	
			IDSwprintf(hModule,IDS_ERR_DES_STORE);
			return FALSE;

        }

        //can not set -s, -y, -f, or -r for the destination store
		if((g_fDesSystemStore==TRUE) || (g_wszDesStoreLocation) ||
				(g_wszDesStoreProvider) || (g_wszDesStoreOpenFlag))
		{
			IDSwprintf(hModule,IDS_TOO_MANY_DES_STORE);
			return FALSE;
		}
		
    }

	if((g_dwAction & ACTION_ADD) ||
		(g_dwAction & ACTION_DELETE))
	{

		//if g_fAll is set, OK 
		if(TRUE==g_fAll)
		{
			if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem )
				g_dwItem = g_dwItem | ITEM_CERT | ITEM_CTL | ITEM_CRL;
		}

		//check the destination store
		if(NULL == g_wszDesStoreName)
		{	
			if(g_dwAction & ACTION_ADD)
			{
				IDSwprintf(hModule,IDS_ERR_DES_STORE);
				return FALSE;
			}

			g_fSameSrcDes=TRUE;

			//can not have set -s, -y, -f or -r if the store name is not set
			if((g_fDesSystemStore==TRUE) || (g_wszDesStoreLocation) ||
				(g_wszDesStoreProvider) || (g_wszDesStoreOpenFlag))
			{
				IDSwprintf(hModule,IDS_ERR_DES_STORE);
				return FALSE;
			}
			g_wszDesStoreName=g_wszSrcStoreName;
			g_dwDesStoreFlag=g_dwSrcStoreFlag;
			g_fDesSystemStore=g_fSrcSystemStore;
			g_szDesStoreProvider=g_szSrcStoreProvider;
			g_dwDesStoreOpenFlag=g_dwSrcStoreOpenFlag;

		}
		
		//if -7 is set, can not save to a system store
		if(TRUE==g_fSaveAs7)
		{
			if(TRUE==g_fDesSystemStore)
			{
				IDSwprintf(hModule,IDS_ERR_SOURCE_SYSTEM_7);
				return FALSE;
			}
		}

	}

	return 	TRUE;

}

//------------------------------------------------------------------------------------
//
//	Open a store.  The order of trying is following:
//
//		Using predefined store provider
//		SystemStore
//		CTL
//		CRL
//		Serialized Store, PKCS#7, Encoded Cert
//		PKCS7 via sip
//		Base64 encoded, then go throught the whole thing again
//
//		
//------------------------------------------------------------------------------------
BOOL	OpenGenericStore(LPWSTR			wszStoreName,
						 BOOL			fSystemStore,
						 DWORD			dwStoreFlag,
						 LPSTR			szStoreProvider,
						 DWORD			dwStoreOpenFlag,
						 BOOL			fCheckExist,
						 HCERTSTORE		*phCertStore)
{
	HCERTSTORE		hStore=NULL;
	BYTE			*pbByte=NULL;
	DWORD			cbByte=0;
	CRYPT_DATA_BLOB	Blob;

	if(!wszStoreName || !phCertStore)
		return FALSE;

	//open the store using supplied store provider
	if(szStoreProvider)
	{
		hStore=CertOpenStore(szStoreProvider,
							g_dwMsgAndCertEncodingType,
							NULL,
							dwStoreOpenFlag,
							wszStoreName);

		//one shot and we are done
		goto CLEANUP;

	}

	//open the system store
	if(fSystemStore)
	{	
		if(TRUE==fCheckExist)
		{
			//open Read Only stores
			hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
						g_dwMsgAndCertEncodingType,
						NULL,
						dwStoreFlag |CERT_STORE_READONLY_FLAG,
						wszStoreName);

			//we need to open the store as non-readonly if the store exists
			//and we the source store is the same as destination store
			if(NULL!=hStore)
			{
				if(TRUE==g_fSameSrcDes)
				{
					CertCloseStore(hStore, 0);

					hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							g_dwMsgAndCertEncodingType,
							NULL,
							dwStoreFlag,
							wszStoreName);
				}

			}

		}
		else
		{
			hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
						g_dwMsgAndCertEncodingType,
						NULL,
						dwStoreFlag,
						wszStoreName);
		}
		

		//one shot and we are done
		goto CLEANUP;
	}

	//open an encoded CTL
	hStore=OpenEncodedCTL(wszStoreName);
	
	if(hStore)
	{
		//mark this is a CTL
		if((0==g_dwItem) || (ITEM_VERBOSE==g_dwItem))
			g_dwItem |= ITEM_CTL;

		goto CLEANUP;
	}

	//open an encoded CRL
	hStore=OpenEncodedCRL(wszStoreName);
	if(hStore)
	{
		//mark this is a CRL
		if((0==g_dwItem) || (ITEM_VERBOSE==g_dwItem))
			g_dwItem |= ITEM_CRL;

		goto CLEANUP;
	}

	//open an encoded Cert
	hStore=OpenEncodedCert(wszStoreName);
	if(hStore)
	{
		//mark this is a CERT		
		if((0==g_dwItem) || (ITEM_VERBOSE==g_dwItem))
			g_dwItem |= ITEM_CERT;
		
		goto CLEANUP;
	}


	//Serialized Store, PKCS#7, Encoded Cert 
	hStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 wszStoreName);
	if(hStore)
		goto CLEANUP;

	//PKCS7 via SIP
	hStore=OpenSipStore(wszStoreName);
	if(hStore)
		goto CLEANUP;

	//base64 encoded
	if(!GetBase64Decoded(wszStoreName, &pbByte,&cbByte))
		goto CLEANUP;

	Blob.cbData=cbByte;
	Blob.pbData=pbByte;

	//open a temporary memory store
	hStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);

	if(!hStore)
		goto CLEANUP;


	//try as encodedCTL
	if(CertAddEncodedCTLToStore(hStore,
								 g_dwMsgAndCertEncodingType,
								 pbByte,
								 cbByte,
								 CERT_STORE_ADD_ALWAYS,
								 NULL))
		goto CLEANUP;

	//try as encodedCRL
	if(CertAddEncodedCRLToStore(hStore,
								g_dwMsgAndCertEncodingType,
								pbByte,
								cbByte,
								CERT_STORE_ADD_ALWAYS,
								NULL))
		goto CLEANUP;

	//try as encodedCert
	if(CertAddEncodedCertificateToStore(hStore,
								g_dwMsgAndCertEncodingType,
								pbByte,
								cbByte,
								CERT_STORE_ADD_ALWAYS,
								NULL))
		goto CLEANUP;

	//close the temporary store
	CertCloseStore(hStore, 0);
	hStore=NULL;

   //try as an 7
	hStore=CertOpenStore(CERT_STORE_PROV_PKCS7,
							g_dwMsgAndCertEncodingType,
							NULL,
							0,
							&Blob);


	if(hStore)
		goto CLEANUP;

	//try as a serialized store
	hStore=CertOpenStore(CERT_STORE_PROV_SERIALIZED,
							g_dwMsgAndCertEncodingType,
							NULL,
							0,
							&Blob);

	
	//now we give up

CLEANUP:

	//free memory
	if(pbByte)
		ToolUtlFree(pbByte);

	if(hStore)
	{
		*phCertStore=hStore;
		return TRUE;
	}

	return FALSE;
}

//-------------------------------------------------------------------------
//
//	Add certs/CTLs/CRLs from the source store to the destination store
//
//-------------------------------------------------------------------------
BOOL	AddCertStore(HCERTSTORE	hCertStore)
{

	BOOL			fResult=FALSE;
	HCERTSTORE		hAddStore=NULL;
	int				idsErr=0;
	CRYPT_HASH_BLOB Blob;
	DWORD			dwIndex=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	DWORD			dwCertCount=0;
	PCCERT_CONTEXT	*rgpCertContext=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	DWORD			dwCRLCount=0;
	PCCRL_CONTEXT	*rgpCRLContext=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	DWORD			dwCTLCount=0;
	PCCTL_CONTEXT	*rgpCTLContext=NULL;

	//User has to specify the item to delete
	if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem)
	{
		IDSwprintf(hModule,IDS_ERR_C_CTL_CTL_ALL);
		return FALSE;
	}


	//create a temporaray memory store
	hAddStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);

	if(!hAddStore)
	{
		idsErr=IDS_ERR_TMP_STORE;
		goto CLEANUP;
	}

	
	//add certs
	if(g_dwItem & ITEM_CERT)
	{
		//add all 
		if(g_fAll)
		{
			if(!MoveItem(hCertStore, hAddStore,ITEM_CERT))
			{
				idsErr=IDS_ERR_ADD_CERT_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//add based on Hash
			if(g_pbHash)
			{
				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;
			
				//search for the certificate
				pCertContext=CertFindCertificateInStore(
								hCertStore,
								g_dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);
			
				if(!pCertContext)
				{
					idsErr=IDS_ERR_NO_CERT_HASH;
					goto CLEANUP;
				}
			
				//add certificate to the hash
			   if(!CertAddCertificateContextToStore(hAddStore,
													pCertContext,
													CERT_STORE_ADD_REPLACE_EXISTING,
													NULL))
			   {
					idsErr=IDS_ERR_ADD_CERT;
					goto CLEANUP;
			   }
			
			   //free the pCertContext
			   CertFreeCertificateContext(pCertContext);
			   pCertContext=NULL;
			}
			else
			{

				if(g_wszCertCN)
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, g_wszCertCN, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				else
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, NULL, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				
				//check if there is no certs
				if(0==dwCertCount && g_wszCertCN)
				{
					idsErr=IDS_ERR_ADD_NO_CERT;
					goto CLEANUP;
				}
				
				
				//check if there is only one cert
				if(1==dwCertCount)
				{
					//add certificate 
				   if(!CertAddCertificateContextToStore(hAddStore,
														rgpCertContext[0],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
				   {
						idsErr=IDS_ERR_ADD_CERT;
						goto CLEANUP;
				   }
				
				}
				else 
				{
					if(dwCertCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCertAndPrompt(rgpCertContext, dwCertCount, &dwIndex))
						{
							idsErr=IDS_ERR_ADD_CERT;
							goto CLEANUP;
						}
				
						//add certificate 
						if(!CertAddCertificateContextToStore(hAddStore,
														rgpCertContext[dwIndex],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
						{
							idsErr=IDS_ERR_ADD_CERT;
							goto CLEANUP;
						}
					}
				
				}
			}
		}		
	}

	//add CRLs
	if(g_dwItem & ITEM_CRL)
	{
		//add all 
		if(g_fAll)
		{
			if(!MoveItem(hCertStore, hAddStore,ITEM_CRL))
			{
				idsErr=IDS_ERR_ADD_CRL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCRLContext=FindCRLInStore(
								hCertStore,
								&Blob);

				if(!pCRLContext)
				{
					idsErr=IDS_ERR_NO_CRL_HASH;
					goto CLEANUP;
				}

				//add CRL to the hash
				if(!CertAddCRLContextToStore(hAddStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_ADD_CRL;
						goto CLEANUP;
				}

				//free the pCRLContext
				CertFreeCRLContext(pCRLContext);
				pCRLContext=NULL;
				
			}
			else
			{

				//search for the CRL
				if(!BuildCRLList(hCertStore, &rgpCRLContext, &dwCRLCount))
				{
					idsErr=IDS_ERR_CRL_FIND;
					goto CLEANUP;
				}

				//check if there is only one CRL
				if(1==dwCRLCount)
				{
					//add CRL 
					if(!CertAddCRLContextToStore(hAddStore,
										rgpCRLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_ADD_CRL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCRLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCRLAndPrompt(rgpCRLContext, dwCRLCount, &dwIndex))
						{
							idsErr=IDS_ERR_ADD_CRL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCRLContextToStore(hAddStore,
										rgpCRLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_ADD_CRL;
							goto CLEANUP;
						}
					}

				}
			}
		}
	}

	//add CTLs
	if(g_dwItem & ITEM_CTL)
	{
		//add all 
		if(g_fAll)
		{
			if(!MoveItem(hCertStore, hAddStore,ITEM_CTL))
			{
				idsErr=IDS_ERR_ADD_CTL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCTLContext=CertFindCTLInStore(
								hCertStore,
								g_dwMsgAndCertEncodingType,
								0,
								CTL_FIND_SHA1_HASH,
								&Blob,
								NULL);

				if(!pCTLContext)
				{
					idsErr=IDS_ERR_NO_CTL_HASH;
					goto CLEANUP;
				}


				//add CTL to the hash
				if(!CertAddCTLContextToStore(hAddStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_ADD_CTL;
						goto CLEANUP;  
				}

				//free the pCRLContext
				CertFreeCTLContext(pCTLContext);
				pCTLContext=NULL;
				
			}
			else
			{

				//search for the certificate
				if(!BuildCTLList(hCertStore,&rgpCTLContext, &dwCTLCount))
				{
					idsErr=IDS_ERR_CTL_FIND;
					goto CLEANUP;
				}

				//check if there is only one item
				if(1==dwCTLCount)
				{
					//add CRL 
					if(!CertAddCTLContextToStore(hAddStore,
										rgpCTLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_ADD_CTL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCTLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCTLAndPrompt(rgpCTLContext, dwCTLCount, &dwIndex))
						{
							idsErr=IDS_ERR_ADD_CTL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCTLContextToStore(hAddStore,
										rgpCTLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_ADD_CTL;
							goto CLEANUP;
						}
					}

				}
			}
		}



	}

	//save the properties to the certificates in the store
	if(g_wszEKU)
	{
		if(!SetEKUProperty(hAddStore))
		{
			idsErr=IDS_ERR_SET_EKU;
			goto CLEANUP;
		}
	}

    //save the properties to the certificates in the store
	if(g_wszName)
	{
		if(!SetNameProperty(hAddStore))
		{
			idsErr=IDS_ERR_SET_NAME;
			goto CLEANUP;
		}
	}


	//save the hAddStore to the destination store
	if(!SaveStore(hAddStore))
		goto CLEANUP;


	fResult=TRUE;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(rgpCertContext)
	{
		for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
			CertFreeCertificateContext(rgpCertContext[dwIndex]);

		free(rgpCertContext);
	}

	if(rgpCRLContext)
	{
		for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
			CertFreeCRLContext(rgpCRLContext[dwIndex]);

		free(rgpCRLContext);
	}

	if(rgpCTLContext)
	{
		for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
			CertFreeCTLContext(rgpCTLContext[dwIndex]);

		free(rgpCTLContext);
	}


	if(hAddStore)
		CertCloseStore(hAddStore, 0);

	if(FALSE==fResult)
	{
		//output the error message
		IDSwprintf(hModule,idsErr);			
	}

	return fResult;

}
//-------------------------------------------------------------------------
//
//	Put certs/CTLs/CRLs from the source store to the destination store
//
//-------------------------------------------------------------------------
BOOL	PutCertStore(HCERTSTORE	hCertStore)
{

	BOOL			fResult=FALSE;
	HCERTSTORE		hPutStore=NULL;
	int				idsErr=0;
	CRYPT_HASH_BLOB Blob;
	DWORD			dwIndex=0;

	PCCERT_CONTEXT	pCertContext=NULL;
    PCCERT_CONTEXT  pCertPut=NULL;
	DWORD			dwCertCount=0;
	PCCERT_CONTEXT	*rgpCertContext=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
    PCCRL_CONTEXT	pCRLPut=NULL;
	DWORD			dwCRLCount=0;
	PCCRL_CONTEXT	*rgpCRLContext=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
    PCCTL_CONTEXT	pCTLPut=NULL;
	DWORD			dwCTLCount=0;
	PCCTL_CONTEXT	*rgpCTLContext=NULL;   

    BYTE            *pByte=NULL;
    DWORD           cbByte=0;
    DWORD           dwCRLFlag=0;

	//User has to specify the item to delete
	if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem)
	{
		IDSwprintf(hModule,IDS_ERR_PUT_ITEM);
		return FALSE;
	}


	//create a temporaray memory store
	hPutStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);

	if(!hPutStore)
	{
		idsErr=IDS_ERR_TMP_STORE;
		goto CLEANUP;
	}

	
	//put certs
	if(g_dwItem & ITEM_CERT)
	{
			//add based on Hash
			if(g_pbHash)
			{
				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;
			
				//search for the certificate
				pCertContext=CertFindCertificateInStore(
								hCertStore,
								g_dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);
			
				if(!pCertContext)
				{
					idsErr=IDS_ERR_NO_CERT_HASH;
					goto CLEANUP;
				}
			
				//add certificate to the hash
			   if(!CertAddCertificateContextToStore(hPutStore,
													pCertContext,
													CERT_STORE_ADD_REPLACE_EXISTING,
													NULL))
			   {
					idsErr=IDS_ERR_PUT_CERT;
					goto CLEANUP;
			   }
			
			   //free the pCertContext
			   CertFreeCertificateContext(pCertContext);
			   pCertContext=NULL;
			}
			else
			{

				if(g_wszCertCN)
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, g_wszCertCN, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				else
				{
					//search for the certificate
					if(!BuildCertList(hCertStore, NULL, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_PUT_NO_CERT;
						goto CLEANUP;
					}
				}
				
				//check if there is no certs
				if(0==dwCertCount)
				{
					idsErr=IDS_ERR_CERT_FIND;
					goto CLEANUP;
				}
				
				
				//check if there is only one cert
				if(1==dwCertCount)
				{
					//add certificate 
				   if(!CertAddCertificateContextToStore(hPutStore,
														rgpCertContext[0],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
				   {
						idsErr=IDS_ERR_PUT_CERT;
						goto CLEANUP;
				   }
				
				}
				else 
				{
					if(dwCertCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCertAndPrompt(rgpCertContext, dwCertCount, &dwIndex))
						{
							idsErr=IDS_ERR_PUT_CERT;
							goto CLEANUP;
						}
				
						//add certificate 
						if(!CertAddCertificateContextToStore(hPutStore,
														rgpCertContext[dwIndex],
														CERT_STORE_ADD_REPLACE_EXISTING,
														NULL))
						{
							idsErr=IDS_ERR_PUT_CERT;
							goto CLEANUP;
						}
					}
				
				}
			}
	}

	//add CRLs
	if(g_dwItem & ITEM_CRL)
	{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCRLContext=FindCRLInStore(
								hCertStore,
								&Blob);

				if(!pCRLContext)
				{
					idsErr=IDS_ERR_NO_CRL_HASH;
					goto CLEANUP;
				}

				//add CRL to the hash
				if(!CertAddCRLContextToStore(hPutStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_PUT_CRL;
						goto CLEANUP;
				}

				//free the pCRLContext
				CertFreeCRLContext(pCRLContext);
				pCRLContext=NULL;
				
			}
			else
			{

				//search for the CRL
				if(!BuildCRLList(hCertStore, &rgpCRLContext, &dwCRLCount))
				{
					idsErr=IDS_ERR_PUT_CRL_FIND;
					goto CLEANUP;
				}

                //check if there is no certs
				if(0==dwCRLCount)
				{
					idsErr=IDS_ERR_PUT_CRL_FIND;
					goto CLEANUP;
				}


				//check if there is only one CRL
				if(1==dwCRLCount)
				{
					//add CRL 
					if(!CertAddCRLContextToStore(hPutStore,
										rgpCRLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_PUT_CRL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCRLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCRLAndPrompt(rgpCRLContext, dwCRLCount, &dwIndex))
						{
							idsErr=IDS_ERR_PUT_CRL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCRLContextToStore(hPutStore,
										rgpCRLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_PUT_CRL;
							goto CLEANUP;
						}
					}

				}
			}
	}

	//add CTLs
	if(g_dwItem & ITEM_CTL)
	{
			//add based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCTLContext=CertFindCTLInStore(
								hCertStore,
								g_dwMsgAndCertEncodingType,
								0,
								CTL_FIND_SHA1_HASH,
								&Blob,
								NULL);

				if(!pCTLContext)
				{
					idsErr=IDS_ERR_NO_CTL_HASH;
					goto CLEANUP;
				}


				//add CTL to the hash
				if(!CertAddCTLContextToStore(hPutStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				{
						idsErr=IDS_ERR_PUT_CTL;
						goto CLEANUP;  
				}

				//free the pCRLContext
				CertFreeCTLContext(pCTLContext);
				pCTLContext=NULL;
				
			}
			else
			{

				//search for the certificate
				if(!BuildCTLList(hCertStore,&rgpCTLContext, &dwCTLCount))
				{
					idsErr=IDS_ERR_PUT_CTL_FIND;
					goto CLEANUP;
				}

               //check if there is no certs
				if(0==dwCTLCount)
				{
					idsErr=IDS_ERR_PUT_CTL_FIND;
					goto CLEANUP;
				}


				//check if there is only one item
				if(1==dwCTLCount)
				{
					//add CRL 
					if(!CertAddCTLContextToStore(hPutStore,
										rgpCTLContext[0],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
					{
						idsErr=IDS_ERR_PUT_CTL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCTLCount>1)
					{
						//promt user for the index number to add
						if(!DisplayCTLAndPrompt(rgpCTLContext, dwCTLCount, &dwIndex))
						{
							idsErr=IDS_ERR_PUT_CTL;
							goto CLEANUP;
						}

						//add certificate 
						if(!CertAddCTLContextToStore(hPutStore,
										rgpCTLContext[dwIndex],
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
						{
							idsErr=IDS_ERR_PUT_CTL;
							goto CLEANUP;
						}
					}

				}
			}



	}


	//save the hPutStore to the destination store
    //save as 7 is required
    if(g_fSaveAs7==TRUE)
    {
		if(!CertSaveStore(hPutStore,
						g_dwMsgAndCertEncodingType,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_FILENAME_W,
						g_wszDesStoreName,
						0))
		{
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;
		}
    }
    else
    {
        //get the BLOB to save to a file in X509 format
        if(g_dwItem & ITEM_CERT)
        {
            if(NULL==(pCertPut=CertEnumCertificatesInStore(hPutStore, NULL)))
		    {
			    IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			    goto CLEANUP;
		    }

            pByte=pCertPut->pbCertEncoded;
            cbByte=pCertPut->cbCertEncoded;
        }

        if(g_dwItem & ITEM_CRL)
        {
            if(NULL==(pCRLPut=CertGetCRLFromStore(hPutStore,
												NULL,
												NULL,
												&dwCRLFlag)))
            {
			    IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			    goto CLEANUP;
            }

            pByte=pCRLPut->pbCrlEncoded;
            cbByte=pCRLPut->cbCrlEncoded;

        }

        if(g_dwItem & ITEM_CTL)
        {
            if(NULL==(pCTLPut=CertEnumCTLsInStore(hPutStore, NULL)))
            {
			    IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			    goto CLEANUP;
            }
            pByte=pCTLPut->pbCtlEncoded;
            cbByte=pCTLPut->cbCtlEncoded;
        }

       if(S_OK !=OpenAndWriteToFile(g_wszDesStoreName,pByte, cbByte))
       {
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;

       }
    }


	fResult=TRUE;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

    if(pCertPut)
		CertFreeCertificateContext(pCertPut);

	if(pCRLPut)
		CertFreeCRLContext(pCRLPut);

	if(pCTLPut)
		CertFreeCTLContext(pCTLPut);


	if(rgpCertContext)
	{
		for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
			CertFreeCertificateContext(rgpCertContext[dwIndex]);

		free(rgpCertContext);
	}

	if(rgpCRLContext)
	{
		for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
			CertFreeCRLContext(rgpCRLContext[dwIndex]);

		free(rgpCRLContext);
	}

	if(rgpCTLContext)
	{
		for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
			CertFreeCTLContext(rgpCTLContext[dwIndex]);

		free(rgpCTLContext);
	}


	if(hPutStore)
		CertCloseStore(hPutStore, 0);

	if(FALSE==fResult)
	{
		//output the error message
		IDSwprintf(hModule,idsErr);			
	}

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Delete certs/CTLs/CRLs from the source store to the destination store
//
//-------------------------------------------------------------------------
BOOL	DeleteCertStore(HCERTSTORE	hCertStore)
{

	BOOL			fResult=FALSE;
	HCERTSTORE		hDeleteStore=NULL;
	BOOL			fDuplicated=FALSE;
	int				idsErr=0;
	CRYPT_HASH_BLOB	Blob;
	DWORD			dwIndex=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	DWORD			dwCertCount=0;
	PCCERT_CONTEXT	*rgpCertContext=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	DWORD			dwCRLCount=0;
	PCCRL_CONTEXT	*rgpCRLContext=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	DWORD			dwCTLCount=0;
	PCCTL_CONTEXT	*rgpCTLContext=NULL;


	//User has to specify the item to delete
	if(g_dwItem==0 || ITEM_VERBOSE==g_dwItem)
	{
		IDSwprintf(hModule,IDS_ERR_C_CTL_CTL_ALL);
		return FALSE;
	}


	//first of all, create a certificate from which the certs will be deleted
	//if the source store is a fileStore, or a system store saved to its self,
	//we do not need to duplicate the source store since the deletion is not persistent;
	//otherwise, we need to duplicate the source store so that the deletion
	//will not show up at the source store
	if( ((NULL != g_szSrcStoreProvider) &&(FALSE==g_fSameSrcDes) ) ||
		((FALSE==g_fSameSrcDes) &&(TRUE==g_fSrcSystemStore)))
	{
		//open a temporary store
		hDeleteStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 g_dwMsgAndCertEncodingType,
						 NULL,
						 0,
						 NULL);


		if(!hDeleteStore)
		{
			idsErr=IDS_ERR_TMP_STORE;
			goto CLEANUP;
		}

		fDuplicated=TRUE;

		//need to copy from the source to the delete store
		if(!MoveItem(hCertStore, hDeleteStore, ITEM_CERT | ITEM_CTL | ITEM_CRL))
		{
			idsErr=IDS_ERR_COPY_FROM_SRC;
			goto CLEANUP;
		}


	}
	else
		hDeleteStore=hCertStore;


	//now, we delete CERTs, CTLs, and CRLs
	
	//delete certs
	if(g_dwItem & ITEM_CERT)
	{
		//delete all 
		if(g_fAll)
		{
			if(!DeleteItem(hDeleteStore,ITEM_CERT))
			{
				idsErr=IDS_ERR_DELETE_CERT_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//delete based on Hash
			if(g_pbHash)
			{
				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;
			
				//search for the certificate
				pCertContext=CertFindCertificateInStore(
								hDeleteStore,
								g_dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);
			
				if(!pCertContext)
				{
					idsErr=IDS_ERR_NO_CERT_HASH;
					goto CLEANUP;
				}
			
				//delete certificate to the hash
			   if(!CertDeleteCertificateFromStore(pCertContext))
			   {
					idsErr=IDS_ERR_DELETE_CERT;
					goto CLEANUP;
			   }
			
			   //free the pCertContext
			   //CertFreeCertificateContext(pCertContext);
			   pCertContext=NULL;
			}
			else
			{

				if(g_wszCertCN)
				{
					//search for the certificate
					if(!BuildCertList(hDeleteStore, g_wszCertCN, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				else
				{
					//search for the certificate
					if(!BuildCertList(hDeleteStore, NULL, 
											&rgpCertContext, &dwCertCount))
					{
						idsErr=IDS_ERR_CERT_FIND;
						goto CLEANUP;
					}
				}
				
				//check if there is no certs
				if(0==dwCertCount && g_wszCertCN)
				{
					idsErr=IDS_ERR_DELETE_NO_CERT;
					goto CLEANUP;
				}
				
				
				//check if there is only one cert
				if(1==dwCertCount)
				{
					//delete certificate 
                    CertDuplicateCertificateContext(rgpCertContext[0]);

				   if(!CertDeleteCertificateFromStore(rgpCertContext[0]))
				   {
						idsErr=IDS_ERR_DELETE_CERT;
						goto CLEANUP;
				   }
				
				}
				else 
				{
					if(dwCertCount>1)
					{
						//promt user for the index number to delete
						if(!DisplayCertAndPrompt(rgpCertContext, dwCertCount, &dwIndex))
						{
							idsErr=IDS_ERR_DELETE_CERT;
							goto CLEANUP;
						}
				
						//delete certificate 

                        CertDuplicateCertificateContext(rgpCertContext[dwIndex]);

						if(!CertDeleteCertificateFromStore(rgpCertContext[dwIndex]))
						{
							idsErr=IDS_ERR_DELETE_CERT;
							goto CLEANUP;
						}
					}
				
				}
			}
		}		
	}


 	//delete CRLs
	if(g_dwItem & ITEM_CRL)
	{
		//delete all 
		if(g_fAll)
		{
			if(!DeleteItem(hDeleteStore, ITEM_CRL))
			{
				idsErr=IDS_ERR_DELETE_CRL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//delete based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCRLContext=FindCRLInStore(
								hDeleteStore,
								&Blob);

				if(!pCRLContext)
				{
					idsErr=IDS_ERR_NO_CRL_HASH;
					goto CLEANUP;
				}

				//delete CRL to the hash
				if(!CertDeleteCRLFromStore(pCRLContext))
				{
						idsErr=IDS_ERR_DELETE_CRL;
						goto CLEANUP;
				}

				//free the pCRLContext
				//CertFreeCRLContext(pCRLContext);
				pCRLContext=NULL;
				
			}
			else
			{

				//search for the CRL
				if(!BuildCRLList(hDeleteStore, &rgpCRLContext, &dwCRLCount))
				{
					idsErr=IDS_ERR_CRL_FIND;
					goto CLEANUP;
				}

				//check if there is only one CRL
				if(1==dwCRLCount)
				{
					//delete CRL 
                    CertDuplicateCRLContext(rgpCRLContext[0]);

					if(!CertDeleteCRLFromStore(rgpCRLContext[0]))
					{
						idsErr=IDS_ERR_DELETE_CRL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCRLCount>1)
					{
						//promt user for the index number to delete
						if(!DisplayCRLAndPrompt(rgpCRLContext, dwCRLCount, &dwIndex))
						{
							idsErr=IDS_ERR_DELETE_CRL;
							goto CLEANUP;
						}

						//delete certificate
                        CertDuplicateCRLContext(rgpCRLContext[dwIndex]);

						if(!CertDeleteCRLFromStore(rgpCRLContext[dwIndex]))
						{
							idsErr=IDS_ERR_DELETE_CRL;
							goto CLEANUP;
						}
					}

				}
			}
		}
	}

	//delete CTLs
	if(g_dwItem & ITEM_CTL)
	{
		//delete all 
		if(g_fAll)
		{
			if(!DeleteItem(hDeleteStore, ITEM_CTL))
			{
				idsErr=IDS_ERR_DELETE_CTL_ALL;
				goto CLEANUP;
			}

		}
		else
		{
			//delete based on Hash
			if(g_pbHash)
			{

				Blob.cbData=g_cbHash;
				Blob.pbData=g_pbHash;

				pCTLContext=CertFindCTLInStore(
								hDeleteStore,
								g_dwMsgAndCertEncodingType,
								0,
								CTL_FIND_SHA1_HASH,
								&Blob,
								NULL);

				if(!pCTLContext)
				{
					idsErr=IDS_ERR_NO_CTL_HASH;
					goto CLEANUP;
				}


				//delete CTL to the hash
				if(!CertDeleteCTLFromStore(pCTLContext))
				{
						idsErr=IDS_ERR_DELETE_CTL;
						goto CLEANUP;
				}

				//free the pCRLContext
				//CertFreeCTLContext(pCTLContext);
				pCTLContext=NULL;
				
			}
			else
			{

				//search for the CTLs
				if(!BuildCTLList(hDeleteStore,&rgpCTLContext, &dwCTLCount))
				{
					idsErr=IDS_ERR_CTL_FIND;
					goto CLEANUP;
				}

				//check if there is only one item
				if(1==dwCTLCount)
				{
					//delete CRL 

                    CertDuplicateCTLContext(rgpCTLContext[0]);

					if(!CertDeleteCTLFromStore(rgpCTLContext[0]))
					{
						idsErr=IDS_ERR_DELETE_CTL;
						goto CLEANUP;
					}

				}
				else
				{
					if(dwCTLCount>1)
					{
						//promt user for the index number to delete
						if(!DisplayCTLAndPrompt(rgpCTLContext, dwCTLCount, &dwIndex))
						{
							idsErr=IDS_ERR_DELETE_CTL;
							goto CLEANUP;
						}

						//delete CTL 
                        CertDuplicateCTLContext(rgpCTLContext[dwIndex]);

						if(!CertDeleteCTLFromStore(rgpCTLContext[dwIndex]))
						{
							idsErr=IDS_ERR_DELETE_CTL;
							goto CLEANUP;
						}
					}

				}
			}
		}



	}

	//save the properties to the certificates in the store
	if(g_wszEKU)
	{
		if(!SetEKUProperty(hDeleteStore))
		{
			idsErr=IDS_ERR_SET_EKU;
			goto CLEANUP;
		}
	}

    //save the properties to the certificates in the store
	if(g_wszName)
	{
		if(!SetNameProperty(hDeleteStore))
		{
			idsErr=IDS_ERR_SET_NAME;
			goto CLEANUP;
		}
	}


	//at last, we save the content for hDeleteStore to the desination store

	//we do not need to do any thing if the source is a system store and 
	//it is saved to its self
	if(((TRUE==g_fSameSrcDes) && (TRUE==g_fDesSystemStore))||
		((TRUE==g_fSameSrcDes)&& (NULL!=g_szDesStoreProvider)))
	{
		fResult=TRUE;
		goto CLEANUP;
	}

	if(!SaveStore(hDeleteStore))
		goto CLEANUP;

	fResult=TRUE;

CLEANUP:


	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(rgpCertContext)
	{
		for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
			CertFreeCertificateContext(rgpCertContext[dwIndex]);

		free(rgpCertContext);
	}

	if(rgpCRLContext)
	{
		for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
			CertFreeCRLContext(rgpCRLContext[dwIndex]);

		free(rgpCRLContext);
	}

	if(rgpCTLContext)
	{
		for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
			CertFreeCTLContext(rgpCTLContext[dwIndex]);

		free(rgpCTLContext);
	}


	if((hDeleteStore) &&(TRUE==fDuplicated) )
		CertCloseStore(hDeleteStore, 0);


	if(FALSE==fResult)
		//output the error message
		IDSwprintf(hModule,idsErr);			

	return fResult;

}

//---------------------------------------------------------------------------
//
//	Save the store to the destination
//--------------------------------------------------------------------------
BOOL	SaveStore(HCERTSTORE hSrcStore)
{
	BOOL		fResult=FALSE;
	HCERTSTORE	hDesStore=NULL;	
   

	DWORD		dwSaveAs=0;


	if(!hSrcStore)
	{
		IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
		return FALSE;
	}	


	//now, we need to distinguish between save to a file, or to a system store
	if(g_fDesSystemStore || g_szDesStoreProvider)
	{
		if(NULL==g_szDesStoreProvider)
		{
			hDesStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
					g_dwMsgAndCertEncodingType,
					NULL,
					g_dwDesStoreFlag,
					g_wszDesStoreName);
		}
		else
		{
			hDesStore=CertOpenStore(g_szDesStoreProvider,
							g_dwMsgAndCertEncodingType,
							NULL,
							g_dwDesStoreOpenFlag,
							g_wszDesStoreName);
		}



		if(!hDesStore)
		{
		 	IDSwprintf(hModule,IDS_ERR_OPEN_DES_STORE);
			goto CLEANUP;
		}

		if(!MoveItem(hSrcStore, hDesStore,ITEM_CERT | ITEM_CRL |ITEM_CTL))
		{
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;
		}

	}
	else
	{
		//now, try to open the desitnation store so that the content of the destination
		//store will not be overwritten
		//we should try to do so, except when we are doing deleting,
		//and the file is saved to its self
		if(!((g_dwAction & ACTION_DELETE) && (g_fSameSrcDes==TRUE) && 
			  (FALSE==g_fDesSystemStore)))
		{
			if(OpenGenericStore(g_wszDesStoreName,
							 g_fDesSystemStore,
							 g_dwDesStoreFlag,
							 g_szDesStoreProvider,
							 g_dwDesStoreOpenFlag,
							 FALSE,
							 &hDesStore))

			{
				//if open succeeded, just move the items
				if(!MoveItem(hSrcStore, hDesStore,ITEM_CERT | ITEM_CRL |ITEM_CTL))
				{
					IDSwprintf(hModule,IDS_ERR_OPEN_DES_STORE);
					goto CLEANUP;
				}

				//now the items are moved, we need to persist them to a file.  Go on.
			
			}
			//if we can not open the generic store, then the desination store
			//does not exist.  Go on
		}

	
		//now, we have the right store to save from
		if(g_fSaveAs7==TRUE)
			dwSaveAs=CERT_STORE_SAVE_AS_PKCS7;
		else
			dwSaveAs=CERT_STORE_SAVE_AS_STORE;

		if(!CertSaveStore(hDesStore ? hDesStore : hSrcStore,
						g_dwMsgAndCertEncodingType,
						dwSaveAs,
						CERT_STORE_SAVE_TO_FILENAME_W,
						g_wszDesStoreName,
						0))
		{
			IDSwprintf(hModule,IDS_ERR_SAVE_DES_STORE);
			goto CLEANUP;
		}
	}

	fResult=TRUE;

CLEANUP:

	if(hDesStore)
		CertCloseStore(hDesStore, 0);

	return fResult;

}


//-------------------------------------------------------------------------
//
//	Set EKU property to all the certificate in the store
//
//-------------------------------------------------------------------------
BOOL	SetEKUProperty( HCERTSTORE		hSrcStore)
{

	BOOL				fResult=FALSE;
	BYTE				*pbEncoded =NULL;
    DWORD				cbEncoded =0;
    DWORD				cCount;
    LPSTR				psz=NULL;
    LPSTR				pszTok=NULL;
    DWORD				cTok = 0;
    PCERT_ENHKEY_USAGE	pUsage =NULL;
	CRYPT_DATA_BLOB		Blob;

    PCCERT_CONTEXT		pCertContext=NULL;
	PCCERT_CONTEXT		pCertPre=NULL;


	if(S_OK != WSZtoSZ(g_wszEKU, &psz))
		return FALSE;

    // Count the number of OIDs as well as converting from comma delimited
    // to NULL character delimited
    pszTok = strtok(psz, ",");
    while ( pszTok != NULL )
    {
        cTok++;
        pszTok = strtok(NULL, ",");
    }

	//if cTok is 0, make sure user has passed in the correct format
	if(0==cTok)
	{
		if(0!=strcmp(psz, ","))
			goto CLEANUP;
	}

    // Allocate a cert enhanced key usage structure and fill it in with
    // the string tokens
	if(0!=cTok)
	{
		pUsage = (PCERT_ENHKEY_USAGE)ToolUtlAlloc(sizeof(CERT_ENHKEY_USAGE));

		if(NULL==pUsage)
			goto CLEANUP;

		pUsage->cUsageIdentifier = cTok;
		pUsage->rgpszUsageIdentifier = (LPSTR *)ToolUtlAlloc(sizeof(LPSTR)*cTok);
        
        if(NULL==pUsage->rgpszUsageIdentifier)
            goto CLEANUP;

		//set up the OID array
		pszTok = psz;

		for ( cCount = 0; cCount < cTok; cCount++ )
		{
			pUsage->rgpszUsageIdentifier[cCount] = pszTok;
			pszTok = pszTok+strlen(pszTok)+1;
		}

		// Encode the usage
		if(!CryptEncodeObject(
                       X509_ASN_ENCODING,
                       szOID_ENHANCED_KEY_USAGE,
                       pUsage,
                       NULL,
                       &cbEncoded
                       ))
			goto CLEANUP;

		pbEncoded = (BYTE *)ToolUtlAlloc(cbEncoded);
		if ( NULL == pbEncoded)
			goto CLEANUP;

 
		if(!CryptEncodeObject(X509_ASN_ENCODING,
                               szOID_ENHANCED_KEY_USAGE,
                               pUsage,
                               pbEncoded,
                               &cbEncoded
                               ))
			goto CLEANUP;
	}

	//now, set the EKU for each certificate in the store
	while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
	{
		//1st, delete the original property
		if(!CertSetCertificateContextProperty(pCertContext,
										CERT_ENHKEY_USAGE_PROP_ID,
										0,
										NULL))
			goto CLEANUP;

		//2nd, set the new property	if required
		if(0!=cTok)
		{	
			Blob.cbData=cbEncoded;
			Blob.pbData=pbEncoded;

			if(!CertSetCertificateContextProperty(pCertContext,
										CERT_ENHKEY_USAGE_PROP_ID,
										0,
										&Blob))
			goto CLEANUP;
		}

		pCertPre=pCertContext;
	}


	fResult=TRUE;

CLEANUP:

	if(psz)
		ToolUtlFree(psz);

	if(pUsage)
	{
	   if(pUsage->rgpszUsageIdentifier)
		   ToolUtlFree(pUsage->rgpszUsageIdentifier);
	   ToolUtlFree(pUsage);

	}

	if(pbEncoded)
		ToolUtlFree(pbEncoded);

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);


	return fResult;

}

//-------------------------------------------------------------------------
//
//	Set name property to all the certificate in the store
//
//-------------------------------------------------------------------------
BOOL	SetNameProperty( HCERTSTORE		hSrcStore)
{

	BOOL				fResult=FALSE;
	CRYPT_DATA_BLOB		Blob;

    PCCERT_CONTEXT		pCertContext=NULL;
	PCCERT_CONTEXT		pCertPre=NULL;


    //init the name property
    Blob.cbData=(wcslen(g_wszName)+1)*sizeof(WCHAR);
    Blob.pbData=(BYTE*)g_wszName;

	//now, set the NAME for each certificate in the store
	while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
	{
		//1st, delete the original property
		if(!CertSetCertificateContextProperty(pCertContext,
										CERT_FRIENDLY_NAME_PROP_ID,
										0,
										NULL))
			goto CLEANUP;

		//2nd, set the new property	if required

		if(!CertSetCertificateContextProperty(pCertContext,
										CERT_FRIENDLY_NAME_PROP_ID,
										0,
										&Blob))
			goto CLEANUP;

		pCertPre=pCertContext;
	}


	fResult=TRUE;

CLEANUP:


	if(pCertContext)
		CertFreeCertificateContext(pCertContext);


	return fResult;

}


//-------------------------------------------------------------------------
//
//	Find a CRL based on SHA1 hash
//
//-------------------------------------------------------------------------
PCCRL_CONTEXT	FindCRLInStore(HCERTSTORE hCertStore,
							   CRYPT_HASH_BLOB	*pBlob)
{

	BYTE			*pbData=NULL;
	DWORD			cbData=0;

	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;
	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	if(!pBlob)
		return NULL;

	if(!(pBlob->pbData))
		return NULL;

	//enum the CRLS
	while(pCRLContext=CertGetCRLFromStore(hCertStore,
											NULL,
											pCRLPre,
											&dwCRLFlag))
	{
		//get the hash
		if(!CertGetCRLContextProperty(pCRLContext,
						CERT_SHA1_HASH_PROP_ID,
						NULL,
						&cbData))
			goto CLEANUP;

		pbData=(BYTE *)ToolUtlAlloc(cbData);
		if(!pbData)
			goto CLEANUP;

		if(!CertGetCRLContextProperty(pCRLContext,
						CERT_SHA1_HASH_PROP_ID,
						pbData,
						&cbData))
			goto CLEANUP;

		//Compare
		if(cbData==pBlob->cbData)
		{
			if(memcmp(pbData, pBlob->pbData, cbData)==0)
			{
				fResult=TRUE;
				break;
			}
		}

		pCRLPre=pCRLContext;

	}


CLEANUP:

	if(pbData)
		ToolUtlFree(pbData);

	if(FALSE==fResult)
	{
		if(pCRLContext)
		{
			CertFreeCRLContext(pCRLContext);
			pCRLContext=NULL;
		}
	}

	return pCRLContext;


}

//-------------------------------------------------------------------------
//
//	Move Certs/CRls/CTLs from the source store to the destination
//
//-------------------------------------------------------------------------
BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem)
{
	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//add the certs
	if(dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
		 {

			if(!CertAddCertificateContextToStore(hDesStore,
												pCertContext,
												CERT_STORE_ADD_REPLACE_EXISTING,
												NULL))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }

	}

	//add the CTLs
	if(dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hSrcStore, pCTLPre))
		 {
			if(!CertAddCTLContextToStore(hDesStore,
										pCTLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCTLPre=pCTLContext;
		 }
	}

	//add the CRLs
	if(dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hSrcStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {

			if(!CertAddCRLContextToStore(hDesStore,
										pCRLContext,
										CERT_STORE_ADD_REPLACE_EXISTING,
										NULL))
				goto CLEANUP;

			pCRLPre=pCRLContext;
		 }

	}


	fResult=TRUE;


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Delete Certs/CRls/CTLs from the source store
//
//-------------------------------------------------------------------------
BOOL	DeleteItem(HCERTSTORE	hSrcStore, 
				 DWORD		dwItem)
{
	BOOL			fResult=FALSE;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//add the certs
	if(dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hSrcStore, pCertPre))
		 {
			pCertPre=pCertContext;

			if(!CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pCertContext)))
				goto CLEANUP;

		 }

	}

	//add the CTLs
	if(dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hSrcStore, pCTLPre))
		 {
			 pCTLPre=pCTLContext;

			 if(!CertDeleteCTLFromStore(CertDuplicateCTLContext(pCTLContext)))
				goto CLEANUP;


		 }
	}

	//add the CRLs
	if(dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hSrcStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {

			pCRLPre=pCRLContext;

			if(!CertDeleteCRLFromStore(CertDuplicateCRLContext(pCRLContext)))
				goto CLEANUP;
			
		 }

	}


	fResult=TRUE;


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Display all the certificates and prompt user for the index
//
//-------------------------------------------------------------------------
BOOL	DisplayCertAndPrompt(PCCERT_CONTEXT	*rgpCertContext, 
							 DWORD			dwCertCount,
							 DWORD			*pdwIndex)
{  	
	DWORD			dwIndex=0;
	

	if(!pdwIndex)
		return FALSE;

	//the count has to be more than 1	
	if(dwCertCount<2)
		return FALSE;

	//Display all the certs
	for(dwIndex=0; dwIndex<dwCertCount; dwIndex++)
	{

		IDSwprintf(hModule,IDS_CERT_INDEX, dwIndex+1);

		if(!DisplayCert(rgpCertContext[dwIndex], 0))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY);
			return FALSE;
		}
	}

	//promot user for an index
		//tell them starting from 1
    if(g_dwAction & ACTION_ADD)
	    IDSwprintf(hModule,IDS_ENTER_ADD_INDEX_CERT);
    else
    {
        if(g_dwAction & ACTION_DELETE)
            IDSwprintf(hModule, IDS_ENTER_DELETE_INDEX_CERT);
        else
        {
            IDSwprintf(hModule, IDS_ENTER_PUT_INDEX_CERT);
        }
    }

	if (0 == scanf("%d",pdwIndex))
    {
        return FALSE;
    }

	if((*pdwIndex>=1) && (*pdwIndex<=dwCertCount))
	{

		//return the index
		*pdwIndex=*pdwIndex-1;

		return TRUE;
	}

	IDSwprintf(hModule, IDS_ERR_INVALID_INDEX);
	
	return FALSE;
}
//-------------------------------------------------------------------------
//
//	Display all the CRLs and prompt user for the index
//
//-------------------------------------------------------------------------
BOOL	DisplayCRLAndPrompt(PCCRL_CONTEXT	*rgpCRLContext, 
							 DWORD			dwCRLCount, 
							 DWORD			*pdwIndex)
{  	
	DWORD			dwIndex=0;
	

	if(!pdwIndex)
		return FALSE;

	//the count has to be more than 1	
	if(dwCRLCount<2)
		return FALSE;

	//Display all the CRLs
	for(dwIndex=0; dwIndex<dwCRLCount; dwIndex++)
	{

		IDSwprintf(hModule,IDS_CRL_INDEX, dwIndex+1);

		if(!DisplayCRL(rgpCRLContext[dwIndex], 0))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY);
			return FALSE;
		}
	}

	//promot user for an index
		//tell them starting from 1
    if(g_dwAction & ACTION_ADD)
	    IDSwprintf(hModule,IDS_ENTER_ADD_INDEX_CRL);
    else
    {
        if(g_dwAction & ACTION_DELETE)
            IDSwprintf(hModule, IDS_ENTER_DELETE_INDEX_CRL);
        else
        {
            IDSwprintf(hModule, IDS_ENTER_PUT_INDEX_CRL);
        }
    }

	if (0 == scanf("%d",pdwIndex))
    {
        return FALSE;
    }

	if((*pdwIndex>=1) && (*pdwIndex<=dwCRLCount))
	{

		//return the index
		*pdwIndex=*pdwIndex-1;

		return TRUE;
	}

	IDSwprintf(hModule,IDS_ERR_INVALID_INDEX);

	return FALSE;


}

//-------------------------------------------------------------------------
//
//	Display all the CTLs and prompt user for the index
//
//-------------------------------------------------------------------------
BOOL	DisplayCTLAndPrompt(PCCTL_CONTEXT	*rgpCTLContext, 
							 DWORD			dwCTLCount, 
							 DWORD			*pdwIndex)
{  	
	DWORD			dwIndex=0;
	
	if(!pdwIndex)
		return FALSE;

	//the count has to be more than 1	
	if(dwCTLCount<2)
		return FALSE;

	//Display all the CTLs
	for(dwIndex=0; dwIndex<dwCTLCount; dwIndex++)
	{

		IDSwprintf(hModule,IDS_CTL_INDEX, dwIndex+1);

		if(!DisplayCTL(rgpCTLContext[dwIndex], 0))
		{
			IDSwprintf(hModule,IDS_ERR_DISPLAY);
			return FALSE;
		}
	}

	//promot user for an index
	//tell them starting from 1
    if(g_dwAction & ACTION_ADD)
	    IDSwprintf(hModule,IDS_ENTER_ADD_INDEX_CTL);
    else
    {
        if(g_dwAction & ACTION_DELETE)
            IDSwprintf(hModule, IDS_ENTER_DELETE_INDEX_CTL);
        else
        {
            IDSwprintf(hModule, IDS_ENTER_PUT_INDEX_CTL);
        }
    }

	if (0 == scanf("%d",pdwIndex))
    {
        return FALSE;
    }

	if((*pdwIndex>=1) && (*pdwIndex<=dwCTLCount))
	{

		//return the index
		*pdwIndex=*pdwIndex-1;

		return TRUE;
	}

	IDSwprintf(hModule,IDS_ERR_INVALID_INDEX);

	return FALSE;

}


//-------------------------------------------------------------------------
//
//	Build a list of certificates for people to choose from
//
//-------------------------------------------------------------------------
BOOL	BuildCertList(HCERTSTORE		hCertStore, 
					  LPWSTR			wszCertCN, 
					  PCCERT_CONTEXT	**prgpCertContext,
					  DWORD				*pdwCertCount)
{
	BOOL		 	 fResult=FALSE;
	PCCERT_CONTEXT	 pCertContext=NULL;
	PCCERT_CONTEXT   pCertPre=NULL;
    PCCERT_CONTEXT * rgpCertContext=NULL;
	DWORD			 dwIndex=0;
	DWORD			 dwCount=0;



	if(!prgpCertContext || !pdwCertCount)
		return FALSE;

	//init
	*prgpCertContext=NULL;
	*pdwCertCount=0;


	//if wszCertCN is NULL, include every certs in the list
	if(NULL==wszCertCN)
	{
		while(pCertContext=CertEnumCertificatesInStore(hCertStore, pCertPre))
		{
			dwCount++;

			//allocation enough memory
            rgpCertContext=(PCCERT_CONTEXT *)realloc((*prgpCertContext),
                            dwCount * sizeof(PCCERT_CONTEXT));

			if(!rgpCertContext)
				goto CLEANUP;

            *prgpCertContext=rgpCertContext;

			//duplicate the certificate context
			(*prgpCertContext)[dwCount-1]=CertDuplicateCertificateContext(pCertContext);

			if(!((*prgpCertContext)[dwCount-1]))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }

	}
	else
	{
		//we search for the certificate based on the common name
		while(pCertContext=CertFindCertificateInStore(hCertStore,  
						 		g_dwCertEncodingType,              
						 		0,                               
						 		CERT_FIND_SUBJECT_STR_W,             
						 		wszCertCN,                       
						 		pCertPre))
		{
			dwCount++;

			//allocation enough memory
            rgpCertContext=(PCCERT_CONTEXT *)realloc((*prgpCertContext),
                            dwCount * sizeof(PCCERT_CONTEXT));

			if(!rgpCertContext)
				goto CLEANUP;

            *prgpCertContext=rgpCertContext;

			//duplicate the certificate context
			(*prgpCertContext)[dwCount-1]=CertDuplicateCertificateContext(pCertContext);

			if(!((*prgpCertContext)[dwCount-1]))
				goto CLEANUP;

			pCertPre=pCertContext;
		 }
	}

	fResult=TRUE;


CLEANUP:

	if(FALSE==fResult)
	{
		if(*prgpCertContext)
		{
			for(dwIndex=0; dwIndex<dwCount; dwIndex++)
			{
				if(((*prgpCertContext)[dwIndex]))
					CertFreeCertificateContext(((*prgpCertContext)[dwIndex]));
			}

			free(*prgpCertContext);
		}

		*prgpCertContext=NULL;
		*pdwCertCount=0;
	}
	else
	{
		*pdwCertCount=dwCount;
	}

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	return fResult;

}

//-------------------------------------------------------------------------
//
//	Build a list of CRLs for people to choose from
//
//-------------------------------------------------------------------------
BOOL	BuildCRLList(	HCERTSTORE		hCertStore, 
						PCCRL_CONTEXT	**prgpCRLContext,
						DWORD			*pdwCRLCount)
{
	BOOL			fResult=FALSE;
	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;
    PCCRL_CONTEXT * rgpCRLContext=NULL;
	DWORD			dwCRLFlag=0;
	DWORD			dwIndex=0;
	DWORD			dwCount=0;



	if(!prgpCRLContext || !pdwCRLCount)
		return FALSE;

	//init
	*prgpCRLContext=NULL;
	*pdwCRLCount=0;


	while(pCRLContext=CertGetCRLFromStore(hCertStore, 
											NULL,
											pCRLPre,
											&dwCRLFlag))
	{
			dwCount++;

			//allocation enough memory
			rgpCRLContext=(PCCRL_CONTEXT *)realloc((*prgpCRLContext),
				dwCount * sizeof(PCCRL_CONTEXT));

			if(!rgpCRLContext)
				goto CLEANUP;

            *prgpCRLContext=rgpCRLContext;

			//duplicate the CRL context
			(*prgpCRLContext)[dwCount-1]=CertDuplicateCRLContext(pCRLContext);

			if(!((*prgpCRLContext)[dwCount-1]))
				goto CLEANUP;

			pCRLPre=pCRLContext;
		 }

	fResult=TRUE;


CLEANUP:

	if(FALSE==fResult)
	{
		if(*prgpCRLContext)
		{
			for(dwIndex=0; dwIndex<dwCount; dwIndex++)
			{
				if(((*prgpCRLContext)[dwIndex]))
					CertFreeCRLContext(((*prgpCRLContext)[dwIndex]));
			}

			free(*prgpCRLContext);
		}

		*prgpCRLContext=NULL;
		*pdwCRLCount=0;
	}
	else
	{
		*pdwCRLCount=dwCount;
	}

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);


	return fResult;

}

//-------------------------------------------------------------------------
//
//	Build a list of CTLs for people to choose from
//
//-------------------------------------------------------------------------
BOOL	BuildCTLList(	HCERTSTORE		hCertStore, 
						PCCTL_CONTEXT	**prgpCTLContext,
						DWORD			*pdwCTLCount)
{
	BOOL			fResult=FALSE;
	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;
    PCCTL_CONTEXT * rgpCTLContext=NULL;
	DWORD			dwIndex=0;
	DWORD			dwCount=0;



	if(!prgpCTLContext || !pdwCTLCount)
		return FALSE;

	//init
	*prgpCTLContext=NULL;
	*pdwCTLCount=0;


	while(pCTLContext=CertEnumCTLsInStore(hCertStore,pCTLPre))
	{
			dwCount++;

			//allocation enough memory
			rgpCTLContext=(PCCTL_CONTEXT *)realloc((*prgpCTLContext),
				dwCount * sizeof(PCCTL_CONTEXT));

			if(!rgpCTLContext)
				goto CLEANUP;

            *prgpCTLContext=rgpCTLContext;

			//duplicate the CTL context
			(*prgpCTLContext)[dwCount-1]=CertDuplicateCTLContext(pCTLContext);

			if(!((*prgpCTLContext)[dwCount-1]))
				goto CLEANUP;

			pCTLPre=pCTLContext;
		 }

	fResult=TRUE;


CLEANUP:

	if(FALSE==fResult)
	{
		if(*prgpCTLContext)
		{
			for(dwIndex=0; dwIndex<dwCount; dwIndex++)
			{
				if(((*prgpCTLContext)[dwIndex]))
					CertFreeCTLContext(((*prgpCTLContext)[dwIndex]));
			}

			free(*prgpCTLContext);
		}

		*prgpCTLContext=NULL;
		*pdwCTLCount=0;
	}
	else
	{
		*pdwCTLCount=dwCount;
	}

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);


	return fResult;

}
//-------------------------------------------------------------------------
//
//	Display everthing in a store
//
//-------------------------------------------------------------------------
BOOL	DisplayCertStore(HCERTSTORE	hCertStore)
{
	BOOL			fResult=FALSE;
	DWORD			dwCount=0;
	DWORD			dwCRLFlag=0;

	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pCertPre=NULL;

	PCCRL_CONTEXT	pCRLContext=NULL;
	PCCRL_CONTEXT	pCRLPre=NULL;

	PCCTL_CONTEXT	pCTLContext=NULL;
	PCCTL_CONTEXT	pCTLPre=NULL;

	//Display the certs
	if(g_dwItem & ITEM_CERT)
	{
		 while(pCertContext=CertEnumCertificatesInStore(hCertStore, pCertPre))
		 {
			dwCount++;

			IDSwprintf(hModule,IDS_CERT_INDEX, dwCount);

			if(!DisplayCert(pCertContext, g_dwItem))
			{
				IDSwprintf(hModule,IDS_ERR_DISPLAY);
			}

			pCertPre=pCertContext;
		 }

		 if(0==dwCount)
			 IDSwprintf(hModule,IDS_NO_CERT);
	}

	dwCount=0;
	//Display the CTLs
	if(g_dwItem & ITEM_CTL)
	{
		 while(pCTLContext=CertEnumCTLsInStore(hCertStore, pCTLPre))
		 {
			dwCount++;

			IDSwprintf(hModule,IDS_CTL_INDEX, dwCount);

			if(!DisplayCTL(pCTLContext, g_dwItem))
			{
				IDSwprintf(hModule,IDS_ERR_DISPLAY);
			}

			pCTLPre=pCTLContext;
		 }

		 if(0==dwCount)
			 IDSwprintf(hModule,IDS_NO_CTL);
	}

	dwCount=0;
	//Display the CRLs
	if(g_dwItem & ITEM_CRL)
	{
		 while(pCRLContext=CertGetCRLFromStore(hCertStore,
												NULL,
												pCRLPre,
												&dwCRLFlag))
		 {
			dwCount++;

			IDSwprintf(hModule,IDS_CRL_INDEX, dwCount);

			if(!DisplayCRL(pCRLContext, g_dwItem))
			{
				IDSwprintf(hModule,IDS_ERR_DISPLAY);
			}

			pCRLPre=pCRLContext;
		 }

		 if(0==dwCount)
			 IDSwprintf(hModule,IDS_NO_CRL);
	}



	fResult=TRUE;



	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCTLContext)
		CertFreeCTLContext(pCTLContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	return fResult;

}

//+-------------------------------------------------------------------------
//  DisplaySMIMECapabilitiesExtension
//--------------------------------------------------------------------------
void DisplayTimeStamp(BYTE *pbEncoded,DWORD cbEncoded,DWORD	dwDisplayFlags)
{
	CMSG_SIGNER_INFO	*pSignerInfo=NULL;

	if (NULL == (pSignerInfo = (CMSG_SIGNER_INFO *) TestNoCopyDecodeObject(
            PKCS7_SIGNER_INFO,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

	//display the timestamper's information
	//"   Timestamp Version:: %d\n"
	IDSwprintf(hModule, IDS_TS_VERSION, pSignerInfo->dwVersion);

	//"Timestamp server's certificate issuer::\n");
	IDSwprintf(hModule, IDS_TS_ISSUER);
	
    DecodeName(pSignerInfo->Issuer.pbData,
        pSignerInfo->Issuer.cbData, dwDisplayFlags);

   	//"Timestamp server's certificate SerialNumber::\n"
    IDSwprintf(hModule, IDS_TS_SERIAL_NUMBER);       
    DisplaySerialNumber(&pSignerInfo->SerialNumber);
    printf("\n");

	//"Timestamp's authenticated attributes::\n"
	IDSwprintf(hModule, IDS_TS_AUTHATTR);       
	PrintAttributes(pSignerInfo->AuthAttrs.cAttr, pSignerInfo->AuthAttrs.rgAttr, 
		dwDisplayFlags);

	//"Timestamp's unauthenticated attributes::\n"
	if(pSignerInfo->UnauthAttrs.cAttr)
	{
		IDSwprintf(hModule, IDS_TS_UNAUTHATTR);       
		PrintAttributes(pSignerInfo->UnauthAttrs.cAttr, 
			pSignerInfo->UnauthAttrs.rgAttr, 
			dwDisplayFlags);
	}

CommonReturn:

	if(pSignerInfo)
		ToolUtlFree(pSignerInfo);

	return;
}


//-------------------------------------------------------------------------
//
//	Display a certificate
//
//-------------------------------------------------------------------------
BOOL	DisplayCert(PCCERT_CONTEXT	pCert, DWORD	dwDisplayFlags)
{
	BOOL		fResult=FALSE;
	BYTE		rgbHash[MAX_HASH_LEN];
    DWORD		cbHash = MAX_HASH_LEN;
	HCRYPTPROV	hProv = 0;


						 
	//"Subject::\n");
	IDSwprintf(hModule, IDS_SUBJECT);
	
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData, dwDisplayFlags);

	//"Issuer::\n"
    IDSwprintf(hModule, IDS_ISSUER);

    DecodeName(pCert->pCertInfo->Issuer.pbData,
            pCert->pCertInfo->Issuer.cbData, dwDisplayFlags);

	//"SerialNumber::"
    IDSwprintf(hModule, IDS_SERIAL_NUMBER);       
    DisplaySerialNumber(&pCert->pCertInfo->SerialNumber);
    printf("\n");

    CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
	);
    DisplayThumbprint(g_wszSHA1, rgbHash, cbHash);

    cbHash = MAX_HASH_LEN;
    CertGetCertificateContextProperty(
            pCert,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
     );
     DisplayThumbprint(g_wszMD5, rgbHash, cbHash);


           
    CryptAcquireContext(
                &hProv,
                NULL,
                NULL,           // pszProvider
                PROV_RSA_FULL,
                0               // dwFlags
	);
	if (hProv) 
	{
        cbHash = MAX_HASH_LEN;
        CryptHashPublicKeyInfo(
             hProv,
             CALG_MD5,
             0,                  // dwFlags
             g_dwCertEncodingType,
             &pCert->pCertInfo->SubjectPublicKeyInfo,
             rgbHash,
             &cbHash
        );


		//"Key "
		IDSwprintf(hModule, IDS_KEY);

        DisplayThumbprint(g_wszMD5, rgbHash, cbHash);
        CryptReleaseContext(hProv, 0);
	}

	//print the Key_Prov_Info_Prop_ID
    {
        PCRYPT_KEY_PROV_INFO pInfo = NULL;
        DWORD cbInfo;

        cbInfo = 0;

        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                           // pvData
            &cbInfo
            );
        if (cbInfo) 
		{
            pInfo = (PCRYPT_KEY_PROV_INFO) ToolUtlAlloc(cbInfo);
            if (pInfo) 
			{
                if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        pInfo,
                        &cbInfo
                        )) 
				{
					//"Provider Type:: %d"
					IDSwprintf(hModule, IDS_KEY_PROVIDER, pInfo->dwProvType);

					//" Provider Name:: %s"
                    if (pInfo->pwszProvName)
						IDSwprintf(hModule, IDS_PROV_NAME, pInfo->pwszProvName);
					
					//" Flags: 0x%x"
                    if (pInfo->dwFlags)
                        IDSwprintf(hModule, IDS_FLAGS, pInfo->dwFlags);

					//" Container: %S"
                    if (pInfo->pwszContainerName)
						IDSwprintf(hModule, IDS_CONTAINER, pInfo->pwszContainerName);

                    //" Params: %d" 
					if (pInfo->cProvParam)
						IDSwprintf(hModule, IDS_PARAM,pInfo->cProvParam);

					//" KeySpec: %d"
                    if (pInfo->dwKeySpec)
                        IDSwprintf(hModule, IDS_KEY_SPEC, pInfo->dwKeySpec);
                    printf("\n");
                } 

                ToolUtlFree(pInfo);
            }
        }
    }


	//"NotBefore:: %s\n"
    IDSwprintf(hModule, IDS_NOT_BEFORE, FileTimeText(&pCert->pCertInfo->NotBefore));

	//"NotAfter:: %s\n"
    IDSwprintf(hModule, IDS_NOT_AFTER, FileTimeText(&pCert->pCertInfo->NotAfter));


	//Display the aux properties if verbose
	if(dwDisplayFlags & ITEM_VERBOSE)
		PrintAuxCertProperties(pCert,dwDisplayFlags);

    if (dwDisplayFlags & ITEM_VERBOSE) 
	{
        LPSTR	pszObjId;
        ALG_ID	aiPubKey;
        DWORD	dwBitLen;


		//"Version:: %d\n"
		IDSwprintf(hModule, IDS_VERSION, pCert->pCertInfo->dwVersion);

        pszObjId = pCert->pCertInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		//"SignatureAlgorithm:: "
		IDSwprintf(hModule, IDS_SIG_ALGO);

        printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));

        if (pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData) 
		{
			//"SignatureAlgorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SIG_ALGO_PARAM);
            PrintBytes(L"    ",
                pCert->pCertInfo->SignatureAlgorithm.Parameters.pbData,
                pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData);
        }


		//public key algorithm
        pszObjId = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		// "SubjectPublicKeyInfo.Algorithm:: 
		IDSwprintf(hModule, IDS_SUB_KEY_ALGO);

        printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID));

        aiPubKey = GetAlgid(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) 
		{
			//"SubjectPublicKeyInfo.Algorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SUB_KEY_ALGO_PARAM);

            PrintBytes(L"    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);

			//display DSS sign key
            if (CALG_DSS_SIGN == aiPubKey) 
			{
                PCERT_DSS_PARAMETERS pDssParameters;
                DWORD cbDssParameters;
                if (pDssParameters =
                    (PCERT_DSS_PARAMETERS) TestNoCopyDecodeObject(
                        X509_DSS_PARAMETERS,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
                        &cbDssParameters
                        )) 
				{
                    DWORD cbKey = pDssParameters->p.cbData;

					//"DSS Key Length:: %d bytes, %d bits\n"
                    IDSwprintf(hModule, IDS_DSS_LENGTH, cbKey, cbKey*8);

					//"DSS P (little endian)::\n"
                    IDSwprintf(hModule, IDS_DSS_P);
                    PrintBytes(L"    ", pDssParameters->p.pbData,
                        pDssParameters->p.cbData);

					//"DSS Q (little endian)::\n"
                    IDSwprintf(hModule, IDS_DSS_Q);
                    PrintBytes(L"    ", pDssParameters->q.pbData,
                        pDssParameters->q.cbData);

					//"DSS G (little endian)::\n"
                    IDSwprintf(hModule, IDS_DSS_G);
                    PrintBytes(L"    ", pDssParameters->g.pbData,
                        pDssParameters->g.cbData);

                    ToolUtlFree(pDssParameters);
                }
            }
        }

		//"SubjectPublicKeyInfo.PublicKey"
        IDSwprintf(hModule, IDS_SUB_KEY_INFO);

        if (0 != (dwBitLen = CertGetPublicKeyLength(
                g_dwCertEncodingType,
                &pCert->pCertInfo->SubjectPublicKeyInfo)))
			//" (BitLength: %d)"
            IDSwprintf(hModule, IDS_BIT_LENGTH, dwBitLen);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
			//" (UnusedBits: %d)"
            IDSwprintf(hModule, IDS_UNUSED_BITS,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);

        printf("\n");

		//print public key
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData) 
		{
            PrintBytes(L"    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

            if (CALG_RSA_SIGN == aiPubKey || CALG_RSA_KEYX == aiPubKey) 
			{
                PUBLICKEYSTRUC	*pPubKeyStruc=NULL;
                DWORD			cbPubKeyStruc;

				//"RSA_CSP_PUBLICKEYBLOB::\n"
                IDSwprintf(hModule, IDS_RSA_CSP);
                if (pPubKeyStruc = (PUBLICKEYSTRUC *) TestNoCopyDecodeObject(
                        RSA_CSP_PUBLICKEYBLOB,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbPubKeyStruc
                        )) 
				{
                    PrintBytes(L"    ", (BYTE *) pPubKeyStruc, cbPubKeyStruc);
                    ToolUtlFree(pPubKeyStruc);
                }
            } 
			else if (CALG_DSS_SIGN == aiPubKey) 
			{
                PCRYPT_UINT_BLOB	pDssPubKey;
                DWORD				cbDssPubKey;


				//"DSS Y (little endian)::\n"
                IDSwprintf(hModule, IDS_DSS_Y);
                
				if (pDssPubKey = (PCRYPT_UINT_BLOB) TestNoCopyDecodeObject
				(
                        X509_DSS_PUBLICKEY,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbDssPubKey
                        )) 
				{
                    PrintBytes(L"    ", pDssPubKey->pbData, pDssPubKey->cbData);
                    ToolUtlFree(pDssPubKey);
                }
            }
        } 
		else
			//"  No public key\n"
            IDSwprintf(hModule, IDS_NO_PUB_KEY);

        DisplaySignature
		(
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            dwDisplayFlags);

		//IssuerUniqueId
        if (pCert->pCertInfo->IssuerUniqueId.cbData) 
		{
			//"IssuerUniqueId"
			IDSwprintf(hModule, IDS_ISSUER_ID);

            if (pCert->pCertInfo->IssuerUniqueId.cUnusedBits)

				//" (UnusedBits: %d)"
				IDSwprintf(hModule, IDS_UNUSED_BITS,
                    pCert->pCertInfo->IssuerUniqueId.cUnusedBits);

            printf("\n");
            PrintBytes(L"    ", pCert->pCertInfo->IssuerUniqueId.pbData,
                pCert->pCertInfo->IssuerUniqueId.cbData);
        }

        if (pCert->pCertInfo->SubjectUniqueId.cbData) 
		{
			//"SubjectUniqueId"
			IDSwprintf(hModule, IDS_SUBJECT_ID);

            if (pCert->pCertInfo->SubjectUniqueId.cUnusedBits)
				//" (UnusedBits: %d)"
				IDSwprintf(hModule, IDS_UNUSED_BITS,
                    pCert->pCertInfo->SubjectUniqueId.cUnusedBits);


            printf("\n");
            PrintBytes(L"    ", pCert->pCertInfo->SubjectUniqueId.pbData,
                pCert->pCertInfo->SubjectUniqueId.cbData);
        }


		//extensions
		if (pCert->pCertInfo->cExtension != 0) 
		{
			PrintExtensions(pCert->pCertInfo->cExtension,
                pCert->pCertInfo->rgExtension, dwDisplayFlags);
		}


    }//ITEM_VERBOSE


	fResult=TRUE;


	return fResult;


}

//-------------------------------------------------------------------------
//
//	Display a CTL
//
//-------------------------------------------------------------------------
BOOL	DisplayCTL(PCCTL_CONTEXT	pCtl, DWORD	dwDisplayFlags)
{
	BOOL		fResult=FALSE;
    PCTL_INFO	pInfo = pCtl->pCtlInfo;
    DWORD		cId;
    LPSTR		*ppszId = NULL;
    DWORD		i;
	BYTE		rgbHash[MAX_HASH_LEN];
    DWORD		cbHash = MAX_HASH_LEN;
 


 	// "SubjectUsage::\n"
    IDSwprintf(hModule, IDS_SUBJECT_USAGE);

    
	cId = pInfo->SubjectUsage.cUsageIdentifier;
    ppszId = pInfo->SubjectUsage.rgpszUsageIdentifier;
    if (cId == 0)
	{
		//"  No Usage Identifiers\n"
        IDSwprintf(hModule, IDS_NO_USAGE_IDS );
	}
	else
	{
		for (i = 0; i < cId; i++, ppszId++)
			printf("  [%d] %s\n", i, *ppszId);
	}

	//list identifier
    if (pInfo->ListIdentifier.cbData)
	{
		//"ListIdentifier::\n"
        IDSwprintf(hModule, IDS_LIST_DIS);
        PrintBytes(L"    ",
            pInfo->ListIdentifier.pbData,
            pInfo->ListIdentifier.cbData);
    }

    if (pInfo->SequenceNumber.cbData) 
	{	
		//"SequenceNumber::"
        IDSwprintf(hModule, IDS_SEQUENCE);
        DisplaySerialNumber(&pInfo->SequenceNumber);
        printf("\n");
    }

	//update 
	//"ThisUpdate:: %s\n"
	IDSwprintf(hModule, IDS_THIS_UPDATE, FileTimeText(&pCtl->pCtlInfo->ThisUpdate));
	//"NextUpdate:: %s\n"
	IDSwprintf(hModule,IDS_NEXT_UPDATE, FileTimeText(&pCtl->pCtlInfo->NextUpdate));

	//check the time validity
    if (!IsTimeValidCtl(pCtl))
		// "****** Time Invalid CTL\n"
		IDSwprintf(hModule, IDS_TIME_INVALID);


	//Display SHA1 thumbprint

    CertGetCTLContextProperty(
            pCtl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );

    DisplayThumbprint(g_wszSHA1, rgbHash, cbHash);

	cbHash=MAX_HASH_LEN;

	CertGetCTLContextProperty(
            pCtl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );

    DisplayThumbprint(g_wszMD5, rgbHash, cbHash);

 //   PrintAuxCtlProperties(pCtl, dwDisplayFlags);

	//Display SubjectAlgorithm
    if (dwDisplayFlags & ITEM_VERBOSE) 
	{
        LPSTR pszObjId;

		//"Version:: %d\n"
		IDSwprintf(hModule, IDS_VERSION, pInfo->dwVersion);


        pszObjId = pInfo->SubjectAlgorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		//"SubjectAlgorithm:: "
		IDSwprintf(hModule, IDS_SUB_ALGO);
        printf("%s \n", pszObjId);

        if (pInfo->SubjectAlgorithm.Parameters.cbData) 
		{
			//"SubjectAlgorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SUB_ALGO_PARAM);
            PrintBytes(L"    ",
                pInfo->SubjectAlgorithm.Parameters.pbData,
                pInfo->SubjectAlgorithm.Parameters.cbData);
        }

		if (pInfo->cExtension != 0) 
		{
			PrintExtensions(pInfo->cExtension, pInfo->rgExtension,
                dwDisplayFlags);
		}

    }



	if (pInfo->cCTLEntry == 0)
		//"-----  No Entries  -----\n"
		IDSwprintf(hModule, IDS_NO_ENTRIES);
	else
	{
		//"-----  Entries  -----\n"
		IDSwprintf(hModule, IDS_ENTRIES);
		PrintCtlEntries(pCtl,dwDisplayFlags);
	}

	//print the signer info
	DisplaySignerInfo(pCtl->hCryptMsg, dwDisplayFlags);


	fResult=TRUE;



	return fResult;


}


//-------------------------------------------------------------------------
//
//	Display a CTL entries
//
//-------------------------------------------------------------------------
 void PrintCtlEntries(PCCTL_CONTEXT pCtl, DWORD dwDisplayFlags)
{
    PCTL_INFO	pInfo = pCtl->pCtlInfo;
    DWORD		cEntry = pInfo->cCTLEntry;
    PCTL_ENTRY	pEntry = pInfo->rgCTLEntry;
    DWORD		i;


    for (i = 0; i < cEntry; i++, pEntry++) 
	{
		//" [%d] SubjectIdentifier::\n"
		IDSwprintf(hModule, IDS_SUB_ID,i);
        PrintBytes(L"      ",
            pEntry->SubjectIdentifier.pbData,
            pEntry->SubjectIdentifier.cbData);


        if (dwDisplayFlags & ITEM_VERBOSE) 
		{
            if (pEntry->cAttribute) 
			{
				//" [%d] Attributes::\n"
                IDSwprintf(hModule, IDS_ATTR, i);

                PrintAttributes(pEntry->cAttribute, pEntry->rgAttribute,
                    dwDisplayFlags);
            }
        }
    }
}

//-------------------------------------------------------------------------
//
//	Display a CRL
//
//-------------------------------------------------------------------------
BOOL	DisplayCRL(PCCRL_CONTEXT	pCrl, DWORD	dwDisplayFlags)
{
	BOOL		fResult=FALSE;
	BYTE		rgbHash[MAX_HASH_LEN];
    DWORD		cbHash = MAX_HASH_LEN;


	//"Issuer::\n"
    IDSwprintf(hModule, IDS_ISSUER);
    
    DecodeName(pCrl->pCrlInfo->Issuer.pbData,
            pCrl->pCrlInfo->Issuer.cbData, dwDisplayFlags);

	//"ThisUpdate:: %s\n"
	IDSwprintf(hModule, IDS_THIS_UPDATE, FileTimeText(&pCrl->pCrlInfo->ThisUpdate));
	//"NextUpdate:: %s\n"
	IDSwprintf(hModule,IDS_NEXT_UPDATE, FileTimeText(&pCrl->pCrlInfo->NextUpdate));


    CertGetCRLContextProperty(
            pCrl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
    DisplayThumbprint(g_wszSHA1, rgbHash, cbHash);

	cbHash=MAX_HASH_LEN;
    CertGetCRLContextProperty(
            pCrl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
    DisplayThumbprint(g_wszMD5, rgbHash, cbHash);

  //  PrintAuxCrlProperties(pCrl, dwDisplayFlags);

    if (dwDisplayFlags & ITEM_VERBOSE) 
	{
        LPSTR pszObjId;

		//"Version:: %d\n"
		IDSwprintf(hModule, IDS_VERSION, pCrl->pCrlInfo->dwVersion);
	

        pszObjId = pCrl->pCrlInfo->SignatureAlgorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;


		//"SignatureAlgorithm::  "
		IDSwprintf(hModule, IDS_SIG_ALGO);
        printf("%s \n", pszObjId);

        if (pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData) 
		{
			//"SignatureAlgorithm.Parameters::\n"
			IDSwprintf(hModule, IDS_SIG_ALGO_PARAM);
            PrintBytes(L"    ",
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.pbData,
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData);
        }

			//extensions
		if (pCrl->pCrlInfo->cExtension != 0) 
		{
			PrintExtensions(pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension,
                dwDisplayFlags);
		}



    }


    if (pCrl->pCrlInfo->cCRLEntry == 0)
		//"-----  No Entries  -----\n"
		IDSwprintf(hModule, IDS_NO_ENTRIES);
    else 
	{
		//"-----  Entries  -----\n"
		IDSwprintf(hModule, IDS_ENTRIES);

        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry, dwDisplayFlags);
    }

	fResult=TRUE;

	return fResult;
}

//-------------------------------------------------------------------------
//
//	PrintCrlEntries
//
//-------------------------------------------------------------------------
 void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry,
        DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) 
	{	
		//" [%d] SerialNumber::"
		IDSwprintf(hModule, IDS_SERIAL_NUM_I, i);
        
		DisplaySerialNumber(&pEntry->SerialNumber);
        printf("\n");

        if (dwDisplayFlags & ITEM_VERBOSE) 
		{
			//" [%d] RevocationDate:: %s\n"
			IDSwprintf(hModule, IDS_REVOC_DATE, 
				i,FileTimeText(&pEntry->RevocationDate));
			
        }

		if (pEntry->cExtension == 0)
				//" [%d] Extensions:: NONE\n"
            IDSwprintf(hModule, IDS_NO_EXTENSION,i);
        else 
		{
			//" [%d] Extensions::\n"
            IDSwprintf(hModule, IDS_EXTENSION, i);

            PrintExtensions(pEntry->cExtension, pEntry->rgExtension,
                    dwDisplayFlags);
        }

    }
}


//-------------------------------------------------------------------------
//
//	Display a signer info
//
//-------------------------------------------------------------------------
BOOL	DisplaySignerInfo(HCRYPTMSG hMsg,  DWORD dwItem)
{

	BOOL				fResult=FALSE;
	DWORD				dwSignerCount=0;
	DWORD				cbData=0;
	DWORD				dwSignerIndex=0;
	PCRYPT_ATTRIBUTES	pAttrs;	  
	LPSTR				pszObjId=NULL;

	if(!hMsg)
		return FALSE;

    //decide the number of signers
    cbData=sizeof(dwSignerCount);

	if(!CryptMsgGetParam(hMsg, 
						CMSG_SIGNER_COUNT_PARAM,
						0,
						&dwSignerCount,
						&cbData) )
	{
		IDSwprintf(hModule, IDS_ERR_GET_SINGER_COUNT);
		return FALSE;
	}

	if(dwSignerCount==0)
	{
		IDSwprintf(hModule, IDS_DIS_NO_SIGNER);
		return TRUE;
	}

	for(dwSignerIndex=0; dwSignerIndex < dwSignerCount; dwSignerIndex++)
	{
         PCCERT_CONTEXT				pSigner;
		 PCMSG_SIGNER_INFO			pSignerInfo;

		 //"-----  Signer  [%d] -----\n");
		IDSwprintf(hModule, IDS_SIGNER_INDEX,  dwSignerIndex+1);

		//get the signerInfo
		if(pSignerInfo=(PCMSG_SIGNER_INFO) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_INFO_PARAM,
            dwSignerIndex,
            &cbData))
		{

			//Dispaly the hash algorithm
			 pszObjId = pSignerInfo->HashAlgorithm.pszObjId;
			if (pszObjId == NULL)
				pszObjId = g_szNULL;

			//"Hash Algorithm:: "
			IDSwprintf(hModule, IDS_HASH_ALGO);

			printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_HASH_ALG_OID_GROUP_ID));

			if (pSignerInfo->HashAlgorithm.Parameters.cbData) 
			{
				//"HashAlgorithm.Parameters::\n"
				IDSwprintf(hModule, IDS_HASH_ALGO_PARAM);
				PrintBytes(L"    ",
					pSignerInfo->HashAlgorithm.Parameters.pbData,
					pSignerInfo->HashAlgorithm.Parameters.cbData);
			}

			//Display the encrypt algorithm
			pszObjId = pSignerInfo->HashEncryptionAlgorithm.pszObjId;
			if (pszObjId == NULL)
				pszObjId = g_szNULL;

			//"Encrypt Algorithm:: "
			IDSwprintf(hModule, IDS_ENCRYPT_ALGO);

			printf("%s (%S)\n", pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));

			if (pSignerInfo->HashEncryptionAlgorithm.Parameters.cbData) 
			{
				//"Encrypt Algorithm.Parameters::\n"
				IDSwprintf(hModule, IDS_ENCRYPT_ALGO_PARAM);
				PrintBytes(L"    ",
					pSignerInfo->HashEncryptionAlgorithm.Parameters.pbData,
					pSignerInfo->HashEncryptionAlgorithm.Parameters.cbData);
			}

			ToolUtlFree(pSignerInfo);
		}


        if (CryptMsgGetAndVerifySigner(
                        hMsg,
                        0,                  // cSignerStore
                        NULL,               // rghSignerStore
                        CMSG_USE_SIGNER_INDEX_FLAG,
                        &pSigner,
                        &dwSignerIndex
                        )) 
		{
			//"-----  Signer [%d] Certificate-----\n");
			IDSwprintf(hModule, IDS_SIGNER_INDEX_CERT,  dwSignerIndex+1);
            DisplayCert(pSigner, dwItem);
            CertFreeCertificateContext(pSigner);
		}
		else
		{
			IDSwprintf(hModule, IDS_ERR_GET_SIGNER_CERT);
			goto CLEANUP;
		}

		//DisplaySigner information
		 
	   if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_AUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) 
	   {   
		   //"-----  Signer [%d] AuthenticatedAttributes  -----\n"
		   IDSwprintf(hModule, IDS_DIS_SIGNER_AUTH_ATTR, dwSignerIndex+1);
		   PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwItem);
		   ToolUtlFree(pAttrs);
	   }

		if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_UNAUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) 
		{
			//"-----  Signer [%d] UnauthenticatedAttributes  -----\n",
            IDSwprintf(hModule, IDS_DIS_SIGNER_UNAUTH_ATTR, dwSignerIndex+1);
			PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwItem);
			ToolUtlFree(pAttrs);
		}

	}

	fResult=TRUE;

CLEANUP:

	return fResult;

}


//-------------------------------------------------------------------------
//
//	Open a store file using sip functions
//
//-------------------------------------------------------------------------
HCERTSTORE OpenSipStore(LPWSTR pwszStoreFilename)
{
    HCERTSTORE			hStore = NULL;
    CRYPT_DATA_BLOB		SignedData;
    memset(&SignedData, 0, sizeof(SignedData));
    DWORD				dwGetEncodingType;
	DWORD				dwMsgType=0;

    GUID				gSubject;
    SIP_DISPATCH_INFO	SipDispatch;
    SIP_SUBJECTINFO		SubjectInfo;


    if (!CryptSIPRetrieveSubjectGuid(
            pwszStoreFilename,
            NULL,                       // hFile
            &gSubject)) goto CommonReturn;

    memset(&SipDispatch, 0, sizeof(SipDispatch));
    SipDispatch.cbSize = sizeof(SipDispatch);

    if (!CryptSIPLoad(
            &gSubject,
            0,                  // dwFlags
            &SipDispatch)) goto CommonReturn;

    memset(&SubjectInfo, 0, sizeof(SubjectInfo));
    SubjectInfo.cbSize = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType = (GUID*) &gSubject;
    SubjectInfo.hFile = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName = pwszStoreFilename;
    // SubjectInfo.pwsDisplayName = 
    // SubjectInfo.lpSIPInfo = 
    // SubjectInfo.dwReserved = 
    // SubjectInfo.hProv = 
    // SubjectInfo.DigestAlgorithm =
    // SubjectInfo.dwFlags =
    SubjectInfo.dwEncodingType = g_dwMsgAndCertEncodingType;
    // SubjectInfo.lpAddInfo =
        
    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            NULL                        // pbSignedData
            ) || 0 == SignedData.cbData)
        goto CommonReturn;

    if (NULL == (SignedData.pbData = (BYTE *) ToolUtlAlloc(SignedData.cbData)))
        goto CommonReturn;

    if (!SipDispatch.pfGet(
            &SubjectInfo, 
            &dwGetEncodingType,
            0,                          // dwIndex
            &SignedData.cbData,
            SignedData.pbData
            ))
        goto CommonReturn;

    hStore = CertOpenStore(
        CERT_STORE_PROV_PKCS7,
        g_dwMsgAndCertEncodingType,
        0,                      // hCryptProv
        0,                      // dwFlags
        (const void *) &SignedData
        );

	if(!hStore)
		goto CommonReturn;

	//now, we want to update the g_hMsg to hold the signer info
	if(SignNoContentWrap(SignedData.pbData, SignedData.cbData))
          dwMsgType = CMSG_SIGNED;

    if (!(g_hMsg = CryptMsgOpenToDecode(g_dwMsgAndCertEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          NULL,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
     {
		 CertCloseStore(hStore, 0);
		 hStore=NULL;
		 goto CommonReturn;
	 }

        
    if (!CryptMsgUpdate(g_hMsg,
                           SignedData.pbData,
                           SignedData.cbData,
                            TRUE))                    // fFinal
	  {

		 CertCloseStore(hStore, 0);
		 hStore=NULL;
		 CryptMsgClose(g_hMsg);
		 g_hMsg=NULL;
	  }


CommonReturn:
	if(SignedData.pbData)
		ToolUtlFree(SignedData.pbData);

    return hStore;
}

//-------------------------------------------------------------------------
//
//	BytesToBase64: ascii:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb)
{
    DWORD dwErr;
    BYTE *pb;
    DWORD cb;

    *ppb = NULL;
    *pcb = 0;

 
    cb = 0;
    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            NULL,
            &cb,
            NULL,
            NULL
            ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (cb == 0)
        return S_OK;

    if (NULL == (pb = (BYTE *) ToolUtlAlloc(cb)))
        return E_OUTOFMEMORY;

    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            pb,
            &cb,
            NULL,
            NULL
            )) {
        ToolUtlFree(pb);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *ppb = pb;
        *pcb = cb;
        return S_OK;
    }

}

//-------------------------------------------------------------------------
//
//	BytesToBase64 wchar version:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytesW(WCHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb)
{
    DWORD dwErr;
    BYTE *pb;
    DWORD cb;

    *ppb = NULL;
    *pcb = 0;

 
    cb = 0;
    if (!CryptStringToBinaryW(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            NULL,
            &cb,
            NULL,
            NULL
            ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (cb == 0)
        return S_OK;

    if (NULL == (pb = (BYTE *) ToolUtlAlloc(cb)))
        return E_OUTOFMEMORY;

    if (!CryptStringToBinaryW(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            pb,
            &cb,
            NULL,
            NULL
            )) {
        ToolUtlFree(pb);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *ppb = pb;
        *pcb = cb;
        return S_OK;
    }

}


//------------------------------------------------------------------------------------
//
// Base64 decode the file
//
//------------------------------------------------------------------------------------
BOOL	GetBase64Decoded(LPWSTR		wszStoreName, 
						 BYTE		**ppbByte,
						 DWORD		*pcbByte)
{
	BOOL	fResult=FALSE;
	BYTE	*pbEncoded=NULL;
	DWORD	cbEncoded=0;
	
    //get the blob
	if (S_OK != RetrieveBLOBFromFile(wszStoreName,&cbEncoded, &pbEncoded))
        return FALSE;
	
	//base64 decode.  ascii version
	if(S_OK != Base64ToBytes((CHAR *)pbEncoded, cbEncoded,
							ppbByte, pcbByte))
	{
		//WCHAR version 
		if(cbEncoded %2 == 0)
		{
			if(S_OK !=Base64ToBytesW((WCHAR *)pbEncoded, cbEncoded/2,
							ppbByte, pcbByte))
				goto CLEANUP;
		}
		else
		{
			goto CLEANUP;
		}
	}

	fResult=TRUE;

CLEANUP:

	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

	return fResult;


}
//------------------------------------------------------------------------------------
//
// Attempt to read as a file containing an encoded CRL.
//
//------------------------------------------------------------------------------------
HCERTSTORE OpenEncodedCRL(LPWSTR pwszStoreFilename)
{
    HCERTSTORE hStore=NULL;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (S_OK != RetrieveBLOBFromFile(pwszStoreFilename, &cbEncoded,&pbEncoded))
        return NULL;

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCRLToStore(
            hStore,
            g_dwCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCrlContext
            )) 
	{
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

    return hStore;
}
//------------------------------------------------------------------------------------
//
// Attempt to read as a file containing an encoded CER.
//
//------------------------------------------------------------------------------------
HCERTSTORE OpenEncodedCert (LPWSTR pwszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (S_OK != RetrieveBLOBFromFile(pwszStoreFilename, &cbEncoded, &pbEncoded))
        return NULL;

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCertificateToStore(
            hStore,
            g_dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) 
	{
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

    return hStore;
}

//------------------------------------------------------------------------------------
//
// Attempt to read as a file containing an encoded CTL.
//
//------------------------------------------------------------------------------------
HCERTSTORE OpenEncodedCTL (LPWSTR pwszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (S_OK != RetrieveBLOBFromFile(pwszStoreFilename, &cbEncoded, &pbEncoded))
        return NULL;

    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            g_dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) 
	{
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
	if(pbEncoded)
		UnmapViewOfFile(pbEncoded);

    return hStore;
}



//--------------------------------------------------------------------------------
// Set the parameters.  They can only be set once
//--------------------------------------------------------------------------------
BOOL	SetParam(WCHAR **ppwszParam, WCHAR *pwszValue)
{
	if(*ppwszParam!=NULL)
	{
		IDSwprintf(hModule,IDS_ERR_TOO_MANY_PARAM);
		return FALSE;
	}

	*ppwszParam=pwszValue;

	return TRUE;
}


//--------------------------------------------------------------------------------
// Convert an array of wchars to a BLOB
//--------------------------------------------------------------------------------
HRESULT	WSZtoBLOB(LPWSTR  pwsz, BYTE **ppbByte, DWORD	*pcbByte)
{
	HRESULT		hr=E_FAIL;
	DWORD		dwIndex=0;
	ULONG		ulHalfByte=0;
	DWORD		dw1st=0;
	DWORD		dw2nd=0;

	if((!pwsz) || (!ppbByte) || (!pcbByte))
		return E_INVALIDARG;

	*ppbByte=NULL;
	*pcbByte=0;

	//make sure the pwsz consists of 20 characters
	if(wcslen(pwsz)!= 2*SHA1_LENGTH)
		return E_FAIL;

	//memory allocation 
	*ppbByte=(BYTE *)ToolUtlAlloc(SHA1_LENGTH);
	if(NULL==(*ppbByte))
		return E_INVALIDARG;

	memset(*ppbByte, 0, SHA1_LENGTH);

	//go through two characters (one byte) at a time
	for(dwIndex=0; dwIndex<SHA1_LENGTH; dwIndex++)
	{
		dw1st=dwIndex * 2;
		dw2nd=dwIndex * 2 +1;

		//1st character
		if(((int)(pwsz[dw1st])-(int)(L'0')) <=9  &&
		   ((int)(pwsz[dw1st])-(int)(L'0')) >=0)
		{

			ulHalfByte=(ULONG)((ULONG)(pwsz[dw1st])-(ULONG)(L'0'));
		}
		else
		{
			if(((int)(towupper(pwsz[dw1st]))-(int)(L'A')) >=0 && 
			   ((int)(towupper(pwsz[dw1st]))-(int)(L'A')) <=5 )
			   ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw1st]))-(ULONG)(L'A'));
			else
			{
				hr=E_INVALIDARG;
				goto CLEANUP;
			}
		}

		//copy the 1st character
		(*ppbByte)[dwIndex]=(BYTE)ulHalfByte;

		//left shift 4 bits
		(*ppbByte)[dwIndex]= (*ppbByte)[dwIndex] <<4;

		//2nd character
	   	if(((int)(pwsz[dw2nd])-(int)(L'0')) <=9  &&
		   ((int)(pwsz[dw2nd])-(int)(L'0')) >=0)
		{

			ulHalfByte=(ULONG)((ULONG)(pwsz[dw2nd])-(ULONG)(L'0'));
		}
		else
		{
			if(((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) >=0 && 
			   ((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) <=5 )
			   ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw2nd]))-(ULONG)(L'A'));
			else
			{
				hr=E_INVALIDARG;
				goto CLEANUP;
			}
		}

		//ORed the second character
		(*ppbByte)[dwIndex]=(*ppbByte)[dwIndex] | ((BYTE)ulHalfByte);

	}


	hr=S_OK;

CLEANUP:

	if(hr!=S_OK)
	{
	   if(*ppbByte)
		   ToolUtlFree(*ppbByte);

	   *ppbByte=NULL;
	}
	else
		*pcbByte=SHA1_LENGTH;

	return hr;

}

//+-------------------------------------------------------------------------
//  Skip over the identifier and length octets in an ASN encoded blob.
//  Returns the number of bytes skipped.
//
//  For an invalid identifier or length octet returns 0.
//--------------------------------------------------------------------------
 DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
#define TAG_MASK 0x1f
    DWORD   cb;
    DWORD   cbLength;
    const BYTE   *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
        return 0;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++) {
            if (cb >= cbDER)
                return 0;
        }
    } else
        // low-tag-number form
        cb = 1;

    // need at least one more byte for length
    if (cb >= cbDER)
        return 0;

    if (0x80 == *pb)
        // Indefinite
        cb++;
    else if ((cbLength = *pb) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;
        if (cb > cbDER)
            return 0;
    } else
        cb++;

    return cb;
}

//--------------------------------------------------------------------------
//
//	Skip over the tag and length
//----------------------------------------------------------------------------
BOOL SignNoContentWrap(IN const BYTE *pbDER, IN DWORD cbDER)
{
    DWORD cb;

    cb = SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if (cb > 0 && cb < cbDER && pbDER[cb] == 0x02)
        return TRUE;
    else
        return FALSE;
}


//--------------------------------------------------------------------------
//
// Print out bytes
//--------------------------------------------------------------------------
#define CROW 16
void PrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    if (cbSize == 0) 
	{
		//"%s NO Value Bytes\n"
		IDSwprintf(hModule, IDS_NO_BYTE,pwszHdr); 
        return;
    }

    while (cbSize > 0)
    {
        wprintf(L"%s", pwszHdr);

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            wprintf(L" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            wprintf(L"   ");
        wprintf(L"    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                wprintf(L"%c", pb[i]);
            else
                wprintf(L".");
        pb += cb;
        wprintf(L"'\n");
    }
}


//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
 void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr,
        DWORD dwItem)
{
    DWORD	i; 
    DWORD	j; 
	LPWSTR	pwszObjId=NULL;


    for (i = 0; i < cAttr; i++, pAttr++) 
	{
        DWORD cValue = pAttr->cValue;
        PCRYPT_ATTR_BLOB pValue = pAttr->rgValue;
        LPSTR pszObjId = pAttr->pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

        if (cValue) 
		{
            for (j = 0; j < cValue; j++, pValue++) 
			{
                printf("  [%d,%d] %s\n", i, j, pszObjId);
                if (pValue->cbData) 
				{
                   if(dwItem & ITEM_VERBOSE)
						PrintBytes(L"    ", pValue->pbData, pValue->cbData);

                    if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0) 
					{
						//"   NextUpdateLocation::\n"
						IDSwprintf(hModule, IDS_NEXT_UPDATE_LOCATION);

                        DecodeAndDisplayAltName(pValue->pbData, pValue->cbData,
                            dwItem);
                    }

					//Display the timestamp attriute
					if(strcmp(pszObjId, szOID_RSA_counterSign)==0)
					{
						
						//"    Timestamp:: \n"
						IDSwprintf(hModule, IDS_TIMESTMAP);

						DisplayTimeStamp(pValue->pbData,
										pValue->cbData,
										dwItem);

					}

					//Display the signing time
					if(strcmp(pszObjId, szOID_RSA_signingTime)==0)
					{
						FILETIME	*pSigningTime=NULL;

						if(pSigningTime=(FILETIME *)TestNoCopyDecodeObject(
							PKCS_UTC_TIME,
							pValue->pbData,
							pValue->cbData))
						{
							//"   Signing Time:: \n %s\n"
							IDSwprintf(hModule, IDS_SIGNING_TIME, 
								FileTimeText(pSigningTime));

							ToolUtlFree(pSigningTime);
						}
					}
                } 
				else
					//"    NO Value Bytes\n"
					IDSwprintf(hModule, IDS_NO_VALUE_BYTES);
            }
        } 
		else 
		{
			if(S_OK==SZtoWSZ(pszObjId, &pwszObjId))
				//"  [%d] %s :: No Values\n"
				IDSwprintf(hModule, IDS_I_ID_NO_VALUE, i, pwszObjId);
		}
    }

	if(pwszObjId)
		ToolUtlFree(pwszObjId);
}



//+-------------------------------------------------------------------------
//  DecodeAndDisplayAltName
//--------------------------------------------------------------------------
 void DecodeAndDisplayAltName(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_ALT_NAME_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) TestNoCopyDecodeObject(
            X509_ALTERNATE_NAME,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    DisplayAltName(pInfo, dwDisplayFlags);

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  Display AltName
//--------------------------------------------------------------------------
 void DisplayAltName(
    PCERT_ALT_NAME_INFO pInfo,
    DWORD dwDisplayFlags)
{
    DWORD i;
    PCERT_ALT_NAME_ENTRY pEntry = pInfo->rgAltEntry;
    DWORD cEntry = pInfo->cAltEntry;

    for (i = 0; i < cEntry; i++, pEntry++) {
        wprintf(L"    [%d] ", i);
        DisplayAltNameEntry(pEntry, dwDisplayFlags);
    }
}


//+-------------------------------------------------------------------------
//  Display an alternative name entry
//--------------------------------------------------------------------------
 void DisplayAltNameEntry(
    PCERT_ALT_NAME_ENTRY pEntry,
    DWORD dwDisplayFlags)
{

    switch (pEntry->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
		//"OtherName:\n"
		IDSwprintf(hModule, IDS_OTHER_NAME);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
        //"X400Address:\n");
		IDSwprintf(hModule, IDS_X400);
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        //("DirectoryName:\n");
		IDSwprintf(hModule, IDS_DIRECTORY_NAME);
        DecodeName(pEntry->DirectoryName.pbData,
            pEntry->DirectoryName.cbData, dwDisplayFlags);
        break;
    case CERT_ALT_NAME_EDI_PARTY_NAME:
		//"EdiPartyName:\n"
		IDSwprintf(hModule, IDS_EDI_PARTY);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
        //"RFC822: %s\n"
		IDSwprintf(hModule, IDS_RFC,pEntry->pwszRfc822Name );
        break;
    case CERT_ALT_NAME_DNS_NAME:
        //"DNS: %s\n", 
		IDSwprintf(hModule, IDS_DNS, pEntry->pwszDNSName);
        break;
    case CERT_ALT_NAME_URL:
		//"URL: %s\n"
		IDSwprintf(hModule, IDS_ALT_NAME_URL,pEntry->pwszURL); 
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        //"IPAddress:\n"
		IDSwprintf(hModule, IDS_IP);
        PrintBytes(L"    ", pEntry->IPAddress.pbData, pEntry->IPAddress.cbData);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        //"RegisteredID:", 
		IDSwprintf(hModule, IDS_REG_ID);
		printf("%s\n", pEntry->pszRegisteredID);
        break;
    default:
		//"Unknown choice: %d\n"
		IDSwprintf(hModule, IDS_UNKNOWN_ALT_NAME,pEntry->dwAltNameChoice);
    }

}

//+-------------------------------------------------------------------------
//  Display an alternative name entry
//--------------------------------------------------------------------------
 void DisplayThumbprint(
    LPWSTR pwszHash,
    BYTE *pbHash,
    DWORD cbHash
    )
{
    
	//"%s Thumbprint:: "
	IDSwprintf(hModule, IDS_Thumbprint, pwszHash);

    if (cbHash == 0)
        printf("%s", g_szNULL);

    else 
	{
        ULONG cb;

        while (cbHash > 0) {
            cb = min(4, cbHash);
            cbHash -= cb;
            for (; cb > 0; cb--, pbHash++)
                printf("%02X", *pbHash);

            printf(" ");
        }
    }

    printf("\n");
}


//+-------------------------------------------------------------------------
//  Print out the FileTime 
//--------------------------------------------------------------------------
LPWSTR FileTimeText(FILETIME *pft)
{
    static  WCHAR	wszbuf[100];
    FILETIME		ftLocal;
    struct tm		ctm;
    SYSTEMTIME		st;
	WCHAR			wszFileTime[50];
	WCHAR			wszMilliSecond[50];

	//init
	wszbuf[0]=L'\0';

	//check if the time is available
	if((pft->dwLowDateTime==0) &&
		(pft->dwHighDateTime==0))
	{
		LoadStringU(hModule, IDS_NOT_AVAILABLE, wszbuf, 100);
		return wszbuf;
	}

	//load the string we need
	//" <milliseconds:: %03d>"
	//"<FILETIME %08lX:%08lX>"
	if(!LoadStringU(hModule, IDS_FILE_TIME, wszFileTime, 50) ||
		!LoadStringU(hModule, IDS_MILLI_SECOND, wszMilliSecond, 50))
		return wszbuf;

    FileTimeToLocalFileTime(pft, &ftLocal);

    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        wcscpy(wszbuf, _wasctime(&ctm));
        wszbuf[wcslen(wszbuf)-1] = 0;

        if (st.wMilliseconds) 
		{
            WCHAR *pwch = wszbuf + wcslen(wszbuf);
            swprintf(pwch, wszMilliSecond, st.wMilliseconds);
        }
    }
    else
        swprintf(wszbuf, wszFileTime, pft->dwHighDateTime, pft->dwLowDateTime);
    return wszbuf;
}



//+-------------------------------------------------------------------------
//  Print other cer properies
//--------------------------------------------------------------------------
 void PrintAuxCertProperties(PCCERT_CONTEXT pCert, DWORD dwDisplayFlags)
{
    DWORD dwPropId = 0;

    while (dwPropId = CertEnumCertificateContextProperties(pCert, dwPropId)) 
	{
        switch (dwPropId) 
		{
			case CERT_KEY_PROV_INFO_PROP_ID:
			case CERT_SHA1_HASH_PROP_ID:
			case CERT_MD5_HASH_PROP_ID:
			case CERT_KEY_CONTEXT_PROP_ID:
				// Formatted elsewhere
				break;
			default:
            {
                BYTE *pbData;
                DWORD cbData;

				//"Aux PropId %d (0x%x) ::\n"
				IDSwprintf(hModule, IDS_AUX_PROP_ID, dwPropId, dwPropId);

                CertGetCertificateContextProperty(
                    pCert,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) 
				{
                    if (pbData = (BYTE *) ToolUtlAlloc(cbData)) 
					{
                        if (CertGetCertificateContextProperty(
                                pCert,
                                dwPropId,
                                pbData,
                                &cbData
                                )) 
						{
                            PrintBytes(L"    ", pbData, cbData); 

                            if (CERT_CTL_USAGE_PROP_ID == dwPropId) 
							{
                                // "  EnhancedKeyUsage::\n"
								IDSwprintf(hModule, IDS_ENHANCED_KEY_USAGE);

                                DecodeAndDisplayCtlUsage(pbData, cbData,
                                    dwDisplayFlags);
                            }
                        } 

                        ToolUtlFree(pbData);
                    }
                } 
				else
					//"     NO Property Bytes\n"
					IDSwprintf(hModule, IDS_NO_PROP_BYTES);
            } 

            break;
        }
    }
}


//+-------------------------------------------------------------------------
//  DecodeAndDisplayCtlUsage
//--------------------------------------------------------------------------
 void DecodeAndDisplayCtlUsage(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCTL_USAGE pInfo;
    DWORD cId;
    LPSTR *ppszId;
    DWORD i;

    if (NULL == (pInfo =
            (PCTL_USAGE) TestNoCopyDecodeObject(
                X509_ENHANCED_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto CLEANUP;

    cId = pInfo->cUsageIdentifier;
    ppszId = pInfo->rgpszUsageIdentifier;

    if (cId == 0)
		//"    No Usage Identifiers\n"
		IDSwprintf(hModule, IDS_NO_USAGE_ID);

    for (i = 0; i < cId; i++, ppszId++)
        printf("    [%d] %s\n", i, *ppszId);

CLEANUP:
    if (pInfo)
        ToolUtlFree(pInfo);
}



//+-------------------------------------------------------------------------
//  DisplaySignature
//--------------------------------------------------------------------------
 void DisplaySignature(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_SIGNED_CONTENT_INFO pSignedContent;
    
    if (pSignedContent = (PCERT_SIGNED_CONTENT_INFO) TestNoCopyDecodeObject(
            X509_CERT,
            pbEncoded,
            cbEncoded
            )) 
	{
        LPSTR pszObjId;

        pszObjId = pSignedContent->SignatureAlgorithm.pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

		//"Content SignatureAlgorithm:: 
		IDSwprintf(hModule, IDS_CONTENT_SIG_ALGO);

        printf("%s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));

        if (pSignedContent->SignatureAlgorithm.Parameters.cbData) 
		{
			//"Content SignatureAlgorithm.Parameters::\n"
            IDSwprintf(hModule, IDS_CONTENT_SIG_ALGO_PARAM);
            PrintBytes(L"    ",
                pSignedContent->SignatureAlgorithm.Parameters.pbData,
                pSignedContent->SignatureAlgorithm.Parameters.cbData);
        }

        if (pSignedContent->Signature.cbData) 
		{
            ALG_ID aiHash;
            ALG_ID aiPubKey;

			//"Content Signature (little endian)::\n"
			IDSwprintf(hModule, IDS_CONTEXT_SIG);
            PrintBytes(L"    ", pSignedContent->Signature.pbData,
                pSignedContent->Signature.cbData);

            GetSignAlgids(pszObjId, &aiHash, &aiPubKey);

            if (CALG_SHA == aiHash && CALG_DSS_SIGN == aiPubKey) 
			{
                BYTE *pbDssSignature;
                DWORD cbDssSignature;

                ReverseBytes(pSignedContent->Signature.pbData,
                    pSignedContent->Signature.cbData);

                if (pbDssSignature =
                    (BYTE *) TestNoCopyDecodeObject(
                        X509_DSS_SIGNATURE,
                        pSignedContent->Signature.pbData,
                        pSignedContent->Signature.cbData,
                        &cbDssSignature
                        )) {
                    if (CERT_DSS_SIGNATURE_LEN == cbDssSignature) 
					{
						//"DSS R (little endian)::\n"
                        IDSwprintf(hModule, IDS_DSS_R);
                        PrintBytes(L"    ", pbDssSignature, CERT_DSS_R_LEN);

						//"DSS S (little endian)::\n"
                        IDSwprintf(hModule, IDS_DSS_S);
                        PrintBytes(L"    ", pbDssSignature + CERT_DSS_R_LEN,
                            CERT_DSS_S_LEN);

                    } 
					else
					{
						//"DSS Signature (unexpected length, little endian)::\n"
						IDSwprintf(hModule, IDS_DSS_INFO);
                        PrintBytes(L"    ", pbDssSignature, cbDssSignature);
                    }
                    ToolUtlFree(pbDssSignature);
                }
            }
        } else
			//"Content Signature:: NONE\n"
			IDSwprintf(hModule, IDS_CONTENT_SIG_NONE);

		ToolUtlFree(pSignedContent);
    }
}


//+-------------------------------------------------------------------------
//  Decode an X509 Name
//--------------------------------------------------------------------------
 BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwDisplayFlags)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

    if (NULL == (pInfo = (PCERT_NAME_INFO) TestNoCopyDecodeObject
	(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) 
	{
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) 
		{
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = g_szNULL;

            if ((dwDisplayFlags & ITEM_VERBOSE) ||
                (pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) 
			{
				printf("  [%d,%d] %s (%S) ", i, j, pszObjId, GetOIDName(pszObjId));

				//ValueType: %d\n"
				IDSwprintf(hModule, IDS_VALUE_TYPE, pAttr->dwValueType);
                PrintBytes(L"    ", pAttr->Value.pbData, pAttr->Value.cbData);
            } else if (pAttr->dwValueType == CERT_RDN_UNIVERSAL_STRING) 
			{
                printf("  [%d,%d] %s (%S)",
                    i, j, pszObjId, GetOIDName(pszObjId));

                DWORD cdw = pAttr->Value.cbData / 4;
                DWORD *pdw = (DWORD *) pAttr->Value.pbData;
                for ( ; cdw > 0; cdw--, pdw++)
                    printf(" 0x%08X", *pdw);
                printf("\n");

                DWORD csz;
                csz = CertRDNValueToStrA(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // psz
                    0                   // csz
                    );
                if (csz > 1) 
				{
                    LPSTR psz = (LPSTR) ToolUtlAlloc(csz);
                    if (psz) 
					{
                        CertRDNValueToStrA(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            psz,
                            csz
                            );

						//"    Str: "
						IDSwprintf(hModule, IDS_STR);
                        printf("%s\n", psz);
                        ToolUtlFree(psz);
                    }
                }

                DWORD cwsz;
                cwsz = CertRDNValueToStrW(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // pwsz
                    0                   // cwsz
                    );
                if (cwsz > 1) 
				{
                    LPWSTR pwsz =
                        (LPWSTR) ToolUtlAlloc(cwsz * sizeof(WCHAR));
                    if (pwsz) 
					{
                        CertRDNValueToStrW(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            pwsz,
                            cwsz
                            );

						//"    WStr: %S\n"
						IDSwprintf(hModule, IDS_WSTR, pwsz);
                        ToolUtlFree(pwsz);
                    }
                }
            } else if (pAttr->dwValueType == CERT_RDN_BMP_STRING) 
			{
                printf("  [%d,%d] %s (%S) %S\n",
                    i, j, pszObjId, GetOIDName(pszObjId), (LPWSTR) pAttr->Value.pbData);
            } else
                printf("  [%d,%d] %s (%S) %s\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->Value.pbData);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
    return fResult;
}



//+-------------------------------------------------------------------------
//  PrintExtensions
//--------------------------------------------------------------------------
 void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt, DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cExt; i++, pExt++) 
	{
        LPSTR pszObjId = pExt->pszObjId;

        if (pszObjId == NULL)
            pszObjId = g_szNULL;

        int	idsCritical = pExt->fCritical ? IDS_TRUE : IDS_FALSE;

		//print the end of line
		printf("\n");


		//"Extension[%d] "
		IDSwprintf(hModule, IDS_EXTENSION_INDEX, i);

        printf("%s", pszObjId);
		
		//(%s) Critical: ",
		IDSwprintf(hModule, IDS_NAME_CRITICAL, GetOIDName(pszObjId));
		
		//"%s::\n"
		IDS_IDSwprintf(hModule, IDS_STRING, idsCritical);

		//print bytes on verbose options
		if(dwDisplayFlags & ITEM_VERBOSE)
			PrintBytes(L"    ", pExt->Value.pbData, pExt->Value.cbData);

		//try the installed formatting routine 1st
		if(TRUE==InstalledFormat(pszObjId, pExt->Value.pbData, pExt->Value.cbData))
			continue;

        if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER) == 0)
            DisplayAuthorityKeyIdExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2) == 0)
            DisplayAuthorityKeyId2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

// Will add back after PKIX stabilizes on the definition of this extension
//        else if (strcmp(pszObjId, szOID_AUTHORITY_INFO_ACCESS) == 0)
//           DisplayAuthorityInfoAccessExtension(
//               pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_CRL_DIST_POINTS) == 0)
            DisplayCrlDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_KEY_IDENTIFIER) == 0)
            //"  <SubjectKeyIdentifer> \n"
			DisplayOctetString(IDS_SUB_KEY_ID,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_ATTRIBUTES) == 0)
            DisplayKeyAttrExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME) == 0)
			//"  <Subject AltName> \n"
            DisplayAltNameExtension(IDS_SUB_ALT,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME) == 0)
			//"  <Issuer AltName> \n"
            DisplayAltNameExtension(IDS_ISS_ALT,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME2) == 0)
			//"  <Subject AltName #2> \n"
            DisplayAltNameExtension(IDS_SUB_ALT2,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME2) == 0)
            //"  <Issuer AltName #2> \n"
			DisplayAltNameExtension(IDS_ISS_ALT2,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0)
			//"  <NextUpdateLocation> \n"
            DisplayAltNameExtension(IDS_NEXT_UPDATE_LOC,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE_RESTRICTION) == 0)
            DisplayKeyUsageRestrictionExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS) == 0)
            DisplayBasicConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE) == 0)
            DisplayKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS2) == 0)
            DisplayBasicConstraints2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CERT_POLICIES) == 0)
			//"  <Certificate Policies> \n"
            DisplayPoliciesExtension(IDS_CERT_POLICIES,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_SP_AGENCY_INFO_OBJID) == 0)
            DisplaySpcSpAgencyExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_FINANCIAL_CRITERIA_OBJID) == 0)
            DisplaySpcFinancialCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
       else if (strcmp(pszObjId, SPC_MINIMAL_CRITERIA_OBJID) == 0)
      		DisplaySpcMinimalCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_COMMON_NAME) == 0)
            DisplayCommonNameExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_ENHANCED_KEY_USAGE) == 0)
            DisplayEnhancedKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_RSA_SMIMECapabilities) == 0)
            DisplaySMIMECapabilitiesExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // CRL extensions
        else if (strcmp(pszObjId, szOID_CRL_REASON_CODE) == 0)
            DisplayCRLReason(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // Netscape extensions
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_TYPE) == 0)
			//"  <NetscapeCertType> \n"
            DisplayBits(IDS_NSCP_CERT,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_BASE_URL) == 0)
            //"  <NetscapeBaseURL> \n"
			DisplayAnyString(IDS_NSCP_BASE,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_REVOCATION_URL) == 0)
            //"  <NetscapeRevocationURL> \n"
			DisplayAnyString(IDS_NSCP_REV,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_REVOCATION_URL) == 0)
			//"  <NetscapeCARevocationURL> \n"
            DisplayAnyString(IDS_NSCP_CA_REV,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_RENEWAL_URL) == 0)
            //"  <NetscapeCertRenewalURL> \n"
			DisplayAnyString(IDS_NSCP_RENEW,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_POLICY_URL) == 0)
            //"  <NetscapeCAPolicyURL> \n"
			DisplayAnyString(IDS_NSCP_CA_URL,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_SSL_SERVER_NAME) == 0)
            //"  <NetscapeSSLServerName> \n"
			DisplayAnyString(IDS_NSCP_SSL,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_COMMENT) == 0)
			//"  <NetscapeComment> \n"
            DisplayAnyString(IDS_NSCP_COM,
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
		else if(0==(dwDisplayFlags & ITEM_VERBOSE))
			PrintBytes(L"    ", pExt->Value.pbData, pExt->Value.cbData);


    }
}


//+-------------------------------------------------------------------------
//  DisplaySMIMECapabilitiesExtension
//--------------------------------------------------------------------------
 void DisplaySMIMECapabilitiesExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_SMIME_CAPABILITIES pInfo;
    DWORD cCap;
    PCRYPT_SMIME_CAPABILITY pCap;
    DWORD i;

    if (NULL == (pInfo =
            (PCRYPT_SMIME_CAPABILITIES) TestNoCopyDecodeObject(
                PKCS_SMIME_CAPABILITIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cCap = pInfo->cCapability;
    pCap = pInfo->rgCapability;

	//"  <SMIME Capabilties>\n"
	IDSwprintf(hModule, IDS_SMIME);

    if (cCap == 0)
        IDSwprintf(hModule, IDS_NONE);

    for (i = 0; i < cCap; i++, pCap++) 
	{
        LPSTR pszObjId = pCap->pszObjId;

        printf("    [%d] %s (%S)", i, pszObjId, GetOIDName(pszObjId));
        if (pCap->Parameters.cbData) 
		{
            //"  Parameters::\n"
			IDSwprintf(hModule, IDS_PARAMS);

            PrintBytes(L"      ",
                pCap->Parameters.pbData,
                pCap->Parameters.cbData);
        } else
            printf("\n");
    }

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayEnhancedKeyUsageExtension
//--------------------------------------------------------------------------
 void DisplayEnhancedKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    //"  <EnhancedKeyUsage> \n");
	IDSwprintf(hModule, IDS_ENH_KEY_USAGE);
    DecodeAndDisplayCtlUsage(pbEncoded, cbEncoded, dwDisplayFlags);
}

//+-------------------------------------------------------------------------
//  DisplaySpcFinancialCriteriaExtension
//--------------------------------------------------------------------------
 void DisplayCommonNameExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_NAME_VALUE pInfo = NULL;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_NAME_VALUE,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

	//"  <Common Name> \n"
	IDSwprintf(hModule, IDS_COMMON_NAME);

    cwsz = CertRDNValueToStrW(
        pInfo->dwValueType,
        &pInfo->Value,
        NULL,               // pwsz
        0                   // cwsz
        );
    if (cwsz > 1) 
	{
        pwsz = (LPWSTR)ToolUtlAlloc(cwsz * sizeof(WCHAR));
        if (pwsz)
            CertRDNValueToStrW(
                pInfo->dwValueType,
                &pInfo->Value,
                pwsz,
                cwsz
                );
    }

    //"  ValueType: %d String: ", 
	IDSwprintf(hModule, IDS_VALUE_STRING, pInfo->dwValueType);
    if (pwsz)
        wprintf(L"%s", pwsz);
    else
        IDSwprintf(hModule, IDS_NULL);

	printf("\n");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
    if (pwsz)
        ToolUtlFree(pwsz);
}

//+-------------------------------------------------------------------------
//  DisplaySpcFinancialCriteriaExtension
//--------------------------------------------------------------------------
 void DisplaySpcFinancialCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    SPC_FINANCIAL_CRITERIA FinancialCriteria;
    DWORD cbInfo = sizeof(FinancialCriteria);
    if (!CryptDecodeObject(
            g_dwCertEncodingType,
            SPC_FINANCIAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &FinancialCriteria,
            &cbInfo
            )) {
        return;
    }

    //"  <FinancialCriteria> \n "
	IDSwprintf(hModule, IDS_FIN_CRI);

    if (FinancialCriteria.fFinancialInfoAvailable)
        //"Financial Info Available.");
		IDSwprintf(hModule, IDS_FIN_AVAI);
    else
        IDSwprintf(hModule, IDS_NONE);

    if (FinancialCriteria.fMeetsCriteria)
		//" Meets Criteria."
		IDSwprintf(hModule, IDS_MEET_CRI);
    else
		//"	Doesn't Meets Criteria."
        IDSwprintf(hModule, IDS_NO_MEET_CRI);
    printf("\n");
}

//+-------------------------------------------------------------------------
//  DisplaySpcMinimalCriteriaExtension
//--------------------------------------------------------------------------
 void DisplaySpcMinimalCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BOOL fMinimalCriteria;
    DWORD cbInfo = sizeof(fMinimalCriteria);

    if (!CryptDecodeObject(
            g_dwCertEncodingType,
            SPC_MINIMAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &fMinimalCriteria,
            &cbInfo)) {
        return;
    }

    //"  <MinimalCriteria> \n ");
	IDSwprintf(hModule, IDS_MIN_CRI);

    if (fMinimalCriteria)
        //"Meets Minimal Criteria."
		IDSwprintf(hModule, IDS_MEET_MIN);
    else
        //"Doesn't Meet Minimal Criteria."
		IDSwprintf(hModule, IDS_NO_MEET_MIN);
    printf("\n");
}

//+-------------------------------------------------------------------------
//  DisplaySpcLink
//--------------------------------------------------------------------------
void DisplaySpcLink(PSPC_LINK pSpcLink)
{
    switch (pSpcLink->dwLinkChoice) 
	{
    case SPC_URL_LINK_CHOICE:
        //"URL=> %S\n", );
		IDSwprintf(hModule, IDS_SPC_URL, pSpcLink->pwszUrl);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        wprintf(L"%s\n", GuidText((GUID *) pSpcLink->Moniker.ClassId));

        if (pSpcLink->Moniker.SerializedData.cbData)
		{
            //"     SerializedData::\n");
			IDSwprintf(hModule, IDS_SERIAL_DATA);
            PrintBytes(L"    ", pSpcLink->Moniker.SerializedData.pbData,
                pSpcLink->Moniker.SerializedData.cbData);
        }
        break;
    case SPC_FILE_LINK_CHOICE:
        //"FILE=> %S\n", 
		IDSwprintf(hModule, IDS_SPC_FILE,pSpcLink->pwszFile);
        break;
    default:
        //"Unknown SPC Link Choice:: %d\n", 
		IDSwprintf(hModule, IDS_UNKNOWN_SPC, pSpcLink->dwLinkChoice);
    }
}

 
//+-------------------------------------------------------------------------
//  DisplaySpcSpAgencyExtension
//--------------------------------------------------------------------------
 void DisplaySpcSpAgencyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PSPC_SP_AGENCY_INFO pInfo;
    if (NULL == (pInfo = (PSPC_SP_AGENCY_INFO) TestNoCopyDecodeObject(
            SPC_SP_AGENCY_INFO_OBJID,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    //"  <SpcSpAgencyInfo> \n");
	IDSwprintf(hModule, IDS_SPC_AGENCY);

    if (pInfo->pPolicyInformation) 
	{
        //"    PolicyInformation: "
		IDSwprintf(hModule, IDS_POL_INFO);
        DisplaySpcLink(pInfo->pPolicyInformation);
    }

    if (pInfo->pwszPolicyDisplayText) 
	{
        //"    PolicyDisplayText: %s\n", 
		IDSwprintf(hModule, IDS_POL_DIS, pInfo->pwszPolicyDisplayText);
    }

    if (pInfo->pLogoImage) 
	{
        PSPC_IMAGE pImage = pInfo->pLogoImage;
        if (pImage->pImageLink) 
		{
            //"    ImageLink: ");
			IDSwprintf(hModule, IDS_IMG_LINK);
            DisplaySpcLink(pImage->pImageLink);
        }
        if (pImage->Bitmap.cbData) 
		{
            //"    Bitmap:\n");
			IDSwprintf(hModule, IDS_BITMAP);
            PrintBytes(L"    ", pImage->Bitmap.pbData, pImage->Bitmap.cbData);
        }
        if (pImage->Metafile.cbData) 
		{
            //"    Metafile:\n");
			IDSwprintf(hModule, IDS_META_FILE);

            PrintBytes(L"    ", pImage->Metafile.pbData,
                pImage->Metafile.cbData);
        }
        if (pImage->EnhancedMetafile.cbData) 
		{
            //"    EnhancedMetafile:\n");
			IDSwprintf(hModule, IDS_ENH_META);

            PrintBytes(L"    ", pImage->EnhancedMetafile.pbData,
                pImage->EnhancedMetafile.cbData);
        }
        if (pImage->GifFile.cbData) 
		{
            //"    GifFile:\n"
			IDSwprintf(hModule, IDS_GIF_FILE);

            PrintBytes(L"    ", pImage->GifFile.pbData,
                pImage->GifFile.cbData);
        }
    }
    if (pInfo->pLogoLink) 
	{
        //"    LogoLink: ");
		IDSwprintf(hModule, IDS_LOGO_LINK);

        DisplaySpcLink(pInfo->pLogoLink);
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayPoliciesExtension
//--------------------------------------------------------------------------
 void DisplayPoliciesExtension(
    int		idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICIES_INFO pInfo;
    DWORD cPolicy;
    PCERT_POLICY_INFO pPolicy;
    DWORD i;

    if (NULL == (pInfo =
            (PCERT_POLICIES_INFO) TestNoCopyDecodeObject(
                X509_CERT_POLICIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cPolicy = pInfo->cPolicyInfo;
    pPolicy = pInfo->rgPolicyInfo;


	//Display the name of the extension
	IDSwprintf(hModule, idsIDS);

    if (cPolicy == 0)
          IDSwprintf(hModule, IDS_NONE);

    for (i = 0; i < cPolicy; i++, pPolicy++) 
	{
        DWORD cQualifier = pPolicy->cPolicyQualifier;
        PCERT_POLICY_QUALIFIER_INFO pQualifier;
        DWORD j;
        printf("    [%d] %s", i, pPolicy->pszPolicyIdentifier);

        if (cQualifier)	
			//" Qualifiers:: \n"
			IDSwprintf(hModule, IDS_QUALI);

        pQualifier = pPolicy->rgPolicyQualifier;
        for (j = 0; j < cQualifier; j++, pQualifier++) 
		{
            printf("      [%d] %s", j, pQualifier->pszPolicyQualifierId);

            if (pQualifier->Qualifier.cbData) 
			{
                //" Encoded Data::\n"
				IDSwprintf(hModule, IDS_ENCODED_DATA);
                PrintBytes(L"    ",
                    pQualifier->Qualifier.pbData, pQualifier->Qualifier.cbData);
            } else
                printf("\n");
                    
        }
    }

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayKeyUsageExtension
//--------------------------------------------------------------------------
 void DisplayKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo;
    BYTE bFlags;

    if (NULL == (pInfo =
            (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
                X509_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    //"  <KeyUsage> \n"
	IDSwprintf(hModule, IDS_KEY_USAGE);

    if (pInfo->cbData)
        bFlags = *pInfo->pbData;
    else
        bFlags = 0;

	DisplayKeyUsage(bFlags);

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayBasicConstraints2Extension
//--------------------------------------------------------------------------
 void DisplayBasicConstraints2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS2,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    
	//"  <Basic Constraints2> \n"
	IDSwprintf(hModule, IDS_BASIC_CON2);


    if (pInfo->fCA)
		IDSwprintf(hModule, IDS_SUB_CA);
    else
		IDSwprintf(hModule, IDS_SUB_EE);

	printf("\n");

    //"  PathLenConstraint:: "
	IDSwprintf(hModule, IDS_PATH_LEN);

    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        IDSwprintf(hModule, IDS_NONE);

    printf("\n");

ErrorReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayBasicConstraintsExtension
//--------------------------------------------------------------------------
 void DisplayBasicConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;


	//"  <Basic Constraints> \n"
	IDSwprintf(hModule, IDS_BASIC_CON);

	//"  SubjectType:: ";
	IDSwprintf(hModule, IDS_SUB_TYPE);

    if (pInfo->SubjectType.cbData == 0)
          IDSwprintf(hModule, IDS_NONE);
	else
	{
		BYTE bSubjectType = *pInfo->SubjectType.pbData;

        if (bSubjectType == 0)
          IDSwprintf(hModule, IDS_NONE);

        if (bSubjectType & CERT_CA_SUBJECT_FLAG)
            //"  CA ");
			IDSwprintf(hModule, IDS_SUB_CA);

        if (bSubjectType & CERT_END_ENTITY_SUBJECT_FLAG)
            //"  END_ENTITY ")
			IDSwprintf(hModule, IDS_SUB_EE);
    }

    printf("\n");

    //"  PathLenConstraint:: "
	IDSwprintf(hModule, IDS_PATH_LEN);

    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        IDSwprintf(hModule, IDS_NONE_NOELN);

    printf("\n");

    if (pInfo->cSubtreesConstraint) 
	{
        DWORD i;
        PCERT_NAME_BLOB pSubtrees = pInfo->rgSubtreesConstraint;
        for (i = 0; i < pInfo->cSubtreesConstraint; i++, pSubtrees++) 
		{
            //"  SubtreesConstraint[%d]::\n"
			IDSwprintf(hModule, IDS_SUB_CON, i);
            DecodeName(pSubtrees->pbData, pSubtrees->cbData, dwDisplayFlags);
        }
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayKeyUsageRestrictionExtension
//--------------------------------------------------------------------------
 void DisplayKeyUsage(BYTE	bFlags)
{
        if (bFlags == 0)
            IDSwprintf(hModule, IDS_NONE);
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            //"DIGITAL_SIGNATURE "
			IDSwprintf(hModule, IDS_DIG_SIG);
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            //"NON_REPUDIATION "
			IDSwprintf(hModule, IDS_NON_REP);
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            //"KEY_ENCIPHERMENT "
			IDSwprintf(hModule, IDS_KEY_ENCI);
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            //"DATA_ENCIPHERMENT ");
			IDSwprintf(hModule, IDS_DATA_ENCI);
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            //"KEY_AGREEMENT ");
			IDSwprintf(hModule, IDS_KEY_AGRE);
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            //"KEY_CERT_SIGN "
			IDSwprintf(hModule, IDS_CERT_SIGN);
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            //"OFFLINE_CRL_SIGN "
			IDSwprintf(hModule, IDS_OFFLINE_CRL);
        printf("\n");
}


//+-------------------------------------------------------------------------
//  DisplayKeyUsageRestrictionExtension
//--------------------------------------------------------------------------
 void DisplayKeyUsageRestrictionExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo;
    if (NULL == (pInfo =
            (PCERT_KEY_USAGE_RESTRICTION_INFO) TestNoCopyDecodeObject(
                X509_KEY_USAGE_RESTRICTION,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;
				   
	//Display the name of the certificate
	//"  <KeyUsageRestriction> \n "
	IDSwprintf(hModule, IDS_KEY_RESTRIC);

    if (pInfo->cCertPolicyId) 
	{
        DWORD i, j;

		//"  CertPolicySet::\n"
		IDSwprintf(hModule, IDS_CERT_POLICY);

        PCERT_POLICY_ID pPolicyId = pInfo->rgCertPolicyId;
        for (i = 0; i < pInfo->cCertPolicyId; i++, pPolicyId++) 
		{
            if (pPolicyId->cCertPolicyElementId == 0)
                printf("     [%d,*] %s\n", i, g_szNULL);

            LPSTR *ppszObjId = pPolicyId->rgpszCertPolicyElementId;
            for (j = 0; j < pPolicyId->cCertPolicyElementId; j++, ppszObjId++) 
			{
                LPSTR pszObjId = *ppszObjId;
                if (pszObjId == NULL)
                    pszObjId = g_szNULL;
                printf("     [%d,%d] %s\n", i, j, pszObjId);
            }
        }
    }

    if (pInfo->RestrictedKeyUsage.cbData) 
	{
        BYTE bFlags = *pInfo->RestrictedKeyUsage.pbData;

        //"  RestrictedKeyUsage:: "
		IDSwprintf(hModule, IDS_RESTRIC_KEY);
	
		DisplayKeyUsage(bFlags);
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayCRLReason
//--------------------------------------------------------------------------
 void DisplayCRLReason(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    DWORD cbInfo;
    int CRLReason;

    cbInfo = sizeof(CRLReason);
    if (!CryptDecodeObject(
            g_dwCertEncodingType,
            szOID_CRL_REASON_CODE,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &CRLReason,
            &cbInfo
            )) 
	{
        return;
    }

	//"  <CRL Reason> \n");
    IDSwprintf(hModule, IDS_CRL_REASON);
    switch (CRLReason) 
	{
        case CRL_REASON_UNSPECIFIED:
            //"REASON_UNSPECIFIED"
			IDSwprintf(hModule, IDS_CRL_UNSPECIFIED);
            break;
        case CRL_REASON_KEY_COMPROMISE:
            //"KEY_COMPROMISE"
			IDSwprintf(hModule, IDS_KEY_COMP);
            break;
        case CRL_REASON_CA_COMPROMISE:
            //"CA_COMPROMISE"
			IDSwprintf(hModule, IDS_CA_COMP);
            break;
        case CRL_REASON_AFFILIATION_CHANGED:
            //"AFFILIATION_CHANGED"
			IDSwprintf(hModule, IDS_AFFI_CHANGED);
            break;
        case CRL_REASON_SUPERSEDED:
            //"SUPERSEDED"
			IDSwprintf(hModule, IDS_SUPERSEDED);
            break;
        case CRL_REASON_CESSATION_OF_OPERATION:
            //"CESSATION_OF_OPERATION"
			IDSwprintf(hModule, IDS_CESS_OPER);
            break;
        case CRL_REASON_CERTIFICATE_HOLD:
            //"CERTIFICATE_HOLD"
			IDSwprintf(hModule, IDS_CERT_HOLD);
            break;
        case CRL_REASON_REMOVE_FROM_CRL:
            //REMOVE_FROM_CRL);
			IDSwprintf(hModule, IDS_REMOVE_CRL);
            break;
        default:
            printf("%d", CRLReason);
            break;
    }
    
	printf("\n");
}
//+-------------------------------------------------------------------------
//  DisplayAltNameExtension
//--------------------------------------------------------------------------
 void DisplayAltNameExtension(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    IDSwprintf(hModule, idsIDS);
    DecodeAndDisplayAltName(pbEncoded, cbEncoded, dwDisplayFlags);
}
//+-------------------------------------------------------------------------
//  DisplayKeyAttrExtension
//--------------------------------------------------------------------------
 void DisplayKeyAttrExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_ATTRIBUTES_INFO pInfo;
    if (NULL == (pInfo = (PCERT_KEY_ATTRIBUTES_INFO) TestNoCopyDecodeObject(
            X509_KEY_ATTRIBUTES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

	//"  <KeyAttributes>\n"
	IDSwprintf(hModule ,IDS_KEY_ATTR);

    if (pInfo->KeyId.cbData) 
	{
		//"  KeyId::\n"
        IDSwprintf(hModule, IDS_KEY_ID);

        PrintBytes(L"    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->IntendedKeyUsage.cbData) 
	{
        BYTE bFlags = *pInfo->IntendedKeyUsage.pbData;

        //"  IntendedKeyUsage:: "
		IDSwprintf(hModule, IDS_INTEND_KEY_USAGE);

        if (bFlags == 0)
            IDSwprintf(hModule, IDS_NONE);
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            //"DIGITAL_SIGNATURE "
			IDSwprintf(hModule, IDS_DIG_SIG);
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            //"NON_REPUDIATION "
			IDSwprintf(hModule, IDS_NON_REP);
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            //"KEY_ENCIPHERMENT "
			IDSwprintf(hModule, IDS_KEY_ENCI);
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            //"DATA_ENCIPHERMENT ");
			IDSwprintf(hModule, IDS_DATA_ENCI);
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            //"KEY_AGREEMENT ");
			IDSwprintf(hModule, IDS_KEY_AGRE);
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            //"KEY_CERT_SIGN "
			IDSwprintf(hModule, IDS_CERT_SIGN);
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            //"OFFLINE_CRL_SIGN "
			IDSwprintf(hModule, IDS_OFFLINE_CRL);
        printf("\n");
    }

    if (pInfo->pPrivateKeyUsagePeriod) 
	{
        PCERT_PRIVATE_KEY_VALIDITY p = pInfo->pPrivateKeyUsagePeriod;

		//"NotBefore:: %s\n"
		IDSwprintf(hModule, IDS_NOT_BEFORE, FileTimeText(&p->NotBefore));

		IDSwprintf(hModule, IDS_NOT_AFTER, FileTimeText(&p->NotAfter));
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayCrlDistPointsExtension
//--------------------------------------------------------------------------
 void DisplayCrlDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRL_DIST_POINTS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCRL_DIST_POINTS_INFO) TestNoCopyDecodeObject(
            X509_CRL_DIST_POINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 == pInfo->cDistPoint)
		//"    NO CRL Distribution Points\n"
        IDSwprintf(hModule, IDS_NO_CRL_DIS);
    else 
	{
        DWORD cPoint = pInfo->cDistPoint;
        PCRL_DIST_POINT pPoint = pInfo->rgDistPoint;

        for (i = 0; i < cPoint; i++, pPoint++) 
		{
			//"  CRL Distribution Point[%d]\n"
            IDSwprintf(hModule,IDS_CRL_IDS_I, i);
            DWORD dwNameChoice = pPoint->DistPointName.dwDistPointNameChoice;
            switch (dwNameChoice) 
			{
                case CRL_DIST_POINT_NO_NAME:
                    break;
                case CRL_DIST_POINT_FULL_NAME:
					//"    FullName:\n"
                    IDSwprintf(hModule, IDS_CRL_DIS_FULL_NAME);

                    DisplayAltName(&pPoint->DistPointName.FullName,
                        dwDisplayFlags);
                    break;

                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                    //printf("    IssuerRDN: (Not Implemented)\n");
					IDSwprintf(hModule, IDS_CRL_RDN);
                    break;

                default:
                    //"    Unknown name choice: %d\n", dwNameChoice);
					IDSwprintf(hModule, IDS_CRL_UNKNOWN, dwNameChoice);
					break;
            }

            if (pPoint->ReasonFlags.cbData) 
			{
                BYTE bFlags;

                //"    ReasonFlags: "
				IDSwprintf(hModule, IDS_REASON_FLAG);
                bFlags = *pPoint->ReasonFlags.pbData;

                if (bFlags == 0)
					//"<NONE> \n"
					IDSwprintf(hModule, IDS_NONE);
                if (bFlags & CRL_REASON_UNUSED_FLAG)
                    //"UNUSED "
					IDSwprintf(hModule, IDS_REASON_UNUSED);
                if (bFlags & CRL_REASON_KEY_COMPROMISE_FLAG)
                    //"KEY_COMPROMISE "
					IDSwprintf(hModule, IDS_KEY_COMP);
                if (bFlags & CRL_REASON_CA_COMPROMISE_FLAG)
					//"CA_COMPROMISE "
					IDSwprintf(hModule, IDS_CA_COMP);
                if (bFlags & CRL_REASON_AFFILIATION_CHANGED_FLAG)
                    //"AFFILIATION_CHANGED "
					IDSwprintf(hModule, IDS_AFFI_CHANGED);
                if (bFlags & CRL_REASON_SUPERSEDED_FLAG)
                    //"SUPERSEDED "
					IDSwprintf(hModule, IDS_SUPERSEDED);
                if (bFlags & CRL_REASON_CESSATION_OF_OPERATION_FLAG)
                    //"CESSATION_OF_OPERATION "
  					IDSwprintf(hModule, IDS_CESS_OPER);
				if (bFlags & CRL_REASON_CERTIFICATE_HOLD_FLAG)
                    //"CERTIFICATE_HOLD "
				  	IDSwprintf(hModule, IDS_CERT_HOLD);

                printf("\n");
            }

            if (pPoint->CRLIssuer.cAltEntry) 
			{
				//"    ISSUER::\n"
				IDSwprintf(hModule, IDS_CRL_ISSUER);

                DisplayAltName(&pPoint->CRLIssuer, dwDisplayFlags);
            }
        }
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayAuthorityKeyIdExtension
//--------------------------------------------------------------------------
 void DisplayAuthorityKeyIdExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID_INFO pInfo;

	//"  <AuthorityKeyId>\n"
	IDSwprintf(hModule, IDS_AUTH_KEY_ID);

    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) 
	{
		//"  KeyId::\n"
        IDSwprintf(hModule, IDS_KEY_ID);
        PrintBytes(L"    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->CertIssuer.cbData) 
	{
		//"  AuthorityCertIssuer::\n"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER);
        DecodeName(pInfo->CertIssuer.pbData, pInfo->CertIssuer.cbData,
            dwDisplayFlags);
    }
    if (pInfo->CertSerialNumber.cbData) 
	{
		//"  CertSerialNumber::"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER_SERIAL_NUMBER);
        DisplaySerialNumber(&pInfo->CertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  Get the name of an OID
//--------------------------------------------------------------------------
 void DisplayAuthorityKeyId2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo;

	//"  <AuthorityKeyId #2>\n"
	IDSwprintf(hModule, IDS_AUTH_KEY_ID2);

    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID2_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID2,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) 
	{
		//"  KeyId::\n"
        IDSwprintf(hModule, IDS_KEY_ID);
        PrintBytes(L"    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->AuthorityCertIssuer.cAltEntry) 
	{
		//"  AuthorityCertIssuer::\n"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER);
        DisplayAltName(&pInfo->AuthorityCertIssuer, dwDisplayFlags);
    }

    if (pInfo->AuthorityCertSerialNumber.cbData) 
	{
		//"  AuthorityCertSerialNumber::"
        IDSwprintf(hModule, IDS_AUTH_CERT_ISSUER_SERIAL_NUMBER);
        DisplaySerialNumber(&pInfo->AuthorityCertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayAnyString
//--------------------------------------------------------------------------
 void DisplayAnyString(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_NAME_VALUE pInfo = NULL;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

	//print the pre-fix
	IDSwprintf(hModule, idsIDS);

    if (pInfo->dwValueType == CERT_RDN_ENCODED_BLOB ||
            pInfo->dwValueType == CERT_RDN_OCTET_STRING) 
	{
		//"ValueType: %d\n"
		IDSwprintf(hModule, IDS_VALUE_TYPE, pInfo->dwValueType);
        PrintBytes(L"    ", pInfo->Value.pbData, pInfo->Value.cbData);
    } else
		//"ValueType: %d String: %s\n"
		IDSwprintf(hModule, IDS_VALUE_STRING_S,
		pInfo->dwValueType, pInfo->Value.pbData);

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}


//+-------------------------------------------------------------------------
//  DisplayBits
//--------------------------------------------------------------------------
 void DisplayBits(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
            X509_BITS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    IDSwprintf(hModule, idsIDS);

    if (1 == pInfo->cbData) 
	{
        printf(" %02X", *pInfo->pbData);
        if (pInfo->cUnusedBits)
		{
			//" (UnusedBits: %d)"
            IDSwprintf(hModule, IDS_UNUSED_BITS, pInfo->cUnusedBits);
		}
        printf("\n");
    } 
	else 
	{
        if (pInfo->cbData) 
		{
            printf("\n");
            PrintBytes(L"    ", pInfo->pbData, pInfo->cbData);
            IDSwprintf(hModule, IDS_UNUSED_BITS, pInfo->cUnusedBits);
			printf("\n");
        } 
		else
            IDSwprintf(hModule, IDS_NONE);
    }

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  DisplayOctetString
//--------------------------------------------------------------------------
 void DisplayOctetString(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_DATA_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_DATA_BLOB) TestNoCopyDecodeObject(
            X509_OCTET_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    IDSwprintf(hModule, idsIDS);

    PrintBytes(L"    ", pInfo->pbData, pInfo->cbData);

CommonReturn:
    if (pInfo)
        ToolUtlFree(pInfo);
}

//+-------------------------------------------------------------------------
//  Get the name of an OID
//--------------------------------------------------------------------------
LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo
		(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            )) 
	{
        if (L'\0' != pInfo->pwszName[0])
            return pInfo->pwszName;
    }

    return g_wszUnKnown;
}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints2
//--------------------------------------------------------------------------
 BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	WCHAR							wszFormat[100]=L"\0";
	WCHAR							wszLength[15];
	PCERT_BASIC_CONSTRAINTS2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;

	
	//check for input parameters
	if(( pbEncoded!=NULL && cbEncoded==0)
		||(pbEncoded==NULL && cbEncoded!=0)
		|| (pcbFormat==NULL))
	{
		SetLastError(E_INVALIDARG);
		return FALSE;
	}

	//check for simple case.  No work needed
	if(pbEncoded==NULL && cbEncoded==0)
	{
		*pcbFormat=0;
		return TRUE;
	}

    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS2,
            pbEncoded,
            cbEncoded
            ))) 
			return FALSE;

    
	//"  <Basic Constraints2> \n"
	IDSwcscat(hModule, wszFormat, IDS_BASIC_CON2);
	

    if (pInfo->fCA)
		//"  CA ");
		IDSwcscat(hModule,wszFormat,IDS_SUB_CA);
    else
		//"  End-Entity"
		IDSwcscat(hModule,wszFormat, IDS_SUB_EE);

	//"\n"
	IDSwcscat(hModule, wszFormat, IDS_ELN);

    //"  PathLenConstraint:: "
	IDSwcscat(hModule, wszFormat, IDS_PATH_LEN);

    if (pInfo->fPathLenConstraint)
	{
        swprintf(wszLength, L"%d",pInfo->dwPathLenConstraint);

		wcscat(wszFormat, wszLength);
	}
    else
        IDSwcscat(hModule, wszFormat, IDS_NONE_NOELN);

    if (pInfo)
        ToolUtlFree(pInfo);

	cbNeeded=sizeof(WCHAR)*(wcslen(wszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		return TRUE;
	}


	if((*pcbFormat)<cbNeeded)
	{
		SetLastError(ERROR_MORE_DATA);
		return FALSE;
	}

	//copy the data
	memcpy(pbFormat, wszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	return TRUE;
}


//+-------------------------------------------------------------------------
//  Get the name of an OID
//--------------------------------------------------------------------------
BOOL	InstalledFormat(LPSTR	szStructType, BYTE	*pbEncoded, DWORD cbEncoded)
{
	BOOL				fResult=FALSE;
	void				*pvFuncAddr=NULL;
    HCRYPTOIDFUNCADDR   hFuncAddr=NULL;
	DWORD				cbFormat=0;
	LPWSTR				wszFormat=NULL;
    DWORD               dwFormatStrType=0;

    if(TRUE==g_fMulti)
        dwFormatStrType |=CRYPT_FORMAT_STR_MULTI_LINE;


	if(NULL==pbEncoded || 0==cbEncoded)
		return FALSE;

	//load the formatting functions
	if (!CryptGetOIDFunctionAddress(
            hFormatFuncSet,
            g_dwCertEncodingType,
            szStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
		goto CLEANUP;


	//call the functions
	if(!((PFN_FORMAT_FUNC) pvFuncAddr)(
				g_dwCertEncodingType,     
				0,      
				dwFormatStrType,   
				NULL,    
				szStructType,   
				pbEncoded,   
				cbEncoded,         
				NULL,         
				&cbFormat     
            ))
		goto CLEANUP;


	//allocate
	wszFormat=(LPWSTR)ToolUtlAlloc(cbFormat * sizeof(WCHAR));

	if(!wszFormat)
		goto CLEANUP;
		
	if(!((PFN_FORMAT_FUNC) pvFuncAddr)(
				g_dwCertEncodingType,     
				0,      
				dwFormatStrType,   
				NULL,    
				szStructType,   
				pbEncoded,   
				cbEncoded,         
				wszFormat,         
				&cbFormat     
            ))
		goto CLEANUP;

   //print
	wprintf(L"%s\n", wszFormat);

	fResult=TRUE;

CLEANUP:

	if(wszFormat)
		ToolUtlFree(wszFormat);

	if(hFuncAddr)
		CryptFreeOIDFunctionAddress(hFuncAddr, 0);

	return fResult;

}

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

 WCHAR *GuidText(GUID *pguid)
{
    static WCHAR buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    swprintf(buf, L"{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certhlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlp.h
//
//  Contents:   the header for certhlp.cpp, the helper functions for 
//				CertMgr tool 
//
//
//  History:    21-July-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef CERTHLP_H
#define CERTHLP_H



#ifdef __cplusplus
extern "C" {
#endif	 


BOOL	CheckParameter();

BOOL	ParseSwitch (int	*pArgc, WCHAR	**pArgv[]);

void Usage(void);

void UndocumentedUsage();

BOOL	InitModule();

wchar_t *IDSwcscat(HMODULE hModule, WCHAR *pwsz, int idsString);


BOOL	SetParam(WCHAR **ppwszParam, WCHAR *pwszValue);

BOOL	OpenGenericStore(LPWSTR			wszStoreName,
						 BOOL			fSystemStore,
						 DWORD			dwStoreFlag,
						 LPSTR			szStoreProvider,
						 DWORD			dwStoreOpenFlag,
						 BOOL			fCheckExist,
						 HCERTSTORE		*phCertStore);

BOOL	AddCertStore(HCERTSTORE	hCertStore);

BOOL	DeleteCertStore(HCERTSTORE	hCertStore);

BOOL	PutCertStore(HCERTSTORE	hCertStore);

BOOL	SaveStore(HCERTSTORE hSrcStore);

BOOL	SetEKUProperty( HCERTSTORE		hSrcStore);

BOOL	SetNameProperty( HCERTSTORE		hSrcStore);


PCCRL_CONTEXT	FindCRLInStore(HCERTSTORE hCertStore,
							   CRYPT_HASH_BLOB	*pBlob);


BOOL	MoveItem(HCERTSTORE	hSrcStore, 
				 HCERTSTORE	hDesStore,
				 DWORD		dwItem);


BOOL	DeleteItem(HCERTSTORE	hSrcStore, 
				 DWORD		dwItem);


BOOL	DisplayCertAndPrompt(PCCERT_CONTEXT	*rgpCertContext, 
							 DWORD			dwCertCount, 
							 DWORD			*pdwIndex);

BOOL	DisplayCRLAndPrompt(PCCRL_CONTEXT	*rgpCRLContext, 
							 DWORD			dwCRLCount, 
							 DWORD			*pdwIndex);


BOOL	DisplayCTLAndPrompt(PCCTL_CONTEXT	*rgpCTLContext, 
							 DWORD			dwCTLCount, 
							 DWORD			*pdwIndex);


BOOL	BuildCertList(HCERTSTORE		hCertStore, 
					  LPWSTR			wszCertCN, 
					  PCCERT_CONTEXT	**prgpCertContext,
					  DWORD				*pdwCertCount);


BOOL	BuildCRLList(	HCERTSTORE		hCertStore, 
						PCCRL_CONTEXT	**prgpCRLContext,
						DWORD			*pdwCRLCount);


BOOL	BuildCTLList(	HCERTSTORE		hCertStore, 
						PCCTL_CONTEXT	**prgpCTLContext,
						DWORD			*pdwCTLCount);


BOOL	DisplayCertStore(HCERTSTORE	hCertStore);

BOOL	DisplayCert(PCCERT_CONTEXT	pCertContext, DWORD	dwItem);


BOOL	DisplayCTL(PCCTL_CONTEXT	pCTLContext, DWORD	dwItem);

BOOL	DisplayCRL(PCCRL_CONTEXT	pCRLContext, DWORD	dwItem);


BOOL	DisplaySignerInfo(HCRYPTMSG hMsg,  DWORD dwItem);


HCERTSTORE OpenSipStore(LPWSTR pwszStoreFilename);

HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb);

HRESULT Base64ToBytesW(WCHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb);

BOOL	GetBase64Decoded(LPWSTR		wszStoreName, 
						 BYTE		**ppbByte,
						 DWORD		*pcbByte);

HCERTSTORE OpenEncodedCRL(LPWSTR pwszStoreFilename);

HCERTSTORE OpenEncodedCTL (LPWSTR pwszStoreFilename);

HCERTSTORE OpenEncodedCert (LPWSTR pwszStoreFilename);

BOOL	SetParam(WCHAR **ppwszParam, WCHAR *pwszValue);

HRESULT	WSZtoBLOB(LPWSTR  pwsz, BYTE **ppbByte, DWORD	*pcbByte);

 DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    );

BOOL SignNoContentWrap(IN const BYTE *pbDER, IN DWORD cbDER);

 BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


 void PrintCtlEntries(PCCTL_CONTEXT pCtl, DWORD dwDisplayFlag);

 void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry,
        DWORD dwDisplayFlags);

BOOL	DisplaySignerInfo(HCRYPTMSG hMsg,  DWORD dwItem);

void PrintBytes(LPWSTR pwszHdr, BYTE *pb, DWORD cbSize);


 void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr,
        DWORD dwItem);


 void DecodeAndDisplayAltName(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayAltName(
    PCERT_ALT_NAME_INFO pInfo,
    DWORD dwDisplayFlags);


 void DisplayAltNameEntry(
    PCERT_ALT_NAME_ENTRY pEntry,
    DWORD dwDisplayFlags);


 void DisplayThumbprint(
    LPWSTR pwszHash,
    BYTE *pbHash,
    DWORD cbHash
    );

LPWSTR FileTimeText(FILETIME *pft);

 void PrintAuxCertProperties(PCCERT_CONTEXT pCert,DWORD dwDisplayFlags);


 void DecodeAndDisplayCtlUsage(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplaySignature(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    );


 BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwDisplayFlags);

 void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt, DWORD dwDisplayFlags);

 void DisplaySMIMECapabilitiesExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayEnhancedKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayCommonNameExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

  void DisplaySpcFinancialCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplaySpcMinimalCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

void DisplaySpcLink(PSPC_LINK pSpcLink);


 void DisplaySpcSpAgencyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayPoliciesExtension(
    int		idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayBasicConstraints2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayBasicConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayKeyUsage(BYTE	bFlag);

 void DisplayKeyUsageRestrictionExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayCRLReason(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayAltNameExtension(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayKeyAttrExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayCrlDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayAuthorityKeyIdExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayAuthorityKeyId2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayAnyString(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);


 void DisplayBits(
    int	 idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

 void DisplayOctetString(
    int	  idsIDS,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags);

LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId = 0);

BOOL	InstalledFormat(LPSTR	szStructType, BYTE	*pbEncoded, DWORD cbEncoded);

 WCHAR *GuidText(GUID *pguid);


 void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    );

HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz);

 void *TestNoCopyDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT DWORD       *pcbInfo = NULL
    );


BOOL IsTimeValidCtl(IN PCCTL_CONTEXT pCtl);

 void DisplaySerialNumber(PCRYPT_INTEGER_BLOB pSerialNumber);

void ReverseBytes(IN OUT PBYTE pbIn, IN DWORD cbIn);

ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId);

 void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    );

 void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    );

void DisplayTimeStamp(BYTE *pbEncoded,DWORD cbEncoded,DWORD	dwDisplayFlags);

#ifdef __cplusplus
}
#endif

#endif  // CERTHLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\certmgr\certhlp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       Certhlp.cpp
//
//  Contents:   Certificate store management tools helper functions
//
//
//  History:    July 21st   xiaohs   created
//              
//--------------------------------------------------------------------------

#include "certmgr.h"

//+-------------------------------------------------------------------------
//  GetSignAlgids
//--------------------------------------------------------------------------
 void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    )
{
    PCCRYPT_OID_INFO pInfo;

    *paiHash = 0;
    *paiPubKey = 0;
    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            CRYPT_SIGN_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

        *paiHash = pInfo->Algid;
        if (1 <= cExtra)
            *paiPubKey = pdwExtra[0];
    }
}

//+-------------------------------------------------------------------------
//  GetAlgid
//--------------------------------------------------------------------------
ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            ))
        return pInfo->Algid;
    return 0;
}
//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
 void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto ErrorReturn;
    if (NULL == (pvData = ToolUtlAlloc(cbData)))
        goto ErrorReturn;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        ToolUtlFree(pvData);
        goto ErrorReturn;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
}


////////////////////////////////////////////////////////
//
// Convert STR to WSTR
//
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz)
{
	DWORD	dwSize=0;
	DWORD	dwError=0;

	assert(pwsz);

	*pwsz=NULL;

	//return NULL
	if(!szStr)
		return S_OK;

	dwSize=MultiByteToWideChar(0, 0,szStr, -1,NULL,0);

	if(dwSize==0)
	{
		dwError=GetLastError();
		return HRESULT_FROM_WIN32(dwError);
	}

	//allocate memory
	*pwsz=(LPWSTR)ToolUtlAlloc(dwSize * sizeof(WCHAR));

	if(*pwsz==NULL)
		return E_OUTOFMEMORY;

	if(MultiByteToWideChar(0, 0,szStr, -1,
		*pwsz,dwSize))
	{
		return S_OK;
	}
	else
	{
		 ToolUtlFree(*pwsz);
		 dwError=GetLastError();
		 return HRESULT_FROM_WIN32(dwError);
	}
}

//+-------------------------------------------------------------------------
//  Decode the object and allocate memory
//--------------------------------------------------------------------------
 void *TestNoCopyDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT DWORD       *pcbInfo
    )
{
    BOOL fResult;
    DWORD cbInfo;
    void *pvInfo;

    if (pcbInfo)
        *pcbInfo = 0;
    
    // Set to bogus value. pvInfo == NULL, should cause it to be ignored.
    cbInfo = 0x12345678;
    fResult = CryptDecodeObject(
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvInfo
            &cbInfo
            );
    if (!fResult || cbInfo == 0) 
        return NULL;

    if (NULL == (pvInfo = ToolUtlAlloc(cbInfo)))
        return NULL;

    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvInfo,
            &cbInfo
            )) 
	{
        ToolUtlFree(pvInfo);
        return NULL;
    }

    if (pcbInfo)
        *pcbInfo = cbInfo;
    return pvInfo;
}


//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
BOOL IsTimeValidCtl(
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pCtlInfo = pCtl->pCtlInfo;
    SYSTEMTIME SystemTime;
    FILETIME CurrentTime;

    // Get current time to be used to determine if CTLs are time valid
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &CurrentTime);

    // Note, NextUpdate is optional. When not present, its set to 0
    if ((0 == pCtlInfo->NextUpdate.dwLowDateTime &&
                0 == pCtlInfo->NextUpdate.dwHighDateTime) ||
            CompareFileTime(&pCtlInfo->NextUpdate, &CurrentTime) >= 0)
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//  Display serial number
//
//--------------------------------------------------------------------------
 void DisplaySerialNumber(
    PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    DWORD cb;
    BYTE *pb;
    for (cb = pSerialNumber->cbData,
         pb = pSerialNumber->pbData + (cb - 1); cb > 0; cb--, pb--) {
        printf(" %02X", *pb);
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\makecert\root.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       root.h
//
//--------------------------------------------------------------------------

0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\makectl\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for makectl.cpp.  
//
//
//  History:    01-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------

//defintion for string IDS
 
#define IDS_SYNTAX					6002
#define	IDS_CAN_NOT_READ_FILE		6003
#define	IDS_CAN_NOT_PROPERTY		6004
#define	IDS_OUT_OF_MEMORY			6005
#define	IDS_OPTION_U				6006	
#define	IDS_OPTION_U_DESC			6007
#define	IDS_OPTIONS					6008
#define IDS_SYNTAX1					6009
#define	IDS_OPTION_U_DESC1			6010
#define	IDS_OPTION_U_DESC2			6011
#define IDS_FAILED					6013
#define IDS_SUCCEEDED				6014
#define	IDS_SWITCH1					6015
#define	IDS_SWITCH2					6016
#define IDS_TOO_FEW_PARAM			6017
#define	IDS_TOO_MANY_PARAM			6018
#define	IDS_OPTION_S				6019	
#define	IDS_OPTION_S_DESC			6020
#define	IDS_OPTION_R				6021
#define	IDS_OPTION_R_DESC           6022
#define	IDS_OPTION_MORE_VALUE		6023	                  
#define	IDS_R_CU					6024
#define	IDS_R_LM					6025
#define	IDS_ERR_OPEN_STORE			6026						
#define	IDS_ERR_HASH				6027			
#define	IDS_ERR_MEMORY				6028
#define	IDS_INVALID_R				6029
#define	IDS_ERR_ENCODE_CTL			6030
#define	IDS_ERR_SAVE_CTL			6031
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signcode\signcode.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signcode.cpp
//
//  Contents:   The signcode console tool
//
//  History:    July-1st-1997   Xiaohs    Created
//----------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <assert.h>
#include <wincrypt.h>

#include <signer.h>
#include "mssip.h"
#include "resource.h"
#include "unicode.h"
#include "signhlp.h"
#include "pvkhlpr.h"
#include "toolutl.h"
#include "javaAttr.h"
#include "cryptui.h"


#define ACTION_SIGN                 0x01
#define ACTION_STAMP                0x02
#define ACTION_REQUEST              0x04
#define ACTION_RESPONSE             0x08

#define STORE_DEFAULT_NAME_MAX          40
#define SHA1_LENGTH                     20


// Global data for parsing the input parameters
DWORD   dwAction =      0;
DWORD   dwExpectedError = 0;

BOOL    fSigning =      TRUE;
BOOL    fTesting =      FALSE;
BOOL    fStoreTechnology=TRUE;

BOOL    fUndocumented = FALSE;

LPWSTR pwszFile =        NULL;
LPWSTR pwszCapiProvider=NULL;
LPWSTR pwszProviderType=NULL;
LPWSTR pwszPvkFile =      NULL;
LPWSTR pwszKeyContainer= NULL;
LPWSTR pwszOpusName =    NULL;
LPWSTR pwszOpusInfo =    NULL;
LPWSTR pwszAlgorithm =   NULL;
LPWSTR pwszAuthority =   NULL;
LPWSTR pwszSpcFile =     NULL;
LPWSTR pwszCertFile     =NULL;
LPWSTR pwszCommonName =NULL;
LPWSTR pwszStoreName=     NULL;
LPWSTR pwszStoreLocation=NULL;
LPWSTR pwszStorePolicy=  NULL;
LPWSTR pwszHttpTime =    NULL;
LPWSTR pwszRequestFile  =NULL;
LPWSTR pwszResponseFile =NULL;
LPWSTR pwszWait=NULL;
LPWSTR pwszRepeat=NULL;
LPWSTR pwszKeySpec=NULL;
LPWSTR pwszSignerIndex=NULL;
LPWSTR pwszSha1Hash = NULL;

BYTE   *g_pbHash=NULL;
DWORD  g_cbHash=0;



DWORD   dwCertEncodingType=X509_ASN_ENCODING;
DWORD   dwStoreEncodingType=X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
DWORD   dwWait=0;
DWORD   dwRepeat=1;
DWORD   dwProviderType = PROV_RSA_FULL;
BOOL    fCommercial =   FALSE;
BOOL    fIndividual =   FALSE;
DWORD   dwKeySpec=0;
DWORD   dwSignerIndex=0;



LPWSTR              *prgwszDllName=NULL;
LPWSTR              *prgwszDllParam=NULL;
DWORD               dwDllIndex=0;
DWORD               dwParamIndex=0;


//default:
//Assume the store is on CERT_SYSTEM_STORE_CURRENT_USER
DWORD   dwStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
DWORD   dwStorePolicy=SIGNER_CERT_POLICY_SPC;
WCHAR   wszMyStore[STORE_DEFAULT_NAME_MAX];
//Use MD5 as the default hashing algorithm
ALG_ID  dwAlgorithmOid = CALG_MD5;

//Global Data for loading the string
#define OPTION_SWITCH_SIZE  5
#define WSTR_LENGTH_MAX     30

WCHAR   wszCaption[WSTR_LENGTH_MAX];
WCHAR   wszNULL[WSTR_LENGTH_MAX];
WCHAR   wszPlus[WSTR_LENGTH_MAX];


HMODULE hModule=NULL;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// function prototypes
HRESULT InitDllParameter(PCRYPT_ATTRIBUTES pAuthAttr,
                         PCRYPT_ATTRIBUTES pUnauthAttr,
                         PCRYPT_ATTRIBUTES *ppAuthAttr,
                         PCRYPT_ATTRIBUTES *ppUnauthAttr);

void    ReleaseDllParameter(PCRYPT_ATTRIBUTES * ppAuthAttr,
                            PCRYPT_ATTRIBUTES * ppUnauthAttr);

HRESULT SetUpSubjectInfo(SIGNER_SUBJECT_INFO        *pSubjectInfo,
                         SIGNER_FILE_INFO           *pFileInfo);

HRESULT SetUpParameter(SIGNER_SUBJECT_INFO      *pSubjectInfo,
                       SIGNER_FILE_INFO         *pFileInfo,
                       SIGNER_SIGNATURE_INFO    *pSignatureInfo,
                        SIGNER_ATTR_AUTHCODE    *pAttrAuthcode,
                        SIGNER_PROVIDER_INFO    *pProviderInfo,
                        SIGNER_CERT_STORE_INFO  *pCertStoreInfo,
                        SIGNER_CERT             *pSignerCert,
                        CRYPT_ATTRIBUTES        *pAuthenticated,
                        CRYPT_ATTRIBUTES        *pUnauthenticated,
                        HCERTSTORE              *phCertStore);


PCCERT_CONTEXT  GetSigningCert(HCERTSTORE *phCertStore, BOOL *pfMore);


HRESULT GetCertHashFromFile(LPWSTR  pwszCertFile,
                            BYTE    **pHash,
                            DWORD   *pcbHash,
                            BOOL    *pfMore);
//--------------------------------------------------------------------------
//   Get the hModule hanlder and init two DLLMain.
//
//---------------------------------------------------------------------------
BOOL    InitModule()
{
    if(!(hModule=GetModuleHandle(NULL)))
       return FALSE;

    return TRUE;
}

//--------------------------------------------------------------------------------
//
// Help command
//--------------------------------------------------------------------------------
void Usage()
{
    IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_OPTIONS);
    IDSwprintf(hModule,IDS_OPTION_SPC_DESC);

    IDSwprintf(hModule,IDS_OPTION_V_DESC);
    IDSwprintf(hModule,IDS_OPTION_K_DESC);

    IDSwprintf(hModule,IDS_OPTION_N_DESC);
    IDSwprintf(hModule,IDS_OPTION_I_DESC);
    IDSwprintf(hModule,IDS_OPTION_P_DESC);
    IDSwprintf(hModule,IDS_OPTION_Y_DESC);
    IDSwprintf(hModule,IDS_OPTION_KY_DESC);
    IDS_IDS_IDSwprintf(hModule, IDS_OPTION_KY_VALUES, IDS_OPTION_KY_SIG,
                        IDS_OPTION_KY_EXC);
    IDSwprintf(hModule,IDS_OPTION_AUTH_DESC);
    IDS_IDS_IDSwprintf(hModule,IDS_OPTION_AUTH_VALUE, IDS_AUTHORITY_ID,
        IDS_AUTHORITY_CM);
    IDS_IDSwprintf(hModule,IDS_OPTION_AUTH_VALUE1, IDS_AUTHORITY_DEFAULT);
    IDSwprintf(hModule,IDS_OPTION_A_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE, IDS_A_MD5,
        IDS_A_SHA, IDS_A_MD5);

    IDSwprintf(hModule,IDS_OPTION_T_DESC);
    IDSwprintf(hModule,IDS_OPTION_TR_DESC);
    IDSwprintf(hModule,IDS_OPTION_TW_DESC);
    IDSwprintf(hModule,IDS_OPTION_J_DESC);
    IDSwprintf(hModule,IDS_OPTION_JP_DESC);

    IDSwprintf(hModule,IDS_OPTION_C_DESC);
    IDSwprintf(hModule,IDS_OPTION_S_DESC);
    IDSwprintf(hModule,IDS_OPTION_R_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE, IDS_R_LM, IDS_R_CU,IDS_R_CU);
    IDSwprintf(hModule,IDS_OPTION_SP_DESC);
    IDSwprintf(hModule,IDS_OPTION_SP_DESC1);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE, IDS_OPTION_SP_CHAIN,
        IDS_OPTION_SP_SPCSTORE, IDS_OPTION_SP_SPCSTORE);
    IDSwprintf(hModule, IDS_OPTION_CN_DESC);
    IDSwprintf(hModule, IDS_OPTION_SHA1_DESC);

    IDSwprintf(hModule,IDS_OPTION_X_DESC);



    IDSwprintf(hModule,IDS_ENFLN);
    IDSwprintf(hModule, IDS_MORE_INFO_1);
    IDSwprintf(hModule, IDS_MORE_INFO_2);
    IDSwprintf(hModule, IDS_MORE_INFO_3);
}

void UndocumentedUsage()
{
    IDSwprintf(hModule,IDS_SYNTAX);
    IDSwprintf(hModule,IDS_OPTIONS);

    IDSwprintf(hModule, IDS_OPTION_H_DESC);
    IDSwprintf(hModule, IDS_OPTION_TQ_DESC);
    IDSwprintf(hModule, IDS_OPTION_TS_DESC);
    IDSwprintf(hModule, IDS_OPTION_INDEX_DESC);

    //mark this is undocumented
    fUndocumented=TRUE;
}


//--------------------------------------------------------------------------------
// Print out error msg based on the HRESULT
//--------------------------------------------------------------------------------
BOOL    PrintBasedOnHResult(HRESULT hr)
{
    BOOL    fKnownResult=TRUE;

    switch(hr)
    {
        //0x80070002 is the HRESULT_FROM_WIN32(GetLastError()) when CreateFile failed
        case 0x80070002:
                IDSwprintf(hModule,IDS_ERR_INPUT_INVALID);
            break;
        case HRESULT_FROM_WIN32(ERROR_INVALID_DATA):
                IDSwprintf(hModule,IDS_ERR_RESPONSE_INVALID);
            break;
        case HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION):
                IDSwprintf(hModule, IDS_ERR_INVALID_ADDRESS);
            break;
        case CRYPT_E_NO_MATCH:
                IDSwprintf(hModule,IDS_ERR_NOMATCH);
            break;
        case TYPE_E_TYPEMISMATCH:
                IDSwprintf(hModule,IDS_ERR_AUTH);
            break;
        case CRYPT_E_FILERESIZED:
                IDSwprintf(hModule,IDS_ERR_RESIZE);
            break;
        case TRUST_E_TIME_STAMP:
                IDSwprintf(hModule, IDS_ERR_TS_CERT_INVALID);
            break;
        case CRYPT_E_NO_DECRYPT_CERT:
                IDSwprintf(hModule, IDS_ERR_NO_CERT, pwszStoreName);
            break;
        case CRYPT_E_DELETED_PREV:
                IDSwprintf(hModule, IDS_ERR_TOO_MANY_CERT, pwszStoreName);
            break;
        case CRYPT_E_NO_PROVIDER:
                IDSwprintf(hModule, IDS_ERR_NO_PROVIDER);
            break;
        case CERT_E_CHAINING:
                IDSwprintf(hModule, IDS_ERR_NO_CHAINING);
            break;
        case CERT_E_EXPIRED:
                IDSwprintf(hModule, IDS_ERR_EXPRIED);
            break;
        default:
            fKnownResult=FALSE;
    }
    return fKnownResult;

}

//--------------------------------------------------------------------------------
// Convert an array of wchars to a BLOB
//--------------------------------------------------------------------------------
HRESULT WSZtoBLOB(LPWSTR  pwsz, BYTE **ppbByte, DWORD   *pcbByte)
{
    HRESULT     hr=E_FAIL;
    DWORD       dwIndex=0;
    ULONG       ulHalfByte=0;
    DWORD       dw1st=0;
    DWORD       dw2nd=0;

    if((!pwsz) || (!ppbByte) || (!pcbByte))
        return E_INVALIDARG;

    *ppbByte=NULL;
    *pcbByte=0;

    //make sure the pwsz consists of 20 characters
    if(wcslen(pwsz)!= 2*SHA1_LENGTH)
        return E_FAIL;

    //memory allocation
    *ppbByte=(BYTE *)ToolUtlAlloc(SHA1_LENGTH);
    if(NULL==(*ppbByte))
        return E_INVALIDARG;

    memset(*ppbByte, 0, SHA1_LENGTH);

    //go through two characters (one byte) at a time
    for(dwIndex=0; dwIndex<SHA1_LENGTH; dwIndex++)
    {
        dw1st=dwIndex * 2;
        dw2nd=dwIndex * 2 +1;

        //1st character
        if(((int)(pwsz[dw1st])-(int)(L'0')) <=9  &&
           ((int)(pwsz[dw1st])-(int)(L'0')) >=0)
        {

            ulHalfByte=(ULONG)((ULONG)(pwsz[dw1st])-(ULONG)(L'0'));
        }
        else
        {
            if(((int)(towupper(pwsz[dw1st]))-(int)(L'A')) >=0 &&
               ((int)(towupper(pwsz[dw1st]))-(int)(L'A')) <=5 )
               ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw1st]))-(ULONG)(L'A'));
            else
            {
                hr=E_INVALIDARG;
                goto CLEANUP;
            }
        }

        //copy the 1st character
        (*ppbByte)[dwIndex]=(BYTE)ulHalfByte;

        //left shift 4 bits
        (*ppbByte)[dwIndex]= (*ppbByte)[dwIndex] <<4;

        //2nd character
        if(((int)(pwsz[dw2nd])-(int)(L'0')) <=9  &&
           ((int)(pwsz[dw2nd])-(int)(L'0')) >=0)
        {

            ulHalfByte=(ULONG)((ULONG)(pwsz[dw2nd])-(ULONG)(L'0'));
        }
        else
        {
            if(((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) >=0 &&
               ((int)(towupper(pwsz[dw2nd]))-(int)(L'A')) <=5 )
               ulHalfByte=10+(ULONG)((ULONG)(towupper(pwsz[dw2nd]))-(ULONG)(L'A'));
            else
            {
                hr=E_INVALIDARG;
                goto CLEANUP;
            }
        }

        //ORed the second character
        (*ppbByte)[dwIndex]=(*ppbByte)[dwIndex] | ((BYTE)ulHalfByte);

    }


    hr=S_OK;

CLEANUP:

    if(hr!=S_OK)
    {
       if(*ppbByte)
           ToolUtlFree(*ppbByte);

       *ppbByte=NULL;
    }
    else
        *pcbByte=SHA1_LENGTH;

    return hr;

}

//--------------------------------------------------------------------------------
//make sure the input parameters make sense for signing
//--------------------------------------------------------------------------------
BOOL CheckSignParam()
{
    //make sure pwszPvkFile and pwszKeyContainer name are not set at the same time
    if(pwszPvkFile && pwszKeyContainer)
    {
        IDSwprintf(hModule,IDS_ERR_BOTH_PVK);
        return FALSE;
    }

    //make sure spc/pvk information and store related information can not be set
    //at the same time
    if(pwszSpcFile || pwszPvkFile || pwszKeyContainer || pwszProviderType ||
        pwszCapiProvider ||pwszKeySpec)
    {
        fStoreTechnology=FALSE;

        if(pwszStoreName || pwszCertFile || pwszStoreName || pwszStorePolicy ||
            pwszStoreLocation || pwszCommonName || pwszSha1Hash)
        {
            IDSwprintf(hModule,IDS_ERR_BOTH_SPC);
            return FALSE;
        }

        //now that we are not using certStore, spc file has to be set
        if(!pwszSpcFile)
        {
            IDSwprintf(hModule, IDS_ERR_NO_SPC);
            return FALSE;
        }

        //either PVKFile or KeyContainer has to be set
        if(pwszPvkFile == NULL && pwszKeyContainer ==NULL)
        {
            IDSwprintf(hModule,IDS_ERR_NO_PVK);
            return FALSE;
        }
    }

    //pwszCommonName, pwszCertFile and pwszSha1Hash can not be set at the same time
    if(pwszCertFile)
    {
        if(pwszCommonName || pwszSha1Hash)
        {
            IDSwprintf(hModule, IDS_ERR_BOTH_CN_SHA1);
            return FALSE;
        }
    }

    if(pwszCommonName && pwszSha1Hash)
    {
        IDSwprintf(hModule, IDS_ERR_BOTH_CN_SHA1);
        return FALSE;
    }

    //if pwszStoreLocation is set, then the storeName as to be set
    if(pwszStoreLocation && (pwszStoreName==NULL))
    {
        IDSwprintf(hModule, IDS_STORE_LOCATION_NAME);
        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------------
//make sure the user has passed in a valid set of parameters
//--------------------------------------------------------------------------------
BOOL CheckParameter()
{
    BOOL    fValid=FALSE;

    //has to set the file name
    if(!pwszFile)
    {
        IDSwprintf(hModule,IDS_ERR_NO_FILE);
        return FALSE;
    }


    if(fSigning==TRUE)
    {
        dwAction |= ACTION_SIGN;

        //make sure the input parameters make sense
        if(!CheckSignParam())
            return FALSE;
    }

    if(pwszResponseFile)
    {
        dwAction |= ACTION_RESPONSE;
    }

    if(pwszHttpTime)
    {
        dwAction |= ACTION_STAMP;


        //make sure that we have http:// in the address
        if(wcslen(pwszHttpTime)<=7)
        {
           IDSwprintf(hModule,IDS_ERR_ADDR_INVALID);
           return FALSE;
        }

        if(IDSwcsnicmp(hModule, pwszHttpTime, IDS_HTTP,7)!=0)
        {
           IDSwprintf(hModule,IDS_ERR_HTTP);
           return FALSE;
        }
    }

    if(pwszRequestFile)
    {
        dwAction |= ACTION_REQUEST;

    }

    //make sure timestamping and applying response do not go together
    if((dwAction & ACTION_RESPONSE) && (dwAction & ACTION_STAMP))
    {
        IDSwprintf(hModule,IDS_ERR_TIME_RESPONSE);
        return FALSE;
    }

    //make sure apply response can not be done after a new signature
    if((dwAction & ACTION_SIGN) && (dwAction & ACTION_RESPONSE))
    {
        IDSwprintf(hModule,IDS_ERR_SIGN_RESPONSE);
        return FALSE;
    }



    //determine the algorithm OID
    if(pwszAlgorithm)
    {
        if(IDSwcsicmp(hModule, pwszAlgorithm, IDS_A_MD5) == 0)
            dwAlgorithmOid = CALG_MD5;
        else
        {
            if(IDSwcsicmp(hModule,pwszAlgorithm, IDS_A_SHA) == 0)
                dwAlgorithmOid = CALG_SHA1;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_ALGO);
                return FALSE;
            }
        }

    }

    //determing the store location
    if(pwszStoreLocation)
    {
        if(IDSwcsicmp(hModule,pwszStoreLocation, IDS_R_CU) == 0)
            dwStoreFlag = CERT_SYSTEM_STORE_CURRENT_USER;
        else
        {
            if(IDSwcsicmp(hModule,pwszStoreLocation, IDS_R_LM) == 0)
                dwStoreFlag = CERT_SYSTEM_STORE_LOCAL_MACHINE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_REG);
                return FALSE;
            }
        }
    }


    //determing the store policy
    if(pwszStorePolicy)
    {
        if(IDSwcsicmp(hModule,pwszStorePolicy, IDS_OPTION_SP_CHAIN) == 0)
            dwStorePolicy=SIGNER_CERT_POLICY_CHAIN;
        else
        {
            if(IDSwcsicmp(hModule, pwszStorePolicy, IDS_OPTION_SP_SPCSTORE) == 0)
                dwStorePolicy=SIGNER_CERT_POLICY_SPC;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_POLICY);
                return FALSE;
            }
        }
    }

    //determine the signing authority, either individual or commercial
    if(pwszAuthority)
    {
        if(IDSwcsicmp(hModule,pwszAuthority, IDS_AUTHORITY_ID) == 0)
            fIndividual = TRUE;
        else
        {
            if(IDSwcsicmp(hModule,pwszAuthority, IDS_AUTHORITY_CM) == 0)
                fCommercial = TRUE;
            else
            {
                IDSwprintf(hModule,IDS_ERR_NO_AUTH);
                return FALSE;
            }
        }
    }

    //determine the key specificatioin
    if(pwszKeySpec)
    {
        if(IDSwcsicmp(hModule,pwszKeySpec, IDS_OPTION_KY_SIG) == 0)
            dwKeySpec = AT_SIGNATURE;
        else
        {
            if(IDSwcsicmp(hModule,pwszKeySpec, IDS_OPTION_KY_EXC) == 0)
                dwKeySpec = AT_KEYEXCHANGE;
            else
                dwKeySpec=_wtol(pwszKeySpec);
        }

    }

    //get the hash
    if(pwszSha1Hash)
    {
        if(S_OK != WSZtoBLOB(pwszSha1Hash, &g_pbHash, &g_cbHash))
        {
            //sha1 hash is invalid
            IDSwprintf(hModule, IDS_ERR_SHA1_HASH);
            return FALSE;
        }
    }


    //determine the provider Type
    if(pwszProviderType)
        dwProviderType = _wtoi(pwszProviderType);

     //get the # of timestamp trial and the # of seconds of delay between
     //each trial
    if(pwszWait)
        dwWait = _wtoi(pwszWait);

    if(pwszRepeat)
        dwRepeat = _wtoi(pwszRepeat);

   //determine the default store name
    if(!pwszStoreName)
        pwszStoreName=wszMyStore;

    //determin the signerIndex.  Default to 0
    if(pwszSignerIndex)
        dwSignerIndex=_wtol(pwszSignerIndex);

    return TRUE;
}

//--------------------------------------------------------------------------------
// Set the parameters.  They can only be set once
//--------------------------------------------------------------------------------
BOOL    SetParam(WCHAR **ppwszParam, WCHAR *pwszValue)
{
    if(*ppwszParam!=NULL)
    {
        IDSwprintf(hModule,IDS_ERR_TOO_MANY_PARAM);
        return FALSE;
    }

    *ppwszParam=pwszValue;

    return TRUE;
}


//--------------------------------------------------------------------------------
// Parse arguements
//--------------------------------------------------------------------------------
BOOL
ParseSwitch (int    *pArgc,
             WCHAR  **pArgv[])
{
    WCHAR* param = **pArgv;

    //move pass '/' or '-'
    param++;

    if (IDSwcsicmp(hModule, param, IDS_OPTION_H) == 0)
    {
        fTesting = TRUE;
        if (!(param[1]))
        {
            if (!--(*pArgc))
                return FALSE;

            (*pArgv)++;
            param = **pArgv;
            dwExpectedError = wcstoul(&param[0], NULL, 16);
        }
        else
        {
            dwExpectedError = wcstoul(&param[1], NULL, 16);
        }

        return TRUE;
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_SPC)==0) {
        if (!--(*pArgc))
            return FALSE;

       (*pArgv)++;
       return SetParam(&pwszSpcFile, **pArgv);
    }
    else if(IDSwcsicmp(hModule, param, IDS_OPTION_C)==0) {
        if (!--(*pArgc))
            return FALSE;

       (*pArgv)++;
       return SetParam(&pwszCertFile, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_S)==0) {
        if (!--(*pArgc))
            return FALSE;

       (*pArgv)++;

       return SetParam(&pwszStoreName, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_R)==0) {
        if (!--(*pArgc))
            return FALSE;

       (*pArgv)++;

       return SetParam(&pwszStoreLocation, **pArgv);

    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_SP)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszStorePolicy, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_CN)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszCommonName, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_SHA1)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszSha1Hash, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_V)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszPvkFile, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_K)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszKeyContainer, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_N)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszOpusName, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_I)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszOpusInfo, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_P)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszCapiProvider, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_Y)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszProviderType, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_KY)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszKeySpec, **pArgv);
    }

    else if(IDSwcsicmp(hModule,param, IDS_OPTION_AUTH)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszAuthority, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_A)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszAlgorithm, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_X)==0) {
        fSigning=FALSE;

        return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_T)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszHttpTime, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_TW)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszWait,**pArgv);
   }
   else if(IDSwcsicmp(hModule,param, IDS_OPTION_TR)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszRepeat,**pArgv);
    }

    else if(IDSwcsicmp(hModule,param, IDS_OPTION_J)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        prgwszDllName[dwDllIndex]=**pArgv;

        //mark its corresponding parameter as NULL
        dwParamIndex=dwDllIndex;
        prgwszDllParam[dwParamIndex]=NULL;

        dwDllIndex++;

        return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_JP)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        //make sure there is only one or less parameter per dll
        if(dwParamIndex+1!=dwDllIndex)
            return FALSE;

        prgwszDllParam[dwParamIndex]=**pArgv;

        dwParamIndex++;

        return TRUE;
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_TS)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszResponseFile, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_TQ)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszRequestFile, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_INDEX)==0) {
        if (!--(*pArgc))
            return FALSE;

        (*pArgv)++;

        return SetParam(&pwszSignerIndex, **pArgv);
    }
    else if(IDSwcsicmp(hModule,param, IDS_OPTION_TEST)==0) {

        UndocumentedUsage();
        return FALSE;
    }


    return FALSE;
}


//--------------------------------------------------------------------------------
//
// wmain
//
//--------------------------------------------------------------------------------
extern "C" int __cdecl wmain(int argc, WCHAR ** wargv)
{
    HRESULT     hr = E_FAIL;
    int         idsAction=IDS_ACTION_SIGNCODE;

    BYTE        *pbStampResponse=NULL;
    DWORD       cbStampResponse=0;
    BYTE        *pbStampRequest=NULL;
    DWORD       cbStampRequest=0;
    HANDLE      hFile=NULL;
    DWORD       dwWriteBytes=0;


    WCHAR       *pwChar;
    WCHAR       wszSwitch1[OPTION_SWITCH_SIZE];
    WCHAR       wszSwitch2[OPTION_SWITCH_SIZE];

    CRYPT_ATTRIBUTES    AuthAttr;
    CRYPT_ATTRIBUTES    UnauthAttr;
    PCRYPT_ATTRIBUTES   *ppAuthAttr=NULL;
    PCRYPT_ATTRIBUTES   *ppUnauthAttr=NULL;
    DWORD               dwIndex=0;
    DWORD               dwMilliSeconds=0;

    SIGNER_SUBJECT_INFO     subjectInfo;
    SIGNER_FILE_INFO        fileInfo;
    SIGNER_SIGNATURE_INFO   signatureInfo;
    SIGNER_ATTR_AUTHCODE    attrAuthcode;
    SIGNER_PROVIDER_INFO    providerInfo;
    SIGNER_CERT_STORE_INFO  certStoreInfo;
    SIGNER_CERT             signerCert;
    HCERTSTORE              hCertStore=NULL;

   CRYPTUI_WIZ_DIGITAL_SIGN_INFO    DigitalSignInfo;

    //call the UI version of the signcode
    if(1==argc)
    {

       //memset
       memset(&DigitalSignInfo, 0, sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO));
       DigitalSignInfo.dwSize=sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO);

         //call the signing wizard, which provides
         //the confirmation result.
         if(CryptUIWizDigitalSign(0,
                                NULL,
                                NULL,
                                &DigitalSignInfo,
                                NULL))
            return 0;
         else
            return -1;
    }


    //get the module handle
    if(!InitModule())
        return -1;

    //load the strings necessary for parsing the parameters
    if( !LoadStringU(hModule, IDS_SWITCH1,  wszSwitch1, OPTION_SWITCH_SIZE)
      ||!LoadStringU(hModule, IDS_SWITCH2,  wszSwitch2, OPTION_SWITCH_SIZE)
      ||!LoadStringU(hModule, IDS_CAPITION, wszCaption, WSTR_LENGTH_MAX)
      ||!LoadStringU(hModule, IDS_PLUS,     wszPlus,    WSTR_LENGTH_MAX)
      ||!LoadStringU(hModule, IDS_MY,       wszMyStore, STORE_DEFAULT_NAME_MAX)
      )
        return -1;

    //load wszNULL
    LoadStringU(hModule, IDS_NULL,     wszNULL,    WSTR_LENGTH_MAX);

    if ( argc <= 1 )
    {
        Usage ();
        return -1;
    }

    //allocate memory for prgwszDllName and prgwszDllParam
    prgwszDllName=(LPWSTR *)ToolUtlAlloc(sizeof(LPWSTR)*argc);
    prgwszDllParam=(LPWSTR *)ToolUtlAlloc(sizeof(LPWSTR)*argc);
    dwDllIndex=0;
    dwParamIndex=0;

    if(!prgwszDllName || !prgwszDllParam)
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //memset
    memset(prgwszDllName, 0, sizeof(LPWSTR)*argc);
    memset(prgwszDllParam, 0, sizeof(LPWSTR)*argc);
    memset(&AuthAttr, 0, sizeof(CRYPT_ATTRIBUTES));
    memset(&UnauthAttr, 0, sizeof(CRYPT_ATTRIBUTES));


    //parse the parameters
    while (--argc)
    {
        pwChar = *++wargv;
        if (*pwChar == *wszSwitch1 || *pwChar == *wszSwitch2)
        {
            //parse the options
            if(!ParseSwitch (&argc, &wargv))
            {
                if(FALSE==fUndocumented)
                    Usage();

                return -1;
            }
        }
        else
        {
            //parse the file name
            if(!SetParam(&pwszFile, pwChar))
            {
                Usage();
                hr=E_FAIL;
                goto CLEANUP;
            }
        }
    }



    //Determine the parameter sets passed in by the user
    if(!CheckParameter())
    {
        Usage();
        hr=E_INVALIDARG;
        goto CLEANUP;
    }

    //memory allocation for the dlls
    if(dwDllIndex)
    {
        ppAuthAttr=(PCRYPT_ATTRIBUTES *)ToolUtlAlloc(sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);
        ppUnauthAttr=(PCRYPT_ATTRIBUTES *)ToolUtlAlloc(sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);

        if(!ppAuthAttr || !ppUnauthAttr)
        {
            hr=E_OUTOFMEMORY;
            goto CLEANUP;
        }

        memset(ppAuthAttr, 0,sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);
        memset(ppUnauthAttr, 0,sizeof(PCRYPT_ATTRIBUTES)*dwDllIndex);
    }


    //init the dll parameters, call the GetAttr entry points of the dlls
    if(dwDllIndex)
    {
        if(S_OK!=(hr=InitDllParameter(&AuthAttr, &UnauthAttr,
            ppAuthAttr, ppUnauthAttr)))
            goto CLEANUP;
    }

    //Perform the requested action one at a time
    if(dwAction & ACTION_SIGN)
    {
        idsAction=IDS_ACTION_SIGN;

        //set up the parameters for signing
        if(S_OK != (hr=SetUpParameter(&subjectInfo, &fileInfo, &signatureInfo,
                        &attrAuthcode, &providerInfo,
                        &certStoreInfo, &signerCert,&AuthAttr,
                        &UnauthAttr, &hCertStore)))
            goto CLEANUP;


        hr=SignerSign(&subjectInfo,
                      &signerCert,
                      &signatureInfo,
                      fStoreTechnology ? NULL : &providerInfo,
                      NULL,
                      NULL,
                      NULL);

        if (hr != S_OK)
        {
            idsAction=IDS_ACTION_SIGN;
            goto CLEANUP;
        }

#if (0) //DSIE: Bug 236022
        //warn the user that the file is not timeStamped
        if (!(dwAction & ACTION_STAMP) && !(dwAction & ACTION_RESPONSE) && !(fTesting))
            IDSwprintf(hModule,IDS_WARNING);
#endif
        //free the certificate context
        if(certStoreInfo.pSigningCert)
            CertFreeCertificateContext(certStoreInfo.pSigningCert);

        //close the cert store which includes the signing certificate
        if(hCertStore)
            CertCloseStore(hCertStore, 0);

    }

    if(dwAction & ACTION_STAMP)
    {
        //timestamp the code
        dwMilliSeconds=dwWait*1000;

        //set up subject information
        if((dwAction & ACTION_SIGN) ==0)
        {
            if(S_OK!=(hr=SetUpSubjectInfo(&subjectInfo, &fileInfo)))
                goto CLEANUP;
        }


        //perform the # of trials
        for(dwIndex=0; dwIndex<dwRepeat; dwIndex++)
        {

            hr=SignerTimeStamp(&subjectInfo,pwszHttpTime,NULL,NULL);

            if(hr==S_OK)
                break;

            //wait per timestamp request
            if(dwWait!=0)
                Sleep(dwMilliSeconds);
        }

        if (hr != S_OK)
        {
            idsAction=IDS_ACTION_TIMESTAMP;
            goto CLEANUP;
        }

    }

    if(dwAction & ACTION_RESPONSE)
    {

        hr=RetrieveBLOBFromFile(pwszResponseFile,&cbStampResponse,
            &pbStampResponse);

        if (hr != S_OK)
        {
            idsAction=IDS_ACTION_RESPONSE;
            goto CLEANUP;
        }

        //set up subject information
        if(S_OK!=(hr=SetUpSubjectInfo(&subjectInfo, &fileInfo)))
                goto CLEANUP;

        hr=SignerAddTimeStampResponse(&subjectInfo,
                        pbStampResponse,
                        cbStampResponse,
                        NULL);

        if (hr != S_OK)
        {
            idsAction=IDS_ACTION_RESPONSE;
            goto CLEANUP;
        }
    }

    if(dwAction & ACTION_REQUEST)
    {
        cbStampRequest=0;

        //set up subject information
        if(S_OK!=(hr=SetUpSubjectInfo(&subjectInfo, &fileInfo)))
                goto CLEANUP;


        hr=SignerCreateTimeStampRequest(
            &subjectInfo,
            NULL,
            NULL,
            NULL,
            &cbStampRequest);

        if (hr != S_OK)
        {
            idsAction=IDS_ACTION_REQUEST;
            goto CLEANUP;
        }

        pbStampRequest=(BYTE *)ToolUtlAlloc(cbStampRequest);

        if(!pbStampRequest)
        {
            hr=E_OUTOFMEMORY;
            idsAction=IDS_ACTION_REQUEST;
            goto CLEANUP;
        }

        hr=SignerCreateTimeStampRequest(
            &subjectInfo,
            NULL,
            NULL,
            pbStampRequest,
            &cbStampRequest);

        if ( hr != S_OK)
        {
            idsAction=IDS_ACTION_REQUEST;
            goto CLEANUP;
        }

        //put the stamp request into a file
        if((hFile = CreateFileU(pwszRequestFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL)) == INVALID_HANDLE_VALUE)
        {
            hr=SignError();
            idsAction=IDS_ACTION_REQUEST;
            goto CLEANUP;
        }



        if(WriteFile(hFile,
                     pbStampRequest,
                     cbStampRequest,
                     &dwWriteBytes,
                     NULL) == FALSE ||
                 dwWriteBytes != cbStampRequest)
        {
            hr=SignError();
            idsAction=IDS_ACTION_REQUEST;
            goto CLEANUP;
        }

    }



CLEANUP:

    if (fTesting)
    {
        if (hr == (HRESULT)dwExpectedError)
            IDSwprintf(hModule,IDS_TEST_SUCCEEDED, hr);
        else
            IDSwprintf(hModule,IDS_TEST_FAILED, dwExpectedError, hr);
    }
    else
    {
        if(hr==S_OK)
        {
            IDSwprintf(hModule,IDS_SUCCEEDED);

            //we need to tell user the returned index of signature/timestamp
            if(pwszSignerIndex)
                IDSwprintf(hModule, IDS_SIGNER_INDEX, *(subjectInfo.pdwIndex));
        }
        else
        {
            //first try to print out dedebug info
            if(!PrintBasedOnHResult(hr))
            {

                //print out addtional info for timestamping
                if(idsAction==IDS_ACTION_TIMESTAMP)
                {
                    /*if(dwIndex!=1)
                    IDSwprintf(hModule,IDS_TIMESTAMP_TIMES_DELAY, dwIndex+1,dwWait); */

                    //file needs to be signed in order to timestamp it
                    if((dwAction & ACTION_SIGN) ==0)
                        //file may needs to be resigned
                        IDSwprintf(hModule,IDS_RESIGN);
                }
            }

            //then print out general information
            IDS_IDS_DW_DWwprintf(hModule,IDS_ERROR, idsAction, hr, hr);

        }
    }

    if(hFile)
        CloseHandle(hFile);

    //release the authenticated attributes
    ReleaseDllParameter(ppAuthAttr, ppUnauthAttr);

    //release prgwszDllName
    if(prgwszDllName)
        ToolUtlFree(prgwszDllName);

    //release prgwszDllParam
    if(prgwszDllParam)
        ToolUtlFree(prgwszDllParam);

    //release pAuthAttr
    if(AuthAttr.rgAttr)
        ToolUtlFree(AuthAttr.rgAttr);

    if(UnauthAttr.rgAttr)
        ToolUtlFree(UnauthAttr.rgAttr);

    //free ppAuthAttr and ppUnauthAttr
    if(ppAuthAttr)
        ToolUtlFree(ppAuthAttr);

    if(ppUnauthAttr)
        ToolUtlFree(ppUnauthAttr);


    if(pbStampResponse)
        UnmapViewOfFile(pbStampResponse);

    if(pbStampRequest)
        ToolUtlFree(pbStampRequest);


    if(g_pbHash)
        ToolUtlFree(g_pbHash);


    if(hr==S_OK)
        return 0;
    else
        return -1;


}

//-----------------------------------------------------------------------
//
// Get the hash from a cert file
//
//--------------------------------------------------------------------------
HRESULT GetCertHashFromFile(LPWSTR  pwszCertFile,
                            BYTE    **ppHash,
                            DWORD   *pcbHash,
                            BOOL    *pfMore)
{
    HRESULT         hr=S_OK;
    HCERTSTORE      hCertStore=NULL;
    PCCERT_CONTEXT  pSigningCert=NULL;
    PCCERT_CONTEXT  pPreCert=NULL;
    PCCERT_CONTEXT  pDupCert=NULL;
    DWORD           dwCount=0;

    if(!ppHash || !pcbHash || !pfMore)
        return E_INVALIDARG;

    //init
    *pcbHash=0;
    *ppHash=NULL;
    *pfMore=FALSE;

    //open a cert store
    hCertStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
                        dwStoreEncodingType,
                        NULL,
                        0,
                        pwszCertFile);

    if(hCertStore==NULL)
    {
        hr=SignError();
        goto CLEANUP;
    }

    while(pDupCert=CertEnumCertificatesInStore(hCertStore,
                                        pPreCert))
    {
        dwCount++;

        if(dwCount > 1)
        {
            CertFreeCertificateContext(pDupCert);
            pDupCert=NULL;
            CertFreeCertificateContext(pSigningCert);
            pSigningCert=NULL;

            *pfMore=TRUE;
            hr=S_FALSE;
            goto CLEANUP;
        }

        pPreCert=pDupCert;

        pSigningCert=CertDuplicateCertificateContext(pDupCert);

    }

    if(pSigningCert==NULL)
    {
        hr=CRYPT_E_NO_DECRYPT_CERT;
        goto CLEANUP;
    }

    //get the hash
    if(!CertGetCertificateContextProperty(pSigningCert,
                        CERT_SHA1_HASH_PROP_ID,
                        NULL,
                        pcbHash))
    {
        hr=SignError();
        goto CLEANUP;
    }

    *ppHash=(BYTE *)ToolUtlAlloc(*pcbHash);
    if(!(*ppHash))
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    if(!CertGetCertificateContextProperty(pSigningCert,
                        CERT_SHA1_HASH_PROP_ID,
                        *ppHash,
                        pcbHash))
    {
        hr=SignError();
        goto CLEANUP;
    }

CLEANUP:

    if(pSigningCert)
        CertFreeCertificateContext(pSigningCert);

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hr!=S_OK)
    {
        if(*ppHash)
        {
          ToolUtlFree(*ppHash);
          *ppHash=NULL;
        }

    }

    return hr;
}



//-----------------------------------------------------------------------
//
// Get the signing certificate
//
//--------------------------------------------------------------------------
PCCERT_CONTEXT  GetSigningCert(HCERTSTORE *phCertStore, BOOL *pfMore)
{
    PCCERT_CONTEXT  pSigningCert=NULL;
    PCCERT_CONTEXT  pPreCert=NULL;
    PCCERT_CONTEXT  pDupCert=NULL;
    BYTE            *pHash=NULL;
    DWORD           cbHash;
    HCERTSTORE      hCertStore=NULL;
    CRYPT_HASH_BLOB HashBlob;
    DWORD           dwCount=0;

    //init the output
    if(!phCertStore || !pfMore)
        return NULL;

    *phCertStore=NULL;
    *pfMore=FALSE;

    //open a cert store
    hCertStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                        dwStoreEncodingType,
                        NULL,
                        dwStoreFlag |CERT_STORE_READONLY_FLAG,
                        pwszStoreName);

    if(!hCertStore)
        return NULL;


    //get the hash of the certificate.  Find the cert based on
    //pwszCertFile
    if(pwszCertFile)
    {
        if(S_OK != GetCertHashFromFile(pwszCertFile, &pHash, &cbHash, pfMore))
            goto CLEANUP;

        HashBlob.cbData=cbHash;
        HashBlob.pbData=pHash;

        pSigningCert=CertFindCertificateInStore(hCertStore,
                            dwCertEncodingType,
                            0,
                            CERT_FIND_SHA1_HASH,
                            &HashBlob,
                            NULL);
    }
    else
    {
        //find the certificate with the common name
        if(pwszCommonName)
        {
            while(pDupCert=CertFindCertificateInStore(hCertStore,
                                dwCertEncodingType,
                                0,
                                CERT_FIND_SUBJECT_STR_W,
                                pwszCommonName,
                                pPreCert))
            {
                dwCount++;

                if(dwCount > 1)
                {
                    CertFreeCertificateContext(pDupCert);
                    pDupCert=NULL;
                    CertFreeCertificateContext(pSigningCert);
                    pSigningCert=NULL;

                    *pfMore=TRUE;
                    goto CLEANUP;
                }

                pPreCert=pDupCert;

                pSigningCert=CertDuplicateCertificateContext(pDupCert);

            }

        }
        else
        {
            //find the certificate based on the hash
            if(g_pbHash)
            {

                HashBlob.cbData=g_cbHash;
                HashBlob.pbData=g_pbHash;

                pSigningCert=CertFindCertificateInStore(hCertStore,
                                    dwCertEncodingType,
                                    0,
                                    CERT_FIND_SHA1_HASH,
                                    &HashBlob,
                                    NULL);
            }
            else
            {
                //no searching criteria, find the only cert in the store
                while(pDupCert=CertEnumCertificatesInStore(hCertStore,
                                            pPreCert))
                {
                    dwCount++;

                    if(dwCount > 1)
                    {
                        CertFreeCertificateContext(pDupCert);
                        pDupCert=NULL;
                        CertFreeCertificateContext(pSigningCert);
                        pSigningCert=NULL;

                        *pfMore=TRUE;
                        goto CLEANUP;
                    }

                    pPreCert=pDupCert;

                    pSigningCert=CertDuplicateCertificateContext(pDupCert);

                }

            }
        }
    }
CLEANUP:

    if(pHash)
        ToolUtlFree(pHash);

    if(pSigningCert)
    {
       *phCertStore=hCertStore;
    }
    else
    {
        //free the hCertStore
        CertCloseStore(hCertStore, 0);
    }

    return pSigningCert;

}

//-----------------------------------------------------------------------
//
// Set up the subject info
//
//--------------------------------------------------------------------------
HRESULT SetUpSubjectInfo(SIGNER_SUBJECT_INFO        *pSubjectInfo,
                         SIGNER_FILE_INFO           *pFileInfo)
{
    if(!pSubjectInfo || !pFileInfo)
        return E_INVALIDARG;

    //init
    memset(pSubjectInfo, 0, sizeof(SIGNER_SUBJECT_INFO));
    memset(pFileInfo, 0, sizeof(SIGNER_FILE_INFO));

    //init cbSize
    pSubjectInfo->cbSize=sizeof(SIGNER_SUBJECT_INFO);
    pFileInfo->cbSize=sizeof(SIGNER_FILE_INFO);

    //init pSubjectInfo
    pSubjectInfo->pdwIndex=&dwSignerIndex;
    pSubjectInfo->dwSubjectChoice=SIGNER_SUBJECT_FILE;
    pSubjectInfo->pSignerFileInfo=pFileInfo;
    pFileInfo->pwszFileName=pwszFile;

    return S_OK;
}


//-----------------------------------------------------------------------
//
// Set up the signing parameters
//
//--------------------------------------------------------------------------
HRESULT SetUpParameter(SIGNER_SUBJECT_INFO      *pSubjectInfo,
                       SIGNER_FILE_INFO         *pFileInfo,
                       SIGNER_SIGNATURE_INFO    *pSignatureInfo,
                        SIGNER_ATTR_AUTHCODE    *pAttrAuthcode,
                        SIGNER_PROVIDER_INFO    *pProviderInfo,
                        SIGNER_CERT_STORE_INFO  *pCertStoreInfo,
                        SIGNER_CERT             *pSignerCert,
                        CRYPT_ATTRIBUTES        *pAuthenticated,
                        CRYPT_ATTRIBUTES        *pUnauthenticated,
                        HCERTSTORE              *phCertStore
)
{
    HRESULT             hr;
    PCCERT_CONTEXT      pCertContext=NULL;
    BOOL                fMore=FALSE;


    if(S_OK!=(hr=SetUpSubjectInfo(pSubjectInfo, pFileInfo)))
        return hr;


    if(!pSignatureInfo || !pAttrAuthcode || !pProviderInfo ||
        !pCertStoreInfo || !pSignerCert)
        return E_INVALIDARG;

    //init
    memset(pSignatureInfo, 0, sizeof(SIGNER_SIGNATURE_INFO));
    memset(pAttrAuthcode, 0, sizeof(SIGNER_ATTR_AUTHCODE));
    memset(pProviderInfo, 0, sizeof(SIGNER_PROVIDER_INFO));
    memset(pCertStoreInfo, 0, sizeof(SIGNER_CERT_STORE_INFO));
    memset(pSignerCert, 0, sizeof(SIGNER_CERT));


    //init cbSize
    pSignatureInfo->cbSize=sizeof(SIGNER_SIGNATURE_INFO);
    pAttrAuthcode->cbSize=sizeof(SIGNER_ATTR_AUTHCODE);
    pProviderInfo->cbSize=sizeof(SIGNER_PROVIDER_INFO);
    pCertStoreInfo->cbSize=sizeof(SIGNER_CERT_STORE_INFO);
    pSignerCert->cbSize=sizeof(SIGNER_CERT);


    //init pAttrAuthcode
    pAttrAuthcode->fCommercial=fCommercial;
    pAttrAuthcode->fIndividual=fIndividual;
    pAttrAuthcode->pwszName=pwszOpusName;
    pAttrAuthcode->pwszInfo=pwszOpusInfo;

    //init pSignatureInfo
    pSignatureInfo->algidHash=dwAlgorithmOid;
    pSignatureInfo->dwAttrChoice=SIGNER_AUTHCODE_ATTR;
    pSignatureInfo->pAttrAuthcode=pAttrAuthcode;
    pSignatureInfo->psAuthenticated=pAuthenticated;
    pSignatureInfo->psUnauthenticated=pUnauthenticated;

    //init pProviderInfo only if we are using non-cerStore tech
    if(fStoreTechnology!=TRUE)
    {
        pProviderInfo->pwszProviderName=pwszCapiProvider;
        pProviderInfo->dwProviderType=dwProviderType;
        pProviderInfo->dwKeySpec=dwKeySpec;
        if(pwszPvkFile)
        {
            pProviderInfo->dwPvkChoice=PVK_TYPE_FILE_NAME;
            pProviderInfo->pwszPvkFileName=pwszPvkFile;
        }
        else
        {
            pProviderInfo->dwPvkChoice=PVK_TYPE_KEYCONTAINER;
            pProviderInfo->pwszKeyContainer=pwszKeyContainer;
        }
    }

    //init pSignerCert
    if(fStoreTechnology)
    {
        //get the signing cert context
        pCertContext=GetSigningCert(phCertStore,&fMore );
        if(!pCertContext)
        {
            if(fMore==FALSE)
                return CRYPT_E_NO_DECRYPT_CERT;
            else
                return CRYPT_E_DELETED_PREV;
        }

        pSignerCert->dwCertChoice=SIGNER_CERT_STORE;
        pSignerCert->pCertStoreInfo=pCertStoreInfo;
        //init pCertStoreInfo
        pCertStoreInfo->pSigningCert=pCertContext;
        pCertStoreInfo->dwCertPolicy=dwStorePolicy;


    }
    else
    {
        pSignerCert->dwCertChoice=SIGNER_CERT_SPC_FILE;
        pSignerCert->pwszSpcFile=pwszSpcFile;
    }

    return S_OK;

}



//-----------------------------------------------------------------------
//
//get the attributes from the dlls
//
//--------------------------------------------------------------------------
HRESULT InitDllParameter(PCRYPT_ATTRIBUTES pAuthAttr,
                         PCRYPT_ATTRIBUTES pUnauthAttr,
                         PCRYPT_ATTRIBUTES *ppAuthAttr,
                         PCRYPT_ATTRIBUTES *ppUnauthAttr)
{
    DWORD               dwIndex=0;
    DWORD               dwIndex2=0;
    DWORD               dwAttrIndex=0;
    HRESULT             hr=E_FAIL;
    HINSTANCE           hAuthInst=NULL;
    LPSTR               pszName=NULL;
    FARPROC             pProc=NULL;
    PCRYPT_ATTRIBUTES   pDllAuthAttr=NULL;
    PCRYPT_ATTRIBUTES   pDllUnauthAttr=NULL;
    DWORD               dwAuthAttrSum=0;
    DWORD               dwUnauthAttrSum=0;

    if(dwDllIndex==0)
        return S_OK;


    if(!ppAuthAttr || !ppUnauthAttr ||!pAuthAttr || !pUnauthAttr)
        return E_INVALIDARG;


    //process each dll
    for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
    {
        //get the char version of the dll name
        if((prgwszDllName[dwIndex] == NULL) ||
           (S_OK!=(hr=WSZtoSZ(prgwszDllName[dwIndex], &pszName))))
            goto CLEANUP;

        //load the libriary
        hAuthInst=LoadLibrary(pszName);

        if(!hAuthInst)
        {
            hr=SignError();
            goto CLEANUP;
        }

        //init
        if(!(pProc=GetProcAddress(hAuthInst, "InitAttr")))
        {
            hr=SignError();
            goto CLEANUP;
        }

        if(S_OK!=(hr=((pInitAttr)pProc)(prgwszDllParam[dwIndex])))
            goto CLEANUP;

        //get the attributes for either GetAttr or GetAttrEx
        if(!(pProc=GetProcAddress(hAuthInst, "GetAttrEx")))
        {
            if(!(pProc=GetProcAddress(hAuthInst, "GetAttr")))
            {
                hr=SignError();
                goto CLEANUP;
            }

            if(S_OK!=(hr=((pGetAttr)pProc)(&pDllAuthAttr, &pDllUnauthAttr)))
                goto CLEANUP;

        }
        else
        {
            if(S_OK!=(hr=((pGetAttrEx)pProc)(0,
                                             pwszFile,
                                             prgwszDllParam[dwIndex],
                                             &pDllAuthAttr,
                                             &pDllUnauthAttr)))
                goto CLEANUP;
        }


        //make sure valid return
        if(!pDllAuthAttr || !pDllUnauthAttr)
        {
            hr=E_UNEXPECTED;
            goto CLEANUP;
        }

        //add the sum pf authenticated
        if(pDllAuthAttr->cAttr)
            dwAuthAttrSum+=pDllAuthAttr->cAttr;

        ppAuthAttr[dwIndex]=pDllAuthAttr;


        //add the sume of unauthenticated
        if(pDllUnauthAttr->cAttr)
            dwUnauthAttrSum+=pDllUnauthAttr->cAttr;

        ppUnauthAttr[dwIndex]=pDllUnauthAttr;

        //exit
        if(!(pProc=GetProcAddress(hAuthInst, "ExitAttr")))
        {
            hr=SignError();
            goto CLEANUP;
        }

        if(S_OK!=(hr=((pExitAttr)pProc)()))
            goto CLEANUP;

        //free library
        FreeLibrary(hAuthInst);
        hAuthInst=NULL;

        //free memory
        ToolUtlFree(pszName);
        pszName=NULL;
    }


    //build up authenticated attribute
    if(dwAuthAttrSum)
    {
        pAuthAttr->cAttr=dwAuthAttrSum;
        pAuthAttr->rgAttr=(PCRYPT_ATTRIBUTE)ToolUtlAlloc(sizeof(CRYPT_ATTRIBUTE)*
                                    pAuthAttr->cAttr);

        if(!(pAuthAttr->rgAttr) )
        {
            hr=E_OUTOFMEMORY;
            goto CLEANUP;
        }

        //build up autheticated attributes
        dwAttrIndex=0;
        for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
        {
            for(dwIndex2=0;dwIndex2<ppAuthAttr[dwIndex]->cAttr; dwIndex2++)
            {
                pAuthAttr->rgAttr[dwAttrIndex]= ppAuthAttr[dwIndex]->rgAttr[dwIndex2];
                dwAttrIndex++;
            }

        }

        //make sure dwAttrIndex==pAuthAttr->cAttr
        if(dwAttrIndex!=pAuthAttr->cAttr)
        {
            hr=E_UNEXPECTED;
            goto CLEANUP;
        }
    }
    else
    {
        memset(pAuthAttr, 0, sizeof(CRYPT_ATTRIBUTES));
    }


    //build up unauthenticated attribute
    if(dwUnauthAttrSum)
    {

        pUnauthAttr->cAttr=dwUnauthAttrSum;

        pUnauthAttr->rgAttr=(PCRYPT_ATTRIBUTE)ToolUtlAlloc(sizeof(CRYPT_ATTRIBUTE)*
                                    pUnauthAttr->cAttr);

        if(!(pUnauthAttr->rgAttr))
        {
            hr=E_OUTOFMEMORY;
            goto CLEANUP;
        }



        //build up the unauthenticated attributes
        dwAttrIndex=0;
        for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
        {
            for(dwIndex2=0; dwIndex2<ppUnauthAttr[dwIndex]->cAttr; dwIndex2++)
            {
                pUnauthAttr->rgAttr[dwAttrIndex]=ppUnauthAttr[dwIndex]->rgAttr[dwIndex2];
                dwAttrIndex++;
            }
        }

        if(dwAttrIndex != pUnauthAttr->cAttr)
        {
            hr=E_UNEXPECTED;
            goto CLEANUP;
        }
    }
    else
    {
        memset(pUnauthAttr, 0, sizeof(CRYPT_ATTRIBUTES));
    }

    hr=S_OK;

CLEANUP:

    if(hAuthInst)
        FreeLibrary(hAuthInst);

    if(pszName)
        ToolUtlFree(pszName);

    //free up memory when hr!=S_OK
    if(hr!=S_OK)
    {
        if(pAuthAttr->rgAttr)
        {
            ToolUtlFree(pAuthAttr->rgAttr);
            pAuthAttr->rgAttr=NULL;
        }

        if(pUnauthAttr->rgAttr)
        {
            ToolUtlFree(pUnauthAttr->rgAttr);
            pUnauthAttr->rgAttr=NULL;

        }
    }

    return hr;

}

//-----------------------------------------------------------------------
//
// Release the attributes by calling the dlls's ReleaseAttr entry point
//
//--------------------------------------------------------------------------
void    ReleaseDllParameter(PCRYPT_ATTRIBUTES * ppAuthAttr,
                            PCRYPT_ATTRIBUTES * ppUnauthAttr)
{
    DWORD               dwIndex=0;
    HRESULT             hr=E_FAIL;
    HINSTANCE           hAuthInst=NULL;
    LPSTR               pszName=NULL;
    FARPROC             pProc=NULL;

    if((dwDllIndex==0) ||(!ppAuthAttr) || (!ppUnauthAttr))
        return;


    //process each dll
    for(dwIndex=0; dwIndex<dwDllIndex; dwIndex++)
    {
        //free library
        if(hAuthInst)
        {
            FreeLibrary(hAuthInst);
            hAuthInst=NULL;
        }

        //free memory
        if(pszName)
        {
            ToolUtlFree(pszName);
            pszName=NULL;
        }


        //get the char version of the dll name
        if((prgwszDllName[dwIndex]==NULL) ||
           (S_OK!=(hr=WSZtoSZ(prgwszDllName[dwIndex], &pszName))))
            continue;

        //load the libriary
        hAuthInst=LoadLibrary(pszName);

        if(!hAuthInst)
            continue;

        //init
        if(!(pProc=GetProcAddress(hAuthInst, "InitAttr")))
            continue;

        if(S_OK!=(hr=((pInitAttr)pProc)(prgwszDllParam[dwIndex])))
            continue;

        //release the attributes
        if(!(pProc=GetProcAddress(hAuthInst, "ReleaseAttr")))
            continue;

        if(S_OK!=(hr=((pReleaseAttr)pProc)(
            ppAuthAttr[dwIndex], ppUnauthAttr[dwIndex])))
            continue;

        //exit
        if(!(pProc=GetProcAddress(hAuthInst, "ExitAttr")))
            continue;

        ((pExitAttr)pProc)();
    }


    //cleanup
    if(hAuthInst)
    {
        FreeLibrary(hAuthInst);
        hAuthInst=NULL;
    }

    //free memory
    if(pszName)
    {
        ToolUtlFree(pszName);
        pszName=NULL;
    }

     return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signtool\capicom.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0359 */
/* Compiler settings for capicom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data
    VC __declspec() decoration level:
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __capicom_h__
#define __capicom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */

#ifndef __Settings_FWD_DEFINED__
#define __Settings_FWD_DEFINED__

#ifdef __cplusplus
typedef class Settings Settings;
#else
typedef struct Settings Settings;
#endif /* __cplusplus */

#endif  /* __Settings_FWD_DEFINED__ */


#ifndef __EKU_FWD_DEFINED__
#define __EKU_FWD_DEFINED__

#ifdef __cplusplus
typedef class EKU EKU;
#else
typedef struct EKU EKU;
#endif /* __cplusplus */

#endif  /* __EKU_FWD_DEFINED__ */


#ifndef __EKUs_FWD_DEFINED__
#define __EKUs_FWD_DEFINED__

#ifdef __cplusplus
typedef class EKUs EKUs;
#else
typedef struct EKUs EKUs;
#endif /* __cplusplus */

#endif  /* __EKUs_FWD_DEFINED__ */


#ifndef __KeyUsage_FWD_DEFINED__
#define __KeyUsage_FWD_DEFINED__

#ifdef __cplusplus
typedef class KeyUsage KeyUsage;
#else
typedef struct KeyUsage KeyUsage;
#endif /* __cplusplus */

#endif  /* __KeyUsage_FWD_DEFINED__ */


#ifndef __ExtendedKeyUsage_FWD_DEFINED__
#define __ExtendedKeyUsage_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExtendedKeyUsage ExtendedKeyUsage;
#else
typedef struct ExtendedKeyUsage ExtendedKeyUsage;
#endif /* __cplusplus */

#endif  /* __ExtendedKeyUsage_FWD_DEFINED__ */


#ifndef __BasicConstraints_FWD_DEFINED__
#define __BasicConstraints_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicConstraints BasicConstraints;
#else
typedef struct BasicConstraints BasicConstraints;
#endif /* __cplusplus */

#endif  /* __BasicConstraints_FWD_DEFINED__ */


#ifndef __CertificateStatus_FWD_DEFINED__
#define __CertificateStatus_FWD_DEFINED__

#ifdef __cplusplus
typedef class CertificateStatus CertificateStatus;
#else
typedef struct CertificateStatus CertificateStatus;
#endif /* __cplusplus */

#endif  /* __CertificateStatus_FWD_DEFINED__ */


#ifndef __Certificate_FWD_DEFINED__
#define __Certificate_FWD_DEFINED__

#ifdef __cplusplus
typedef class Certificate Certificate;
#else
typedef struct Certificate Certificate;
#endif /* __cplusplus */

#endif  /* __Certificate_FWD_DEFINED__ */


#ifndef __Certificates_FWD_DEFINED__
#define __Certificates_FWD_DEFINED__

#ifdef __cplusplus
typedef class Certificates Certificates;
#else
typedef struct Certificates Certificates;
#endif /* __cplusplus */

#endif  /* __Certificates_FWD_DEFINED__ */


#ifndef __Chain_FWD_DEFINED__
#define __Chain_FWD_DEFINED__

#ifdef __cplusplus
typedef class Chain Chain;
#else
typedef struct Chain Chain;
#endif /* __cplusplus */

#endif  /* __Chain_FWD_DEFINED__ */


#ifndef __Store_FWD_DEFINED__
#define __Store_FWD_DEFINED__

#ifdef __cplusplus
typedef class Store Store;
#else
typedef struct Store Store;
#endif /* __cplusplus */

#endif  /* __Store_FWD_DEFINED__ */


#ifndef __Attribute_FWD_DEFINED__
#define __Attribute_FWD_DEFINED__

#ifdef __cplusplus
typedef class Attribute Attribute;
#else
typedef struct Attribute Attribute;
#endif /* __cplusplus */

#endif  /* __Attribute_FWD_DEFINED__ */


#ifndef __Attributes_FWD_DEFINED__
#define __Attributes_FWD_DEFINED__

#ifdef __cplusplus
typedef class Attributes Attributes;
#else
typedef struct Attributes Attributes;
#endif /* __cplusplus */

#endif  /* __Attributes_FWD_DEFINED__ */


#ifndef __Signer_FWD_DEFINED__
#define __Signer_FWD_DEFINED__

#ifdef __cplusplus
typedef class Signer Signer;
#else
typedef struct Signer Signer;
#endif /* __cplusplus */

#endif  /* __Signer_FWD_DEFINED__ */


#ifndef __Signers_FWD_DEFINED__
#define __Signers_FWD_DEFINED__

#ifdef __cplusplus
typedef class Signers Signers;
#else
typedef struct Signers Signers;
#endif /* __cplusplus */

#endif  /* __Signers_FWD_DEFINED__ */


#ifndef __SignedData_FWD_DEFINED__
#define __SignedData_FWD_DEFINED__

#ifdef __cplusplus
typedef class SignedData SignedData;
#else
typedef struct SignedData SignedData;
#endif /* __cplusplus */

#endif  /* __SignedData_FWD_DEFINED__ */


#ifndef __Algorithm_FWD_DEFINED__
#define __Algorithm_FWD_DEFINED__

#ifdef __cplusplus
typedef class Algorithm Algorithm;
#else
typedef struct Algorithm Algorithm;
#endif /* __cplusplus */

#endif  /* __Algorithm_FWD_DEFINED__ */


#ifndef __Recipients_FWD_DEFINED__
#define __Recipients_FWD_DEFINED__

#ifdef __cplusplus
typedef class Recipients Recipients;
#else
typedef struct Recipients Recipients;
#endif /* __cplusplus */

#endif  /* __Recipients_FWD_DEFINED__ */


#ifndef __EnvelopedData_FWD_DEFINED__
#define __EnvelopedData_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnvelopedData EnvelopedData;
#else
typedef struct EnvelopedData EnvelopedData;
#endif /* __cplusplus */

#endif  /* __EnvelopedData_FWD_DEFINED__ */


#ifndef __EncryptedData_FWD_DEFINED__
#define __EncryptedData_FWD_DEFINED__

#ifdef __cplusplus
typedef class EncryptedData EncryptedData;
#else
typedef struct EncryptedData EncryptedData;
#endif /* __cplusplus */

#endif  /* __EncryptedData_FWD_DEFINED__ */


#ifndef __OID_FWD_DEFINED__
#define __OID_FWD_DEFINED__

#ifdef __cplusplus
typedef class OID OID;
#else
typedef struct OID OID;
#endif /* __cplusplus */

#endif  /* __OID_FWD_DEFINED__ */


#ifndef __OIDs_FWD_DEFINED__
#define __OIDs_FWD_DEFINED__

#ifdef __cplusplus
typedef class OIDs OIDs;
#else
typedef struct OIDs OIDs;
#endif /* __cplusplus */

#endif  /* __OIDs_FWD_DEFINED__ */


#ifndef __NoticeNumbers_FWD_DEFINED__
#define __NoticeNumbers_FWD_DEFINED__

#ifdef __cplusplus
typedef class NoticeNumbers NoticeNumbers;
#else
typedef struct NoticeNumbers NoticeNumbers;
#endif /* __cplusplus */

#endif  /* __NoticeNumbers_FWD_DEFINED__ */


#ifndef __Qualifier_FWD_DEFINED__
#define __Qualifier_FWD_DEFINED__

#ifdef __cplusplus
typedef class Qualifier Qualifier;
#else
typedef struct Qualifier Qualifier;
#endif /* __cplusplus */

#endif  /* __Qualifier_FWD_DEFINED__ */


#ifndef __Qualifiers_FWD_DEFINED__
#define __Qualifiers_FWD_DEFINED__

#ifdef __cplusplus
typedef class Qualifiers Qualifiers;
#else
typedef struct Qualifiers Qualifiers;
#endif /* __cplusplus */

#endif  /* __Qualifiers_FWD_DEFINED__ */


#ifndef __PolicyInformation_FWD_DEFINED__
#define __PolicyInformation_FWD_DEFINED__

#ifdef __cplusplus
typedef class PolicyInformation PolicyInformation;
#else
typedef struct PolicyInformation PolicyInformation;
#endif /* __cplusplus */

#endif  /* __PolicyInformation_FWD_DEFINED__ */


#ifndef __CertificatePolicies_FWD_DEFINED__
#define __CertificatePolicies_FWD_DEFINED__

#ifdef __cplusplus
typedef class CertificatePolicies CertificatePolicies;
#else
typedef struct CertificatePolicies CertificatePolicies;
#endif /* __cplusplus */

#endif  /* __CertificatePolicies_FWD_DEFINED__ */


#ifndef __EncodedData_FWD_DEFINED__
#define __EncodedData_FWD_DEFINED__

#ifdef __cplusplus
typedef class EncodedData EncodedData;
#else
typedef struct EncodedData EncodedData;
#endif /* __cplusplus */

#endif  /* __EncodedData_FWD_DEFINED__ */


#ifndef __Extension_FWD_DEFINED__
#define __Extension_FWD_DEFINED__

#ifdef __cplusplus
typedef class Extension Extension;
#else
typedef struct Extension Extension;
#endif /* __cplusplus */

#endif  /* __Extension_FWD_DEFINED__ */


#ifndef __Extensions_FWD_DEFINED__
#define __Extensions_FWD_DEFINED__

#ifdef __cplusplus
typedef class Extensions Extensions;
#else
typedef struct Extensions Extensions;
#endif /* __cplusplus */

#endif  /* __Extensions_FWD_DEFINED__ */


#ifndef __ExtendedProperty_FWD_DEFINED__
#define __ExtendedProperty_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExtendedProperty ExtendedProperty;
#else
typedef struct ExtendedProperty ExtendedProperty;
#endif /* __cplusplus */

#endif  /* __ExtendedProperty_FWD_DEFINED__ */


#ifndef __ExtendedProperties_FWD_DEFINED__
#define __ExtendedProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExtendedProperties ExtendedProperties;
#else
typedef struct ExtendedProperties ExtendedProperties;
#endif /* __cplusplus */

#endif  /* __ExtendedProperties_FWD_DEFINED__ */


#ifndef __Template_FWD_DEFINED__
#define __Template_FWD_DEFINED__

#ifdef __cplusplus
typedef class Template Template;
#else
typedef struct Template Template;
#endif /* __cplusplus */

#endif  /* __Template_FWD_DEFINED__ */


#ifndef __PublicKey_FWD_DEFINED__
#define __PublicKey_FWD_DEFINED__

#ifdef __cplusplus
typedef class PublicKey PublicKey;
#else
typedef struct PublicKey PublicKey;
#endif /* __cplusplus */

#endif  /* __PublicKey_FWD_DEFINED__ */


#ifndef __PrivateKey_FWD_DEFINED__
#define __PrivateKey_FWD_DEFINED__

#ifdef __cplusplus
typedef class PrivateKey PrivateKey;
#else
typedef struct PrivateKey PrivateKey;
#endif /* __cplusplus */

#endif  /* __PrivateKey_FWD_DEFINED__ */


#ifndef __SignedCode_FWD_DEFINED__
#define __SignedCode_FWD_DEFINED__

#ifdef __cplusplus
typedef class SignedCode SignedCode;
#else
typedef struct SignedCode SignedCode;
#endif /* __cplusplus */

#endif  /* __SignedCode_FWD_DEFINED__ */


#ifndef __HashedData_FWD_DEFINED__
#define __HashedData_FWD_DEFINED__

#ifdef __cplusplus
typedef class HashedData HashedData;
#else
typedef struct HashedData HashedData;
#endif /* __cplusplus */

#endif  /* __HashedData_FWD_DEFINED__ */


#ifndef __Utilities_FWD_DEFINED__
#define __Utilities_FWD_DEFINED__

#ifdef __cplusplus
typedef class Utilities Utilities;
#else
typedef struct Utilities Utilities;
#endif /* __cplusplus */

#endif  /* __Utilities_FWD_DEFINED__ */


#ifndef __ISettings_FWD_DEFINED__
#define __ISettings_FWD_DEFINED__
typedef interface ISettings ISettings;
#endif  /* __ISettings_FWD_DEFINED__ */


#ifndef __IEKU_FWD_DEFINED__
#define __IEKU_FWD_DEFINED__
typedef interface IEKU IEKU;
#endif  /* __IEKU_FWD_DEFINED__ */


#ifndef __IEKUs_FWD_DEFINED__
#define __IEKUs_FWD_DEFINED__
typedef interface IEKUs IEKUs;
#endif  /* __IEKUs_FWD_DEFINED__ */


#ifndef __IKeyUsage_FWD_DEFINED__
#define __IKeyUsage_FWD_DEFINED__
typedef interface IKeyUsage IKeyUsage;
#endif  /* __IKeyUsage_FWD_DEFINED__ */


#ifndef __IExtendedKeyUsage_FWD_DEFINED__
#define __IExtendedKeyUsage_FWD_DEFINED__
typedef interface IExtendedKeyUsage IExtendedKeyUsage;
#endif  /* __IExtendedKeyUsage_FWD_DEFINED__ */


#ifndef __IBasicConstraints_FWD_DEFINED__
#define __IBasicConstraints_FWD_DEFINED__
typedef interface IBasicConstraints IBasicConstraints;
#endif  /* __IBasicConstraints_FWD_DEFINED__ */


#ifndef __ICertificateStatus_FWD_DEFINED__
#define __ICertificateStatus_FWD_DEFINED__
typedef interface ICertificateStatus ICertificateStatus;
#endif  /* __ICertificateStatus_FWD_DEFINED__ */


#ifndef __ICertificate_FWD_DEFINED__
#define __ICertificate_FWD_DEFINED__
typedef interface ICertificate ICertificate;
#endif  /* __ICertificate_FWD_DEFINED__ */


#ifndef __ICertificates_FWD_DEFINED__
#define __ICertificates_FWD_DEFINED__
typedef interface ICertificates ICertificates;
#endif  /* __ICertificates_FWD_DEFINED__ */


#ifndef __IChain_FWD_DEFINED__
#define __IChain_FWD_DEFINED__
typedef interface IChain IChain;
#endif  /* __IChain_FWD_DEFINED__ */


#ifndef __IStore_FWD_DEFINED__
#define __IStore_FWD_DEFINED__
typedef interface IStore IStore;
#endif  /* __IStore_FWD_DEFINED__ */


#ifndef __IAttribute_FWD_DEFINED__
#define __IAttribute_FWD_DEFINED__
typedef interface IAttribute IAttribute;
#endif  /* __IAttribute_FWD_DEFINED__ */


#ifndef __IAttributes_FWD_DEFINED__
#define __IAttributes_FWD_DEFINED__
typedef interface IAttributes IAttributes;
#endif  /* __IAttributes_FWD_DEFINED__ */


#ifndef __ISigner_FWD_DEFINED__
#define __ISigner_FWD_DEFINED__
typedef interface ISigner ISigner;
#endif  /* __ISigner_FWD_DEFINED__ */


#ifndef __ISigners_FWD_DEFINED__
#define __ISigners_FWD_DEFINED__
typedef interface ISigners ISigners;
#endif  /* __ISigners_FWD_DEFINED__ */


#ifndef __ISignedData_FWD_DEFINED__
#define __ISignedData_FWD_DEFINED__
typedef interface ISignedData ISignedData;
#endif  /* __ISignedData_FWD_DEFINED__ */


#ifndef __IAlgorithm_FWD_DEFINED__
#define __IAlgorithm_FWD_DEFINED__
typedef interface IAlgorithm IAlgorithm;
#endif  /* __IAlgorithm_FWD_DEFINED__ */


#ifndef __IRecipients_FWD_DEFINED__
#define __IRecipients_FWD_DEFINED__
typedef interface IRecipients IRecipients;
#endif  /* __IRecipients_FWD_DEFINED__ */


#ifndef __IEnvelopedData_FWD_DEFINED__
#define __IEnvelopedData_FWD_DEFINED__
typedef interface IEnvelopedData IEnvelopedData;
#endif  /* __IEnvelopedData_FWD_DEFINED__ */


#ifndef __IEncryptedData_FWD_DEFINED__
#define __IEncryptedData_FWD_DEFINED__
typedef interface IEncryptedData IEncryptedData;
#endif  /* __IEncryptedData_FWD_DEFINED__ */


#ifndef __IOID_FWD_DEFINED__
#define __IOID_FWD_DEFINED__
typedef interface IOID IOID;
#endif  /* __IOID_FWD_DEFINED__ */


#ifndef __IOIDs_FWD_DEFINED__
#define __IOIDs_FWD_DEFINED__
typedef interface IOIDs IOIDs;
#endif  /* __IOIDs_FWD_DEFINED__ */


#ifndef __INoticeNumbers_FWD_DEFINED__
#define __INoticeNumbers_FWD_DEFINED__
typedef interface INoticeNumbers INoticeNumbers;
#endif  /* __INoticeNumbers_FWD_DEFINED__ */


#ifndef __IQualifier_FWD_DEFINED__
#define __IQualifier_FWD_DEFINED__
typedef interface IQualifier IQualifier;
#endif  /* __IQualifier_FWD_DEFINED__ */


#ifndef __IQualifiers_FWD_DEFINED__
#define __IQualifiers_FWD_DEFINED__
typedef interface IQualifiers IQualifiers;
#endif  /* __IQualifiers_FWD_DEFINED__ */


#ifndef __IPolicyInformation_FWD_DEFINED__
#define __IPolicyInformation_FWD_DEFINED__
typedef interface IPolicyInformation IPolicyInformation;
#endif  /* __IPolicyInformation_FWD_DEFINED__ */


#ifndef __ICertificatePolicies_FWD_DEFINED__
#define __ICertificatePolicies_FWD_DEFINED__
typedef interface ICertificatePolicies ICertificatePolicies;
#endif  /* __ICertificatePolicies_FWD_DEFINED__ */


#ifndef __IEncodedData_FWD_DEFINED__
#define __IEncodedData_FWD_DEFINED__
typedef interface IEncodedData IEncodedData;
#endif  /* __IEncodedData_FWD_DEFINED__ */


#ifndef __IExtension_FWD_DEFINED__
#define __IExtension_FWD_DEFINED__
typedef interface IExtension IExtension;
#endif  /* __IExtension_FWD_DEFINED__ */


#ifndef __IExtensions_FWD_DEFINED__
#define __IExtensions_FWD_DEFINED__
typedef interface IExtensions IExtensions;
#endif  /* __IExtensions_FWD_DEFINED__ */


#ifndef __IExtendedProperty_FWD_DEFINED__
#define __IExtendedProperty_FWD_DEFINED__
typedef interface IExtendedProperty IExtendedProperty;
#endif  /* __IExtendedProperty_FWD_DEFINED__ */


#ifndef __IExtendedProperties_FWD_DEFINED__
#define __IExtendedProperties_FWD_DEFINED__
typedef interface IExtendedProperties IExtendedProperties;
#endif  /* __IExtendedProperties_FWD_DEFINED__ */


#ifndef __ITemplate_FWD_DEFINED__
#define __ITemplate_FWD_DEFINED__
typedef interface ITemplate ITemplate;
#endif  /* __ITemplate_FWD_DEFINED__ */


#ifndef __IPublicKey_FWD_DEFINED__
#define __IPublicKey_FWD_DEFINED__
typedef interface IPublicKey IPublicKey;
#endif  /* __IPublicKey_FWD_DEFINED__ */


#ifndef __IPrivateKey_FWD_DEFINED__
#define __IPrivateKey_FWD_DEFINED__
typedef interface IPrivateKey IPrivateKey;
#endif  /* __IPrivateKey_FWD_DEFINED__ */


#ifndef __ICertificateStatus2_FWD_DEFINED__
#define __ICertificateStatus2_FWD_DEFINED__
typedef interface ICertificateStatus2 ICertificateStatus2;
#endif  /* __ICertificateStatus2_FWD_DEFINED__ */


#ifndef __ICertificate2_FWD_DEFINED__
#define __ICertificate2_FWD_DEFINED__
typedef interface ICertificate2 ICertificate2;
#endif  /* __ICertificate2_FWD_DEFINED__ */


#ifndef __ICertificates2_FWD_DEFINED__
#define __ICertificates2_FWD_DEFINED__
typedef interface ICertificates2 ICertificates2;
#endif  /* __ICertificates2_FWD_DEFINED__ */


#ifndef __IChain2_FWD_DEFINED__
#define __IChain2_FWD_DEFINED__
typedef interface IChain2 IChain2;
#endif  /* __IChain2_FWD_DEFINED__ */


#ifndef __IStore2_FWD_DEFINED__
#define __IStore2_FWD_DEFINED__
typedef interface IStore2 IStore2;
#endif  /* __IStore2_FWD_DEFINED__ */


#ifndef __ISigner2_FWD_DEFINED__
#define __ISigner2_FWD_DEFINED__
typedef interface ISigner2 ISigner2;
#endif  /* __ISigner2_FWD_DEFINED__ */


#ifndef __ISignedCode_FWD_DEFINED__
#define __ISignedCode_FWD_DEFINED__
typedef interface ISignedCode ISignedCode;
#endif  /* __ISignedCode_FWD_DEFINED__ */


#ifndef __IHashedData_FWD_DEFINED__
#define __IHashedData_FWD_DEFINED__
typedef interface IHashedData IHashedData;
#endif  /* __IHashedData_FWD_DEFINED__ */


#ifndef __IUtilities_FWD_DEFINED__
#define __IUtilities_FWD_DEFINED__
typedef interface IUtilities IUtilities;
#endif  /* __IUtilities_FWD_DEFINED__ */


#ifndef __ICertContext_FWD_DEFINED__
#define __ICertContext_FWD_DEFINED__
typedef interface ICertContext ICertContext;
#endif  /* __ICertContext_FWD_DEFINED__ */


#ifndef __IChainContext_FWD_DEFINED__
#define __IChainContext_FWD_DEFINED__
typedef interface IChainContext IChainContext;
#endif  /* __IChainContext_FWD_DEFINED__ */


#ifndef __ICertStore_FWD_DEFINED__
#define __ICertStore_FWD_DEFINED__
typedef interface ICertStore ICertStore;
#endif  /* __ICertStore_FWD_DEFINED__ */


#ifndef __ICSigner_FWD_DEFINED__
#define __ICSigner_FWD_DEFINED__
typedef interface ICSigner ICSigner;
#endif  /* __ICSigner_FWD_DEFINED__ */


#ifndef __ICCertificates_FWD_DEFINED__
#define __ICCertificates_FWD_DEFINED__
typedef interface ICCertificates ICCertificates;
#endif  /* __ICCertificates_FWD_DEFINED__ */


#ifndef __ICPrivateKey_FWD_DEFINED__
#define __ICPrivateKey_FWD_DEFINED__
typedef interface ICPrivateKey ICPrivateKey;
#endif  /* __ICPrivateKey_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wincrypt.h"

#ifdef __cplusplus
extern "C"{
#endif

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * );


#ifndef __CAPICOM_LIBRARY_DEFINED__
#define __CAPICOM_LIBRARY_DEFINED__

/* library CAPICOM */
/* [helpstring][version][uuid] */

typedef
enum CAPICOM_ERROR_CODE
    {   CAPICOM_E_ENCODE_INVALID_TYPE   = 0x80880100,
    CAPICOM_E_EKU_INVALID_OID   = 0x80880200,
    CAPICOM_E_EKU_OID_NOT_INITIALIZED   = 0x80880201,
    CAPICOM_E_CERTIFICATE_NOT_INITIALIZED   = 0x80880210,
    CAPICOM_E_CERTIFICATE_NO_PRIVATE_KEY    = 0x80880211,
    CAPICOM_E_CHAIN_NOT_BUILT   = 0x80880220,
    CAPICOM_E_STORE_NOT_OPENED  = 0x80880230,
    CAPICOM_E_STORE_EMPTY   = 0x80880231,
    CAPICOM_E_STORE_INVALID_OPEN_MODE   = 0x80880232,
    CAPICOM_E_STORE_INVALID_SAVE_AS_TYPE    = 0x80880233,
    CAPICOM_E_ATTRIBUTE_NAME_NOT_INITIALIZED    = 0x80880240,
    CAPICOM_E_ATTRIBUTE_VALUE_NOT_INITIALIZED   = 0x80880241,
    CAPICOM_E_ATTRIBUTE_INVALID_NAME    = 0x80880242,
    CAPICOM_E_ATTRIBUTE_INVALID_VALUE   = 0x80880243,
    CAPICOM_E_SIGNER_NOT_INITIALIZED    = 0x80880250,
    CAPICOM_E_SIGNER_NOT_FOUND  = 0x80880251,
    CAPICOM_E_SIGNER_NO_CHAIN   = 0x80880252,
    CAPICOM_E_SIGNER_INVALID_USAGE  = 0x80880253,
    CAPICOM_E_SIGN_NOT_INITIALIZED  = 0x80880260,
    CAPICOM_E_SIGN_INVALID_TYPE = 0x80880261,
    CAPICOM_E_SIGN_NOT_SIGNED   = 0x80880262,
    CAPICOM_E_INVALID_ALGORITHM = 0x80880270,
    CAPICOM_E_INVALID_KEY_LENGTH    = 0x80880271,
    CAPICOM_E_ENVELOP_NOT_INITIALIZED   = 0x80880280,
    CAPICOM_E_ENVELOP_INVALID_TYPE  = 0x80880281,
    CAPICOM_E_ENVELOP_NO_RECIPIENT  = 0x80880282,
    CAPICOM_E_ENVELOP_RECIPIENT_NOT_FOUND   = 0x80880283,
    CAPICOM_E_ENCRYPT_NOT_INITIALIZED   = 0x80880290,
    CAPICOM_E_ENCRYPT_INVALID_TYPE  = 0x80880291,
    CAPICOM_E_ENCRYPT_NO_SECRET = 0x80880292,
    CAPICOM_E_NOT_SUPPORTED = 0x80880900,
    CAPICOM_E_UI_DISABLED   = 0x80880901,
    CAPICOM_E_CANCELLED = 0x80880902,
    CAPICOM_E_NOT_ALLOWED   = 0x80880903,
    CAPICOM_E_OUT_OF_RESOURCE   = 0x80880904,
    CAPICOM_E_INTERNAL  = 0x80880911,
    CAPICOM_E_UNKNOWN   = 0x80880999,
    CAPICOM_E_PRIVATE_KEY_NOT_INITIALIZED   = 0x80880300,
    CAPICOM_E_PRIVATE_KEY_NOT_EXPORTABLE    = 0x80880301,
    CAPICOM_E_ENCODE_NOT_INITIALIZED    = 0x80880320,
    CAPICOM_E_EXTENSION_NOT_INITIALIZED = 0x80880330,
    CAPICOM_E_PROPERTY_NOT_INITIALIZED  = 0x80880340,
    CAPICOM_E_FIND_INVALID_TYPE = 0x80880350,
    CAPICOM_E_FIND_INVALID_PREDEFINED_POLICY    = 0x80880351,
    CAPICOM_E_CODE_NOT_INITIALIZED  = 0x80880360,
    CAPICOM_E_CODE_NOT_SIGNED   = 0x80880361,
    CAPICOM_E_CODE_DESCRIPTION_NOT_INITIALIZED  = 0x80880362,
    CAPICOM_E_CODE_DESCRIPTION_URL_NOT_INITIALIZED  = 0x80880363,
    CAPICOM_E_CODE_INVALID_TIMESTAMP_URL    = 0x80880364,
    CAPICOM_E_HASH_NO_DATA  = 0x80880370,
    CAPICOM_E_INVALID_CONVERT_TYPE  = 0x80880380
    }   CAPICOM_ERROR_CODE;

typedef
enum CAPICOM_ENCODING_TYPE
    {   CAPICOM_ENCODE_BASE64   = 0,
    CAPICOM_ENCODE_BINARY   = 1,
    CAPICOM_ENCODE_ANY  = 0xffffffff
    }   CAPICOM_ENCODING_TYPE;

typedef
enum CAPICOM_EKU
    {   CAPICOM_EKU_OTHER   = 0,
    CAPICOM_EKU_SERVER_AUTH = 1,
    CAPICOM_EKU_CLIENT_AUTH = 2,
    CAPICOM_EKU_CODE_SIGNING    = 3,
    CAPICOM_EKU_EMAIL_PROTECTION    = 4,
    CAPICOM_EKU_SMARTCARD_LOGON = 5,
    CAPICOM_EKU_ENCRYPTING_FILE_SYSTEM  = 6
    }   CAPICOM_EKU;

typedef
enum CAPICOM_CHECK_FLAG
    {   CAPICOM_CHECK_NONE  = 0,
    CAPICOM_CHECK_TRUSTED_ROOT  = 0x1,
    CAPICOM_CHECK_TIME_VALIDITY = 0x2,
    CAPICOM_CHECK_SIGNATURE_VALIDITY    = 0x4,
    CAPICOM_CHECK_ONLINE_REVOCATION_STATUS  = 0x8,
    CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS = 0x10,
    CAPICOM_CHECK_COMPLETE_CHAIN    = 0x20,
    CAPICOM_CHECK_NAME_CONSTRAINTS  = 0x40,
    CAPICOM_CHECK_BASIC_CONSTRAINTS = 0x80,
    CAPICOM_CHECK_NESTED_VALIDITY_PERIOD    = 0x100,
    CAPICOM_CHECK_ONLINE_ALL    = 0x1ef,
    CAPICOM_CHECK_OFFLINE_ALL   = 0x1f7
    }   CAPICOM_CHECK_FLAG;

#define CAPICOM_CHECK_FLAG_LO_MASK                     0x0000ffff
#define CAPICOM_CHECK_FLAG_HI_MASK                     0xffff0000
#define CAPICOM_CHECK_APPLICATION_USAGE                0x00010000
#define CAPICOM_CHECK_CERTIFICATE_POLICY               0x00020000
#define CAPICOM_CHECK_REVOCATION_END_CERT_ONLY         0x00040000
#define CAPICOM_CHECK_REVOCATION_ENTIRE_CHAIN          0x00080000
typedef
enum CAPICOM_CERT_INFO_TYPE
    {   CAPICOM_CERT_INFO_SUBJECT_SIMPLE_NAME   = 0,
    CAPICOM_CERT_INFO_ISSUER_SIMPLE_NAME    = 1,
    CAPICOM_CERT_INFO_SUBJECT_EMAIL_NAME    = 2,
    CAPICOM_CERT_INFO_ISSUER_EMAIL_NAME = 3,
    CAPICOM_CERT_INFO_SUBJECT_UPN   = 4,
    CAPICOM_CERT_INFO_ISSUER_UPN    = 5,
    CAPICOM_CERT_INFO_SUBJECT_DNS_NAME  = 6,
    CAPICOM_CERT_INFO_ISSUER_DNS_NAME   = 7
    }   CAPICOM_CERT_INFO_TYPE;

typedef
enum CAPICOM_STORE_LOCATION
    {   CAPICOM_MEMORY_STORE    = 0,
    CAPICOM_LOCAL_MACHINE_STORE = 1,
    CAPICOM_CURRENT_USER_STORE  = 2,
    CAPICOM_ACTIVE_DIRECTORY_USER_STORE = 3,
    CAPICOM_SMART_CARD_USER_STORE   = 4
    }   CAPICOM_STORE_LOCATION;

typedef
enum CAPICOM_STORE_OPEN_MODE
    {   CAPICOM_STORE_OPEN_READ_ONLY    = 0,
    CAPICOM_STORE_OPEN_READ_WRITE   = 1,
    CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED  = 2,
    CAPICOM_STORE_OPEN_EXISTING_ONLY    = 128,
    CAPICOM_STORE_OPEN_INCLUDE_ARCHIVED = 256
    }   CAPICOM_STORE_OPEN_MODE;

typedef
enum CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION
    {   CAPICOM_SEARCH_ANY  = 0,
    CAPICOM_SEARCH_GLOBAL_CATALOG   = 1,
    CAPICOM_SEARCH_DEFAULT_DOMAIN   = 2
    }   CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION;

typedef
enum CAPICOM_STORE_SAVE_AS_TYPE
    {   CAPICOM_STORE_SAVE_AS_SERIALIZED    = 0,
    CAPICOM_STORE_SAVE_AS_PKCS7 = 1
    }   CAPICOM_STORE_SAVE_AS_TYPE;

typedef
enum CAPICOM_ATTRIBUTE
    {   CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME    = 0,
    CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_NAME   = 1,
    CAPICOM_AUTHENTICATED_ATTRIBUTE_DOCUMENT_DESCRIPTION    = 2
    }   CAPICOM_ATTRIBUTE;

typedef
enum CAPICOM_SIGNED_DATA_VERIFY_FLAG
    {   CAPICOM_VERIFY_SIGNATURE_ONLY   = 0,
    CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE    = 1
    }   CAPICOM_SIGNED_DATA_VERIFY_FLAG;

typedef
enum CAPICOM_ENCRYPTION_ALGORITHM
    {   CAPICOM_ENCRYPTION_ALGORITHM_RC2    = 0,
    CAPICOM_ENCRYPTION_ALGORITHM_RC4    = 1,
    CAPICOM_ENCRYPTION_ALGORITHM_DES    = 2,
    CAPICOM_ENCRYPTION_ALGORITHM_3DES   = 3,
    CAPICOM_ENCRYPTION_ALGORITHM_AES    = 4
    }   CAPICOM_ENCRYPTION_ALGORITHM;

typedef
enum CAPICOM_ENCRYPTION_KEY_LENGTH
    {   CAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM   = 0,
    CAPICOM_ENCRYPTION_KEY_LENGTH_40_BITS   = 1,
    CAPICOM_ENCRYPTION_KEY_LENGTH_56_BITS   = 2,
    CAPICOM_ENCRYPTION_KEY_LENGTH_128_BITS  = 3,
    CAPICOM_ENCRYPTION_KEY_LENGTH_192_BITS  = 4,
    CAPICOM_ENCRYPTION_KEY_LENGTH_256_BITS  = 5
    }   CAPICOM_ENCRYPTION_KEY_LENGTH;

typedef
enum CAPICOM_SECRET_TYPE
    {   CAPICOM_SECRET_PASSWORD = 0
    }   CAPICOM_SECRET_TYPE;

typedef
enum CAPICOM_KEY_ALGORITHM
    {   CAPICOM_KEY_ALGORITHM_OTHER = 0,
    CAPICOM_KEY_ALGORITHM_RSA   = 1,
    CAPICOM_KEY_ALGORITHM_DSS   = 2
    }   CAPICOM_KEY_ALGORITHM;

typedef
enum CAPICOM_OID
    {   CAPICOM_OID_OTHER   = 0,
    CAPICOM_OID_AUTHORITY_KEY_IDENTIFIER_EXTENSION  = 1,
    CAPICOM_OID_KEY_ATTRIBUTES_EXTENSION    = 2,
    CAPICOM_OID_CERT_POLICIES_95_EXTENSION  = 3,
    CAPICOM_OID_KEY_USAGE_RESTRICTION_EXTENSION = 4,
    CAPICOM_OID_LEGACY_POLICY_MAPPINGS_EXTENSION    = 5,
    CAPICOM_OID_SUBJECT_ALT_NAME_EXTENSION  = 6,
    CAPICOM_OID_ISSUER_ALT_NAME_EXTENSION   = 7,
    CAPICOM_OID_BASIC_CONSTRAINTS_EXTENSION = 8,
    CAPICOM_OID_SUBJECT_KEY_IDENTIFIER_EXTENSION    = 9,
    CAPICOM_OID_KEY_USAGE_EXTENSION = 10,
    CAPICOM_OID_PRIVATEKEY_USAGE_PERIOD_EXTENSION   = 11,
    CAPICOM_OID_SUBJECT_ALT_NAME2_EXTENSION = 12,
    CAPICOM_OID_ISSUER_ALT_NAME2_EXTENSION  = 13,
    CAPICOM_OID_BASIC_CONSTRAINTS2_EXTENSION    = 14,
    CAPICOM_OID_NAME_CONSTRAINTS_EXTENSION  = 15,
    CAPICOM_OID_CRL_DIST_POINTS_EXTENSION   = 16,
    CAPICOM_OID_CERT_POLICIES_EXTENSION = 17,
    CAPICOM_OID_POLICY_MAPPINGS_EXTENSION   = 18,
    CAPICOM_OID_AUTHORITY_KEY_IDENTIFIER2_EXTENSION = 19,
    CAPICOM_OID_POLICY_CONSTRAINTS_EXTENSION    = 20,
    CAPICOM_OID_ENHANCED_KEY_USAGE_EXTENSION    = 21,
    CAPICOM_OID_CERTIFICATE_TEMPLATE_EXTENSION  = 22,
    CAPICOM_OID_APPLICATION_CERT_POLICIES_EXTENSION = 23,
    CAPICOM_OID_APPLICATION_POLICY_MAPPINGS_EXTENSION   = 24,
    CAPICOM_OID_APPLICATION_POLICY_CONSTRAINTS_EXTENSION    = 25,
    CAPICOM_OID_AUTHORITY_INFO_ACCESS_EXTENSION = 26,
    CAPICOM_OID_SERVER_AUTH_EKU = 100,
    CAPICOM_OID_CLIENT_AUTH_EKU = 101,
    CAPICOM_OID_CODE_SIGNING_EKU    = 102,
    CAPICOM_OID_EMAIL_PROTECTION_EKU    = 103,
    CAPICOM_OID_IPSEC_END_SYSTEM_EKU    = 104,
    CAPICOM_OID_IPSEC_TUNNEL_EKU    = 105,
    CAPICOM_OID_IPSEC_USER_EKU  = 106,
    CAPICOM_OID_TIME_STAMPING_EKU   = 107,
    CAPICOM_OID_CTL_USAGE_SIGNING_EKU   = 108,
    CAPICOM_OID_TIME_STAMP_SIGNING_EKU  = 109,
    CAPICOM_OID_SERVER_GATED_CRYPTO_EKU = 110,
    CAPICOM_OID_ENCRYPTING_FILE_SYSTEM_EKU  = 111,
    CAPICOM_OID_EFS_RECOVERY_EKU    = 112,
    CAPICOM_OID_WHQL_CRYPTO_EKU = 113,
    CAPICOM_OID_NT5_CRYPTO_EKU  = 114,
    CAPICOM_OID_OEM_WHQL_CRYPTO_EKU = 115,
    CAPICOM_OID_EMBEDED_NT_CRYPTO_EKU   = 116,
    CAPICOM_OID_ROOT_LIST_SIGNER_EKU    = 117,
    CAPICOM_OID_QUALIFIED_SUBORDINATION_EKU = 118,
    CAPICOM_OID_KEY_RECOVERY_EKU    = 119,
    CAPICOM_OID_DIGITAL_RIGHTS_EKU  = 120,
    CAPICOM_OID_LICENSES_EKU    = 121,
    CAPICOM_OID_LICENSE_SERVER_EKU  = 122,
    CAPICOM_OID_SMART_CARD_LOGON_EKU    = 123,
    CAPICOM_OID_PKIX_POLICY_QUALIFIER_CPS   = 124,
    CAPICOM_OID_PKIX_POLICY_QUALIFIER_USERNOTICE    = 125
    }   CAPICOM_OID;

typedef
enum CAPICOM_PROPID
    {   CAPICOM_PROPID_UNKNOWN  = 0,
    CAPICOM_PROPID_KEY_PROV_HANDLE  = 1,
    CAPICOM_PROPID_KEY_PROV_INFO    = 2,
    CAPICOM_PROPID_SHA1_HASH    = 3,
    CAPICOM_PROPID_HASH_PROP    = 3,
    CAPICOM_PROPID_MD5_HASH = 4,
    CAPICOM_PROPID_KEY_CONTEXT  = 5,
    CAPICOM_PROPID_KEY_SPEC = 6,
    CAPICOM_PROPID_IE30_RESERVED    = 7,
    CAPICOM_PROPID_PUBKEY_HASH_RESERVED = 8,
    CAPICOM_PROPID_ENHKEY_USAGE = 9,
    CAPICOM_PROPID_CTL_USAGE    = 9,
    CAPICOM_PROPID_NEXT_UPDATE_LOCATION = 10,
    CAPICOM_PROPID_FRIENDLY_NAME    = 11,
    CAPICOM_PROPID_PVK_FILE = 12,
    CAPICOM_PROPID_DESCRIPTION  = 13,
    CAPICOM_PROPID_ACCESS_STATE = 14,
    CAPICOM_PROPID_SIGNATURE_HASH   = 15,
    CAPICOM_PROPID_SMART_CARD_DATA  = 16,
    CAPICOM_PROPID_EFS  = 17,
    CAPICOM_PROPID_FORTEZZA_DATA    = 18,
    CAPICOM_PROPID_ARCHIVED = 19,
    CAPICOM_PROPID_KEY_IDENTIFIER   = 20,
    CAPICOM_PROPID_AUTO_ENROLL  = 21,
    CAPICOM_PROPID_PUBKEY_ALG_PARA  = 22,
    CAPICOM_PROPID_CROSS_CERT_DIST_POINTS   = 23,
    CAPICOM_PROPID_ISSUER_PUBLIC_KEY_MD5_HASH   = 24,
    CAPICOM_PROPID_SUBJECT_PUBLIC_KEY_MD5_HASH  = 25,
    CAPICOM_PROPID_ENROLLMENT   = 26,
    CAPICOM_PROPID_DATE_STAMP   = 27,
    CAPICOM_PROPID_ISSUER_SERIAL_NUMBER_MD5_HASH    = 28,
    CAPICOM_PROPID_SUBJECT_NAME_MD5_HASH    = 29,
    CAPICOM_PROPID_EXTENDED_ERROR_INFO  = 30,
    CAPICOM_PROPID_RENEWAL  = 64,
    CAPICOM_PROPID_ARCHIVED_KEY_HASH    = 65,
    CAPICOM_PROPID_FIRST_RESERVED   = 66,
    CAPICOM_PROPID_LAST_RESERVED    = 0x7fff,
    CAPICOM_PROPID_FIRST_USER   = 0x8000,
    CAPICOM_PROPID_LAST_USER    = 0xffff
    }   CAPICOM_PROPID;

typedef
enum CAPICOM_PROV_TYPE
    {   CAPICOM_PROV_RSA_FULL   = 1,
    CAPICOM_PROV_RSA_SIG    = 2,
    CAPICOM_PROV_DSS    = 3,
    CAPICOM_PROV_FORTEZZA   = 4,
    CAPICOM_PROV_MS_EXCHANGE    = 5,
    CAPICOM_PROV_SSL    = 6,
    CAPICOM_PROV_RSA_SCHANNEL   = 12,
    CAPICOM_PROV_DSS_DH = 13,
    CAPICOM_PROV_EC_ECDSA_SIG   = 14,
    CAPICOM_PROV_EC_ECNRA_SIG   = 15,
    CAPICOM_PROV_EC_ECDSA_FULL  = 16,
    CAPICOM_PROV_EC_ECNRA_FULL  = 17,
    CAPICOM_PROV_DH_SCHANNEL    = 18,
    CAPICOM_PROV_SPYRUS_LYNKS   = 20,
    CAPICOM_PROV_RNG    = 21,
    CAPICOM_PROV_INTEL_SEC  = 22,
    CAPICOM_PROV_REPLACE_OWF    = 23,
    CAPICOM_PROV_RSA_AES    = 24
    }   CAPICOM_PROV_TYPE;

typedef
enum CAPICOM_CERTIFICATE_SAVE_AS_TYPE
    {   CAPICOM_CERTIFICATE_SAVE_AS_PFX = 0,
    CAPICOM_CERTIFICATE_SAVE_AS_CER = 1
    }   CAPICOM_CERTIFICATE_SAVE_AS_TYPE;

typedef
enum CAPICOM_CERTIFICATES_SAVE_AS_TYPE
    {   CAPICOM_CERTIFICATES_SAVE_AS_SERIALIZED = 0,
    CAPICOM_CERTIFICATES_SAVE_AS_PKCS7  = 1,
    CAPICOM_CERTIFICATES_SAVE_AS_PFX    = 2
    }   CAPICOM_CERTIFICATES_SAVE_AS_TYPE;

typedef
enum CAPICOM_CERTIFICATE_INCLUDE_OPTION
    {   CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT   = 0,
    CAPICOM_CERTIFICATE_INCLUDE_WHOLE_CHAIN = 1,
    CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY = 2
    }   CAPICOM_CERTIFICATE_INCLUDE_OPTION;

typedef
enum CAPICOM_KEY_SPEC
    {   CAPICOM_KEY_SPEC_KEYEXCHANGE    = 1,
    CAPICOM_KEY_SPEC_SIGNATURE  = 2
    }   CAPICOM_KEY_SPEC;

typedef
enum CAPICOM_KEY_LOCATION
    {   CAPICOM_CURRENT_USER_KEY    = 0,
    CAPICOM_LOCAL_MACHINE_KEY   = 1
    }   CAPICOM_KEY_LOCATION;

typedef
enum CAPICOM_KEY_STORAGE_FLAG
    {   CAPICOM_KEY_STORAGE_DEFAULT = 0,
    CAPICOM_KEY_STORAGE_EXPORTABLE  = 1,
    CAPICOM_KEY_STORAGE_USER_PROTECTED  = 2
    }   CAPICOM_KEY_STORAGE_FLAG;

typedef
enum CAPICOM_EXPORT_FLAG
    {   CAPICOM_EXPORT_DEFAULT  = 0,
    CAPICOM_EXPORT_IGNORE_PRIVATE_KEY_NOT_EXPORTABLE_ERROR  = 1
    }   CAPICOM_EXPORT_FLAG;

typedef
enum CAPICOM_KEY_USAGE
    {   CAPICOM_DIGITAL_SIGNATURE_KEY_USAGE = 0x80,
    CAPICOM_NON_REPUDIATION_KEY_USAGE   = 0x40,
    CAPICOM_KEY_ENCIPHERMENT_KEY_USAGE  = 0x20,
    CAPICOM_DATA_ENCIPHERMENT_KEY_USAGE = 0x10,
    CAPICOM_KEY_AGREEMENT_KEY_USAGE = 0x8,
    CAPICOM_KEY_CERT_SIGN_KEY_USAGE = 0x4,
    CAPICOM_OFFLINE_CRL_SIGN_KEY_USAGE  = 0x2,
    CAPICOM_CRL_SIGN_KEY_USAGE  = 0x2,
    CAPICOM_ENCIPHER_ONLY_KEY_USAGE = 0x1,
    CAPICOM_DECIPHER_ONLY_KEY_USAGE = 0x8000
    }   CAPICOM_KEY_USAGE;

typedef
enum CAPICOM_CERTIFICATE_FIND_TYPE
    {   CAPICOM_CERTIFICATE_FIND_SHA1_HASH  = 0,
    CAPICOM_CERTIFICATE_FIND_SUBJECT_NAME   = 1,
    CAPICOM_CERTIFICATE_FIND_ISSUER_NAME    = 2,
    CAPICOM_CERTIFICATE_FIND_ROOT_NAME  = 3,
    CAPICOM_CERTIFICATE_FIND_TEMPLATE_NAME  = 4,
    CAPICOM_CERTIFICATE_FIND_EXTENSION  = 5,
    CAPICOM_CERTIFICATE_FIND_EXTENDED_PROPERTY  = 6,
    CAPICOM_CERTIFICATE_FIND_APPLICATION_POLICY = 7,
    CAPICOM_CERTIFICATE_FIND_CERTIFICATE_POLICY = 8,
    CAPICOM_CERTIFICATE_FIND_TIME_VALID = 9,
    CAPICOM_CERTIFICATE_FIND_TIME_NOT_YET_VALID = 10,
    CAPICOM_CERTIFICATE_FIND_TIME_EXPIRED   = 11,
    CAPICOM_CERTIFICATE_FIND_KEY_USAGE  = 12
    }   CAPICOM_CERTIFICATE_FIND_TYPE;

typedef
enum CAPICOM_HASH_ALGORITHM
    {   CAPICOM_HASH_ALGORITHM_SHA1 = 0,
    CAPICOM_HASH_ALGORITHM_MD2  = 1,
    CAPICOM_HASH_ALGORITHM_MD4  = 2,
    CAPICOM_HASH_ALGORITHM_MD5  = 3
    }   CAPICOM_HASH_ALGORITHM;


EXTERN_C const IID LIBID_CAPICOM;


#ifndef __Constants_MODULE_DEFINED__
#define __Constants_MODULE_DEFINED__


/* module Constants */
/* [dllname] */

const long CAPICOM_MAJOR_VERSION    =   2;

const long CAPICOM_MINOR_VERSION    =   0;

const LPSTR CAPICOM_VERSION_INFO    =   "CAPICOM v2.0";

const LPSTR CAPICOM_COPY_RIGHT  =   "Copyright (c) Microsoft Corporation 1999-2002. All rights reserved.";

const LPSTR CAPICOM_MY_STORE    =   "My";

const LPSTR CAPICOM_CA_STORE    =   "Ca";

const LPSTR CAPICOM_ROOT_STORE  =   "Root";

const LPSTR CAPICOM_OTHER_STORE =   "AddressBook";

const LPSTR CAPICOM_OID_SERVER_AUTH =   "1.3.6.1.5.5.7.3.1";

const LPSTR CAPICOM_OID_CLIENT_AUTH =   "1.3.6.1.5.5.7.3.2";

const LPSTR CAPICOM_OID_CODE_SIGNING    =   "1.3.6.1.5.5.7.3.3";

const LPSTR CAPICOM_OID_EMAIL_PROTECTION    =   "1.3.6.1.5.5.7.3.4";

const LPSTR CAPICOM_OID_IPSEC_END_SYSTEM    =   "1.3.6.1.5.5.7.3.5";

const LPSTR CAPICOM_OID_IPSEC_TUNNEL    =   "1.3.6.1.5.5.7.3.6";

const LPSTR CAPICOM_OID_IPSEC_USER  =   "1.3.6.1.5.5.7.3.7";

const LPSTR CAPICOM_OID_TIME_STAMPING   =   "1.3.6.1.5.5.7.3.8";

const LPSTR CAPICOM_OID_CTL_USAGE_SIGNING   =   "1.3.6.1.4.1.311.10.3.1";

const LPSTR CAPICOM_OID_TIME_STAMP_SIGNING  =   "1.3.6.1.4.1.311.10.3.2";

const LPSTR CAPICOM_OID_SERVER_GATED_CRYPTO =   "1.3.6.1.4.1.311.10.3.3";

const LPSTR CAPICOM_OID_ENCRYPTING_FILE_SYSTEM  =   "1.3.6.1.4.1.311.10.3.4";

const LPSTR CAPICOM_OID_EFS_RECOVERY    =   "1.3.6.1.4.1.311.10.3.4.1";

const LPSTR CAPICOM_OID_WHQL_CRYPTO =   "1.3.6.1.4.1.311.10.3.5";

const LPSTR CAPICOM_OID_NT5_CRYPTO  =   "1.3.6.1.4.1.311.10.3.6";

const LPSTR CAPICOM_OID_OEM_WHQL_CRYPTO =   "1.3.6.1.4.1.311.10.3.7";

const LPSTR CAPICOM_OID_EMBEDED_NT_CRYPTO   =   "1.3.6.1.4.1.311.10.3.8";

const LPSTR CAPICOM_OID_ROOT_LIST_SIGNER    =   "1.3.6.1.4.1.311.10.3.9";

const LPSTR CAPICOM_OID_QUALIFIED_SUBORDINATION =   "1.3.6.1.4.1.311.10.3.10";

const LPSTR CAPICOM_OID_KEY_RECOVERY    =   "1.3.6.1.4.1.311.10.3.11";

const LPSTR CAPICOM_OID_DIGITAL_RIGHTS  =   "1.3.6.1.4.1.311.10.5.1";

const LPSTR CAPICOM_OID_LICENSES    =   "1.3.6.1.4.1.311.10.6.1";

const LPSTR CAPICOM_OID_LICENSE_SERVER  =   "1.3.6.1.4.1.311.10.6.2";

const LPSTR CAPICOM_OID_SMART_CARD_LOGON    =   "1.3.6.1.4.1.311.20.2.2";

const LPSTR CAPICOM_SERVER_AUTH_OID =   "1.3.6.1.5.5.7.3.1";

const LPSTR CAPICOM_CLIENT_AUTH_OID =   "1.3.6.1.5.5.7.3.2";

const LPSTR CAPICOM_CODE_SIGNING_OID    =   "1.3.6.1.5.5.7.3.3";

const LPSTR CAPICOM_EMAIL_PROTECTION_OID    =   "1.3.6.1.5.5.7.3.4";

const LPSTR CAPICOM_IPSEC_END_SYSTEM_OID    =   "1.3.6.1.5.5.7.3.5";

const LPSTR CAPICOM_IPSEC_TUNNEL_OID    =   "1.3.6.1.5.5.7.3.6";

const LPSTR CAPICOM_IPSEC_USER_OID  =   "1.3.6.1.5.5.7.3.7";

const LPSTR CAPICOM_TIME_STAMPING_OID   =   "1.3.6.1.5.5.7.3.8";

const LPSTR CAPICOM_CTL_USAGE_SIGNING_OID   =   "1.3.6.1.4.1.311.10.3.1";

const LPSTR CAPICOM_TIME_STAMP_SIGNING_OID  =   "1.3.6.1.4.1.311.10.3.2";

const LPSTR CAPICOM_SERVER_GATED_CRYPTO_OID =   "1.3.6.1.4.1.311.10.3.3";

const LPSTR CAPICOM_ENCRYPTING_FILE_SYSTEM_OID  =   "1.3.6.1.4.1.311.10.3.4";

const LPSTR CAPICOM_EFS_RECOVERY_OID    =   "1.3.6.1.4.1.311.10.3.4.1";

const LPSTR CAPICOM_WHQL_CRYPTO_OID =   "1.3.6.1.4.1.311.10.3.5";

const LPSTR CAPICOM_NT5_CRYPTO_OID  =   "1.3.6.1.4.1.311.10.3.6";

const LPSTR CAPICOM_OEM_WHQL_CRYPTO_OID =   "1.3.6.1.4.1.311.10.3.7";

const LPSTR CAPICOM_EMBEDED_NT_CRYPTO_OID   =   "1.3.6.1.4.1.311.10.3.8";

const LPSTR CAPICOM_ROOT_LIST_SIGNER_OID    =   "1.3.6.1.4.1.311.10.3.9";

const LPSTR CAPICOM_QUALIFIED_SUBORDINATION_OID =   "1.3.6.1.4.1.311.10.3.10";

const LPSTR CAPICOM_KEY_RECOVERY_OID    =   "1.3.6.1.4.1.311.10.3.11";

const LPSTR CAPICOM_DIGITAL_RIGHTS_OID  =   "1.3.6.1.4.1.311.10.5.1";

const LPSTR CAPICOM_LICENSES_OID    =   "1.3.6.1.4.1.311.10.6.1";

const LPSTR CAPICOM_LICENSE_SERVER_OID  =   "1.3.6.1.4.1.311.10.6.2";

const LPSTR CAPICOM_SMART_CARD_LOGON_OID    =   "1.3.6.1.4.1.311.20.2.2";

const LPSTR CAPICOM_ANY_APPLICATION_POLICY_OID  =   "1.3.6.1.4.1.311.10.12.1";

const LPSTR CAPICOM_ANY_CERT_POLICY_OID =   "2.5.29.32.0";

const LPSTR CAPICOM_AUTHORITY_KEY_IDENTIFIER_OID    =   "2.5.29.1";

const LPSTR CAPICOM_KEY_ATTRIBUTES_OID  =   "2.5.29.2";

const LPSTR CAPICOM_CERT_POLICIES_95_OID    =   "2.5.29.3";

const LPSTR CAPICOM_KEY_USAGE_RESTRICTION_OID   =   "2.5.29.4";

const LPSTR CAPICOM_LEGACY_POLICY_MAPPINGS_OID  =   "2.5.29.5";

const LPSTR CAPICOM_SUBJECT_ALT_NAME_OID    =   "2.5.29.7";

const LPSTR CAPICOM_ISSUER_ALT_NAME_OID =   "2.5.29.8";

const LPSTR CAPICOM_BASIC_CONSTRAINTS_OID   =   "2.5.29.10";

const LPSTR CAPICOM_SUBJECT_KEY_IDENTIFIER_OID  =   "2.5.29.14";

const LPSTR CAPICOM_KEY_USAGE_OID   =   "2.5.29.15";

const LPSTR CAPICOM_PRIVATEKEY_USAGE_PERIOD_OID =   "2.5.29.16";

const LPSTR CAPICOM_SUBJECT_ALT_NAME2_OID   =   "2.5.29.17";

const LPSTR CAPICOM_ISSUER_ALT_NAME2_OID    =   "2.5.29.18";

const LPSTR CAPICOM_BASIC_CONSTRAINTS2_OID  =   "2.5.29.19";

const LPSTR CAPICOM_NAME_CONSTRAINTS_OID    =   "2.5.29.30";

const LPSTR CAPICOM_CRL_DIST_POINTS_OID =   "2.5.29.31";

const LPSTR CAPICOM_CERT_POLICIES_OID   =   "2.5.29.32";

const LPSTR CAPICOM_POLICY_MAPPINGS_OID =   "2.5.29.33";

const LPSTR CAPICOM_AUTHORITY_KEY_IDENTIFIER2_OID   =   "2.5.29.35";

const LPSTR CAPICOM_POLICY_CONSTRAINTS_OID  =   "2.5.29.36";

const LPSTR CAPICOM_ENHANCED_KEY_USAGE_OID  =   "2.5.29.37";

const LPSTR CAPICOM_CERTIFICATE_TEMPLATE_OID    =   "1.3.6.1.4.1.311.21.7";

const LPSTR CAPICOM_APPLICATION_CERT_POLICIES_OID   =   "1.3.6.1.4.1.311.21.10";

const LPSTR CAPICOM_APPLICATION_POLICY_MAPPINGS_OID =   "1.3.6.1.4.1.311.21.11";

const LPSTR CAPICOM_APPLICATION_POLICY_CONSTRAINTS_OID  =   "1.3.6.1.4.1.311.21.12";

const LPSTR CAPICOM_AUTHORITY_INFO_ACCESS_OID   =   "1.3.6.1.5.5.7.1.1";

const LPSTR CAPICOM_PKIX_POLICY_QUALIFIER_CPS_OID   =   "1.3.6.1.5.5.7.2.1";

const LPSTR CAPICOM_PKIX_POLICY_QUALIFIER_USERNOTICE_OID    =   "1.3.6.1.5.5.7.2.2";

const long CAPICOM_TRUST_IS_NOT_TIME_VALID  =   0x1;

const long CAPICOM_TRUST_IS_NOT_TIME_NESTED =   0x2;

const long CAPICOM_TRUST_IS_REVOKED =   0x4;

const long CAPICOM_TRUST_IS_NOT_SIGNATURE_VALID =   0x8;

const long CAPICOM_TRUST_IS_NOT_VALID_FOR_USAGE =   0x10;

const long CAPICOM_TRUST_IS_UNTRUSTED_ROOT  =   0x20;

const long CAPICOM_TRUST_REVOCATION_STATUS_UNKNOWN  =   0x40;

const long CAPICOM_TRUST_IS_CYCLIC  =   0x80;

const long CAPICOM_TRUST_INVALID_EXTENSION  =   0x100;

const long CAPICOM_TRUST_INVALID_POLICY_CONSTRAINTS =   0x200;

const long CAPICOM_TRUST_INVALID_BASIC_CONSTRAINTS  =   0x400;

const long CAPICOM_TRUST_INVALID_NAME_CONSTRAINTS   =   0x800;

const long CAPICOM_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT  =   0x1000;

const long CAPICOM_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT    =   0x2000;

const long CAPICOM_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT  =   0x4000;

const long CAPICOM_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT   =   0x8000;

const long CAPICOM_TRUST_IS_OFFLINE_REVOCATION  =   0x1000000;

const long CAPICOM_TRUST_NO_ISSUANCE_CHAIN_POLICY   =   0x2000000;

const long CAPICOM_TRUST_IS_PARTIAL_CHAIN   =   0x10000;

const long CAPICOM_TRUST_CTL_IS_NOT_TIME_VALID  =   0x20000;

const long CAPICOM_TRUST_CTL_IS_NOT_SIGNATURE_VALID =   0x40000;

const long CAPICOM_TRUST_CTL_IS_NOT_VALID_FOR_USAGE =   0x80000;

const LPSTR CAPICOM_PROV_MS_DEF_PROV    =   "Microsoft Base Cryptographic Provider v1.0";

const LPSTR CAPICOM_PROV_MS_ENHANCED_PROV   =   "Microsoft Enhanced Cryptographic Provider v1.0";

const LPSTR CAPICOM_PROV_MS_STRONG_PROV =   "Microsoft Strong Cryptographic Provider";

const LPSTR CAPICOM_PROV_MS_DEF_RSA_SIG_PROV    =   "Microsoft RSA Signature Cryptographic Provider";

const LPSTR CAPICOM_PROV_MS_DEF_RSA_SCHANNEL_PROV   =   "Microsoft RSA SChannel Cryptographic Provider";

const LPSTR CAPICOM_PROV_MS_DEF_DSS_PROV    =   "Microsoft Base DSS Cryptographic Provider";

const LPSTR CAPICOM_PROV_MS_DEF_DSS_DH_PROV =   "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";

const LPSTR CAPICOM_PROV_MS_ENH_DSS_DH_PROV =   "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";

const LPSTR CAPICOM_PROV_MS_DEF_DH_SCHANNEL_PROV    =   "Microsoft DH SChannel Cryptographic Provider";

const LPSTR CAPICOM_PROV_MS_SCARD_PROV  =   "Microsoft Base Smart Card Crypto Provider";

const LPSTR CAPICOM_PROV_MS_ENH_RSA_AES_PROV    =   "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";

#endif /* __Constants_MODULE_DEFINED__ */

EXTERN_C const CLSID CLSID_Settings;

#ifdef __cplusplus

class DECLSPEC_UUID("A996E48C-D3DC-4244-89F7-AFA33EC60679")
Settings;
#endif

EXTERN_C const CLSID CLSID_EKU;

#ifdef __cplusplus

class DECLSPEC_UUID("8535F9A1-738A-40D0-8FB1-10CC8F74E7D3")
EKU;
#endif

EXTERN_C const CLSID CLSID_EKUs;

#ifdef __cplusplus

class DECLSPEC_UUID("F1800663-5BFC-4D1A-8D44-56CE02DDA34F")
EKUs;
#endif

EXTERN_C const CLSID CLSID_KeyUsage;

#ifdef __cplusplus

class DECLSPEC_UUID("9226C95C-38BE-4CC4-B3A2-A867F5199C13")
KeyUsage;
#endif

EXTERN_C const CLSID CLSID_ExtendedKeyUsage;

#ifdef __cplusplus

class DECLSPEC_UUID("42C18607-1B4B-4126-8F1B-76E2DC7F631A")
ExtendedKeyUsage;
#endif

EXTERN_C const CLSID CLSID_BasicConstraints;

#ifdef __cplusplus

class DECLSPEC_UUID("C05AAC6E-3A58-45A9-A203-56952E961E48")
BasicConstraints;
#endif

EXTERN_C const CLSID CLSID_CertificateStatus;

#ifdef __cplusplus

class DECLSPEC_UUID("16951EE6-A455-47CA-A78B-F98DA566B604")
CertificateStatus;
#endif

EXTERN_C const CLSID CLSID_Certificate;

#ifdef __cplusplus

class DECLSPEC_UUID("E38FD381-6404-4041-B5E9-B2739258941F")
Certificate;
#endif

EXTERN_C const CLSID CLSID_Certificates;

#ifdef __cplusplus

class DECLSPEC_UUID("FBAB033B-CDD0-4C5E-81AB-AEA575CD1338")
Certificates;
#endif

EXTERN_C const CLSID CLSID_Chain;

#ifdef __cplusplus

class DECLSPEC_UUID("65104D73-BA60-4160-A95A-4B4782E7AA62")
Chain;
#endif

EXTERN_C const CLSID CLSID_Store;

#ifdef __cplusplus

class DECLSPEC_UUID("78E61E52-0E57-4456-A2F2-517492BCBF8F")
Store;
#endif

EXTERN_C const CLSID CLSID_Attribute;

#ifdef __cplusplus

class DECLSPEC_UUID("54BA1E8F-818D-407F-949D-BAE1692C5C18")
Attribute;
#endif

EXTERN_C const CLSID CLSID_Attributes;

#ifdef __cplusplus

class DECLSPEC_UUID("933013A9-64C8-4485-ACEF-4908C3692A33")
Attributes;
#endif

EXTERN_C const CLSID CLSID_Signer;

#ifdef __cplusplus

class DECLSPEC_UUID("60A9863A-11FD-4080-850E-A8E184FC3A3C")
Signer;
#endif

EXTERN_C const CLSID CLSID_Signers;

#ifdef __cplusplus

class DECLSPEC_UUID("1314C1D8-D3A8-4F8A-BED0-811FD7A8A633")
Signers;
#endif

EXTERN_C const CLSID CLSID_SignedData;

#ifdef __cplusplus

class DECLSPEC_UUID("94AFFFCC-6C05-4814-B123-A941105AA77F")
SignedData;
#endif

EXTERN_C const CLSID CLSID_Algorithm;

#ifdef __cplusplus

class DECLSPEC_UUID("A1EEF42F-5026-4A32-BC5C-2E552B70FD96")
Algorithm;
#endif

EXTERN_C const CLSID CLSID_Recipients;

#ifdef __cplusplus

class DECLSPEC_UUID("96A1B8B0-8F9A-436A-84DE-E23CD6818DA5")
Recipients;
#endif

EXTERN_C const CLSID CLSID_EnvelopedData;

#ifdef __cplusplus

class DECLSPEC_UUID("F3A12E08-EDE9-4160-8B51-334D982A9AD0")
EnvelopedData;
#endif

EXTERN_C const CLSID CLSID_EncryptedData;

#ifdef __cplusplus

class DECLSPEC_UUID("A440BD76-CFE1-4D46-AB1F-15F238437A3D")
EncryptedData;
#endif

EXTERN_C const CLSID CLSID_OID;

#ifdef __cplusplus

class DECLSPEC_UUID("7BF3AC5C-CC84-429A-ACA5-74D916AD6B8C")
OID;
#endif

EXTERN_C const CLSID CLSID_OIDs;

#ifdef __cplusplus

class DECLSPEC_UUID("FD661131-D716-4D15-A187-AEAAB161C8AD")
OIDs;
#endif

EXTERN_C const CLSID CLSID_NoticeNumbers;

#ifdef __cplusplus

class DECLSPEC_UUID("A6FDF22A-8E00-464B-B15D-1A891D88B6ED")
NoticeNumbers;
#endif

EXTERN_C const CLSID CLSID_Qualifier;

#ifdef __cplusplus

class DECLSPEC_UUID("E5F29B74-0902-4654-8A9A-21C5201DFA61")
Qualifier;
#endif

EXTERN_C const CLSID CLSID_Qualifiers;

#ifdef __cplusplus

class DECLSPEC_UUID("6C8006C0-F649-4783-B4A6-617DD0B270C7")
Qualifiers;
#endif

EXTERN_C const CLSID CLSID_PolicyInformation;

#ifdef __cplusplus

class DECLSPEC_UUID("0AAF88F4-1C22-4F65-A0E3-289D97DCE994")
PolicyInformation;
#endif

EXTERN_C const CLSID CLSID_CertificatePolicies;

#ifdef __cplusplus

class DECLSPEC_UUID("988583C2-00C7-4D22-9241-E810E35EED1B")
CertificatePolicies;
#endif

EXTERN_C const CLSID CLSID_EncodedData;

#ifdef __cplusplus

class DECLSPEC_UUID("7083C0AA-E7B9-48A4-8EFB-D6A109EBEC13")
EncodedData;
#endif

EXTERN_C const CLSID CLSID_Extension;

#ifdef __cplusplus

class DECLSPEC_UUID("D2359E2C-82D6-458F-BB6F-41559155E693")
Extension;
#endif

EXTERN_C const CLSID CLSID_Extensions;

#ifdef __cplusplus

class DECLSPEC_UUID("7C92E131-C1DC-4CA1-B02C-F513A08B41ED")
Extensions;
#endif

EXTERN_C const CLSID CLSID_ExtendedProperty;

#ifdef __cplusplus

class DECLSPEC_UUID("9E7EA907-5810-4FCA-B817-CD0BBA8496FC")
ExtendedProperty;
#endif

EXTERN_C const CLSID CLSID_ExtendedProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("90E7143D-1A07-438D-8F85-3DBB0B73D314")
ExtendedProperties;
#endif

EXTERN_C const CLSID CLSID_Template;

#ifdef __cplusplus

class DECLSPEC_UUID("61F0D2BD-373E-4F3C-962E-59B7C42C1B22")
Template;
#endif

EXTERN_C const CLSID CLSID_PublicKey;

#ifdef __cplusplus

class DECLSPEC_UUID("301FC658-4055-4D76-9703-AA38E6D7236A")
PublicKey;
#endif

EXTERN_C const CLSID CLSID_PrivateKey;

#ifdef __cplusplus

class DECLSPEC_UUID("03ACC284-B757-4B8F-9951-86E600D2CD06")
PrivateKey;
#endif

EXTERN_C const CLSID CLSID_SignedCode;

#ifdef __cplusplus

class DECLSPEC_UUID("8C3E4934-9FA4-4693-9253-A29A05F99186")
SignedCode;
#endif

EXTERN_C const CLSID CLSID_HashedData;

#ifdef __cplusplus

class DECLSPEC_UUID("CE32ABF6-475D-41F6-BF82-D27F03E3D38B")
HashedData;
#endif

EXTERN_C const CLSID CLSID_Utilities;

#ifdef __cplusplus

class DECLSPEC_UUID("22A85CE1-F011-4231-B9E4-7E7A0438F71B")
Utilities;
#endif
#endif /* __CAPICOM_LIBRARY_DEFINED__ */

#ifndef __ISettings_INTERFACE_DEFINED__
#define __ISettings_INTERFACE_DEFINED__

/* interface ISettings */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ISettings;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("A24104F5-46D0-4C0F-926D-665565908E91")
    ISettings : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnablePromptForCertificateUI(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnablePromptForCertificateUI(
            /* [defaultvalue][in] */ VARIANT_BOOL newVal = 0) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveDirectorySearchLocation(
            /* [retval][out] */ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ActiveDirectorySearchLocation(
            /* [defaultvalue][in] */ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION newVal = CAPICOM_SEARCH_ANY) = 0;

    };

#else   /* C style interface */

    typedef struct ISettingsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ISettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ISettings * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ISettings * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ISettings * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ISettings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ISettings * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ISettings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnablePromptForCertificateUI )(
            ISettings * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnablePromptForCertificateUI )(
            ISettings * This,
            /* [defaultvalue][in] */ VARIANT_BOOL newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveDirectorySearchLocation )(
            ISettings * This,
            /* [retval][out] */ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ActiveDirectorySearchLocation )(
            ISettings * This,
            /* [defaultvalue][in] */ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION newVal);

        END_INTERFACE
    } ISettingsVtbl;

    interface ISettings
    {
        CONST_VTBL struct ISettingsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ISettings_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISettings_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define ISettings_Release(This) \
    (This)->lpVtbl -> Release(This)


#define ISettings_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISettings_get_EnablePromptForCertificateUI(This,pVal)   \
    (This)->lpVtbl -> get_EnablePromptForCertificateUI(This,pVal)

#define ISettings_put_EnablePromptForCertificateUI(This,newVal) \
    (This)->lpVtbl -> put_EnablePromptForCertificateUI(This,newVal)

#define ISettings_get_ActiveDirectorySearchLocation(This,pVal)  \
    (This)->lpVtbl -> get_ActiveDirectorySearchLocation(This,pVal)

#define ISettings_put_ActiveDirectorySearchLocation(This,newVal)    \
    (This)->lpVtbl -> put_ActiveDirectorySearchLocation(This,newVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISettings_get_EnablePromptForCertificateUI_Proxy(
    ISettings * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB ISettings_get_EnablePromptForCertificateUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISettings_put_EnablePromptForCertificateUI_Proxy(
    ISettings * This,
    /* [defaultvalue][in] */ VARIANT_BOOL newVal);


void __RPC_STUB ISettings_put_EnablePromptForCertificateUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISettings_get_ActiveDirectorySearchLocation_Proxy(
    ISettings * This,
    /* [retval][out] */ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION *pVal);


void __RPC_STUB ISettings_get_ActiveDirectorySearchLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISettings_put_ActiveDirectorySearchLocation_Proxy(
    ISettings * This,
    /* [defaultvalue][in] */ CAPICOM_ACTIVE_DIRECTORY_SEARCH_LOCATION newVal);


void __RPC_STUB ISettings_put_ActiveDirectorySearchLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISettings_INTERFACE_DEFINED__ */


#ifndef __IEKU_INTERFACE_DEFINED__
#define __IEKU_INTERFACE_DEFINED__

/* interface IEKU */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IEKU;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("976B7E6D-1002-4051-BFD4-824A74BD74E2")
    IEKU : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name(
            /* [retval][out] */ CAPICOM_EKU *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name(
            /* [in] */ CAPICOM_EKU newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OID(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OID(
            /* [in] */ BSTR newVal) = 0;

    };

#else   /* C style interface */

    typedef struct IEKUVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IEKU * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IEKU * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IEKU * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IEKU * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IEKU * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IEKU * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IEKU * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )(
            IEKU * This,
            /* [retval][out] */ CAPICOM_EKU *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )(
            IEKU * This,
            /* [in] */ CAPICOM_EKU newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OID )(
            IEKU * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OID )(
            IEKU * This,
            /* [in] */ BSTR newVal);

        END_INTERFACE
    } IEKUVtbl;

    interface IEKU
    {
        CONST_VTBL struct IEKUVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IEKU_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEKU_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEKU_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEKU_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEKU_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEKU_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEKU_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEKU_get_Name(This,pVal)    \
    (This)->lpVtbl -> get_Name(This,pVal)

#define IEKU_put_Name(This,newVal)  \
    (This)->lpVtbl -> put_Name(This,newVal)

#define IEKU_get_OID(This,pVal) \
    (This)->lpVtbl -> get_OID(This,pVal)

#define IEKU_put_OID(This,newVal)   \
    (This)->lpVtbl -> put_OID(This,newVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEKU_get_Name_Proxy(
    IEKU * This,
    /* [retval][out] */ CAPICOM_EKU *pVal);


void __RPC_STUB IEKU_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEKU_put_Name_Proxy(
    IEKU * This,
    /* [in] */ CAPICOM_EKU newVal);


void __RPC_STUB IEKU_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEKU_get_OID_Proxy(
    IEKU * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEKU_get_OID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEKU_put_OID_Proxy(
    IEKU * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IEKU_put_OID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEKU_INTERFACE_DEFINED__ */


#ifndef __IEKUs_INTERFACE_DEFINED__
#define __IEKUs_INTERFACE_DEFINED__

/* interface IEKUs */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IEKUs;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("47C87CEC-8C4B-4E3C-8D22-34280274EFD1")
    IEKUs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IEKUsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IEKUs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IEKUs * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IEKUs * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IEKUs * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IEKUs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IEKUs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IEKUs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            IEKUs * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            IEKUs * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            IEKUs * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        END_INTERFACE
    } IEKUsVtbl;

    interface IEKUs
    {
        CONST_VTBL struct IEKUsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IEKUs_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEKUs_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IEKUs_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IEKUs_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEKUs_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEKUs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEKUs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEKUs_get_Item(This,Index,pVal) \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IEKUs_get_Count(This,pVal)  \
    (This)->lpVtbl -> get_Count(This,pVal)

#define IEKUs_get__NewEnum(This,pVal)   \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEKUs_get_Item_Proxy(
    IEKUs * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IEKUs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEKUs_get_Count_Proxy(
    IEKUs * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IEKUs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEKUs_get__NewEnum_Proxy(
    IEKUs * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IEKUs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEKUs_INTERFACE_DEFINED__ */


#ifndef __IKeyUsage_INTERFACE_DEFINED__
#define __IKeyUsage_INTERFACE_DEFINED__

/* interface IKeyUsage */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IKeyUsage;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("41DD35A8-9FF9-45A6-9A7C-F65B2F085D1F")
    IKeyUsage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsPresent(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCritical(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDigitalSignatureEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsNonRepudiationEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsKeyEnciphermentEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDataEnciphermentEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsKeyAgreementEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsKeyCertSignEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCRLSignEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsEncipherOnlyEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDecipherOnlyEnabled(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IKeyUsageVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IKeyUsage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IKeyUsage * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IKeyUsage * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IKeyUsage * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IKeyUsage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IKeyUsage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IKeyUsage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCritical )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDigitalSignatureEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsNonRepudiationEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsKeyEnciphermentEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDataEnciphermentEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsKeyAgreementEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsKeyCertSignEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCRLSignEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsEncipherOnlyEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDecipherOnlyEnabled )(
            IKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        END_INTERFACE
    } IKeyUsageVtbl;

    interface IKeyUsage
    {
        CONST_VTBL struct IKeyUsageVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IKeyUsage_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IKeyUsage_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IKeyUsage_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IKeyUsage_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IKeyUsage_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IKeyUsage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IKeyUsage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IKeyUsage_get_IsPresent(This,pVal)  \
    (This)->lpVtbl -> get_IsPresent(This,pVal)

#define IKeyUsage_get_IsCritical(This,pVal) \
    (This)->lpVtbl -> get_IsCritical(This,pVal)

#define IKeyUsage_get_IsDigitalSignatureEnabled(This,pVal)  \
    (This)->lpVtbl -> get_IsDigitalSignatureEnabled(This,pVal)

#define IKeyUsage_get_IsNonRepudiationEnabled(This,pVal)    \
    (This)->lpVtbl -> get_IsNonRepudiationEnabled(This,pVal)

#define IKeyUsage_get_IsKeyEnciphermentEnabled(This,pVal)   \
    (This)->lpVtbl -> get_IsKeyEnciphermentEnabled(This,pVal)

#define IKeyUsage_get_IsDataEnciphermentEnabled(This,pVal)  \
    (This)->lpVtbl -> get_IsDataEnciphermentEnabled(This,pVal)

#define IKeyUsage_get_IsKeyAgreementEnabled(This,pVal)  \
    (This)->lpVtbl -> get_IsKeyAgreementEnabled(This,pVal)

#define IKeyUsage_get_IsKeyCertSignEnabled(This,pVal)   \
    (This)->lpVtbl -> get_IsKeyCertSignEnabled(This,pVal)

#define IKeyUsage_get_IsCRLSignEnabled(This,pVal)   \
    (This)->lpVtbl -> get_IsCRLSignEnabled(This,pVal)

#define IKeyUsage_get_IsEncipherOnlyEnabled(This,pVal)  \
    (This)->lpVtbl -> get_IsEncipherOnlyEnabled(This,pVal)

#define IKeyUsage_get_IsDecipherOnlyEnabled(This,pVal)  \
    (This)->lpVtbl -> get_IsDecipherOnlyEnabled(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsPresent_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsCritical_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsCritical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsDigitalSignatureEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsDigitalSignatureEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsNonRepudiationEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsNonRepudiationEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsKeyEnciphermentEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsKeyEnciphermentEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsDataEnciphermentEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsDataEnciphermentEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsKeyAgreementEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsKeyAgreementEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsKeyCertSignEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsKeyCertSignEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsCRLSignEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsCRLSignEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsEncipherOnlyEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsEncipherOnlyEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IKeyUsage_get_IsDecipherOnlyEnabled_Proxy(
    IKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IKeyUsage_get_IsDecipherOnlyEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IKeyUsage_INTERFACE_DEFINED__ */


#ifndef __IExtendedKeyUsage_INTERFACE_DEFINED__
#define __IExtendedKeyUsage_INTERFACE_DEFINED__

/* interface IExtendedKeyUsage */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IExtendedKeyUsage;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("7289D408-987D-45D1-8DEE-CF9E91C2E90E")
    IExtendedKeyUsage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsPresent(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCritical(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EKUs(
            /* [retval][out] */ IEKUs **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IExtendedKeyUsageVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IExtendedKeyUsage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IExtendedKeyUsage * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IExtendedKeyUsage * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IExtendedKeyUsage * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IExtendedKeyUsage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IExtendedKeyUsage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IExtendedKeyUsage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )(
            IExtendedKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCritical )(
            IExtendedKeyUsage * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EKUs )(
            IExtendedKeyUsage * This,
            /* [retval][out] */ IEKUs **pVal);

        END_INTERFACE
    } IExtendedKeyUsageVtbl;

    interface IExtendedKeyUsage
    {
        CONST_VTBL struct IExtendedKeyUsageVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IExtendedKeyUsage_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendedKeyUsage_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IExtendedKeyUsage_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IExtendedKeyUsage_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExtendedKeyUsage_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExtendedKeyUsage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExtendedKeyUsage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExtendedKeyUsage_get_IsPresent(This,pVal)  \
    (This)->lpVtbl -> get_IsPresent(This,pVal)

#define IExtendedKeyUsage_get_IsCritical(This,pVal) \
    (This)->lpVtbl -> get_IsCritical(This,pVal)

#define IExtendedKeyUsage_get_EKUs(This,pVal)   \
    (This)->lpVtbl -> get_EKUs(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedKeyUsage_get_IsPresent_Proxy(
    IExtendedKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IExtendedKeyUsage_get_IsPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedKeyUsage_get_IsCritical_Proxy(
    IExtendedKeyUsage * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IExtendedKeyUsage_get_IsCritical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedKeyUsage_get_EKUs_Proxy(
    IExtendedKeyUsage * This,
    /* [retval][out] */ IEKUs **pVal);


void __RPC_STUB IExtendedKeyUsage_get_EKUs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IExtendedKeyUsage_INTERFACE_DEFINED__ */


#ifndef __IBasicConstraints_INTERFACE_DEFINED__
#define __IBasicConstraints_INTERFACE_DEFINED__

/* interface IBasicConstraints */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IBasicConstraints;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("4E298C47-ABA6-459E-851B-993D6C626EAD")
    IBasicConstraints : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsPresent(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCritical(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCertificateAuthority(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsPathLenConstraintPresent(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PathLenConstraint(
            /* [retval][out] */ long *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IBasicConstraintsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IBasicConstraints * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IBasicConstraints * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IBasicConstraints * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IBasicConstraints * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IBasicConstraints * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IBasicConstraints * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IBasicConstraints * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )(
            IBasicConstraints * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCritical )(
            IBasicConstraints * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCertificateAuthority )(
            IBasicConstraints * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsPathLenConstraintPresent )(
            IBasicConstraints * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PathLenConstraint )(
            IBasicConstraints * This,
            /* [retval][out] */ long *pVal);

        END_INTERFACE
    } IBasicConstraintsVtbl;

    interface IBasicConstraints
    {
        CONST_VTBL struct IBasicConstraintsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IBasicConstraints_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasicConstraints_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IBasicConstraints_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IBasicConstraints_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IBasicConstraints_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IBasicConstraints_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IBasicConstraints_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IBasicConstraints_get_IsPresent(This,pVal)  \
    (This)->lpVtbl -> get_IsPresent(This,pVal)

#define IBasicConstraints_get_IsCritical(This,pVal) \
    (This)->lpVtbl -> get_IsCritical(This,pVal)

#define IBasicConstraints_get_IsCertificateAuthority(This,pVal) \
    (This)->lpVtbl -> get_IsCertificateAuthority(This,pVal)

#define IBasicConstraints_get_IsPathLenConstraintPresent(This,pVal) \
    (This)->lpVtbl -> get_IsPathLenConstraintPresent(This,pVal)

#define IBasicConstraints_get_PathLenConstraint(This,pVal)  \
    (This)->lpVtbl -> get_PathLenConstraint(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBasicConstraints_get_IsPresent_Proxy(
    IBasicConstraints * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IBasicConstraints_get_IsPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBasicConstraints_get_IsCritical_Proxy(
    IBasicConstraints * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IBasicConstraints_get_IsCritical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBasicConstraints_get_IsCertificateAuthority_Proxy(
    IBasicConstraints * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IBasicConstraints_get_IsCertificateAuthority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBasicConstraints_get_IsPathLenConstraintPresent_Proxy(
    IBasicConstraints * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IBasicConstraints_get_IsPathLenConstraintPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IBasicConstraints_get_PathLenConstraint_Proxy(
    IBasicConstraints * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IBasicConstraints_get_PathLenConstraint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IBasicConstraints_INTERFACE_DEFINED__ */


#ifndef __ICertificateStatus_INTERFACE_DEFINED__
#define __ICertificateStatus_INTERFACE_DEFINED__

/* interface ICertificateStatus */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ICertificateStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("AB769053-6D38-49D4-86EF-5FA85ED3AF27")
    ICertificateStatus : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Result(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CheckFlag(
            /* [retval][out] */ CAPICOM_CHECK_FLAG *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CheckFlag(
            /* [in] */ CAPICOM_CHECK_FLAG newVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EKU(
            /* [retval][out] */ IEKU **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct ICertificateStatusVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertificateStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertificateStatus * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertificateStatus * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ICertificateStatus * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ICertificateStatus * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ICertificateStatus * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ICertificateStatus * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Result )(
            ICertificateStatus * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CheckFlag )(
            ICertificateStatus * This,
            /* [retval][out] */ CAPICOM_CHECK_FLAG *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CheckFlag )(
            ICertificateStatus * This,
            /* [in] */ CAPICOM_CHECK_FLAG newVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EKU )(
            ICertificateStatus * This,
            /* [retval][out] */ IEKU **pVal);

        END_INTERFACE
    } ICertificateStatusVtbl;

    interface ICertificateStatus
    {
        CONST_VTBL struct ICertificateStatusVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertificateStatus_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertificateStatus_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define ICertificateStatus_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define ICertificateStatus_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertificateStatus_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertificateStatus_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertificateStatus_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertificateStatus_get_Result(This,pVal)    \
    (This)->lpVtbl -> get_Result(This,pVal)

#define ICertificateStatus_get_CheckFlag(This,pVal) \
    (This)->lpVtbl -> get_CheckFlag(This,pVal)

#define ICertificateStatus_put_CheckFlag(This,newVal)   \
    (This)->lpVtbl -> put_CheckFlag(This,newVal)

#define ICertificateStatus_EKU(This,pVal)   \
    (This)->lpVtbl -> EKU(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificateStatus_get_Result_Proxy(
    ICertificateStatus * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB ICertificateStatus_get_Result_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificateStatus_get_CheckFlag_Proxy(
    ICertificateStatus * This,
    /* [retval][out] */ CAPICOM_CHECK_FLAG *pVal);


void __RPC_STUB ICertificateStatus_get_CheckFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICertificateStatus_put_CheckFlag_Proxy(
    ICertificateStatus * This,
    /* [in] */ CAPICOM_CHECK_FLAG newVal);


void __RPC_STUB ICertificateStatus_put_CheckFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificateStatus_EKU_Proxy(
    ICertificateStatus * This,
    /* [retval][out] */ IEKU **pVal);


void __RPC_STUB ICertificateStatus_EKU_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertificateStatus_INTERFACE_DEFINED__ */


#ifndef __ICertificate_INTERFACE_DEFINED__
#define __ICertificate_INTERFACE_DEFINED__

/* interface ICertificate */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ICertificate;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("0BBA0B86-766C-4755-A443-243FF2BD8D29")
    ICertificate : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SerialNumber(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubjectName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IssuerName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ValidFromDate(
            /* [retval][out] */ DATE *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ValidToDate(
            /* [retval][out] */ DATE *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Thumbprint(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasPrivateKey(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInfo(
            /* [in] */ CAPICOM_CERT_INFO_TYPE InfoType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsValid(
            /* [retval][out] */ ICertificateStatus **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE KeyUsage(
            /* [retval][out] */ IKeyUsage **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtendedKeyUsage(
            /* [retval][out] */ IExtendedKeyUsage **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BasicConstraints(
            /* [retval][out] */ IBasicConstraints **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Export(
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Import(
            /* [in] */ BSTR EncodedCertificate) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Display( void) = 0;

    };

#else   /* C style interface */

    typedef struct ICertificateVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertificate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertificate * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertificate * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ICertificate * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ICertificate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ICertificate * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ICertificate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )(
            ICertificate * This,
            /* [retval][out] */ long *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialNumber )(
            ICertificate * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubjectName )(
            ICertificate * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IssuerName )(
            ICertificate * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValidFromDate )(
            ICertificate * This,
            /* [retval][out] */ DATE *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValidToDate )(
            ICertificate * This,
            /* [retval][out] */ DATE *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Thumbprint )(
            ICertificate * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasPrivateKey )(
            ICertificate * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )(
            ICertificate * This,
            /* [in] */ CAPICOM_CERT_INFO_TYPE InfoType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsValid )(
            ICertificate * This,
            /* [retval][out] */ ICertificateStatus **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *KeyUsage )(
            ICertificate * This,
            /* [retval][out] */ IKeyUsage **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExtendedKeyUsage )(
            ICertificate * This,
            /* [retval][out] */ IExtendedKeyUsage **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BasicConstraints )(
            ICertificate * This,
            /* [retval][out] */ IBasicConstraints **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Export )(
            ICertificate * This,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Import )(
            ICertificate * This,
            /* [in] */ BSTR EncodedCertificate);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Display )(
            ICertificate * This);

        END_INTERFACE
    } ICertificateVtbl;

    interface ICertificate
    {
        CONST_VTBL struct ICertificateVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertificate_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertificate_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ICertificate_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ICertificate_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertificate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertificate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertificate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertificate_get_Version(This,pVal) \
    (This)->lpVtbl -> get_Version(This,pVal)

#define ICertificate_get_SerialNumber(This,pVal)    \
    (This)->lpVtbl -> get_SerialNumber(This,pVal)

#define ICertificate_get_SubjectName(This,pVal) \
    (This)->lpVtbl -> get_SubjectName(This,pVal)

#define ICertificate_get_IssuerName(This,pVal)  \
    (This)->lpVtbl -> get_IssuerName(This,pVal)

#define ICertificate_get_ValidFromDate(This,pVal)   \
    (This)->lpVtbl -> get_ValidFromDate(This,pVal)

#define ICertificate_get_ValidToDate(This,pVal) \
    (This)->lpVtbl -> get_ValidToDate(This,pVal)

#define ICertificate_get_Thumbprint(This,pVal)  \
    (This)->lpVtbl -> get_Thumbprint(This,pVal)

#define ICertificate_HasPrivateKey(This,pVal)   \
    (This)->lpVtbl -> HasPrivateKey(This,pVal)

#define ICertificate_GetInfo(This,InfoType,pVal)    \
    (This)->lpVtbl -> GetInfo(This,InfoType,pVal)

#define ICertificate_IsValid(This,pVal) \
    (This)->lpVtbl -> IsValid(This,pVal)

#define ICertificate_KeyUsage(This,pVal)    \
    (This)->lpVtbl -> KeyUsage(This,pVal)

#define ICertificate_ExtendedKeyUsage(This,pVal)    \
    (This)->lpVtbl -> ExtendedKeyUsage(This,pVal)

#define ICertificate_BasicConstraints(This,pVal)    \
    (This)->lpVtbl -> BasicConstraints(This,pVal)

#define ICertificate_Export(This,EncodingType,pVal) \
    (This)->lpVtbl -> Export(This,EncodingType,pVal)

#define ICertificate_Import(This,EncodedCertificate)    \
    (This)->lpVtbl -> Import(This,EncodedCertificate)

#define ICertificate_Display(This)  \
    (This)->lpVtbl -> Display(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate_get_Version_Proxy(
    ICertificate * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ICertificate_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate_get_SerialNumber_Proxy(
    ICertificate * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICertificate_get_SerialNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate_get_SubjectName_Proxy(
    ICertificate * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICertificate_get_SubjectName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate_get_IssuerName_Proxy(
    ICertificate * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICertificate_get_IssuerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate_get_ValidFromDate_Proxy(
    ICertificate * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB ICertificate_get_ValidFromDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate_get_ValidToDate_Proxy(
    ICertificate * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB ICertificate_get_ValidToDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate_get_Thumbprint_Proxy(
    ICertificate * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICertificate_get_Thumbprint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_HasPrivateKey_Proxy(
    ICertificate * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB ICertificate_HasPrivateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_GetInfo_Proxy(
    ICertificate * This,
    /* [in] */ CAPICOM_CERT_INFO_TYPE InfoType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICertificate_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_IsValid_Proxy(
    ICertificate * This,
    /* [retval][out] */ ICertificateStatus **pVal);


void __RPC_STUB ICertificate_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_KeyUsage_Proxy(
    ICertificate * This,
    /* [retval][out] */ IKeyUsage **pVal);


void __RPC_STUB ICertificate_KeyUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_ExtendedKeyUsage_Proxy(
    ICertificate * This,
    /* [retval][out] */ IExtendedKeyUsage **pVal);


void __RPC_STUB ICertificate_ExtendedKeyUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_BasicConstraints_Proxy(
    ICertificate * This,
    /* [retval][out] */ IBasicConstraints **pVal);


void __RPC_STUB ICertificate_BasicConstraints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_Export_Proxy(
    ICertificate * This,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ICertificate_Export_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_Import_Proxy(
    ICertificate * This,
    /* [in] */ BSTR EncodedCertificate);


void __RPC_STUB ICertificate_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate_Display_Proxy(
    ICertificate * This);


void __RPC_STUB ICertificate_Display_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertificate_INTERFACE_DEFINED__ */


#ifndef __ICertificates_INTERFACE_DEFINED__
#define __ICertificates_INTERFACE_DEFINED__

/* interface ICertificates */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ICertificates;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("68646716-BDA0-4046-AB82-4444BC93B84A")
    ICertificates : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct ICertificatesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertificates * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertificates * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertificates * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ICertificates * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ICertificates * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ICertificates * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ICertificates * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            ICertificates * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            ICertificates * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            ICertificates * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        END_INTERFACE
    } ICertificatesVtbl;

    interface ICertificates
    {
        CONST_VTBL struct ICertificatesVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertificates_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertificates_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define ICertificates_Release(This) \
    (This)->lpVtbl -> Release(This)


#define ICertificates_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertificates_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertificates_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertificates_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertificates_get_Item(This,Index,pVal) \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define ICertificates_get_Count(This,pVal)  \
    (This)->lpVtbl -> get_Count(This,pVal)

#define ICertificates_get__NewEnum(This,pVal)   \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificates_get_Item_Proxy(
    ICertificates * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ICertificates_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificates_get_Count_Proxy(
    ICertificates * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ICertificates_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificates_get__NewEnum_Proxy(
    ICertificates * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB ICertificates_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertificates_INTERFACE_DEFINED__ */


#ifndef __IChain_INTERFACE_DEFINED__
#define __IChain_INTERFACE_DEFINED__

/* interface IChain */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IChain;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("77F6F881-5D3A-4F2F-AEF0-E4A2F9AA689D")
    IChain : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Certificates(
            /* [retval][out] */ ICertificates **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status(
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Build(
            /* [in] */ ICertificate *pICertificate,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IChainVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IChain * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IChain * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IChain * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IChain * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IChain * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IChain * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificates )(
            IChain * This,
            /* [retval][out] */ ICertificates **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )(
            IChain * This,
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ long *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Build )(
            IChain * This,
            /* [in] */ ICertificate *pICertificate,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        END_INTERFACE
    } IChainVtbl;

    interface IChain
    {
        CONST_VTBL struct IChainVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IChain_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IChain_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IChain_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IChain_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IChain_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IChain_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IChain_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IChain_get_Certificates(This,pVal)  \
    (This)->lpVtbl -> get_Certificates(This,pVal)

#define IChain_get_Status(This,Index,pVal)  \
    (This)->lpVtbl -> get_Status(This,Index,pVal)

#define IChain_Build(This,pICertificate,pVal)   \
    (This)->lpVtbl -> Build(This,pICertificate,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IChain_get_Certificates_Proxy(
    IChain * This,
    /* [retval][out] */ ICertificates **pVal);


void __RPC_STUB IChain_get_Certificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IChain_get_Status_Proxy(
    IChain * This,
    /* [defaultvalue][in] */ long Index,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IChain_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IChain_Build_Proxy(
    IChain * This,
    /* [in] */ ICertificate *pICertificate,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IChain_Build_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IChain_INTERFACE_DEFINED__ */


#ifndef __IStore_INTERFACE_DEFINED__
#define __IStore_INTERFACE_DEFINED__

/* interface IStore */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("E860EF75-1B63-4254-AF47-960DAA3DD337")
    IStore : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Certificates(
            /* [retval][out] */ ICertificates **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Open(
            /* [defaultvalue][in] */ CAPICOM_STORE_LOCATION StoreLocation = CAPICOM_CURRENT_USER_STORE,
            /* [defaultvalue][in] */ BSTR StoreName = L"My",
            /* [defaultvalue][in] */ CAPICOM_STORE_OPEN_MODE OpenMode = CAPICOM_STORE_OPEN_READ_ONLY) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add(
            /* [in] */ ICertificate *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove(
            /* [in] */ ICertificate *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Export(
            /* [defaultvalue][in] */ CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Import(
            /* [in] */ BSTR EncodedStore) = 0;

    };

#else   /* C style interface */

    typedef struct IStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IStore * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IStore * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IStore * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IStore * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IStore * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IStore * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificates )(
            IStore * This,
            /* [retval][out] */ ICertificates **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Open )(
            IStore * This,
            /* [defaultvalue][in] */ CAPICOM_STORE_LOCATION StoreLocation,
            /* [defaultvalue][in] */ BSTR StoreName,
            /* [defaultvalue][in] */ CAPICOM_STORE_OPEN_MODE OpenMode);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )(
            IStore * This,
            /* [in] */ ICertificate *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )(
            IStore * This,
            /* [in] */ ICertificate *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Export )(
            IStore * This,
            /* [defaultvalue][in] */ CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Import )(
            IStore * This,
            /* [in] */ BSTR EncodedStore);

        END_INTERFACE
    } IStoreVtbl;

    interface IStore
    {
        CONST_VTBL struct IStoreVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IStore_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStore_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IStore_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IStore_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStore_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStore_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStore_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStore_get_Certificates(This,pVal)  \
    (This)->lpVtbl -> get_Certificates(This,pVal)

#define IStore_Open(This,StoreLocation,StoreName,OpenMode)  \
    (This)->lpVtbl -> Open(This,StoreLocation,StoreName,OpenMode)

#define IStore_Add(This,pVal)   \
    (This)->lpVtbl -> Add(This,pVal)

#define IStore_Remove(This,pVal)    \
    (This)->lpVtbl -> Remove(This,pVal)

#define IStore_Export(This,SaveAs,EncodingType,pVal)    \
    (This)->lpVtbl -> Export(This,SaveAs,EncodingType,pVal)

#define IStore_Import(This,EncodedStore)    \
    (This)->lpVtbl -> Import(This,EncodedStore)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IStore_get_Certificates_Proxy(
    IStore * This,
    /* [retval][out] */ ICertificates **pVal);


void __RPC_STUB IStore_get_Certificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStore_Open_Proxy(
    IStore * This,
    /* [defaultvalue][in] */ CAPICOM_STORE_LOCATION StoreLocation,
    /* [defaultvalue][in] */ BSTR StoreName,
    /* [defaultvalue][in] */ CAPICOM_STORE_OPEN_MODE OpenMode);


void __RPC_STUB IStore_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStore_Add_Proxy(
    IStore * This,
    /* [in] */ ICertificate *pVal);


void __RPC_STUB IStore_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStore_Remove_Proxy(
    IStore * This,
    /* [in] */ ICertificate *pVal);


void __RPC_STUB IStore_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStore_Export_Proxy(
    IStore * This,
    /* [defaultvalue][in] */ CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IStore_Export_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStore_Import_Proxy(
    IStore * This,
    /* [in] */ BSTR EncodedStore);


void __RPC_STUB IStore_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IStore_INTERFACE_DEFINED__ */


#ifndef __IAttribute_INTERFACE_DEFINED__
#define __IAttribute_INTERFACE_DEFINED__

/* interface IAttribute */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("B17A8D78-B5A6-45F7-BA21-01AB94B08415")
    IAttribute : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name(
            /* [retval][out] */ CAPICOM_ATTRIBUTE *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name(
            /* [in] */ CAPICOM_ATTRIBUTE newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value(
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value(
            /* [in] */ VARIANT newVal) = 0;

    };

#else   /* C style interface */

    typedef struct IAttributeVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IAttribute * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IAttribute * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IAttribute * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IAttribute * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IAttribute * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IAttribute * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IAttribute * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )(
            IAttribute * This,
            /* [retval][out] */ CAPICOM_ATTRIBUTE *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )(
            IAttribute * This,
            /* [in] */ CAPICOM_ATTRIBUTE newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )(
            IAttribute * This,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )(
            IAttribute * This,
            /* [in] */ VARIANT newVal);

        END_INTERFACE
    } IAttributeVtbl;

    interface IAttribute
    {
        CONST_VTBL struct IAttributeVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IAttribute_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAttribute_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IAttribute_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IAttribute_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAttribute_get_Name(This,pVal)  \
    (This)->lpVtbl -> get_Name(This,pVal)

#define IAttribute_put_Name(This,newVal)    \
    (This)->lpVtbl -> put_Name(This,newVal)

#define IAttribute_get_Value(This,pVal) \
    (This)->lpVtbl -> get_Value(This,pVal)

#define IAttribute_put_Value(This,newVal)   \
    (This)->lpVtbl -> put_Value(This,newVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAttribute_get_Name_Proxy(
    IAttribute * This,
    /* [retval][out] */ CAPICOM_ATTRIBUTE *pVal);


void __RPC_STUB IAttribute_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAttribute_put_Name_Proxy(
    IAttribute * This,
    /* [in] */ CAPICOM_ATTRIBUTE newVal);


void __RPC_STUB IAttribute_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAttribute_get_Value_Proxy(
    IAttribute * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IAttribute_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAttribute_put_Value_Proxy(
    IAttribute * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IAttribute_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IAttribute_INTERFACE_DEFINED__ */


#ifndef __IAttributes_INTERFACE_DEFINED__
#define __IAttributes_INTERFACE_DEFINED__

/* interface IAttributes */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("6ADC653E-D5B9-422A-991A-A2B0119CEDAC")
    IAttributes : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add(
            /* [in] */ IAttribute *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove(
            /* [in] */ long Index) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;

    };

#else   /* C style interface */

    typedef struct IAttributesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IAttributes * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IAttributes * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IAttributes * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IAttributes * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IAttributes * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IAttributes * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            IAttributes * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            IAttributes * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            IAttributes * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )(
            IAttributes * This,
            /* [in] */ IAttribute *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )(
            IAttributes * This,
            /* [in] */ long Index);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )(
            IAttributes * This);

        END_INTERFACE
    } IAttributesVtbl;

    interface IAttributes
    {
        CONST_VTBL struct IAttributesVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IAttributes_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAttributes_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IAttributes_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IAttributes_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAttributes_get_Item(This,Index,pVal)   \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IAttributes_get_Count(This,pVal)    \
    (This)->lpVtbl -> get_Count(This,pVal)

#define IAttributes_get__NewEnum(This,pVal) \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IAttributes_Add(This,pVal)  \
    (This)->lpVtbl -> Add(This,pVal)

#define IAttributes_Remove(This,Index)  \
    (This)->lpVtbl -> Remove(This,Index)

#define IAttributes_Clear(This) \
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAttributes_get_Item_Proxy(
    IAttributes * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IAttributes_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAttributes_get_Count_Proxy(
    IAttributes * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IAttributes_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAttributes_get__NewEnum_Proxy(
    IAttributes * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IAttributes_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAttributes_Add_Proxy(
    IAttributes * This,
    /* [in] */ IAttribute *pVal);


void __RPC_STUB IAttributes_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAttributes_Remove_Proxy(
    IAttributes * This,
    /* [in] */ long Index);


void __RPC_STUB IAttributes_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAttributes_Clear_Proxy(
    IAttributes * This);


void __RPC_STUB IAttributes_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IAttributes_INTERFACE_DEFINED__ */


#ifndef __ISigner_INTERFACE_DEFINED__
#define __ISigner_INTERFACE_DEFINED__

/* interface ISigner */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ISigner;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("51017B88-1913-49AD-82BE-6BB7C417DCF2")
    ISigner : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Certificate(
            /* [retval][out] */ ICertificate **pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Certificate(
            /* [in] */ ICertificate *newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AuthenticatedAttributes(
            /* [retval][out] */ IAttributes **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct ISignerVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ISigner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ISigner * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ISigner * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ISigner * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ISigner * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ISigner * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ISigner * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificate )(
            ISigner * This,
            /* [retval][out] */ ICertificate **pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Certificate )(
            ISigner * This,
            /* [in] */ ICertificate *newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticatedAttributes )(
            ISigner * This,
            /* [retval][out] */ IAttributes **pVal);

        END_INTERFACE
    } ISignerVtbl;

    interface ISigner
    {
        CONST_VTBL struct ISignerVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ISigner_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISigner_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define ISigner_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define ISigner_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISigner_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISigner_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISigner_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISigner_get_Certificate(This,pVal)  \
    (This)->lpVtbl -> get_Certificate(This,pVal)

#define ISigner_put_Certificate(This,newVal)    \
    (This)->lpVtbl -> put_Certificate(This,newVal)

#define ISigner_get_AuthenticatedAttributes(This,pVal)  \
    (This)->lpVtbl -> get_AuthenticatedAttributes(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISigner_get_Certificate_Proxy(
    ISigner * This,
    /* [retval][out] */ ICertificate **pVal);


void __RPC_STUB ISigner_get_Certificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISigner_put_Certificate_Proxy(
    ISigner * This,
    /* [in] */ ICertificate *newVal);


void __RPC_STUB ISigner_put_Certificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISigner_get_AuthenticatedAttributes_Proxy(
    ISigner * This,
    /* [retval][out] */ IAttributes **pVal);


void __RPC_STUB ISigner_get_AuthenticatedAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISigner_INTERFACE_DEFINED__ */


#ifndef __ISigners_INTERFACE_DEFINED__
#define __ISigners_INTERFACE_DEFINED__

/* interface ISigners */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ISigners;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("5A0780F8-9E6B-4BB0-BF54-87CD9627A8B4")
    ISigners : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct ISignersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ISigners * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ISigners * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ISigners * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ISigners * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ISigners * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ISigners * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ISigners * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            ISigners * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            ISigners * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            ISigners * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        END_INTERFACE
    } ISignersVtbl;

    interface ISigners
    {
        CONST_VTBL struct ISignersVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ISigners_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISigners_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISigners_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISigners_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISigners_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISigners_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISigners_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISigners_get_Item(This,Index,pVal)  \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define ISigners_get_Count(This,pVal)   \
    (This)->lpVtbl -> get_Count(This,pVal)

#define ISigners_get__NewEnum(This,pVal)    \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISigners_get_Item_Proxy(
    ISigners * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ISigners_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISigners_get_Count_Proxy(
    ISigners * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ISigners_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISigners_get__NewEnum_Proxy(
    ISigners * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB ISigners_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISigners_INTERFACE_DEFINED__ */


#ifndef __ISignedData_INTERFACE_DEFINED__
#define __ISignedData_INTERFACE_DEFINED__

/* interface ISignedData */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ISignedData;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("AE9C454B-FC65-4C10-B130-CD9B45BA948B")
    ISignedData : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Content(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Content(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Signers(
            /* [retval][out] */ ISigners **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Certificates(
            /* [retval][out] */ ICertificates **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Sign(
            /* [defaultvalue][in] */ ISigner *pSigner,
            /* [defaultvalue][in] */ VARIANT_BOOL bDetached,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CoSign(
            /* [defaultvalue][in] */ ISigner *pSigner,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Verify(
            /* [in] */ BSTR SignedMessage,
            /* [defaultvalue][in] */ VARIANT_BOOL bDetached = 0,
            /* [defaultvalue][in] */ CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag = CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE) = 0;

    };

#else   /* C style interface */

    typedef struct ISignedDataVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ISignedData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ISignedData * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ISignedData * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ISignedData * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ISignedData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ISignedData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ISignedData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Content )(
            ISignedData * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Content )(
            ISignedData * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Signers )(
            ISignedData * This,
            /* [retval][out] */ ISigners **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificates )(
            ISignedData * This,
            /* [retval][out] */ ICertificates **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Sign )(
            ISignedData * This,
            /* [defaultvalue][in] */ ISigner *pSigner,
            /* [defaultvalue][in] */ VARIANT_BOOL bDetached,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CoSign )(
            ISignedData * This,
            /* [defaultvalue][in] */ ISigner *pSigner,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Verify )(
            ISignedData * This,
            /* [in] */ BSTR SignedMessage,
            /* [defaultvalue][in] */ VARIANT_BOOL bDetached,
            /* [defaultvalue][in] */ CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag);

        END_INTERFACE
    } ISignedDataVtbl;

    interface ISignedData
    {
        CONST_VTBL struct ISignedDataVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ISignedData_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISignedData_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define ISignedData_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define ISignedData_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISignedData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISignedData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISignedData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISignedData_put_Content(This,newVal)    \
    (This)->lpVtbl -> put_Content(This,newVal)

#define ISignedData_get_Content(This,pVal)  \
    (This)->lpVtbl -> get_Content(This,pVal)

#define ISignedData_get_Signers(This,pVal)  \
    (This)->lpVtbl -> get_Signers(This,pVal)

#define ISignedData_get_Certificates(This,pVal) \
    (This)->lpVtbl -> get_Certificates(This,pVal)

#define ISignedData_Sign(This,pSigner,bDetached,EncodingType,pVal)  \
    (This)->lpVtbl -> Sign(This,pSigner,bDetached,EncodingType,pVal)

#define ISignedData_CoSign(This,pSigner,EncodingType,pVal)  \
    (This)->lpVtbl -> CoSign(This,pSigner,EncodingType,pVal)

#define ISignedData_Verify(This,SignedMessage,bDetached,VerifyFlag) \
    (This)->lpVtbl -> Verify(This,SignedMessage,bDetached,VerifyFlag)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISignedData_put_Content_Proxy(
    ISignedData * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISignedData_put_Content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedData_get_Content_Proxy(
    ISignedData * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ISignedData_get_Content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedData_get_Signers_Proxy(
    ISignedData * This,
    /* [retval][out] */ ISigners **pVal);


void __RPC_STUB ISignedData_get_Signers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedData_get_Certificates_Proxy(
    ISignedData * This,
    /* [retval][out] */ ICertificates **pVal);


void __RPC_STUB ISignedData_get_Certificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISignedData_Sign_Proxy(
    ISignedData * This,
    /* [defaultvalue][in] */ ISigner *pSigner,
    /* [defaultvalue][in] */ VARIANT_BOOL bDetached,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ISignedData_Sign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISignedData_CoSign_Proxy(
    ISignedData * This,
    /* [defaultvalue][in] */ ISigner *pSigner,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ISignedData_CoSign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISignedData_Verify_Proxy(
    ISignedData * This,
    /* [in] */ BSTR SignedMessage,
    /* [defaultvalue][in] */ VARIANT_BOOL bDetached,
    /* [defaultvalue][in] */ CAPICOM_SIGNED_DATA_VERIFY_FLAG VerifyFlag);


void __RPC_STUB ISignedData_Verify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISignedData_INTERFACE_DEFINED__ */


#ifndef __IAlgorithm_INTERFACE_DEFINED__
#define __IAlgorithm_INTERFACE_DEFINED__

/* interface IAlgorithm */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IAlgorithm;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("BF3D04A9-B0DA-4153-B45E-6CCFA5AC715B")
    IAlgorithm : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name(
            /* [retval][out] */ CAPICOM_ENCRYPTION_ALGORITHM *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name(
            /* [in] */ CAPICOM_ENCRYPTION_ALGORITHM newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeyLength(
            /* [retval][out] */ CAPICOM_ENCRYPTION_KEY_LENGTH *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_KeyLength(
            /* [in] */ CAPICOM_ENCRYPTION_KEY_LENGTH newVal) = 0;

    };

#else   /* C style interface */

    typedef struct IAlgorithmVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IAlgorithm * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IAlgorithm * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IAlgorithm * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IAlgorithm * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IAlgorithm * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IAlgorithm * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IAlgorithm * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )(
            IAlgorithm * This,
            /* [retval][out] */ CAPICOM_ENCRYPTION_ALGORITHM *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )(
            IAlgorithm * This,
            /* [in] */ CAPICOM_ENCRYPTION_ALGORITHM newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyLength )(
            IAlgorithm * This,
            /* [retval][out] */ CAPICOM_ENCRYPTION_KEY_LENGTH *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_KeyLength )(
            IAlgorithm * This,
            /* [in] */ CAPICOM_ENCRYPTION_KEY_LENGTH newVal);

        END_INTERFACE
    } IAlgorithmVtbl;

    interface IAlgorithm
    {
        CONST_VTBL struct IAlgorithmVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IAlgorithm_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAlgorithm_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IAlgorithm_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IAlgorithm_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAlgorithm_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAlgorithm_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAlgorithm_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAlgorithm_get_Name(This,pVal)  \
    (This)->lpVtbl -> get_Name(This,pVal)

#define IAlgorithm_put_Name(This,newVal)    \
    (This)->lpVtbl -> put_Name(This,newVal)

#define IAlgorithm_get_KeyLength(This,pVal) \
    (This)->lpVtbl -> get_KeyLength(This,pVal)

#define IAlgorithm_put_KeyLength(This,newVal)   \
    (This)->lpVtbl -> put_KeyLength(This,newVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAlgorithm_get_Name_Proxy(
    IAlgorithm * This,
    /* [retval][out] */ CAPICOM_ENCRYPTION_ALGORITHM *pVal);


void __RPC_STUB IAlgorithm_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAlgorithm_put_Name_Proxy(
    IAlgorithm * This,
    /* [in] */ CAPICOM_ENCRYPTION_ALGORITHM newVal);


void __RPC_STUB IAlgorithm_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAlgorithm_get_KeyLength_Proxy(
    IAlgorithm * This,
    /* [retval][out] */ CAPICOM_ENCRYPTION_KEY_LENGTH *pVal);


void __RPC_STUB IAlgorithm_get_KeyLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAlgorithm_put_KeyLength_Proxy(
    IAlgorithm * This,
    /* [in] */ CAPICOM_ENCRYPTION_KEY_LENGTH newVal);


void __RPC_STUB IAlgorithm_put_KeyLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IAlgorithm_INTERFACE_DEFINED__ */


#ifndef __IRecipients_INTERFACE_DEFINED__
#define __IRecipients_INTERFACE_DEFINED__

/* interface IRecipients */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IRecipients;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("A694C896-FC38-4C34-AE61-3B1A95984C14")
    IRecipients : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add(
            /* [in] */ ICertificate *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove(
            /* [in] */ long Index) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;

    };

#else   /* C style interface */

    typedef struct IRecipientsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IRecipients * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IRecipients * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IRecipients * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IRecipients * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IRecipients * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IRecipients * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IRecipients * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            IRecipients * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            IRecipients * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            IRecipients * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )(
            IRecipients * This,
            /* [in] */ ICertificate *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )(
            IRecipients * This,
            /* [in] */ long Index);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )(
            IRecipients * This);

        END_INTERFACE
    } IRecipientsVtbl;

    interface IRecipients
    {
        CONST_VTBL struct IRecipientsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IRecipients_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecipients_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IRecipients_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IRecipients_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRecipients_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRecipients_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRecipients_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRecipients_get_Item(This,Index,pVal)   \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IRecipients_get_Count(This,pVal)    \
    (This)->lpVtbl -> get_Count(This,pVal)

#define IRecipients_get__NewEnum(This,pVal) \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IRecipients_Add(This,pVal)  \
    (This)->lpVtbl -> Add(This,pVal)

#define IRecipients_Remove(This,Index)  \
    (This)->lpVtbl -> Remove(This,Index)

#define IRecipients_Clear(This) \
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRecipients_get_Item_Proxy(
    IRecipients * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IRecipients_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRecipients_get_Count_Proxy(
    IRecipients * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IRecipients_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRecipients_get__NewEnum_Proxy(
    IRecipients * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IRecipients_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRecipients_Add_Proxy(
    IRecipients * This,
    /* [in] */ ICertificate *pVal);


void __RPC_STUB IRecipients_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRecipients_Remove_Proxy(
    IRecipients * This,
    /* [in] */ long Index);


void __RPC_STUB IRecipients_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRecipients_Clear_Proxy(
    IRecipients * This);


void __RPC_STUB IRecipients_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IRecipients_INTERFACE_DEFINED__ */


#ifndef __IEnvelopedData_INTERFACE_DEFINED__
#define __IEnvelopedData_INTERFACE_DEFINED__

/* interface IEnvelopedData */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IEnvelopedData;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("F6CB6A20-CC18-4424-AE57-6F2AA3DC2059")
    IEnvelopedData : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Content(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Content(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Algorithm(
            /* [retval][out] */ IAlgorithm **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recipients(
            /* [retval][out] */ IRecipients **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt(
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt(
            /* [in] */ BSTR EnvelopedMessage) = 0;

    };

#else   /* C style interface */

    typedef struct IEnvelopedDataVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IEnvelopedData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IEnvelopedData * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IEnvelopedData * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IEnvelopedData * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IEnvelopedData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IEnvelopedData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IEnvelopedData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Content )(
            IEnvelopedData * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Content )(
            IEnvelopedData * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Algorithm )(
            IEnvelopedData * This,
            /* [retval][out] */ IAlgorithm **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recipients )(
            IEnvelopedData * This,
            /* [retval][out] */ IRecipients **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Encrypt )(
            IEnvelopedData * This,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decrypt )(
            IEnvelopedData * This,
            /* [in] */ BSTR EnvelopedMessage);

        END_INTERFACE
    } IEnvelopedDataVtbl;

    interface IEnvelopedData
    {
        CONST_VTBL struct IEnvelopedDataVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnvelopedData_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnvelopedData_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IEnvelopedData_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEnvelopedData_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEnvelopedData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEnvelopedData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEnvelopedData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEnvelopedData_put_Content(This,newVal) \
    (This)->lpVtbl -> put_Content(This,newVal)

#define IEnvelopedData_get_Content(This,pVal)   \
    (This)->lpVtbl -> get_Content(This,pVal)

#define IEnvelopedData_get_Algorithm(This,pVal) \
    (This)->lpVtbl -> get_Algorithm(This,pVal)

#define IEnvelopedData_get_Recipients(This,pVal)    \
    (This)->lpVtbl -> get_Recipients(This,pVal)

#define IEnvelopedData_Encrypt(This,EncodingType,pVal)  \
    (This)->lpVtbl -> Encrypt(This,EncodingType,pVal)

#define IEnvelopedData_Decrypt(This,EnvelopedMessage)   \
    (This)->lpVtbl -> Decrypt(This,EnvelopedMessage)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEnvelopedData_put_Content_Proxy(
    IEnvelopedData * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IEnvelopedData_put_Content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEnvelopedData_get_Content_Proxy(
    IEnvelopedData * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEnvelopedData_get_Content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEnvelopedData_get_Algorithm_Proxy(
    IEnvelopedData * This,
    /* [retval][out] */ IAlgorithm **pVal);


void __RPC_STUB IEnvelopedData_get_Algorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEnvelopedData_get_Recipients_Proxy(
    IEnvelopedData * This,
    /* [retval][out] */ IRecipients **pVal);


void __RPC_STUB IEnvelopedData_get_Recipients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnvelopedData_Encrypt_Proxy(
    IEnvelopedData * This,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEnvelopedData_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnvelopedData_Decrypt_Proxy(
    IEnvelopedData * This,
    /* [in] */ BSTR EnvelopedMessage);


void __RPC_STUB IEnvelopedData_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnvelopedData_INTERFACE_DEFINED__ */


#ifndef __IEncryptedData_INTERFACE_DEFINED__
#define __IEncryptedData_INTERFACE_DEFINED__

/* interface IEncryptedData */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IEncryptedData;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C4778A66-972F-42E4-87C5-5CC16F7931CA")
    IEncryptedData : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Content(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Content(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Algorithm(
            /* [retval][out] */ IAlgorithm **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecret(
            /* [in] */ BSTR newVal,
            /* [defaultvalue][in] */ CAPICOM_SECRET_TYPE SecretType = CAPICOM_SECRET_PASSWORD) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt(
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt(
            /* [in] */ BSTR EncryptedMessage) = 0;

    };

#else   /* C style interface */

    typedef struct IEncryptedDataVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IEncryptedData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IEncryptedData * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IEncryptedData * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IEncryptedData * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IEncryptedData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IEncryptedData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IEncryptedData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Content )(
            IEncryptedData * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Content )(
            IEncryptedData * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Algorithm )(
            IEncryptedData * This,
            /* [retval][out] */ IAlgorithm **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecret )(
            IEncryptedData * This,
            /* [in] */ BSTR newVal,
            /* [defaultvalue][in] */ CAPICOM_SECRET_TYPE SecretType);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Encrypt )(
            IEncryptedData * This,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decrypt )(
            IEncryptedData * This,
            /* [in] */ BSTR EncryptedMessage);

        END_INTERFACE
    } IEncryptedDataVtbl;

    interface IEncryptedData
    {
        CONST_VTBL struct IEncryptedDataVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IEncryptedData_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEncryptedData_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IEncryptedData_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEncryptedData_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEncryptedData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEncryptedData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEncryptedData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEncryptedData_put_Content(This,newVal) \
    (This)->lpVtbl -> put_Content(This,newVal)

#define IEncryptedData_get_Content(This,pVal)   \
    (This)->lpVtbl -> get_Content(This,pVal)

#define IEncryptedData_get_Algorithm(This,pVal) \
    (This)->lpVtbl -> get_Algorithm(This,pVal)

#define IEncryptedData_SetSecret(This,newVal,SecretType)    \
    (This)->lpVtbl -> SetSecret(This,newVal,SecretType)

#define IEncryptedData_Encrypt(This,EncodingType,pVal)  \
    (This)->lpVtbl -> Encrypt(This,EncodingType,pVal)

#define IEncryptedData_Decrypt(This,EncryptedMessage)   \
    (This)->lpVtbl -> Decrypt(This,EncryptedMessage)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IEncryptedData_put_Content_Proxy(
    IEncryptedData * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IEncryptedData_put_Content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEncryptedData_get_Content_Proxy(
    IEncryptedData * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEncryptedData_get_Content_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEncryptedData_get_Algorithm_Proxy(
    IEncryptedData * This,
    /* [retval][out] */ IAlgorithm **pVal);


void __RPC_STUB IEncryptedData_get_Algorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEncryptedData_SetSecret_Proxy(
    IEncryptedData * This,
    /* [in] */ BSTR newVal,
    /* [defaultvalue][in] */ CAPICOM_SECRET_TYPE SecretType);


void __RPC_STUB IEncryptedData_SetSecret_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEncryptedData_Encrypt_Proxy(
    IEncryptedData * This,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEncryptedData_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEncryptedData_Decrypt_Proxy(
    IEncryptedData * This,
    /* [in] */ BSTR EncryptedMessage);


void __RPC_STUB IEncryptedData_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEncryptedData_INTERFACE_DEFINED__ */


#ifndef __IOID_INTERFACE_DEFINED__
#define __IOID_INTERFACE_DEFINED__

/* interface IOID */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IOID;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("208E5E9B-58B1-4086-970F-161B582A846F")
    IOID : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name(
            /* [retval][out] */ CAPICOM_OID *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name(
            /* [in] */ CAPICOM_OID newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FriendlyName(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value(
            /* [in] */ BSTR newVal) = 0;

    };

#else   /* C style interface */

    typedef struct IOIDVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IOID * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IOID * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IOID * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IOID * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IOID * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IOID * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IOID * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )(
            IOID * This,
            /* [retval][out] */ CAPICOM_OID *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )(
            IOID * This,
            /* [in] */ CAPICOM_OID newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )(
            IOID * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FriendlyName )(
            IOID * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )(
            IOID * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )(
            IOID * This,
            /* [in] */ BSTR newVal);

        END_INTERFACE
    } IOIDVtbl;

    interface IOID
    {
        CONST_VTBL struct IOIDVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IOID_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOID_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IOID_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IOID_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IOID_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IOID_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IOID_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IOID_get_Name(This,pVal)    \
    (This)->lpVtbl -> get_Name(This,pVal)

#define IOID_put_Name(This,newVal)  \
    (This)->lpVtbl -> put_Name(This,newVal)

#define IOID_get_FriendlyName(This,pVal)    \
    (This)->lpVtbl -> get_FriendlyName(This,pVal)

#define IOID_put_FriendlyName(This,newVal)  \
    (This)->lpVtbl -> put_FriendlyName(This,newVal)

#define IOID_get_Value(This,pVal)   \
    (This)->lpVtbl -> get_Value(This,pVal)

#define IOID_put_Value(This,newVal) \
    (This)->lpVtbl -> put_Value(This,newVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IOID_get_Name_Proxy(
    IOID * This,
    /* [retval][out] */ CAPICOM_OID *pVal);


void __RPC_STUB IOID_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IOID_put_Name_Proxy(
    IOID * This,
    /* [in] */ CAPICOM_OID newVal);


void __RPC_STUB IOID_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IOID_get_FriendlyName_Proxy(
    IOID * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IOID_get_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IOID_put_FriendlyName_Proxy(
    IOID * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IOID_put_FriendlyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IOID_get_Value_Proxy(
    IOID * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IOID_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IOID_put_Value_Proxy(
    IOID * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IOID_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IOID_INTERFACE_DEFINED__ */


#ifndef __IOIDs_INTERFACE_DEFINED__
#define __IOIDs_INTERFACE_DEFINED__

/* interface IOIDs */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IOIDs;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("DA55E8FC-8E27-451B-AEA8-1470D80FAD42")
    IOIDs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add(
            /* [in] */ IOID *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove(
            /* [in] */ VARIANT Index) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;

    };

#else   /* C style interface */

    typedef struct IOIDsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IOIDs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IOIDs * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IOIDs * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IOIDs * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IOIDs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IOIDs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IOIDs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            IOIDs * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            IOIDs * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            IOIDs * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )(
            IOIDs * This,
            /* [in] */ IOID *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )(
            IOIDs * This,
            /* [in] */ VARIANT Index);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )(
            IOIDs * This);

        END_INTERFACE
    } IOIDsVtbl;

    interface IOIDs
    {
        CONST_VTBL struct IOIDsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IOIDs_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOIDs_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IOIDs_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IOIDs_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IOIDs_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IOIDs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IOIDs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IOIDs_get_Item(This,Index,pVal) \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IOIDs_get_Count(This,pVal)  \
    (This)->lpVtbl -> get_Count(This,pVal)

#define IOIDs_get__NewEnum(This,pVal)   \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IOIDs_Add(This,pVal)    \
    (This)->lpVtbl -> Add(This,pVal)

#define IOIDs_Remove(This,Index)    \
    (This)->lpVtbl -> Remove(This,Index)

#define IOIDs_Clear(This)   \
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IOIDs_get_Item_Proxy(
    IOIDs * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IOIDs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IOIDs_get_Count_Proxy(
    IOIDs * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IOIDs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IOIDs_get__NewEnum_Proxy(
    IOIDs * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IOIDs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IOIDs_Add_Proxy(
    IOIDs * This,
    /* [in] */ IOID *pVal);


void __RPC_STUB IOIDs_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IOIDs_Remove_Proxy(
    IOIDs * This,
    /* [in] */ VARIANT Index);


void __RPC_STUB IOIDs_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IOIDs_Clear_Proxy(
    IOIDs * This);


void __RPC_STUB IOIDs_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IOIDs_INTERFACE_DEFINED__ */


#ifndef __INoticeNumbers_INTERFACE_DEFINED__
#define __INoticeNumbers_INTERFACE_DEFINED__

/* interface INoticeNumbers */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_INoticeNumbers;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("EE2C051D-33A1-4157-86B4-9280E29782F2")
    INoticeNumbers : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct INoticeNumbersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            INoticeNumbers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            INoticeNumbers * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            INoticeNumbers * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            INoticeNumbers * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            INoticeNumbers * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            INoticeNumbers * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            INoticeNumbers * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            INoticeNumbers * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            INoticeNumbers * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            INoticeNumbers * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        END_INTERFACE
    } INoticeNumbersVtbl;

    interface INoticeNumbers
    {
        CONST_VTBL struct INoticeNumbersVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define INoticeNumbers_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INoticeNumbers_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define INoticeNumbers_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define INoticeNumbers_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INoticeNumbers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INoticeNumbers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INoticeNumbers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INoticeNumbers_get_Item(This,Index,pVal)    \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define INoticeNumbers_get_Count(This,pVal) \
    (This)->lpVtbl -> get_Count(This,pVal)

#define INoticeNumbers_get__NewEnum(This,pVal)  \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE INoticeNumbers_get_Item_Proxy(
    INoticeNumbers * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB INoticeNumbers_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE INoticeNumbers_get_Count_Proxy(
    INoticeNumbers * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB INoticeNumbers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE INoticeNumbers_get__NewEnum_Proxy(
    INoticeNumbers * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB INoticeNumbers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __INoticeNumbers_INTERFACE_DEFINED__ */


#ifndef __IQualifier_INTERFACE_DEFINED__
#define __IQualifier_INTERFACE_DEFINED__

/* interface IQualifier */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IQualifier;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3604C9DD-A22E-4A15-A469-8181C0C113DE")
    IQualifier : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OID(
            /* [retval][out] */ IOID **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CPSPointer(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OrganizationName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NoticeNumbers(
            /* [retval][out] */ INoticeNumbers **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExplicitText(
            /* [retval][out] */ BSTR *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IQualifierVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IQualifier * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IQualifier * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IQualifier * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IQualifier * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IQualifier * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IQualifier * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IQualifier * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OID )(
            IQualifier * This,
            /* [retval][out] */ IOID **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CPSPointer )(
            IQualifier * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OrganizationName )(
            IQualifier * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NoticeNumbers )(
            IQualifier * This,
            /* [retval][out] */ INoticeNumbers **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExplicitText )(
            IQualifier * This,
            /* [retval][out] */ BSTR *pVal);

        END_INTERFACE
    } IQualifierVtbl;

    interface IQualifier
    {
        CONST_VTBL struct IQualifierVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IQualifier_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQualifier_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IQualifier_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IQualifier_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IQualifier_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IQualifier_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IQualifier_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IQualifier_get_OID(This,pVal)   \
    (This)->lpVtbl -> get_OID(This,pVal)

#define IQualifier_get_CPSPointer(This,pVal)    \
    (This)->lpVtbl -> get_CPSPointer(This,pVal)

#define IQualifier_get_OrganizationName(This,pVal)  \
    (This)->lpVtbl -> get_OrganizationName(This,pVal)

#define IQualifier_get_NoticeNumbers(This,pVal) \
    (This)->lpVtbl -> get_NoticeNumbers(This,pVal)

#define IQualifier_get_ExplicitText(This,pVal)  \
    (This)->lpVtbl -> get_ExplicitText(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifier_get_OID_Proxy(
    IQualifier * This,
    /* [retval][out] */ IOID **pVal);


void __RPC_STUB IQualifier_get_OID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifier_get_CPSPointer_Proxy(
    IQualifier * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IQualifier_get_CPSPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifier_get_OrganizationName_Proxy(
    IQualifier * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IQualifier_get_OrganizationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifier_get_NoticeNumbers_Proxy(
    IQualifier * This,
    /* [retval][out] */ INoticeNumbers **pVal);


void __RPC_STUB IQualifier_get_NoticeNumbers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifier_get_ExplicitText_Proxy(
    IQualifier * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IQualifier_get_ExplicitText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IQualifier_INTERFACE_DEFINED__ */


#ifndef __IQualifiers_INTERFACE_DEFINED__
#define __IQualifiers_INTERFACE_DEFINED__

/* interface IQualifiers */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IQualifiers;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("6B5A8AB6-597D-4398-AC63-1036EF546348")
    IQualifiers : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IQualifiersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IQualifiers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IQualifiers * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IQualifiers * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IQualifiers * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IQualifiers * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IQualifiers * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IQualifiers * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            IQualifiers * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            IQualifiers * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            IQualifiers * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        END_INTERFACE
    } IQualifiersVtbl;

    interface IQualifiers
    {
        CONST_VTBL struct IQualifiersVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IQualifiers_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQualifiers_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IQualifiers_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IQualifiers_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IQualifiers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IQualifiers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IQualifiers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IQualifiers_get_Item(This,Index,pVal)   \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IQualifiers_get_Count(This,pVal)    \
    (This)->lpVtbl -> get_Count(This,pVal)

#define IQualifiers_get__NewEnum(This,pVal) \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifiers_get_Item_Proxy(
    IQualifiers * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IQualifiers_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifiers_get_Count_Proxy(
    IQualifiers * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IQualifiers_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IQualifiers_get__NewEnum_Proxy(
    IQualifiers * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IQualifiers_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IQualifiers_INTERFACE_DEFINED__ */


#ifndef __IPolicyInformation_INTERFACE_DEFINED__
#define __IPolicyInformation_INTERFACE_DEFINED__

/* interface IPolicyInformation */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IPolicyInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("8973710C-8411-4951-9E65-D45FD524FFDF")
    IPolicyInformation : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OID(
            /* [retval][out] */ IOID **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Qualifiers(
            /* [retval][out] */ IQualifiers **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IPolicyInformationVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IPolicyInformation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IPolicyInformation * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IPolicyInformation * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IPolicyInformation * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IPolicyInformation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IPolicyInformation * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IPolicyInformation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OID )(
            IPolicyInformation * This,
            /* [retval][out] */ IOID **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Qualifiers )(
            IPolicyInformation * This,
            /* [retval][out] */ IQualifiers **pVal);

        END_INTERFACE
    } IPolicyInformationVtbl;

    interface IPolicyInformation
    {
        CONST_VTBL struct IPolicyInformationVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IPolicyInformation_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPolicyInformation_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IPolicyInformation_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IPolicyInformation_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPolicyInformation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPolicyInformation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPolicyInformation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPolicyInformation_get_OID(This,pVal)   \
    (This)->lpVtbl -> get_OID(This,pVal)

#define IPolicyInformation_get_Qualifiers(This,pVal)    \
    (This)->lpVtbl -> get_Qualifiers(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPolicyInformation_get_OID_Proxy(
    IPolicyInformation * This,
    /* [retval][out] */ IOID **pVal);


void __RPC_STUB IPolicyInformation_get_OID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPolicyInformation_get_Qualifiers_Proxy(
    IPolicyInformation * This,
    /* [retval][out] */ IQualifiers **pVal);


void __RPC_STUB IPolicyInformation_get_Qualifiers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPolicyInformation_INTERFACE_DEFINED__ */


#ifndef __ICertificatePolicies_INTERFACE_DEFINED__
#define __ICertificatePolicies_INTERFACE_DEFINED__

/* interface ICertificatePolicies */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ICertificatePolicies;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("CC7A72A7-C83A-4049-85F4-4292DE9DBFD3")
    ICertificatePolicies : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct ICertificatePoliciesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertificatePolicies * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertificatePolicies * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertificatePolicies * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ICertificatePolicies * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ICertificatePolicies * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ICertificatePolicies * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ICertificatePolicies * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            ICertificatePolicies * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            ICertificatePolicies * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            ICertificatePolicies * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        END_INTERFACE
    } ICertificatePoliciesVtbl;

    interface ICertificatePolicies
    {
        CONST_VTBL struct ICertificatePoliciesVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertificatePolicies_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertificatePolicies_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ICertificatePolicies_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ICertificatePolicies_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertificatePolicies_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertificatePolicies_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertificatePolicies_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertificatePolicies_get_Item(This,Index,pVal)  \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define ICertificatePolicies_get_Count(This,pVal)   \
    (This)->lpVtbl -> get_Count(This,pVal)

#define ICertificatePolicies_get__NewEnum(This,pVal)    \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificatePolicies_get_Item_Proxy(
    ICertificatePolicies * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ICertificatePolicies_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificatePolicies_get_Count_Proxy(
    ICertificatePolicies * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ICertificatePolicies_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificatePolicies_get__NewEnum_Proxy(
    ICertificatePolicies * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB ICertificatePolicies_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertificatePolicies_INTERFACE_DEFINED__ */


#ifndef __IEncodedData_INTERFACE_DEFINED__
#define __IEncodedData_INTERFACE_DEFINED__

/* interface IEncodedData */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IEncodedData;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("D3D460F2-E7F3-4AF3-8EC6-8EB68C61C567")
    IEncodedData : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value(
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Format(
            /* [defaultvalue][in] */ VARIANT_BOOL bMultiLines,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decoder(
            /* [retval][out] */ IDispatch **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IEncodedDataVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IEncodedData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IEncodedData * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IEncodedData * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IEncodedData * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IEncodedData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IEncodedData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IEncodedData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )(
            IEncodedData * This,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Format )(
            IEncodedData * This,
            /* [defaultvalue][in] */ VARIANT_BOOL bMultiLines,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decoder )(
            IEncodedData * This,
            /* [retval][out] */ IDispatch **pVal);

        END_INTERFACE
    } IEncodedDataVtbl;

    interface IEncodedData
    {
        CONST_VTBL struct IEncodedDataVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IEncodedData_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEncodedData_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEncodedData_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEncodedData_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEncodedData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEncodedData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEncodedData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEncodedData_get_Value(This,EncodingType,pVal)  \
    (This)->lpVtbl -> get_Value(This,EncodingType,pVal)

#define IEncodedData_Format(This,bMultiLines,pVal)  \
    (This)->lpVtbl -> Format(This,bMultiLines,pVal)

#define IEncodedData_Decoder(This,pVal) \
    (This)->lpVtbl -> Decoder(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEncodedData_get_Value_Proxy(
    IEncodedData * This,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEncodedData_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEncodedData_Format_Proxy(
    IEncodedData * This,
    /* [defaultvalue][in] */ VARIANT_BOOL bMultiLines,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEncodedData_Format_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEncodedData_Decoder_Proxy(
    IEncodedData * This,
    /* [retval][out] */ IDispatch **pVal);


void __RPC_STUB IEncodedData_Decoder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEncodedData_INTERFACE_DEFINED__ */


#ifndef __IExtension_INTERFACE_DEFINED__
#define __IExtension_INTERFACE_DEFINED__

/* interface IExtension */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("ED4E4ED4-FDD8-476E-AED9-5239E7948257")
    IExtension : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OID(
            /* [retval][out] */ IOID **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCritical(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EncodedData(
            /* [retval][out] */ IEncodedData **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IExtensionVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IExtension * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IExtension * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IExtension * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IExtension * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IExtension * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IExtension * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OID )(
            IExtension * This,
            /* [retval][out] */ IOID **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCritical )(
            IExtension * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncodedData )(
            IExtension * This,
            /* [retval][out] */ IEncodedData **pVal);

        END_INTERFACE
    } IExtensionVtbl;

    interface IExtension
    {
        CONST_VTBL struct IExtensionVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IExtension_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtension_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IExtension_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IExtension_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExtension_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExtension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExtension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExtension_get_OID(This,pVal)   \
    (This)->lpVtbl -> get_OID(This,pVal)

#define IExtension_get_IsCritical(This,pVal)    \
    (This)->lpVtbl -> get_IsCritical(This,pVal)

#define IExtension_get_EncodedData(This,pVal)   \
    (This)->lpVtbl -> get_EncodedData(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtension_get_OID_Proxy(
    IExtension * This,
    /* [retval][out] */ IOID **pVal);


void __RPC_STUB IExtension_get_OID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtension_get_IsCritical_Proxy(
    IExtension * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IExtension_get_IsCritical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtension_get_EncodedData_Proxy(
    IExtension * This,
    /* [retval][out] */ IEncodedData **pVal);


void __RPC_STUB IExtension_get_EncodedData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IExtension_INTERFACE_DEFINED__ */


#ifndef __IExtensions_INTERFACE_DEFINED__
#define __IExtensions_INTERFACE_DEFINED__

/* interface IExtensions */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IExtensions;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("BC530D61-E692-4225-9E7A-07B90B45856A")
    IExtensions : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IExtensionsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IExtensions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IExtensions * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IExtensions * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IExtensions * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IExtensions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IExtensions * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IExtensions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            IExtensions * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            IExtensions * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            IExtensions * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        END_INTERFACE
    } IExtensionsVtbl;

    interface IExtensions
    {
        CONST_VTBL struct IExtensionsVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IExtensions_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtensions_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IExtensions_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IExtensions_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExtensions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExtensions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExtensions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExtensions_get_Item(This,Index,pVal)   \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IExtensions_get_Count(This,pVal)    \
    (This)->lpVtbl -> get_Count(This,pVal)

#define IExtensions_get__NewEnum(This,pVal) \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtensions_get_Item_Proxy(
    IExtensions * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IExtensions_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtensions_get_Count_Proxy(
    IExtensions * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IExtensions_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtensions_get__NewEnum_Proxy(
    IExtensions * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IExtensions_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IExtensions_INTERFACE_DEFINED__ */


#ifndef __IExtendedProperty_INTERFACE_DEFINED__
#define __IExtendedProperty_INTERFACE_DEFINED__

/* interface IExtendedProperty */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IExtendedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("ECB8A5C8-562C-4989-B49D-FA37D40F8FC4")
    IExtendedProperty : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PropID(
            /* [retval][out] */ CAPICOM_PROPID *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PropID(
            /* [in] */ CAPICOM_PROPID newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value(
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Value(
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [in] */ BSTR newVal) = 0;

    };

#else   /* C style interface */

    typedef struct IExtendedPropertyVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IExtendedProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IExtendedProperty * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IExtendedProperty * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IExtendedProperty * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IExtendedProperty * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IExtendedProperty * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IExtendedProperty * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropID )(
            IExtendedProperty * This,
            /* [retval][out] */ CAPICOM_PROPID *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PropID )(
            IExtendedProperty * This,
            /* [in] */ CAPICOM_PROPID newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )(
            IExtendedProperty * This,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Value )(
            IExtendedProperty * This,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [in] */ BSTR newVal);

        END_INTERFACE
    } IExtendedPropertyVtbl;

    interface IExtendedProperty
    {
        CONST_VTBL struct IExtendedPropertyVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IExtendedProperty_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendedProperty_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IExtendedProperty_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IExtendedProperty_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExtendedProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExtendedProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExtendedProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExtendedProperty_get_PropID(This,pVal) \
    (This)->lpVtbl -> get_PropID(This,pVal)

#define IExtendedProperty_put_PropID(This,newVal)   \
    (This)->lpVtbl -> put_PropID(This,newVal)

#define IExtendedProperty_get_Value(This,EncodingType,pVal) \
    (This)->lpVtbl -> get_Value(This,EncodingType,pVal)

#define IExtendedProperty_put_Value(This,EncodingType,newVal)   \
    (This)->lpVtbl -> put_Value(This,EncodingType,newVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedProperty_get_PropID_Proxy(
    IExtendedProperty * This,
    /* [retval][out] */ CAPICOM_PROPID *pVal);


void __RPC_STUB IExtendedProperty_get_PropID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IExtendedProperty_put_PropID_Proxy(
    IExtendedProperty * This,
    /* [in] */ CAPICOM_PROPID newVal);


void __RPC_STUB IExtendedProperty_put_PropID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedProperty_get_Value_Proxy(
    IExtendedProperty * This,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IExtendedProperty_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IExtendedProperty_put_Value_Proxy(
    IExtendedProperty * This,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [in] */ BSTR newVal);


void __RPC_STUB IExtendedProperty_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IExtendedProperty_INTERFACE_DEFINED__ */


#ifndef __IExtendedProperties_INTERFACE_DEFINED__
#define __IExtendedProperties_INTERFACE_DEFINED__

/* interface IExtendedProperties */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IExtendedProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3B096E87-6218-4A3B-A880-F6CB951E7805")
    IExtendedProperties : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item(
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum(
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add(
            /* [in] */ IExtendedProperty *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove(
            /* [in] */ CAPICOM_PROPID PropId) = 0;

    };

#else   /* C style interface */

    typedef struct IExtendedPropertiesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IExtendedProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IExtendedProperties * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IExtendedProperties * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IExtendedProperties * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IExtendedProperties * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IExtendedProperties * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IExtendedProperties * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            IExtendedProperties * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            IExtendedProperties * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            IExtendedProperties * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )(
            IExtendedProperties * This,
            /* [in] */ IExtendedProperty *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )(
            IExtendedProperties * This,
            /* [in] */ CAPICOM_PROPID PropId);

        END_INTERFACE
    } IExtendedPropertiesVtbl;

    interface IExtendedProperties
    {
        CONST_VTBL struct IExtendedPropertiesVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IExtendedProperties_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendedProperties_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IExtendedProperties_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IExtendedProperties_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExtendedProperties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExtendedProperties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExtendedProperties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExtendedProperties_get_Item(This,Index,pVal)   \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define IExtendedProperties_get_Count(This,pVal)    \
    (This)->lpVtbl -> get_Count(This,pVal)

#define IExtendedProperties_get__NewEnum(This,pVal) \
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IExtendedProperties_Add(This,pVal)  \
    (This)->lpVtbl -> Add(This,pVal)

#define IExtendedProperties_Remove(This,PropId) \
    (This)->lpVtbl -> Remove(This,PropId)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedProperties_get_Item_Proxy(
    IExtendedProperties * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IExtendedProperties_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedProperties_get_Count_Proxy(
    IExtendedProperties * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IExtendedProperties_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IExtendedProperties_get__NewEnum_Proxy(
    IExtendedProperties * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IExtendedProperties_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IExtendedProperties_Add_Proxy(
    IExtendedProperties * This,
    /* [in] */ IExtendedProperty *pVal);


void __RPC_STUB IExtendedProperties_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IExtendedProperties_Remove_Proxy(
    IExtendedProperties * This,
    /* [in] */ CAPICOM_PROPID PropId);


void __RPC_STUB IExtendedProperties_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IExtendedProperties_INTERFACE_DEFINED__ */


#ifndef __ITemplate_INTERFACE_DEFINED__
#define __ITemplate_INTERFACE_DEFINED__

/* interface ITemplate */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ITemplate;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("5F10FFCE-C922-476F-AA76-DF99D5BDFA2C")
    ITemplate : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsPresent(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCritical(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OID(
            /* [retval][out] */ IOID **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MajorVersion(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MinorVersion(
            /* [retval][out] */ long *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct ITemplateVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ITemplate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ITemplate * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ITemplate * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ITemplate * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ITemplate * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ITemplate * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ITemplate * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsPresent )(
            ITemplate * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCritical )(
            ITemplate * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )(
            ITemplate * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OID )(
            ITemplate * This,
            /* [retval][out] */ IOID **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MajorVersion )(
            ITemplate * This,
            /* [retval][out] */ long *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MinorVersion )(
            ITemplate * This,
            /* [retval][out] */ long *pVal);

        END_INTERFACE
    } ITemplateVtbl;

    interface ITemplate
    {
        CONST_VTBL struct ITemplateVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ITemplate_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITemplate_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define ITemplate_Release(This) \
    (This)->lpVtbl -> Release(This)


#define ITemplate_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITemplate_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITemplate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITemplate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITemplate_get_IsPresent(This,pVal)  \
    (This)->lpVtbl -> get_IsPresent(This,pVal)

#define ITemplate_get_IsCritical(This,pVal) \
    (This)->lpVtbl -> get_IsCritical(This,pVal)

#define ITemplate_get_Name(This,pVal)   \
    (This)->lpVtbl -> get_Name(This,pVal)

#define ITemplate_get_OID(This,pVal)    \
    (This)->lpVtbl -> get_OID(This,pVal)

#define ITemplate_get_MajorVersion(This,pVal)   \
    (This)->lpVtbl -> get_MajorVersion(This,pVal)

#define ITemplate_get_MinorVersion(This,pVal)   \
    (This)->lpVtbl -> get_MinorVersion(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITemplate_get_IsPresent_Proxy(
    ITemplate * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB ITemplate_get_IsPresent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITemplate_get_IsCritical_Proxy(
    ITemplate * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB ITemplate_get_IsCritical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITemplate_get_Name_Proxy(
    ITemplate * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ITemplate_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITemplate_get_OID_Proxy(
    ITemplate * This,
    /* [retval][out] */ IOID **pVal);


void __RPC_STUB ITemplate_get_OID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITemplate_get_MajorVersion_Proxy(
    ITemplate * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ITemplate_get_MajorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITemplate_get_MinorVersion_Proxy(
    ITemplate * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ITemplate_get_MinorVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ITemplate_INTERFACE_DEFINED__ */


#ifndef __IPublicKey_INTERFACE_DEFINED__
#define __IPublicKey_INTERFACE_DEFINED__

/* interface IPublicKey */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IPublicKey;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("72BF9ADA-6817-4C31-B43E-25F7C7B091F4")
    IPublicKey : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Algorithm(
            /* [retval][out] */ IOID **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Length(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EncodedKey(
            /* [retval][out] */ IEncodedData **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EncodedParameters(
            /* [retval][out] */ IEncodedData **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IPublicKeyVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IPublicKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IPublicKey * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IPublicKey * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IPublicKey * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IPublicKey * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IPublicKey * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IPublicKey * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Algorithm )(
            IPublicKey * This,
            /* [retval][out] */ IOID **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )(
            IPublicKey * This,
            /* [retval][out] */ long *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncodedKey )(
            IPublicKey * This,
            /* [retval][out] */ IEncodedData **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncodedParameters )(
            IPublicKey * This,
            /* [retval][out] */ IEncodedData **pVal);

        END_INTERFACE
    } IPublicKeyVtbl;

    interface IPublicKey
    {
        CONST_VTBL struct IPublicKeyVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IPublicKey_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPublicKey_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IPublicKey_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IPublicKey_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPublicKey_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPublicKey_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPublicKey_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPublicKey_get_Algorithm(This,pVal) \
    (This)->lpVtbl -> get_Algorithm(This,pVal)

#define IPublicKey_get_Length(This,pVal)    \
    (This)->lpVtbl -> get_Length(This,pVal)

#define IPublicKey_get_EncodedKey(This,pVal)    \
    (This)->lpVtbl -> get_EncodedKey(This,pVal)

#define IPublicKey_get_EncodedParameters(This,pVal) \
    (This)->lpVtbl -> get_EncodedParameters(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPublicKey_get_Algorithm_Proxy(
    IPublicKey * This,
    /* [retval][out] */ IOID **pVal);


void __RPC_STUB IPublicKey_get_Algorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPublicKey_get_Length_Proxy(
    IPublicKey * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPublicKey_get_Length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPublicKey_get_EncodedKey_Proxy(
    IPublicKey * This,
    /* [retval][out] */ IEncodedData **pVal);


void __RPC_STUB IPublicKey_get_EncodedKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPublicKey_get_EncodedParameters_Proxy(
    IPublicKey * This,
    /* [retval][out] */ IEncodedData **pVal);


void __RPC_STUB IPublicKey_get_EncodedParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPublicKey_INTERFACE_DEFINED__ */


#ifndef __IPrivateKey_INTERFACE_DEFINED__
#define __IPrivateKey_INTERFACE_DEFINED__

/* interface IPrivateKey */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IPrivateKey;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("659DEDC3-6C85-42DB-8527-EFCB21742862")
    IPrivateKey : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ContainerName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueContainerName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProviderType(
            /* [retval][out] */ CAPICOM_PROV_TYPE *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_KeySpec(
            /* [retval][out] */ CAPICOM_KEY_SPEC *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAccessible(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsProtected(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsExportable(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsRemovable(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsMachineKeyset(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsHardwareDevice(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Open(
            /* [in] */ BSTR ContainerName,
            /* [defaultvalue][in] */ BSTR ProviderName = L"Microsoft Enhanced Cryptographic Provider v1.0",
            /* [defaultvalue][in] */ CAPICOM_PROV_TYPE ProviderType = CAPICOM_PROV_RSA_FULL,
            /* [defaultvalue][in] */ CAPICOM_KEY_SPEC KeySpec = CAPICOM_KEY_SPEC_SIGNATURE,
            /* [defaultvalue][in] */ CAPICOM_STORE_LOCATION StoreLocation = CAPICOM_CURRENT_USER_STORE,
            /* [defaultvalue][in] */ VARIANT_BOOL bCheckExistence = 0) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;

    };

#else   /* C style interface */

    typedef struct IPrivateKeyVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IPrivateKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IPrivateKey * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IPrivateKey * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IPrivateKey * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IPrivateKey * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IPrivateKey * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IPrivateKey * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainerName )(
            IPrivateKey * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueContainerName )(
            IPrivateKey * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )(
            IPrivateKey * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderType )(
            IPrivateKey * This,
            /* [retval][out] */ CAPICOM_PROV_TYPE *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeySpec )(
            IPrivateKey * This,
            /* [retval][out] */ CAPICOM_KEY_SPEC *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAccessible )(
            IPrivateKey * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsProtected )(
            IPrivateKey * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsExportable )(
            IPrivateKey * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsRemovable )(
            IPrivateKey * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsMachineKeyset )(
            IPrivateKey * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsHardwareDevice )(
            IPrivateKey * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Open )(
            IPrivateKey * This,
            /* [in] */ BSTR ContainerName,
            /* [defaultvalue][in] */ BSTR ProviderName,
            /* [defaultvalue][in] */ CAPICOM_PROV_TYPE ProviderType,
            /* [defaultvalue][in] */ CAPICOM_KEY_SPEC KeySpec,
            /* [defaultvalue][in] */ CAPICOM_STORE_LOCATION StoreLocation,
            /* [defaultvalue][in] */ VARIANT_BOOL bCheckExistence);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )(
            IPrivateKey * This);

        END_INTERFACE
    } IPrivateKeyVtbl;

    interface IPrivateKey
    {
        CONST_VTBL struct IPrivateKeyVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IPrivateKey_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivateKey_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPrivateKey_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPrivateKey_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPrivateKey_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPrivateKey_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPrivateKey_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPrivateKey_get_ContainerName(This,pVal)    \
    (This)->lpVtbl -> get_ContainerName(This,pVal)

#define IPrivateKey_get_UniqueContainerName(This,pVal)  \
    (This)->lpVtbl -> get_UniqueContainerName(This,pVal)

#define IPrivateKey_get_ProviderName(This,pVal) \
    (This)->lpVtbl -> get_ProviderName(This,pVal)

#define IPrivateKey_get_ProviderType(This,pVal) \
    (This)->lpVtbl -> get_ProviderType(This,pVal)

#define IPrivateKey_get_KeySpec(This,pVal)  \
    (This)->lpVtbl -> get_KeySpec(This,pVal)

#define IPrivateKey_IsAccessible(This,pVal) \
    (This)->lpVtbl -> IsAccessible(This,pVal)

#define IPrivateKey_IsProtected(This,pVal)  \
    (This)->lpVtbl -> IsProtected(This,pVal)

#define IPrivateKey_IsExportable(This,pVal) \
    (This)->lpVtbl -> IsExportable(This,pVal)

#define IPrivateKey_IsRemovable(This,pVal)  \
    (This)->lpVtbl -> IsRemovable(This,pVal)

#define IPrivateKey_IsMachineKeyset(This,pVal)  \
    (This)->lpVtbl -> IsMachineKeyset(This,pVal)

#define IPrivateKey_IsHardwareDevice(This,pVal) \
    (This)->lpVtbl -> IsHardwareDevice(This,pVal)

#define IPrivateKey_Open(This,ContainerName,ProviderName,ProviderType,KeySpec,StoreLocation,bCheckExistence)    \
    (This)->lpVtbl -> Open(This,ContainerName,ProviderName,ProviderType,KeySpec,StoreLocation,bCheckExistence)

#define IPrivateKey_Delete(This)    \
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPrivateKey_get_ContainerName_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPrivateKey_get_ContainerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPrivateKey_get_UniqueContainerName_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPrivateKey_get_UniqueContainerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPrivateKey_get_ProviderName_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPrivateKey_get_ProviderName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPrivateKey_get_ProviderType_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ CAPICOM_PROV_TYPE *pVal);


void __RPC_STUB IPrivateKey_get_ProviderType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPrivateKey_get_KeySpec_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ CAPICOM_KEY_SPEC *pVal);


void __RPC_STUB IPrivateKey_get_KeySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_IsAccessible_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPrivateKey_IsAccessible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_IsProtected_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPrivateKey_IsProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_IsExportable_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPrivateKey_IsExportable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_IsRemovable_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPrivateKey_IsRemovable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_IsMachineKeyset_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPrivateKey_IsMachineKeyset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_IsHardwareDevice_Proxy(
    IPrivateKey * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPrivateKey_IsHardwareDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_Open_Proxy(
    IPrivateKey * This,
    /* [in] */ BSTR ContainerName,
    /* [defaultvalue][in] */ BSTR ProviderName,
    /* [defaultvalue][in] */ CAPICOM_PROV_TYPE ProviderType,
    /* [defaultvalue][in] */ CAPICOM_KEY_SPEC KeySpec,
    /* [defaultvalue][in] */ CAPICOM_STORE_LOCATION StoreLocation,
    /* [defaultvalue][in] */ VARIANT_BOOL bCheckExistence);


void __RPC_STUB IPrivateKey_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPrivateKey_Delete_Proxy(
    IPrivateKey * This);


void __RPC_STUB IPrivateKey_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPrivateKey_INTERFACE_DEFINED__ */


#ifndef __ICertificateStatus2_INTERFACE_DEFINED__
#define __ICertificateStatus2_INTERFACE_DEFINED__

/* interface ICertificateStatus2 */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ICertificateStatus2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("BF95660E-F743-4EAC-9DE5-960787A4606C")
    ICertificateStatus2 : public ICertificateStatus
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VerificationTime(
            /* [retval][out] */ DATE *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_VerificationTime(
            /* [in] */ DATE newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UrlRetrievalTimeout(
            /* [retval][out] */ long *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UrlRetrievalTimeout(
            /* [in] */ long newVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CertificatePolicies(
            /* [retval][out] */ IOIDs **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ApplicationPolicies(
            /* [retval][out] */ IOIDs **pVal) = 0;

    };

#else   /* C style interface */

    typedef struct ICertificateStatus2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertificateStatus2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertificateStatus2 * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertificateStatus2 * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ICertificateStatus2 * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ICertificateStatus2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ICertificateStatus2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ICertificateStatus2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Result )(
            ICertificateStatus2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CheckFlag )(
            ICertificateStatus2 * This,
            /* [retval][out] */ CAPICOM_CHECK_FLAG *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CheckFlag )(
            ICertificateStatus2 * This,
            /* [in] */ CAPICOM_CHECK_FLAG newVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EKU )(
            ICertificateStatus2 * This,
            /* [retval][out] */ IEKU **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerificationTime )(
            ICertificateStatus2 * This,
            /* [retval][out] */ DATE *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_VerificationTime )(
            ICertificateStatus2 * This,
            /* [in] */ DATE newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UrlRetrievalTimeout )(
            ICertificateStatus2 * This,
            /* [retval][out] */ long *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UrlRetrievalTimeout )(
            ICertificateStatus2 * This,
            /* [in] */ long newVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CertificatePolicies )(
            ICertificateStatus2 * This,
            /* [retval][out] */ IOIDs **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ApplicationPolicies )(
            ICertificateStatus2 * This,
            /* [retval][out] */ IOIDs **pVal);

        END_INTERFACE
    } ICertificateStatus2Vtbl;

    interface ICertificateStatus2
    {
        CONST_VTBL struct ICertificateStatus2Vtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertificateStatus2_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertificateStatus2_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define ICertificateStatus2_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define ICertificateStatus2_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertificateStatus2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertificateStatus2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertificateStatus2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertificateStatus2_get_Result(This,pVal)   \
    (This)->lpVtbl -> get_Result(This,pVal)

#define ICertificateStatus2_get_CheckFlag(This,pVal)    \
    (This)->lpVtbl -> get_CheckFlag(This,pVal)

#define ICertificateStatus2_put_CheckFlag(This,newVal)  \
    (This)->lpVtbl -> put_CheckFlag(This,newVal)

#define ICertificateStatus2_EKU(This,pVal)  \
    (This)->lpVtbl -> EKU(This,pVal)


#define ICertificateStatus2_get_VerificationTime(This,pVal) \
    (This)->lpVtbl -> get_VerificationTime(This,pVal)

#define ICertificateStatus2_put_VerificationTime(This,newVal)   \
    (This)->lpVtbl -> put_VerificationTime(This,newVal)

#define ICertificateStatus2_get_UrlRetrievalTimeout(This,pVal)  \
    (This)->lpVtbl -> get_UrlRetrievalTimeout(This,pVal)

#define ICertificateStatus2_put_UrlRetrievalTimeout(This,newVal)    \
    (This)->lpVtbl -> put_UrlRetrievalTimeout(This,newVal)

#define ICertificateStatus2_CertificatePolicies(This,pVal)  \
    (This)->lpVtbl -> CertificatePolicies(This,pVal)

#define ICertificateStatus2_ApplicationPolicies(This,pVal)  \
    (This)->lpVtbl -> ApplicationPolicies(This,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificateStatus2_get_VerificationTime_Proxy(
    ICertificateStatus2 * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB ICertificateStatus2_get_VerificationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICertificateStatus2_put_VerificationTime_Proxy(
    ICertificateStatus2 * This,
    /* [in] */ DATE newVal);


void __RPC_STUB ICertificateStatus2_put_VerificationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificateStatus2_get_UrlRetrievalTimeout_Proxy(
    ICertificateStatus2 * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ICertificateStatus2_get_UrlRetrievalTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICertificateStatus2_put_UrlRetrievalTimeout_Proxy(
    ICertificateStatus2 * This,
    /* [in] */ long newVal);


void __RPC_STUB ICertificateStatus2_put_UrlRetrievalTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificateStatus2_CertificatePolicies_Proxy(
    ICertificateStatus2 * This,
    /* [retval][out] */ IOIDs **pVal);


void __RPC_STUB ICertificateStatus2_CertificatePolicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificateStatus2_ApplicationPolicies_Proxy(
    ICertificateStatus2 * This,
    /* [retval][out] */ IOIDs **pVal);


void __RPC_STUB ICertificateStatus2_ApplicationPolicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertificateStatus2_INTERFACE_DEFINED__ */


#ifndef __ICertificate2_INTERFACE_DEFINED__
#define __ICertificate2_INTERFACE_DEFINED__

/* interface ICertificate2 */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ICertificate2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("6FE450DC-AD32-48d4-A366-01EE7E0B1374")
    ICertificate2 : public ICertificate
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Archived(
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Archived(
            /* [in] */ VARIANT_BOOL newVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Template(
            /* [retval][out] */ ITemplate **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PublicKey(
            /* [retval][out] */ IPublicKey **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PrivateKey(
            /* [retval][out] */ IPrivateKey **pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PrivateKey(
            /* [in] */ IPrivateKey *newVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Extensions(
            /* [retval][out] */ IExtensions **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtendedProperties(
            /* [retval][out] */ IExtendedProperties **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load(
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password = L"",
            /* [defaultvalue][in] */ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag = CAPICOM_KEY_STORAGE_DEFAULT,
            /* [defaultvalue][in] */ CAPICOM_KEY_LOCATION KeyLocation = CAPICOM_CURRENT_USER_KEY) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save(
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password = L"",
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_SAVE_AS_TYPE SaveAs = CAPICOM_CERTIFICATE_SAVE_AS_CER,
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption = CAPICOM_CERTIFICATE_INCLUDE_END_ENTITY_ONLY) = 0;

    };

#else   /* C style interface */

    typedef struct ICertificate2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertificate2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertificate2 * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertificate2 * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ICertificate2 * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ICertificate2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ICertificate2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ICertificate2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )(
            ICertificate2 * This,
            /* [retval][out] */ long *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialNumber )(
            ICertificate2 * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubjectName )(
            ICertificate2 * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IssuerName )(
            ICertificate2 * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValidFromDate )(
            ICertificate2 * This,
            /* [retval][out] */ DATE *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ValidToDate )(
            ICertificate2 * This,
            /* [retval][out] */ DATE *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Thumbprint )(
            ICertificate2 * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasPrivateKey )(
            ICertificate2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInfo )(
            ICertificate2 * This,
            /* [in] */ CAPICOM_CERT_INFO_TYPE InfoType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsValid )(
            ICertificate2 * This,
            /* [retval][out] */ ICertificateStatus **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *KeyUsage )(
            ICertificate2 * This,
            /* [retval][out] */ IKeyUsage **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExtendedKeyUsage )(
            ICertificate2 * This,
            /* [retval][out] */ IExtendedKeyUsage **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BasicConstraints )(
            ICertificate2 * This,
            /* [retval][out] */ IBasicConstraints **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Export )(
            ICertificate2 * This,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Import )(
            ICertificate2 * This,
            /* [in] */ BSTR EncodedCertificate);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Display )(
            ICertificate2 * This);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Archived )(
            ICertificate2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Archived )(
            ICertificate2 * This,
            /* [in] */ VARIANT_BOOL newVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Template )(
            ICertificate2 * This,
            /* [retval][out] */ ITemplate **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PublicKey )(
            ICertificate2 * This,
            /* [retval][out] */ IPublicKey **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateKey )(
            ICertificate2 * This,
            /* [retval][out] */ IPrivateKey **pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivateKey )(
            ICertificate2 * This,
            /* [in] */ IPrivateKey *newVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Extensions )(
            ICertificate2 * This,
            /* [retval][out] */ IExtensions **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExtendedProperties )(
            ICertificate2 * This,
            /* [retval][out] */ IExtendedProperties **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Load )(
            ICertificate2 * This,
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag,
            /* [defaultvalue][in] */ CAPICOM_KEY_LOCATION KeyLocation);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )(
            ICertificate2 * This,
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_SAVE_AS_TYPE SaveAs,
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption);

        END_INTERFACE
    } ICertificate2Vtbl;

    interface ICertificate2
    {
        CONST_VTBL struct ICertificate2Vtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertificate2_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertificate2_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define ICertificate2_Release(This) \
    (This)->lpVtbl -> Release(This)


#define ICertificate2_GetTypeInfoCount(This,pctinfo)    \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertificate2_GetTypeInfo(This,iTInfo,lcid,ppTInfo) \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertificate2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)   \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertificate2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertificate2_get_Version(This,pVal)    \
    (This)->lpVtbl -> get_Version(This,pVal)

#define ICertificate2_get_SerialNumber(This,pVal)   \
    (This)->lpVtbl -> get_SerialNumber(This,pVal)

#define ICertificate2_get_SubjectName(This,pVal)    \
    (This)->lpVtbl -> get_SubjectName(This,pVal)

#define ICertificate2_get_IssuerName(This,pVal) \
    (This)->lpVtbl -> get_IssuerName(This,pVal)

#define ICertificate2_get_ValidFromDate(This,pVal)  \
    (This)->lpVtbl -> get_ValidFromDate(This,pVal)

#define ICertificate2_get_ValidToDate(This,pVal)    \
    (This)->lpVtbl -> get_ValidToDate(This,pVal)

#define ICertificate2_get_Thumbprint(This,pVal) \
    (This)->lpVtbl -> get_Thumbprint(This,pVal)

#define ICertificate2_HasPrivateKey(This,pVal)  \
    (This)->lpVtbl -> HasPrivateKey(This,pVal)

#define ICertificate2_GetInfo(This,InfoType,pVal)   \
    (This)->lpVtbl -> GetInfo(This,InfoType,pVal)

#define ICertificate2_IsValid(This,pVal)    \
    (This)->lpVtbl -> IsValid(This,pVal)

#define ICertificate2_KeyUsage(This,pVal)   \
    (This)->lpVtbl -> KeyUsage(This,pVal)

#define ICertificate2_ExtendedKeyUsage(This,pVal)   \
    (This)->lpVtbl -> ExtendedKeyUsage(This,pVal)

#define ICertificate2_BasicConstraints(This,pVal)   \
    (This)->lpVtbl -> BasicConstraints(This,pVal)

#define ICertificate2_Export(This,EncodingType,pVal)    \
    (This)->lpVtbl -> Export(This,EncodingType,pVal)

#define ICertificate2_Import(This,EncodedCertificate)   \
    (This)->lpVtbl -> Import(This,EncodedCertificate)

#define ICertificate2_Display(This) \
    (This)->lpVtbl -> Display(This)


#define ICertificate2_get_Archived(This,pVal)   \
    (This)->lpVtbl -> get_Archived(This,pVal)

#define ICertificate2_put_Archived(This,newVal) \
    (This)->lpVtbl -> put_Archived(This,newVal)

#define ICertificate2_Template(This,pVal)   \
    (This)->lpVtbl -> Template(This,pVal)

#define ICertificate2_PublicKey(This,pVal)  \
    (This)->lpVtbl -> PublicKey(This,pVal)

#define ICertificate2_get_PrivateKey(This,pVal) \
    (This)->lpVtbl -> get_PrivateKey(This,pVal)

#define ICertificate2_put_PrivateKey(This,newVal)   \
    (This)->lpVtbl -> put_PrivateKey(This,newVal)

#define ICertificate2_Extensions(This,pVal) \
    (This)->lpVtbl -> Extensions(This,pVal)

#define ICertificate2_ExtendedProperties(This,pVal) \
    (This)->lpVtbl -> ExtendedProperties(This,pVal)

#define ICertificate2_Load(This,FileName,Password,KeyStorageFlag,KeyLocation)   \
    (This)->lpVtbl -> Load(This,FileName,Password,KeyStorageFlag,KeyLocation)

#define ICertificate2_Save(This,FileName,Password,SaveAs,IncludeOption) \
    (This)->lpVtbl -> Save(This,FileName,Password,SaveAs,IncludeOption)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate2_get_Archived_Proxy(
    ICertificate2 * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB ICertificate2_get_Archived_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICertificate2_put_Archived_Proxy(
    ICertificate2 * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB ICertificate2_put_Archived_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate2_Template_Proxy(
    ICertificate2 * This,
    /* [retval][out] */ ITemplate **pVal);


void __RPC_STUB ICertificate2_Template_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate2_PublicKey_Proxy(
    ICertificate2 * This,
    /* [retval][out] */ IPublicKey **pVal);


void __RPC_STUB ICertificate2_PublicKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ICertificate2_get_PrivateKey_Proxy(
    ICertificate2 * This,
    /* [retval][out] */ IPrivateKey **pVal);


void __RPC_STUB ICertificate2_get_PrivateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ICertificate2_put_PrivateKey_Proxy(
    ICertificate2 * This,
    /* [in] */ IPrivateKey *newVal);


void __RPC_STUB ICertificate2_put_PrivateKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate2_Extensions_Proxy(
    ICertificate2 * This,
    /* [retval][out] */ IExtensions **pVal);


void __RPC_STUB ICertificate2_Extensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate2_ExtendedProperties_Proxy(
    ICertificate2 * This,
    /* [retval][out] */ IExtendedProperties **pVal);


void __RPC_STUB ICertificate2_ExtendedProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate2_Load_Proxy(
    ICertificate2 * This,
    /* [in] */ BSTR FileName,
    /* [defaultvalue][in] */ BSTR Password,
    /* [defaultvalue][in] */ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag,
    /* [defaultvalue][in] */ CAPICOM_KEY_LOCATION KeyLocation);


void __RPC_STUB ICertificate2_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificate2_Save_Proxy(
    ICertificate2 * This,
    /* [in] */ BSTR FileName,
    /* [defaultvalue][in] */ BSTR Password,
    /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_SAVE_AS_TYPE SaveAs,
    /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION IncludeOption);


void __RPC_STUB ICertificate2_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertificate2_INTERFACE_DEFINED__ */


#ifndef __ICertificates2_INTERFACE_DEFINED__
#define __ICertificates2_INTERFACE_DEFINED__

/* interface ICertificates2 */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ICertificates2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("7B57C04B-1786-4B30-A7B6-36235CD58A14")
    ICertificates2 : public ICertificates
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Find(
            /* [in] */ CAPICOM_CERTIFICATE_FIND_TYPE FindType,
            /* [defaultvalue][in] */ VARIANT varCriteria,
            /* [defaultvalue][in] */ VARIANT_BOOL bFindValidOnly,
            /* [retval][out] */ ICertificates2 **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Select(
            /* [defaultvalue][in] */ BSTR Title,
            /* [defaultvalue][in] */ BSTR DisplayString,
            /* [defaultvalue][in] */ VARIANT_BOOL bMultiSelect,
            /* [retval][out] */ ICertificates2 **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add(
            /* [in] */ ICertificate2 *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove(
            /* [in] */ VARIANT Index) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save(
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password = L"",
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATES_SAVE_AS_TYPE SaveAs = CAPICOM_CERTIFICATES_SAVE_AS_PFX,
            /* [defaultvalue][in] */ CAPICOM_EXPORT_FLAG ExportFlag = CAPICOM_EXPORT_DEFAULT) = 0;

    };

#else   /* C style interface */

    typedef struct ICertificates2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertificates2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertificates2 * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertificates2 * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ICertificates2 * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ICertificates2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ICertificates2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ICertificates2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )(
            ICertificates2 * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )(
            ICertificates2 * This,
            /* [retval][out] */ long *pVal);

        /* [restricted][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )(
            ICertificates2 * This,
            /* [retval][out] */ LPUNKNOWN *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Find )(
            ICertificates2 * This,
            /* [in] */ CAPICOM_CERTIFICATE_FIND_TYPE FindType,
            /* [defaultvalue][in] */ VARIANT varCriteria,
            /* [defaultvalue][in] */ VARIANT_BOOL bFindValidOnly,
            /* [retval][out] */ ICertificates2 **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Select )(
            ICertificates2 * This,
            /* [defaultvalue][in] */ BSTR Title,
            /* [defaultvalue][in] */ BSTR DisplayString,
            /* [defaultvalue][in] */ VARIANT_BOOL bMultiSelect,
            /* [retval][out] */ ICertificates2 **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )(
            ICertificates2 * This,
            /* [in] */ ICertificate2 *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )(
            ICertificates2 * This,
            /* [in] */ VARIANT Index);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )(
            ICertificates2 * This);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Save )(
            ICertificates2 * This,
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATES_SAVE_AS_TYPE SaveAs,
            /* [defaultvalue][in] */ CAPICOM_EXPORT_FLAG ExportFlag);

        END_INTERFACE
    } ICertificates2Vtbl;

    interface ICertificates2
    {
        CONST_VTBL struct ICertificates2Vtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertificates2_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertificates2_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define ICertificates2_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define ICertificates2_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertificates2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertificates2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertificates2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertificates2_get_Item(This,Index,pVal)    \
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#define ICertificates2_get_Count(This,pVal) \
    (This)->lpVtbl -> get_Count(This,pVal)

#define ICertificates2_get__NewEnum(This,pVal)  \
    (This)->lpVtbl -> get__NewEnum(This,pVal)


#define ICertificates2_Find(This,FindType,varCriteria,bFindValidOnly,pVal)  \
    (This)->lpVtbl -> Find(This,FindType,varCriteria,bFindValidOnly,pVal)

#define ICertificates2_Select(This,Title,DisplayString,bMultiSelect,pVal)   \
    (This)->lpVtbl -> Select(This,Title,DisplayString,bMultiSelect,pVal)

#define ICertificates2_Add(This,pVal)   \
    (This)->lpVtbl -> Add(This,pVal)

#define ICertificates2_Remove(This,Index)   \
    (This)->lpVtbl -> Remove(This,Index)

#define ICertificates2_Clear(This)  \
    (This)->lpVtbl -> Clear(This)

#define ICertificates2_Save(This,FileName,Password,SaveAs,ExportFlag)   \
    (This)->lpVtbl -> Save(This,FileName,Password,SaveAs,ExportFlag)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificates2_Find_Proxy(
    ICertificates2 * This,
    /* [in] */ CAPICOM_CERTIFICATE_FIND_TYPE FindType,
    /* [defaultvalue][in] */ VARIANT varCriteria,
    /* [defaultvalue][in] */ VARIANT_BOOL bFindValidOnly,
    /* [retval][out] */ ICertificates2 **pVal);


void __RPC_STUB ICertificates2_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificates2_Select_Proxy(
    ICertificates2 * This,
    /* [defaultvalue][in] */ BSTR Title,
    /* [defaultvalue][in] */ BSTR DisplayString,
    /* [defaultvalue][in] */ VARIANT_BOOL bMultiSelect,
    /* [retval][out] */ ICertificates2 **pVal);


void __RPC_STUB ICertificates2_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificates2_Add_Proxy(
    ICertificates2 * This,
    /* [in] */ ICertificate2 *pVal);


void __RPC_STUB ICertificates2_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificates2_Remove_Proxy(
    ICertificates2 * This,
    /* [in] */ VARIANT Index);


void __RPC_STUB ICertificates2_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificates2_Clear_Proxy(
    ICertificates2 * This);


void __RPC_STUB ICertificates2_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICertificates2_Save_Proxy(
    ICertificates2 * This,
    /* [in] */ BSTR FileName,
    /* [defaultvalue][in] */ BSTR Password,
    /* [defaultvalue][in] */ CAPICOM_CERTIFICATES_SAVE_AS_TYPE SaveAs,
    /* [defaultvalue][in] */ CAPICOM_EXPORT_FLAG ExportFlag);


void __RPC_STUB ICertificates2_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertificates2_INTERFACE_DEFINED__ */


#ifndef __IChain2_INTERFACE_DEFINED__
#define __IChain2_INTERFACE_DEFINED__

/* interface IChain2 */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IChain2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("CA65D842-2110-4073-AEE3-D0AA5F56C421")
    IChain2 : public IChain
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CertificatePolicies(
            /* [retval][out] */ IOIDs **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ApplicationPolicies(
            /* [retval][out] */ IOIDs **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtendedErrorInfo(
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ BSTR *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IChain2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IChain2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IChain2 * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IChain2 * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IChain2 * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IChain2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IChain2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IChain2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificates )(
            IChain2 * This,
            /* [retval][out] */ ICertificates **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )(
            IChain2 * This,
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ long *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Build )(
            IChain2 * This,
            /* [in] */ ICertificate *pICertificate,
            /* [retval][out] */ VARIANT_BOOL *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CertificatePolicies )(
            IChain2 * This,
            /* [retval][out] */ IOIDs **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ApplicationPolicies )(
            IChain2 * This,
            /* [retval][out] */ IOIDs **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExtendedErrorInfo )(
            IChain2 * This,
            /* [defaultvalue][in] */ long Index,
            /* [retval][out] */ BSTR *pVal);

        END_INTERFACE
    } IChain2Vtbl;

    interface IChain2
    {
        CONST_VTBL struct IChain2Vtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IChain2_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IChain2_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IChain2_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IChain2_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IChain2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IChain2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IChain2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IChain2_get_Certificates(This,pVal) \
    (This)->lpVtbl -> get_Certificates(This,pVal)

#define IChain2_get_Status(This,Index,pVal) \
    (This)->lpVtbl -> get_Status(This,Index,pVal)

#define IChain2_Build(This,pICertificate,pVal)  \
    (This)->lpVtbl -> Build(This,pICertificate,pVal)


#define IChain2_CertificatePolicies(This,pVal)  \
    (This)->lpVtbl -> CertificatePolicies(This,pVal)

#define IChain2_ApplicationPolicies(This,pVal)  \
    (This)->lpVtbl -> ApplicationPolicies(This,pVal)

#define IChain2_ExtendedErrorInfo(This,Index,pVal)  \
    (This)->lpVtbl -> ExtendedErrorInfo(This,Index,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IChain2_CertificatePolicies_Proxy(
    IChain2 * This,
    /* [retval][out] */ IOIDs **pVal);


void __RPC_STUB IChain2_CertificatePolicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IChain2_ApplicationPolicies_Proxy(
    IChain2 * This,
    /* [retval][out] */ IOIDs **pVal);


void __RPC_STUB IChain2_ApplicationPolicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IChain2_ExtendedErrorInfo_Proxy(
    IChain2 * This,
    /* [defaultvalue][in] */ long Index,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IChain2_ExtendedErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IChain2_INTERFACE_DEFINED__ */


#ifndef __IStore2_INTERFACE_DEFINED__
#define __IStore2_INTERFACE_DEFINED__

/* interface IStore2 */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IStore2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("4DA6ABC4-BDCD-4317-B650-262075B93A9C")
    IStore2 : public IStore
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load(
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password = L"",
            /* [defaultvalue][in] */ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag = CAPICOM_KEY_STORAGE_DEFAULT) = 0;

    };

#else   /* C style interface */

    typedef struct IStore2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IStore2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IStore2 * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IStore2 * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IStore2 * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IStore2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IStore2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IStore2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificates )(
            IStore2 * This,
            /* [retval][out] */ ICertificates **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Open )(
            IStore2 * This,
            /* [defaultvalue][in] */ CAPICOM_STORE_LOCATION StoreLocation,
            /* [defaultvalue][in] */ BSTR StoreName,
            /* [defaultvalue][in] */ CAPICOM_STORE_OPEN_MODE OpenMode);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )(
            IStore2 * This,
            /* [in] */ ICertificate *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )(
            IStore2 * This,
            /* [in] */ ICertificate *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Export )(
            IStore2 * This,
            /* [defaultvalue][in] */ CAPICOM_STORE_SAVE_AS_TYPE SaveAs,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Import )(
            IStore2 * This,
            /* [in] */ BSTR EncodedStore);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Load )(
            IStore2 * This,
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password,
            /* [defaultvalue][in] */ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag);

        END_INTERFACE
    } IStore2Vtbl;

    interface IStore2
    {
        CONST_VTBL struct IStore2Vtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IStore2_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStore2_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IStore2_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IStore2_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStore2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStore2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStore2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStore2_get_Certificates(This,pVal) \
    (This)->lpVtbl -> get_Certificates(This,pVal)

#define IStore2_Open(This,StoreLocation,StoreName,OpenMode) \
    (This)->lpVtbl -> Open(This,StoreLocation,StoreName,OpenMode)

#define IStore2_Add(This,pVal)  \
    (This)->lpVtbl -> Add(This,pVal)

#define IStore2_Remove(This,pVal)   \
    (This)->lpVtbl -> Remove(This,pVal)

#define IStore2_Export(This,SaveAs,EncodingType,pVal)   \
    (This)->lpVtbl -> Export(This,SaveAs,EncodingType,pVal)

#define IStore2_Import(This,EncodedStore)   \
    (This)->lpVtbl -> Import(This,EncodedStore)


#define IStore2_Load(This,FileName,Password,KeyStorageFlag) \
    (This)->lpVtbl -> Load(This,FileName,Password,KeyStorageFlag)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IStore2_Load_Proxy(
    IStore2 * This,
    /* [in] */ BSTR FileName,
    /* [defaultvalue][in] */ BSTR Password,
    /* [defaultvalue][in] */ CAPICOM_KEY_STORAGE_FLAG KeyStorageFlag);


void __RPC_STUB IStore2_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IStore2_INTERFACE_DEFINED__ */


#ifndef __ISigner2_INTERFACE_DEFINED__
#define __ISigner2_INTERFACE_DEFINED__

/* interface ISigner2 */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ISigner2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("625B1F55-C720-41D6-9ECF-BA59F9B85F17")
    ISigner2 : public ISigner
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Chain(
            /* [retval][out] */ IChain **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Options(
            /* [retval][out] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Options(
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION newVal = CAPICOM_CERTIFICATE_INCLUDE_CHAIN_EXCEPT_ROOT) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load(
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password = L"") = 0;

    };

#else   /* C style interface */

    typedef struct ISigner2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ISigner2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ISigner2 * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ISigner2 * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ISigner2 * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ISigner2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ISigner2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ISigner2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificate )(
            ISigner2 * This,
            /* [retval][out] */ ICertificate **pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Certificate )(
            ISigner2 * This,
            /* [in] */ ICertificate *newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AuthenticatedAttributes )(
            ISigner2 * This,
            /* [retval][out] */ IAttributes **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Chain )(
            ISigner2 * This,
            /* [retval][out] */ IChain **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Options )(
            ISigner2 * This,
            /* [retval][out] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Options )(
            ISigner2 * This,
            /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION newVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Load )(
            ISigner2 * This,
            /* [in] */ BSTR FileName,
            /* [defaultvalue][in] */ BSTR Password);

        END_INTERFACE
    } ISigner2Vtbl;

    interface ISigner2
    {
        CONST_VTBL struct ISigner2Vtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ISigner2_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISigner2_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ISigner2_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ISigner2_GetTypeInfoCount(This,pctinfo) \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISigner2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)  \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISigner2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)    \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISigner2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)  \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISigner2_get_Certificate(This,pVal) \
    (This)->lpVtbl -> get_Certificate(This,pVal)

#define ISigner2_put_Certificate(This,newVal)   \
    (This)->lpVtbl -> put_Certificate(This,newVal)

#define ISigner2_get_AuthenticatedAttributes(This,pVal) \
    (This)->lpVtbl -> get_AuthenticatedAttributes(This,pVal)


#define ISigner2_get_Chain(This,pVal)   \
    (This)->lpVtbl -> get_Chain(This,pVal)

#define ISigner2_get_Options(This,pVal) \
    (This)->lpVtbl -> get_Options(This,pVal)

#define ISigner2_put_Options(This,newVal)   \
    (This)->lpVtbl -> put_Options(This,newVal)

#define ISigner2_Load(This,FileName,Password)   \
    (This)->lpVtbl -> Load(This,FileName,Password)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISigner2_get_Chain_Proxy(
    ISigner2 * This,
    /* [retval][out] */ IChain **pVal);


void __RPC_STUB ISigner2_get_Chain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISigner2_get_Options_Proxy(
    ISigner2 * This,
    /* [retval][out] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION *pVal);


void __RPC_STUB ISigner2_get_Options_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISigner2_put_Options_Proxy(
    ISigner2 * This,
    /* [defaultvalue][in] */ CAPICOM_CERTIFICATE_INCLUDE_OPTION newVal);


void __RPC_STUB ISigner2_put_Options_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISigner2_Load_Proxy(
    ISigner2 * This,
    /* [in] */ BSTR FileName,
    /* [defaultvalue][in] */ BSTR Password);


void __RPC_STUB ISigner2_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISigner2_INTERFACE_DEFINED__ */


#ifndef __ISignedCode_INTERFACE_DEFINED__
#define __ISignedCode_INTERFACE_DEFINED__

/* interface ISignedCode */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_ISignedCode;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("84FBCB95-5600-404C-9187-AC25B4CD6E94")
    ISignedCode : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DescriptionURL(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DescriptionURL(
            /* [in] */ BSTR newVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Signer(
            /* [retval][out] */ ISigner2 **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeStamper(
            /* [retval][out] */ ISigner2 **pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Certificates(
            /* [retval][out] */ ICertificates2 **pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Sign(
            /* [defaultvalue][in] */ ISigner2 *pISigner2 = 0) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Timestamp(
            /* [in] */ BSTR URL) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Verify(
            /* [defaultvalue][in] */ VARIANT_BOOL bUIAllowed = 0) = 0;

    };

#else   /* C style interface */

    typedef struct ISignedCodeVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ISignedCode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ISignedCode * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ISignedCode * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            ISignedCode * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            ISignedCode * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            ISignedCode * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            ISignedCode * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )(
            ISignedCode * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )(
            ISignedCode * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )(
            ISignedCode * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )(
            ISignedCode * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DescriptionURL )(
            ISignedCode * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DescriptionURL )(
            ISignedCode * This,
            /* [in] */ BSTR newVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Signer )(
            ISignedCode * This,
            /* [retval][out] */ ISigner2 **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeStamper )(
            ISignedCode * This,
            /* [retval][out] */ ISigner2 **pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Certificates )(
            ISignedCode * This,
            /* [retval][out] */ ICertificates2 **pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Sign )(
            ISignedCode * This,
            /* [defaultvalue][in] */ ISigner2 *pISigner2);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Timestamp )(
            ISignedCode * This,
            /* [in] */ BSTR URL);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Verify )(
            ISignedCode * This,
            /* [defaultvalue][in] */ VARIANT_BOOL bUIAllowed);

        END_INTERFACE
    } ISignedCodeVtbl;

    interface ISignedCode
    {
        CONST_VTBL struct ISignedCodeVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ISignedCode_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISignedCode_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define ISignedCode_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define ISignedCode_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISignedCode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISignedCode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISignedCode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISignedCode_get_FileName(This,pVal) \
    (This)->lpVtbl -> get_FileName(This,pVal)

#define ISignedCode_put_FileName(This,newVal)   \
    (This)->lpVtbl -> put_FileName(This,newVal)

#define ISignedCode_get_Description(This,pVal)  \
    (This)->lpVtbl -> get_Description(This,pVal)

#define ISignedCode_put_Description(This,newVal)    \
    (This)->lpVtbl -> put_Description(This,newVal)

#define ISignedCode_get_DescriptionURL(This,pVal)   \
    (This)->lpVtbl -> get_DescriptionURL(This,pVal)

#define ISignedCode_put_DescriptionURL(This,newVal) \
    (This)->lpVtbl -> put_DescriptionURL(This,newVal)

#define ISignedCode_get_Signer(This,pVal)   \
    (This)->lpVtbl -> get_Signer(This,pVal)

#define ISignedCode_get_TimeStamper(This,pVal)  \
    (This)->lpVtbl -> get_TimeStamper(This,pVal)

#define ISignedCode_get_Certificates(This,pVal) \
    (This)->lpVtbl -> get_Certificates(This,pVal)

#define ISignedCode_Sign(This,pISigner2)    \
    (This)->lpVtbl -> Sign(This,pISigner2)

#define ISignedCode_Timestamp(This,URL) \
    (This)->lpVtbl -> Timestamp(This,URL)

#define ISignedCode_Verify(This,bUIAllowed) \
    (This)->lpVtbl -> Verify(This,bUIAllowed)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedCode_get_FileName_Proxy(
    ISignedCode * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ISignedCode_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISignedCode_put_FileName_Proxy(
    ISignedCode * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISignedCode_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedCode_get_Description_Proxy(
    ISignedCode * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ISignedCode_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISignedCode_put_Description_Proxy(
    ISignedCode * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISignedCode_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedCode_get_DescriptionURL_Proxy(
    ISignedCode * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ISignedCode_get_DescriptionURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISignedCode_put_DescriptionURL_Proxy(
    ISignedCode * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISignedCode_put_DescriptionURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedCode_get_Signer_Proxy(
    ISignedCode * This,
    /* [retval][out] */ ISigner2 **pVal);


void __RPC_STUB ISignedCode_get_Signer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedCode_get_TimeStamper_Proxy(
    ISignedCode * This,
    /* [retval][out] */ ISigner2 **pVal);


void __RPC_STUB ISignedCode_get_TimeStamper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISignedCode_get_Certificates_Proxy(
    ISignedCode * This,
    /* [retval][out] */ ICertificates2 **pVal);


void __RPC_STUB ISignedCode_get_Certificates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISignedCode_Sign_Proxy(
    ISignedCode * This,
    /* [defaultvalue][in] */ ISigner2 *pISigner2);


void __RPC_STUB ISignedCode_Sign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISignedCode_Timestamp_Proxy(
    ISignedCode * This,
    /* [in] */ BSTR URL);


void __RPC_STUB ISignedCode_Timestamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISignedCode_Verify_Proxy(
    ISignedCode * This,
    /* [defaultvalue][in] */ VARIANT_BOOL bUIAllowed);


void __RPC_STUB ISignedCode_Verify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISignedCode_INTERFACE_DEFINED__ */


#ifndef __IHashedData_INTERFACE_DEFINED__
#define __IHashedData_INTERFACE_DEFINED__

/* interface IHashedData */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IHashedData;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("9F7F23E8-06F4-42E8-B965-5CBD044BF27F")
    IHashedData : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value(
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Algorithm(
            /* [retval][out] */ CAPICOM_HASH_ALGORITHM *pVal) = 0;

        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Algorithm(
            /* [in] */ CAPICOM_HASH_ALGORITHM newVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Hash(
            /* [in] */ BSTR newVal) = 0;

    };

#else   /* C style interface */

    typedef struct IHashedDataVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IHashedData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IHashedData * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IHashedData * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IHashedData * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IHashedData * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IHashedData * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IHashedData * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )(
            IHashedData * This,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Algorithm )(
            IHashedData * This,
            /* [retval][out] */ CAPICOM_HASH_ALGORITHM *pVal);

        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Algorithm )(
            IHashedData * This,
            /* [in] */ CAPICOM_HASH_ALGORITHM newVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Hash )(
            IHashedData * This,
            /* [in] */ BSTR newVal);

        END_INTERFACE
    } IHashedDataVtbl;

    interface IHashedData
    {
        CONST_VTBL struct IHashedDataVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IHashedData_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHashedData_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IHashedData_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IHashedData_GetTypeInfoCount(This,pctinfo)  \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHashedData_GetTypeInfo(This,iTInfo,lcid,ppTInfo)   \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHashedData_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHashedData_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)   \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHashedData_get_Value(This,pVal)    \
    (This)->lpVtbl -> get_Value(This,pVal)

#define IHashedData_get_Algorithm(This,pVal)    \
    (This)->lpVtbl -> get_Algorithm(This,pVal)

#define IHashedData_put_Algorithm(This,newVal)  \
    (This)->lpVtbl -> put_Algorithm(This,newVal)

#define IHashedData_Hash(This,newVal)   \
    (This)->lpVtbl -> Hash(This,newVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHashedData_get_Value_Proxy(
    IHashedData * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IHashedData_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHashedData_get_Algorithm_Proxy(
    IHashedData * This,
    /* [retval][out] */ CAPICOM_HASH_ALGORITHM *pVal);


void __RPC_STUB IHashedData_get_Algorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IHashedData_put_Algorithm_Proxy(
    IHashedData * This,
    /* [in] */ CAPICOM_HASH_ALGORITHM newVal);


void __RPC_STUB IHashedData_put_Algorithm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IHashedData_Hash_Proxy(
    IHashedData * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IHashedData_Hash_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IHashedData_INTERFACE_DEFINED__ */


#ifndef __IUtilities_INTERFACE_DEFINED__
#define __IUtilities_INTERFACE_DEFINED__

/* interface IUtilities */
/* [unique][helpstring][dual][uuid][object] */


EXTERN_C const IID IID_IUtilities;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("EB166CF6-2AE6-44DA-BD96-0C1635D183FE")
    IUtilities : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRandom(
            /* [defaultvalue][in] */ long Length,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Base64Encode(
            /* [in] */ BSTR SrcString,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Base64Decode(
            /* [in] */ BSTR EncodedString,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BinaryToHex(
            /* [in] */ BSTR BinaryString,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HexToBinary(
            /* [in] */ BSTR HexString,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BinaryStringToByteArray(
            /* [in] */ BSTR BinaryString,
            /* [retval][out] */ VARIANT *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ByteArrayToBinaryString(
            /* [in] */ VARIANT varByteArray,
            /* [retval][out] */ BSTR *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LocalTimeToUTCTime(
            /* [in] */ DATE LocalTime,
            /* [retval][out] */ DATE *pVal) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UTCTimeToLocalTime(
            /* [in] */ DATE UTCTime,
            /* [retval][out] */ DATE *pVal) = 0;

    };

#else   /* C style interface */

    typedef struct IUtilitiesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IUtilities * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IUtilities * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IUtilities * This);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )(
            IUtilities * This,
            /* [out] */ UINT *pctinfo);

        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )(
            IUtilities * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);

        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )(
            IUtilities * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )(
            IUtilities * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRandom )(
            IUtilities * This,
            /* [defaultvalue][in] */ long Length,
            /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Base64Encode )(
            IUtilities * This,
            /* [in] */ BSTR SrcString,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Base64Decode )(
            IUtilities * This,
            /* [in] */ BSTR EncodedString,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BinaryToHex )(
            IUtilities * This,
            /* [in] */ BSTR BinaryString,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HexToBinary )(
            IUtilities * This,
            /* [in] */ BSTR HexString,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BinaryStringToByteArray )(
            IUtilities * This,
            /* [in] */ BSTR BinaryString,
            /* [retval][out] */ VARIANT *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ByteArrayToBinaryString )(
            IUtilities * This,
            /* [in] */ VARIANT varByteArray,
            /* [retval][out] */ BSTR *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LocalTimeToUTCTime )(
            IUtilities * This,
            /* [in] */ DATE LocalTime,
            /* [retval][out] */ DATE *pVal);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UTCTimeToLocalTime )(
            IUtilities * This,
            /* [in] */ DATE UTCTime,
            /* [retval][out] */ DATE *pVal);

        END_INTERFACE
    } IUtilitiesVtbl;

    interface IUtilities
    {
        CONST_VTBL struct IUtilitiesVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IUtilities_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUtilities_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IUtilities_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IUtilities_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IUtilities_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IUtilities_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IUtilities_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IUtilities_GetRandom(This,Length,EncodingType,pVal) \
    (This)->lpVtbl -> GetRandom(This,Length,EncodingType,pVal)

#define IUtilities_Base64Encode(This,SrcString,pVal)    \
    (This)->lpVtbl -> Base64Encode(This,SrcString,pVal)

#define IUtilities_Base64Decode(This,EncodedString,pVal)    \
    (This)->lpVtbl -> Base64Decode(This,EncodedString,pVal)

#define IUtilities_BinaryToHex(This,BinaryString,pVal)  \
    (This)->lpVtbl -> BinaryToHex(This,BinaryString,pVal)

#define IUtilities_HexToBinary(This,HexString,pVal) \
    (This)->lpVtbl -> HexToBinary(This,HexString,pVal)

#define IUtilities_BinaryStringToByteArray(This,BinaryString,pVal)  \
    (This)->lpVtbl -> BinaryStringToByteArray(This,BinaryString,pVal)

#define IUtilities_ByteArrayToBinaryString(This,varByteArray,pVal)  \
    (This)->lpVtbl -> ByteArrayToBinaryString(This,varByteArray,pVal)

#define IUtilities_LocalTimeToUTCTime(This,LocalTime,pVal)  \
    (This)->lpVtbl -> LocalTimeToUTCTime(This,LocalTime,pVal)

#define IUtilities_UTCTimeToLocalTime(This,UTCTime,pVal)    \
    (This)->lpVtbl -> UTCTimeToLocalTime(This,UTCTime,pVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_GetRandom_Proxy(
    IUtilities * This,
    /* [defaultvalue][in] */ long Length,
    /* [defaultvalue][in] */ CAPICOM_ENCODING_TYPE EncodingType,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IUtilities_GetRandom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_Base64Encode_Proxy(
    IUtilities * This,
    /* [in] */ BSTR SrcString,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IUtilities_Base64Encode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_Base64Decode_Proxy(
    IUtilities * This,
    /* [in] */ BSTR EncodedString,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IUtilities_Base64Decode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_BinaryToHex_Proxy(
    IUtilities * This,
    /* [in] */ BSTR BinaryString,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IUtilities_BinaryToHex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_HexToBinary_Proxy(
    IUtilities * This,
    /* [in] */ BSTR HexString,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IUtilities_HexToBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_BinaryStringToByteArray_Proxy(
    IUtilities * This,
    /* [in] */ BSTR BinaryString,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IUtilities_BinaryStringToByteArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_ByteArrayToBinaryString_Proxy(
    IUtilities * This,
    /* [in] */ VARIANT varByteArray,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IUtilities_ByteArrayToBinaryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_LocalTimeToUTCTime_Proxy(
    IUtilities * This,
    /* [in] */ DATE LocalTime,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IUtilities_LocalTimeToUTCTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUtilities_UTCTimeToLocalTime_Proxy(
    IUtilities * This,
    /* [in] */ DATE UTCTime,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IUtilities_UTCTimeToLocalTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IUtilities_INTERFACE_DEFINED__ */


#ifndef __ICertContext_INTERFACE_DEFINED__
#define __ICertContext_INTERFACE_DEFINED__

/* interface ICertContext */
/* [unique][helpstring][local][uuid][object] */


EXTERN_C const IID IID_ICertContext;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("9E7D3477-4F63-423E-8A45-E13B2BB851A2")
    ICertContext : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CertContext(
            /* [retval][out] */ long *ppCertContext) = 0;

        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_CertContext(
            /* [in] */ long pCertContext) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FreeContext(
            /* [in] */ long pCertContext) = 0;

    };

#else   /* C style interface */

    typedef struct ICertContextVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertContext * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertContext * This);

        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CertContext )(
            ICertContext * This,
            /* [retval][out] */ long *ppCertContext);

        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CertContext )(
            ICertContext * This,
            /* [in] */ long pCertContext);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FreeContext )(
            ICertContext * This,
            /* [in] */ long pCertContext);

        END_INTERFACE
    } ICertContextVtbl;

    interface ICertContext
    {
        CONST_VTBL struct ICertContextVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertContext_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertContext_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ICertContext_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ICertContext_get_CertContext(This,ppCertContext)    \
    (This)->lpVtbl -> get_CertContext(This,ppCertContext)

#define ICertContext_put_CertContext(This,pCertContext) \
    (This)->lpVtbl -> put_CertContext(This,pCertContext)

#define ICertContext_FreeContext(This,pCertContext) \
    (This)->lpVtbl -> FreeContext(This,pCertContext)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICertContext_get_CertContext_Proxy(
    ICertContext * This,
    /* [retval][out] */ long *ppCertContext);


void __RPC_STUB ICertContext_get_CertContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ICertContext_put_CertContext_Proxy(
    ICertContext * This,
    /* [in] */ long pCertContext);


void __RPC_STUB ICertContext_put_CertContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICertContext_FreeContext_Proxy(
    ICertContext * This,
    /* [in] */ long pCertContext);


void __RPC_STUB ICertContext_FreeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertContext_INTERFACE_DEFINED__ */


#ifndef __IChainContext_INTERFACE_DEFINED__
#define __IChainContext_INTERFACE_DEFINED__

/* interface IChainContext */
/* [unique][helpstring][local][uuid][object] */


EXTERN_C const IID IID_IChainContext;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("B27FFB30-432E-4585-A3FD-72530108CBFD")
    IChainContext : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ChainContext(
            /* [retval][out] */ long *pChainContext) = 0;

        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ChainContext(
            /* [in] */ long pChainContext) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FreeContext(
            /* [in] */ long pChainContext) = 0;

    };

#else   /* C style interface */

    typedef struct IChainContextVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            IChainContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            IChainContext * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            IChainContext * This);

        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChainContext )(
            IChainContext * This,
            /* [retval][out] */ long *pChainContext);

        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ChainContext )(
            IChainContext * This,
            /* [in] */ long pChainContext);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FreeContext )(
            IChainContext * This,
            /* [in] */ long pChainContext);

        END_INTERFACE
    } IChainContextVtbl;

    interface IChainContext
    {
        CONST_VTBL struct IChainContextVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define IChainContext_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IChainContext_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IChainContext_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IChainContext_get_ChainContext(This,pChainContext)  \
    (This)->lpVtbl -> get_ChainContext(This,pChainContext)

#define IChainContext_put_ChainContext(This,pChainContext)  \
    (This)->lpVtbl -> put_ChainContext(This,pChainContext)

#define IChainContext_FreeContext(This,pChainContext)   \
    (This)->lpVtbl -> FreeContext(This,pChainContext)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IChainContext_get_ChainContext_Proxy(
    IChainContext * This,
    /* [retval][out] */ long *pChainContext);


void __RPC_STUB IChainContext_get_ChainContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IChainContext_put_ChainContext_Proxy(
    IChainContext * This,
    /* [in] */ long pChainContext);


void __RPC_STUB IChainContext_put_ChainContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IChainContext_FreeContext_Proxy(
    IChainContext * This,
    /* [in] */ long pChainContext);


void __RPC_STUB IChainContext_FreeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IChainContext_INTERFACE_DEFINED__ */


#ifndef __ICertStore_INTERFACE_DEFINED__
#define __ICertStore_INTERFACE_DEFINED__

/* interface ICertStore */
/* [unique][helpstring][local][uuid][object] */


EXTERN_C const IID IID_ICertStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("BB3ECB9C-A83A-445c-BDB5-EFBEF691B731")
    ICertStore : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StoreHandle(
            /* [retval][out] */ long *phCertStore) = 0;

        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_StoreHandle(
            /* [in] */ long hCertStore) = 0;

        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StoreLocation(
            /* [retval][out] */ CAPICOM_STORE_LOCATION *pStoreLocation) = 0;

        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_StoreLocation(
            /* [in] */ CAPICOM_STORE_LOCATION StoreLocation) = 0;

        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CloseHandle(
            /* [in] */ long hCertStore) = 0;

    };

#else   /* C style interface */

    typedef struct ICertStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICertStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICertStore * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICertStore * This);

        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StoreHandle )(
            ICertStore * This,
            /* [retval][out] */ long *phCertStore);

        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StoreHandle )(
            ICertStore * This,
            /* [in] */ long hCertStore);

        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StoreLocation )(
            ICertStore * This,
            /* [retval][out] */ CAPICOM_STORE_LOCATION *pStoreLocation);

        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StoreLocation )(
            ICertStore * This,
            /* [in] */ CAPICOM_STORE_LOCATION StoreLocation);

        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CloseHandle )(
            ICertStore * This,
            /* [in] */ long hCertStore);

        END_INTERFACE
    } ICertStoreVtbl;

    interface ICertStore
    {
        CONST_VTBL struct ICertStoreVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICertStore_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertStore_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define ICertStore_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define ICertStore_get_StoreHandle(This,phCertStore)    \
    (This)->lpVtbl -> get_StoreHandle(This,phCertStore)

#define ICertStore_put_StoreHandle(This,hCertStore) \
    (This)->lpVtbl -> put_StoreHandle(This,hCertStore)

#define ICertStore_get_StoreLocation(This,pStoreLocation)   \
    (This)->lpVtbl -> get_StoreLocation(This,pStoreLocation)

#define ICertStore_put_StoreLocation(This,StoreLocation)    \
    (This)->lpVtbl -> put_StoreLocation(This,StoreLocation)

#define ICertStore_CloseHandle(This,hCertStore) \
    (This)->lpVtbl -> CloseHandle(This,hCertStore)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICertStore_get_StoreHandle_Proxy(
    ICertStore * This,
    /* [retval][out] */ long *phCertStore);


void __RPC_STUB ICertStore_get_StoreHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ICertStore_put_StoreHandle_Proxy(
    ICertStore * This,
    /* [in] */ long hCertStore);


void __RPC_STUB ICertStore_put_StoreHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICertStore_get_StoreLocation_Proxy(
    ICertStore * This,
    /* [retval][out] */ CAPICOM_STORE_LOCATION *pStoreLocation);


void __RPC_STUB ICertStore_get_StoreLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ICertStore_put_StoreLocation_Proxy(
    ICertStore * This,
    /* [in] */ CAPICOM_STORE_LOCATION StoreLocation);


void __RPC_STUB ICertStore_put_StoreLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ICertStore_CloseHandle_Proxy(
    ICertStore * This,
    /* [in] */ long hCertStore);


void __RPC_STUB ICertStore_CloseHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICertStore_INTERFACE_DEFINED__ */


#ifndef __ICSigner_INTERFACE_DEFINED__
#define __ICSigner_INTERFACE_DEFINED__

/* interface ICSigner */
/* [unique][helpstring][restricted][local][uuid][object] */


EXTERN_C const IID IID_ICSigner;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("8F83F792-014C-4E22-BD57-5C381E622F34")
    ICSigner : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AdditionalStore(
            /* [retval][out] */ long *phAdditionalStore) = 0;

        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AdditionalStore(
            /* [in] */ long hAdditionalStore) = 0;

    };

#else   /* C style interface */

    typedef struct ICSignerVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICSigner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICSigner * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICSigner * This);

        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AdditionalStore )(
            ICSigner * This,
            /* [retval][out] */ long *phAdditionalStore);

        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AdditionalStore )(
            ICSigner * This,
            /* [in] */ long hAdditionalStore);

        END_INTERFACE
    } ICSignerVtbl;

    interface ICSigner
    {
        CONST_VTBL struct ICSignerVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICSigner_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICSigner_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ICSigner_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ICSigner_get_AdditionalStore(This,phAdditionalStore)    \
    (This)->lpVtbl -> get_AdditionalStore(This,phAdditionalStore)

#define ICSigner_put_AdditionalStore(This,hAdditionalStore) \
    (This)->lpVtbl -> put_AdditionalStore(This,hAdditionalStore)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ICSigner_get_AdditionalStore_Proxy(
    ICSigner * This,
    /* [retval][out] */ long *phAdditionalStore);


void __RPC_STUB ICSigner_get_AdditionalStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE ICSigner_put_AdditionalStore_Proxy(
    ICSigner * This,
    /* [in] */ long hAdditionalStore);


void __RPC_STUB ICSigner_put_AdditionalStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICSigner_INTERFACE_DEFINED__ */


#ifndef __ICCertificates_INTERFACE_DEFINED__
#define __ICCertificates_INTERFACE_DEFINED__

/* interface ICCertificates */
/* [unique][helpstring][restricted][local][uuid][object] */


EXTERN_C const IID IID_ICCertificates;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("EBDC6DC2-684D-4425-BBB7-CB4D15A088A7")
    ICCertificates : public IUnknown
    {
    public:
        virtual /* [restricted] */ HRESULT STDMETHODCALLTYPE _ExportToStore(
            /* [in] */ HCERTSTORE hCertStore) = 0;

    };

#else   /* C style interface */

    typedef struct ICCertificatesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICCertificates * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICCertificates * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICCertificates * This);

        /* [restricted] */ HRESULT ( STDMETHODCALLTYPE *_ExportToStore )(
            ICCertificates * This,
            /* [in] */ HCERTSTORE hCertStore);

        END_INTERFACE
    } ICCertificatesVtbl;

    interface ICCertificates
    {
        CONST_VTBL struct ICCertificatesVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICCertificates_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICCertificates_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define ICCertificates_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define ICCertificates__ExportToStore(This,hCertStore)  \
    (This)->lpVtbl -> _ExportToStore(This,hCertStore)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [restricted] */ HRESULT STDMETHODCALLTYPE ICCertificates__ExportToStore_Proxy(
    ICCertificates * This,
    /* [in] */ HCERTSTORE hCertStore);


void __RPC_STUB ICCertificates__ExportToStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICCertificates_INTERFACE_DEFINED__ */


#ifndef __ICPrivateKey_INTERFACE_DEFINED__
#define __ICPrivateKey_INTERFACE_DEFINED__

/* interface ICPrivateKey */
/* [unique][helpstring][restricted][local][uuid][object] */


EXTERN_C const IID IID_ICPrivateKey;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("50F241B7-A8F2-4e0a-B982-4BD7DF0CCF3C")
    ICPrivateKey : public IUnknown
    {
    public:
        virtual /* [restricted] */ HRESULT STDMETHODCALLTYPE _GetKeyProvInfo(
            /* [retval][out] */ PCRYPT_KEY_PROV_INFO *pKeyProvInfo) = 0;

    };

#else   /* C style interface */

    typedef struct ICPrivateKeyVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
            ICPrivateKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);

        ULONG ( STDMETHODCALLTYPE *AddRef )(
            ICPrivateKey * This);

        ULONG ( STDMETHODCALLTYPE *Release )(
            ICPrivateKey * This);

        /* [restricted] */ HRESULT ( STDMETHODCALLTYPE *_GetKeyProvInfo )(
            ICPrivateKey * This,
            /* [retval][out] */ PCRYPT_KEY_PROV_INFO *pKeyProvInfo);

        END_INTERFACE
    } ICPrivateKeyVtbl;

    interface ICPrivateKey
    {
        CONST_VTBL struct ICPrivateKeyVtbl *lpVtbl;
    };



#ifdef COBJMACROS


#define ICPrivateKey_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICPrivateKey_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ICPrivateKey_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ICPrivateKey__GetKeyProvInfo(This,pKeyProvInfo) \
    (This)->lpVtbl -> _GetKeyProvInfo(This,pKeyProvInfo)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [restricted] */ HRESULT STDMETHODCALLTYPE ICPrivateKey__GetKeyProvInfo_Proxy(
    ICPrivateKey * This,
    /* [retval][out] */ PCRYPT_KEY_PROV_INFO *pKeyProvInfo);


void __RPC_STUB ICPrivateKey__GetKeyProvInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ICPrivateKey_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * );
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * );
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * );
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * );

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * );
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * );
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * );
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\makecert\rootasn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rootasn.h
//
//--------------------------------------------------------------------------

0x30,0x5B,0x30,0x0D,0x06,0x09,0x2A,0x86,0x48,0x86,0xF7,0x0D,0x01,0x01,0x01,0x05,
0x00,0x03,0x4A,0x00,0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,
0xD6,0xE7,0xD9,0x66,0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,
0xB1,0xF7,0x87,0x30,0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,
0x5F,0x42,0xB6,0x9D,0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,
0x58,0x11,0xCB,0x40,0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signcode\resource.h ===
//--------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for signcode.cpp
//
//
//  History:    07-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------
//defintion for string IDS

#define			IDS_CAPITION				5993
#define			IDS_PLUS					5994
#define			IDS_NULL					5995
#define			IDS_MY						5996
#define			IDS_SPC						5997
#define			IDS_ROOT					5998
#define			IDS_CA						5999
#define			IDS_ENFLN					6000
#define			IDS_SYNTAX					6001																																																																	               
#define			IDS_OPTIONS					6002
#define			IDS_OPTION_C				6003
#define			IDS_OPTION_C_DESC			6004
#define			IDS_OPTION_S				6005
#define			IDS_OPTION_S_DESC			6006
#define			IDS_OPTION_MORE_DESC		6007
#define			IDS_OPTION_R				6008
#define			IDS_OPTION_R_DESC			6009
#define			IDS_OPTION_MORE_VALUE		6011
#define			IDS_OPTION_V				6012
#define			IDS_OPTION_V_DESC			6013
#define			IDS_OPTION_K				6014
#define			IDS_OPTION_K_DESC			6015
#define			IDS_OPTION_N				6016
#define			IDS_OPTION_N_DESC			6017
#define			IDS_OPTION_I				6018
#define			IDS_OPTION_I_DESC			6019
#define			IDS_OPTION_P				6020
#define			IDS_OPTION_P_DESC			6021
#define			IDS_OPTION_Y				6022
#define			IDS_OPTION_Y_DESC			6023
#define			IDS_OPTION_AUTH				6024
#define			IDS_OPTION_AUTH_DESC		6025
#define			IDS_OPTION_A				6026
#define			IDS_OPTION_A_DESC			6027
#define			IDS_OPTION_T				6028
#define			IDS_OPTION_T_DESC			6029
#define			IDS_OPTION_X				6030
#define			IDS_OPTION_X_DESC			6031
#define			IDS_OPTION_H				6032
#define			IDS_OPTION_TQ				6033
#define			IDS_OPTION_TS				6034
#define			IDS_SWITCH1					6035
#define			IDS_SWITCH2					6036
#define			IDS_OPTION_SPC				6037
#define			IDS_OPTION_SPC_DESC			6039
#define			IDS_OPTION_J				6040
#define			IDS_OPTION_J_DESC			6041
#define			IDS_OPTION_JP				6042
#define			IDS_OPTION_JP_DESC			6043
#define			IDS_OPTION_TW				6044
#define			IDS_OPTION_TW_DESC			6045
#define			IDS_OPTION_TR				6046
#define			IDS_OPTION_TR_DESC			6047
#define			IDS_OPTION_CN				6048
#define			IDS_OPTION_CN_DESC			6049
		
#define			IDS_A_MD5					6050
#define			IDS_A_SHA					6051
#define			IDS_R_CU					6052
#define			IDS_R_LM					6053
#define			IDS_AUTHORITY_ID			6054
#define			IDS_AUTHORITY_CM			6055
#define			IDS_AUTHORITY_DEFAULT		6056
#define			IDS_OPTION_AUTH_VALUE		6057
#define         IDS_OPTION_AUTH_VALUE1      6058
#define			IDS_OPTION_SP_DESC1			6059

											
#define			IDS_ACTION_SIGN				6060
#define			IDS_ACTION_TIMESTAMP		6061
#define			IDS_ACTION_REQUEST			6062
#define			IDS_ACTION_RESPONSE			6063
#define			IDS_ACTION_SIGNCODE			6064
	
#define			IDS_SIGNED					6071
#define			IDS_RESIGN					6072
#define			IDS_ERROR					6073
#define			IDS_SUCCEEDED				6074
#define			IDS_FAILED					6075
#define			IDS_TEST_SUCCEEDED			6076
#define			IDS_TEST_FAILED				6077
#define			IDS_WARNING					6078
#define			IDS_ERR_TOO_MANY_PARAM		6079
#define			IDS_ERR_INPUT_INVALID   	6080
#define			IDS_ERR_RESPONSE_INVALID	6081
#define			IDS_ERR_NOMATCH				6082
#define			IDS_ERR_AUTH				6083
#define			IDS_ERR_RESIZE				6084
#define			IDS_ERR_NO_SPC				6085
#define			IDS_ERR_NO_PVK				6086
#define			IDS_ERR_NO_FILE				6087
#define			IDS_ERR_ADDR_INVALID		6088
#define			IDS_ERR_HTTP				6089
#define			IDS_ERR_TIME_RESPONSE		6090
#define			IDS_ERR_SIGN_RESPONSE		6091
#define			IDS_ERR_BOTH_PVK			6092
#define			IDS_ERR_BOTH_SPC			6093
#define			IDS_ERR_NO_ALGO				6094
#define			IDS_ERR_NO_AUTH				6095
#define			IDS_HTTP					6096
#define			IDS_ERR_NO_REG				6097
#define			IDS_ERR_TOO_FEW_PARAM		6098
#define			IDS_ERR_HRPOV_FROM_CERT		6099
#define			IDS_ERR_NO_CERT_CHAIN		7000
#define			IDS_OPTION_SP				7001			
#define			IDS_OPTION_SP_DESC			7002		
#define			IDS_OPTION_SP_CHAIN			7003	
#define			IDS_OPTION_SP_SPCSTORE		7004
#define			IDS_OPTION_ADD				7005			
#define			IDS_OPTION_ADD_DESC			7006	
#define			IDS_OPTION_ADDR				7007
#define			IDS_OPTION_ADDR_DESC		7008
#define			IDS_ERR_NO_POLICY			7009
#define			IDS_TIMESTAMP_TIMES_DELAY	7010
#define			IDS_TIMESTAMP_TIMES			7011
#define			IDS_ERR_INVALID_ADDRESS		7012
#define			IDS_ERR_TS_CERT_INVALID		7013
#define			IDS_STORE_LOCATION_NAME		7014
#define			IDS_ERR_NO_CERT				7015
#define			IDS_ERR_TOO_MANY_CERT		7016
#define			IDS_ERR_NO_PROVIDER			7017
#define			IDS_ERR_NO_CHAINING			7018
#define			IDS_ERR_EXPRIED				7019
#define         IDS_OPTION_INDEX			7020
#define			IDS_OPTION_INDEX_DESC		7021 
#define			IDS_SIGNER_INDEX			7022
#define			IDS_MORE_INFO_1             7023
#define			IDS_MORE_INFO_2             7024
#define			IDS_MORE_INFO_3             7025


#define			IDS_OPTION_KY				7030
#define			IDS_OPTION_KY_DESC			7031
#define			IDS_OPTION_KY_VALUES		7032
#define			IDS_OPTION_KY_EXC			7033
#define			IDS_OPTION_KY_SIG			7034
#define			IDS_OPTION_H_DESC			7035
#define			IDS_OPTION_TQ_DESC			7036
#define			IDS_OPTION_TS_DESC			7037
#define			IDS_OPTION_TEST				7038
#define			IDS_OPTION_SHA1_DESC        7039
#define			IDS_OPTION_SHA1		        7040
#define			IDS_ERR_BOTH_CN_SHA1        7041
#define			IDS_ERR_SHA1_HASH           7042
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signtool\resource.h ===
// Resources constant definitions
// Used by SignTool.rc
//

//    0 -   99  Top level usage
//  100 -  199  Sign command usage
//  200 -  299  Verify command usage
//  300 -  399  Timestamp command usage
//  400 -  499  CatDb command usage
//  500 -  999  Reserved for other command usages

// 1000 - 1099  Top level or generic warnings, info and errors
// 1100 - 1199  Sign command parsing warnings, info and errors
// 1200 - 1299  Verify command parsing warnings, info and errors
// 1300 - 1399  Timestamp command parsing warnings, info and errors
// 1400 - 1499  CatDb command parsing warnings, info and errors
// 1500 - 1999  Reserved for other command parsing warnings, info and errors

// 2000 - 2099  Generic action warnings, info and errors
// 2100 - 2199  Sign command action warnings, info and errors
// 2200 - 2299  Verify command action warnings, info and errors
// 2300 - 2399  Timestamp command action warnings, info and errors
// 2400 - 2499  CatDb command action warnings, info and errors
// 2500 - 2999  Reserved for other command action warnings, info and errors


// Top level Usage:
#define IDS_LOCALE                      0
#define IDS_SIGNTOOL_USAGE              10

// SIGN Command Usage:
#define IDS_SIGN_USAGE                  100
#define IDS_SIGN_CERT_OPTIONS           101
#define IDS_SIGN_SIGNING_OPTIONS        102
#define IDS_SIGN_PRIV_KEY_OPTIONS       103
#define IDS_SIGN_OTHER_OPTIONS          104
#define IDS_SIGN_                       105
#define IDS_SIGN_A                      106
#define IDS_SIGN_C                      107
#define IDS_SIGN_CSP                    108
#define IDS_SIGN_D                      109
#define IDS_SIGN_DU                     110
#define IDS_SIGN_F                      111
#define IDS_SIGN_I                      112
#define IDS_SIGN_K                      113
#define IDS_SIGN_N                      114
#define IDS_SIGN_P                      115
#define IDS_SIGN_Q                      116
#define IDS_SIGN_R                      117
#define IDS_SIGN_S                      118
#define IDS_SIGN_SM                     119
#define IDS_SIGN_SHA1                   120
#define IDS_SIGN_T                      121
#define IDS_SIGN_U                      122
#define IDS_SIGN_UW                     123
#define IDS_SIGN_V                      124

// VERIFY Command Usage:
#define IDS_VERIFY_USAGE                200
#define IDS_VERIFY_CATALOG_OPTIONS      201
#define IDS_VERIFY_OTHER_OPTIONS        202
#define IDS_VERIFY_POLICY_OPTIONS       203
#define IDS_VERIFY_SIG_OPTIONS          204
#define IDS_VERIFY_A                    205
#define IDS_VERIFY_AD                   206
#define IDS_VERIFY_AS                   207
#define IDS_VERIFY_AG                   208
#define IDS_VERIFY_C                    209
#define IDS_VERIFY_O                    210
#define IDS_VERIFY_PD                   211
#define IDS_VERIFY_PG                   212
#define IDS_VERIFY_Q                    213
#define IDS_VERIFY_R                    214
#define IDS_VERIFY_TW                   215
#define IDS_VERIFY_V                    216

// TIMESTAMP Command Usage:
#define IDS_TIMESTAMP_USAGE             300
#define IDS_TIMESTAMP_Q                 301
#define IDS_TIMESTAMP_T                 302
#define IDS_TIMESTAMP_V                 303

// CATDB Command Usage:
#define IDS_CATDB_USAGE                 400
#define IDS_CATDB_DB_SELECT_OPTIONS     401
#define IDS_CATDB_OTHER_OPTIONS         402
#define IDS_CATDB_D                     403
#define IDS_CATDB_G                     404
#define IDS_CATDB_Q                     405
#define IDS_CATDB_R                     406
#define IDS_CATDB_U                     407
#define IDS_CATDB_V                     408

// SIGNWIZARD Command Usage:
#define IDS_SIGNWIZARD_USAGE            500
#define IDS_SIGNWIZARD_OPTIONS          501
#define IDS_SIGNWIZARD_Q                502
#define IDS_SIGNWIZARD_V                503


// Generic Parsing Warnings, Info and Errors
#define IDS_ERR_NO_PARAMS               1001
#define IDS_ERR_INVALID_COMMAND         1002
#define IDS_ERR_MISSING_FILENAME        1003
#define IDS_ERR_FILE_NOT_FOUND          1004
#define IDS_ERR_DUP_SWITCH              1005
#define IDS_ERR_NO_PARAM                1006
#define IDS_ERR_INVALID_SWITCH          1007
#define IDS_ERR_UNEXPECTED              1008
#define IDS_ERR_PARAM_DEPENDENCY        1009
#define IDS_ERR_PARAM_MULTI_DEP         1010
#define IDS_ERR_PARAM_INCOMPATIBLE      1011
#define IDS_ERR_PARAM_MULTI_INCOMP      1012
#define IDS_ERR_PARAM_REQUIRED          1013
#define IDS_ERR_OPENING_FILE_LIST       1014
#define IDS_ERR_INVALID_GUID            1015

// SIGN Parsing Warnings, Info and Errors
#define IDS_ERR_INVALID_SHA1            1100
#define IDS_ERR_INVALID_EKU             1101
#define IDS_ERR_EKU_LENGTH              1102
#define IDS_ERR_BAD_TIMESTAMP_URL       1103

// VERIFY Parsing Warnings, Info and Errors
#define IDS_ERR_INVALID_VERSION         1200

// TIMESTAMP Parsing Warnings, Info and Errors
// none defined
// #define IDS_ERR_blah                 1300

// CATDB Parsing Warnings, Info and Errors
// none defined
// #define IDS_ERR_blah                 1400



// Generic Action Warnings, Info and Errors
#define IDS_INFO_WARNINGS               2000
#define IDS_INFO_ERRORS                 2001
#define IDS_WARN_UNSUPPORTED            2002
#define IDS_ERR_NO_FILES_DONE           2003
#define IDS_ERR_FUNCTION                2004
#define IDS_ERR_CAPICOM_NOT_REG         2005
#define IDS_ERR_ACCESS_DENIED           2006
#define IDS_ERR_SHARING_VIOLATION       2007
#define IDS_ERR_FILE_SIZE_ZERO          2008

// SIGN Action Warnings, Info and Errors
#define IDS_INFO_SIGNED                 2100
#define IDS_INFO_CERT_SELECTED          2101
#define IDS_INFO_CERT_NAME              2102
#define IDS_INFO_CERT_ISSUER            2103
#define IDS_INFO_CERT_EXPIRE            2104
#define IDS_INFO_CERT_SHA1              2105
#define IDS_INFO_SIGN_SUCCESS           2106
#define IDS_INFO_SIGN_SUCCESS_T         2107
#define IDS_INFO_SIGN_ATTEMPT           2108
#define IDS_WARN_SIGN_NO_TIMESTAMP      2109
#define IDS_ERR_PFX_BAD_PASSWORD        2110
#define IDS_ERR_NO_CERT                 2111
#define IDS_ERR_BAD_CSP                 2112
#define IDS_ERR_CERT_NO_PRIV_KEY        2113
#define IDS_ERR_CERT_FILE               2114
#define IDS_ERR_CERT_HASH               2115
#define IDS_ERR_CERT_ISSUER             2116
#define IDS_ERR_CERT_MULTIPLE           2117
#define IDS_ERR_STORE                   2118
#define IDS_ERR_SIGN                    2119
#define IDS_ERR_SIGN_FILE_FORMAT        2120
#define IDS_ERR_PRIV_KEY_MISMATCH       2121
#define IDS_ERR_STORE_NOT_FOUND         2122
#define IDS_ERR_BAD_KEY_CONTAINER       2123
#define IDS_ERR_PRIV_KEY                2124

// VERIFY Action Warnings, Info and Errors
#define IDS_INFO_VERIFIED               2200
#define IDS_INFO_INVALIDS               2201
#define IDS_INFO_VERIFY_ATTEMPT         2202
#define IDS_INFO_VERIFY_SUCCESS         2203
#define IDS_INFO_VERIFY_CAT             2204
#define IDS_INFO_VERIFY_BADCAT          2205
#define IDS_INFO_VERIFY_SIGNER          2206
#define IDS_INFO_VERIFY_COUNTER         2207
#define IDS_INFO_VERIFY_TIMESTAMP       2208
#define IDS_INFO_VERIFY_NO_TIMESTAMP    2209
#define IDS_INFO_VERIFY_TIME            2210
#define IDS_INFO_VERIFY_CACHED_CAT      2211
#define IDS_WARN_VERIFY_NO_TS           2212
#define IDS_ERR_VERIFY                  2213
#define IDS_ERR_VERIFY_INVALID          2214
#define IDS_ERR_VERIFY_ROOT             2215
#define IDS_ERR_VERIFY_CAT_OPEN         2216
#define IDS_ERR_VERIFY_NOT_IN_CAT       2217
#define IDS_ERR_VERIFY_VERSION          2218
#define IDS_ERR_VERIFY_CUR_VERSION      2219
#define IDS_ERR_VERIFY_FILE_FORMAT      2220
#define IDS_ERR_BAD_USAGE               2221
#define IDS_ERR_TRY_OTHER_POLICY        2222
#define IDS_ERR_NOT_SIGNED              2223
#define IDS_ERR_UNTRUSTED_ROOT          2224

// TIMESTAMP Action Warnings, Info and Errors
#define IDS_INFO_TIMESTAMPED            2300
#define IDS_INFO_TIMESTAMP_ATTEMPT      2301
#define IDS_INFO_TIMESTAMP_SUCCESS      2302
#define IDS_ERR_TIMESTAMP               2303
#define IDS_ERR_TIMESTAMP_NO_SIG        2304
#define IDS_ERR_TIMESTAMP_BAD_URL       2305

// CATDB Action Warnings, Info and Errors
#define IDS_INFO_ADDING_CAT             2400
#define IDS_INFO_REMOVING_CAT           2401
#define IDS_INFO_ADDED_CAT              2402
#define IDS_INFO_ADDED_CAT_AS           2403
#define IDS_INFO_REMOVED_CAT            2404
#define IDS_INFO_CATS_ADDED             2405
#define IDS_INFO_CATS_REMOVED           2406
#define IDS_ERR_ADDING_CAT              2407
#define IDS_ERR_REMOVING_CAT            2408
#define IDS_ERR_REM_CAT_PLATFORM        2409
#define IDS_ERR_CATALOG_NAME            2410
#define IDS_ERR_CAT_NOT_FOUND           2411

// SIGNWIZARD Action Warnings, Info and Errors
#define IDS_INFO_SIGNWIZARD_ATTEMPT     2500
#define IDS_INFO_SIGNWIZARD_SUCCESS     2501
#define IDS_INFO_WIZARDSIGNED           2502
#define IDS_ERR_SIGNWIZARD              2503
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signcode\javaattr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       JavaAttr.h
//
//
//----------------------------------------------------------------------------

#ifndef _JAVA_ATTR_DLL_H
#define _JAVA_ATTR_DLL_H



#ifdef __cplusplus
extern "C" {
#endif

//+-----------------------------------------------------------------------
//  
//  InitAttr:
//
//		This function should be called as the first call to the dll.
//
//		The dll has to use the input memory allocation and free routine
//		to allocate and free all memories, including internal use.
//      It has to handle when pInitString==NULL.
//
//------------------------------------------------------------------------

HRESULT WINAPI  
InitAttr(LPWSTR			pInitString); //IN: the init string
	
typedef HRESULT (*pInitAttr)(LPWSTR	pInitString);

 //+-----------------------------------------------------------------------
//  
//  GetAttrs:
//
//
//		Return authenticated and unauthenticated attributes.  
//
//      *ppsAuthenticated and *ppsUnauthenticated should never be NULL.
//      If there is no attribute, *ppsAuthenticated->cAttr==0.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
GetAttr(PCRYPT_ATTRIBUTES  *ppsAuthenticated,		// OUT: Authenticated attributes added to signature
        PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	// OUT: Uunauthenticated attributes added to signature
	
typedef HRESULT (*pGetAttr)(PCRYPT_ATTRIBUTES  *ppsAuthenticated,		
							PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	


 //+-----------------------------------------------------------------------
//  
//  GetAttrsEx:
//
//
//		Return authenticated and unauthenticated attributes.  
//
//      *ppsAuthenticated and *ppsUnauthenticated should never be NULL.
//      If there is no attribute, *ppsAuthenticated->cAttr==0.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
GetAttrEx(  DWORD               dwFlags,                //In:   Reserved.  Set to 0.
            LPWSTR              pwszFileName,           //In:   The file name to sign
            LPWSTR			    pInitString,            //In:   The init string, same as the input parameter to InitAttr
            PCRYPT_ATTRIBUTES  *ppsAuthenticated,		// OUT: Authenticated attributes added to signature
            PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	// OUT: Uunauthenticated attributes added to signature
	
typedef HRESULT (*pGetAttrEx)(DWORD                 dwFlags,
                              LPWSTR                pwszFileName,
                              LPWSTR			    pInitString,
                              PCRYPT_ATTRIBUTES     *ppsAuthenticated,		
							  PCRYPT_ATTRIBUTES     *ppsUnauthenticated);	



//+-----------------------------------------------------------------------
//  
//  ReleaseAttrs:
//
//
//		Release authenticated and unauthenticated attributes
//		returned from GetAttr(). 
//
//      psAuthenticated and psUnauthenticated should never be NULL.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
ReleaseAttr(PCRYPT_ATTRIBUTES  psAuthenticated,		// OUT: Authenticated attributes to be released
			PCRYPT_ATTRIBUTES  psUnauthenticated);	// OUT: Uunauthenticated attributes to be released
	
typedef HRESULT (*pReleaseAttr)(PCRYPT_ATTRIBUTES  psAuthenticated,		
								PCRYPT_ATTRIBUTES  psUnauthenticated);	


//+-----------------------------------------------------------------------
//  
//  ExitAttr:
//
//		This function should be called as the last call to the dll
//------------------------------------------------------------------------
HRESULT	WINAPI
ExitAttr( );	

typedef HRESULT (*pExitAttr)();



#ifdef __cplusplus
}
#endif

#endif  //#define _JAVA_ATTR_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\makectl\makectl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       makectl.cpp
//
//  Contents:   Make a CTL
//
//              See Usage() for list of options.
//
//
//  Functions:  wmain
//
//  History:    17-June-97   xiaohs   created
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <unicode.h>
#include <wchar.h>

#include "wincrypt.h"
#include "mssip.h"
#include "softpub.h"
#include "resource.h"
#include "toolutl.h"
#include "cryptui.h"    //the UI version of the tool

//--------------------------------------------------------------------------
//
// Global Data
//
//----------------------------------------------------------------------------

HMODULE         hModule=NULL;

BYTE            **g_rgpHash=NULL;
DWORD           *g_rgcbHash=NULL;
DWORD           g_dwCount=0;
DWORD           g_dwMsgAndCertEncodingType=CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING;
DWORD           g_dwCertEncodingType=CRYPT_ASN_ENCODING;

//---------------------------------------------------------------------------
//   Get the hModule hanlder and init two DLLMain.
//
//---------------------------------------------------------------------------
BOOL    InitModule()
{
    if(!(hModule=GetModuleHandle(NULL)))
       return FALSE;

    return TRUE;
}

static void Usage(void)
{
    IDSwprintf(hModule, IDS_SYNTAX);
    IDSwprintf(hModule, IDS_SYNTAX1);
    IDSwprintf(hModule, IDS_OPTIONS);
    IDSwprintf(hModule, IDS_OPTION_U_DESC);
    IDSwprintf(hModule, IDS_OPTION_U_DESC1);
    IDSwprintf(hModule, IDS_OPTION_U_DESC2);
    IDSwprintf(hModule,IDS_OPTION_S_DESC);
    IDSwprintf(hModule,IDS_OPTION_R_DESC);
    IDS_IDS_IDS_IDSwprintf(hModule,IDS_OPTION_MORE_VALUE,IDS_R_CU,IDS_R_LM,IDS_R_CU);

}


//----------------------------------------------------------------------------
//
//Build the CTL_INFO struct and encode/sign it with no signer info
//----------------------------------------------------------------------------
HRESULT BuildAndEncodeCTL(DWORD dwMsgEncodingType, LPSTR szOid, DWORD dwCount, BYTE **rgpHash,
                  DWORD *rgcbHash, BYTE     **ppbEncodedCTL,    DWORD   *pcbEncodedCTL)
{
    HRESULT                 hr=E_FAIL;
    CMSG_SIGNED_ENCODE_INFO sSignInfo;
    CTL_INFO                CTLInfo;
    DWORD                   dwIndex=0;

    if(dwCount==0 || !rgpHash || !ppbEncodedCTL || !pcbEncodedCTL)
        return E_INVALIDARG;

    //init
    *ppbEncodedCTL=NULL;
    *pcbEncodedCTL=0;

    memset(&sSignInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    sSignInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

    memset(&CTLInfo, 0, sizeof(CTL_INFO));

    //set up CTL
    CTLInfo.dwVersion=CTL_V1;
    CTLInfo.SubjectUsage.cUsageIdentifier = 1;
    CTLInfo.SubjectUsage.rgpszUsageIdentifier = (LPSTR *)&szOid;
    GetSystemTimeAsFileTime(&(CTLInfo.ThisUpdate));
    CTLInfo.SubjectAlgorithm.pszObjId=szOID_OIWSEC_sha1;

    CTLInfo.cCTLEntry=dwCount;
    CTLInfo.rgCTLEntry=(CTL_ENTRY *)ToolUtlAlloc(sizeof(CTL_ENTRY)*dwCount);
    if(!(CTLInfo.rgCTLEntry))
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //memset
    memset(CTLInfo.rgCTLEntry, 0, sizeof(CTL_ENTRY)*dwCount);

    for(dwIndex=0; dwIndex<dwCount; dwIndex++)
    {
        CTLInfo.rgCTLEntry[dwIndex].SubjectIdentifier.cbData=rgcbHash[dwIndex];
        CTLInfo.rgCTLEntry[dwIndex].SubjectIdentifier.pbData=rgpHash[dwIndex];
    }


    //encode and sign the CTL
    if(!CryptMsgEncodeAndSignCTL(dwMsgEncodingType,
                                    &CTLInfo,
                                    &sSignInfo,
                                    0,
                                    NULL,
                                    pcbEncodedCTL))
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUP;
    }

    //memory allocation
    *ppbEncodedCTL=(BYTE *)ToolUtlAlloc(*pcbEncodedCTL);

    if(!(*ppbEncodedCTL))
    {
        hr=E_OUTOFMEMORY;
        goto CLEANUP;
    }

    if(!CryptMsgEncodeAndSignCTL(dwMsgEncodingType,
                                    &CTLInfo,
                                    &sSignInfo,
                                    0,
                                    *ppbEncodedCTL,
                                    pcbEncodedCTL))
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        goto CLEANUP;
    }


    hr=S_OK;

CLEANUP:

    if(hr!=S_OK)
    {
        if(*ppbEncodedCTL)
        {
            ToolUtlFree(*ppbEncodedCTL);
            *ppbEncodedCTL=NULL;
        }

        *pcbEncodedCTL=0;
    }

    if(CTLInfo.rgCTLEntry)
        ToolUtlFree(CTLInfo.rgCTLEntry);

    return hr;

}


//----------------------------------------------------------------------------
//
//Get the hash of the certificates from the store
//----------------------------------------------------------------------------
HRESULT GetCertFromStore(LPWSTR wszStoreName, BOOL  fSystemStore, DWORD dwStoreFlag)
{
    HCERTSTORE      hStore=NULL;
    HRESULT         hr=E_FAIL;
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pCertPre=NULL;
    BYTE            *pbData=NULL;
    DWORD           cbData=0;
    void            *p = NULL;

    //open the store
    if(fSystemStore)
    {
        hStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                    g_dwMsgAndCertEncodingType,
                    NULL,
                    dwStoreFlag | CERT_STORE_READONLY_FLAG,
                    wszStoreName);


    }
    else
    {
        //Serialized Store, PKCS#7, Encoded Cert
        hStore=CertOpenStore(CERT_STORE_PROV_FILENAME_W,
                         g_dwMsgAndCertEncodingType,
                         NULL,
                         0,
                         wszStoreName);
    }

    if(!hStore)
    {
        hr=GetLastError();
        IDSwprintf(hModule, IDS_ERR_OPEN_STORE);
        goto CLEANUP;
    }

    //now, we need to enum all the certs in the store
    while(pCertContext=CertEnumCertificatesInStore(hStore, pCertPre))
    {

        //get the SHA1 hash of the certificate
        if(!CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID,NULL,&cbData))
        {
            hr=GetLastError();
            IDSwprintf(hModule, IDS_ERR_HASH);
            goto CLEANUP;
        }

        pbData=(BYTE *)ToolUtlAlloc(cbData);
        if(!pbData)
        {
            hr=E_OUTOFMEMORY;
            IDSwprintf(hModule, IDS_ERR_MEMORY);
            goto CLEANUP;
        }

        //get the SHA1 hash of the certificate
        if(!CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID,pbData,&cbData))
        {
            hr=GetLastError();
            IDSwprintf(hModule, IDS_ERR_HASH);
            ToolUtlFree(pbData);
            goto CLEANUP;
        }


        //add to our global list
        g_dwCount++;

        //re-alloc memory
        p = (void *)g_rgpHash;
        #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
        g_rgpHash=(BYTE **)realloc(g_rgpHash, sizeof(BYTE *)*g_dwCount);
        if(!g_rgpHash)
        {
            g_rgpHash = (BYTE **)p;
            hr=E_OUTOFMEMORY;
            IDSwprintf(hModule, IDS_ERR_HASH);
            ToolUtlFree(pbData);
            goto CLEANUP;
        }

        p = (void *)g_rgcbHash;
        #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
        g_rgcbHash=(DWORD *)realloc(g_rgcbHash, sizeof(DWORD)*g_dwCount);
        if(!g_rgcbHash)
        {
            g_rgcbHash = (DWORD *)p;
            hr=E_OUTOFMEMORY;
            IDSwprintf(hModule, IDS_ERR_HASH);
            ToolUtlFree(pbData);
            goto CLEANUP;
        }

        g_rgpHash[g_dwCount-1]=pbData;
        g_rgcbHash[g_dwCount-1]=cbData;

        pCertPre=pCertContext;
    }

    hr=S_OK;

CLEANUP:

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    if(hStore)
        CertCloseStore(hStore, 0);

    return hr;

}
extern "C" int __cdecl wmain(int argc, WCHAR *wargv[])
{
    int             ReturnStatus=-1;
    HRESULT         hr=E_FAIL;
    LPWSTR          pwszOutputFilename=NULL;
    DWORD           dwIndex=0;
    LPSTR           szOid=szOID_PKIX_KP_CODE_SIGNING;
    BOOL            fAllocated=FALSE;
    LPWSTR          pwszOption=NULL;

    BYTE            *pbEncodedCTL=NULL;
    DWORD           cbEncodedCTL=0;
    WCHAR           wszSwitch1[10];
    WCHAR           wszSwitch2[10];

    BOOL            fSystemstore=FALSE;
    LPWSTR          wszStoreLocation=NULL;
    DWORD           dwStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;


    //we call the UI version of the makectl if no parameters are passed into
    //the command line
    if(1==argc)
    {
        //build the CTL file without signing process
        //call the wizard which provides feedback
        if(CryptUIWizBuildCTL(CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL))
            return 0;
        else
            return -1;
    }

    if(argc<3)
    {
        Usage();
        return ReturnStatus;
    }

    if(!InitModule())
        goto ErrorReturn;


    //process the stores one at a time
    for (dwIndex=1; dwIndex<(DWORD)(argc-1); dwIndex++)
    {

        //see if this is the options
        if(IDSwcsnicmp(hModule, wargv[dwIndex], IDS_SWITCH1, 1)==0 ||
           IDSwcsnicmp(hModule, wargv[dwIndex], IDS_SWITCH2, 1)==0)
        {
            pwszOption=wargv[dwIndex];

            //get the OIDs
            if(IDSwcsicmp(hModule, &(pwszOption[1]),IDS_OPTION_U)==0)
            {
                dwIndex++;

                if(dwIndex >= (DWORD)((argc-1)))
                {
                    IDSwprintf(hModule,IDS_TOO_FEW_PARAM);
                    goto ErrorReturn;
                }

                if(!fAllocated)
                {
                    if(S_OK != WSZtoSZ(wargv[dwIndex], &szOid))
                        goto ErrorReturn;

                    fAllocated=TRUE;
                }
                else
                {
                    IDSwprintf(hModule,IDS_TOO_MANY_PARAM);
                    goto ErrorReturn;

                }

            }
            //check for -s options
            else if(IDSwcsicmp(hModule, &(pwszOption[1]),IDS_OPTION_S)==0)
            {
                fSystemstore=TRUE;
            }
            //check for -r options
            else if(IDSwcsicmp(hModule, &(pwszOption[1]),IDS_OPTION_R)==0)
            {
                dwIndex++;

                if(dwIndex >= (DWORD)((argc-1)))
                {
                    IDSwprintf(hModule,IDS_TOO_FEW_PARAM);
                    goto ErrorReturn;
                }

                if(NULL==wszStoreLocation)
                {
                    wszStoreLocation=wargv[dwIndex];

                    if(IDSwcsicmp(hModule, wszStoreLocation, IDS_R_CU)==0)
                        dwStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
                    else
                    {
                        if(IDSwcsicmp(hModule,wszStoreLocation, IDS_R_LM)==0)
                            dwStoreFlag=CERT_SYSTEM_STORE_LOCAL_MACHINE;
                        else
                        {
                            IDSwprintf(hModule, IDS_INVALID_R);
                            goto ErrorReturn;
                        }
                    }

                }
                else
                {
                    IDSwprintf(hModule,IDS_TOO_MANY_PARAM);
                    goto ErrorReturn;

                }

            }
            else
            {

                //print out the Usage
                Usage();
                return ReturnStatus;
            }
        }
        else
        {
            //build the cert hash from the store
            if(S_OK !=(hr=GetCertFromStore(wargv[dwIndex], fSystemstore, dwStoreFlag)))
                goto ErrorReturn;

            //int for the next cycle
            fSystemstore=FALSE;
            wszStoreLocation=NULL;
            dwStoreFlag=CERT_SYSTEM_STORE_CURRENT_USER;
            hr=E_FAIL;
        }

    }

    if(0==g_dwCount)
    {
        IDSwprintf(hModule, IDS_TOO_FEW_PARAM);
        hr=E_FAIL;
        goto ErrorReturn;
    }

    //set up the CTL_INFO structure
    if(S_OK!=(hr=BuildAndEncodeCTL(g_dwMsgAndCertEncodingType, szOid, g_dwCount, g_rgpHash, g_rgcbHash, &pbEncodedCTL,
            &cbEncodedCTL)))
    {
        IDSwprintf(hModule, IDS_ERR_ENCODE_CTL);
        goto ErrorReturn;
    }

    //get the output file name
    pwszOutputFilename = wargv[argc-1];
    if(S_OK!=(hr=OpenAndWriteToFile(pwszOutputFilename, pbEncodedCTL, cbEncodedCTL)))
    {
        IDSwprintf(hModule, IDS_ERR_SAVE_CTL);
        goto ErrorReturn;
    }

    //mark succeed
    ReturnStatus = 0;
    hr=S_OK;
    IDSwprintf(hModule, IDS_SUCCEEDED);
    goto CommonReturn;



ErrorReturn:
    ReturnStatus = -1;
    //print out an error msg
    IDSwprintf(hModule, IDS_FAILED,hr,hr);


CommonReturn:
    if(g_rgpHash)
    {
        for(dwIndex=0; dwIndex<g_dwCount; dwIndex++)
            ToolUtlFree(g_rgpHash[dwIndex]);

        ToolUtlFree(g_rgpHash);
    }

    if(fAllocated)
        ToolUtlFree(szOid);

    if(g_rgcbHash)
        ToolUtlFree(g_rgcbHash);


    if(pbEncodedCTL)
        ToolUtlFree(pbEncodedCTL);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\toolutl\toolutl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       toolutl
//
//  Contents:   Tools Unitilies Header
//
//----------------------------------------------------------------------------

#ifndef TOOLUTL_H
#define TOOLUTL_H

#ifdef __cplusplus
extern "C" {
#endif
 
//--------------------------------------------------------------------------
//
//  Memory routines
//--------------------------------------------------------------------------
void *ToolUtlAlloc(IN size_t cbBytes, HMODULE hModule=NULL, int idsString=0);

void ToolUtlFree(IN void *pv);


//--------------------------------------------------------------------------
//
//  string routines
//--------------------------------------------------------------------------
int IDSwcsnicmp(HMODULE hModule, WCHAR *pwsz, int idsString, DWORD dwCount);

int IDSwcsicmp(HMODULE hModule, WCHAR *pwsz, int idsString);


HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz);

//-------------------------------------------------------------------------
//
//	The private version of wprintf.  Input is an ID for a stirng resource
//  and the output is the standard output of wprintf.
//
//-------------------------------------------------------------------------
void IDSwprintf(HMODULE hModule, int idsString, ...);

void IDS_IDSwprintf(HMODULE hModule, int idString, int idStringTwo);

void IDS_IDS_DW_DWwprintf(HMODULE hModule, int idString, int idStringTwo, DWORD dwOne, DWORD dwTwo);

void IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3);

void IDS_DW_IDS_IDSwprintf(HMODULE hModule, int ids1,DWORD dw,int ids2,int ids3);

void IDS_IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3, int ids4);



//--------------------------------------------------------------------------------
//
// file routines
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb);

HRESULT OpenAndWriteToFile(LPCWSTR  pwszFileName,PBYTE   pb, DWORD   cb);

void	GetFileName(LPWSTR	pwszPath, LPWSTR  *ppwszName);


//--------------------------------------------------------------------------------
//
// compose and decompose the certificate property
//
//---------------------------------------------------------------------------------
HRESULT	ComposePvkString(	CRYPT_KEY_PROV_INFO *pKeyProvInfo,
							LPWSTR				*ppwszPvkString,
							DWORD				*pcwchar);


#ifdef __cplusplus
}
#endif

#endif  // TOOLUTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\toolutl\toolutl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       toolutl.cpp
//
//  Contents:   Utilities for the tools
//
//  History:    17-Jun-97    xiaohs    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <wchar.h>
#include <stdarg.h>
#include "unicode.h"
#include "toolutl.h"

#define MAX_STRING_RSC_SIZE 512

WCHAR	wszBuffer[MAX_STRING_RSC_SIZE];
DWORD	dwBufferSize=sizeof(wszBuffer)/sizeof(wszBuffer[0]); 

WCHAR	wszBuffer2[MAX_STRING_RSC_SIZE];
WCHAR	wszBuffer3[MAX_STRING_RSC_SIZE];


//+-------------------------------------------------------------------------
//  Allocation and free routines
//--------------------------------------------------------------------------
void *ToolUtlAlloc(IN size_t cbBytes, HMODULE hModule, int idsString)
{
	void *pv=NULL;

	pv=malloc(cbBytes);

	//out put error message
	if((pv==NULL) && (hModule!=NULL) && (idsString!=0))
	{
	   IDSwprintf(hModule, idsString);
	}

	return pv;
}


void ToolUtlFree(IN void *pv)
{
	if(pv)
		free(pv);
}


//--------------------------------------------------------------------------
//
//  Output routines
//--------------------------------------------------------------------------
//---------------------------------------------------------------------------
// The private version of _wcsnicmp
//----------------------------------------------------------------------------
int IDSwcsnicmp(HMODULE hModule, WCHAR *pwsz, int idsString, DWORD dwCount)
{
	assert(pwsz);

	//load the string
	if(!LoadStringU(hModule, idsString, wszBuffer, dwBufferSize))
		return -1;

	return _wcsnicmp(pwsz, wszBuffer,dwCount);
}


//---------------------------------------------------------------------------
// The private version of _wcsicmp
//----------------------------------------------------------------------------
int IDSwcsicmp(HMODULE hModule, WCHAR *pwsz, int idsString)
{
	assert(pwsz);

	//load the string
	if(!LoadStringU(hModule, idsString, wszBuffer, dwBufferSize))
		return -1;

	return _wcsicmp(pwsz, wszBuffer);
}

//-------------------------------------------------------------------------
//
//	The private version of wprintf.  Input is an ID for a stirng resource
//  and the output is the standard output of wprintf.
//
//-------------------------------------------------------------------------
void IDSwprintf(HMODULE hModule, int idsString, ...)
{
	va_list	vaPointer;

	va_start(vaPointer, idsString);

	//load the string
	LoadStringU(hModule, idsString, wszBuffer, dwBufferSize);

	vwprintf(wszBuffer,vaPointer);

	return;
}	




void IDS_IDSwprintf(HMODULE hModule, int idString, int idStringTwo)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	//print buffer2 on top of buffer1
	wprintf(wszBuffer,wszBuffer2);

	return;
}


void IDS_IDS_DW_DWwprintf(HMODULE hModule, int idString, int idStringTwo, DWORD dwOne, DWORD dwTwo)
{
	//load the string
	LoadStringU(hModule, idString, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, idStringTwo, wszBuffer2, dwBufferSize);

	//print buffer2 on top of buffer1
	wprintf(wszBuffer,wszBuffer2,dwOne, dwTwo);

	return;
}


void IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3)
{


	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize); 

	wprintf(wszBuffer,wszBuffer2,wszBuffer3);

	return;
}

void IDS_DW_IDS_IDSwprintf(HMODULE hModule, int ids1,DWORD dw,int ids2,int ids3)
{


	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize); 

	wprintf(wszBuffer,dw,wszBuffer2,wszBuffer3,dw);

	return;
}

void IDS_IDS_IDS_IDSwprintf(HMODULE hModule, int ids1,int ids2,int ids3, int ids4)
{
	
   WCHAR	wszBuffer4[MAX_STRING_RSC_SIZE];

	//load the string
	LoadStringU(hModule, ids1, wszBuffer, dwBufferSize);

	//load the string two
	LoadStringU(hModule, ids2, wszBuffer2, dwBufferSize); 

	//load the string three
   	LoadStringU(hModule, ids3, wszBuffer3, dwBufferSize);
	
	//load the string four
   	LoadStringU(hModule, ids4, wszBuffer4, dwBufferSize); 


	wprintf(wszBuffer,wszBuffer2,wszBuffer3,wszBuffer4);

	return;
}

///////////////////////////////////////////////////////////////
//
//	Convert WSZ to SZ
//
//
HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz)
{

	DWORD	cbSize=0;

	assert(psz);
	*psz=NULL;

	if(!wsz)
		return S_OK;

	cbSize=WideCharToMultiByte(0,0,wsz,-1,
			NULL,0,0,0);

	if(cbSize==0)
	   	return HRESULT_FROM_WIN32(GetLastError());


	*psz=(LPSTR)ToolUtlAlloc(cbSize);

	if(*psz==NULL)
		return E_OUTOFMEMORY;

	if(WideCharToMultiByte(0,0,wsz,-1,
			*psz,cbSize,0,0))
	{
		return S_OK;
	}
	else
	{
		 ToolUtlFree(*psz);
		 return HRESULT_FROM_WIN32(GetLastError());
	}
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{


	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;  
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;
	DWORD	cbHighSize=0;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if ((hFile = CreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
        
    if((cbData = GetFileSize(hFile, &cbHighSize)) == 0xffffffff)
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	//we do not handle file more than 4G bytes
	if(cbHighSize != 0)
	{
			hr=E_FAIL;
			goto CLEANUP;
	}
    
    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,             
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }
 
    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,  
		FILE_MAP_READ,     
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;
}


//+-------------------------------------------------------------------------
//  Write a blob to a file
//--------------------------------------------------------------------------
HRESULT OpenAndWriteToFile(
    LPCWSTR  pwszFileName,
    PBYTE   pb,
    DWORD   cb
    )
{
    HRESULT		hr=E_FAIL;
    HANDLE		hFile=NULL;
	DWORD		dwBytesWritten=0;

	if(!pwszFileName || !pb || (cb==0))
	   return E_INVALIDARG;

    hFile = CreateFileU(pwszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile	  

    if (INVALID_HANDLE_VALUE == hFile)
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
	}  
	else 
	{

        if (!WriteFile(
                hFile,
                pb,
                cb,
                &dwBytesWritten,
                NULL            // lpOverlapped
                ))
		{
			hr=HRESULT_FROM_WIN32(GetLastError());
		}
		else
		{

			if(dwBytesWritten != cb)
				hr=E_FAIL;
			else
				hr=S_OK;
		}

        CloseHandle(hFile);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//	Get an absolutely name from the path, such as "c:\public\mydoc\doc.doc." 
//	This function will return doc.doc 
//
//----------------------------------------------------------------------------
void	GetFileName(LPWSTR	pwszPath, LPWSTR  *ppwszName)
{
	DWORD	dwLength=0;

	assert(pwszPath);
	assert(ppwszName);

	(*ppwszName)=pwszPath;

	if(0==(dwLength=wcslen(pwszPath)))
		return;

	(*ppwszName)=pwszPath+dwLength-1;

	for(; dwLength>0; dwLength--)
	{
		if((**ppwszName)=='\\')
			break;

		(*ppwszName)--;
	}

	(*ppwszName)++;

}


//----------------------------------------------------------------------------
//
//	Compose the private key file structure:
//	"pvkFileName"\0"keysepc"\0"provtype"\0"provname"\0\0
//
//----------------------------------------------------------------------------
HRESULT	ComposePvkString(	CRYPT_KEY_PROV_INFO *pKeyProvInfo,
							LPWSTR				*ppwszPvkString,
							DWORD				*pcwchar)
{

		HRESULT		hr=S_OK;
		DWORD		cwchar=0;
		LPWSTR		pwszAddr=0;
		WCHAR		wszKeySpec[12];
		WCHAR		wszProvType[12];

		assert(pKeyProvInfo);
		assert(ppwszPvkString);
		assert(pcwchar);

		//convert dwKeySpec and dwProvType to wchar
		swprintf(wszKeySpec, L"%lu", pKeyProvInfo->dwKeySpec);
		swprintf(wszProvType, L"%lu", pKeyProvInfo->dwProvType);

		//count of the number of characters we need
		cwchar=(pKeyProvInfo->pwszProvName) ? 
			(wcslen(pKeyProvInfo->pwszProvName)+1) : 1;

		//add the ContainerName + two DWORDs
		cwchar += wcslen(pKeyProvInfo->pwszContainerName)+1+
				  wcslen(wszKeySpec)+1+wcslen(wszProvType)+1+1;

		*ppwszPvkString=(LPWSTR)ToolUtlAlloc(cwchar * sizeof(WCHAR));
		if(!(*ppwszPvkString))
			return E_OUTOFMEMORY;

		//copy the private key file name .  
		wcscpy((*ppwszPvkString), pKeyProvInfo->pwszContainerName);

		pwszAddr=(*ppwszPvkString)+wcslen(*ppwszPvkString)+1;

		//copy the key spec
		wcscpy(pwszAddr, wszKeySpec);
		pwszAddr=pwszAddr+wcslen(wszKeySpec)+1;

		//copy the provider type
		wcscpy(pwszAddr, wszProvType);
		pwszAddr=pwszAddr+wcslen(wszProvType)+1;

		//copy the provider name
		if(pKeyProvInfo->pwszProvName)
		{
			wcscpy(pwszAddr, pKeyProvInfo->pwszProvName);
			pwszAddr=pwszAddr+wcslen(pKeyProvInfo->pwszProvName)+1;
		}
		else
		{
			*pwszAddr=L'\0';
			pwszAddr++;
		}

		//NULL terminate the string
		*pwszAddr=L'\0';

		*pcwchar=cwchar;

		return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\toolutl\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//  Contents:   Resource header for toolutl
//
//  History:    17-Jun-97    xiaohs    Created
//
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signtool\signtooldebug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       signtooldebug.h
//
//  Contents:   The SignTool console tool debug functions
//
//  History:    4/30/2001   SCoyne    Created
//
//----------------------------------------------------------------------------


void PrintInputInfo(INPUTINFO *InputInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signtool\signtool.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       signtool.h
//
//  Contents:   The SignTool console tool
//
//  History:    4/30/2001   SCoyne    Created
//
//----------------------------------------------------------------------------



#define MAX_RES_LEN 2048


// Type definitions:
enum COMMAND
    {
    CommandNone=0,
    CatDb,
    Sign,
    SignWizard,
    Timestamp,
    Verify,
    };

enum CATDBSELECT
    {
    NoCatDb=0,
    FullAutoCatDb,
    SystemCatDb,
    DefaultCatDb,
    GuidCatDb
    };

enum POLICY_CHOICE
    {
    SystemDriver=0,
    DefaultAuthenticode,
    GuidActionID
    };

enum CATDB_COMMAND
    {
    UpdateCat=0,
    AddUniqueCat,
    RemoveCat
    };


typedef struct _InputInfo {
    COMMAND         Command;
    WCHAR           **rgwszFileNames;
    DWORD           NumFiles;
    CATDBSELECT     CatDbSelect;
    GUID            PolicyGuid;
    GUID            CatDbGuid;
    CATDB_COMMAND   CatDbCommand;
    CRYPT_HASH_BLOB SHA1;
    BOOL            OpenMachineStore;
    POLICY_CHOICE   Policy;
    BOOL            Quiet;
    BOOL            TSWarn;
    BOOL            Verbose;
    BOOL            HelpRequest;
    BOOL            fIsWow64Process;
    DWORD           dwPlatform;
    DWORD           dwMajorVersion;
    DWORD           dwMinorVersion;
    DWORD           dwBuildNumber;
    WCHAR           *wszCatFile;
    WCHAR           *wszCertFile;
    WCHAR           *wszContainerName;
    WCHAR           *wszCSP;
    WCHAR           *wszDescription;
    WCHAR           *wszDescURL;
    WCHAR           *wszEKU;
    #ifdef SIGNTOOL_LIST
    WCHAR           *wszListFileName;
    WCHAR           *wszListFileContents;
    #endif
    WCHAR           *wszIssuerName;
    WCHAR           *wszPassword;
    WCHAR           *wszRootName;
    WCHAR           *wszStoreName;
    WCHAR           *wszSubjectName;
    WCHAR           *wszTemplateName;
    WCHAR           *wszTimeStampURL;
    WCHAR           *wszVersion;
    } INPUTINFO;


// Function prototypes:
void PrintUsage(INPUTINFO *InputInfo);
BOOL ParseInputs(int argc, WCHAR **targv, INPUTINFO *InputInfo);
int  SignTool_CatDb(INPUTINFO *InputInfo);
int  SignTool_Sign(INPUTINFO *InputInfo);
int  SignTool_SignWizard(INPUTINFO *InputInfo);
int  SignTool_Timestamp(INPUTINFO *InputInfo);
int  SignTool_Verify(INPUTINFO *InputInfo);

// Error Functions:
#ifdef SIGNTOOL_DEBUG
#define ResErr if (gDebug) wprintf(L"%hs (%u):\n", __FILE__, __LINE__); Res_Err
#define ResFormatErr if (gDebug) wprintf(L"%hs (%u):\n", __FILE__, __LINE__); ResFormat_Err
#define FormatErrRet if (gDebug) wprintf(L"%hs (%u):\n", __FILE__, __LINE__); Format_ErrRet
#else
#define ResErr Res_Err
#define ResFormatErr ResFormat_Err
#define FormatErrRet Format_ErrRet
#endif
void ResOut(DWORD dwRes);
void Res_Err(DWORD dwRes);
void ResFormatOut(DWORD dwRes, ...);
void ResFormat_Err(DWORD dwRes, ...);
void Format_ErrRet(WCHAR *wszFunc, DWORD dwErr);

// Helper Functions:
BOOL GUIDFromWStr(GUID *guid, LPWSTR str);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pkisign\tools\signtool\signtoolactions.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       signtoolactions.cpp
//
//  Contents:   The SignTool console tool action functions
//
//  History:    4/30/2001   SCoyne    Created
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef __cplusplus
} // Matches ex